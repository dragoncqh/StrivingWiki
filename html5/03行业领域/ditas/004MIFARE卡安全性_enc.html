<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b51c4d519f52bf1690a1f1a90e00462629805cbf6886b0d069bd3a3c4ec90b71e6c6da0adc2032cbe0f9fe6ecd03615dd4a50f5306848f381e7deb936551060074dcf9c790c92d4a568e19bde1bc4f29ff4696da455b425ea2df68d7f4866542221bf2e3685c97eecc344daba1f2cfeebff124167e649105c8de2a0563f8b642fb230ff137602ce3c7c6cd9e8af11008ebbc59c2ea3927cefadcfb0113d60a34c09c737a51f8c5742941b93e4e24c5fdc1a128a5be5d1960e2fb6fad341237d2c01cf41b3614bb84d3d4da1c2d4b2b0ff6cc80885c9427b316270e4270320c20715043b8122e0e2b887ee21bdc8ae68842ce2b98d3e213de9b02c3f2de00336b24fca5b57778724cf2d344aa34e4101029089080611b3339b75ec3525f6787ef825b21942a272151bbabfa8221da6bfa508e74f57438e66ed17fcfec087b7e481283b7b20a205498164364d60e28a8964f685c9bfce90852dbe6390830db2cb0823bb4b3647331a2c1c51da383ba799ffba27b6f9e2283848c2920804d296b8dac4b1eeb5d886d7a33c0432a514da83f5e466e4b160d74baf42ba66ea90953923066841271b121c0328a10a6b05643838b4e652ebd35f3be7a291557a5886c14ce9677647d826ddddf1155a78045cf10c2d7ea949be0e44992c5602a15be2d80f284c71375d8695f041ba86cc5383e95b40d13158ed71d2fbbfc426dc4c2dc1d357f7db3a039f2a4717647c06f79681a3e4a930a2b5ed7c743aee3885b7e95fd0d8c8dd5a8303913b2a9a1160e452946dade5546f1ab94591a7951fffdbb4db57f031ae2cc4db547e40e955af692d0b008d82db5357b61ed064a151826bec36ba712d3fd5b6b7ec198d28f46dd947f647556d999fbc9e6d74a80b540ba1ae105bb5b7f591cf355885edeed0be969c81fdabd70d748ab5ae2dde1b3510ceee74e72ac76b2ae1f359a15a0655c6ed687af5bc8b81d63e62b4a75796c4c01af2edb22ba4b6996f2d49e42a5afcb9edfb00155616c6f470b2cd78d49953aca3365b32391a2d998ff23dc404d3f9ca18fd5572109380b080332f64a9fe6ced4be3cd7b2eb5796bfa275460b5c3d460df62cf4b97b8ae7981026c85961c638e8ac7336db3bad967add1d6abbbfd145728ad1e949dac048643b97d63893b9aa307725e15435ab5cc3fd1d0333730b0cbd32d54f2ca7532756435043eb89c2fe5cc92a2751f0d72dab1ca39c1eb457080d6fa1b032154b7a50362203b44ea4e3c84ce00c56f7e00a234db366b50ee8e2fbebc287e6c5dc175585ee87a84f76773243aba8a5025b22a7f2ce14adc2385c4da8b622ebe3d8fafcf1f14a23667795f988cc0516115685561b9667e889710f2a9510aee3f9c082058049d009c6840e54d73af5ac03c513714af98c45453796fcb0ab3a2bb6391cf71929907107693a63807eb4687a8ade52476026346324344d57096678aec7390472f21163a493534dd83f0e3b0584776e22a6b2073db333ad81dbb126b6eadfeec88d4728692619f3a7cf90705cc12aa64a9ee53a43b2b7f16777eb186b9d397847259507249aa872f8a3505afda0f08c2b5f76c55b79bf4260645eccee6c486341df53609ed323da7002f6ba20da9728cda5a05e40d6d2fd4a2b99feb6b13825011c2f81bef6ca8caf651c7f2322e86248e1f7040bd324322b8cb298358b52c6d8262cf4766d6520f2ad46761f07b53e8cc16a5fabcebb6c91bdec0603471570d11a89d87a8dc8059212feeb4d42ceba595293b421ca2442c154ee8fddd0cc9761538bba861fc6e34d37e795419653768a64824321510b73944a00fcc22c696f10e7b38d3df01ac85efda75f1cfa7304a6d5bd11930396e325cf612aec37bf8aa98055919924d119a3a57920f907e54152c2331e3a635ba83923b1942eb9d3707a5a276c73143e943b7d83086d14176e3562c499773bd9ec2f0ba369b2461d0cac6935b5f1629d7164f431ab8e3076587e69e4d0afd407df2d52b05d1b8f688c7942235fb8494c666c8a1280abcad08dbef2a5f0087e08537e8fbd6b3e269d2bfe6678511e9e739c8c4cbcb33b85e3d7f2bda2531c21bb7acdb7b683eeb4babb3650c03a7858629b42f5254d54359245eb6ff89c65ed02ff7f8e80f78bc272bb17cecf38779571a4a0cd25e72d50fedef34f7fe443a61ebaa30266285b163d0cf08ec0dd33601ac681546f8cd40c5c80c18611fcda6b66852dfea2c5a5ea590ef4eb49beaf140282b3e635aede48ffbb408a85c226861e08ba3ebd28094482593a8ab639b4c9f8d0e48f8a1d4c9fe65690a0c830de8f63c3a05e19dd346b5f82d8c1740733cda512ee04714b00db7a9308200caa32064ae8db63e6726c84e240d53645c4ab39cc36e49f076af62f623676728b12b95687d79abbb2f6f3ab81667c05a663bf565ab23dc4857b08254942752018897a3b26ab46adb9b1eb4f0fc988f9b9be73f3b4b22ed4222239d550854595df611dc0fefb6ee8325134851563b5ed3c26bd3b9664d60f8941fc6a5c6f58cb3dd64fc4d8e0702e895ca30dd630be4dc8ec127c7fb8cbac8af7cfe7a2f932e92ba674ec14d73592e8f66740897fc76177093dad49f7f44582bc299e75be3df8505ce5956f2d7b07a6e6dda39b5ab735bf80cfca0330ce5b9f05e92b9dcaf14ad444919ab78dc63083a4cd56daeceece1a8823f95a18507a38f77b3125ee7e65c297db415982c5da6d722bec49647d8c71f006a3252fb3562ddca4372b8d4f232b33c488f7166ad8fb84f9cae581da773a8e25249b409887141c37b68e28978bfbb2f9a9f5c0afa88646e856197226984ee9dcb5f6d8fa930715638a93d90f788fd6455a86a796c27d0fde69f1c0c8d41321c890f5f633404103e57d36c90daa05647041fa15cba61f0feebca7ae2e8cc5ce8c97d239d393d3ca8f7c911688eaa82bad2e46f05c4a11c35aecd9bf115151e42a5223ba8727b2d485847a713af4fc8bc924ee628c8dfce111e9ec6cfe176943e8c5b19f443f4952e16c37fab41f941f2d04181cbfa2e12b2e650b4e8c91a1916d43ab3aca59b24d1a3b683f7b42890076603d4f3d17c7d3caeb7252a742e6e62a5026be847796e46fad7ad7ff808a3600beab759688c8b80f4054a0dc1dd35fa6130d2ee6bbe273dc2c08f8d78a60f3ed063cc7cd08c823b76dc600393e757c2f2eec7b6fc3da7774e3c509ce4ee8828fdfc423733cc946a7941fc0951099d9ed9d813281ea6baf3119ba8e25943d581b2c81e55c5b8e965ccc795aa5420ebaf9c36865686d5300b918c3fcbc04930c99fe69468ab33840475b2256eb74b2c6de84bc917f3c70bb78502f68c573c088f1df1375eb0f9d803d87e30cd184a54a298fb97d19b8a01219a7db3d113883965b338d4be4e0f9bcde7049c283c7b6a1dc9b921dba122c61cfea387b1703bf85a0916c7bde3111bdc6dabf3e983c4e8647e397a562b100654a3fe83f3c29c4383238f64e59bcf6026f9e56e9cfdd0563b7c86fcbe63a6954e033403eeb02dbf618f634f30ee3645fcabe3b51638dc2596963ac4d226dce8fc7397f17090ac8876f91178b101b92ac90e0f5b4100abad0b555e989abf51dca08ba2f1794162ed97906dc53be47250c593378ea424ee60ed0ad15b912fe42fd871cd6eae1fc56f5dfb15327d2c69097cb2bb91366c97a2bcd0813564c415b4c74f02c0ca5ef03d8b9f089bb40bb70d73bae3e83d0b52fa7c9594ea19b6feffa3a1993407b7726e338e87f6818f3649befa01458999fe47514005eb5eca9bf5b5633f7534bc00e51c62e2815477bf2f72b96d5048dc157c9b0929097a78fd9ff28ac4e9d010d109106c630a056ad4270e27354e40f9740ab6bc8b3dbf485b6143e2be27610b0f329cf77d81cb63ecb2f2954ba5f41a274562c6bea1deb9ed344e8da74daf111e9a47bf0c195272b088e3ef03eb0830f10ddc813594b01e06b2d39c9e4d69011d8ea1df18390d4087c3159810dd428dc3fa7f40cb8e8aee11fe8cb856b3b9b0e1f9188d8aa10f4070175b3d01714cca81248bd390c9f58d53ed41f5345b8e4d61694a72b73328887522150ea065ad820ce3e62a2c57fdad0e00862e33c43ed7f84ccb0c3ba33614e0115ebb456b3b26e198ce3f9ce5e51196f4e9aa2ef508aafaea7e21c49df3fae47c28325b9e268d0c82cfda9507c5617b6a50e603092711b2dc8f003cf88b7a104920260b2f7e23ee770fe3232490c085298135e8463de58bf8483d3708facfde5e2501ed218c9e07c6e399696653e47afba042f972e15baff23a9a826a030e5cdbfa1b404bfae0bf03f1f723538cce1b6ea2a5de79ffe9f9a6c9180f9febe8f202a41bbf669b6ef47b1f9b241af6c8da6be8882f65db417fba376e2cbd60573b54e04f8d648f957094b9e6371bb5cb9b6052b0a2e3c1b6d0ea0da9f6aa3ef9bf413a6a23b851ef1939e1374950e0c6e3ad323510d0a3a6240adbc7a1e7c00792df1a0766261394da9f072e124897e4d82204a47d0f93c0df00c9fd2f750a27867d8d6bf61db578203e8cf18ed9c385cdecdbfe0095a7daa698a84eac00ac0581484a85256acdcb974cac80eaf489fae2490255f0db6a35bb416b33a669e7b1c5cbf58efde74667e24f422f2a46656d8dd524afc4ec6c777999b26a53af10079e25560b9284cb733878fa3e1fa1894aed8b6a63b29f0dac6e8bb045916567c7a84f10557ec22140234035c48f9b4440982114ab1c043a9d8e985135205ac8eea586994cf770721535908d87eda6d29cedc8d9a3888bb0c256379f437fba5c01318d9c1e9dc7e638f62d9fed281307e0a85209c1edc3a008d281ea74cb01cf4e27247d879986c9a0f7dc9599ddc97eb5065caacc60a8ab2f1d83c77c841ceee7e6b884a79b2276106341533961a6750c71009afb0fd35884d187c9e4ac6b68946629753b4c3bfb04e5638371fb7a7419a223f5af6856fc70b146866b765754b1571ecf4fb34d47ab3f00446607077f0477ec22f21728015010f63656ca7742d09b68526b479420b52583de4cd54435b4252013aac9c956dda934f49959d8837bfee12bd1257c4ce39f31f31a72b334954bce1870d51f2aac2852bba1e901696f09856bef4c391946381089add6a5893ee9a71bf81b4ba208d31da88e35b96894e32b0fc2f8a3495ae11294e91b326ea6cde4cb28aa273e19fbeea5971ed59479821af7e8a056540020e736e59c72b3c334e4e68dd93c8a73f899b120c2126c410721aa8e06f362f6644589272ca1fdf9acecfcefb8a48f8cd86995507fcff6047084d2a34745934cf80438372f23046cf1824f97d5ca19a369b552a33fc0536dc72bbe12eb3920181fee3a3c80b92b5486a07245c396e63433302029ee28213fc0d618ebc6e9c61cd8ec1f704ec9540360b48a92a47765e5fcec72a555f2a274420cfa6f08f52fb87b1099da58cec3bb267bdaf557459d200784cf8dceeeae9c564286ab3b71d90d68f96a9e868e82e4026dc8dd552fb9ed1c1e15e4804b35d49d6409e9635bbb99257dc3972216e54a22c2bc274e9a8b7683b00a7e36320a26e247a3e5c4cf2619431659047da244315a7823bddb9e895baac8412a030715b57ac1d2523948752fa20f24424cdba46ccd1b5e384fffea29fe0a772dd57c6a30f81410b1160de3944a3173a0a48493045ae7f295c1e51a0d4c1fc0f7063a10129d5e38d535d87c5419cda048497105160579e88b8de00196827e005ea813b7743d17e29d5cbeb746e101b4e69341ec8db5ad1ff7320e154eae9e6355f8a99ec5c86bee2501d9a1d7c5a750d0bb1d9ad8b4193026a07d884a54ee228f8e51bf3c880affd704c3da3da09b6ee7785aada7f90f5c5661a7654ce93189e69061294e2932475b4c5b01fbdfafd9917fed795e706831c145f9f391a3fd778772ca8a16b55c2cf919a163b50d1e6dd71a85691c423f4a6d9a4678c0235ed7519ab24b81cc45f42abe48a4a207e1a2cb5afc829f329268a012093e6e712ccaec0a5777359b2d4cc9aed3f8b553563378699a35870542bfb068fc3c12574bf7747ca53ab39cac6a80aa31b90624a7b27349a7d3d2f63394a57e5f59536b700cc85cb13380729273c65418331a0e950bfdb69c4f8e3ee0b593feb5b16e4a7179ff85a1527eafc104748577217713471ddee6039a9d3151aa25f2375c476d9c587bf5d43060a34172ec9f121f30e80debd9e0d74fe3dad63d66476df021f0819952f9f260bd107c8374d727cbdb8dd2100d537151c6b5083f9a49bff4931a73e84569426bdd6c5fdc25419c8ba9422aa46eb14da1f3e55a289e52acb829ee9977e11000109d36e42d83bcdb3f92186641082fecf61fb50e7f15778935778b245f12e3cdf5c19aa3373c22c9ae9665552127e6037c7c4725227fe7ad43fd1ecf7dd7b6d877f86d9a240ccd62c241fe31dc2b9acfcdfde5d2754dfae5a03e4a8e4f243c72759dd9daaa5a7d8569b33568ad31d1991e8c9e4dd9859414c91b513bac9a529d2e634f0998e73621794659dd2f700c25166c1777ba8b0261bb510de9e8d4cc33bfaa373da769ab97facd5eb5a2d15380986136e01440e4d852dc2d4365e365e4f6b32f72a8d3dbe6196668832425b5ab53632d86981a74c1063b33858b363be27493614c627e3796bc49442c40c9f233f3ce50d187a720e8e09a09fa7b8d2ec3b1b40869e83f4d37eeb1955534d6e3abe473a3258c03434dd29034d2ca8e26058ce816516784bb7d3214d38c76e6fd9f1b9f31fb9a2f09f24574475587a6baa85627050bc96d3db6bfbaede8257a3d1068ba0d3e9c69a24053bd757491cf26b2a5e69d90048bf3a05616678d62faee1728e6112707adb7a7002731bf11c61a66ad897f6537237eb7792769586dfe3a659b8ef130f02c6d9e09e27dd76e60b64d1fb5e6ae2b67174bb947ba445c0ecbf195d6f633af56a6fe2c16638a7a8982d9c10f9c3949047e9d1c44970ea3f7a73436f652de0bb2486bc1c6405e64731aff5766d246f8c5e2d16735d123adeb1ba55e5d435571deb68ecdce52e8aa6bb539083de5b7cf25aed7110ca93ba565ecfd516fbca5624299f1c7b8b014408c82335d7b56fbfb5fa6bd09b50710b23b151f42012e5b9cb37bc1818b98f090dfcb850de7849f8e9d35838448618a656b89098551a6f677dee44e9bf735af35b30dfadaa5fd8476d9afed6d5030e3b0053dab6e66a86096bf1095269cce0d3630f36c3b229b7a45a6ace7d4e7bb7bf68a3345bd8eb75fbc424a2fbe6fa10407aa9ec7a29020124adbfb77f7c1fc8531c0b806f6dd682b11a0d7a8b245eaed07d6a51f13769ae51786f8f4829ab656b5d33333eab0ab3c814e894bbbb65ba17a5d958fafd4674aeb88e6cd3d8371b746f7643d43068fa4602986b8e3b8a905a893dba77e5b2ddc44dfac8aac99cf9fbe8313bb5e594eee6d95fd4974de4cff732d16836575a7566af809f9ff73771f4506c1302867122abfff5f00a0ab9e9ab5a704d518689cf1cb6d0f0fe8f93871ca93eb0b14eb96e5fc0890c86c97c3cb09a4a1b0f2559b0dc48421fd0751ea146bb2abdd557073361654a3e1c152cae483b712bb577521047a58e683d3c6204a0d3af55b7ea54f96c0516efef06f92d578a912605ea5608f01f4ffeb8d41a10c01e3a18d0479dae694e387a02eda987f57dcc6535ce0341e2bb8115a300ae659741b4cbf41affa1249731f99d60d60c62a5a701d2a9a861907f12c3e5bf7e1614b811c364fb2629aaff644295fcd965144689791be68ec34b5dfabacc727b135c02967cf631664599a6f160ce5e21514756b7dc8d9d2dd80a922b82a4ea40c3fb1cf000c2152ae90c17e39d64bba42c7d8e26ae748dafc713e10ded3a4d0cbf7498e6869d17fa9277018c60f7b59be8e2b57cb52aaf7ac7b48bc000cc04ec98f79234618de54232e885fd5631dd6c037d2b307f463fc7ea30d35bda407f8792ae22c0eae9b4fe0e8e0207ca094bbfd47f1a4739702311d68782dacb39634d13ce5b9329c4c3382167777021cd28d4c036e4ed6b851bae8f1bd75c6122eb1f6117e1fb8ea4d51361ba3a9748e2234a03711e9683b8a02365e9c8211d868bad72229ebf954887e1d881bb6b3064f2dc3494cd5e3067c53513a56edaca50609cb595cf82bbc0e4f74a84fa0ecb54757373ec59d185d5da886a70aaa9a7d3bd221009e5297b49c820265e6bc5c8b1f80333a5a7fe2df784f70dd8b1b01c74bff484536c52b362d57fe95b8619d938ea8bb28bb02ce50b06d491909096577f1563c14de82d712e7e9a26f87175d9ed7524290a35c70cd9827b77833738d14eb55a7053798e3acc8f34c7eebcbb571da9c3028ab21c8bc9bd22d1fc8356284c79ad22b387deebe1dfc38bcdd4a18285659540f5d0648301a0797d34b6d94f5eaebd693fffba3e123ffb507523b72d786ee283461f7185965851a5bfd6213ca642c2a0dec5fb731e65ada4a2238cbf8a19cfdaabe44a084e45bf50c9d5ebe31ec3c9a15f8ca87d9fcc8088a2ae4e3933075ee3e2df15448fc5d22b2887d6cea4bf7e746e84eb8444af6cbda11065f17993bf21dc194ecfbfa2202f00cba092222b5a4287e1c36a759c337a3d957ecefd6e9c75e5fd7b90b0b682d95d4f07ba809b9f37a7d69d7080fabd4db87a66e36a4b523706bb84879064044afa88936fe74013125e9096faf4e3bee3c888906295835b472c7208685aa85eed61151e91b84bcf53630c26877014f66b468cf6282a02bf7c7246dfc16ef0ab1aa10538eacd8214da2bc92be741381f3df803bd647b8fa1985f478d29c17999d3419d93c7b8aa09216d57bd912b80a3426a5bc4eb178e22cc3b7517895be2a55160e4d3649735b921073804c2fd116c5ca069fdaecc24216ccdbc6ef4062db99389c5477760f6b2297af71be9069b04d3a51e7339381e7066fa626d314b9d292444505b14738336b135cd2fe751f659c0f51411197de41940e441a7df8d199af57d78b0b0f0858aaf65b8378381fa5422dcac16f7bc77194b01da0c20a1b346eb68c10a0a91a81bd49c529ade49907c4cdfbd1c3991c547ef18b4532ea00b025bf6a43f9bbe8193bb5a06c3b7e99faeb869c841b748b0477f487885881208a5d6803552b1787796a93d6514a1058e261d8246c27f2413d04e9f18ad506beea50e1c3c479f26de9ffb737c39b5a11b17b6e482ed7f76327112f04b42bec594f1af0158998ee01bff2cfe366a2b96bd423c0845a1927c30cd97dce3c68c6e0a39a59f8fa245995fca00b92d18f65356ad0d1960bbb48afec734e1e4e77102cc76239035a176ad6729cb1984950aff967db2afd7e97b6ea9aa82f36eaefbefa227b739d6255aa2e88683d608deec5334cd9486d8ff7178ddc8b6c22793c7118b4b404ece145ddeebcab93f8393f78e603aec3bc48501ba12f3b7044e373e16e89d86852bd446bf85bce9534082469cc13fb9d2b0147aaa3e632a885fddb837f82d78b318a0056925f626ea1656c203fc1b1f065ef992abe0674231f3db8dc852ba3b88739b469c3a252cad3f389c7650eeb270812714d0b37a0ff8f73b9dcdb8dabbb1267c6097e884a149622c11b0c00c7a61335fab5d97ac1b09a609c5cce088fcb9648abb6655b75bed6e74f443fdca01fad1620fc95f98466afd36ffeecff3770f68bf43e0891f71a40da1706d916b5a30337c351753e3fbdb700775b2187f938fc021dcacc95a259a8bd1c7f6334b09c54559f2032ec3c79991d868497c9565e36d1766197d0629ae2b1ee9c10f5f55e25d692290b9c7c959294308cd5662e7ba70aaa0a43a4f027d1536f5d55ce01dcdbbe108ad04c3f1753cf20253974a9fd70d835672c596c616901c272576ae5800c40ac4513686f20f1b6073e86d6c7b85eeb2fcd289c1943e4541129d5775b3b09560e83690443b23e55aa60ad7ed807b060bed2d4c676c9f40fc850db852365f78e55a6b8d08c39057c1d52932ff4265fb3925b369dec292365878e1819cbc35b5e45c3c22f8aba269da92337164006e55f830efb2f4e2ad7ccbb78b13a43ed9d06a2f94e13f9db130d87f823c35c1c96b06ee09dbfa89d3fe0ced957e514d97f95169332d5182a100401eb21e722e3c69fe416803c3fbd6c4ad2885e50fea879503e4111fef483e15f42b4c6ff16cdcfd7568e597b72f92d5125de5120971abf930697b83dacf7a7c8c3d3c254fbafa6c01b0b792845d2c2b2d046e7146fc7c4214c29042110d98acf53b6a7e54f5a3795ac29a387a4d0925ae00fd2729b84b6241c4eb605aa24387ac1de432b1ef1c190196864f5a438bf915aac57f085f4ce145178dc727aac71b2e01bb2219700452dc1420e32930cdf2324626d1093404b837e285e0d499c2c5c2435150cc5e82ba9110b6646db2a5507f8b257a95428fd57e2e83e163e5e2a2197610237cd9d4c363b58073e0b9f766a75304799f41b0a17108e0a340ade0ad3ab18c25c055e774c7e587b774d749f29bab45ac7e85d2fad64817d44a8b21be2ba1d1ad822b61999966d4518f05147d1d97ffec474b80c43f0169dc401ac590b78ece3bd6f3773bfaa8d3437c4d84cd93c49f14a804a19d98b809f92c756f965308e1502a188e2a182bb706744fbe218e1d0c7432c142da76f2ae455bb5cb085b26b9b14ff1bdaab39355efef95be37bd5511eb043355e9662e7fecd71ff42ad4173f287b86b3885c6f1733c9ffcc0b8f8fc1ca9524f1a391a4ec1bf01c862f950ace4b6988b2badffc35b9864b8cf73fb80788a46eb8754aba55724cee70116544fbf122ecf4a65cc8b9463f55bf032846fd74c27f556d43b6bb0b3587b4ad7faae1c765469284154f3625fbc3727d2e667ba9c675579102a006217a3872e0ada39695c775aeeb2c664621e3238773d4a74eda5649930e2cc1557938ca850ee3afdff58876a09a0e43f1d2c1e886650b292cd2619abc74ff1850d035347e2c2979ff82b5733305a645aefc0e23f56b10ba13870b6ae0224146a098488b1e65f34c0cf5a40e04158303395fa2c946e81caa7cf6a067d74e36d3fb599d29bbec094727049fefe7772ebca02d6c03d39fa368f786862553fdab6553725926d1b767047ee383194f7914ae44c4c67cc4ec93982f0b5e4b257707e87d3c7a0ad24e0ed614da2d2c7a717a02eb388dd1509eab5342cafe72d0dce27ea6962e1f89b6097392d61b6367be9a719757f759e912707abfb7fb00987fbc8b3db31e027f7bba7194a8cef10c67a8b15d2cf295cca5dc2c5eebbabf2a8b267fd62cbb34829eb28c1c66465ac1a34f1ceb2343dbf4594c2cf103941d6fa95f11f24acfa31599892c83343c4e4851398b3e9d50999c09c6318ba1578064f4705a87d08a31637af83749d6fe54591e1126ca286a4b7afddec868a6eb45a0b957557f8716d51f5f21f6348e1c8c5bc43a762342e6e5af5892a5edefbd798dd8f0f4cc3ef5e61c1778ced10d941bd825b5a699c8d803009bc33061de0f1501f10376020b754c2aad23c990a47271e39065add853c5bb92f83f7bc67d8b76a09cc113f13c32c211d0838431fdc2e3c96221fad2b9301f7cf39ad6541d7719b7d6a1fae9ba7712a3987eb12eca3a89f0c3dcfbb5e4aadd2bcccfb13d15f7bd038a28b38e9d20e79440f3859655f348eaef6b50d463fde8b556688c25014bdc6aaa03c6102a213e6ce14ecf21363494a206bebfa0b13925c852023340fd8cebe6b723e2bec57c830eb0d94b8bf5c79cda766df4aa60fcac424c79c90428ab190f2eb22e56c10cd9c46f17506d9c24fee5104707abefe3fc626344a52be0d1cedc1fd23fb4414d3e4f277ad875d8b4e3221b74448dcbd76acaed5d85343fea690dfb2c3476f9030ac7d52ef0f1e60a6ea8ce9c955f48c72aab6e5f7f454f7f8fbdd11c56b0e76b116077ad855bc2de8a737c7a55e4d8e2075bbf060428147c23e19c7f509120fddaae4f8d23ed720b19ff8c6f2b9958f8043e8ffabbe724e72166dc8209f5d23453ccae0ce9a5230e5298e52d7761c27ee850d3f5637282297d1e6969d454970d87a471e21b722ac450ae9415cae391b8eef2b754eee10c2cc3e7650a43f1d49c23f251c9e858fb80d75a7eed835cfaaf94235244a6b59bc334df4ac90e517dea855e099b3af618bdf3158eb4c9861aa33e80227ce4af9b3da7cfe62de4ab7a39a33938d611b5af9de957d5bd3ec612eca3447443641af7c3ac67d5b63267cb0e7bf89319a1124f7896bb5819e7a75516248859b953cc74bf92c9cbb9ed0182fa60594736c352eaf303e53fd5d9089e367f68a7a3163ab7807c5d3a53aa8acffd8a1f754b52a2f1f1e365995c9f9550759a01ba40cc5d9ca29729b526c8bd4107e906163a27763a8c31c238040e50f6c0eaa1ab0611e2f741b01d04d510e6fb9a87c50a668c7bf9ebd3a54c3f55e6be05144873292168ba0f7d4293429841b320b22e63e5bf81896fdd65ab50990749c6650be51081cecc88025f6c3ba739f82a854f29f1576bc82d0c1b644c5c0addff9144c6b6c0936cb6263b81f20449ff968e005e26f5c4488ed39f56345be73223b496647f93ba97d50e2b93a14ee8bf76b158ed5dd798e57f8aaff16811f210ec97a10e6208ecfad34ad5e5ab7d785eef5107094329658e6d7fc0e0c0b296311c16255d1fa863442f422e19337a398989bf85dc4138f4fd2fbcbac1a919f18310f53fe178fb92dd5e810f4097a6b6e459f7bbfe3cceed722d687a8a9da124dc511267929137f2a5cbe44acebdfe94bcc230ec2e2832d99783d188df5a1c201f79b24cce12b7bd74be039b8cc094f4e3f117f4e6b4e86f8922adad0ad38765a8ded7e307861d0793a2dfb8d0a11d2cd0996b962da0ecccb857d3f3ff3f222b3d9ef13981bdaa0c2c71567adc20689c43da94da56e04ee2193b583bcc33442a32e34fb50fb8e5941c298174928ac3eb4623380fff01b6cca40aea06fa154a62f99791b7e427a419ae3d85b25e38a90ed04e79f989cdc39aed7adfe37f985e1c3eaede2942806201d641b2f52cead0b8f20f8e00aab12bdd3b57b0450ae7f42e66388bbb104e52ffa4aa6b47ff08c5c94eb499ea9a904f367acd692e8bbb85e5735c9be98c9f37e7fc4600db8c3e308495dc2f7722af46ff1fc669b537985f919ee5ee77ff42dcd7479aa11c299ab9b35ada6f93f6151ce3405d64eed021f6e04849e8489cea31d3ce2a0d8daada06c3c5d66b8f8a844eced46bd22a876f5dbbbfcd5a225293cf265e23be46451e83e7b71b8366ed1a15948533d1d5876f69aadc09ea0dc09d829cea2daa725e7c123b0edfea6590c81fa7408cef2000b24a6d5eb6377def0c23dff4afaf377ecdb2deb56acc4604f356804d3952f649354f453306015c284fd321aabf3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
