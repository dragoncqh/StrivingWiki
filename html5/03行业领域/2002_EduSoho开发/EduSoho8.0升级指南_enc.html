<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d4a083507646901415490d1239518c3d177f882771ba96c47042b1bfd1163ccde84ec54c8c900d36b7ddd258e11ef5d5e9b2672aeb60820b3934722a16feee9a99638657d77551f21b92416aeddca06984bcb67d060f2a3ee0acf242e9c123e1d8f511adffcc91287827cc7ad1ca5e8f08d62cd18bd792e3d17a84221f544be9e9c36ffd661771526e9ae417a3bf441f830e9a44e8c914edcb0a680b59803a72dee285705d5d1469b187630b724cf5e5aef74846a4e8369979e29c333bd4e53f44dbc2ae030470147dc6141c0154b146ebf2766b6d41565cb2ddd52a14517dcb4ad7e4613455c566db5aa8e82cd2c004ceedc170404d399966b2b3d39806e793000d81d8d4757888373002a1c414a1c25eb3aa9c5deba3f3c29dc790391396eac556c45f9c9c27e1fb788587a99ccd5b27c4a1d2ca74dd78b1fca76527abbfc352539787e56c1857ffc9f29e8fa48c0cab608bb84936baa377ae891d015908c48f49f092379becb766696efe2d3c54d9b08420df859d06768c21e030fefc1f57d4da9b5e220ea63a23fbdcba08f816921a60f208355585ae460ac7370d157e07d8387c9f5ede9be2d4df69a15bd090b5e7aa99e9c5b0a128dc707e623d02ae5f7ce081b703891655decf15c61cd519cda9f8828b0266ce4c79f184ede40059b01abe603ee22f679e6475c5fb9027e61f42b60550d2d72ba6ec87e0ab2aa97aea07a2fb3ab23b04725cc41794cac98377eae43c6b57aceefb6513d9cb1fd37b93197f0bac3e27783ea991869b8839437d344c5d17a89a30ca5ef9bb17e36f38df787df514bc30c5dcf9067aaefff66ae1c725ed2a68c55fcd28097ba73f4da5b96a23db1140789fc038421b37e254f1f71417633989bfde3e1e84d43c71d87b285d31291e30c934f681d89d20ae6dcf9b4fd761008842915ac20b4632720154ff8b530e1a43b9114d474a704bc13588757007fd39c2689a4a358cfe36be257558b3d59ac31afb0b2e5183a11a21b653fb63ff986b86922a592a3e0d92d1e944393ab2c808d7210885c2a5739e38b6345b0a4f9ac48d74edb6554417285b99646633dc29daa1d35eeef011ed08f82239ee630a6bc2cae4eb2751932681e175ea684e6bd8636987dc8453bb07e158e95dd564ef179c3acdfadc47f34f1a0368e58bb05907f20bcf676a8ba78ab3fc7ecd320ed3812f13560e3471670dfbca78a1288c5f8514c78b3df52a8bf8bd535ea5604f4790641772494007b7b81396e0758d759ccf57922499d947a2ddda274ad7f10b00c53aa5e00acdc81c331f706f0c7b18dbb30afa714adc747a138819cf49eca8d22d2c9a38982b88977deee39153b1c3c2d28e72a563128bdfa21896d7bebe7a91449517bf1a53baab24c701bad2f8bd1d476b44f789a0cb0b6f13da57a94ee77878e197aaed5c1972b52e4c62a00507b277748f65f95b585b0ba714f6611c9b6b8ed0475fceb5740a87f6505374fa235fed03ebf43058bdf1c39991240c71eae0383c4f3eae19557e08e29e724ea7b05046c919c5a4aa1e3818a1eb2d62a8fe1c78fbff313eeb54ad84553ac64bd7bac2f56d6d4224abd2192d155f81404d54d746ba4b264d5a46e7905aa29ef2a460497cc6b7d03b2e1d7f366a21f51066391f58f45a80a90349c08be2531069218d36314d8d9a44d7813aaa7f285ef1c95444edf0014f672ce6bb1ec872a890dad5867ffc1ac94ac65aaa2376ea50c0f444698ebfbf37762b2124462df1a00fd7209c318ba3aa6808e1f15242dd64d2d43e13570a52de75601b88a79b82e6bc80a4b160bce8ec2f3f83e7411decc723766a746635b146c7f0527ee348f2d8d4eba6d8bdea036efc2331f153b9a39e8c9694d43e89df8a12fb0b4c5756cff2329737947c247ee3c80568a9741f7f54b9a1eb043518ccf0748447102cd30e9629b3a6dc68f534574e2459b096bf3e23b2565b3996d8057619608a13bceb89e939daf32831d9004955ca39c6a91540aa451c2c0617e725917a64ee063dc6622cb103fa6d8994dafca6fed0e3574e9ad448d75a68e70fab459393a48b12f1c20f961bb5ec51f3c7befec0e728d2435ae5e94f44133b0093ce5178b9a6f24a8a6a14c3dd0153f36895c4aea2090543bba617f8d9258056ef1fc6470c71b2357b34faa22da425077c7df8d295ea3c552d735103ca86eebdcf2dc7719b6087a0bf7feaf60a90f60334d1ea30f134cf706de087e07c08da9638f3fff1d3006e427095fb605102764791045a8755462778c816ee1a32493465b42e9a8c1cb8da5c348b65c6756714130a6cf06c142e496515eb2e4180eb3263838abfbc77d2744cca53c2a82918602aad2c53f8e5d1abadb09b081acca12541dbfe21fe64f6475f7feacca0d89768c42f12483b616d7c40eed6b4d254ef83fc3722eb6ec1c337d11d2c671c8efdbde7e10b0060127c7b28860a8775c5d35735ead7ce26f67d47a105a8767c1308f53d06005dcade769517903b96a22b7984f493e1a6f85c04e926c4093cc8ef37fac5d85905ea19719885cc53e49b6b5a1fecc723f8144fc6f26b1cef0343eef829fc620ff7b9b3ece22803f8693d3732045ea2f7517d696f0bf7a294416b1150cc2d148c00ebcccb4160e5d8eba8ff60d5765cf61c7f3ce80c63ea482ca4302824e0bca7f9a15607a27954ea69fdbb7183b0e7ce1fc471b574fc5df85738b210712ceb784529fba78505df299486ee04b129f7f507e90deb6ce65728f383b1068b4ab5fcc9ff7627127beeef1dacb6bd46d10cc1123769779533169dbbb197a2ae9e442c68b3eff2805f585bc517b694e1202469e6b16b671e8342f3d23cf9e88a1a213967c395fb6ee0bb5cac9a35b84e7f4f2a3298af665bb7e8af9a6ab0f64ae6a00ba6db1eef7fdc7fc4ac92deb135e636364018aaf7c82e0dab7eb1e8499de6023fd12a23f29cc1077b5c1c412e924e37e6ecd4a535b6053ed9af0dc6049a8c5138fe7dfbdbc78edc2b6893af27c761be1eb4b21d15533881425c8c3e0e2df9861bd457299ddd0e280b1cd31efbe00bd6117e4ffdb8436ea52c1d18bddabd230c3926400e25f071fe0cbd4efc194c33abd1b22da033c5f1aded9b64e8fcbbf5267d1d96260cb7341fb203e158761337cb91907ee0c99f613fbcadd3b3b2e52234ab77d57a32702492c6193f7628e54ce55e3ed3a6375424648f8f81bbec2c9df8bd2e21beeff67bc08e33ca3332c97174a4a65ab9907f41f2a0d326b1e66efa05efd9cc44b037f6fcf39d67c7a4bfb2af9e1d193514d6a957fdadc5d2bb9ba8c09a315698aa8bfb390574f4576cbafc1ddb7f2936ce3283d20ee875db9092b749f7b3f602d154bed3a83e95a58159dd7468c00ac141085eeca4971fef4e426d03ebe017ade9948e9543108334b57874b9530911ef5839cd680064ab4df2ac141b4f1b40296eab0b99f6aec3d5f8a3fd8c5ba028a98cbebf2c179612f2da14533aa91671ead9b0b4346f6028598d3172cb0e0f4a51aee26306e95dea133332c738592a15c47ab7291edeed3be2536588b4dcef2b73cec34174ba495bab3cce2e0c0b05fa06a5b990bee67e19c1268233248c534f3f9a8eae1b537a4ec391caf8d11d70f6387161d2374dd2fdb0aa480497cd302675031376f63f34d8df4c20a480c027a1e6f294d7f9db60c667e8413e94acada653d31869adf9e3fa9b7e18fe6f83df39d29fd6b04e9446522fc6cea172b48a4c49c0275bcc1031a5f83a673e0dbfb29d8c8cf3da5a539289e8a5b0ca54772060015c0f49e4c5408dd7122b8f53e4e5068a41f3443be55f7f4a0a42c331d2184aa0189f95ed9789a08092a5ffd4dde6ceded2fa1c770064474b36fb9c6e95f063295fd2860dc1eca78c92f04c766d6f00ef763c1e89035fdf78a65287ed904a3424aef0c6f110276fd9fb1981e9c04c658dcc436b53f221c317f3d21f3f97f19491a10e90cb3f6b1c5c51e32322fb5345402493bfce714c2d7b9ac049070a40e508661452723825becd18b0a7f9b5ec7463e9de888118f0b9b15a855b9e842e338414a316b75d44b5ae1f337cb103e847cdf14b8b95db0786d69b9941a8eb70808475cc0edc547760b834a95181538384d495b7f94fbae1959acefb08550385924833b12019f19cd221718d76be096c85bc2b3d27ce9f0802b7d5add15ba45f92e2fb7a291757d5d4fabcde87e29d061ca7f033c323bf7553e5ec5b07696173e3b2610f5be2a237cd0d6fcf546939ce64434e61a8b23f830260d54b32c47de29bbefaf30bff1bc101120045cfc97ff5db090c8eb9a29ff1fde0aa4abc75e4d7641d7b6245969147b0cc352c16c3a60207251d51595c912699f8b86b4e95bf484368518929519bd89ce8057a8aa4ec78f0ab48b668f496dc179707af8bea1983a5730786c9dde7d6737af19b3ff99664ac73e1782382274a6c4f39e7818edc2033ea499402ecbea924bd4b7376d5e010e8d032c95b42c67ed34a9b6074752f902ded608e335c4c7fa832bb88ceb8c9292084a781420f03b051925bf2d002a4b34bd89f79eaa3413fdeff09a569887d895c8673629ad6225f416326b2492cceaa38fc184b7c10b7972321cfe1c67edcfd2adbc3b0b2e874faa372e9ded37d284da23ef064307473ee8cff50a6ee75422a065d24ed4368c91d9fe37d942fd012f3fdad09564e1d58eabf1a0bd7bdb7588deb593232c57990bacbbcf8a3547de0ae031330881205b804ba228297c3775febf6ee4812d229cc9cf541d8ac4c7ce97893aa98dca04bb5cbfd5d9ed70b24d1a3d15345f3b477d317db74710a48f299c282a1c6b98b47bc9d5072262f6ce3b87fbe303d95c8fd540a4b490d7c2f6d55b3cf8bc3ca4ba22028e0e3911b4072d4ba244f3ef95fd050ebd82ce7d4bfa2bb290e8bcb019a05f8c57a59041033a58f28cd3b93269b1fdc0be995ec33fe9ab5343b070a306062a962ffbd9738d08f5e65a148b13c2ea09acc0e9ceb786430e5a5f60e99f788a2ac2242fa00d4920b089aa7c042dc0eaffb157672cdb5d1e5e53c226dd2e746fe86b4f66ea3dc79508dc08e5adf537de27e5fc0cc58c52a89a7f09bd4060a81c68464a92a079f201855ded315a7f70898c0da88850ded9f73abd3cd2572e6fa926d712fbb7461df2f59f4e3d5636d6e02cadfeddbcbbdaacbcc2c4575d170051198e9d96d60f3f83756b0ab1a68455223bd75f98b7e4687deab24c243161b19bb19537f2d82c806d47b180183c18333ee25763f2ca083821382ad1e581ca401a54980c1bbab2ba13660ef84408368b6d614694d61b9dbef2ac64ac5f3e90b677045009b358f1046057b126bddd6ebd43eddcb9e258d02682815034e9e4651289c885caa1a383362a36d77fdaf6537bf7c62d047ad3ac672fab1eef4de9822f1de04abef379093b5cd69d94e5d4992746c46df35442026b74bde735bde54d6235f42bd596105a84cdb6808a49f5003d59ac931a749a719211b4a5168f25f026ef0747d717f0d358bb538c201423bcf1e5c4de5facc3d92c75bc3ce2b2c8afa160beb1e4b2b0ef60edf4385ce2bb9322261dd3929b2d45bfa749bfcecf5c8d84197e1bc5a02f437ba0bd87de9d0e8ccb6e5c55ecb9d44a70a54217dbd68407117c7b225fa753108eb07c5ed8e83df111bff4341ade8812dd0c494642062395367c4c26ca01751682e736cd4f853a136ef46627e94bd92f0722dbdde188f2e97a02af0d3249d2392e87922db6d9fb8ed88a9fc4c2b04bab4685d4102cd5931e379c6027e9a2c8816af1705421f9c94fbba9d3f744a1664b392e940915223169206ad5845a3ebc87068f0232cf40d8766414d07965bc28d8cfafec7cd3c4f8d6a5beb3bfbaeec690408c63834e417f2f4a2f335d512020dbdb6f30efba75aafa60527eac1b113c118f9d901083cb3a8f4061b7e39c4488b89d654a34e9d35890bb315404123b8fd5691c4aee166fc99503d1a8bea66237b1fc122db0ee3eb5823ed00a3d65ed03ef02233d2f6c645c75621d1f21f29005ed40dab4646caacf46c1d177ac0876a0630a3d840babf6d31ac3da5f4903d6c774144f7a65c9725b9369cbe992080966a218ce5300231e2dddd1d6de6b47132234005e37ca3012bfd92dd3d73be259f07f427c8fba22f9923f88ae46cafce3c08d01577858bdd8ef765ce6f762d8dee85f62d67e5febaa113be8dedffc5df1cc08db21e19d1368cbb13dbedb7585418d8ac3fa4860e062134efaa9674ab1bb1bd16873f05018fb97284ed7bec5a0f998821d23e2f2cee58b97287eff94331db36f2a6c9673401457a42b397ff58759166269efd60d9ecdc293db0f86f18f39344ce37e501f77bd4114ed020632ad1f2bf5e70bd45b19695b75364c0d94fe0a9942457504cb96326c4b775d9bb7b174c3190c065a6111d7db90a323b70f149d324f92312b101beb14ecc2daa4a1e6960895555bd73fe84963d36683378cb2148505b8f6c9c78889b00ba34f798873581245ae286985962bb3b269dd82ca40b1727098d958a64db70c83a1cfe7fb478f4b799d494b146bb1c8724dce64760b021ab1a14c091ceeb2710c7e410993a1b1bca26071f5047f41352df57b4f618f9823a5737aaedcbcc5ed652faed3cbe891a1126a2d5626ca81b7235321efe098a7333a10fd236207db55798d5120c6ceacd583a0dad2b101fe520c6d78521f768b43719a38fb39b1ce241063be4c287b491bae3e1323a56a34ced3ebd8c5f1a77af4395acfe750681e805c471e5d517019ee709bbaae664170beaa1a5cb17fdbfb808e4fa3e5c12845d5977dbe1ae3d7b7704611ba2d53d4f6db3e61f4647493c448604b6766ea7c09e3e555d0725b12e338ef9b891a6cbdee2269a798e479937fb1815a39f73ad3a7094d3336635e7f39ed66272658e75c2d926735f24dddb502e497a97ba3ff0fbdb2f28fcfb9150d338717a2063eeaada4eb115be6e3418f08c20297afb5351f310f818eca426a3bf7b267d16891e69a1e02389fb9df6f2a31434d404266b1e5e9d525d833fd1323a6f627dc351c469d6c581a9952d21a1caa7fbb2adc43d63ecd49bfd69b3ecdb797232521b2107c8ba2118e5aa2a85e8d2d91dfdbbab3b2ac494cb2ff8f85a4dea6a0158987f5deb1aca62ab5a9c9a2ce8ea0d45206811fdd25710b4bb141af170630edc99fa48361110be2122b41c85ef9320ad851fe492b21c2c31b6217648bfa9756fd58a645f02653dd41429364067cd07efc2e38de967ef47848e33d957f364d77295388d79f09ac172bae4cadb731156e22586be998ce8fc6fe76d775553f543706afdf588de7d7e273435e4d1e1a58b38f2c07a8d169b128b965fb108cc4d99fa2a69f87aa8a79fa964b931091169b954e651ec04646d1755cd235e1178ae80c29c8f89c68e58c9b81a4aa9c572cb1d4c04b95c9b0cae849696cb2340161424b4947d7be8b7c186929b0b7f36204697bd08e098100f5cefbf1adbecad3cad1c0807e382e6cb34f38f3e5bdfcb8f5a3e7d64d1a50a2803b0c1e85d7278ce29272eced5fcd730532ee8001317f660d875277322c4c4d93c3c366570b74005866aa700084c39f221e1c4883c6609d223b1f833e0f4d38270da7acb8b8593165864eab332c2b63483ea8c279456162112b650de555417bc6f20a6dcab0c21a1bfc83d703a1cef46d63da915987a660331915d370448fba471304d3ad25b7cc19ef2f581fbe64968579c4edda81e2498f85b0906e2934e41668d5999fe48a05a84a9813bb920b1160da9e035b060505ac15668e302d1b626ff06fe4434c653f773400c87aa5295fa7889fa8d49da4a61763ad83fac20c2ae8c51fce7727d9784f7870e5e79c2b50f261756f82a11a294166bb1bd0cf72c28b4d73574fd272e5559c86b65a7ec1fe6d96278ddb48fa4dfe1fe369dab41fa469d953787f48569ca4d7b15aaceebaf29bf10be5f2165f19e11d4b931aae2fd6c4e0e0e3d70922b6ec77188aa5a004494f0d0a6c59273c4253a4c7b1a11c5cbae2ce97d564ce19e711820483ecfcb7ed768fc0977982ceb80fb44ffbccac731e0b125bfda4e80da395fdefcbde23faedb2629b91c6b9c2d20aa7688c8ec3c97d1747338b2430017162794e8acfe0287b5f37ec9b696dd2e6c0120b7d20c04564a1c04fec71186aefd0c99e58fc523c9e7cb0ac766096393558ed279c31b4391526469514362262fc59f8d9b23725d5b13bc0d16198b7256f8604a4947752a63d5f41899f4bbd9bd2957ddcb96d66defc53b41c5a6e6c3e01fb7faa94b7dedaab4c901b7e9f8622ef483c24efc0cc0f5defea1bbba9e32c2d585570a273cc56f4b894b5f071585f97c9b6b4892333dfc01c8f9199f90cd0af027a9ae8fffd15bfd29304b0c1aa89ef8dcded2dea8ff683e6fd474c36a0af12cd5322ce842edccb6a5f1fe37a9810a3991b5433f61925a396b53ba81addbf3b355bf96226ff12ab78cd060bd8b1f363bd572b61b863b837eaade8a5b00a627ca17e6ade690e4ec1becf2453a9ce52f73000edac2ce91099798d139ace238b774cf69b450b51e32adb77f3f5da545d9de8ececbb2f4042cf01263fa352b0dce4e9d3ad0fe892111719a113c890b8a95f994d31b9f6a80d03f01d977ca57d645619b36f36b7e1b3bde9237d093729fd4be8b8556c1f68a106f77a020d09a9ff892a822bd0dcb41c842616016be3ee018850fe8e05cc87527629336bdef790b632da0cf5535a247b27be166a159f054dfaff6247c46fff1e88f58bd214feb48f38a6e3cce7b1179a0e367a9ac72a3abbd1e226a7b8792417ca4ebafc7061fa4a0a0e479155e8c36b45e9987a0b6509def76bdd4a0c45debbc5c7d82bbc4d0fa1b925448eed7566786043097a9c0ec4f2fed83d6d2a01903fc5838010657df6456114367fa2c616df1f8a1c2fd6842c4d1a596dc98d1082d11c1ef78717826c500f8554cf663fc0ae677ee48a4e52fb241ddf1e982b6341ee2125326f2820c0ad6ca952e229069bd6c699cf752161ce08ae69f015d7df4726d17b56dd4cb4c723ca4c3c5510f6fb7dc9ba740b973e11a9df80e79f0dfd97805cd6fa020323ba93303bb9395adc8afbeaff707e484138b3b91c52bbfcf371ca2fe22ea5892177f419a9de9d7a03698740bd24926e197581ac2e349078dbfb320c419278676072a38154d7e54058b379ffb32357d631cb6dd7c399a415df0a71ee8e275d35c6234ae2ae0b037a0973e916728cb5aec3fbe55e19bbe163a6ab0a6ae1a3621ac6a48f3bd17de0e93f95cceae59473e0d13dcb736b92ccd33ba274722a435999fd308778b3f712017e0db6ffe86114e650fdcc369b89cf9e4873f9e1af76775edb607555a848c02d8d156c89efb2af81accfcf2cf1e8aca7fce6f69c9d2dbe94dff51c84ec087414c6c08df1b2c2c87536ed77318554dfb3460ee522cd02b748f58611c00c744699571dbb89603abc64aaf593500b7185f7e790c78d4de5f3caa539924c0d1dddc3aa8c87ab333d1a86a405207720b11c9f2f674a2a08b9f1fb37ec676155a83dbdd8711e7b5d282fb23ef3463c599bdd8892e7cd8a34468d606e549e77f93636a66775da715718b93a273ad6763491cf41ecc3dd9dab9952acdafebdd8c70d74b709788424ee44c3edb08f4c189aa2062a863b7493b482155de787aa425fda99c9181247bc31a381b5092cb0a14fe5f8951a9622fe8802f9543c161bba75ef09ba605dd159bcd033027d5cce96c8abba2e50e6e9bc1efb34556319e040b7253c3001c5bb9bb411586e495119b15b87bf79f0d278ea03cd2480ed42b7abc09991666a68c26402e23ba338606cd9a778dacf2f89db36480348ebd0fde5b2203168975d3125fcf371259c8f258629b267c72b1716a94a2ac91d1aa1368dcd18534ef533edc6a08f1a320cf01579c088e0664df449343578688743f1da1c29ed7796c58a187272aa9b7b75d95fd7af9057eb1982a18a4a7eef65bd7dd17a0344e2cf8e3efc3ab7822ba80e5bcfbf7a9f1bb8f197d673592e37cb55e57fcbe44b5f55e5c75686992deece4a49faeff0b9e86f665aae92ce4053ab78d4033a77da3c915d3a497c42210f9ea496adfc9a2fa2de46f63a1026f7582515e2962de73e3f220d21cb813e78114e00867da5de4bd215645a4739448035e5fe965383c1cafe82b3c879d778bf15047d7f971fc4e810a01b18c66587d8ef12a856ec82013feae344c550545bf6063ab159c8d85bb21e1df4e53190b8489bcfcec935f55385d126fd8182e94643375f3bca4d57a7171163adb1717e718a399ad3259bc0238091229bdb209769ed9e72f8b839c1c88909f86534138137fd4fc1a12d9489e9271d0d5f847db92e1df023e69b13108c39615519c0c45c670dc14136f72440ef789bb73caa89be6d868b7f7217a6a63ebf0f853e89b76788a6db4cfdad71579ebc893108096d006d7c6bb080d9a122aa1d65dd15647c06bcc9c1d2538976f9f4174b7786928de3373813b43f6d5208cdfcbd0976fa146e65493963976dc7621ebc524672690df70d8fdc0f59382f1ebc386752418e04564f0dae49a2228bc0efcecfb1ebc3f13c22a1337396204fc2ebeda166e8a3b860f385657c773cd4e41739e911fefaec83b8ddba5dbb0343f8583a4ac2145bc4635ec8da48dfbfbcb3fd2e17fa59562cac82e578d096ece9cb237bf867b165d102bddf423bc2c316f2b3d99bf2cb62c7db3089d5d537505e729af983982f29aef8c5ab593d596298123f000075bf19c509927a720739405cf0f23860ff84ccf7d7ccaef3df125d1a3e302d81c7957002979b410bdbae438ec290b7205e95e5412e45aa088c143223e1f2b473399bb81e7678c645c2e9bdea5f8094b741be60bb2e75551941b966d30806241166d267e52801a1b8ef134ba887913317d1f4ccba8f623872b9454e2aa1fad5836c3fbf7efc557715b1f67575c4dd47be872ba78e31b0a6b2d4670400b0916e81051973c22c6bbfaff108f2caa4961ec2631a13a97a7a7d85f6b89e19891b6e64376b7c27eee927d2382a9740dd3a9b4008da1264ba12b43c6d29b19619c50075c17da33a325dbba55f84948e8ad411731d80089bd1ee5105b4db54f460f281b7a40d5342de1bf3ffa6ba99b158a1291c2e145989656b0d8e0cd1f9b980cc43c73ef20f0b560996470a8d917669e6820ad02bb75b17c8e7d756a42dfe1c8bdde6ee2426acb2d61337155400fa6c3b8d06ee582e074fe3cb613ed8bf6ce67dd1be3f12c71eed1a8f655e6b90bd93a60133c8e6e39f752941d8f2f234cb25c4031c1cb1a33121b11f6bfe397ee4212252843155381b5855c527bb796ccba99a62d4dfd43642b78e3336e0969aa8680ae7f70941018aaa065e1122bc24e37faceca463fa3c86e18ce008fa2fa60f9466fe559a872e832757cd3e327dc9202e66909199df2d5ce157a4e78d9e7a31de7438052da96914c05554768f40d6eaf18bef50af2d0d0ffb3ecf3ae153ff28dfabbc9bf7271ed014b4edfec82f45d6a08289a71f585bcd7ba7fee7906bca1ee7a6fb99df366d67fd6b087b922c4a2804d12dcbcabd281dfd98ace0405300ddbc846cc43f6bacdc36bb3b5d9c8e667b252bf1fe54b2df7f3da43343840806ca3fcf0fbd9251af968e4518ffc08597c9d5a5c100726360d65cb73631e7b4fd94682e73e1e945b22766553ce90cbe51a504f2425076e6bf324b747666950d68e90f1931b1729d6487f09bf9243cfb100915a5ad6592baa64e359e2480eee07f18190455047ca9d51a4a4f842aced2f08122b46e6cc92136bc9d6b36016a441e0ff65e0493144684c33a443f6ac515bede7fbafd82336cd2b0b7a35905cad37c224656a0682fd9b91c9a568a502b1f5df3bdd77c15694a36ada74c10a5f782652d8b7a8a7d506c40b7d9208e6df009f35dd4f8c3b1cc10974dc0cf7fc4fe66289e94beb4b746bdfeb99ce261636434ed578b988c0ff5f5e186fd8f9d532b2e171f34d1b6e66965642826e36fae63c5f17819fd639cfac3a8aacaac608203c22d51ef93224e0b52311c227be8ab42ff214f98cedb1f1aa175f25784b1312a4ad7d0d44de6be65078cb1377cd681b0818ffce52847ba07368b43c63b7dc5555bc49d8b368b9cf09e0f5eec25b3d4a33e7595ab2adde275afb0b3e460ad85c5c9af0dc6be9cefcb09288b7c98886a255fda31f17ac32adcf19538e2def2c45323a464840d66010da9c4dbcce2b1be81bfa22d701abf887f950b6afa36c4622f1556e6be10c5019c2c42f3b7b1034f23efe0d5003804e824e3594e0c007d142d847366b1bb7c0e4a0f0f98b36c248177a011bffd42f9f1e445732f4c08d0cd345371528c5a0fc04b02270cb9f36458524b73c55db466a31f1c64bb9ea86181e8f8fed973301d32292029f45bfd9db0bfda6c1c8fb2138552cc2b2eea8dc8e3f3669b58c7bcdd1dc151125d6a461a5102cdbcc205ed2a1977d6bdd61fb9189b64b216e7847c0c9a99afd5341f113069246db4255b73efdb9f47da3b14c6ee77435bcea6a6c4bbabe76418d46841df43d37afefc48dd1d927be68e3342dc057313c93046faba93c7d63edde6f0b0636d413c6d812271f985354df36f8ec4f6870d59fde98ed61b2d60fb89cfeae0a52dccb5c3ea4cf11b7e8a1930e7957083029b54c5828c41790d8d42b5484876d9fd001eac6d42812cccf3b6ce06b35cd8b317a4b6544e86b3d4ea11fdf97a49998a2ccaf9a24014c94542631f3eeb41daef2c1eb4c8435930373f21b4d49b86f0db43e639ceebc32d9a4f67740c60f57b6e5e06b22eb7bcddbda00ebcb688066aaac4bc4a4cd2faf9f5e08620231c566fdd209b7e0c552aae74715fba37d3d48b0e4845544360d32db5b58392ef75373585c86f8ce9521fcacdf01c890455662aba1d747959ff7099d6f62b849b27e582609fd9284582cda109ca72ece02727266238ab635380cf22939ce0a7dca8f815d454441d5379013f71d3814dfcbe566ee1fc3b4d93a17d3ba1b2b5e94cf8049965be352accf0b76af53f19ec8d914cb58339cd4ff9bc996ebaf04cc15608366515e17058fdf2f10e4a5841ec03e2d4000760929eb6fb0a27f65018dcb5df7cd0e202c80c0d23bb48e932b238a32ee1f8dc695161d7e0b003c66014678444e628a6e713be4c2468555a8c978868646fbc2e3bc6fd5a8b840792ee575f317e657168d2cebe558eb97f0daf9698b6bb83534c7f75806384293bbd6ae70c90dde9c08bf616718cb3f798b7354de55e08be9d2d74f85e1a8c38d5f8fda998d6a3dfdddd1297267988fc9c6d36342521247d7d0301702ff4e703d7219044c11ea29d1f6ef79b7e1d5218d861cd58677c036a4e74224250f5cc5825c91fd32b4005f4cdcf029f2d46054c226c750007d1c2869af9c696f0affccf072c19876d41f6ebf31c653e51832eb0fb4f5ba100f6eae30765fcec52f60e6896d03fdf1b2776259121316fa5254cbebb1317b73dc10b98334d03fd49ba7df97ece16ba0df803b0e1877820a8a0ea5b344f138d93fed63b97ac94b08757456cf1376c37a2f3059ef9f706c67072e7e8b06b0b890b2be90d8a5118619f36313a261c865512f8d5faa0cea8893ed5b1d64fed2a840b7d2da8512abf3aee742cb02b92c076a22a71d4fad5a592124f0b0a4ea1b5448c5d13509b33a77b19f2e078af8b5e44f5cbb961b037011abd4f0e381f4ec007bb6251ef60228c563753112060dc4356f885e86fc031b7a92a38ecef5495d96d3818d7050ecd2e31d41f25c9a60d16bd14aa4c9cdcffd1af7a12269d094372076fa62c621a8ad37c869427d89cb92eb81c5af37828df07dc84ed61c273c15a0efc4377ab647caf1a31eb2a8117001830cf2eaebf4034c1605105accb05411e1b82fb447841bf421d553b1fb7f77913c48676ddf146adfceed4cc08fb6dda176c25ee185e020f99e85d98c502e8b500ede11c7ca2d406b89951c8a1d4a87b45c302cb9000cba721f10d82f63b8c28a8f311081c538cacc6f23af9aea34194d5095dcf4237d66a62d25d0af3b919fe17ab94f23fba83576144c8aa6d0f82a28238524456f4344790036620f37ee42182ec1548ae27bec469be34b1c224e36f5c558073858e41ed23db306928e3fe5cd251847954b9452efd47cad9cb3c2d1474e7e62bed6893243e7d180db5b22a09dfc35fa3b2375a274d56acdf32bd1c7fddda91530158b960deccffaa23573b10cf6d16ddc38b21cb230897efef876","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
