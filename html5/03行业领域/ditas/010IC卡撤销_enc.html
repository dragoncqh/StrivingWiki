<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"386dfb4103222cd469803a59fb9da92cf1038a3d971a9ba08cfd89f512053faf6b5fd1b96bf5b82241d30b60fa59a08f93d21cf2d4c586318c493dbb6f1e3d52dcd98f04cac97d0e7374149cfecb390a52e1a64f657531abc69aa55788dfcb8eefaac31a79d2aeefbc03b78c4901589d2bdc08b3f4d33dec5e906bc31f1f1a1270f79520f7d5c8523ca9cdd888e4aed0196646be553df77cc778f9f6fb4379b78f03152b67daa79c4a262dc9bae7696a200424b6a84d2f88a6e6b0f169511191b4e931871f2adccc153be27225e53cb7c195e63102c9c9847d94ed2ea23c85d20f6bf2e82ecb0485b1867452d0f0b4865d0c1b5105e224f734dba356ce27533f6450c3adfbdd2140bd9c317a6b531783fd54693bea9decbefd9ef5d650775e2898e6adab23a63223cfa0da7763842dbb7717a77dbf43f828d53be49ed9bcaf63138135bc1845f540f6f9f2c9f893df9a34778bc45f1dd7fb934ec783f532a6217f8b5869e322e8543d76305528fbd27b2109d1ece3e5a9db8cd59d88bcf4ead2ee0ed0949d14a9cf6a07c72f5e7ce094903d932513d1a936b353f3b5790bb99ddcc185eed9ae93f001bfd1e45c413f3bde71f834b1325c7b26085b4334c61c1c8f8802685f68ce60e6587820556396be2829bab1f3558961d350fe9124f75e559c3bd0295fcc945df683355dbbf1bb025dcf1cb59fe0664bf4da45418e02a3284ec38e55add4540f21dfadc66c589dd0ae415aeb4358b73e0e13bd2183f1ff571ebaee6be781c31c61efd3af0aae72e02bcf4ff547c386d7bbbcdc0353d71a0bf41b424aab90de011cb7e9256ee6ad0c535341bbd8ef772d30035dcbaa94fdd8889fa7802e93b913b307c6f7d0874cea309428914e94398279d8eaa7fb7c91b747b431c982cdbd58322303c88582387227766c4a399ae29ab44445f08f2df208b6d81acc1ad5d83c7b048aff82f96dfd2bbebb4154378a9d282befd1fc6e63a4e70876d30087f907bc837f6dfd36e0203527e03a1678e6195b0ce7b9a6a735d1ebdbcd7ddea290aad6f3cc4639700794cdd3b69db72987550262389cd7f4dc476d4f6b3eb3c7b06cadabb617ca6b1e195678848e77090d93967123ab8a81c89087533621b5519e69df5d7b318a3d5258c67182984ae7ebae56c5c05480b46c8aaf189ea6747a953f5a6483c590ed6c6ac11d7398195bde56e196cf554e2c3722361e3222e3e88b0578ab8cfac34d9f98d13521330263408b998c42abd4cddcee10c1465f1a718767ff9acaab6ed8f7b3cc423e89f8b7d89e6fd84d16f7348e257161649df1b5a2ed25d7005e6dee935d9cde225447ccdbe4b84b3af2358c40514adee0300b9813ad1201339ae80467effd85bbef2cf6095d8065406b02bc7f965004f19f2ca86f5b3e9ebb8e2935f3bc755a51490bab97a77f5c6094fdd218582dad9daac9cfc51c4826662370718131e64ebb8c6c340c0901999468b4f712b5ae03ac01c50d0174983eba8cda9f5a279d5ba7051b7a9f7fb20da8534023ca6d0856b9fbc9cc4c0c13307096b86be0c1690e3ffc69c25a31c83e1181ccbde112acd56627debbe2f5c70840c246746fd9b5e2c2216b149a6db1db564f87e6080953f0b6f93905534c7439a25415eda778328ea69b126de2737b521eb3af0f531c3996e51f809def22c1792d42c0bbdbf4b06c31201fa0b9d332905c6a7cf173fd45aa5feb580f957751f7902c78f2cdd595e307479304ae234ed503115db04eec07ac463a0b5c7af0033449519d6c9aa49fd86becc39ef71b3d2f0f8c09450e31a0bb6221d904f05f7ba6d2b3f9f98369f0cb1c7f0d5ac422457cac793f1c4f5ddcd3ea5a1154f130863221e5eb3c5dd96d56d7f492a587905b8986e3de11449fb674f573bb4ba30b088f1382f0b13da11214734c3873e354287fde0cf7e41cf9d972bb43587c89bdd5343c53783e0bd6cffae551b0848033b3a2729f974ee9be26c7779f810eac5097fac4b558ae4807b177cf0293eddb430ab4e52f49e543a08769660eb66c21eb9bf5d2c50aa9a67bb65a9e7c9ef10c8ef6ab92b1ea7b032d56cf6dde6a32d847ce4811ddfed62a802b0d3ba41335b468a1f47094696f4606bdaca9984a8ffebefd1e27dcecce3cb3294affa79ecee8c8950ff0e78250a9d5981e6f7c843c0acd6e210f4951ed676059ef2144ce39b7e5db9f87d95543696caae5d3a7e9c240c7eefb8317ec5c2891d3039201ae775315958b8a7612e8e9df36328022459f9db7782d3b10cb7f1b7b6952f2de43b6e8a32854f03ffd79a31df9ee84c2b0e42f5322d919ef952974e00058f33afb5be81f04b963b513877e35a6738ba98bc7b24b779ad7afe117cfdec4ac963ce6185206c35c8743eb68cffc907b15e2dd5f1e4c86b9d5409adb7f0791bb455b4ca481cabf2cb72063a46ffea3942940bcb8a083ac219c1514b23977e374168c8e85f4e2132cc4663154a684b003bc052ddd89660a1a137c56bbdf07df013ef5add25687101ba2fbb33794fb1799338173331be561b99e2cfd11d089297697ad4b47c483927c686098079b0b52dd3903ac899243cc0302c19f5e69a57b1a4c4ebaf94147461d95a4e237908b16873a46253de7d8d7e48e09538a1f7d11cef762e947c973aab41527f164eb2f868721d78c158f304da705bfb172de2a5ed1029bf6b40dae479bafb43778cb370a20ad585dda73ec86ab47c8016dd0d03af368ca6c8ddf4c2d9cbe74e123bbebaca01e4b8bb51a2a0dfe2a82014e2b3df40507826114a148178aa92179e2d9b8c007f0afde36912d1591d4933a6e2c5408c42e3a915e0fe2ed49f245338f6192794ae74fcbd731046ca9cae4c58917aa9238d1caa9d3de4710ca0155aa73a44176f4901e5cae3a9cd4af401dd0de4f6c62fe2e9efe5208b8805f737d1e2d656346d51c127b7e4343a1df15e1fe67cf4187d0f930b1be917294fbeb21a7c2702395dcafc6d22e14a7bf212adb2ddaaf51b846e506d79eb663dcf75e033ae5b285b08bcdc10a72f031fe047b131f02a1836847860c88eb25de38fcad8b7f3a39c7e5fe791b1d3e061c0a943f5d81072a4b9f50a7a51b8fbcc24f51fa0d7a1c8057fac9bf721975d55388403be28ba98e60feba03f6f21a8e27d9e509dc9ba4d3970c7cf9bfff23997f0d8f42298cea6c5fb0f86125b99192a98b89a858fa5ed0843f7f6b4b549b7341b5ba30b4cd06b213f327c5105ec3bc60d50bb844d42f7eaeed269d4ebf66113d1f8fbc7e632b5c6cc74f08fba5dee9196de83acfdeb2e939d88b3d141635085cd2346d099a8227987a4cf894a235a26005571152a639d9266a21846fd2f923c1d6f0701811e5c412acd6b2f9315013f532833ee9d898d3c9691d49d820c38b86a1219ef166218db0436d438572cc46ffce0569a06578c466c4b42d0414c663e9a424118dcb6d456284d10ad98655185c56dcf24948cc7103892807373a927328559fddaf5bf1c65a32846304a4aa25bf005cdd9466e336bdb368a36e3fc15560ddac7e692d2d5e1670a8e38ee5876b25377ed74591e7cac3328299262d3bc31ceaa32eaaf2f67ec71005b8d7095a96d96bbe46dc2f9451e5dc8336afffaa160889511cc2fc5141dc6281c28ad214e9e3014e672fa7aa453b49355f21f0405656c2d55e37eb8c93814f0f4c63672cd37dd23dda5fd98a3cfb45b021732da276b5db9ba4d6276f8cf1d207ca8abd8e9ab5b3d2a2dee987f3b9aecefbc6789c94cc09bc7668aa514baa14191a4146f675d8e1a8df033998b240961a8d675d78bbb82ba1b68e50a52ef6be3728b5f2ce892a8ba3c2a773f184b46002e89801f46b010e8fa95abe50c76a65147cc4de2165ce90b0849dd65739db6c5ee8401d3289190ebb8f0e0649cf410f6803ad7b68f63d4e2e4ac16514c74f698e085b828e8aab15175089f2d28100d43ef18101812e0000139aea3ce9cb722dfc0f5aee5a18b496033aba4832acfbf22a315c7684e8605bed5f1047186ef9a4d1835d439807b3e92f503a466f999254d72805faa8f3153cbb135a2ab62330aa586273a912c54287a0c176e59b0f32d57525c3a9ad0e0345e337627281616511c122bdc8ee21dcd1b41a673d18b11e45ee501f0171aa57775e9e44bc011b3a410a8c60092b37edea1e922e304a70c8101aeeb22f1f9a479cf9c7e1bca3d81710c8f369fce302fe2c2dbb04b701d03cf0a985819e0871bc1e444454853d95e18450efb6daaa10623ba46655c400b2d166f23e8b18f689203f31c84ae6d7b3984e44ee7803c99272cbe9d93fc9621b51b9270e60f64d0b9da88fa087d4dbdf42169dfa0c1b6d4f62edb13e528c2ba0d17a377b4baa842dddc2dc4112953afef602605e56082c46dda532a08c38b74fd7847a597ce9e00a9e5b4a143787a088f4f6ef942a4735e778547cc66268e3b1ed42cbfde08c4606dfad8a4b3b2336e2cb289a6600a63f7515a0d5c2e245e9c3f6404699338fc45c8c64130a855ca1fb57d462599e8c2560a1a83b845ca7716d254907bdeb57b15801adcdd1b5be55dccd6c56380863afeddb71863f1f0012deda9b14dcee13a1920d3d8212bf3d0a530dd772b71f167c39c916cc030f1f80e97c5baebd47102c02504dea6dd3c5b0201e617ed88a02fd738b9814fe3e0366d531e08981d931f956af3863bad83978a0695f010ae9992f99b6655823430fe9eba1fcf7afc9520326b08417d9e6ff9c21d8ffe2be6a2812dd34333f4e2fedb2fef886adaf6691c38476111bef5b3cc95b3556c3cf9923538af2dc73ee6414c1a598a7be9d2339f62b5f3c24092a41b1fa78a516a499fd0e353e63342cfc9f230583ad61e8480fc398c9c3e25761504c38c8ac414400ec08c840f860e8dcd5a4ea8b842ee0d87379010399e76de3592a50ad4f10f8d2dc1605ff9df8b49cb78dab06f38f8eb120e7fdae5e28eaa025cf562d8c5f2ac9b3b683804f0205d1f0a8b59d1555a5337018c42f18a298f8da6f2f1dfe903d927c0e13fd716961fc62459d37358238637c51a05a6bac64ad3b521638c5281ae02da4c1484a18834c280faa02117a11e4c58381904f0a5a34c9f17c7318b9ccd92f9ab25f60b69a340eb56d4d711f1f2c63f185ea1580ddc98da5ab7aeb08b491ec2a8661b2c0e2a61e4e1f63ee18cb9068e705b58645084969af284dbb7e7012dbccb498fadeabc94ff34c760fa97e011fb880b17ce85d7649a9e515ca9b1c881c13bf3489ffadbf4cdae702c44b365d13f7237ccf8878a1a8f114025fddfd8f479cd9155c7f8e0042bc0919f74f56a12f5a729004425cc51231fe016606ef27f5ae4c50eb7ac38c84f7e7bbe96ae1c43f015a55049e89af9a794377738f1b5f1f85bbf480210e5481020784ea58308b85dbc6d2e64017380221aef69ec93a1fb1dbf9560585760e13fe3ec04f64f6ad09545ffd4c8d91547dedd6f6d373ac4d839bfcefd2a085f57bcbfef5e0f29e0c428390fc89f956d03a6cefadb23807eec7861f59e4dc9e712493832315c39ce63d31823d3141cbf5934d7f06bfad5ac363182833d49f8a3991325942bbd2ade14132f9fe48a5cb3b2507c1eaf02970d7081213f60cbd53424922bd72cc18ce2b1ed3e94df85ae86f11ef77ea61d3e35bb8747353a76291234f53a56c453fe625ae280e3b5a045c6be98c1f482714ed24d1f45fc96a2aee22f0c2992c9f8b7105d719173d143fdbb9b981920aac0ed37f78bb0949b3f8389c30b48c48531b69841233b305f04b6a72c48ea410e587a5cc6639ddc896652d86fd1e66f3bd8598c5b124031f8eeb2d1d51f0942f8614575d770359918cbd31fe81680c09de83448f2cb4fb2cd1f2a21a3b390cd709a38eb42db8eeefdb4714572846323d232a2cefeeb61c3629c438e9dfcd86c6b79e123a30778d7ac0f6cf932ff3f517d0e18a8a3e338f248c4ef5af220834676d03923a359a5e91551f14d1413df81687003f5eed523031458890116f72cd8fea1e4be2062f028c5afbd4c2221f5c908571bd67db95b06d4897904633f20f25a620f1f9d1e737d36e1a271f87ce95aa40db4d8389aa2d3d2da528b0a2ab1d33c4636d113751972986079cbcee3c3c6fc3e91d84a64af365f9be1df67a3f6cfce793a66411042ba8ce6fe4b0c6b38405cf0f72bb3a81da04fe8404c75233e3045b1c8edc968693fcd5524f8c7d470c4445ad6ee893804318238c0f96f3bb1bc7f516e2862e48c7236a44ea6f9276e73cbb2c882c349e8380c011cb793ea2a99c456a6a72ff287fdd66edd3e0d051bfc846bc545cb2d244ba59c657c6f38451703adb645cb4b8600b5dbcd5a2baa69662dda9b15fff0785a66e76db8df3b8ef3977734bc36b843f1dfda40091e0aa9fd7ea631986b597d6d3e8a1506d64b602ce9e9dcbc62f3f7aa961fd715083b1435f2adf14f6e44ab1612ce6377343a6f6fb64bafd5293dd0a6f27ec5d36a0f8acd207f36bfa5d6160c92a6b22e2eac52796aecc969e1d551f8b66a551b829461c07559834d5347d20db5bba5cd7ed2c28210e85570af65bec0bbb4f85d969ca19aa70dab2982446c0dd79177622da88c7ee3c1e570fe300a2416c90e733235a07d179bb0b59f133cf0ce7ed300453b1ad3dfab9f40f120fb25c2f14ddf83653786753b826d58749b8ef2862f078fa047c5a9f26ab981141ecbcc50d4ecec7c14b1eda0e9394a30522a477a238e750f2f9b073b1b6d33ae63a823819138f97d6b8f3fcd6aa320fbc67597df072e76bb5fcb8ac935ca4b686a1d2f145edd726b40f81b89497687bc5d798f6614d1cb16eb6b8aa7b4ff5a413e82817024f295006a37ebb6b28369c0be7c1578c15b147dbdbcaf5a9d877be786cd0166f52dca4ed7fe3e856dd641a365cec0a439633be3b70a1799411a16f49a79ca2e703f8c1b607e9f2bec9284268288046510e94904279451cf5697997dc6934f3183e9c1721a1713ce5f5e000844602e3e0c3ce7d07d521fe03bd78a07f03d36ee83b8e5972c0ef2900bed3bc135575f72a04cefa859da1dc91a7b884dff449fddcc4ed7166606eee0c3e43b8b32f5dc179c257a77a5a3cd4e9945dc8a226890eefc71b958703c63bd1b5402cf5050acc1b652b007514717f6be0e0f957c5221c938b877a7c0686e0ddbb7d9cf183e6a5e02a59174f02befdbbadefc9ef8a4a6397447d89f28755811ed0f2493f75bfc985175a05ca02c0c7263040cb04f11fccb97385a3c7ed9befa8b86bfb2b94b95bcd8b77b9896c5b0befe56c49253db8763f0babdd7432c270705806175e65d10f985fc3e53af517ef1072fd7d09ec048c4354bf1503775dd94652108f800b185aa7f799c8748bd483e2f146e6332fb117f27024de8acb2243f3409b9f293a6cb30dd594fc044fc7e08b02b92dfbdb8ca7f685d38364e79d5b403efeacb6fe963d6dbfc0121ab41c20da09fce5d353b110c2d460d52ec9a797e94a768685d49980cd717bc8783585663554404bfcac0290075ff41e6e94871954a4cf0f338309acfc7382bb393068e3f54e8d9035e887611afa30c50a0fc9851c9f84bcbc7a36843767d55e6a948bec5fbb3f16546d667f4d8cd4d1e0d2ed12eeb30547ed1fe4533aafacdde4bb139e51d0ccf3d692fc3d61a6bbf333c460c03792eff4f11ed980192b62735b3d87494afcc7905f1bfae2c54aebcd20cdd3f35bf1ebbd565a2cb7301c48543fa16be306e93122b64583db7dd95b4e27cd2fe5ea92175848838260dd6f2b67b8b4b5b3fad800d41179414392dfddc27057e8e9dd5ff4abd497fee78cfc0cc9b2b47a72f9bc9197e729648eccdd597f843df27c35dbd003d4f8a0a1854aaeb42bbcc92129e93c4b73a73a5c75933d313e3beaef463192d08cd9a7cc2742c9107f6e6af0720d5123be91b1023ac3fc107b6736b742e756b2429cafa58b9fe47bdc7d07bdd79b50455a5257cd741809cd6a8497944cc18e79a1dd51db94008451eb6e9648af743fe9cbaee5338ca7e21e0b0a3d68dc9f3b9c2e86d01b5fcee750953d4dca39ae227963df5b24b6b0442267dadc796f4b5ae44fff04af69b5cf2e44322aeb638357599f7c53d6a69415b5b3c5843737e977194d1aabd8f18eb41d8c0f609c7c67bf3b050378544a628d1027f22a75a9684f2046b69ab33af4420d7889bd4bc2ff7f0c18e5ebc5c2a15133674d4412b63dd7e6a69314a00a966a789b57a09c98ac26e4cbd916147de012d23038df505e2ffc73e5580122e4224355c9b3b2d35297b9c59999ccb85b979df561b24925758ca8674dfd3fc9fffdd7946b4fcc51c4444d77728abe33a8371f308b89fead5a522094552ebdb95f1634483436a04f91eeba1bdcb4d977f45163909ee169388c16c4f2c083b9c4e5e4f515d069b287f0a3fcf96401c9672f027fdbcc69239755818be18593338abd15784d8ec419d05595553195331c387891aaac673a0a1a998e77d73f6a0c2c48949ae7f420f08e0b8a6c8628975c7dcfac0a26a25b7d239bb58b23faf291abd79fdcd3d861a7ac49441bcb0ae4e5e0d6bd7c6ff177549bc24475051a00a4a79af32e602425e6173a3b1d2b0847d41a74be1bb754f2cc9e9d90e55fd90eb35da35d417d6ce91161eafbb31cbe44e8d8547e19c973963d768b115cb10e2f5ccb99a33bac1864a46b110c08743b4573266a0a662b896916f570bb7e7fba7a31ef0ab91bcc0a39ced992f2ddb53ee6717493df19c449d8b336d1046ded87aa332e9235727667a8d540f4850efd1ad6a925fcba0d7058628de5d28c0281c8afac46025e5bee12020d6805e0373660ecf3d0f5bb0d2ee070088bfdc2236f55490e31aaaaef34debfce62c9423171ee6304dbcfabbd8449ed86e2c24544d14b2d61fb59d43286082582d763aebd346cdb17a50071479e338cc490879f2e29fe359bcac95e69bbf2015b8b14b3823e4972add9d211d6fc4d6f9b719195e9a62a607bbd58fc675ecdccf41f183e1843b7acf5707ecd5cd36d79210f6b928e17ed597a283bbc9efe34e39ded290d73bd11d4c4f23b8035c0effffab329a79575fab4677ff5f140b7c8143c262ce1d776f0678a1c7166d5b12869b02569499a8da05075b6db4c54cbb81a139b49b27c861a7a840c6346054279d4ba194e96599a1863180674f6d85e557e054d031f85209b9bcf61c190367b12593a4bab9647e0ed79badf6a711bab6a08e74968fe27b05dd7714726b5400fdaa0f2a9cf73805fa97fa1f71fe945ff93ab6acbb9acba2e1583fa41cc9408fb153296a93c800a7c07acd9b597fb2473c1c90ffb399a13a357e509e0984ebed498bf019228a634abaf47a1204a40e2347b556ef1973637bf99ba923ddb18d59375046fd4e5a4776a11c76b737f527d89f0b15ae1863c3c1ef8630cb8adea8f8c707dd9e012981e5f469ab97c2b99a54d67a91f74d24b54c624c931f2bfbae182fef0c6a86fe781933aef280fef0438fe1b4dd31317afef93510cc3f574f5399424c573e78b55b21dec10aac877899f44d9a49f13f0cf9b4b5114aa6b4c9932b5822d07c408ee5342e363f5f4a5061c7476062b33cb2796f690fd09856fd74648a7df5b3b72cacf7d34b0d67941fa658157d751c6b60039d272c85c93d0a65cd02911ec65b3989416b00a940def12671dcf5f0c95b2f6e09f424a387eda8eaf61abaa299aa67817b8305060cfb8d85bd531fa90c68f3ae92b1b7e3d0811bdc70d75f2c12ae25d0711029f8f46123592f4f55a3f76210a2d9ebf0397aa0bedc864f0637836478d2db936ae630849a49f611aaddc4764ecb8067ea84b05e2fefa0f742b78afc0757410ce9612fc4f2fd8e666711157bebda9a9e3b82c8191d1958fdb6605ba74d95b767a3a5fdbc5dad68c329627573b7591460b4a618191d652f26225396b36b02cfb535c9629afb8251ea68365e6df1d43b17d0911cc28f8b6d2c07ab7f5376d5c7c6dc1153537726397aac73f93aa3780cc4407531d1245ccb8e206357eff3214c88733101043375bab82c804e7ef4a813f7d50a62035a0c6eac301ef3b8ff20e9560e1704f499b0820c26c0368ddf0dc2d43858457c9e8077c2529433197e24228ee7959d0053aee6e5ed6472b87d22a57b9a98c70dde1b9d741983eadd0fa388af62b97e71bcc2bf27a891a0dde51f7862f47bacb2f2324c1203b08fdba99279b71887e2fa4f85dcbdf0ea04301930d0259b0095d106f1df1a1e714ca053f331cc3932daf8743dec00ea90fede4bdd90550ff8cc07c4d8b8cdcf72abdf08b8426fe00bed3db1449cbc24033bb5ebe0b9d6c19e1c9584de1e9c1b867fcd6ce0162ebd142b80f99cf30092a11e3799fa2adc2f079173138c949f59546ec6b2367aeae79a6d8e5fdbbd13b072d80aa82f2e69e4b0f003df9b42a1d17ddeb3409c4f5c1510df33826f8894723cdc267a9420a1b7b9b08bdca17503b4b24107a048fe451734c400e5873e5fc65e21cf365607e2e820cf9ed39470705a73f723f837defdcb1147115e51bdf72ffd9401776922d268616b836c081460625fbb4b4c67cc545ed29e7e0f3373308e656a9fb7ffc5e068fcbde20a5b05295efadce703a0b973b7fe7914e7def728d18ac08eb0edf811e1102640583b7d009ff6df4fee2893c28cb3af0af97183fa03404","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
