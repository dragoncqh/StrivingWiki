<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"24b24e178dec94381237fd1a7f1d8f20a9196c8562d484032fa2774691f73fe0795edf959f0bb2259531162e60064b4faa759bb4f7dca68c864a8f38485f1f24f5222da338569fb7590b49abf3cc2b6a78959932ca217f23112038bb3de7f3506d6a887927a4890edb91cb0c86d54b798030be692bb05ea3f55150a35a75d4b8f8a285ba88a74a6a823a49c65bd77ab7c66447d64da745bbb29ce8091fdfbf3422a9dc957f405027b5f07a7a08d6f1d48fadf2b050ae661188c9ddb8fde19cf3ebc4aa08afb139f913c279f1c0564a712c3070f0b6b57043e47784b92c630863fa988aec077aca8f770ae0f00a744c7af73ff7689757ca281218a7ca4cd77f5b47be63ce948b35a1431011cd75adc0a3c86e9ed054fc0b7d1cb0878cc4235ab8632fa2a97ea6a8be62fdf869ab299b9738b3d6ddfb1f5a22494dde03203838c33ecce5d3d236c3463827b8f377b4daf3a6bb6082eb11753e49d1b20318f7764efa70603b1483ecd56cd9242e0c09f74f2c730a994f5becebd0ccab8f6152833a8824cb6272f420f905f99030b217318e6837d3e3e94e824734a427e328800d79f4cc18b3c980fb57bc4c1b9cbb3d09d365a56288553071d5266c57db7bf7b977ab359ce0a5ee8160077dc112a0bf5e0d8a287020474cde37291e7a6622c52f0cf9de22365f25a4da7022e636dedab537bc9f0e9c81cba057b200130d974ef848c7ecd0fb768af0ec098a44939778d5c8e32c85574e453e4f149c8f86eb07cdec26fa358c8dd855934bcbd0ccc3cd2e8900975d66ab78d29e2f56e55ad39d553978f3d5c8c374fe5a77eeb534bb02b95ac61a38f6f8ab47d88858f282fba1a82f99d8ae08819cadb16bbf1446068b327fec978999baa3b038808ab9726805d85f1853a53123bd4fc1771ab0abd8e8f3b0dd72f4f8bc6339e6d32524a8c0c73843478da1fdb81b2f9bde137ecf48024a112c689eb404469e5e4f475bfa3a53297a584ae821f3629742b536e4fec677cbac8e5c39fe5745aadeb2a815d969fece8e0bc984c9dea014857e0c90189f3162c74177b6b055ca7507fe25362cd7a016c6a9791f621a756eb97104453779a619d35018fbc5a894c0b266d62554309a56e34b5a263a7cba991afdccb82651cb91e98c56755d0c8b655952fab38031b5e58ce8a84b4c34f7789cf0c134a2f183e7e9c1cf71b189cb52d5a051180c24da1a24f7f0eff5004c2815f5a0d798a97395f6fcead680db9f0da43df1660ec38ccc6128455ff43eb29b4110b9fc2f35edf7366c4a01e3db4c21fabe2dcd91ce7abfc7773efe714b9f8776c2a4be7567055f7de477c1cf9062de96036034d1c384b45b25dacb69849f5b1494a83d11a48bf06a11ad4679bff8d14db4625ccf977fee45e910f28ec6a370e1ce6354d39ac385344ddeeae58a4dc9c03dc3b205fc8f11447dc78f54b5be73f3fbb03762eefc49cf88e23f3470d2375b7595ef50874b3c931f4fcc4f63cb40ed481f7c137f0985c5e59ea0a777fd60feae36536817fb62f52f06ec143104776d9350a00ed410c15f3aeabe9631dabb76cb57da4a0d29b41f43d0b031d07dd2de9b425fd48648d7d58163b264085c66f5865cf5abcab06ab38c685a545646a546540dc9b920d377876d75f7db890380d80afbb4e5046425530a068f7244e8523391f22120586d2cb9419000aa21ed42ee356f4753ed1f1e55364da3a757a6fa7f95d153d101b0e051b3de1d1e65ee84692ec518c9c00654ab39fbc502ebfc6b395b226b2aff3fee3ece097258ff86b1dd957d4d9dc1373681da3ab9004a5235fc4b17062db706bd24064bad475e86daa92c506d226e1919758ddf23a64e3c345aae8763b13c9ceb612775f703aeb04d1093c656b37b42ac4a8ae5c5079888ab8cb0dded8332f4213bd8345537b77bf41663d97852c8a55bf63468f01cecf1e4b2ee64bd10b126a3b0e67ce79c608c73cac877c28cfef8f4bb29383b20cdaf12c79f7a520925a83a50083b7efe224451e73d33c937301a47e6413a5d61e7548518e36db40d06f1f1cba2ca4c2892e29b63ca2f52d4800c3bc812f07beebcb097d37664df43ec16c79f2f3497ba46be0dbacff7364f01c7e58a12ba01d7916e7274e28536684c48852f22af55e12f773e32a8c32900373a1c92f2ae8207013331fa66ec311ad98d2f501b563123f72172f8e222b3de81165420799980a3a27d67ba017c8e38eb7961464e2a68de74a0064514d8a0c476d30a6c6e102a626f5d5824ed9826aaa56a40486b50445f8704e04aedcdd270c73bfc33bc8b74241dbe129b4ddd376b97d0c8783d8bcc28191d17ae4864a0d2f392bd0087a8c4b9e8356e4bb3887cb83a1c2923ed1a0e5dd4cd19e863e6316b6ec2d08a1274691bd5217f53e615f80af5d03d7d3e14165a4c4fc46672729064b9f9430f0f0de7627830dbb5a11a8f46117dc9ea9eb6b39f95de7ceec6a2a6b34373dc4552c7f3b02fd4f6661611bc34d427fb20739d0dffb90d2d3811969eff290504a5bea345e7e562163443cefd0793d8d332e8695ff99b5f26a5fa08a53ddfe66c349eb670fa2a0c7c131b01ecbfb39bfe32d43cae304e57907bb45d4cc6eb53002ba5e555119e0be11cef8758c900020c408fb10c10227b96b3fa076f6986542f1ea52483d0538240513ce82b2a82b8f5f514af810e7409dcadda2be77eef80758a600ef77f302b12740e1e305a14e35f95b8f2ef6d5c50cf1c5bd5fd8ab9521c4d2213e0b09bc64901075efacd1a63b2d426881e283f0158281ad7566ebd2f386e8a478302d9b0fa6e443d87a308e5a3cff9d56b045a6ed07cfc3590d0b3ef4a935424d2aa16e271fd4c0edbbebf5b5056b8618d9136191f3854f68ba46f65000d7391dee293474886392e8a1c2dd67c21c332518cfb8ce181f37155c59d2099d864cf656a87daa97a1237ebfd6eee778759255ed25434a37469e1e876f08aba8fcbe73fef0cf6072a93a6ec849ee0b36bc7be95d2fd6c3b046d0e0598c0436093ad98d92cc64885dd066b300e310dbe4e7803a36097d438d18a644e325646e3399a7c1977650ce6baf3af4599f80b3ae7a4b56503fbcf6721a91313569630652504ab0b81ab43f42ab2261c8122a6670aadf5ef6d3b3d981e969da4fffa2cb29da519390fb308f90032dbc3187d605f6c01cc5a96585ce2b060a111c9bc47c633e44b4d37c7c21a74e8e594093341512ff67fca424575904b768542ea7734e68feae5e96c92926cd57a9b2ec93f083ea9d106af9b3ca39234d817a84dacef3a69982d909a0799106e2efe8581e4d125b6a02f2f63ce24c6a65b0289b1c8acf6fa1ed5a688f22c43fdf3aa696f67dd34cef97656fa1a3f5435422eda6f8a5edd483e3aa94c4f075ceb9c4d422975983fcf417fa5b41259f98679221a318af85dd29f92ec7e172d0ee98dced85eb20410cbf85323c272a14d1aecda4231d898a6a085f07737636c2675fe01e75dbf078b097090a180daf4584ca9fdef3f6c69cda229aaddf4e4f1c9fa30ec6fa84e560623246c605f11259d18da1a0ba306d0ea63cb224f6bf97d0634d6fcab8a8fb9d0309f265365f38059e20b11cb3fa777b4477b8e64040caeb664221744d956b1ab5fbdd3cc00552ec52743622c7e9de0ce173a9e8ccfb6d11ea4d9dac0b77dd107340e8c4e8deb1efb079697c8a6f1718fadf039704d05f0ecbf616d7ef5f2910919432a22116a3e8956f5fd2f85223661028c39a6b3c4874ae25d77034fefc0dfb63b31193afd8edf3e6b323f9a2419ec135f8d192f6c026e002fe53c9fe9be0521eba6965e84f403d8cf9dfa8dd5a18ab107edc9088f0465ac90c50bbb94a7e91251e38e7e59c00638acb26ab73917dfeadee281103a0a0e1ba1d50a87fe30e8ae0823713c4afb11fde9decc46160e051b36909a6ada4db499c52c8739de33897024bffa60a48b8ab0719ea6c7849f089d83209f56498bbf85d09937c52b87f9ea1cde2198df16a16f2e3e9b1496d4fe6f49fdd62bdde8f9107d3df1abc7f011fc149a911aad82dfa4e2c62509015837287689a90ae28363d4a804370023851e3ec1ea54181000a8fe6831a32d95124192c4ff7d6068781b5dcb60647f13520c7d0ebfcbf52e992c970ab1f35902c715b0d6f7517572912dab71309a8d828181e08cf17747aa84a00cfc88a5292fe7a9c3a0c42e436b62cf8cd2adbcd5392619e3a7be95ffc3878fc879bf4df7cd7fa28f1d66abdd99f77e32a758b3f4f96f50ce88965a1d0c41991658785994898aa7994f0c1bba24b8e8f530fc43e75a5fbde86eae7a06938932bdbb0f169640d4ff1f0aab42ac84fb9a3fa9d61d7c021285214e3963aa97e6bdfb0a76a77d457af030d1bc9bca4937b18d123f6d6c9c0d7eb931a88a8b39397f27c6cf4c038bf7bffe4345b0f1e3ec2877b482c2282d47b3d66f1bc4d5c652b5f93d6ad8eb3a94f6d083e195433bfdd64d3a04eeb4872cc58333892de43b9702034e288fb400355ab33da574fa780925f4d0005e9d02ddbc3b23aae9582f9d7cb614dd4cefd24c771ffe9803dc85d66f708489da940268482fcc6e0d55188489fe7395f0769e99c00382b51b1a93298ab024711500bc6473af95cefdc517dae4415f7070c8fea83f34a6997d47c2987412510d83faea8bc36bb756839862133ecb40b53070d1a7cf04b0cd7f95d97b7eb77ef0785a2f8cfe5932657806a02c6902265a2c8b9557954231d64d204a3e60b87b6e9bdca80d3486380f001a2c440f4f71608a329a679639ac2b0c26f56d67233eaa744f645d6971f07346ee116da1c2a82405bdf09b3a1d852355d482f22da920b1d2cc65f28c9ee9d724feb01b5e7c33d326ae7824d4fb1a5d78a8f3ded958c63f9fca5e8ee8b608e4cde20b253966a0c0765ebe65b7d7478f77030a452666f78f26dfb52e6e4da0d68aa0f7b6509f8d1973c290a81fcfaef88001897c7f85cf02ff554f1007dd789f7c40d20f89960fa097eeef8e7addb5187d627974b6b3a88849d33854d866e3d798351523f80f36de3b2f741072eef0049cc2ec39eb7cc844bc5d5800876d157e1e0191d9dcca21627f7bff65264155dca3784fe9bd2dea90b6ef9570bc7ce5c8c87fdc36f2d55ae3655cdf1c26ef07b2ca9a092ba23bf02f9027fa9cffcca793a2cab0a9dd4527c7710f5ec0c3b447ef1b7924f571e2aec3f07971a08fa492f807d39c6204ffa4d07fba51436efca7c26111141a172bd191f49c478b687753111d6da9780de68d54881ba4facff69c070e914be34b3260fa32e9c5b03f08e0bc639a3815b75a5b057af03510dc415125bc45011822e19f1ca5e365b572f580438a3468110ef910a6fe5df9f58ea0f08f6af5cd08a1ade0f3396d86795041d008efb2517b2af374a7d4516d187df42565d35e72ce3a79df3638ae5260936828da172931593832d4630ec81500edac9c8d1592bf089a5e6bf5880b6242be83f64857287c835cd05ff29c05d54ded0aaf2425c33cefda348e8a2be1cc131d079b6013526c717b5d39d4f3db34e930de44a6b31b085f3398b3e0e2b1617d6768d2875e052bce8b986d14705be2aeac5ba7286d6736fd6136f0b8a90dcb129d28c6cda6245a877be184561db2a33043bedc4521e4181e7758b95f1b83e18ad9ecb6af60a7399c1db1afb5f71def5b2e5b38d5ee8a89ec956b8c4cc8048ac3528a24606b22284e1e179491efd841a8e48ef53fee1afe6b349e869bab63c36d7c8341a462754148c4ab25913c1b9b616d5d0a3f47080f33b16d47d442788ecf771ac377fef36f61a99d8e6c90751f60d95632bbda2941060d17ff491e8e9f5f60f94d988473120d970bbdac5b57367ba86466c5ec5da477b5223e25709838f160223f44087cd53d3f5bfee5b3fec08f9bae474cd198c3b88c23791dd5d5b8a576cebc71339dac860ee731496946bbccaf3ae3fd8ca804fe75013ae1dd0ec1677f0c57c4a41b1db262cd2e20d6ac72d9e7dd5b7ff9b0aecb0fd8544ebd36ae4afc134b95bc70994fcb0b23a8677e1bdde8e550b0154c55d54b268fe2d827056291ce3580656740f6c6951339ff04e17914852426092530af26e26fa1f718413615d5d205700061a3125ce2d00de2c4571ef6adab2ea88af658fb7c902bab5eec65fd3ab5a113ff51d60ff3f63f25c2a2d0271597328e684e96754b0fc7f331e72ad9ab6300130046c40aa3654b255965e53ad08d0b6ce2cb2961df66fbc8d1c9dc7cd08e901b95cb81caf7b25c4aa89b1504ce76458f2cdbd1f9df801b114e983f65452a1c3f0c3e077cb7bacf4411e3f846478701d3a8fcb379950bc9c81e8a67bace08cb6a442249b0b18feaad15c586e3c4ccddc841e46daeaed37c5a250d3c9982860a55b3740e9925493918e13e895b33461182879a67825552426353fc073172730d6cd30371638b1c9425ff63e15dca68e1f24a62ca3b9d209ac81710cb1948024999148a0f1f15838368ef1727c0578a0c1278e4cb39e426a1ea938f0286d0a31af6fda11efcba0fd0ba5088c3bb7b94466bea407bf6cd9eff612ac0e69cfac6369facbe3b5ce5fc4776c823cc8c667dde6d56a48522eb7edf7ce808f8a65490e2154b372378887b4202db9259e9bdeada8517f7fedc7c805b0bc0471ad3bcce650fae7f02cbfb72d5b346f02cd7cbfbaba2b7600de232e0d738b523fac702690565894ec8fd9393ffd088ba90069a47c07c5c8eab5ae3d20c96c7eb4ae5892b0f67a142ee9991d94bdd4979601cb836ed66704aa727bb6c9b2874544e5c12e317c0217b30d8c621c44e84b2f5921c85d93fbe4498a5587a71d7a17a52465126835146f6f07c8bf1f23a442a06ef8bc1a1b6e7e468e74d6d7ba90fa814a265164aa3fc5fd75f3dfe1d80197d70baab1584ad60c503aafd2b3c82fd0986555657c0b766591f074988d4e6cefe28022c912fe9d9de68777872f40f576735779ba26ff78c66ca1d3fb6dfca9cf2b260411a65e9f0581ad3018409010b549fa46a041f8ee23337072b9a8746f782953250811a2539c35d307d366fd5b07d4319086da7312f5b362fb2f636341023a44ca1a94956c239c5085d5f9c39dd3b46602ba0f7344f59892b038f923bbbe70f4d3477644494b7709e4f63b0f0c1e1a114af2ced193d03e6819d0940ff8cefb77d8adc1e71258cbb49c908ad79fb416bb113c3d6e07506fa37de2c0c70c5bf405eb0ed191ef50927ee7f5a59cd5510aa3fce8e50310c630d90150f0af596b545fd4fe39c6b37260be3c48d1ba82e4d752d15736510774721d03105bd0a5ad64994880363916385519a1d30048625e4dcb4c229ef05ed93fb44937b9bf56e12483da57a68db295eff4bf9ac0c809d5e8a9f83991b976148c824f9187ee33d1d4139f7c5d0737388c818d4166893cbf7bbc19a75f2b956992b4122f016a7f9d4baa4e1b3c6636e51b35c71b5e84f770bda63df368339de61863885da52a4e3d3ff4400a6a1b420bf9b8d28c2b4de452139799652349083ae649a9726bcd5319f85298235e6ff1f549641420d5d66065917f686c1752b74804c9764931b8e07de8f70da1b0b6b8d1779d68154fc26a1b4381b0e530a2a732aa35d48e815142a0532ac72154377026e442af967f0ac702d2970d48f34448c8b1551b872b83c5725ddf996b925aca116edb4cba1e14737939c812cbc61a0fdf6697f812cef362706c5c92a26504b320f21af40d76df23b482dc8a4e8e1498cbbece89432b6c29970ee6fe9cac788a600ed465395bb7dbb1f19416d7123df972abb1be3f45c4b4b6acdc54147bbfb1303c07ab97c4cdc1a5d9e2d9a1b141b44819bf72f1f111404ea310b5bcb35717cba59aafbc116c653ad490d855b75b131b55f0117a014d010394f87ea2d02d364187afb82013f36f681997543630bf8213936168953f3678789b4f78ee528591dae83203cc8831d89a6faf6d938795af225b90277e4556fdf65e1c5be201b9a43a915a040173b53b3fe5dc94dcab0ffd141189fe7c109d9c202ba296f477fcf2c820bc64d807d489d4b6557b845245b75b1b4b7fd96e0a70870972e0ad42b59e8699c4a4458c9a5f76567f664c9c57879165772f6539afd5b4665c8fa96d6f69650638f1db2c4ab9bfde4e032e21a0fb8b0dce69870874164297f51d3561e960448b5dcfcf5477b66b4a3f79603d1ddac0912f0db8693815c5de57608d605c45e4b320df3e33887ed86479645c46ec4f488ff5e633edb5d2ba908ef9732d8afc58fd6d752a3b9367e45d8bdf488339a68f4e448728a893ba721a8e6139f939138f92ee610f2cf585805320e5be2c8a327de54b69f5f0443c7df5fb720c1d4465fae09605754724bdae8c70218c3c70ca21bd5616208ee967ef39fcefe420eca03940e6f27bc7c79ae5da08369f31861951075bb39027ccafc57eec0ce0c0824b8910326fe36dce9b80b813f818664f4acc31d40d4ab280c205b4eadf6fc6070bdbef2708220f04ef418e23f6b843d04aa42de0a6512ea09bfd1dd295ce78e31f89c9a962f5e444747b264ee7d3f51f35d802d2432a9ea5119582274b72fa3141e8be3af98a28267dc6c5acdfaf1cfdff04af1ce8add5505c08d8e881caaa8cf2481560d9982817e92826bca4c95875c34af524fb9259569fca087d9890447bad9a5a2b8fc1c0dcf83accc82ff04705275a710601d292e5719fcced686bb54e64c7c1030a5c98bf2d95ab8ec20523768514d0826698d51b61d0b426358478c6e5770219717e3aafd54ec1d5ed03de12b47bb01ba5c2956094d4ec13c440c5b3b93cd927bce94e6b0e002c76d2c4f1b10e434e9d6fb0c9d9cffcd94983fb2e2ccde21f7fb1e79e8e9f4d64e424402259789c0bc808c68f2f6e0a22840583f389afc40e1450f59a3f5eb3bd87065f0541579810223733e23a19bf5e6108f53b0b47c3fb2817ee822eb730785b6e8ba1c5f660204285e8d36df7fe9aac18432471056d7fff65e9924a4ce847dd7cd205b68d1b3f78787f6a5302f07aa4b90b2fa3b06cc42a3efe8d0fa3a940e3bba5d3711bb9de9a16e72691a5f5887f7c46d676288d6735004618d29421e87a90aac63d284cc9755f39365694ab904e823bf52f59a5bfd1223e81843e959e533a241b58f7724a4d308f13ccf7e05e3d74d1a4ef3c3d459724d3d638057cdf8fd0dfa35f346e134619a4773305b98ca217a11ff4f4d3a51cf863a3eed57575a5f456ee9671e495f5fb91774070742ad6f920e1d8fc18108300dbadcb7fb0eb03139e5b06cb31ab619670375cc75efc763dd3253c189e97a228ce119d8c172aee7034086b87e797a661d6e6e5e63ce5d177ac8ec1e3583762bb3669e7c2e85eabe01939d80a1f4d0dfb4331a88e30b8e95e0a27e9b5fc994cd95da85f73f0b8ffd62644781aa32168d3f475d82a02f585319f5aac778e9e8f917031af44f7f7cd632201e3d48087d22d7e4b7535299a192db9ce10512233f8564aa623f31f0b394e6cc41e28024b243d79d132f478b2f8575fa663e536e8c67a2b16bdbfccdca92d80757a4a60564b37a0133a2fccd97d59fa28d4a988638f15d59bdbb244583db631d7397ba476e5ec0dbf8ca4ea78a01e8c894dfd855d7fec1c563d5eafb3cdd51fb089ba9ad776a9d8a41981a40f0f2879c58fd59a4ce4ab934f6ae6bf8a504ae24aa1ef873d8c379946e205942fbe9ed36c190997d421f5b1f75731326b16eb9234835beaf3ebe6fd2afe5c337fb2b904e6d40989dfbbe3f46e21d70725a9d11d8ca5d8a296d7b8aad0fcab6957321a1cdde583155e80e03e9814eb57c58290562476d4d6d0cd7e565819278a4c337913a2bc631ad94b39ec6aa0a0b0281c0df1d6c4d09f3b0532715a8ff363dabe9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
