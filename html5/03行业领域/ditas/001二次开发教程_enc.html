<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"979f89ed2767568304e7c036d05b4ce5adc6de6f7dc1e2606d844446a60251feafe32cd3d0c32fde9670ff781d8543384e710eaadfd5eadcc88b83667b64f01cb250780bd6ceaed54186f0d425c4ed9457e956d1d6d41e029b8c3f26848f00d545d7245fdfcf590652b0a51a791c881742fd3265e67cb1a83078b6d671f8fbbb595ae9bf97b5a0de788adff7f4203c43f0f3624cd6995b3dac8e992762c3fa77e23d12b45bee0352d6e5697ea980459983ec76d8361e24ba82693b230ddeae5e423fc2e77223a8afc38efc3b45d9f6d520f407673e3405ce54e448db902b434933e47273c48b25c694a14ca5115dc02298761f9acfcdaa3dbd41766ae11fff88a2c068a2918ac1868fd725ce9aad2f262e6fe42162db4b77c425e9a8127fe4b3019e9c8113d3453165151fd54da131c1269593a7896479f1b1de49fa1d1153f80a26b759618baa7cb4817efc36b21d5ce37011215e1eccc3b9b36be16ec88391182cf08cb588d5ef249848a8b48414a5d66378fbedf9550bbc34d2f0b5bffa3f29d6a2bbb1e0229a6b1efafe4ecc062958c428528367b74a8118a9105647c9f4bdad7b0de581493003406fc79893c08cacacf3df17dfbec96f828acf3f0ee084e973635e2dbad90a73c73f3db82b207c17d490cc887dbe7b7afb8604386fdf0394ed74aa92d5c595ed899388b121bbfeccb6bb83ca9a174fdf49ceb7498015ef691b12eebd3bebdb75756509ea6dc50aa690e0e32e003ed79a62b1ad2419e6391614da897a08222f004637cb2be30c4a2330dc6f44a5091dc7d904d3a6a060bb443e3f34654b030f67e2a61fde15fe57dc6e7eac2cf38bb57464ba4e804dc1e845157cdb7c1d4b3825e2f5d91097f533615cfc424f29c1fff6f961a2cd360d281dc197c44f4652737c0d2d171c978b8bd2c10055ff742c01af4492976a98ad84fecd48ab6577dd27b1c0de20d14ba6a46e5597f82dd17187000d9f7ba5b30c0a542fe8f883aa70f1c2f14ea1a6740ead803f6a8e1f51de385a02f4a2af7b5fd3ee835976dd1a0bbcac5a5a61249f15acad712ecc6ff84fbba7386b22c492e142c7d6aab7d94c782e01b5d7abbd478ebcfce108e8036136bb1e9d9b467bd2400e14c1896213a002bf4b3229713434f01044a744c2d3b23ecb9b229475c518b9ad4dd4d158c65a5c0c4a9995568ec96f49da9ed955a2458631ff82eb767f482a7cd57abdaf1a396aefcfaf75855320c8a8e78dd751baa80645ed18077bb8182a3530b4667fd97cacfcc65e6129a2da7e44ffb4bbbaf2e3bd29400f4beb5f41d7bff64d5f681a93ad13f61d8e545fe6a7f05e13ed185cf1c1e27f9ef33be8403ccb83453b71d31bed53f972d851ea15bead4d66269e0f616ea74a870fd965f9627a13fbc3267e46afecd2f901cd0b05ef0c39e834e9ede3dadc96d0fa50bc4d647caf3323e6312b569966c90879e3260391ec578a35327dcc98125a7cf5f80668315830da35d6162af6b3ebe834a64f53c5e2c157c076053dcc8c09ae4c5cb79ca790bfc8606c524e525b62b5af8266b36ff5f5f8ae56d5e114295da3b21d9268bebd355c4281240637f547e6c2f9c792cd92bc03ed2941822f792ac04c37ae786f02cff38d1145c4cd005a40b850629e5ea00d667891be624fe412c1c7662e1f741070cf6a79b4daa0be22629a7bb61938c2ce9e647bf9b4c8ae0df9645cebc9b6cf7cd243eef1b38c9d5a63881a2cce8977fb933909787e95c104430aec5474f5297b8965fc2dcc55e61def7bd5ddc3eb1cf18e71a8bb48c77b3a413874f048553e0f3d26fe649602ed5b152d8c6e696186dc16ed664862bd315ebef1006156dec89c00fc566c34023d45633143e5f1ae9f2ec3d692f669829c8de13ac06526880e5be155b17c109c0f4194ae481fdec82c1125c3e173b1785df4d83cca790419a8ae6521f4985e9905b9387bf536294f79cee20dc96517e20dd0694404a6cf5af4096f9229c699203123231ff4355a480f310fe53b0a4f11cbb5d89849cffdf9a599d91463f89f30e1caaf1bc0b14991c5c23ea490dc048a211ee130a8c6afc21624e58e941d5179ad8c8f10e64f69feea1ca3f6aa7da2aa9ed8abf6afb7c6849072719f278a5cd22683fa71bf12607c121b4c3db4ca8564962d22076d8d99efc6351f5881d77227e68debdd292c026fe2d97a35579dd8baeff81b8ddc0f02325bc08ffb23fd9292de0524401ba6c708d9dadcb61db63cd36dcb490e53bfb08a86d6582bc0b3fa67e9804a3989dd39d9784dbbefade960437ab85c6e7f1c6bccb34eb2bcd18a631381755da201bfe7267526d380536f2329767471f37cc7893cbaa411769743b8e5088c3d7d7ac494f180c4737515a1cbf8c489d2280f8d17c635b8be4ee0c8c16633f7f15aa2c33fe75c98383e75e9af1dec5a5e18266a3faaaa90df344dd082bd77e41edcf10285a7ef2fc6377c0a8cfd4ddbd96b5087cfdedfcb6309b98e4cbdc61d955674ad7feb3270020bde9cabe1475daae781ce62785a7191e8b8da278cd247fc91f261d839b9340f7c021d461a5e68f268fd52645437f1728c8876f398b9cdab18ddf989e715ba0d2e56c8f62247987597de8cfbf46355ea9dda086f9ef43cec9ef3b0a0981abb08e2da99b19f4699ffca4e57d02b8c0616d0173dd5b011bbb4847b1ca57e0fada67957b3e49b90f8d839a2018d29ffbc124373c528d8d705b99e4d2463b16e80f23e66bca566b16200975bd76bc033729cb8d4f7454e44af16cc987554e3db9b3fb8cad6ef2b16868f13958825d1285031df4085e30ab1476d2472c27530a3ed0e9b5ae0609fab3cf464614c2d898fd3f9697474a21bcb4435dbf5d87e1867276411f945e2d4874edad7ff139b13ebe80bd21d9ee5aae75ed66a80bd88e7f4ebf245d43d509d698e9389a88c24f17547a1e0e699526c7ff697a6911c44a215f8b8df847751e76b8fd683eda92b4cc2d1be8cc58c929029b128fb090c830e35548410f7ffa6663e6a5dcfadf330cdd926efa393255e8ef7d805b8c605e59563b78ca3029cde5fbb1a7853bb57fb3f8d24aa9578ed4ca3ee10d4cecf11e3e10cb8b9cceaef75b4392e14899317a0ab69a411ea6f2335bc7001ddd79c0ce2a4a14126d7b4f96c997c86a708e55f6cce44dea83376cc38b323575f98c40eb36df317adf1a333dae07015072baa3728075828580b440d738678ab7458fee282a2ffd7e22c099d36f66b2105e117b0196451ea2bdf9ceadd8d33257135185bcc8b95194493a4b6c87f4da29ca39faee666659c5013c2fb3141587e537a90414839fb4bbe3de2ac79c6ba6032f9f958f1cb21edba56dc1471818c254c8b14751c83799b396e0d3439ba439a4f85edbc50a0ea2c86c574a4a538c8f9c75bf6b697d25f7a1dd9f0a9739327133258f84c2439be07ffe667f1ee2331dd32f7d306f3b74c0641e75402de979412d74f458258529112978420b209956465b451535a9c05c3cb0da388fa37b68dc6749288a1b26bc985f4e9cd7cb188328031ffb06aa0efeff4fdaee5c16606ce1cd69eb8fbe9625b6f997c567ba09dd9589e6d6c69c904bd9ddd3515c3b4a1b127c9d79e4e2417398642e369d46b5440b45d633a66dfd54a2bb6e93454d36835141490f1c1c5f1b5d8f67e5f465454b8c8eda5cabc0ac5da175336332a89e98123569c7fa7b59c382dd946728733c1a4aa648bb2fa662ab26e07411c833b67f46f75a47eca0a25a301ca57305e5a20e4ff1af3b4cda7a351e698ba293e25889521cff5255f362c0afdb3dbcd23a71c3640925ca02b4c98b5576472f437818ddd8845dcacaa7d09b0b48f62177f2fff517a804c5a1b7eefe6233cb1b9661c710e9fd4fc745a0d5f03e13605cbda7abb4592202154ed76817061c1a651db62360fbc63fc08624b82a411624721b77748f63f33cdb4ec2dd86a1ffd37c969d863025805a38425ba6e06c3d09a4ecf45371a60e230d1097000c4e119a64f426e73b368680353b710a693f53ef92ef8e6f29fd52c985fa753a927276f15de71da7d295a926ae94337e03968577a50a6ec8722adb81c8643f7a96427e6f66b67abb7a68def110b3800664c0b6635711b96025dce37377d5d466a53b277a8990b6f3b392a2fa1a6edc6bd2541da679561de703b42433bed9698a7c0c248fbc0f5284fcc68bbbdc5ca670690fe18adfea9adcfdc61ce133ba029ae32079b0dbe6469326013bad492ab6a4269ffad6e1852481372c3fa1e8da74d342407e5a53ba2795cf10b26e570c07d721999a05d175fbd33eeeb9361ab8f1bb00f8c1b95753b74f25030a8d5977f40e9fc66e51a13e60816b72f81a25e6b06234eec35b2451acc8ef67d70a6c4e5a0a53feda34447257430fa9b5eddef51ff4cb5750481dbc58e19d833ca338c331d89f27ebf530530fc308466672521e37af771d68f0d014ea3908656a227fdf4274aa145a96907600b63cefbe830b9acc1edfdf0993bd11519c55a648b9c371ab3927e4641cd2b7d2aa32b68f3320ac0014eddfef1671d5fbf401dc620eccd6bc8c537aa44b87641effb2d63542b76b599f64aefa228ec0497bbc074f0b6d8fcaea0582219a9ee3d7efc905a906410f665a2b311d660d0dc04e4e936cc819f0210e4c9ffe16c1da4200f604670086d9a5d5b469f41013a1083ba8d79706aabcab0c4941c63c2c1643112d21668d06429417983fce8e2dc4b41952f1800e535348dcaa412b35222a6bd66b821505f61c692847c96f33f71901cdf38d8a46354d277d6ae0eaddf65111362535795567517a47eaea814e97d24650c8bfe770e10664967b7346ec25829cf77ab4bdaab126610ff1c7f1434d46c3a44892d054921364b0daf63817642e6e2ab69190ec753952e0645afa1f9ea8ed4780c7e99f2f156c623333174538d5d31107fa61d2c8f932e7759c3fd46d5f0ccd205ebe4666f1aac87fce8a6b98bf9968ccec61ce1bc3056753a4860b0ed1cfe4911530459f28406e1ff7cd3b1a9a4f346c73ed049607e45bcedc9071f53685f4834c207597d33f61876570408c84347a2e03a0841755369862c45190c12004d08e065d70b91d97debe0db9ef99588feb0ce6505324ad467e02787d79f9e868ac2e3518d2e5902e9ee5ad261f3d45fac262acd88818b247fc014c98363c03e9e0466cc40bc5f1ed07af60098314ecba9ecb3fb497a7ff3fe40580ed0ca6b8627251a9f582ab1b5af08b908916708658c47cd23a7100d7817d047d325f9044c8f32169de36e95cbd009440c6f26869ffb1ae1a0b7e0ea23b2307ac6a7f26319bb56ef6b6aaf77f9c0b5cdf1b508bee872b99124a95381745124532f36795b28795f5262a20d21c2bd48d6565d1ed4128fdaa3c192ee24245e7106308758b95dfde77ec51d97d85a550057692357b875e164f92eaa18414c0763c6ceb79cbbdc15687bacd8186e4fd3a775eda4801d0194e68832f128d62782e1cb9ab83849b49206264b1c57a14b2f37a5c9bb19301ac44c230ddb0c7576e009de6c343266f47943ffd25c7b1109e6aa09f5c257db37841df198b8ba7bd630c3b840b42da787be5c162d5de1a4d45bef6b53786164b5971f5b51e445d8846da2f0cafcf636e086f7b6bec3cba087bcd3df15525fa51e0fef1556149feb4fd5fd197a0312818159f7d7a4a9e3e2da3c0ca19c2fc61d38d254539018a494660f6ec1ba65965517d0b394288ebfa0a78330b34f74640ce36176039af6f0913e4e9626f15663004a219f980a4964dc8d2012a691c10777a9e9f0e2d079250b8c91c7bd30ed493a5e42ed37d2705e09c3defcbca114a7ad3f5601781e7f6d78d9de7cdcbb0dfceab7aa044d3b4a82dda4525ced75768adc02ce1788b9dae5363df86c1f4f8b0b4e1b27843bc05bb25a6df4ab39d7b9385779d9d6afbafa6ea93e812214ed99fd0c4cfc02a5f527719ff6602dcca9acffbcf26e69ae1770bed51978e2857d387358d14ba3775eedfd4676e0d49fb84b0020989cc848b308a077121ba409125276305399a607e29deb1b7deceaf487da1a9672004584c3f0e8c3c163374740922a188127dd542d069e5e153cce60201382fdf72ae13707c41ee090f37b732bb974af116bb20162363937d9b8f9cd81c9c61d377ba90376eab52b2df5369861077d2b502730001d37151cbc0322214d97b756b9a39ce0bc32f59472a82e0356463a7499a7bce307b0e6f91e00e045ffc60c0e9b0721ed0aa2d115d548c7417e9804e0955c1e04d6b1e383227215bd950a6ef8dd2e3c152fb3e1c24a8a039b536877e4fce184ebb30fd31352259e17eb4ae7c393a50fb1a352a3bb9c75a5127fd7ad9c2535f6c349cfceca7f5f7793be7ca88f6de2c04a2cfe3b7d03506d9266d97a10578bca53092e4eed121253a5bee988da54bca52453260247368dd607685839dcd050456dc93f1b7c92857c248ceae3c41f63a088a00485c00b952cad10d1921d8871ec6670d4fbfd17cd997f4e768a252175c48192d86d5a29c91c872bc41ede3d64b0d0463d9b7d111cb2408ae7e0df4b7b8cc5860d0348151ae25f601577899b03d3bfc695eab298008340eb3565c40d6e0114bcadf9dcfec39c9b6871623e773f64a43134b85718d14d96261b1733b1010e4868285459c91dd7507a4ed60bc8759edcd13def23646fb363ff66c2947e814ee8448c4057f60ef0be20ae9a9bc30e83abe6c9664b17b69f9e26d4232eeee57d1682e427b0d3f86cb20098c5bcad0c9ad4c47748aaeb2827509854efa4df87682c5883084959e686e5c5c83635d8c92854ed9fa1d7cce0118d1962f7cb48d920937826c2649f4e05ff933464760db2d148e39f281e6d456a8e75dd8273b61d71d8f33c44f1ab1ae9c89f9dd2ac00a9626f5cc270c8d9b1bbb512ea67b57f45a295a5b5e6a70de77f11b6e9865e4861183c3cccbadc1babbd1321519efec8c74da5e457b34e1b2540aa6e41dda6083a0ab63cb7dbfbb2496b4796bbcdf38f8caae62011377534686145725c6803617e83e92572ec0129c0353f0c9e05a70c0845b3e8145adcdca5e15f846fe99b3e96558e011a924ae76f6b7ce9a039ee0cd915d6d51776a56c44ce833dab198a37e8d772a2416979d24adcde447954300a002df9f3bfff120ff0d5da7e38489a32bb6ab1ad2981af01e3cc8fe0333bf0a1fc6fd7c12204d262428c089517f1e0b49923a758059fc7d8f91e30602b9186f94f6a997fedc3881f3ab0260fe552e1a136f1b599090d52dc91a0e518086060273e0f6a26f460c96ebfa3bbff002484fa1ad7bc6c9e3adcf0b56de25a0a3bea2d40e1a56ee44375bbd380967d50d81344ddad2af73d99f43fd68503e10d27f42ae146f580f0c99891aa7ee8f6b55d91312fe2901da3f07079583996b8a52537dab26615ee3030914f403bb93c64725da112452c0d96cb7fbdf4b2d14baeb5789631f104d279e9074c0227f9752db9006926842d4c158124fb751dc545952556d16491c41905ad914cd794c200133ca02e0446bffcdf065c38cb08592fef309589bf607db2c3e8bacf7ea6cc759e508f4695a5186cb3575743ff556b7fe9144f6d174d6f8d33f7ab48f1367821a190b735fcc5095021b5fd8f46fe8a63f2a843eb6cbf946e4889cf323a9c65be2235553e6fcfc1cd956f15d54a75faecc1f0059b32866c4a6f7fa3bd56aa9ef2e25a90ff11b1db003afa1e431953ee7544855ec8cd3d21ea65a928bfe1f9bce8a9faed3066bf91b6ba500b6968de2d56e00dc1784b984fd23aaa400940e05b868899cf18fa0cb75e206ea4dd12dc189c6b54a720df5dd3af503a033b86afc20a1c0563710d9a6b0c1035278c987a1f8fdd5035874e16b512e76b3afb13450a16eb540567143dec52ffa67abadcff1a5af9ddc415a9552996a908614291a1487e08b0f932b3583b37defc155e7af5b34def53612282ba255af9956ffe6aafcf77d85284f68677c9fb9e9460e643e9c69c47afa125a2834ff6aedbf7c4f1350c63d9653d9e8061c905ad3582af6dd950bf88dd2f6d0e3647a8dda6aabbae8928fe2ddf65c2e17fc30923d131ac2b12b765d73134b37e0a8d97824b314b22ca5f7e73e08ac0d74e003eef0e414ba00eca735241b6697c2bef000a022c3671893c7762e1cdd1ada9900598b85ba785c1c54d8c65ea7cd0ccf500bf949107ba2653efcba76796772bac6d1992e14b72c6c2ca0b0f749aea022e29aa5e60742fb7fac94fca6da41e55c25dbeb6c5f6feb72a150807ebe8e79f6790813465ad4cc0fd864578eb168cc002b488ed2fbb85caebe77eec7ea98b68fd6d7eb0236a4aeac69a28c88527a2c3d67ef6f6026ea29ae41a62548ebadd834155863309741585ba9b883186e64fd3982b3f09dd649b1948ea871932d44d34c135aa8e6f3fa58be99ffdfb63971a3ba184ce53469f6f06d29f3dfcdcca1ac927d23fa4c8e4c12f517464ab57610b10b5c95bd050bcc2af896158f30f62540a5e8aa0e8c2b145ea99dfca5c12ae3760238b60e85a4432fc561c3ec3754b4172d9a9f24f7d5ffba2e893bd9ac4abef76976549c80741065c6b6a35304bd325bb6519ed2bd00da426c00fae7f41b746dfa17695fc815c81e7228a60fdac09a59297c4d8e1594c9b414fecfc21622d005096685cbe925a138e3e75f53dcfdc74f83b30d09f21aee878fa3fb6040e7b9a8c6a7ad25dab51ebb829861b427a6e5aaccf9a44047114faf37c8e362b2992cc0f24fd8ae57326402e8b143cf0962927437eb2ec403ba8855e649c57b4b0c0da1e9b824ff2c34dfa669dfa7c541eea801fb76a0688bd8bcd2c4721135889b7fb3d22e5dd0d6d774ce9b4f677ddd549f148e5496c237395dc4de5815546fbc211311b985c04efff30655dd8d1804a473bd6bc52528167ff1522abc07f1e15af377aafde50ff3ea886ceab5adbc96db735030ad7fafd8b8b0e98b535b176c061218f796c558497db502eb79881a8ec591c5389b11ea3df8cfc39767289abd83d7b8e13878463141b90caf92c2dc9751ec83f3800bbab5fd9160b5ae7e1e28d3c7630c0170d74b07ec0eac0b8cc91663b4231bcdd8919f9a656141a03bccffec485d159a3ee8ef7787ce0e3bfc7707d88683eb9f5ec0a0009db9e671df1beac429352e87cc4a7add9955376b989252addb052e3a737c21f6d94b46fc78b8130ca356172b5fb32a6c73887889ff6ca79c47710a5a6c921eac44f403d48032c281e57915312db66fd3326ac1918201edd88719595787cdaa10f124e9d63b419dc761c3d143f97df2c8a3f47c0d76dd0fc14221307567055fe2dab28a621b54e6f602d87930d6e844348c5bc70e2870e5bbfa4e5696955db3d182ffb454b3c3b6cf42402ffb4dadbaff986ff300c0b4f9daf49022600f0aa704cbe86909971aebd89307635defe982fcf02cd0f1d6d2465545ed005081bad401176cac3d68a99fd9677b066b75c4b170748210fbbca7c9500386832baa2117eff211d76bac12f903712bc5c0c8ac540ccbf006fe3e6d0ebe7a9ec9fd84db080d84b12325e3a6d21306c22c01703f42a25bb9a41e0f03e844869a370de6b2ec1e25cef99f145eeabb052bec388d8937d7db78c17e7d7ce25a23265dd1b71452e4fdfdf0452572b5f92ba7259b8eedda33b45aa0426fb1507be4e96f381af015602cdaa2983b3221818740c19d3d00000e1ba7a4f01f205086922c1193f96a1869e6bcf4c1414b6475623b1e535b74c87a73247f24d6cbc21b025c534eefe3f09514e3c3048b83815e21f2657ee05770d153f71589acf1af85f77d55ec70a8469c369e8774b33af8ae600c1f6fc1162a1fdf57558681d67c0c113697bdbb220b811dd47d3d88d3b35dbb5dcba90ce979e5a9f724f0c23b63b027ffa42573f72e11980b025b010c30d1b1baa9c8d3cab5a609478aba4cdd9fc408cf01e4b79916c156ef3835f9961bef5da2812215ba63ba5c916588a716079d8c73950bb0aacc790a9504c12d42e9a5031550b8b1b066eb820f9b923d5ac452018f850b5d9c113261e29ffd6488658a9ba723cc1adfd9dad5712838f88058ea26ada8d76f24dc56790a02ee755cb11664639641ce9dd66e5ba0354d549657b22a87fa17b362c12e105e84dc12c2fa1deee0d418eabdec35ecd15831fdd133ecb33cc1e4a80c9fffe66977bf205717f095169e97ea7e274b4e4b3184ee6e12565282f393a626df67a5a82f0529caf7fd3304bc6bbc361bfddfd3239d92ab328016ee0a2fac72a516f423cf9c7b33f13ca2a5ae5228b680d8b688ec1e027e2907fb6388247d3aafbe4eed3e13c2af59aa8b49ee92504aabdebeb641e06f1678fd850faa6559917e9e293889a7dcdd9e252c985ed1e5168c44d1688ad88f5bc276d9179d733a61beee19c94e8a5c842451b06220be28b6844d1729e44df84a38b49cdecc4d821cc7f2b55b5d4597903e5e64b2d98b16b72cc38c52c0bededee0b8de61bef249bbcbd01091ebdee5002386a87981769260dc4883e6e499085ff529bb4744d7d5c82c5262af64a5bf2f1eca506d494f3e88e050d523e54c77a204853b44252246b2117ff744cc83fd0cfd7ba6c918662538c5507f1a7427cb3ed9cd045452b4a6be14e675549e27b162cc649e81a8fe5f59b0ac9ff8ee359bbabbb56453e511a102cbc92873655f19c97cb78a53bb3bf4dcc91c1d11455be21a40889c1d9f3a07d8bdfff452b5935dd4e617dff7fe33ae7e15a4692c999871a634926fc1608c26bc76681db34820a8b1d7a261c39f6a57328b4140d76f13ef73d6f603e90b3e9b8610fdcb35b4899a7e11e9d22c18ec5c240540dec8574ffb2094554db7471db82a6edc1941c4fe8f73fa96bac0f33e2dbb748811c48c38ba6f389e5762cd0c1e9411e972c8c250ce5e66d1a07cc291ff946154e62a5f27a149d25eec7c0b3e0a87b38ba806ff1b6156c8fcba613476abb8051cfbedf55b3ef1651108df854331578eb17543e6c56c6e8e80929ecf788d21d6edb4900d2adf3c3436db7cb4385ba25f91a4147f28c5dbe951ae602714898ed12fa24e51bf6f555d336d865db72917cc1a24909cb14d2160ec85a7f733b8335a700210f142cf9c6a506c72ee1c4ebc4238d3079dff9e5fb6d5a4dc9ed97c53b5d7fcb2c78974e394f2400e1d2b4605e800e64fd1525b7f21f1bf9d02afb9a94cd8ea561954977f296f7b770e300be917b30e9cb441e53d34bd1e32a3368b3e651c3447bc43fbc9a545108618366fd99628476ea0acbef0dc766efacfe65ca4a8ab074d28c51369eff74775959fe91af73aba799a74415c55f4fa24bafb44a5e82c19fdddb1d1b0d10cdb79663e6079f8f2d1842cc2ca31dd4ad72ea468863833c3e348e6838963a6a975528e50e97d4609650ee6ed5b9c0dd7cc97707104b28219f78d5c2304a4903ccfd158a049405d678dc5fc2105ce19ef6e85d1f37c9e3070f6f7a2dcb24f00a49a2afb4dee79a64735afbfa2ce1123f6dbc9f30995e1db8d1b1672def5e4582d0e7d9f147397dc1b76d58a805b2a366ba95a7f92d36e41576919b2c40f3b6a1b3f55294068cb6d091506079f6f49b982f84486b17a40a5a9dee6b7a8af8c1236341a742bc436416ac52b0df08794e3f64c7853d2a675ea57b4ce690a9619c2ff092a6856e81292ae0d71826765a7564618f865e32c3f389ceb514f7a367162060291decc811cf3890ccc1108ced8657a19d4494a4ea7cd7f9b0d80ab5968e923677352853652c99cfb4aef994df55c5c35a32348b4838d7661c2e9653b5042afaaa1bb6752775b9a3789cbde4bcc6a24a0433555e05ec415468b6acf45ee977c6839e8ce08455eff5b07db61883465ff8ef2e6bbbca788090f8abd78d5b616f2c31ec43011751f1ee08928bf9440efbf279ddda4779d1bbd51b1a6bd726e98c19c529e13e0f0e395da246bb0f8ed99ac9b2691d84915407dfa5fff8b262dc1efb0b4b96230ded7c0982e7864de6044168ceb1d551d44155593d5dfdf687fb259147627544870c6925587f9a100ca6a8ffad0a36ed8193ae6af8b47c645e1e7bbfadf6eceb563886b31b4237e58d554feaf2338dab27158916703243af76327a6b73b8ddce4b41ef3de42c4d054a012db1ec7021db8250b9a8c2e9e56eee78b029a546a0b881d05a99f86a0625d05fccdf3397842bbacf02913d3c606a7e0d8165651f96ff67f97b27bf668106c0fa490ef71a4d397572707eeb46e7447b1af0b8147700f6643be3a372101cb2d43b57698d1b7a01b862cbc673777c806267a5892bee18faf24ce552fb3997c7ee93c3c94d21b4d5638a9bcf5675bf4b8d3b98e2dc941bacdf0f4415257f7b93f1cceb6d478bec37ffd29db383afe2946ef8281f1e0ab7b8c2adc1b597fd67e06ea8b866467485adb977f9cded188906acd05c3c0cc5c649618303ab1124b126fe52ee1f176943528afeea8966d5de3a5662541159110dccd5cd45761041e5310dd5fee1500b496a063973c90e8ae3b7cfe84945074368901679f11b79b2fe6c6178aa358522777d147d8a68235215fd6ab78b3b159aa806473d7bb85e396b29b4a6ae0f09afe7dd7bc3cb50adf11d2f2d4b43374d079dbad5926ba70bfb0f14939d10fca917cb3a988b24b86ac4a983f707d8c8814902aaa8588dc0305f06269f99523dce0254541b6bc463fd35131af9999474037197f5ad598d8625c50b3945172927525b6ca245aa1d6246032c5f38235e9c7bb03f193673af4ea57a18b4f1ca644476d2c980a521aa25c2dca47731a113368bb96192f58e01ce6f073b245da1c4ae7d5debeb5ad69a2e765cf3160713cf3197b346a7953f1f817738e882bd97ec38daeeadac0e6cc76fd691a403edf4e8db19eddc6e50efa4f4aacfad1689504455c3b154981512fef50458bd0466138ee90f2dc601095fc70d8a89207e9835675bf7f301dd47d78bf36104da0fca9b436231c7d2426a553bbc97d012c1f5e3073046f9d1aefdcf3fed02aac8b80c4ce65c9da082153027e0f254c332e35e9a1682ef6150ae9c7badc234d04bf70dbc000e19793801d8df2e640e4e7680f75e65fc0d70c68bc7a451a5876c25edcc03bad32c0687a534a08cf6d7f2489689b4ae547849d5bc6d3937da120265aa9a9f2b5371074e7abc527f6e5de37f07311225f422dd889f320a5842c310096ba9a828f93ce2d522c621b5f6bb35a3b5bdbcc2d17acdb480b28ef73a329be6f931c1c642e303d802d599f64f85620267ac6aee6298ee358f21a3f34116d8a3fac3129f2a6a78ff45a9d7ca331b775376c29a7ed05cd5b4df9b9d5e7e4ba813804b7b0fc3f582082a53001e694f45e51a80a47d24ef33baeff853e4ab2bc4ccf3c00f6fe15629d6e535fed82c0712423dc5819ba7f62a180d78980a2977e35596c7688c1a9e39b6ee457a857c943fdc43287c5304a7add04cb1f68f0fcf91e782f29903efdc37ad2aa52a816a6db8d69e691383564b3a6ff5e3cab6dd524195002dcc4d72fd6faecf451edd0eccbae179ca5f2a68db83245fb5886dd0eee1f81ec66496f6dbbfb4883d95db2c2575e4411ad736dce1521c869eebfd9530f3b49307a9849b21a764f85520a36690aa765f2498ad0cc3436d64b8aa0f462ef02e086e93ede81b21a19a1dfe7af8ce5822fa614590bd8875a68346987c0ba4d720a0b75300c53f523fde98d3ec7d365659d35372e681c509a4141baa243be92b808cf9ceac894cce8ca3a49b65042144120fefe67b9fbf81dae55276aa0acfe843bfe56dd72043f79abc4559b8961c1a5efd6bc524466ae0ef6a71ad261316b41e4d3216aad6683df16b2ba82b97fbea2b6ff81a55756b9c9dc13a36270e444825ce9db58336dbd788c8877c7752fd229bd445137fb19355d69395a49b82ded7408d037b082d54466ccb3ffb6e440dc3ca7cbd8dea25b0b6e72122fc9b94b67e42a211b72be1644745737567cffb6eda4540c2ebf9727adf313b93fc46a8ce06319444934f5af1d64d7298ef8126eb524fcf6dd01d69eb01b2d47d2b0b61b097aed3933df0e2d575e081456ecf96da9c97cb0fb688490c2cedd3a63fc957e261398a1444198c649e7e8d8b16fb89da512bf593ba9f3716053c679af58572a77fe8d670fec27b7d4d9d1a2e4dfd2c9f6d36ccbecd737f180d7077cce8a7485eba08285a2f5eaa3fa70544ecbf69cd61aa2b9bc0326ab6bcbfb0d467f2ba023b8317501b8217a374cb133b05b280ddbe61561fff7beb7265558c2650bfb8bb0f0427099835e7b883aa562849762b36bca7ad0c8fc8469b26327ddc9bcc590c12d936c9a22eaf0603c75c42f40f36429a89572740d398b5bfbeda1143e06eb8d59c131250ce4542458f4f5d7733266d3392d1ab0fd53e08a12694fa014f376127bb50efc89e8adf531ec4920aa7c76cc7f43e5e0687c81154427cad5f78536ddc76e9e1057c15dff0098d64d0600dfbb8cdf027e4f05f776665794d5eba15f0767d4190d78815a6e4a79793e339e525378b7b68aacd1b95e005db7d9756a76c173fbe489a2c60bd92310ebe17a9f146c3b2c1b1d984494eb160a8eb6a1db998f0014af6253d89036c377fd282ef53616785af8e25854e6c4dbe3bf9f30ba8614b6583bcb4a6845b97aee2cadf4b8ab0f0ec4d5202f12b5cf7a076a3c9f991f522fce3983dca509007cc36ab35fc9b83b0708cdc0e133090976046e17e34ef08adcdb85e93660e8b085b2099a8faee4c5f31c9e1cb0d92c4a1db27e77c3ad479cd6c34ce190b4be7d57cfae2f43bd217b7e46a11680da52617c049870bf4fc675d84ede78e4e37659dd0cadeb94ccde7b5951757beaa2ec8c15c95b238d361fa65145d7cea34288a34187af57cbbaf10b62f663d8951f34c8756a3e8bfe465d99b9362f84dd27cffea3406353bc80068ebcddd25b3a689b8de23b37032ac395e6c4507c3cad25b0a03e8152c6218a3d70f47fda247326f61db7078abd8ee3c15f7be8f190cc90936667bfefe21b0aca16a909a1031b50637919c0220822e9bed18605045585b738b997f47e8f58d06bfd8fffbb6d549d0f9b8ede5b76a87dd3c15a41252462eb09670761ff6d19760cf2555209c08f29ef72c66d4c984dcc60ea994a3ad4ae6cd19aae57138894f0d2a15186ba67d9eba82306e5c6dbe57bbe83a676b6d19f53c0fcde74f0b23c4069fb82863565e8c3615360ba403dc07fdbf1b9ff234aded6b7f81f0fc47416f515756f2387454c117486acbf4b1d05d063642db4ed20cbdde814ac33c34475f958d41d0c4b43ae81f0e692cb467a6f0cb1ef537cf958df50897cab8e19d01c6ec9ff70a8323ed895320437de575f24f1dc0e0332ae31a04617d93204ab53973ec906723fe5161a64542bad8048e678132315c86595afbc8f0989f7b8f0e2b9dc450afdc359032c2e9571aee3d919ba31462e3ffd82bcb579978add4a2560d45ce28bdb908f2a8dd85377ec8aa2f0b3dd94583d085e2705c8a564e698347c873d3b8cd1b238723f7185142c20458d18ec437e2eda997ef575015b0b08706199ab18452679d96456f167837f80af48375d900cf49c53b8fdf698fa8861731877f51f4c0887fe53cd34057a25c5873fc2a093b6347602c62bcbbb4af04877bcee1308fda5cd0ed38493b1778719302b02015f66af6ce841072fce3676059b694e73799024284f8a99ded013913c8eace43701a4cb0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
