<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0b0a7b34a75e6c697f05fc98a5777a78761b0fa0fd3f63c9842385719fd418f764e0c333c4d4733da355387cb65cf6951604ffb6ed6f1af94191d204b84f0de25e2e9a8d08d38b03c8e04997622c050ab413e6210e77bcd247171c5697c526c66b6290cc671400ccdde4dacc5b3bad217f9adafba06a0638605f9f1470b781b9e645b9674d27cc5442d56e6e49e064e6bdd11ae443dd32bdf0aef51ff02b88e66e0025479070c1b4cb4aede80229974bf6c6944838db30bf67ae2a9410f2397b171e8463a91abccfdbeeb1b515dd50f06f48407c0eb5f5840596c202f98fb39c96af3cef573a01714a09389122209e96cf0fd819e2c1a8a3fe4f9c924df907f1ae2463a4355ae07c25b543f4090e208e63bdab379bdaf23dc8f73e307e013cf79feb79bb7c045312edb4ddcd93ea18060d76f7d0c1c5ae9658055196139b69f5abd463afba8e93ef601207dd516da6c5c3f450183616572cf0355ee1e0b7976a0cc6b49770cfb45bf04ef40ecc9128b9d763b04ea394bcf44cfad0e8ed00619c8c7a67bf990d01a0b5b26c788c159cd30437d89530fc2d5797d8357a8c557f854c7eb69f177c2889821939dab1aa8266f16ac7dfd3a7fb6b2f8d2824c7fd0cfe204a2851a4a0b8ab5e62468f8fd859b09365f272c877b7b41cb18f3022ef73771e448bb5f271aa849af0bfae978c5459c90a0ae658478ef85daa9eaea4783852cedf4d4bf52599b8123a8c1109cee1a0c31c8da9cdc3f340f2fd241ba1c46607954814623a6ba9f0ce7ff7b1b17698c6ed748c1f315cf11076cd75a8decba421e11de179797837ee0402c4850ad6fcf1d7faaf7d870fb0b4e62f02c704589690df79a70a3cc0cb37238246d46cf9e650d78a427db539bdb29fc4a26784ea92df8fe32b729251ec240850d6bb024b22c364ba5325e9d84b21a7543163242bafd0fdac3660c51db1041c6b9b360cb237db57009f0515f986f8a939ad57cf5567c514ce0801b26ddc68a8f14e4507e069e149a3448d9e59c15998521cb0bac4bf37cfb9c5607dc42ecb3483d2af457baa4b3c6c966e0d26cc646df114660fd885cc49bcb8724983d903773fc1c68996abde57705f5ace273db19372991d48bccc392996fcd6b3e43b80f605ef2251bbd8fda1ccf3974635d0e474a9d5794994b43108c6bda0a7fdff965fad6c3af9865b7e224b428958b6a695cae564cebc24ee2bd906a6b2088814c7e47e64b9ea4158532af2646acb44cdb1bf862eedee830ca80300c3cc1f1772656f39d67b26bf99be7acc2b561f8bb83f3a71b752a55984c773e3ae9738c836a30143e9088697dc5e2f085ce93faa74b480aefb05f0b502b7c9748a856059bc569a1b72ac3aafcfd1a0c6875e7add36641f0255a6d14f3f5b2c3d59afd4d822f99a422e56df4f8c4590b6c1753035c40a9a5ca71873cbfc8eed6f1770ace5455dd1e271145067c0b2f93e454a7b74376cdbaf3333b612f1fc711fe74ee8e496429d407c9cd8bd8716cb2fbbdeb1ec08c066e434da1155a7d39ccac9313f6553fc92f8af8e9dd8483a776ed62504aeaa48081a28dc92bb69ce17ef5c214b8bb63bcce4e90605537764114f6c8a9b2853b71f1cadf31a8378e47ded2887f5b71abc578dda593a720f4f4c2a4c45c5bff975eb4218e49a8db470242538c5b098cf687c2c47fdfbc6c37d9d9b32f9bf9c3eb865aa7b3dcf34e079f69bf5c5c9955a4f3328df0070e22b033f3795a17f8f84cfbe822e0dcd16247792bcff1ceccaefc31fa575e01e2ae0601ce692f982d341f4ef5d10efc04452edc2ea1ff98fafceb844f110b191999114d4931f2e43c1c4df6508e1b8198b88fceacee36a212a4abbb5dcf1a507828bd097fca6886764e52549dd1751ec06f0da317bd0b025353267507e966595c273d058ff41dfb65e353e370e8507ccc7092191153a0d12d729dbd158bd8dd7f21306c171b6f289fc4130eee4f4321dd3c159e2340da431d3a6d859e4194ede23581030fe13ab70c8e9fff4afef3fd6ec971d41ffe102d4c142631e5bd4d575c6ec60fc24d15a3e2bec9ab26b53ac489be722b2a26842ff00fb546d4b6374008bcbda94f5a4ffe82cb309515aacd29277560c74d1c23af432c5b87dda684186b7f6840d60adf783422755fa9e6f99457898d470be1ec68fa00028dd5c121da47e8d20794436cdd3348c2b81220734fba8624767cddacea5b3a2fba9183e438fc6391b012ef8a53a03f33c690aa63800c4479d89bc0ba28713bc7ced8d5ae4b2f8ea45d210fc98353340db8d0730f5d99bb1578778fa9dbeb7c08b88cbc43015046da169a2c62096f563bd038cedb7976776872fbde01e1a991843c84670ad7c18ec130cad8a82c735a6ec5d43f0c08cdc6933403ca3465197d5e64e6981961a6dfbe80afe184092edd1bd826e533febd0e2f3d1745464b485202be4daed05cbfa3c93f8c1e9a666d66c4140d5c5b347a0594bea457f65ecf38961f05b94a785e297c1550bc8e4e830a1a1600cfd202dc94e5aa843240d307a064381fca677908678aecf0df834488e931b97112b63c015cc8eeb1e7702c3572886ef7dcf5fa45574161053802ed70e9cc5c9723048b36b5bf6d1f6ddcac2186f980ec6e785ca7da62db7f03e6c359a755d84aa847b77c9db4b548d91d0ffed55c936b5338eb4c4358e5d0f0ae83b1ade22b4c695952abec4513e8bac1d7848f830353d87b579c3e60e259e4eb4c4efbe90d3c008bbd10b1d2a2b7436fb2bf5923ba4c6560791c7e37d935dae94b0e62b8be63da73289e92bb1bfbbdf936022801fab4860b5b0c2331befa51c46b566819d2a16fd1013788a1edefb7fdbddf87d196e8da4dfc09b3490fea9bd5add4083741255a14fab77b6789631de3620da8a37e200451c55407bf29cf83c75c081885cd5966922158a3a34f8a0f7de4fbc2d92f657f3951b1eff3fb96150b656d9b6d205fafc2499523e8bffa18f2473eb4d15beaa87f1dbe740782cf085624df5e27855d952f463c0af2a82d81eadea625a2ee55fb552df8349db1280f7d53404467d9cb60601c8018e394320243b2c503154173a4c1b12572973d131ae4f22e9acfb9db53da8cd58b38691e6d1b0a7bc1a542d8617acad47f1fdc01b4890891a6fa3cef842e48dbb656674559b9cda9edccd76101c77edcae3cc489df08ee1ba60a0c9c5c6145b87121b7df7cadc56808aef5ffe2ff730ac0e11eacf6ef2eb3b61f162ed32b8cd4a211a276f40298a511b18b3b7900055ecfd0ca9e53a9e4a6bd89437887966a0ead7e35c834ae1aeacf0ba21a9796569095f278e6efa42ac10412ea1e452f2a1f9365426610a967efb6b8ede73306695c417db290c833d8b97e95b93b8043f56260ca327f7071aeecef4b99b9ceea5b530af432be1157ed1f30b009597ea4161731eae23d07b8ea15c85a3fb47e7defaba49c0b3eb6ccb2fb56c4ca1649ce9bdf6dfeab166c3b8cd9cb2e463d8f4b06bc50503b3ba4105b63a6410dbbf9bb467bd864e540e29da0f160c6c87b0987d7de65e4a5155e3e8a2480c20cda54840a3ad5b74ce52e9dfca71051ab6ee4a0b992a7a689d6645c44b8094804987a31544ae0754d01746dbb320b0b20884116e4af78c6da8ad40641e1f388a5390ea08ac4608811a7ea9e3884629a2e95cfcb801b4baa2b877810913f68d6ae1b5db11710ccadbcc4be13ccde1db5b75e2636f7109e02c239be67505b3e56e02b6b14fbccaebddf451b744f3a6d342d72e5c9184563bfb1a500857147bd13c8ff4904e7fb75fd4ab3a7e926faa7dd5166f200f257942a476df6bf665f5c8ad3130ce1e610c3e5441b2f638b5176a9fad05c3f77b31628fc10e7dae8641274a6691b3e895ad4bbdf6c2384d6efdda07e1826ae755630379b74e699b9ec6ae32d95b91859f617d5754763d1a5180586d1c37de188098e577c517f3d2fb46a9dcabea4ba6c882a6fd6b1a3fb78c24375756e6f72a6eb8942c984b470fd869058cf1443fb9069c675fda77e1c46750ff488db1ce8ce447cd0026e737269e80b5ae73b999841c81c111ead548d8631a5f9b15a05648aac85504f6928ade2553cbbdd9d21f92ff33be01a4b29aadc672307f26a6e7b01c4f34fc24df2835f72d2f35086bbf30c6d788db20ceb34af273745207a1056eb1f55f80fe4d2df4414971f5ed063a9f4a0bf897097e0c9c5bd9f12c0c200adef5fb1064312759bc89718999b0b5e85d3dd8b1c1921e44595618da1628eb5101b56c60ebfbfb5cf9e09a1004237b91d32632146c4c8b8f62983b7f718cdecc000ebe996cf0c4b95d543e19e6f3693169c1da2b190c5df13d0e5c4a4af58827cf0f680910e4972084450aba6a0c939e3ea367200de95a9fc3286dddd031acecf9a6f9f841a6e3608a0b80dfa0b7fb9c4819b03b6757d9f8a80b90e091eeb614418b060a303f588dcb26169b6834bff7fc6f337ca0ff5d50e68acf042239fb68ff9c3029b41608971e7b75fb91200b0c16d094f09790137cb15040332d85cc5296ddb526aab29e84e1bd8e1c824f60c5dc461d5d480a7210b8a30a02ab6f7a5bdf5d968faf81763295c08ba1c25def4d16fb4f0525ace260f0c7c882699f8ee36385b7f250b636af2aadb46e9bebc30658e9d58d5c815d26089859996adc82b2322e6d43670e28286e7ae2b886630c1e704156614c496c338ffb20a11fbf583930ff673d30cc06e8e4a4930c27944cf935b0181e83e3ef42e0d2be704517fd15fe455d843dcbe60f229b2b2bb3da7e4fd03ee75ec55e92747c9705ca5580fe8e4ebb360a9b3f97e01c62d4aa08338c84c541aa21c06c1b6835fb68ecbbf1ebfcce405cb023b01be251c37fc73cf39e415c89136b848596ae6e5436df82f7b56ccfb95648fa04958a8247b9cbc5f1dd45993280cc8e00b9175166c896058e5917fbda6ce3758fa7d24ee3b7bc88899dcae5aaf250dde1eae7a182f0bd0f59f554ca800a6edf3f880c481c5b5fcda4e6d0896582d9181b9bb41988fc764853adc16ae38583b435d741c5d54544f504fbfa76c595beb37f5b724789ba4e226ea32e3bc08a87ae5c33932e5ef4da6be000661952a05a6d5e464d9ba037728d4f1b22fc00e145028ee4b96b429595b8df09275b060a888c1528a13ed01c2c3d298cfab0511d6d662b524657b44f18542b93bedfbc0c111cc3a66de56b333b43bd51d8db519b121cbff365cd2ea4b1c7f9d99ec36ce06b3ada190bfe6b5cd7c4174dabf4f2f2f47fcaa5898f7a91307449f8a1d3e97f908a7b478ad7baa1bf3ec00c2e09d29b2bf8d7af4521eca74b72f0bf226b3f89a23d0e7adf83c357067d0eb98ff7b202a7d71b7abbbc3b97ab922e222ca681e05db27b9adfc16f363eed31a8531517ffce7fde5aff8a456f8c2d1af542a8796d78e53917875ae130e538c2450a6aa0e8e2c12c193743469c6f7a269320ab50a72518e974def1e54ec5caee9f2fb4e0808ba2afce31830decfd682a3ef5d563a93d5e3d58d555ebdcf1312dde5905370a517ea215ae9cb72862f0bfa3fc976f23a3bdd437361482bf0ca4df606310967378d9687c0d892eb903fd0ac1ebf9a4a7e703c37a6db90c45de50fe6e75f3dc22d6f2f790842f4816fc3d854b702e2ad5306bf8d770fdac1bda5da1bd6ec92bab0c4375ec931055f0f386a86ed9d3c4a7c98e40ba83b9d1a47345df8a2bafbdfa8677a43cb3a701ff1cba12ac6be781032ad8d68819114f85804ff8461c85fe5a386e9cb3eeb2f100fa823ae295ff22198f1623b9318d167131cfc4fe426cc90e580c74383ac5ce8a4a0193a17c6b8752a65e9c379bd7b80aad4ffe8ae10b432522906fd56ab234abc23a9d2e0fdb4d3959ff5d2d75474a7999d730da8f23413003452f906e0b7590eb426afeb3af88137a8d2f51832241f28b46652a434566254dc3507fdc4eeefdb71d68e6b3401a0fc383d9ea462c23f10169d3882654bd66b7ea6a208fa2fb135273c27a0423979bd38f554bda5afddd1ea8e2fe8479cbdcd99b3deda9ea4f4f95e6dd64ac8756c859dcb9d3cdbaaa818d703ebc2b08e8be30b914e22fad74e393679d4e7ddfaaee44f11429c59dba44c0c09f9c1df42267089519cbfaae011acab6306f116cf3ae5e6949b58377eddc338f6ea0f4e81452588238832a53d51961655591087eff3ba3a5ed8931bfbfea2d1cad7ddd3219a2552457fc8aa2f4eefe8dedc25dd1df639939008d9cc89aaaa0a81dc77701d9c889f1c463a0e4d9b480a2e7804a576cd63b1cdadc1961a87872221af210d5c4db20cf6e770718fd19d08d4091eba9b2432132e8aac1817d3b522aeb7a3fe312cacc29bd92467405b5f4a491dc41e853ad605e2cf9b259ad03414f531ee76b823c548ddaa350f25c4da116f384b008beb2a17d97b0e3b315d5ba38f0023057cc745420a42a8191e712834a20d959aed51b6d392627eaf3bc50bffb6c5f8ae5c6857c3628c3180e392d39d4956ab6999b0a255b489451f94b5d6dd1b8e590a84a434a1ba0078fa0a7a82fb8771d7557be43c32acc03bd0b94e9fd382fa1094b69c3018409023629a322f75179185ab6474f5a1507585106db2569341a8b168bf596e700de54465f12a38a92b84aaa1d50a77100a94ed1ea9442d07871ac679a6decdeafc0d1c59c339da13d42db6be802973136f2394bd8cada20f414c934627f694706911a8d0f4902d1cac3775922cbbb2a85eea26790201299960581046b0942861afff0d05e3790098f86b8efec3cfe15d04f9ddfb4b8803816cd5b157bbf407fab5172c457a21085d625ceb2b9fc188a7a789159eaedad5462814424620e5242e418b1af7a0850949a987d99ef97b216725d604b4f771c5f28b9cb09c93b4322b50e6f2a04312112df7f9bb87b183b05a0ce8086c796e5dc011a7f022b24bd31c02287fe3f287b26e137a8e50b8afbf307130027003ce554b726da5816382829ed60935373f26b6ad6493b67341c364dec7e0b95b8b9e1d40f1e1ded4740d51157d6fa808fe2d7b5dc3ee3331c7f2a4e664cda5412bcc60feca87efba2baf5546ee2042abeaf885db364b94c6bf01d1efdd6758b780de41583e37c7979f989213655d87d3bd2748ff7ef3108937b98941cb6820db972116ea122a3b8fe9a8d2d3133880ce048ebeb69b05559f33cd57dcfe394c384c3ace89227b8f9b27db36f7c5d69dc41b56dc239bdb3cfdb2e519659ea6bb408f3de6d5a2eb259e6159e925618efc0f7c4f9d7ebc21c653df20f82d0632fc35438395ad0cb345b194f976187b38d024d2398770aa7665ee3f73e4cbb916eb38c9a3cbf9a939f2bd35977244fe315c2854bc093ad3d04e118114dee12b85d50fc79ef993fb47138493e3bf8e5c9782cdd76f6e64a4c722094cef08343d43485ea2a3965f6e617a4d76edec9a78961d695a664b2ea9644d52f2bf3e593acf458ea63ac32d5a7bea853078d74e39aad81389b486bb86e43d08276443e60ae11306d6c9f8104aacd77c82f193577dd7bdd2459a42a840f942e43019628eb3cbbc18791ef196d80937ffe5c6e187f34f828d485fe3d75c531accd6e0be2acbd9e8d671594a64485bebdbb1382bd35ddacc51d4b254e5e2a851ae2c41a11df7afa671f93c1a17ebc3248c36a14ef6e67ccc2015c6b668ae04bb9bac42de5bb868c6e560d5f0923cf5a9e3c16b3d77eb0a79e5f3b2019bb7a541e667329279a055bd832001af648084dba6205f9a0b6c9ef7d1200026366a35f3926e166157104723dd68f9c865674f55eb51345c4214916a29011ee78b9ec98a867b207ac725908c570643cd8c5e3e02e41fed67d8a9a519c875bc3fe006bd00d047a0ce58414e279dc8517d9cc4feef3c38ee498b21967a9008bf567fd1db0ec56e322b49d2fec0fad357f913fb1bad4f961e662c79a01d537a0a08f51aa6f2dee0745ad4b0676c78b8697c619e8544d53a1715d1f14ecb4a3c2e7c4d9ad6ca9d329aa57103789d8da541a3a7b846c45e79953e612c098f61a41d2fe207e09253d286a8ce97eb66a9698354c2bbd489e67bf8a4ae6a6fd586e7d9a890f0def47913f381996c6092eaeeb32b26de4e57141380bb7e52944f9c768c6c1512bd0535124868c40a4af737dc8ba48649e8fb709db435132fd260fa7c84423ea657122501cdb67313c25c6db4a7b9c0d3537c773aff7b7c7e908bc0abf70464fe9959d0d1520ef979fd2dee9dcb948361e14b950570c33b9971375ab67322343fa6ae7ca7676cc5338a6cf7ee7ab6d1eda9651ec6f627fa34421e5ccb6151bcd11193947090fea495a8c8aeea5e01249dba95341abf3114261ad80d973ea3a136698195137e9cd3405d78ef5d3bbcc183804d81a93a45d066697be7bdfce7676a1da9b3c6339e985854dee38e18af5c3275e77eadf629a0f36faae6f2b610b894ba06b29e3eb613be81dec34b4d10f9542153a234b912a10d348c20ad86df17a8c31b80780e96caa4069a55e4ce51e427fd3c1e939e7b8fb7f2166a7ffde4f07bc33e0fd618663736481c814bae6ed1fbc33972210f20394082cd865ccac290d47268ec6d4cec2cb0eba7413307f47de08b32dc10c25d993bdc578b5697efcd9545dcdb774c33fcff054d092150309d9b3cae59d0af310c55c79c5d794ab05fe801141d876e4cf08f5fa1270dc004e1b0899762e42d94c1210eea0603b8595fee9a96678728e4473dac85ba6dfed41da05ef3ad1484bebeb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
