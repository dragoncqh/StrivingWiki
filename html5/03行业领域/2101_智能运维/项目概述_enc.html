<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9e90931799637eed83c2bedef93b845e6046d936d8b1ba37b3408cca390c04a10eb7a676aa6f407e8758f55dfc14967f58e1007cb3bd72f94a309a27c39165d593bcb6d8f8346b22371f049f2b5c4daff344a9c41738246f8ef2c7e4597189d0685754b4ec16716e6bc5db4f7a2a7b171f17ec13def7b21a7f0f92a72a4abed0fc87aa65146904baaac952b5e7cd845b9502d5476b32ba53561242b01be788a528b9f3b61dcc652dc8020251ad377cd55f623b70b42ee2afae7882b0824defc9852e35f2c5fb6367348328d526661b6afa604bf76038099068c7ae00ce16047f90b4410e84cacd96c26577fe8d2b973f3f4fb95361ffb602529e46bd69d2915f573db4f7170a573347a0378302116822b0238890c903a27b33b2d2de0ed01b842e6f503f0fab48b13d8c5464753f072f72addd38373bf0b00e569647ca1e8c101ca62530b8a4aec18c4657ce7d7e0a75db6cbf632b5c1fd2069edf5c707cfc4323cdf8434f740b05821807bf579232f2a4c55a3876ea1f26f76911ac4899378146f5250a8eda81c0649852df06d0e61ff0fd1953bafd836920bef557f001b844285033353e4854218dc2a8998aae5d6fd18c738f1cacff8264ebd89ca1f38e09da5d820984f5679b3a998705e8c56aef95eab6626df3664e922cb18621182ecc163b312d8e41efdfd569e89b2545173cb6f12053061428eab13277f2ce6b48731df580e2119a9f6cb50d408b845e21e5bfe1f793ba2b611ee9531e879fcd41b832276ca79b831dbf1726ffa0b7aabdc297b4d13edcb6b66807b17f55ea3e27507dceb74f5749f697e0d18730509ff31521212faa54a0dd4162cdd005efcfe822e1c84d89c61d29ce75434067cbf954b648a7d76901f01a41b9962b55305807529718443132baaa8816ed106cb3ee60a215bbb06b37c1d70e4f587618cba275b20cab742c6c626bb89d1a86b1e7c58e71572409b41c9a4e73fe564a9cf52ce932f700cdd23bbc72e19d4fb84e6f7f7461dcb2133f8101c4fd8f48df733354c8aafd921fcceb0094faad690f4958b2b22fa53cf80276d8e4776c801cc3d856ad18fdbf9bea8cd93be4ea2faa3a5c949ef2e6578ab17e99c3f543675dd98b64828d39faad676852d0fa73441b605300f12c7be2a00cce04799ac06648b51a23cd2245af211ecee5d6a4c225b587a9ddb85f06f4336964ec99af06207239e4e35cd7895731b5a47054e7566c53791abccc68f237d95378817a8cee4db3fa8860a7142bcc16e9d3425ff8fd93dc3d9b4e7bff911fd2f00cfd0ca146db9dec0806d47dfb1ec445e4bab017b09608e9643160f925b6d7031cd8e8f35c5d49e608abb9a954b62603f1ac25334036cbb7cb9901f8f0670c8296cb8d57e82d38c2a7d77634491f473869aa5c5c108f8b6e2ba03a4aec7edb6e6ad6bce8e6ea66550419ffaee9418845cc50e9db07c75579d3dede5589e51ff0a94a422b1b8f777c123426649cd64358d9649d19e0c9aa75ae3dce8ac9615e04139e1a30fefaeb6a177401e088aa2860e37f92586365e212fde777e3a4ddace82609df4cf6913eabb940059efad7d061f47a006c433267467092979fefcbfb54f4f53636e00265e7242d78368bd5ab0ead0528fd17c45b65c61212d3e83b775b9449cd8f2a17db88a5217a4b6433ef1a838a6d7181c3a43accaa3c7ec1b5f6d1ca034f54bf2d1b6cbdfb3154bd9c641f439e0d1d1cdbb9ae6fc816f2e49bf76b271466ee620cbb8ad11551b34444d1484f3d6907da64ad1411ba9673716d2452e225f84eb599766000dccf5bfc91a8b5c3492e17922479e735a6a129e7f1072def230bc2b5646c4117ae1deeacdf9c915a2ec63bc660db3cc32ccf96d1e5c373182e2556106205c3b0290eb0dd79fcff31a5eef6ad7f308023d90544530111ad31d6eac5076a11dea26a30c865285c27d92320ce286902d020790d2acf31e98e747fb6e0cf13060b65be30ca089b21c8dc3853b6a911411202bad267a25d63de24d7a4f4614aedea068006a0606587b8736181dd293e174529b72b2b84d0394e9d0e61a2c411344f777d7f10af12495c4b39c2917a96f3c62652e181f55c0410b9bb2d9df70793a523f96eb6b1a6fbb584067800522f614656bbd51bda4a2b5622e248535d1f05f50b610b56c9c1891189e75fdc7650301f309a16c94d678ac47e8cff91fc1be55a970ab1978fe469f8727f8db0a4cf502e55bdb7da53c72ceb67c010094c40183be32cce0e3e786f954c1ba987d1662338b4c68b4d24c5d8a60ac81d93d6a9133662208d77c4827eaf9233753b8f30f924a7678db764010e6b68749ced12d662289d4eb2b33165f427e022cc47c780e11e5a90e698b43568b5b659726162c52d1a7c9a22b2b535d4b64962d793713635e29c0d33fe763e7681e72908c492bd1a80b58a554b6fb22cfa043bf1775293691ae8d7b11fb7addd2c6032b164e8a4ba024182db12eeaca4ccc5519e93274ae3925f893573bc1d1407839231f9d9827aa1a0fc0c0c526ceef6925f6a77d253b756fa382c2abe74879ff599d6ecc090e14e0a50f136d12878688d2882dce255f3e2acf2b59bc63957507504327e9857d1d9570de1008694db769f6267022a15002a2322b75cd16039d6b480474c8c7b32bac87386cd1091d996ccc7c73438329954513164cdb0e4cbbf4facc6b12fa03e9bb56ac40c019d796b4bb4eea6aa00e86191ff1da3cf97c05ff42a11efc843c56d8bec2aed799dc9d05c9dafd88f3ed8dd1686ebd323b590dcb6eb6150a55345cb42e0f86979832a23cefd2cc82e059f16f0463a6e1e726c9a300eb986f88d717f721b7d83dbf5c11170b459736e6a06e74700cd431aafbea33edcc5618271d63232defa5470702cd22dc9a2856f43fab11d49ab714446e2a1376b5694b0860f0982ff0a685dc6fae155152fc2ab2082d87af7389ae3efbedac6785f2698eaf870eadeaf5462bf78448a0ab89b6c0b5cba4befb827d9c220e0b75aa982918f51ad2e5235bcdbea521cfa91c635d26fe2a556bbd3e91bc5253ab8dfcc499d7de47356a22b0515038581f1b554e3f8c537e67dcf6312ea3cc8bcc2d19390bbc6d7e63cc3a334aedbdaac197c2f94b1b72376f3e31a14e89bd8ae193dead8be67a8f3c75a7465f9a4cea1b90809aaedaf8f16e19686aeb8582a038cdf32973771df526a4bb2e5731b3b9146f03025d3b026d14541837b5d7ffb0012982866593576fc6c452ec125b076be9924bc7d156ec8a28728a1bd1393e5019f81d8fce556c3113eb65600cd58b991d5dad603248068da276750c0e76f43bb6693521e96ac32b506a4892035890317bab13c6ee65d0e60f7caa80c7c571cc139dc9f2de2afc5dd5db5981cd9ab4ffb706140aef30a5dd14440e10aa4737b3ca6a2ba5a73ec1e94df1069feefd886899037d8a0424b48659f37033f571f7b9f62a7bd80d27101f7eedf0650a4634e756c7e33e6014d12c00f4ba57802bd64278077ca3256acdc7e854b24d0e0d0c929728fafa924e1efb9927c138d6f77fb7af3e9d9b8bcfcf88928a3e63fba08ff695301046dd740a23e41af9f8ff7c69ce699808b19ecf5e2709ec3919e218cc900c74cd9303c89588b37f7fbf9bbc8175c7eaf8669017b57043fc3b745a8e1b0143af35d478f24f244d5b4bbbde40d6621b169a31ad1124c3a170d71a1a5d1484ab5df0484a6ec5295dab42a760689839f34ebfcccc07b27e8b64fc97e36196868b9e19eeab9d7e452df8ffa2fe0f13bb9e92a6391d889b718aa76bca0788217448c4bf4ce508adbd81a539325dc2253eee75f95a1d5ff3d6a4c903854299e11aaf1803c917dff19c73050a08ef6fc73a72b3a075a5b77e6a47ae0e4e7e636c05e8821a195cd8258f615f1d7b47e31f40758f054f81c257387684aafc709e5184872c48d3dcd965c862bf9a97c44682061bcca3fd8080c67d89e14b5a6fcd59e47667d17b6bf94e56ea3f4fae5206ca431d631c6c67c1c05b5d7bf3e8b7a3be64455b8b06379d8124053e10d57377e435ab950910c5e920372c5af21c49ffc2b92789b95f9b7c36efe54dfce933894387d47a6133812f8ce06bf00e995d1899b6461288e686df2154fe24f3a44beabb673bc4ed57078d958ae6bd145324de901b0221f2f8044e102d3fc9da8fa2b6c88af642447b7ddba87fa7a88a372c1b538115e19fac8fe1d62b29aaf4a2520fbded7d171c657a5703d1bd32bdb4153b353df9ab9ce8cd1c24b60f633592f1b22926d1865df5a3a5dbb5b96db3b3284419a16995f223da146b8579f7693f359e042db48c1442ec4f2dd3c4dbf3bd489495d3f95c8a2c5278632dee9f7d064a994af53c020f3941d8e9af56dcfd18094a337c0d26b8701c8b90c26f09fa275576019a6fea133c6a66dec33a62aa42d847c0774d731fe245eee7b7ed82dcd36535ebd4a9e80f241244c91ea1aa6aab5258d0753c8ce741bc026b60ca7d871b5a53a0ce92091d6dc6f227596f7018e899b882f1a7c4ae9a4a792fe453810260d8f2eb2e680c3e13ff7d8082dc26b0ad2da695507d5735d267d0529ea99c39f556c4111f8d746a453840e255b8501348d496c280d343dc36fbc8321de7894bbf1b410dee3d0825503b2cf304f6c3b253ed197c5038fe13a4d3d6e2a442ea1bc8d167ac16df006add3fe0e9a8a672cb513c31826fc804e766cd1a9653a35f80d26c0500a9cac9ebbce4e2d9ef08f3374b70370186f9c7c7ab5093080d9d47efc8268c5c02530ff4ccb03846f19740ce1984054625e3c2c128a6ceb03254feb147c53ae2465fbc929834d7fdd5a0de2a0ada5439af06f744402e8f318c83d05c789075d0aa3612ddbdba38564ea7b64dd9a928b2dcecb1559f0c27bb9e3e84bfb8412ccae1621ccc879badae6ba669a253ea68ff9e0ca0d62a610513ff2a4d1fdf08d00f9dffc8646b0101944ec6be1d97f936e434d0356eb797040a40b771ca587b01d7ae5c5f631fbd8b41940d7d48bd6c2880367c2c521dfc69ff8f2fb11ee8ae3697c92da9c46378688e7971d5c6ff4889c07787e84680c40779a2f0666d91d3a8da4268bbf402cc3d776fbe9ecad9269db4a9c4a9cebda3bdc0d2f11f74ecba45346189b58268c1328393678113024b6f1f9a8e35872c5739c11f3d1a307a4c7c647d68de918f3bcf968e7527cb4a40fa206cdcf879a7adf59272a3b50f640ec891a1f21a88073d3b6ea2d968abbb02efc190fee21113b7489e2586432cc7dc75d8877cbb6b78fd3d47d73acf6f495f1a9f325f8506dd0609c45a1c918170065b09900150eae05ee2a3f4dfe4ae1d831072fd341bca54e7136bece498ab3290b616db58af9d74c7e27cbf48e789a4cffcaa41a650f368182973d8b9ad3630c925a9ee65da40b89ff1add059cc196e5db38a6ae6ab2e2bc4c97977337f7bf6ec4001ed225ddfe579b789775b476c8a6fd7cf57c875c3cfacc8b6a5443e377913723174cd4d44f3780118eec309fe153c767eba6a4fe46cbe9d4774591ef8f1a3e118cc78929a0549a14cde789f5cb8d1bf13ace5830bc8081899a2596a66785eae77f0f023732a164b3c99a619ee5117de7a64cc11ab2da243759dedc4c0acacd2c4a33e2f83362a984b8c8a1b7ad0d4ae0c563cc877a50741c952af11923110a4d4676c6096157148b7801f739529ffccfa2c643f95cbaa93a3d12723c99fd908983e9be19bdd11b4199356a741584f7302d00126013c80944c6cca8c4e46579d459ebd213ae63be7b6371f783a5103e801409edfecc06fb271b5a9554a5590ab6b25ff45ec9a067c1cd9c46c7f34bc0cf590703a797870f1d50e5a11cae573f11a1488a7137a3e254a44cc4c964e0a946754d2eb36c950c1d4c7e34f1898792c9a96ea09d8ed948fcdea6396d4f792cf5c921413507544d9ef27d47d2d4ad4f5b4ef4d135eb5380a6259fa3663a0de1b6925cca7aa4b091d36c90dbf44456e4de3b06016861223a967d32dead8770605fa32117e8af8e16d3f8f6697006f28bdc9e8b6697d7a6cbd921c6f73467e0ab99e6585b81b0270db3f4b69a210bf2b232d7fc88346a525fefc29f1342b11352897b963abe28eb138f01a3803c4b9ea385ce48c1166daa62db74f9cf7aeca41e31e003d32f0664f5bb27c6113fefb8484416efaeb49a58137813efeffcbff17d84e9f9b8c019702304b90c575ad6658e3b87fae911e6f1425f25565b4fede41f6f9d9fbb04b418f8cbed90b8355159ac92ab1a4a79e8bf441070f37d9106a52a678d4089ff9a15e482f1a3bd5b7ed881b215b579a14d57e87e02431133dd38ec88f7006261787387b49b722b84834e3dee2b2cffa29efdc6be25d26182739b28a6833d021ba9e01d3b20b86298fb9c906bd953f187ab839e54c6b84947717a3b479f631f23629a87cbea2cbb340b55fc85fda2927685c099dfa632ac0f14e3b78c18363817493326ec8cd4a201c8fe0275305bfe68512d28f562d9af383cd394930c4960b95ccb2c65f127644eaba2f0b951ef380122cf7cd5591abe794d16abe72ba555f904d4c8e315b4543d80cbc5f884c1d119d31c26e1891858acea4f43afccbcd64d74e94ce10977b284add57b5e87631fcc56bfb6d72abba54cf606c62317ac18a1abfc6e5730eded0c7eb91e6f4e6cce2d0584f23ad20d1d81fa86f8abf484761e2b3776cdf11210ad9220481e484fb6953ace4dd336910ff49342afee190e6cb5dcefc266b08e147c4e8464694502029af4b99ee541eac644f13a96a8116415e2217561fe4b24c05973db0219ec6e2b62549171895415fe417d266e920e0acec738928fc817704f95c666f2d082e17b73bfb8e3b049cdea36ae1f552b43190d67243bfbbe88e434d89e8eb201468c615c949211aee981f4b38c079f6f9a705740d86914851820e5a305656681b3c336bf50414edb10b924c2c7cda26c6a1a25b67761956438d4c65b24157df61993c0587cacadcc0f8797f7049e32963cc0bafa86ccca5f9d1c5661609a6f11577a310d77f08f363596cc196f68aee2b1d60c0f0218f8e290bbab1257f174a6d4095129c4fe3a51d32ce3009a24dafc0fd4277bb37b0c663c8e35b686f745c6fabf7b2c489b881fc0c4ccb473da0be2399455d1d3abc81c2c239290a5ed4ec1389bb5331caa3ffca4a0f2ae541a999836a514ca225c3c9840cc62b358ccf03a100f54cac33c79818925f5c96bbd32e51325135b39374867b6909450de116b9630649d7896016e0ead4c1d893d68a34a5b516a604088d14ef14671d4746511ccf0542add4434cb175c7025a79a00bb868b8bd7ca1b8a5096d98333b698b726b7c4d0527caa0f76a0e2b2a29506f0eb5cd1777edefbb8d9f34226184764bb439f12f343ec5a97989d9a2cdfa853efc18d4211d67d1296c203e5d57ce573c8bc84588d297aff13dfd74b7d62eba998b7cf61dc483a2e60874b37aed2ce686a843f8da5a10680b3afb37b4444d279c748d615ca2edf8d59e3e3067d12a2c749aaaabfb4d0bb62c86b8399b68dfc00145c256d061aaf2384adf6b63c7790e3cfd397b0cef610b0d335017ed3c0cbe128885b6a3b00ab05159cdec834962d45942b149215ea57bf7cdd7e64c9a2e47cdcc7a860f8447be342bb2e71ca93ae9a0c056d67b7b2f5a894ca52394eb3066ca4aed0ee239899db426dcb1e14f6594bb8f78850586c150b4fa55a54b3e796be73d615b9552adf24ddc4dbe2df3ff4425bf6648bb133d46184013b6a6db7a70e47b791c95237db901aa1ebc4e3014dae0ccd2be05be12608f114b5afdb938e6de08578f405cb33a4362c8a5f2a5da01a1ba55f76422588218106f2823e00ff1b3c93934083e70a01e1684a7af8f3b19f7d1243fe1d72db64cf02a7af50d0ff156ec4744c864b5d8c8ab61aafcf2df574a0961de60506ea8d6ac33f8158312d2b04fc40964e84176b57837148d72453d9e4cf8a97ea68b606c6a09193adc8ba7f33d57b0cc845784b85f2e6257e9ea8e02bf7ffdddbb425c5d6474928d03c60aa63ddec7c76251c7f8968e2e2730a5e92bff6b77b261935a77d0f04ab514f06d799e85fa80e970ffb0fef222028e87ebb3845944d5bef29d029e644da3c7d30cbc111b164a6670972c289706f70ae8ff451c71b663a5338198a728a37c5a8c109184641f2d7d5c870e3c46dbbdbbb0d470bda006c34499d070a87a384b338451457627498b9844f98be9961d16a7a8b37e7ba569dc825a3c73f927afa41c6b155db22d461698ec869533a28fc82a34d0d799dfdd681a7d6d90ed6ca7e4e4f29345e944296bdbcf0af60b5965cd0ccd02df9f2222359a024ddfa0efe75dc06344a3299baf09165365e95d2da0637ca056fe2bf943a8571ac4d692a3060058a0910c9799c3e487b34cce4a7e0a7eefe2c91190fda82a7d92cebe67b8ab44c00012310b95acbddf3e6253d1999c74007d7b90ed2ee4290fc5bd59261e0dc11decb3241143c75b93a88374ff73194e10d96caf431bc4553992f72b547c9ec4ecf5234abafd75187af3abbd2c91dd94830171052e4fa7bc596ad6c517b02e98a13f90cfa2c3efb4ee40d929df0e368a762c75d71add2606fb63499c1223946ff87205529c935363b350737ab270fd27736948592acff8ef4022877305122d0cad31d02598dbc7b294665ede7a593c36d534ed8cfc51ceb196e927d1cda87b477f8d91b113905c904e1a49b25dd617c6b68d0aa4b2e904f06c5f69b11d9fb333e135186d2e2dac11889bd64c7db69a2ba59d3c528a6b52b0dbd4a47f887b985cf2616c653ad8518f1ddb14304b0d2ab046f8052a0162f2d1ac688b153a8eb461afd76e7efe15a2cd20b5140870e124ae23d38d8967f82122cc4e454af2eaa4aba3222676d53e4d6f18464491bd35e96add40012af34d9692e7c4cf7d6cacc0a198d3f0a2f0f90d7f7ebf1edc87d5bacdbc84474686ab8208cc876c9b0f403172a0dabdf9aadf23b5bb3e6e1473e6ca3e7077fffa98fba44d0a0fafff99814e790387d6743750b011b8545cdabf88225ea8337a2e2481d770a5d9568fdac622e4b5e9c21b2416ff87975b29d704b1a1f05516605c8800290bacf7f7080812af267c70c5a7fc0fbdedb3bedf099c318138e787ee09b1b934104174e676f241f2bc7e2e06ca5c913a0b0ea0a49dcdfb8c89e16cb70b9cad0c10e03cf1179bdd63c6b09a35ff2c9b35e7210204d1345a32b6c7fdf2de54fc2e4a083c3d74bdabda9f61b8424218a5348ffc023d17598972a87823d115586886f6d695c0ed1d61603aa72fbb4fc5a2eacaefadb092108d4b22f60a89312159bff7bc85c694df6047f40f517fca25d522261034074cb675104b580804861c7c166a05ef81bbebfae5ec69a487a5cefa8f8101028b7f2852544fcc30610e32a83e49aebe8121c3030595fdf76fbcd3bbf43b9ed3fec48c691e216e1bfb6990d811f7fa92c7115573a4a6ca5b08569bdc855f689726c7d429a60fbdb4a6528205f78ea998d2cca4db65931a1a9bf245ff94c70707b54f0238d73b57203b329ea7f0a52d7a5c7195d0e364867e7df5a38e475ef9aaa8297e58ab7c0afb87b5dc0269b3298992fbf793a4f0c005160646c62010b9f93e887674a5a89ca7b605c8b0593b5cdd12a52b489efafa4f0937d57cfb96c76b2656c4282ce13aab8917e1399818dd06dda787ad3e4e0549a59d5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
