<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1babff1382b49a00ae18cd890769ceb2dff85f454025ec7eb0c86d25a57732b589f550ca1fecc311e69a0ee502dd1bf604274c656543b6ddbdf92f28e71305b2f09f7de4894234377c1fa2ac08ae49d94219b4245b21555521f811c7b4eff8693b1773670d0f9da19af1442c03d4e214ca61eeb3132fcfb2afc3f8e6eeb42c84b75599edb9ce18afef053d87d979c639da70afccd3bc3cb5750f7ead07482fe58a51dbd35147fa67be37146c485a5fa0963a03104485c80188b33a9d2ab5dfc292fd13bbcf1b44317aa8f04bd13580bb0051d9262ac046877acf9bdb00bf8604d1febf21084c036db43497f49d66f33437e58af9e49131aecac3b4ac6ad94f1bff83eadef6dc5bbb823ba4909bda8da79ca587898221b5fc6b61b2e7654c687263a411e1f7efd9758ae34bd8f12ad5f5d59b9781b5e6bc4dc48e211ce645f2fb1b65336f9c276857a6367a8eff87422458c39c30ab328af9f7a63b7be9bc01c660fef0a4e98f699b1a20be28d16da8bf1d4887d0a465685a88c341a0ca1b2fc28ff9ee7333c13a7e0d553930811e7586f83bed51b1e7521e193954fffb9f775cf51acc118127d26c65bb5285ae730ecd903fdc7429dd284a246385690239ae0540176223a0d3b43c414e03615b1316358771dc7f8625b5df4075ec58d6beab626e49815f92fb234febf7a5af3dc202be8f1b07ecde2ae6cc93a6e7512072e5cd83428c3cef849135a5edfb465ee1678479eefb99ff9b1f95485f5cc3b32faa20829b831c99426d1550cacf2d29889734c8c0265d6dbcd8a2d86494dd325a4a7398129343f7a4e8e4b40fa9bcef04c8aa37816b01293feba0922b168b42aa6ac6cad17b809f7c573b26daa191be4965c5de62830d044c47ec42de73e53a1fba7579811bc13821e4c55df049eeece3004fbfd41b8cf83513b57fe4f37f4c81015143ad2569fdeb7cab006592794111ef6ef419ebcdfa026df48d268d143cab3dd46ebb360fd031f880a8a364aa1eddace3edac3227499da331b3fff8c5d0f483f63396eaf877d07959e5e3c42fb2ddd04010aa9d1b36516c4435c544bba127658cb3db0ad5678bcedc214423e69b54351890e835749b4f75a3e6fc3945409932ab58a4e5ed0ceeb49ddda31dcb065f70c09e68d1e32c084d3bbc29ba098ad0e5085ddf3805eef25b8d275f9b1f49c55e637fc3cc47f408b5e37be27b42f4e4ee0819269152e806c3cc8727b728c61a32ee3fd3f8d54467cc81c12acb6f67ed1c0f09e26b676eb9302f2c5964bd73ffd554ff7de5b9dfc5c4e499df86c399712d63c66d24fff6e0fcf317fda227f99c3c6607ab0131d48650d0a1876e8db955181c49eafcd57e683ecd5eb270c1df6c9d6377a6c70eb6d8c1f0d80d1cc1bffbd3e56d9e700381cad4693d7d4445c999c019ca63c69f7d3f624bf31c93976bc4926138dc0d764a4a0884ae29597553f2b3ab77051fe3c55e9c42e1f739ad7a76729f4ec51ce8740deb4c0c2ae0859365e6e3f3b78c25cb3a006174364446fb8e02e802d8bfbcce894885828ee3737f709afa31652ea39b00a6d0e72c43b7bd28197d3a27432885eabcc79f5a7412dc6f5c8dda1994bcf8faf7d03338868b16a0793941db4757e1e8336d9bbf4435686ea01bad6ebd7b0a07b60ca44c0b138d20466b49678649b8d538d0f744071d8893ff59a2ba54fd77b50d080f269dbbee3b6816bdf4572f16e3e80771e67fc86c37e20d3fa0fcfb6bd781ec31cdfc04a28c6d2f972371666c3bf993ca9ecff259cc583718f27b80dbbbdc1bd1c3ddc4674f75ed454262002ea49e45438edf9bfe9af860af83b6a969726cee64ab982e9668b0c91ef30203ea142399de9955c1f46ff02fbe1642d11d9db1180fcf5ed7db22a38ce7a395f5a1bcac990491396e702d82426e24c2cfadbc51bd62ef5fefdecf9fea174a803a5c72fe6f2d3a1678ec80df65ac51d2a81f276b8ac33d426e312b5eb5e47e75df03675ff36fc70c6bb4784e10d8680fcc837acf0651730182b546ca38ee7ffec78abe7889d8b30aa7153526626bfb16145325be82db035aa6e239b3095d012a285ed069b436b9c44bb8b286256f95d5c52169f85d89c419ce4515696ebb4fe5fd60ab7b4e90ae72b61ee77458226c28e1092ffcb16ca808b3314d6c133d2911625a545b21060c0ab037e4b9ac2991f75dc5c23fbcdaeef9e811b5fc9521847c510150b38dab75ccf7bdd8c6d2a45fc874154f23265c3c4332825c0cc487c69a8608a7473caccd1e1ebd458afcb22ae53ef977d76e597c080b0fa6014b318ebe439dacf3217da250e2d2e6fcf1c05b4ce20967b44911038a7b8a07c47937c61b5340e2d2ea9b5e666929ffecf0514a2ff56f73f55fd34f65baadd418d3102f4ac5f2098f7fe4e255dd79dd53e47e92c50cbd0549d507417a1b81a05ff495d1020ef78deeab5b669878ca2e08afcbcac773ec4dfdde0eb69c0b20e620e19a1a04eb57c7871d18c53afb9e916e2c47a5bbcc8a5b8f80b69fbf425b8a174af85265b747e1434e366952b1414e0d4e068b15e159966cd8d87046bf84ec3ccd85643831a3ef88105e9e663bea99562f7b6dcc793a6fc2c6d52bf5640842068128f0ad3f6cdc2d0f3654097e3d886ec7ad7c86db294ab6025d24b6d861bcf3463a717cb14a7c142958e9c5192db24bdc69b4072e8c92e24f9ff5ab7c1a441cbb5a558b764df904daf7c5fdd62b08675f2b3dde7f93312d62a1058b34cf94e9abc57fedffeba17d8b998f14c480fd2f1b1455dca6ca41229f3f0c15e7e25a263f1fe06b8867f0436574f22c9db72a1acbf984563b7ddf17800ae194e65f63098c59a5447b7589405c8b833ef33042b409a7d025cec764b1c4c64d4b6311dd21a81e3e66905315e3ccf4907d235209d0d69bfcdccc6a9d29b42c053f078b675b192480d2f6b40266e3b440607e54ddacd89928256a09573a3fcc0603ba36c708dec643668d52042cba00cb563ed07c774bd4414a43d757da137e4b33bae2b98d34fc127f9b638e21909772ce5e66db5605b47aed43ebe7f07418783861940f492bd8077d673b4abd5b3b1c7c3672d2d43b28d850ece7e5f9410b61925683eb9af70f32b8f537850bca9e4dd4279ffddcce2b2efe61ba2c5132fa37f45f6e361815bda2068db8035dee78d1a8585e9ddf34ecb4bd20516852aedbd25a07c8fb924be51fcde2d238e685d037c5c51d66c462f42b3ae4ba31a2d91968a32a6c1143eab9e75bf3fc4e5b884c5af785e1d562bd6a68e9fabfef2ae5b06edd42326778bba21543db90e28e4ac9b4148c9dea781c34e17fc2c4302381ef362b0b4768461f1477698200fe179a9da547d8c11890330da7cc1c9313962f9580b8357ca3c68b614fd8bda04ecf77b7489a21c353e392b32f92ccef3ddd3a40b42fee0d9d56fcb4740253868200d3882d610a6c367e4ba64d1d2d5c64231cbbfff03896e9457d7a7b6d7d0f31b0175582e35122d6a866317095525c128bf273a0227c8e49f93dfebb1398057d56e8ed61c3473f2d544336759df8b734b1b28d46cd10d470205ccabb439673b3bfaca947d21177c8ef5af4792fc4a07821093c530c29eadd9cdb3446d233b7bc724eece5c07cf52b1462e34144dba0a72bee2d764ca916e0134550fbc66ff432fc366d536d4fa42f10ec0ea200a7a62d77d65a1977057dac20c6595410bfc4d55b0738e674375aba7f7d2b2f31e6a6db1e002ef64e2348266428fd41805d55e48b5ade7c6983ff26acbf56d77f02c5e5797d82bdc6c454939149a74bf94881e488fc327caed81d395a94b721ba06a26bb1c7f3f956f69611e53e1d4175457329a930f99a67d665d52a2fb158c597c0c74f0acf074ce1e451dcbd4785d83b07ea97e1747a6e142aab7ee52a90cbf3da2b252e23d6061d42293d74ea282e0bb2b5edd4495222ecf4d7bfbaa10c36e5d44f8e41f0897943103e8d316bf0f9d9f8f3b810a70d717c8b02de1b4755cfd831f2a10756f391bda19cf21ad7dc386e3a043d34304690fbf889d26381dcd1b321e18c54c428c205ab58fbc19047e74b20f9fcf24b23f637e5d1e0a215a783ea6d92b13219438734488e4bc14b8d15671823322c7b84a19838b4844ba8b7ced69fe4e2079d117ff555f9c5584ae53b86572f9f4504bd585284751f3d0d7ebdaf80780c088d5e8ba92d0e1ac7a8fd0988967ac33ccc2b3c5a2f654e1af01186d53a467431120824de8d050642cbe4aea2cd31da738e56a45228d8ad39bc4010415bd5230ca8cf138611aedd47e2b83f7bb82f2da9c1767450d23472956fa5fa6290d137048e757bd5a40b8f6d41c08b0bd125d1b6858ec312e7428d1165869db213bd1de70ce2a34cca12ef387bf6ae8729453785d74dc51589012a684eac78c7a54d514d9c97219199f13e9a1cf51983df1e0998ac00a0141e47df0c55f0af524ffb4786b111a695188a02e92a41e17d773434d326705b98697314d95fc9c2f785341c1db76231b3f20c68e7bca256b77e2253252ef30705e69de299ac13f0500a2befd9c58a41aa74e0402425b48345a8818a58649fb234386028004bb9a0e8710a703d415dd4caa547bb3caef25e18c6eaf70684846709ae2a6d88a06e5e6f413d7c7fa0bedb73801eeee7d8d6fe0a4af5c82e49392b0cad6e89d88200835ee634e14a05a5d942f321785219833f0971722e3926afe69d46756795e7f1477a334b9389a0007defbf3f71ab94ecd60250d4f85846a323c4692fe5fa7dc4f40597f31ee8e2ac8f843a9ae89bf01bbc1ecbbc2c092267ee12c0e237afd00be2a33b952da33938ee216af06c0d9a4badea929db52c9b84f3761182e20addcdc3463498ceffac36f74aec270e6dc29d3c62fb3f70d51113e537dcddf5414e5d426aeec533c943eec48b57879357e504ec8deba18ceb11f899803aee2f60d078a2b14c5601acfb60bd40af85eedb0315ffe2564195090dca1589e599a741ff30150eef1e63bc1ee31834a88db1ed57fb819ce42f9c71362dc15002d6bdfd5f7c2359bb3aa120d467280120df6b258b7a72132888b70b29e571f4f0e18400393b67a5644086ea2d8d9578f8233a6706c2ed8a779bbc276dea95616b56241e7843fdd763202d26eacff587a4dbdde674be20da95e8936cd7c17ff266c2648ce332e20121a8df32adf7c1ca154700b3ee1f69e70d4cdeb2c69cdedcc724415c81bdb7ecf88afc66ee3cb075c8df86618c2f73679bc0b31d52f7b64ec127d3876b0e192e808ad7673ba6138236572d2a7e3e42efd3d61369d1485a6cd94dc2e778160759e611baa9dcd44441041345554d5f6fc3758278d9bd6ddad1d930bf5137bd9ee2dea3ea175e05fd0a749a8b2f0ebdc38ccdaa2ed972ad79a64be7cbc239a8c8d17b4ed4f4e5b7a6d0275d13f996ee2de1019d6a7cfb702c60e95292b4505e6b27fefcbaef39f874389643c6050135a84cb5a9a041f16953b4c6f18742ed762604994564e4163c860f166608878479c0eb4f69c9890fff41796618e8728b66d57ecba91d1883d3745e7ba987edef3d789a6364ca028510e11c572715fe91a6246d1ae95355546284697221c02ab6c0effb487d1eb7f209a6029b494b1125a415ad7b7ba9900598b308a250fc38ed5c012e2d8c0a3ec3c92eb4bc92064e08d76bf95c7d700cf72e57425f34b55af6f7cb6e292291dc1e6b60c876ae157eb060296f276ce289556bc09ff4bf4b32c02f93f722f4064042d3e2209b3a8d16f7ec80d9149fd3bd246faa3c9f514ca12e419784402369d1f5e5598e0c7fb45c6e7560199ba3564fe299ac3d2ff9347292027015e6844ca18592a20d972c9c497fc3fcdb7b5fe4c87df9f34857b0ae9add5eff558d5b7f30d07f1de93b2a029834c1930f5a9b65cb3f7b95bf7d2391246a912c7234e75b1707e8e8074191bc508a85f85ce4ebf9862f44011de0a07f95600e7c7b1b3dc398ea53e8128fc74b20595b78e1c1a8d6d93d6447755334c8e25447e1730e4b653f5f69919e860be7117ae0d12b50a92fb479d343cfb37138d04630c7ac9f0d1d783d15a8dbdddbcf0da690d129736fb525125c2a20700feefb17fd3c797efd4e3ae5490e275775b27088265ff677e1442ce658f27feeece7fcea5ceac765242d162c9ce5aa78aea3c79c475647cf7d053f14eb0922b23d27b4f75d796dda34ca4bff6cf198fc2183c762d39c3639f5e0ae940d9224effa2ee707df53879c8119768add228920e56c5a4e821d0e726aebf4c25d0ff3d0cf6fdaaf9c5e62f781c11f654520773502ba50965d2224989a9db3bbd9969ff9d37d33d6fa3d27f68e3a29c7b59d04c0a3a19a80920bea1c16028ac99e02d218ad2af52fc3c792c279a822f5a29bc23fb6be3653d4e44191e958d1e959f3cc9ac3025a8879ae7b965791f5f02c0fba77836a6322b9744ddd0d1e7879f0d139082bde415f5adea65a804d61871dc21b09fb437406f99ebe2c91ceecddd9a8db7ad8f364ec0aae5c8b93bfb218b54f3638ecb3864c7313f0f807e1425aefc8de612bf097efc6f8afc727e9fae62bab0d707a1a1c42dc23061ebf15ac65ed8bbca3045d8dad5ea7e40badcd77d631ff5d77255bd122f9175726e0db5bfb8319a7a743f5703b08130f4dba2bb56aeaf3183106a050ceab8d11c7fb10d9f81223d798dad056f556e47bfebbeb8e712bd55b65c1290da327025c5710df666095ba7de40313312a9d79b0c76fbd2c962657dc4218dd77ea7af3e4b6e7e10063c30a265506289f0e9a06f68a20e052ad1b4e86ba4ad494abc647e34a99c9f670eb949f610cd5a8ae311b9a3d5646a50777e7f2b9d7780aa68370abfb74a6f696e0bf91c06838bb39e485123b158f9e306c8189b6504994c02e5c9ab5ca6f92826930008a777e5595664ff8932f21b90cad6e45b11cb332c1c166d694075a4af0f1fdd6bdb5689cb7111bf2ccfd637274f2009c99bf8f23de5571ffb2441e220fd16c81a08ba14c35c93e1ae79bdf1a99b32516496a0089de3792410988ab642f5142c1378411bd9ace6e63f662867176af40605e38f9c7c1dc612276839d3317d9bc73dcd28431f483d266cb665b94abbfe58c937d234ed24ef98330d2ea6af38259f9ce94f94b70e804b154a4ec4e71b0e1804c60b04e5ef16218e2418c75b394f73dd7d1ab68bf3f7c411d6685b4c54e4fbdeb8294307f3471c77d8c1bd6cee85a5fd3d092fe3dea75f8cc4bc2c2854623939d725a2208edf8fcaca9676b175dac508e3357217eb05a75f897e590ca9adee30c87bb117e1bd50ba9a9c60c69cb95faf17afdfb24bfab819d79603937babea7e2250792a6c0dd50ff9460c609316998a478af9d01e4e1b816b210c4ce8eb4da193d520fb53c4c57ce7fc8471a609844f44bd5bc53bea36ce73076ef782c6e62688b38631c215e09e9b964887c5edff70244e7c4b5f3a6f1a3d86a9e6df56017e6f5f22865c3d104f556ad6f39434da6f375c8350e25b6b45ae9dab10daf12cd12e4fdfd0b7fed92992964a3717d5a397da62c2c1553afb1ec510705b7fab127205af69e57772685b12a26e7659d55b98eed48456ae219b63056330acc876dbd75e8e0ac32e1c604ffb1c38f60f414007266435796f8aafbb92f678c68a6442416615825525e37dda3bf3d6ff8e8c9f427f835b2dfbb775b971842f99982776869b66ab0635933c231615f758c27319de5cac4ba3c010b46aafcad981770f3d4dc28e2fd60c1d8ee05f46cec169d29986aa3d4638ec026db302a66cb4ce9b56eee9caf18cd4de93e317bac2c18cf0086d055b03669f8bc1eac2b73ed53fa8455ef36c0945759775e46e0f30f4eacda4bf1d429a40006d01b65d815c6b198f18597552d4241861ed2f470ade57f79fb5d31f11da558d62878d7a46b76e374d6bba3586d2dfa54a097f0c27b52c04891ff7245dabea58a2ddb715ec6f683fa2db5f90afcdd49d232c24fae140d573acac059806901b553dda02f8e69177389a2e8586174d4e64492ba8ebe72d011543825d52860eda8aec5723a186177ac79dc8feefb56f832779f686e36fa037508a98ca4b38df1f848d608b32b467c9e6c28c2f7ffa223a38ee6ce39536b422a993f757656fc4bed26f263066cbf7164e581f77063e617cdd28773a45a2400743859774d9c21f69745661deef9a33f83871ddc284fa89cb34fa6c5d7bf237319469c4fdde85655741274b7563fbec1494eb9f71fa24f32d228e7fe766a14e8650ecfa37ea42da52ac5f1912104880b73625232ff85b71cf536f23cd579232b6fb12da043a8f2f5c798f46f0b9af752dc6e9892af97500d1fcfd038bb5294c7c84c47dcf08865ebd36e7d07509ac71f1a07d864ba04f12ee17106f07043cfd9b772c2b3b83b8a616e3898992f40d7d562a14e7133af3b571525bcb4f183ee6a598a4c40079de6f4c34522b2042a595045c3d203fa82b8ae3bb837ced16c933c70949933fc327733976d423b331c85fd44faa5c57a4a8130df6f64cbfb862dfec4d080ae5afae5369b659fb5781c2547331194d8b2be5538cac09b9e4a2b97df726e73a5c89f2ad62de13d22c614eb0871c5e2222eb94dc2bd1f784b71e99251478cb234efc986a1396b088a270e472dbdce0c95ad1563efb64f5e2122aef0a49339ad1f5f713915023c2bcf69075d2fc564f8d31787a47043a831a3ceb2343085593a869590423b3dfdb1de2184831f0f49bc37c247fce084d8f53f1546fdcf53de7910f9d3d34039f382803b95786d2ec8ca6af126e622e60e0ef0a67d64107bf6caedecd8cf91439294ed9d3a5e8ac68e60319561fa485f8f80da102e2500cdfc077c04d38cfad456443bb873ddfbb67e63e047964c14d625772656a13df9a46f5edc11d767c25907ca7cad4f498db3e1105dfce57263f5645c81347cda7ff0d05242f5b7c682e5d11ccdc667974bbf8db074182a9999053d4b0eddf4110af7e8001b3939eeda72ae92c0154eb06cb05f326f13a453e4ffcce647fbb6c0ea724b3ad8e772c7303f48e18e89b3b4880027962c8ff4ff31dc7c9f2a06adfce8c214a460e04b315ee810c7a294e22c3f8741735301458d0a8d11ac720786595a1df5412a9ec7bd0ba81be33de051d5a3cb2cd0862330122a2e4e777a96b7cb4bc276a01cf731be0eb377a38bb0eaee7fcdf640dea44d075e7c54c585cc662e837e5523e606a98a777b32f902639d1de31a2cae7d9fcf86125ac4badefaada2b169bd779d0a5b1100f29a9e99f42ddc3f90aad03acd5a09dc950898ddf70bcadd3e20bdc80a17cbbf78c5713f1c34d257c412f3f2994870576e360dd607af0d3ee1a2e98ad8b172f7bce890faa606887237c2a5df23d8a0d2c2743d9bce9e3dfdf4f083fa9bcf535f5e8ba1662fa72f7161fab5f77e74490e4a20029ca8658c2a1450b4519beecc3554ffe7fa51bd747f7bc5a28bc78f77b775d6a4667a359e7d8e9d0618c8cfcd6a5d890d5d6b51f83cfbf50c37f32da10441f1b5c7bd9328d98a8fd99b604a2a28bcc2e5b2101e7034e739061186cda2c09fc6358ca0f73b47962c7a74895a462cac95febbcf10c8848e1ceaccd53eff6e00ef57a980e818ef2ff0c5fc0f5cb930f2711c4b1eefdd0ceaaf20f966f8fcf403579d0311bfa80f3f0b3b18405789d807038340c98942e0f85b7f2a4eed0c7b0870a6736775bf924acb2597eeafa75a52a9759354a5b81fa7303f7d3a14a00d3179ea63b9b2ff821d9c742e6ee9e9d767dd5cddf7d9961a2bdcd579b9f81389eca31f9075b6850c2b15f7fe2967dccda773a5fdfbf7ddd1d1bbc6a1ca85b9368125383887a71659b2eeadef37166d87bbe0785715a865d464bb0e268450a5a2c7a62f3b93a3dcc0e051ea1415ba00132ecf0361f47017e3beef2109848ad3e9f4a5964f0f09df3d6d7355d0f73cd35f6a86761834d8878136612b80f5af4b6bd72b53df128c7f099dffc529fd41d0ba3a5942b581411deabf328c174f88538abc1b31dd58a01a49b2597e2f8b9bbc615f41e44fc3a2c55786800a845d3c3304f9a1b885a0529122c190d2778db1bbcbca8c52ba5436bf9aee5c6ede1c8982ef388a8f1289fef95fc58a77a33dfc1917acd8bf400457ea4705a0ef0e1fb309d53a7b5a1b1542e9f3405804ccbafdeebc340d47c1671e25ac990b7b432f0d3d1abcec237a295284d0ed01c6709209dff0ebfacb180bda25d0ae469dcd3fccb21d3f88c3b6159af78caed96fc469b91198ce209c30f30d881c1dc967b79e8c26a46742a5961ced2b74afdcd73f492f9d763a335646973f34cc92704e44317177f34607ed16749e4f1ac6ab25c76e3845fccaf5933e8e39abd929c79b1124d32ef92931f9c12fe1a0c7aa5694d71ebc8d73a6a1c2614488c719c44c1faf34e84e3050f1740a33a9c3d461f8db8734b782a0ef37b4298a25d28e1316a14dc26d6d5e76bffd851fd801d3273372c9563878bb7bf944ed6719fba65d9d5b68a8a91a2f1d2937d0dfe176d8ae1abee719e3e549266536d55208917b87b368521e8db5447fffa03c41de4b9470be062678c001498197935a9ffba559c55e56bd1096f9880f2cb1dfe3c2023a8a55c3069ebc1f37f96dd9b588ef0bbcf8f084ee5b7272a50bca32799279cb1e9b174ad3d206994b2af0b142a5af7741a6f54cd20be92894a1b37ac72cfe1d99535a1c3301082e14f6e118bced3377ce8ccacc74304f1a641e9a265111f86e46f7ee941dcc4cd12f8721c65335ee828e0c0706c98bde6cd987f0c02b128a47f570e1f71b85f6603848634f141a973478909045b2698c72ea8eb425e56ebc9f26bbf48fba74699f3f32b676bdbc3c3afd7119ba7f97928b568e00235743a5005c01fd20117a05e09ac999237cea2a74270a81076fa2671230c2d981d71f104f5b21bb0cb1f582f61abf25393ecfac117e91e84ffb205961e4828d2a7a0c708f827247fe0e850d2bc9cbc39d7b79961fb868aec776ce078b461c58ac65f8d1dbfbecf8e9e26a5ffffb55efea05acda56e794b048d1b63c19ae61c2ac8ac9d07331e0f849482ed92968778b559fc3835ce9668c121a41da670dcb448128621981176c82dced46e098dfc171b79ea85a3f6ec797f130342ad1d1172c0085f0f3b63507d05d3bc8fc402e73b3e6d7e530cbe734f66cba6a84963a275f294ecf65be84f82ad15a200ae3d701939888b0cd017923d6c6f4e79346ddff7cfe2b07c57c307612d782c10f933f5db668d159fc1db280fa68b71e7c44acbeb607fed2d48bb459d012018e45c075056375d2741df7003c30aa421aeed0640173526af9756db611162bac07f9662038b6d51b69bde3e83e027e700ab3032cbcc99d068aaa1028abad32cc7b08793289c81a30f868a5bf2935c8641c88014d525b2befcecd7c511a32d2fe2cf1f27f943f72d848b84b3105da859c5eb0c32aa81bcdf8aac2099b88ede599abccce6213902d33196428b6a80e745f2dc2a37b9e3cb2c917accbfc3f1428f09e2ab34e8e237ccb2fda9e22b8b8eb0351e4ad907fc00dcc8ae11913b3d6c0ad4c652223812c11a2b69fa5b1cf68be114e8e2e3c2acb86661d010a53b859d68e6009d69b5eddf5da961f01f4991c14dbf2acc5606d5d9f37a846068f7f0638e949e56a8dd08d3f63ac9733583d1fa18d8b2cf0929214ec6a43d4f06f0a98903f6ed07b98db981b28bacfb20b5f2cda57db9b6fb1f0b710cee704ad2062a3f377bb357b663d391be333959f20aaf5dddb472406ae7c0d6f725fd60ee4a2d220f966c21b4d6f317d7735a2e09cd247fd4e5edfc6e4625f23a21dfe2b49206640d9a4947f565a127b9112e15430391de9a44e353fa979bd7950cd49bda9fe43951f98afb1670ef16d7b744b88d637ea2e626f3f9e9377c7eec5682048f31c1427c1bb6ea3be725036fe24ae76797bd53e13c1259c869d6ed51ccefe684f36adb7aab3b2680606db276850b8f87db5765b56a96f4f29ba4d7632eddd9ee378431788be4deca4aa9dcd68b0b36c05822827e0f897b6c2534e516af108addb14f4c44c7736a2bdbb4caced4adfcd477b9bdf48350bda5578b0b35ed0b0da26d1decfb1980d0857dd9089c4129ae00aaf01a4519eb5831a0d770faa0fab4812d100f9e2792b611ac21d903e2d5ae81f165a00198aaded2b3aa270711c236212ef109cadd42e5d846dd29f5d7ab8d8d44a7dfccf0596c0e9a33858f41d6d7bec70048b637139b11527e2a44c9cf67e039d70b5be2dc0c6cce4df7eb9bb434c60172f3a283b00eab1e177f76ab91411d0172466e26bc3b0e7b449e4eee3d161ab3a53e3efea3a5bf0487093069e5faa837eec2f437dc27034b05680d9c7d9841dac42cabf0012c4002aefe3e1f4cf7b9062b24ca871c8b8b7a63b0ad5d0ef72ed83c86cef798e99348801e06c315b0ce300d5905c6ca97f70debfec11b5290544296e54a04203de52a6a96b901b738414b3d2b28d63ab028014464ca5df347ef0f469d7bed4269efeeba17733f6115a21a771b9ed64ebb71d1ac89b6642e1f0822ef6ad7be439814e865b3d639fb92057eeea45dea083c334236e5db3282b27de1df26058bec8913e4b2d28db76944a866c9a6b9709ff77f930b884afa81682a467e027f87cfaa29e0b02a180f6c5ed8f3b40bdb7e6042ca5df7ffb6c9303729bf99e6d311accf322b5e8ea8b4b4413a9f1e4bbc0a39b0f9854958bc8f464dc1dc39a2ce311c2114730e99793072a1408244ca416700ab4eb61e403e14b8931e41419fcd2d56b315a72769f5b595d1cecada06951bafe1c8990fa5d53bcefbeaf4c17d06f20e16956db8c108b4ffa23161c21406dd5ae980f79c25b9d24b59d60f4b177cf9edb9b99a90fa8a7835a141ad2e5686e2146d084ed196b1bfc0bbcb1e5eeee7aee6f9aa979873d7caa0307813a9303d27dd4a1dd25da8ae65ffb7db6cd49a62ead8e614550f88468a65d874e1048d1d8cc1c9ff65b00d6dd8db2c607baf3fcdcee2cad5c7cdb385c3c395e1d515733fcb9253d845e65f42f7b9238d39e4926150dd2919c4be675a8904ed633c5625285206eef4594c9cefa256c5f41c08638839a2e55c69390622d8e4070e68a017e5727e677c361806da0e23cded5bd2e56deacbe4e61d8b7ab2ad0fc30cb415d0ef0b65a1232c07e4051c8aee1e824d51df2955188358be96ac4423bc2715dc8c59187ef9a5c23557a3e64af5c95bc21a71f467eb2d99841b3be30239f14707fdfcc9015b63c712b7797c33be0976e86e15768207e641bd6500a031b5349aad1ffe1e7431289963266a4af779c1d12041796a4fd7b9b7b976acced4f12e84dbabdd484528a7a1a5cfc1115ac7dbd00a2f1d27b6d3f7f0cbe02b194dce249dde8c439b4e7c4203b1e7425eda9d06b4d1dfffb0949be646ec3b82b221dbf1b8648cd353d55a8bbe66f13196088a300050b43b8570e05cdb7ac4a970b79d27aae3596394983a7137f3a036bc5fb82c52041b6f7af1681668629fa15465c38154c749135e491bbf586fac2929e62cd663a322f2e12e603fb301a6b5f409e3866aedb811beeb9aa2534cb06e689d940bd7a0edbc64b453db0602a1de65349adc168ecc121933a94b3c90c452770eb1016bfd5b33ba2d67d1850a9f21048a10103e3df6c72480822495baeac5e8f8b1e509e8053dd273bd19ade56255d4bf3e976425129b4dea4820c2dc950fea87e66a0bfa8afaf5ff097c8c967c07e85eec64eac18f244feffb5eb70c1e4d29419f93115b89d8a4faf025f9afbc52974cebd9e3a4380e69928c631ec50ead9bb4b4a3426c42b1ba517f83af428ae4ea5bd1f09d6050491ca7e34b5304e42b2e6658dcb5c2d477db6b959e5e8285aea0fd3db0e353679e2a5db1cbc410b2ba36f05b652b7a06a52ba87c3c9e8c47fe139652eef580c25744968fa34a923c157dc8b3dae17618b516f27ab27122e032aec37212e6c15be5d54586e1509ea7e687e79cf01f077a6a6a053e86a632f245ad4e575b6144105d905da940e94ca5cd88563e8f56ec002ba66a1bfbb241a49be317e27baa8fc8e959a0787c075cb8e3779eb022b3bedfe8cd3162ea565ef5421d6126d81729c3088a74761ca8cbfad9efb61cfba85c428b26902ebb7aec8dd525d4d254898436994603697c932ef0f4dedcac5ffff78eca93a6380ac6b53db53f3f80aacba44b3cfa3769c0ff0313fc6fe44eefa4c46ce70f294d85e69e11966c5313a5fef9b0015f9b8bc00b93f04436e14a6aad073bed18132993b4624befd7bcd6f69e88eb34656bd7e5577494047d3bc77469635ee29a07d8e5044b89864aebd1e4590c769d5e18714e7333cb17bf3757d117ad8b7f525a841d3835a55ecbf3adbc31299360d37fc0ffd47530e07c18c1ff10db68abe6887c4575636996eed43632cc39085c3853a22c3da497872b955e0f275db875eb7080632b8365858d6fd8da83ef75b0d22410a949e33c5ef6c60204650f3e471cf75f28154aa4606a53bdf6674cd7f521cb5da4c911431bfa6cad46aa3e676177d0b4a76a05ec5edb6882828ce323d69046089f994bc36a2bfc101b70d44ed6b0d858f931a9039719236b1436a1bc680c2b8ad297a61de6537ec3a79bcd3ab72c957de48eae9f6641f99f1a7537f6fe7abbcfebb2553824dc759872c95e69ecd74fda3fa3f02a3d5a10419cd0aee7333442fe49452cb84189e4b70cf371a9f1b4879aecb153d6e17627350e30a55e62beb13febfdf0cfa8fe276f7f09054a707f499ff7c135d49686fc43a8114a9f11afed0dbbb41b3417bd017347c61cc1b9abb076c6dbc1c821c24d0c70f8f2598ae1cc7c360c30bc5042ab17ba921af498fb35b46dc4365c37f20c4d291b4bb8178969e0edaa96adc8fb509a4e1a0980c18b32bae4d4401daf40750cabb18086fb663f6a9e1082d8e0a2e1c28e9ebf803a4fbb989abd883291a3edce66d344c48f2dc7a898d5b6b1f17366af98c82bba45151b27b5e2e8e050241192544d0209743fb05162bda0b830a28043db9af56dfa167a0f4eeeda0070d86ac91d5a0715e9dd31e75389ad037c3cd4d7071125dab00f510bff7df3696a248fa65ced0ccab8f21833db5f93f4ffae5c27b03108765a5ef90d557acfe8c31a1b547cbd742c8084a5d320b8cbc8290866455cb2e8519fb785849aecfa3ca6c25b636cddd7ff6e5ff94258deb30b25d3313883e32bcb3d9f69cf906a54e0b04e65f73b2e5eb1ec2598822b95934f13e023dee13957bc1196a8166c0eb9932923773797581a45d697e147b8b739d143f82f7155a4ff7e03b091c7af0ee81a53ba7116c602953cbafbdc3215103692d3a4fc6a8d7a827f87e7257d45e235a45e0351186ff27adbc74b89a5652f82966ad9bb18f5b2acc4e0fc78446092a7e44fc3f2aa8ddda918888b9b676fa6436b27264d5bb160061e976da4519b378eca4c0ae7a8f39f7a686efa057ac7b7674acd1202ab9f199bd3e15c301f907d61d362dd2688971b66304319e80b08f4a56b77cb3b0a7085402df5016c27296e0c3aad5bfa0f75d6aa4564c1b5fa74bb229e14124030639a9226d11fd8522be710fbe3f29cf3010e0e134192bf331cd72596a2e224bdd752e137a5c9ec754c8abb53689694c3c08432207cbf30dac06239c4eec68e4131d6d53e62c783ab1d3ce9305515a27832727239425fb47d60590da816e9cc7acca5812c1b62a6aa0a75784c519297f1f8ec2f1477000fd24fb584a554fb3bfb935ddad2fa91b6260a5667ab7ab95055e37fb20c45f6bafb8da691c320b47d25b51f391606780fdc793684dbbad4ba6b75d185193134996899af48ada23c1e4556c18360975a4a2dbd8de30b4ebe97d275120a26296143f204b624e4928ea71e4dbaef3a428a6beeef1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
