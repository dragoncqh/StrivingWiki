<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ad18239781e999c88c100b79cb0f3bc5429c01d3f040b054ae56aa3ebe85633d839f10f4d41f69f43614c264daf713135c557ad4a9e4f6c21b1fee1f8b8fe0adc6d9b6e7fe00ded4efe5643b276b641a43eb20be49c3059fc75b99a76ff6412ff9daa955cc716749dc50949b89733b779d8cd01f9c15ca6e7d665868c144915900ebb62516403803acc8f79989a36e00e7f79dce01cb33e0243cff6cf4c663753f3ea160c855c5d591b7e315e3e2d42badc8f87511d7881f81f0e6cbc87ab6410a7e8027e5a4377fd677e17534af792fae193d3977bd16d41180210fa68c0b749f9ab6285807ff436a84e2791c811c63cf762819b9589b0b3f03f47ade9c50ba81f35e964f35a4f84fc83c7a1a39b0a05df6ed5adea735c390938ddb249552921cc6732718fcdfc4de6ba413d600544e65da09a8efa069b282462efcbd0caa15a2b436b875921524d6231451ad46c11e0c6281beb45f0d919fc1585edbce5932e6887b1b4f303951858bbc0ecd705e0fe6b9edd2220f5a1033293174eaad31caeb3b3bc10d274bedc1d9243d62633cb26374f2ffb354293a6e49711c54240e41e8c2878e5057c4d4a24cfa952156b8e3f508498653ef3b688d71a174f1ce8fbc3fc628773e8074e0e2342b717cdac5c1935011b2aab55f96e705fa5f361c08a0283e07a61348aca240bbfacbb211af97abaf0b8d5f3ae52cf7c24c52625da8ae20a78407f7ff5cdcda9f63d7e7d19ed9a30902133b8b5ccbce57a9572fa23438d719518435cd000323e5aa53bc8da66eabc2d7fb271ff8138cf0388240eccaa57ade3abffbc7ff76f7526f8636399bffcb73daf3725152d645eff4a014600e23eef0405bfbc0f621fccf7e5f040afb21d0f07478e8cd2337c196667b4f042446af2cdb9888c97e4700fb5cfde32ec0a0b48558caff7a76a2722cd1ce14d9cf6770b591508b8cd8e7cf6d16d5f3038b5fdd2f4578373f8cd5151aa22d39cf564f8390553cfeb8821939d6cba19767befde69096b5466756f8726a8e6812670a6b18b559e31ff92909562090386e93d2cc0093cbbfeef780eecc1f89f9ff4054511664ac0a29e3dbc594acfec9d485ce0139ce3d81fef199c70e3087e90118062cc0e4abd21576c5f7a05bcae0624f72f5687334f43c1829ca6ed46f582005860ff4be3a6722fb34b1d938360941e2b65fecf2a1cc24e23165eb2d5f2093f35ebc273010eca42c3aae46227dec71ba66fa3e6f1f19c735cf269e0f1f0eaf6c63a729d81137f79ca7b15bbe649b766506d83d1a06ca91903f7d36317f513a511b3b84873c60bcbbc58fe0f18e769cf1547c48388bebf5977f6ad097294d9ba8bef6ab6c12fdd64d72c334745e12a803d6e1d0c95872b490ab426ead87dba8116b808375bff88dce40db2f91da964f4b94293621f9f498eb5cb53b4e233111979a0bedec7065ecda43f5f3e474790c5cc057beb4f9bf5d65cfe41146eb5cdb84566a622b6fe06920f2b5a0bf6813c34de3843125705f869adda02674bdaa5c9b61c5e47cdcc8e1961a3d8fe38ab46e3108d9a34a7389a00df4f5092184b0c8e2e2789fadc070b059f3a2ed5cc104be80de495363abfcc2cf0046d85c261dd915a5f08a7e2687227ff1a800ec808ab82041193500f43af131763e7c32c8616fa21f9f308ccafa8f53c2de91ab04d73f1b7a3d5f9c62c6391fadd27db26901f008be4fcc2e9d586c3704f33b7a727ad789204efcb41d368d9f55c688afab58d53720f9aa82c618bb92a130afd31cf44047306ccd30edd30e2b1d65e88eb335401bc5fc67d1ec341c4e736ac8871d354ae9ad0a40fd08127ffd2594abb4cabdf98c6ea247a2a09f1c3de0d29a7e59f9f60c3d44241e1aec394d2c12b4f5a07e658004c6eb54bb773808b9bc2259e0bbe0e0927ddf5df7df17e0b8a8d5dfa11c59651f2e68b60ae86fe72d853a8a177f2f34b88e8604a5edbd0837240e62adb5e265b8d9a6029b884e2f4320cb3c245d9be8b3c8cd8368e8313912c86311dfc89357fd2cff2d6fd3363006a10785c86663d45c15b2d44cc79d2342169bac2511ad4bb4f7c0b2e7231726e1699f01159e07492e9be42ff348132e91a9fdc6b0e01cdc428127433204badb71096628c371e1866c153913609cc2818928eecbc1eb8d8425b14b1c34512889eb6d1ced090ad4dcd1662c0de3d711656fa72545cdda623cd97850ad1acd053c008db3260a512c48d39e5e109f4f4b24c366165f5b811764d611692f2a10986cb4502ef6c3223e2a78039055deb87e43061deb29360c32d0bd2ef0a664c72cf8fa2d4ff5726acdabed3342e28e0ca50df2e921fd5c642e2a3ac0a475b0da033eb2e7e3c02e3ea0ffd5b55fe98cc1a454694b52fa7c5e12764218075c1eb1a59667bdb993f7d9fc58f20361cc5272381ea2da491dbd6bb1e12cce7b2f9f2e6589fc04312d87c0e97dcd80ec8b3a059b68cd1dc31537dc109904788e6b144fa3b712c0475648756b2f75622c5ccd466b6cb966a67f60f90d3f2f046fe50ef4a0a1d8d3dc88e50e9d64d32c97e8c840c8282d2910b4a4572b5a2b8e4d50a2fd702efe970012dd9bc60c24f344c9b24f0a819771c0d0f2d214289fab980adad150fcd155f0b5a8129e0277f8a5cc65f5037d795330452b414fe5d5140d1061c28126cc355596d0b091d0e7fd457afdecfcedb8cca9e5b8c9f72e7c3109fffdf4194bb097badd6813b999f229622220003748f1246c62670775117833f0c8a371b7380bb29480573315a6177f54034037b953ba06796f24e5dcfdd4643ec06c7f17b148bc238361d029e517398f899bad68ffe9b0920ba609a9d905630bae9bc9e0722a6e4e6a708ad9d912e4f58a487d78698cc719bd08ea0924cc37ca2b81e93c9f8f7119b5da9a89657d42c5d9a28260b226dadc0a51f4345fdfecde9b126a165bc7d0d9254387f508caed33f1dde9ce97e2c204e9699807dbe0c42b3c42640c22790c0c5a7b9ce700aa0fec0f951282922ff473476b81dcd4dce92a347185d6087c065bbda0282c60628d607add9ce0f8dabf475643c38bd0906d02b747d7075200f138d1427eaca74dd66c9909ee485fb1bb26c1b7ec01c4758a936dd38578271d3f4362d0f96e940ebeab0d52903a589a99776a09619cd65e36608a868c321eef0b91cc59452f7e4dc68b412ba9e629413463e48d42102b9aca15eb66230f055fc607f1ae0c0833f23e5ff15b834b8811b387dfb2626ae3638dd859e43f21071fefbe70a61b6185775b18f3956a00b4e62320d82aebada65cf612ba181f06f9caf2a3f7b55ebaff21a165e19c873c042eb1da89c29b7d362637752dcdbfea6b7ca82dfecfc7acaab5380fe192107c4901d9db83eb4f81784bdeb708eca286f0d9fe85f4ca75a73150e431f47047731a3e14bd7bd0bc9f4bbf5175c983a02ea661b3e85fcddf981d98725c72e9a576037595ebdc31fa97b2e2c93caf13d498e6388832a5a560872d29596d57ee704e9d31ada019654686affb300e27c85a71012769a60dd3977e82045b51d37cbc5b42c5f41b9703d54ce5929c528f926c4cec4246fdbec74517bc23490d42693e2e0dc8ed568106c6f8456f659d547c8ed19d4776ec681a826d62e38ebe2b6df081d32f98a57ca477b42a5b509d7f5eed0a4255ff23e8a829770220b1da3b8f86395df85f0ada503c557bb0d5d25f9c8a887d27d33b4b39f1124c6da1c6330f5647933a8ceba7bbe79c46fb2a2ff56d2339caf67d42645e03203d2704f5cfbb213e01120ae28b3b480ea19f6918423fd85bcaa0dd8533eae621159ae69bf86b39539705e00e7c3a4ece854d02561dc738eb509ac77c57636df004bfeaa617414f0f2f9cfa531e96ed138802c428ef2150c206767767c9e57e0129b70570c25add00dec6f211326227200c1805d022d8be82bb0e54d9fe1c4b5d761d0a41a87fdcc5dea35d6cbff8afc03fd61d6a2a2ac80d7d8fe25da5f0d961be01a720e0c87a71d1a38d4487e669d9038c2ff99f43ae9bf410cffb04d132bc905df248755529ba8f26d9d8bede604022f498e2e4951b4642f9114c9e6fef26db8aa51a5670dbcbbaab16cbc2a4688aa1aa7ee80e1712afe9bd77b102f72d13607a37298418a561779eaefcc24bdccb2557f7a33a4891f543c3d8ba35aa47d21f9506e7314a75ee7bf2c7ea49bfce5a0a580724b7bd05b60c76468fe3b9a49b1be386c17850a19c9192bfbfad55e8a7034816ef97e136090e06f03a1e0b385b1a94ecb3bccf664d414a8b385f7f230df683a86f304ca13e68e0047c6e8000c0c611af0a7ef5dc262b3817c0b485bb3bad7e3712b82ada9c927ff3f7f3042384a058c84eae93bffbfa82cf5b5ed206d01b8c39c7a9e777ca14c80506e92dccb0e301a089de4c96d815c62587463d3d5e44448d86f552152557cfed991998767a9722ba797c8213ac0a37588fb0f68b5f482f9455805a2e6aac774dd96312e3764a8a91d9360804f234734d380a1a8871f4fbbd6dfccf036a9e889870a8d0ba58f0f0db2462f4e7138cd1712fad7c7712bd21c22dbfa9808e6beb6b76000c971cb9ba76f263d7716e35b5409c6b802bb6f12ca510817d4e30b78f9a2be535f459de1e7461943ab3c87a528212a9c153edd2a00a09f45e14a59955364388ed5b8dd9bdd58bb3ff3f5755ebeedf57fb263bf308116d911917ba49e82cdf85e9045310b8b44132b9b6c734d4de441e3fe0ba2052f564f787a59c6cb54511da6a3a3a96c1d07c6522b6efeec82107aaf09c0b40aab259694a6004161998f577287d1b31d4bbae7f2171ec6dd49ebd98aff6e260620eef5d25815268b82cb7503d17c9d88e4ac22866637dff2e95f57566ba339ca49a69e68286a966d0f6bb377206910cf8ae43fcd34f02656bfd01f7631fc34cd118129c28c5b62bffd42ee272c5eb87b19ec02d18c0a0c573908622b83eb6193d287334fc546dda1bc22e87570e90bb8b5c5561b09638fd6d5cd2b16ab9febe653315d2495cafaf0065e32292a0ce7b1dcf09507f25071ebe8de5f865e8d8844380099cb06dac78bc28cbca409cecd6e5d77d920972f264e6aa21eb959aff4a53676e5eda44c6a54fb94dbfe2b907eaeb310681f333d1e20be36b8da65548414a251aaa2a1157e332a6275b2c28f843d3134c7c68227a01ef68a1f6f84bddcbf61a791ea8e034776a1c60af4ae0331db9fade8b7292ae69aa27730d96b513c21fff6248ca3cd898db5624c7ac7a3720eb3017ce0cb5a743e057b6c8e605ccfd37950b9850637679dc5c71e7606dde58b9f2ccedb995f3de79769dbe751f0002ba3da0b182609b94bf7047e36c34180a15112cc92df28cc8cfb051b21b09099cc636b782271dfe473eae5b7f790682b0ff4d93fc5a6699c92120f1196a7de5ccdf1691a535a23ca0a5f4c0b9368a3842d6b446e9a5e4d28f3f8dff4df8f15aa86496d76c20018604bd57078b0e261b5e04e9443fa2e9ec8e3bdc54283f1a0cf754bcc20239772e054b319c3ed50b13127ef7bbd120242a1b589236269d0a8151d79fc28f36bba9f318c2598ad7f1fbd14ec2d9fdb80bbb59d1db2e43c707a5d541d4f6b29a4c90e609a4454a9d6afc6b59f0fc332befc53881cc443b42188646e78a3b434dd2e3f7a7b269d2724da455ebc1082124f9ee44e6022013f7534ba9b845ce6913f58c89dc987abf89911e351efcef9a704d3e9efa592b538223cb546155ffe217b8fd3e0c5241866a34eda97e4ffbf4ed3b2b71a753e7d9ebedac61b21a99c40373aa6bf78c8bec81d19f400b7bd1021d9654dbf6cfbad6dacfda9db847c12c7dcdeafc6b08716b2a6e8b753593f7ee041c03eadc67326374507657fda6e1e635247c41666b93303aab6296823be7fedb3e01c4b5d8b8774e7a5b219b5a285f01b8443560430d58df857e949bc3acb82b6c8dcd110b1f0b36f92320984a29fc0947df9371d1778079f1e0ac92c7c8660a17dd1283b763940257de189654d0fdf33e8f0cad57c06f639304e4a50859ac60b8ea5ecc6ed55ce5387508becdfbe212ee6c04dbd5466d3b4c568e4da04290be01356e6da5b20e1ee9355cdea19690242f28c0429ae10a242ba99918a5d3574ee59570e5e48082460f050fe1cbec22453181a59d8d1f206c173e2816491c7caeb7a0dbea6d1548fb1b30eee14fdecdbf4167077554b08fe24bd9d8f16e5dd4058430b96cde6763cebafeca7e2bd421f452cbb81dca588549e750e9f47b6b24e57505ef331defa4cb71b3342dc44fcef7e13931ee65cca2cd35bac544f22743e71e02d3f51979e3e80314b5899b2015740182fb100025f4aaa75845b57a3e169bf1506348a8c760bc973a71dbad78b835e3ee95057560d4943fe40fd19389d022501e6ce01d6595cb76424854d83203201747e5c50da52d8f2e3832c419317c504dcdcc9eda10b7ee2539bd824f5788ce5b67e20dbc7defe17bcf491e758bcd3ea2fe308a5fd0e7b914beed95924dbf9c1b5351472f03c712bf9e4739a813f38dd6299a81f066e7ba865f51466eeb85905947fb80dc7c9da91d67e589089d233c462bb1a6c7c8c3f33f7b1bac51dd274482898fae26a6f7d1b130c72837ddab6001d3c4244052b3bbf507a5b3c5a3464e7c3e38bdabca665598c1e9230fe203d9a13f63ebdcc84846bfccde7f7b857538b381b3b8bdcc9dc9c773521ffe445b257e045f2342439a69688784790abb39808b5fab3b165ba15e19087f73cd0c688dca2c10a904f3320b07ca142c36e879ec7a1dfb162a9347e1f83b212957298b16022fabc25573a5bca45c951dd15ca57828c7268c80c6405a1d192b88fe5650b54f1336c23b06ac324369e2e3b244efbfecdf83ece280d1e100dc8d62e774b552a4cac26e7001df684ec3dc9da828e65b8cea06a2f51a5e7194d3ffbee9a001f0704b4419757c9b9af43e81c14bb506225d638167bfaaa3f531b55edb5347b8ccf1d5c5d626ab735d4cdd381b43d705a5161cc417a5acd69b4c9a9de1d0773c26aac1eea44e3cc0df92a1eb8f46fca5c3d43dc9efe337ffc09356606b71ff098ecd6cf9a2ae5af45ead8e9308eaff47c2afef9a7fbc22cbb3311ad307ab6315a726a323bfd0941bf53c95b1a7b22a9e5eaca1b447a957cc5609ac601d98461ff0129bb2bba91e994fcaf1964570a493248f005119ffeb814d79c72c02ad3f1ea429847b514b7df6ee7cbe63cdc3f5c70f3fcb60b9fad808813f8c40ec3611bc17b22a1213558ae9b514611805d0f2da70cd840d15f6f2662f22c234ef02132cecfc1edd35afb81ed322c7c2a772a3d9346aa77e28fd2c78e03dc5fce0a603e3585f0fb57b72a57ae445f6c394562da64726e35289a6576bce5228a1c67c92f18fafc20ed88009f96514875290e7f32d3a63a9a4b2d3e08d4488a7188d229922e9793d00fe6ba3f4ab78e70b1846694e2163126799be23dc07ac62ffa3da84b640003288da01d9c7d428a8cfef41518cddb88db80647f2ae9c6985b1411b86269d1b69dcf6dea15254d91ab324115da42032c3b3faec3cd68b30337cf32024836424266a4c9aaa9012250b445259e578dbebd9d856cc8f5a5edfd9966cce8fe8db2c39a7455acb4c6554b2e7a3a2cc17c446a718129491bc4999af9bad2b9a58e39b9bbb49fbf38c3607f88155785193c85ae0b19944b4706d4342064dd51f94bac90d2f789e231ce1c5fa98a4d6918951cc2f0c6eae34219559c8f4d598965f6697103e9c8c8e23ae76afb7bdd1d26e6606f2b22f9e7d9e4f03cb5c8521f8ecf5087d7aadc96ddd09a3fc88d337c76d2832ffc1990653759d9d1e906e6e15fb1e15bea8ee5f6161fd598ae32344d0db6c22e822ed5758fb6d202fe013b7f762df0479cba091fd6e0899c160b1cf2bbac3056a04cf3f582acc4cf36093e2f61d21b62ab6c2ac1b520a4af2e25711315aa6fa5bec6faad89ea733898b5c79bf2310669d6a8b75d81f479d5a7771e2fc73a6c39e46befe419be3c39efbca93ded863789b3778d3a3655c81e2ba0a922ad54eb986d9247d5231f7cef181081a1a84d946eedc784c927e7099cdbe4f6d8c1bd989b9ffdf520123ee33ca1e671212731f53fe96c17b8c18e952d12b49e1a50895af39aa41b5e241fc3ebbc3e3da06f18d0b9c0c702cb3a7322cc252c0509b6ab955ff4ee11025624136d72140ddde6004a5bb912c1d64bdf9e0ba4bf24f713be6fb48d8d83b680fda84b68e1df9c14aefd92ee9338e13d2089a7b330db40b2aab559f72c47d3eaad9d081d91ca5427c9898eaaee3ddeaff18beb3476f9d93c3f78d44f9ae45dd8244faf5646771c9d453c824da748ec2bb3d4b59543803dc5b795766004fe33702dfa4bb485efda05480da7c47583e15714b1e44e5ac8d739085568c6f53cd27cc5f6b357b589bb5b6008bf83f32e3d555be6d42b87306db1fa46ac0243c4d266d8dadb2e1850b76450494588b6052933f79c82cf18dfa863468d024da4676606f890ca5c7e8ace7a6508716631e37d09553403a63d6d8ce75a8fa5bef356ec8fb28be6da20c86df0fd656d9bd6604e271d669c0e652e94d73084d9e85e091c8d2297441db4dbc227f0084773cf82e3ee3a0587c573bbcd7e13b7e35ad3f4752b7ba3ac87a83691c0a364167e1788b6b91fbb643b618e6180972c433b8961daa00e092b8067f14a15ad6e409b912ce74d4891658e139603de77883c4a16083b39bbd3764b00692c1dac3617ec4b2eeb689cdacd4b0dae4af10179149d4e8c74099c33b59c97aa350f898394d59ff82480a940abfe813ddce460d5a2d1e446bb920f15d9eb7c2112f4af1b0bb220fc8e2aa9e749e6dbda769a600b145e2fb8f3de1ff7ad318ae20622997986960cd1801eb78f750e0878740341eb21886af1db90554266d2c47b5a6587362137546b26aff808116dd3ad34d4456e079e76c83df439377d054d2b157cb63745c4c7dac4994b3862bf823777e87b84a296f1fe65d22f511f8e6cb77424aa7d450f2580f5fd9637ae0b8ee113303e7a9e127ad830b6d1030205fc7dbac57e769fb38cc274801cc813bd30f9dc39206ac132ac808422a2452d423119426be8bd19971166c53ad46d50d0d06001018ca95852220747e7e3891fbf9b707a53cdc38f760cfce9ad1f269dea384db861f8de50f60ab70f3c72cff0e4b7b601d243e14bf722ddad330230578cc8d8f6d2f298c39f7ba5a41d3ffebd2c967474e210b5795f8621a47c30a5c65fc5e3d74bef70e50a696c94ec06b1cdc93e5d3338e9b675ec0bf5c1c8bd5cb2916bb9641c746a006dcace7facc703a3ec09a9c1eb1bf7c765044fff9e825c59acd24eab2a45269df3d4a1f22d9ef140ac11e66812b0692f4bf993a541168fa33367f6a10ee6843cd72f1d8f4d56a7badf88916940f757c70b7680614b721237b0927339c6d75386a211154192f00f7d9d9405a74fb6c53eb00a5f8541b3b768cce839743b9c1c92a7a27360c1ec0a026fac9224e80d070aa2c8aac0582069dc04f0bfe1b49c8bd464812039f6587054bce8b78ddfee72973b0c808725558dc3fbd9fa4dccf351f22ef537abda804915661321f8b441d7d9cfec72d6d798837cc5e76542266f83563be626c2b6a52b5c8af52a1c21667ec50631fe5bafcba16ebf24a3169a8623a9a7874559d80e16b658227cd34a110d021569ff4b3d3a35af61f2402b147afdd293cc5dc234ed43e5e9bf85579f377b6ec2feedc6efd3121d01426f98823a8bd416275a67e256d28a9e770ddf64ead56b8749886282031e4fd247290012b8fff500666359bef2b3f67fbedd66086c845b2ae6422a70bda69f4ae080c40bfae75054963bea3ac62417a26a0714b88ecbe7ab9ec63c933d5c97a3c9d19cb199ed9164f18ceb762ef80639b02e55ca2de77d0853561ebcd7288136b1e2380357282c3ce6d76096ce29d6f9901fc7fc91c451284fa2a43174d57bfffabfc94658ccf23a446fa645a18c6ff0f2775564f8260e4296ac3cdefd1f61f53501a62ac16eaa9e11b15fc7750233ec99d27e1b59c1fae7f034d69e6ebaacf5755bfc1566dc58341880d646fdbd0620a0169d2f47bbc16654bed02cf07251b779eaad2b25e2b834e1d23a7db7b0dbb54678880b10a6d18e0c1d8931092bf8ba49a1199b35dac08c90ab47c5a570e1f9e67b4931e29ae2446dfbe1c6a9159f7acd5bd922055f833b8632860d95c6ab7293c84b7bdf424dad5fc37c23c4ef1467af8b284c1fb4a49e434de1340f43a13d8ae6643af014719c1318be5b085afef3c00ff385a1b1ec218016810a59aa1fc1d74179c222dff64bb5c8eb8b90ad475384f5c4b744ff097445d80ff2eab64a6ac55c64b8aad37ec8abd4cd6d1a7a80519764f2849dd1ff7e24894d70f1441130a37a3161140247485e38947e9b02e9d2d8c6610da4c2a7823e852ce1403c36a677d1e91808dcc348fba3c7999605e047c650e153b21eabd3c9b576e63860a31c5b9c3f1700f976bab9ce5ef60d2fb03aa2e05f871fb6fe5ddd1c1f2fc4f493c5c544b98cdb00c5af588925de39e5395a78f6efe47e53d85ecd3db2ce9a58251f53477d00607480e3bbd490ebf8599342664fdf7c2260414ed5cea51fa7a8dcb7261b5a8967c3d077e17449101c4f3be51a1a9cb5bde348d90076119771c658f0d95167cb66be863c1f44c62846adcd0e0f202fe36e7dc9fc34e6304bf0105f20d51517bae5e098d68e94f5b1e4c9dd09d1b95e44226fab2bdb74019e25bf8335cb4cbe1346450ec1a157ed1f0c731773ecc0418e6bb08e1b4cf63523cf1ec7648831e9190edfc4885e4a43a246b2964f1200386cb090f032e9e2a7a9a6e785f5d8b1151a593fd5a61baf874e99fbb2637672f1efb1c835ef3605bc284f54bee89b099a0a4e9d90a92a49fae7bee273218695b96dcf57fc95ccbb54671aba7bccbd022cf10efb046ad4772c42c9263999fda3757af5851630964f42bf3f622885d545daf5e32771bfd747c9b0a8663c531aaf0a9a08dd2ddb01afe419ef52c30b5ce235f4ffa7404c26be9c5673544d59a25927e1821ccc4a0833755d3a7a2eeb860d7ec6f61ac4449465288a0a008606b8c5b3b78e96f656cf89d05fed70662621a94c576217a9bbf3cd6f0198885620d563c8fa6b9ef4dba7fab81fa3f4233fab6dbf89e04b3e86e6b0d74f83f11225fb322db9dc5e4bc33a29303317c7b8ebeacebd5434910bf7fc1d476dc6d648b8ee503ec305089116a9c958bd1abfe697e692f183bf60edb0e86b205aeccab1aa67ceb82b1fe4e5a7d5102b2e66b7f992532eeeb93d6d03d7781fbb523393f517f08333ca57642b28c4d6666854bf98a707b0f2a537310bb2e7c5e833ff33ec19c7ea9daee063e75e6c8eafc6afdff57e81e0b4322cd0851564eee19cb45b436d134ad4b04bf5e66119d6f5ba06862237adfa805d40f02bc9fe80af32ff895339e0434de3a0ca48202a0daec70a5794681324d0912f0facb7e79485661f5480631946e1d9c847e75a6fbbe4ee80708a8fe7d933334263f29b26339ae4799cf6d11fdf5c339c37b1e96461fac151a8e1c0c2b7a895f5722df9f3934b31288a0bf6054c485489ca572223fc7f620cab8ebe973e7f7206d02c73b996c2dca0be6ff15073398eb13e0749724086de30c35fff06e6f16633f9928c27fb43c425e3a5251fc4f7462d3263a943b8cd5d0bab698784788a39749dc7d16cb392ad251c2c1ea595cfa1dc98545e265cb8a8aac7482e72458e01a8b58973e26e48409cd315bb84d7a15f781b969defc46ff43a65c2b030eb657ed8ed7ab80128172723ffed17209495630d30ccb8c07fdcdff83d964f63a9ce258fbc05c32d1af97f1222e3f43c7339290bff16d7fa1ebdc49f73ed6f0a390b184613c012c2176525072af5e97cb6fdb3436827b62e65b3d0df3097e0e50fd4c1bc7f79d1080e701ef2d69d05def8a40a72f971eba5c108602e6fdbe70b47e002c70be3e3b49244f310b11eee80ab38d7dd2272fe005c7d940635d117b28125b744ef100bbc1498b3b0e32e0234fc7f6ab71a7197d5efe8fae12d113af6bfbb3aaa83e1eaad9b4231213191f95fa4867cae4cfd688969974ebc09e0bce722b4d543c189d575d7a4d14b22eeb365e6da6b2e12c8bccabc8ce5bb03b2d83fcde1819429c7bf7f70f6c7d5de0e6c5d2acc78ed5b045f2ddcb407c282d24b8b9f12f571a87ecbd9e476bc96a33de053adb0ad3d0d7ae6a33848693856ae908fe63438e882667439682879319ea7930d1eb57993157960b127d124ad88a84414d6bf81d61f1a932cf8de2e34dfd010d634f77b03129306532c38d30233b72b4619b8786938c0e63773079fcb3701cbf3b6f54b12e94862212bf55c5e35c80c234f745fe61c98b6c15b1fea2a973624644333fc0f6b0461db7e4aa3c1410bead93692b6cdc67b5b1b7f1596ad6ec7bbef6f8609b24b87c3074452f8a7049cd64310494e503e5cd43ecb6205e54fbff0b938199f220da690694974f6585937160349e25c14f744d693c30d690c9d5dc02eeea93dff10b8814b852753adecd5a99d1e8a1c84b0e1634bb5fb54cad5c8a4fa2fc1b58a46e0f0be631571aa664930fa6abee2d80764d4e34313bab6af88a1ce515b64cfbeea89842bfd8df57f8f33c4d0c23bdf474be15aa28f6e98d60a8f5110e0735bb0b13818cc6c589e24cae4d3dd4aa4056a4b63bb4392e254d037c3ce9559211d1fa218fa007507e3449f038f66c44fac470e8755c461bff7de7802d96501b15e7d20490e394d5ee2810c227f57ff869d6477e736baf8824468fc387cbb60c9acfd17a986cc3880d5b46c45097222e0c94570e34f1eba31de40f4e58ed1b18504f31866c120101e54d1445f02f65afe5064a0cb6b2175d40c751d37137c587c38d16548b0eb954d92c1b6c84e69f61ff7b03f5dcfa65aadb661025169884b5f0dc24219f955a48e304e155d7f007d94c3e5ffec58e84716c0bde49dead0cf5ba9819ea07c8635df15e5dfe0a347ccc781c0b1df4cc1ace12def852ad8cb3f5364d9e900f58c05c820b89966fada4b25e601f2259c6fdfa38e3abb8bd54f0090083ed09a61a6660f570bad7044a66e9f20e9525ee4410ce62e76c420280ebccd0189ba42954dbf4cc009704221512b0f51cfe70b7eb031d01824069a7316e630b8ae458cb8ccf5bb2104945dc91982196a15075487d74e845fd17389a3814f3cf9824d63cbb4fd858fe10f3aa6b650bcfd4197408e50cfff05a960ff28423b95e72682f580e6821e6fc46eec6baec3e0d8adfb78934e5c970eac5c8274b7c6986716c2e326c152afc9a8631ad28ab8ef5d132b8ae59f040cbdd0e9fe4e934d6ad23cb969e04c11260f1b6f21d7c90fff78a24ccdc2ae0901fc1db3bfe8c50245bc32e96c8943138bb84d079e1ba33ee56b64dd3bad87e2f073a73d7130055305a6b978558b153d0c75e80d5dad109aea51d4d88fd25cece57b7d2b1145c12299ca4422962cc92abef1a765f4f6e48166b67859b304f54b53c3d916ec4048712df5a251940825c5d01770236c92861cdd0567641cc2df00b429f6ff6942813067ecbbf8bb2d47bcd1fab3be2c2e0d7bf2160af53feb03e5dbfb2d32319f396de2bf0b30a8cae39ba16896f1186aad1d9960085d4482a8ea7fc839d56253a103729bbd0ae3a1c4923aefe87169066dadac9da6c23160cbde76b8833c449287ea2320491642cb777de26991cd7f76c61bc0312704278bf3064e917eb9aff82d7ea982bbbc59dfa38a942115500c6550967c23026c142a9af352aa255af184759bfedcac29e464e972dd6fb19ccfdc20bd0bdeb04d11d3612dd6e0febf68228a9c1928bd0ab82d2fd24c6c6bad94d4cd312e8470a3dbc29df59691523fbea60aa4e3a304b41e7e38ae895426ef3d794389756b8ac6018e549872582605eed0ce0451b4c93fa4f6c96285b32c316fe11c818121f38703f127c59684abbcaaa5f1919d1eee2c577c5a4da1dfbe09b1aa10ab912db16e9be4bca8ce4208ece9a3cf3e1e648619a3a50fe6f7520e7d3b82512be24ad8476967c5e742d57b69ee3262d510127567674cbdf53c68ec2e7b056bf63f97d9bc98196d4919c149b821689f3dc8d3f8abee8e46dd48eee2fe108b26faa034afba21caf79c32c2a44745bcf3fb9e7ce58c30f17af3a2c062bee88b2164010d7ab39e108bfe5d567aae59ba9b274292d7e7960c917637afd85589884460ba078141fcde4da444e59feaa4211d20892cce00af1a9d33e3b0ccf69fdafbb377378404005f84e649c6e234852f9206b7b9ee65bf269b52b0a2244ce55b3500c5aefffb9c0ddffd80f10c31f707ce764b294f3f00bf6aebcc036e9c89504701e402ed5e1fabddf96c0c4679f86e6e7b581228952c33fd01703e5dd9ae62c17c32bd81da1764fa97ceb1255845e7ecaa9487da2f72e437279d36f03a4f1bccbbb57388f1c467803875cfd75612406ad6a09d745d9d7f3ed2bb8b5edb4b48a889e50f0fba8c76b93fbe39f926551b7b0cc902071e64ac14cb33c52bfdddefae42ce728cc2a30c03bf980e1257d712f57406d78e912282e3f72ca4f36eabbf258a3626c3ef1b1bcce79d2072855d5bd2eae4dfa3816140a9d633a58647cdff2ac7637b5d2205dffa56de315adc6acca1751880cd4ec6c3bc03882c0047b0fa8fabf4822436cd5f76f6abc257e14752499a1043d0639429d35997de3152f09b8db4626fb9b7e7d764089c7ba1da2f817a511e2086ffcbe0211ed279272294a518c2decba24b714a515a4059b55fcff393e4914e8a25022495a55017a1847f6982d6563976430f7ee2bada93cadf2f8c0c7e7cd85dd5b82684fb27ee15373cedb011c07ca3d359674ca0c675fd3f1171b6eaabc6a43f64c06eaf60c46f592e20e7354375c4a4f2b4de549d1fab1f96912c5b1de5db12f0819509b02ec2b5d9c0558aa10d656395829dec9249f2d09cf1e55b85b62fbe141a0a159263625da34059acaa870248691e2d25bffeea4aafd14224492ca366a0c0942644aca3f24a6ab875b57ed8e079ff6475a2ef0da21fab8db54c06beb8a27c414235104277fb3ab918c003ff9da0673d1cc1ea21d980e4f4faac8bf52b260265dfda8a4d447b857cbf71653682707c7bf170e4437e5555676be77777ad6e01e76480531339c881b23a2523b3d25202025b2e6ff6c2828fb3540418e166a525df8df22d07a87afcc1ae5a4226c3e7a27704654c0c55f6343aac9c23eb48c95c632886c03db413ccd7bc69246cabe4125795aa77d7c3c85fc5e2d1a831feff0ac6624e4fded88f7a64e6b529e9843a30b37f593133e910c53306a556851c83b225b8aad161bb4b283cb54065bb14296b28116afedcc073192c0bab8234a98d2e7e4215bab292483314306ae075e77121ee247fab3076de0e349af4b8bd8997e8b9e5581b75e35ef439ddc4c7ac6009f229c90b0b5225119e05b034142b5b4fb3f86a0fd62d6d6860a3dfa4052c0c2314bd448c41bdf0bb96d4bcf3d7cac38e66851ea45d9a9ab2b60648f4196588ea15f14e4e2e56f8b422173f22d06d0d3e9810215a074893d8b86fa62ec4af7d3e45af642f765cc39e87f06dc281509dfbb98821ac5b27adb904b7345634437ca6e0dae221c0fea6ab723e5c793d827d17912a0e0bbf63b427fe2d55c626c497a2f843f72eecd9930f338371023df27d033bce2bccc5ddab865240997e1efb14b49aefed4ba3b050be9029bef94bebf9f113aa274d996ba801d1f9df64abbfa6143fd07faf256df8fd0538761a0724ac800459856678562c983581ec84e7999afa52ce5608e46402653208a37f633555dbb202070a3921c3d66921e751386a8709ef45ef01b9b3d5360c75b0dcfb3e5d851fa1d6fe7c98a3a200b43a9e40a88a8b0078731c5acdde882429dc4183e5f94121f91cf897346fe277306ed6e0893d50728463bc2af071fa111bef73320fed27245a9b69c648ad8abbdc5d50cc2fc53e796befd4f8006aa25325016a9fa4150731d207b53b9fbe8871dab43cb2fc3dc5c5ea7beec7cd5fc01e8b73f1481c1040e855610a65809070f29bd2278c4aac1cf3f042bb5755d0b2936b9ccb6f5fe9e17054b42fae20228031f7406341d70bb793e1d5a73548b8d5e96dd574fc37355349e458f86ea4c585d4ed09148f60870365e7dee5a4cbfd770ee2522747f0df0e861d658175ecffdf88c5b2fffea3a9963137367a65658c85be70474774c29a142919070f6f3a72a8540a9cc46c6bd9f946bcfb2cf2f008b56091053111e3ac857e30d4e6837916d00d3733c15819089a37ffa7d39c589f7a5958d908f39d3dd8e7df56da8a87fb9c7ba2265016e0ac36dee85e6d0d1e67ed5b18b683adfd9189a2e0b8a63ea9dd8bb8b55a89f8bd97be59d22eef01af0b1d270fb6eb934b0359ffb212029342c745a37bc324c67fb9eb3875f101b2fe71f5e3b53ab3e7428f09f843c4aba8582671075a45e6b27ba315132eae0d0b5a9fcb106eff8b4942ba09272835bd1b19c5fb72993369fb80b93a4f056a2ef56ec16f48d9aa9c50b9acfaa887a85a280ee49618b57042c20ff78b8dc1805d38ed2ca45cbec45f1b973644b094c926706b17999943784a80b08f4cfc5c81cfea2cbf63861e362608358178549bdcd9057015270065a5423f7f9936f6562dae262af32fa262a55c29e0d05f6fa575e9ddb6966d6963c418f56382fead8f72234ae95434624e2c6387a8d94bc604324c82b5d8bdf28b508c889e1c2655e0a4cef6e2cc062c586b95eac8623939ebe0df6f42e3b21ca638ffa3aeba6e5f09e47df826568c2c318abb6d78f2ba4253ca06caf9401f0f545538c0fc22cf1d69636228f79f6598117b479bf4f1d3b22c5d313102aafb1b765d1c429f945df1d62172b5ea32a5303b7cda9d29f3199b05b53b3da8f269681f358fc1ea49c164c976772da0b8d40104881ea49c0e73619e0935834dfcbaacb909cb4b4aa55c33b240e5c854e8d8471e808aae986fa83387dbf19b7821bd7bda663a195777b365c35c09416af76018f68856a3ae2f4f90d3376561f74cd49706dee6fa11d8fdf53934d0791df5d1e415ff07703dfd1af561df6f777f5b955ac66f7a1191ef631aed03c664b2ff4b0fda14215a8182f51a655bfb3d7fcc4d46377917c827d0ebda56c958e267df4685bf98086585feffe3de5c3eb44b8c985bc2a53671472be460f605690fb277f207c6a4dff8b15e3d2779c8a0369fef44ba7d08447ace577ff772bca1f71baab67abaa43546f4b4b4c02ecff77f0425c5a2de449d5e7a24a2e5934c14a28b512504a5db297c6c4407d859cae81388f585319ec3e4a5b0d62c2731b708e992ba23f5a2ecd00a181985713277762a7de81f9355c3987e2b53676396cecf726ada8b222b738221f847a72ff2c7cce6419444f82959630b2da653612a23fd370badda5557a5c725e92b5eac97420e3beabfb93e1b2fa49d838d1058fb74ac19e33f479f5696fd33121e3ee39b7027b0d4032565e70a2857bdd16722e4cd10e73e43a8f47ad247047faea462fffd5f70305438da9a80298fc6bd706daa9d5da0335190eaae89f1f196d9d3767c14ac4bbd6389f332a9dd00b196408014502ad32c9c78f1b713f79ed0326ca749498f8c620b2061adbda9d631da7b7fe112a6af7cee68a6b9d5b32dbb206475c45fb68621a2c29a03ad1def977f11aac7ccce3ac8056e373050f43ceace5513ff813f7e1c0e06a0259ceee018df7baac1ed60462a442e54fd14e8a71210ae01c16160e9a38b042cc72db0eaab5f453b31d6f35ff4377a87d7815e2533e9eaed437c97a84b1a400044a451b33221e2ce85cef78951edee366dafaab49b87cf576d8922d7b34db89f239c65a972be57ffa8c8ce6cf8fb3394ebe7cbf54acf080fa744f29e59e6415467945c2dd60928d53015d13a829c90c0765b27a0f13394e60fc57368887003473a915e1fc168b434020a669d69b8344d9da935c811ddcc9c5a6b43a6910a271125a12d4ac7962d962bd16f287852ff41ce3a93a6a93cff98cd061488c28b901b804a79504cb9da86dd734272b5c76726d59d761fad200e8d7467993a868672622b4811e3c3be3f0456dad82c88fbff8137f0ecd25d418d4dd2fac95469ceed4134c1e7228db9e10464f0663463f6c03001ec7ad651ad6f40f63f99af2b198f1fa34e7b19cbffe95d1662e37c1c490e61a0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
