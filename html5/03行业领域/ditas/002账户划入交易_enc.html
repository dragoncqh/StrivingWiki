<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c36d33256b8b433824e43ecfce04f891a35d2a57c98be26059a8ab04e43778b7a24806682cb6b3fed5abdb444ba9beb51f3986d786cb93d02a6ae8f85b397eb6d4f9d8d107d495f92f09fb05ac3d89b48a6eaa374c14fac1e67756946f7d6d1849e05a008a18506d6a631836748c3cc06e8e7787ea2587d08cc58e3e173260cc38ebdd4ca5905e3451bf24efd5cd714e79335b6db0aca6df71835829b7421ac2d5033f3986286f7919485c869ad9a45f1132878527f7eac40f0bbef82e4e400b10b6436e8a571973948872e054328421596360acc5a09f03d1eeb69ffebd44a22d90379a1a2935cb5643cd35a2025fbb8bddd797ab8dab7a7099c6d1d08aba554f46137e560f27bd170f4d1435633581228425d320c2df35fd3504e84900316da45163dec176793e477737ba46063079f839a450e45c725c05c2d6a0e4d79fc19a7f2a27b212ade23fd5a8b1a71f24b185b3434104602ebbf671e4036999402c52f2922ba1541ff003aba26ad048a2a23d9cb51f66657e60fcb57156296feafbed6c6e168c371e91e8d37c379b835799cb5861997733098a4c4cca78ad2596c39c761b5b861e4db3a360eefc3838eca2dbc3af90bad7e7d30e51efeb0a8af68acaffb9bf68f08f76b389247fbcbbbedc9f35111976e28762391fbd364b0767df11f7406eb06f6200a11a0ab6f8228c2a2967e6045e313cdc532170694c9be24a29a9d80e4a7cb656a2811dd7a0d96084d656609035748d055abc4d81458cfc0e0f9a470f81721f7fa55f51f86b5f47a004c49cf3189643f2e79344150a6503c76c624430478b37b1a9630b7e7bf404dc197de9ca1f3fb4a497486ea63cc8f0fe1ec5744d6c9499c2e6769256969ac64e21e2bd17bf6ce5016c6c2459979fbe84ba677b8fb7e68157701625399275f8aba9cb3492dba4c0b4ceb849ba137c623ed6731b3f2f071c7c08c984ffc00e01c2af5a51624e5a6750f5e3a82bb5358d89c13ed053bee582c05d4846b51758485c179690350c87c9c56b3ff8c12c25d04ecbeccd6e544a09942eda0f1b1b97f3a8268ba2c641449dd2e72da4994b06874aa2359f2757800c531f332414b4ce654031e43e5a87af23f16d40fbba80d14027297dbed56b4591e03b9419358fafbfe9c4d30eada4ad2367d215be121b5804343f6489c0618166a76063d7c586b983fb0b62bcfd781a3b54a38dc965ea52a3cff3a743b5ec181575e68096315d8e4f5755e4084a4dbe53d8322071a7523886473c4b365f681b59701ce7a30f624958f443900ed2fb71c6bd633175af853abed222d011af6207d7915cbcfa68916c928011a0d2255fb1c1667a21a688ed0ff945844cfe2609559b99c19d25ec5d2c3725e56d764d55e1e25d9bbdcd86fd9fd871f52718ce4e2291f3a4955592cbeb96c0d4f5e22ae316812fa82f3bb8f1117cead56590a1699820199c7d23f14fd913893d558286f95311b59340bbc93946d37f3e9bb2c9e0c8cc2be904807f4ff8889c41bb86249c88ccec12c2af69364165d569699446dd808f1a96aa3ce23d45fb41f83b64908bf334a2e8618227265ee7e4a1c60b0f79a7bc11115cedb24952bf3cf62a3d5b06622d002d71a5808d4dafc202d5fe1958af2037c422909763a583e193fd644ff5343d2b3b87022a68f0ba4314d0037785f28b07725297f77cd379d93466943b14f7e626556883f0c5f47463bbf344c5835ffb6f315b62515deeb604d966922f341ada3205d6bd3ed201695ba6bf4126300ada468f9ff6b82bd7d2051ecfb083626cd9adfa02435546f46269642f8d7d63e9498259354891b52b59cf3b59d1354b1767d9683297ae1aea2eec1069202be1b1e54320758a9aa2390f53f2acb5e7b1e2e98265ce1329373d248875170bc2fbef746b321c5c561c47b115693609e009f8ab8e23340640d885d529e00996bb3209ff1ecfa47091d1c99aa19b0b337ff288cd6773ad14ae1b7ec2618d8589c0bf29a0c06405d37eb07036c07c80a960aea92cfe2fee4e58105593c2dc17cf104d93abba34082d14272462f50ae3f6098f4714b8443db055bf05162aec5f2dd41d88e062ac681a13beab9dbf3e289e5c9f6a64fdfd4772277199b24bf52050e0b8e18dde0be0f642e129527609b8cdc068622cc1a280c6794d419947ef41f4dcea06842212d1f4de9a3124047c81bcc8ad0412cfa36f6c996e21b676e6c3b72f2283b861ee4eabc33ec1241389e08cdaf6aadf8a044fe9d6c5b846ec481743cdfd1de5f3052512cc3fe9fbe6865248e82d04e16170c4511c2c9dcf5c4f47ebd47a58e06d5ec5e227420e9b07b2dc69ff788fa186314a1266ac965e5419521b021fcb0d3b182f3bb6c587c4f38e8b532a94c7eef555640eb4c96748b8480fd3e605fdf560e3d3385d49a44d63048b7297ab708eef2efe7b1a45c11ebe1f99d1a711c1b474f6babc91b48907ed438a0c27d46708076cac51c8aabaaac877bb0c5c34488ef022eb82c0dcf3fba144906cb1137142c39cfdda2da19d54316c430e2a1c022d0ad96d265fa106ed1462559114fedded5f48b040cd5c1739ae59d569f4fd3c7f84d01d3d78b15ef2d3d07d1586e4ee34b38a6af1ab6eb61fc0399b35c4d46367fe752e6493dc126839de7a815f663b8327e65101c845b744c883cc4fead8fe79b8cc560cf665a47b3a9f7fdf1d17dea3a2fd781c98fa15737f1e1cafccffa78da7d7a86d5384310cac447e0efb824b5b73aece14d5f93bf06990f2a1f73bb392865c9654725f7bdc868d9304ef5c7f8bd0494c2cfdcb5bb6dbe22671b5a5fe25c2bc60c70f42caf338e633bd52f3f6311c1fd1f7eeb867975fd7ade579670e9ef449bd05167070066cbec7936414f009d70b8f01fda22d802a9cb2191fe5f467d0972849d66238138576486851deef6f7b68a7d1770bae38ec2a1358902ae2653167181a79718bc4ef6d9b8ead034960099528f2a5030648ba45557d0ddf772d237600f5ad45d510ed4b7bb93e6240957cec9c8ddacd2e379551dbffacb1ec0c53f45aee40fe82f431562397fafdf4db3664773619b4c46679849dae8bcd42dc4df370c1e9e5ea4e059357ee542f7c3f3df77011d5a0f2f171cf6784d7b15224fec5d9d02c8916a61f055a8922d93f85da588f11062974e914f40ff4c4914031a10d050139f0db11938edf03ba19def3208aef107e71155d59cf0c92b9fbecb6bce54a63e548c68991f04c951240df8e747414b89a91a60ee67699066ac0a72c086a8581001d5afa9d6a8ee1082881f5ad6d9ff55e4e727ed0a11e6d4682119179f8898149b6f93b886632d654eb6f019fa9c57586e0c9e45d4bf2f2ed441c9f536f4c1dff8c9aa0a10e1b87bec7a02ce512b60f5b13667752fc0804aa40d6dbeaa225783dd4a370768335a74c66e2c2f5770d49a59616545ed864756a7d6dcd4ae84bcaa6db15d05c4ad5c928a1b9289837bc0c9365529a7ed2fdff6d9f9dc3eb349170a63677cd2c0551dca2db8cc6cc866b5244341d9337ca531eb356b8206d7d7869a30843a32879f89fa1ccc5ca6cd47f49510d7537f3876ff4a2b2069a60e6dfa5db1a020da9908184124fd0b247e70f64a536dd90ea5f4e5d08cf80463c55562521edaf2b737590db4ad31342e4b63373009f43cab9f653cf227722e917890eb9a7074b6d91217dce4ff4082e80e00892953f52eca134349ff2c4ef0fbe244d21b75d6ca9ffe08b8742701607558e6a6842727931c4ecefe28cf7b65e8e75f52c4ba4ae7aa03c666fc8df2ac29e7adde047578d1c02d7fe449277fa15e8aea44063cca6be2e563784b9493067ab216b4a1e3cdaf032f6013f82ac9acc117d195ee5cbd8b3db92e9f84535e12695a83ec0de6c42cba0152ec422517bc1090606b6edd008666def91d5cc482dc2357f37e81ea4e1c42117c12df7739e5d6ef0339ad0e1b6cc644c6a1e482f46cec4b702ac9e4253d0284353c4093a87d0527f3b6ad292bdab9b89d2f66556d649e8549aacd1861dec2b02453bef40e9793cd5f568d02837661d60498ed992a1d24b96d59b3bea5634fda9acdb4e036a30ff29408c68b4e3c5c6abacd3082e70a3ca2115af1c8156daa1446ffda8532f7ae757888dd4241006f07b567368aad8e934a7105a1584f31ce62a6dc9599fd4abaf8b61cabec28a0e0d4cb626ea988f26bd34e6a415a198b23079297dadcdf2b02ced908a8d57ffce11c0c8cb6020c52d26240c280ca2794f37e415f4db5c9cfe61b4c308f20ccf7cc07ff1ff7a3fc64da8e3660a6dd1d4fef9a82e767d34977ba27f025cb4ffef951ab2d9054c1c19c2f61fa5c5c19e5ed9299b537a1c826341526ebe481b30082928be4e42b89263f4c4a958633f08e1564818e1ecb03e8d059548e03c657a7a461c8bb8bd7cb56796c402b496584f99f1c7454425b633667d105131d8ae4bb09c82cb07a37b1f9e480a83bd6bdb4aa07ac1af9143065ba1111d29c9d7f2cbc1460eb71ecfb377042151014d9929ed7aebe5942f6e7b671b4f3e87e4964d0216fad5b0ca68d3a96ba390c03c7753b47f2ffb424de45450e01c96d800e45c4cf6b6e42fa545ddf49e71dbeaf9809e124d57298c115762f15ba247002ae6e28e5d515918a7f51a322e2d80020ec5fe2ec9226e02eec14347a58f2f326ef34f075cf8ce3eb0b88e1cb0f99c13d330935b996d0e31bc32120bd729bb3269778033da22e355fd71de3585f93c81a4abb2048e92b54700e1e0be677ab4274d67d6d5457dab1107e24afbea69be550697bed07ab8ae722f121c7b9cf45db4078c1cff2b6e317262e834d708bb4466d171abbb67c68f40fad4b2cca8379da35f52454fdc79271deed316f25ee5e24efb4cfad0ab1b1d9f65ca697903dd0425be9c0c198106984c74a56a12c70341f00f3ab2a9f0115c14146960eec275721b91e0eb99a45e6270324b5be033d716d8404713e268d24b2de17e61aeb2c34669044480e67154c160a706f36f2fbc0b145da27fc43ba614b3b938d4e5c37fd8771229756401fff014c10fd4551cf49979f0b5121e7440c29449ad21e3291300487751dda1351a3d020f38d8844dcd6b4e0ecbf5236a193c8a04ed61b1ad36d3f7cd42af582da9019e9168bcee993339996e6ebbcd095b6084c0b3162de5de069a364c3030e19d0cf8a759bf3c8187355f53e0b1b33781c94001d23ded48e760a6c932fadae11be69b0e33f5b258682a846290e64de3a4394cdc108be5483d30070b8bd5f81ada485b0d7f6aa6b41cfdb8810523da040942a97d6b751e274c42f95e02c6c920d740faa19e3102c17915a6d918055adb11ab26d044ab218db76f4017ae2b35eac15719bfa6ea97767f58298444bd9181dd1f62500e635729a99d2b4aaeef9fc781874e08fcb3b04ca24047b294079ab6010d056936a98a351310f4426b6854bec12c29712a52ead80bf15cc0deed5b32d63b5de375f39f34ecf81d4615f04d980f95dc6527ecc8f64273da70f801367daca5b25ee23218df6bc6a9f4496de7539641cf3db36ffc7b8460360ab8cdf63c387c2799d6891b01039c3c2a80bcdb5fd99cc59823c7bba2b91dadeb207b3a1aa461d2bbd9c087260e7a381de148da7e7eaea7115e8fee5dc13d7bfd550903ee7ea2ecc0aff88469d49e4fc291189350dc25893d59871baf4e29b71eb86bbf087e1769b6314e2b649ff1c8ddf8de53f0462f7cd1063ea150e5f3eea9c92e443b034527a8108bcb0045971982a54fb0dd6846e632e44e6ea80dfff2f12cc7b70443533d833f36a15a631d843a3e0c3da848ed839d8654c8da35480faa19e3aea77375cec8fd3a0d7846b34a831085b9548c06ffd187074090c3ce3928371300c4e1b317f346a0563ff08d96bfb1436960b13104299d21a71541871fb333f0ca6aaa8af32f175a906c43ac9a58c50d8b16721725e827a3fbe8a35f741663f77c76bfaa911b51ccade95808cefba1e2b3acb8bd3d18374b044127e68f1eb2828b29502ec2bc178274ca44e99671bb46168f8f7a1362c7294820afed8c12697d3246edfb4d50dae1969513550a42f0ea0e636e7f61321d5510d21aa37e9a937bd9c6346775322f53a64faad17e4e69d334c89c5c5b69d452898145504fc359b5d22cbf62753bfa61a8937dcb42e9690d69a8753bf3b0b7de921eb2782f609f88c96139f141c42ce73b7763bbc96cab46898c69a4632139c8db47464422ed07b0a95c83413e4d69feaa8d993a61c025de2849744af6929eefae3aa117b79337d43528922eb47282eb2c5422b654917c544843f04b935c321b17b0c6226d46e635f6a3c3865ec00b69a763fc48d42990faff8deee6be3ac339857855b82b555fe43b512b43645ebc24f8ddb9d7b942b3bbb3cd3cc6666ca5541d32b0bac877dca2fc07d3eea2dc79e8c7effe7942caf329834c378ddc047e3eb311f1dc7dc9456dab900021d453a5ad27bc0eecc6f48598281b9a5397926e5556c63f6ca998bd43e90e68a63773ef7f05ca70ef967227d88f2ba815efd5b8ea9b6bcc64c8f74f630e9d67fbeb6b3cc89912e455ddb213b6b1fefc22d20b27f4aab515998e3a4a22fcb7b9dc65efd6a93c1df3b0bab4842a7b7d67e1e62ebecaecf235e696b2d220d47d157ff05f9d4dfe7ecd1fba8a67defd2dd3e8d63db526a688fbf0446cf7c137d4937f4d65ba04f5e4f27080260f66a6f7dac3b494b05d4ab36fe54497add30dfb9c1c20eee196362aa21430378b2972927b9081814e45e29e641356c75d7b805806ba10dbab297d43edf6f0cf206d0f8340b26cb765f006be221ba52315b81fb658ea0f1e1d32072dfe564dd4a53366c034ed7688da0628022c1b2ad2d24867cbc762f9cf04b975d99cf63d1094ba2fb501c36a5ae970ba9fdadd31011ae968702b8f0d3740f4395df477b422df7fcf5451a35cfe8fb4237ac023af1b00bb02d9019196deec001dd3b33dd12b05467bb4c7ac","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
