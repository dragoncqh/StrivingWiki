<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f888b228bcdc55f2d61c7940dbc26635521e615eb2e2ef05e3786109d6bb9ccb31bae9bf60f51b6ad54dee533702be0d096ae0cd02d9095a144fe0588357aafebc9252e34c7bc8c729027b80f020778c4a806cb45d8f11bc6af7bbe73c1eeafec8fe8f322e7d9fff4e2fa437fc79e047c96b5b0e2b06fca9f3005f9c823912fe6fd1c642150c9d42ce6c672bc645cdec852db6786596b76768649e485b3cd74165f929c87766f4ae6798701a7d4fc18d0defae280e4222d29b0d608e3d792b94b938a1e9207b0fee807d1e8e82770174a1a9ebd5c38aaa74800558d3b26bf18602fb683d88b81027b502accba5770c8935d81269f420b090a541b290acae55fcb6de067d568b5bfc191f6d7f691102ca03f865775682596eff01ee4cb4ed588b2516f336d5a379c189005774d4a5985d1e33c121dcf277b5606503f4355f6069a638815717fa4286b3e54632d46acf74986eabff7dbba78d31d692389f52f4dc2dc569d8f36b7ffd8031cd1f141afaa7fef253a7ca844109f2fd4fb38df6d9b8be0033cacf09f8626ad1c3efa89cb7915cb0ef1bd245c1344c2387f535d96d4b1a24f4df0ee8a2c9baaf215703986127c09cb0615ebee414f7336c5725a54002d46bc828185d561cd990d85276f9bcf7c2750b8d26dfc054976fd2519bd8baf1f571fef16e65f23e2609fb14de6dd89576c0054d30e73f25d4093fb75584efafbfe511af7a2197d4aa7c7485e2fc5371f683df40a76b2df77f95f207bfd8dc38c29271bef56bdce7652dae347648cab644720ce69788ca4a2f68febaa0bcbe5e537c4b7e21b08c7e0195be753bccd3629d1d5022c4029c4fc3f7f8f43461bbf04923ff91ff578e3ec2c91726aa57f6e43d64e09b5405762ec7750e70599064fcb089ead8cf820f8241cccc90047df23fd4f298113333dc4e6b95e2fee992ebf30db91fca2bbc2aa02677ed64fc1e78ab690eed292874c133239274a048a37fd567b3fce7a062c2b01049f0a44d603551e07f5e5a860c19c375e986e9a9334050d6f8f17bf38334eb1696358614118bdbec6c60a13084997efc1b217fb082bbbe60c7c6b2fa99744d6adaf64d3e26dceb24ad85793952d36197ebf71a4c127a84832a3d7de63694a91b9a50200936b82d8a99593ed3db41a2191e3783abef15791f26fa9091c82ae5c7b7f5f99bb6186dc38ef578fadffc9ade7f311631ce4b05503f1c41832e4d884c3dd4e119fca6b381d79d935b56cb9e00da319e9b1f408b7cce050599d426f0b038b71499345f1cca828aaba009868d3d16291c7477b53e592cfb4b369004260e5608b970f5cdfaac3bce27c0b1959f1caff805dd627f31b0c6261e1a6a7bf7c562d5bedbd94a48b4765e981378e63cc4d0ef29b20a1b29f3cc74e93aa741521735ebf382f2a397b871afd9e2f30fd48c10fb1bbb37a8e78018ffd71e4fd1f3d8ecd2b760a9b17c0aabaf2c34a0cb053bb2a9319d2c7e283247b722872a67bc9ad380493210c773e513e59c6050a9c1aed4ca6c65957f75ae97771cbf3b6afff02860fd628691a70dcd296982a2702ca5218bfd899afea9eae814713ab86e593d7cf0245af3287f9f40fcc9a4c9244bcc659454913fd4b10d9322f527a9a68048b85a7d74f4be0a5b533c63d4063597810a7bc61bb55c93d9bc65259fc686191cf2503b269a35781d8f998678ec8b311ad48370c0954e18f3080721f05dc31329638ab31496ea7b0f9f37da69635c41770a21fee21958402ff4b214ff9c52ccf01abb43d49c4765d7c22051b685fcba75dbd7b44f3c795cc2b9d59103cec91f402ca31703b3f845c6665163999af909f48607958d0b13fa2c50f65352a2e1db81366681563272d435d4e68f59745d3ff31c7a6a7ce7c69f3267fb48574351d3d614a8385af98420b5864c3d3844a26df9ca26be5e086ba79b68eec9ce46f0d946353bd55936e49f7c9a8a0cd878d0c5dd5137a88e81df356b1fe331f1577ca720365f4e6ff2de38dfa1c1155cf56311178620debf84630f0fb4ff34b169830417f5c285591e5df44cfae83543fb20838022a296fbd32e4d2b1f0bd9b9fbdd92347d6d2d69b8c3f47aebd54da8178fa0c041aed436b2b2d80952f65cec9192a07de0e85eecda2f60adb876e6792bea234a96f65b4717e1a796155e7f59a74249c90e5d7b4edb9aa16eafc99fc5b9dd7b0b3254fa487d53d60a9facc7133bf022731a12c6474bd248872b37477ae3b26b598b6f1c31e6a06d33d0c9d4734a9d42e64aad75e4a851901be89f592210b521ec6509867671e45cdb9ee56cb7c9b6ffc9765b50241d092cc501c169ef475bbdbe127d7dd4a859e64ee3418a0677ab4665c1e59e6c226d407dd411af4f232429cb866a39ee75c83a4aacfa139a7244f1232a418b3f1a7b2f50d401acc720ef493e62e7a89ba1eddb6e42c63303396f22325eeb229be10de614bb1c3211e90897fc0467d589dc40d54c1e9eaf29a893ec60c9e95ab48287dcba393294c7588eef0da3e7e45182ae5776330be0312e1b64b2e489634a072f8355296333aa61a3369c117b256cd770ba68be9be0a8086e3b3f2af4c98752a1ba9863ec7bfc421a2424475b7d323feb079b69aaa8b2ef795f4557607388c82cba767606675a17f3c9314956bfdfbea2071bf6f1a087e370a1b58b2ed6ed5e84f9d7a36af2ab8dd94f4d40c92f9e5bc015eee52e260ef2f2e19931da0ebf7711b6a3e71932493eec58323234494cda0d6f70191cb469ce752e61377f3f927e9e3c3cb78eb79d35d99d64bab33cd171e0050a32e43fe9f7eed13274f5c872e56748d06fa0f7f0cdba8e10e2247b291ae9d315c84aa37c5ab1e11bf1b2f6a8a00ea1a54e02544f8918bf3f2fadf9bdd538d120183d23fd703ff94735f3aaa23726be10621f1fdc0ce81364f9e40e8310ac48bf6e38fec9356cfbfb57e655b11e48443ca4824ef86ca92bb33d05799c0cea8cf84f9027946b9b3c208ffd7fc47f26a02fad0c972f3f10b1afe78fcbecfb3d82518e1b4537c80e5c12fa691d6b00858f8cb630e0b7b74efb9dc8d0e9b2ac9ac90c4e692006239b172478a7ca36e181c1435ba44d8c0a94d8bef77b836ebd2d9cfbe5b8d405c044eebf083fad6f45b1a16700d477188919c03b6dbd6585d765e1cce333a1f44b69272331ff502c37e50200201913d552ac05249ce60ac8ea5780df2755c84be6aa1023c4978f28974617158abecd3d81794f2f68d5fd0ee171d27149f99307797590a1b4cec99bea13d8b73fd235334ef04e8069e02db8dfa7624ed368873fcf317cd535e7be42fa5d4eb1832c1feae8a8f9aa27b195c8f0979f0c8cc6df453f69cc1a8517e9c69d5f6385ec64879acdfd394c53fe56684c9150738ab91ccae09918c487a9215f2a63e3741e1c2c0fd2bfc7df44225a6189c515a46a81624b1a9d4f96273fccbc6b1afc27c17f300ea3e9bdad829f347fd5e1375c9c05a93535cfcf9a8ae1e99d1afa5cb7ab4c61522ad0ac7c1e24f8a0f3dc94b84b619b9bdbf3c000d6e62856c8c61861a345a9845f065267f6fa01f9bfa50b19a16cbf84efb50bf02fc7f9a119bfaff1009824bef3c4cfa8fc11e0e6f9ee4c603b6b6930c1ff4bd0610370ae25e5fe4ef7327425788c26fb847da18e484d2fe11292b128100be747116f1b9b4422662ac70ef169ede15ac5fe3fd6430613379a466b4046745cf107aaeddce9ec45a23370bd85ddd20089b41bb97724445216feaaac77bdcc7db4756982c9c5a10e548731eaff01d285c2466f7c2d04373213b0c766e12852c763ebef589b5ab082ab23efd5c6ddd430f63d64ee75c7100f9f30bc9845c82c5ea1d193fb3c45fcded8c65d82705431841721eb0b3e4cfa94bbd61963d4918ef391889e5f222fce4575b3634935440bf443e14b32c2a480e22457f3082cbcd410542e1ec65b5bcedd08aad3aaae5b49598bea9746ed04624a8915395bc02bff6deb342e64f8ac16e7ed2673fdf321ff2ed248a4829af9d67cacc8d0d0be28292ab5d5329f85536ec593a63afe59a5cefc6388b391a368e0f7d6758ec8de292de01509a7fd9183e35cd4602111293cf240565eabae1989dcdab9d7d2e388f88a7eb8b03d5d365171faf181c432245fa94d217b9b1452232bcc698def55c4ef16044859e4f57c1961fbdcb3d571b0574aab3960ff834ea472a55813a445436aa651897121311117c3b40b24194ee2c0d94ef9cbd244a3251dc0ed5dd237767838db9480a15143c134cca2a4de0584720f602c267f5d8aa3c595ce9a61583f35c11bf74402f432a60f771b0418f752418a99860edc4967998bfbaf7d085dd1ab1f773b1cb71f89606d4be2cefee38d775a26688a6544f65340022918dd45f0313f0b48745334e161ead84e72d5fa14dbd7c24c867b28723c067c15750a2949b632f3eb4aa55566d9408d1fa9b6a1f93d768fc760c4eddbc04f213c0a079f211b59cd5223fb83ed8ad600b1c8d5c36d9a926214c3eae9b67f5f15e58be9de0236ee0990df08bb645f348698f079595de39f9cb206289085b4e29112dbd0d6d7bd0acd00a481d877aaec6800bb47721ecb73ec146a87e34b34d19b24114214ab23ba9da93e4fb64e3215ecc855d1da5a8459660a911451d3abd270342d39a2bac9907dcc7558ef83d3a3a32408545d062747f08f55b97ac7fc769dab200f933c22ed7aef0320b4eed5c517824de110cc1c61256cd21be0d7aeb9eb1009bb1be535e370f7c038ef14bd3c09f57bd161902478c3e7b8e0228036c6ad79185f43a9d342593c9233c9e23d7a8c4fd23b55b208149fef4bd5ee2eb41276e24c5811fb1137a364c50e44754de7ccbf18b23f36db7b4cbfbd2fcb60023d52d78b97ef306b831d420fb1ef52da58a0ac02e2577a9831f4172e1a96c71e883750214fe1fc74ec451aa9174f2979330cd0ce087143706034bbf8d31e25e7cb63162aa21c9b56db11cd89cdc230c474eac2ddbd0a118ad761565bccf537f585e361271e68c4c858c6b156170437dad47631ca21359579ed6ab8f20607f40429155803c4a4d68a701cc12cf615b187f73395dba69bfa0a2bf870be9ce832bb9c026e845d5b85e93af4cdda31bb9c528f91d674014323dbae445c896a1c21425b3667563272f81d1531d88ad9fece92116d7608ccbdd6fbaeacb6a85f4c79bb6ad278335181471a29f6f12f95728be73d6534b7d88f3470dee32f38eae8157424723c30b1bdd77b0a6b5b017ce5472337fa5bb349c57d5a95c801c7a522a9e5f1450bd2f3fe284fb0ce4a86f58de7fe90cc7dbb338daa72ee27ea5a920921d3559ccb8746e1d57745c3d0473aa7dfd755f7deb51f3234bb3cbde1fec0fb8cc389052b12e8b678f80caf5fecd3fd4fe8bf4073a48d4348d26b79446496665bc68dec1d0c7cd0cb87446d1eea894f19deacae0529a36e12fd0c16f65d37f67c1ffbbf59279504850ec5c0f483a5f2e88264416576ae334413a341b24efcbc84ceae86505802f3ee0cde2a397d82d13b1eac4ba57c012c3dfe515a00082ea857a51f568640c257d797f19b5a0b0fc1204fd54860144a11b09028c1ea91f7d536097dd5890d0186b7190e93413e4d99452ea1e3c6f921e6ad164e07551a2a186523dc16a7840e9c8e4312a1a4e8460482486ea48af1f803d929d9e92d94b1e1527a76b8a1d9f96e6b705baf9c5f3a58275c3c8a1d41e2297773acd7e9fae6e13a047c8ca70970ac05635a1f8956766869785bfb3f3ad57f17a3884677c8ca784951ee8293e7160c117fe9f10c75b842cc03b250e0127872e1ad4c46b24dc1db5524f6baa1aa1467ed24ac54aadd43894eee6ad27a501f503ef8851a3c4b9fe54696c953c9d7e0cbee074ac75789cebf9b02aeb6fdbaf5627e1198f5fa4a97b4e2cf3a9183455040e1a5434026dd1fcaa29332bf9e1bc66a0b5bd2aa527dcd0e547c5a794b9fc609324c1324ddfc071904505e6dd737cc7e33a899e771ae705e92b82011ada9268c107be65c5486580a4189233462a002e22a9982ff66a73103d5088d3118a27c940e38d7b4a80c1881426460fdde321a5c55023e780e15ec80f55c6d522dde7b0b3bfd15fca8cb253d0a2075404b02b6894f43554f17a4579f5ff0bdbc315a2ae61a7ad51f754aea4fc2dd3d468f39d35a8ad61ee411d30613d3bfee985c1bda4a2d58c7247aface01e98cee3fd967074fd2f463513e7b0707c2685ad9e77a89a3f47537f90759c1c5e875df75a6694e4e0b545dacb156731ca23bdc9944f9eecc532ffee5b327169d609f32a60d26ae9d98583dde226f7b4855cec2b85ef6135018884ea1c7b2bca291d18db8b8fcf0256f708d548abba8a37aec8d67ec408d3ef2b37477f40d70dc5f1ea8112ea8a8796e7c503458057de02c73ed88e8bd1b81e50e75c34af949281e1a84b281760ea3c4d33a165399d0200ac35a5df6752d4d7fbf12e14786904eb9c1bbad5565e06eda6ac75a1326fed7c8545f1a6b5b17490792e34902b1d7e6f9b0ef91994491dae9cad5d4cb296a2ef416b270733e0a004f058e0645f5dbe5248ec75f66486e1c527afbf956f68f587238afcaed0fc9a74f557e5d56c092aa1817fa26673a492702cd418c444b5512202f02bfcec29adc8ca7f8594f8ea76fa12b47712f7d567cd7f20e913d6f1f5e22bc449a64fe2329a077692316307592cc01316a2ad0823ea25ac041e93011c29d1aa0fa25cea23cf96705f3a494fe515511b859cfdfc5b059455b56d05b838da60b99446dff197e07e1e6fd00dd6f62df56059a7b9824b93ca3c8ca75a5fe8bbd70195a46f9daa16c83b99212af7709626c2f863cf8bd58a5e766ede593b0e73a669b0ee03721c7dfdc62ec5172af6f6e1fdcb5c20ec4b206d8149c78b05d08f154e429e90df3d5247465c5fd1682381a4c850eb634c7183482e54331d5644bec1aa0ffdea73ff3ba58d54021fa50b7108a30f6c760d733c1f8e254c710e4ffbd7a4ef6d4d880d31fe01616d42bb41ab6406e1dae077a5f4e7f796e84f97f5256c6e4d03af53a6f3f52c5affe213baa1f5c1727aa24d50e725f2c0654af63cefa1df6151cd2fcdd1a550c18ba5d7c0a6d2bac6b2c8d0633a81d89f715493b5481ae1b1a18a5a3c0351573ef011e200cfbf8971be3c9f2985d9ec6318dc6612d2a58b4e33740db65a9d5dc1243ef4f550c1be40fbb3d2ce6e0a357140f405b1ff29d38435e1ad4c4ae943ee4953b2325f3eb0b934271ce858fafe492a57df2d75eb879742f0efb17f4efa3b4ac5c2712fb3e2fe191b698691e44bc75ea2bd348663ebd0a5bdc17f15120e88f2e9189e326516c20c11fbec475fe5e032fa37249eb9e581720b38b7c35c7717776ec02bca3643913f4bf6c595ac1a3485717fe06efa54b27d8b548f860b1351a8f49d49adef37a0ce603817850f2ddb1bb86210227749c73817d753575bbba4a5fd954debb60b8e3035181752d2825eb6f1d6d9e816bb005ec51c511331a20caaaaa40a6924a8fe5de64c632bc3f63ce98733237955d91313792e300f1d69651ebf734d88685844a85e6f51d4e34eef8a035f531a363321276614cd1d79adabf991038a2ef663102f8f3915d73adebc51d7e4059bcdf30c86bd2498f8ab99c2bc1fa3d9532ea76e97e9a8d0077d2051d38672cdaf9b4e4dcd0923e2152418ecb3f652ee45b725e4c3209ae352b8f8641ccfdf7b5165c0804dde1b9938eadef4b29961d2cf506c8c35fbabd74f9edd86eb0cef00033de25dc5460f7fd14608402773fc98038061b6683f43c73adabbb0a6a628a81a9acb308ba2575e77654d674e4ea2dcb4b47035a13a023fd4923fbf5bec2f9582c867c03023ce458985890cecdbc17222b93b160caed09e9f1d2f4bf45cc78b59270a435515121ccd1493a3e62ed3d2211e39a58a313a539b7c32f8e4def975cac0e75da5b4558b2a21d37ce1227054dde6aa48f8711fa885c1d4a52661c51d6676b3fcee4eb1747a75221734c92d3ab1dad73022f690f064d19b2643de2debdce9c08f489e7d4cd3ffd3f807c1867fdc836ae02b687010ee18a4739ff1f847d04449f99f0e4602c02cdd146a87b18d754657e0a4d08a2aa3a46b7fd3c20ea0d3be153112c66e65aa6a31505a66fc6fc29e34b56f10bcebf4222fb922f065d949cba74b7978ebe2f338d916c787e7e3b997cb1200528305c953cf1be633bcfc6f9f055631f87ebad758e0ba12e420a57ab791495ee26cf3d4350c56dad6d1daad9e3545b28f47fad2de91d8fa5c5879afcc27445e9aa012486f728d857ee9bf465f1676a32dadccf747a57d023398892b27871ceeeb2cdf38c312dad52b8cb5ff8db39c4c7bbf6581ddc5fb28580a39d3bfca58bd280a3a06592370d5447372dbd7e610f5b31d94620e08fe50a605fa1fd5235f9a8ac60664d83a404abfb078bc6ec6c9fc0963804eeda0f606da142bcb81d3d4edee4771353fca35ca3f0ff29be3cae8f23bbb2e433f01ee9acc952a048858b15342a5ec5c6e3827eeeff9cd9e63d12953c22b824877fe5f4598a64094e74e613232702e9eb0e90c6f87d85113030f11471114ef481a41282a45c2035369801f9b4d2593828f0ece5fe769de2ab49c8a55e507cdf6d6179411f692e29c0c1649cca01f2ec6c5f02bf8b859e551d196913b81a4e7fa7aa064f2139058623d9b0be6cd71bb414e0e944b335e740c80d107ba32c5378ed91de4d563b38b09da05fa308d70d4d3bb2c5ada70c3424ad1260ef300fffc5b45ebfa5ba361fa5a874f650a52bb13bb71c40eaf3c2100be4a4b7ee72d8910dd08631849d77b8970089fafb606d463b86037ace8d408b08e5e1c89418b631c80d0ea1f5792f8681a347b9ca70da3d34283d26248a33285786e0b37a1f6b12c63af6c6d8b0b70c934b87e8fa08ca4cd3a796bd3fe698c076b4237e61039f067f7b5eb730213e6f41dd11a82861aa19c034cd58c923f290f15663a362f8c45465ff1b5f435ae6bf2714e8e780931fa6fa9c93a51d1b616b4ebbdba6539632b8501da2d986d304bf62c3839a3d5a0138057237b07f37377511613daa81baafb6c94bbbcc8e31dee407e3fac7e5e2699c24f9eed7a40666f1753ec3b72c92d1fc15f11fea8afa563ffd663c43d19f67ed15fd781e6c47e20a0c1bfccbfe8882ec969a929c07b1daa7e01d16edeb3a05f42628e2995c1114b7e565d77b7aa85d3fff9ba584289fc2d7bf03aafb7187749df052f599ac38bd83f821e26eadef9715c2260178156992f60c217d105496d8947edb36840767f0f8e173bdcfdea3edef856ae1686a4c15841b3529eff47c2d0a3af395c8bfb62fc69c0cca868c30333eecd7d9dd8df86286ceb5a2194d3cf4dc82183eec222c5e45d86958d603d8a0ef3411c092060e361faf3ebb8fad928c49b70f65e0554f4b6ccf48cf56592c62519b693385ed204ec87b9145856ea1f3a1c3e72a15377081db84d5768f90e018fc380f9941f937bd65d4fadf08076ee101bc8605fba338534a0831b0e6787deea73d9e1a068af5391825e7abc2af4a0ce8b3d326383d78bbb54ae1f44f01e6eeda4afc866ea99d401ea723d38849ae4643710b7bdc21183398d25a4ca7be2621c614cb496e750f907bb751ed7604c66f4868fc7c615dd200b92355e76e1e4d2cb2b8654b541e62fb5250dba31ce9ddad555db8da6642873786cbf11194d4e6c5374104e91c975c241aa712326ca0580c9df578a76f564289cb8cb89287cd85357f53d4bc735b7a7106dafd6d2e88b8dda8eec12019fdb2576eec034ceb075b812a7e47e82ccfd57f4e1992f8527a8716eecc8932f350ffe2bbe2a65c3a2ec6e88d6fbb7234e8a3bf04d05a299c63dbb47120c9fb54c65a64a9421fe32a23d7f47437b969fe6007f489aed0ad53786a22bcecb93babf389241760429e2cd439cb4d7027670894b312d9b0abe6622f3dc68cbaefebc531896f1ca2b51d15e410fd4baba2054c748f5a542c86099518c3c8f7e1dba4a3d3500a17885706a0755f16c10879400c4eaabd912483cf1019b430ad9be637426831368eb6bc2a24acef1310134d9493faa3c1c74764b17d9da3da8ad8ce724994c513df5c8906436c684a9524ca9f376337c56870d13472071fd1860e5a6c4dbc3d5f5297033dd33d71d88586bef73148556191e02e798724c0fe0a66d6599789433c1d4fc19229b38ff2db489c7681015e27760fe665237b34b60e7a4efd1520987c74430dad609320d6da3702dd7192f52a10b9c8c22f59fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
