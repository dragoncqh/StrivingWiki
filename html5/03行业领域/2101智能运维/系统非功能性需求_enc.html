<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"516f681b7b6814caa334824cd025c76d08fb4621f0af8cf5c2eb997ebb5feac780acabbb6b73acba258ff7595a974d2e79d2137b46c3133d461878fd801499f564b07fb18f1c91179c789cdf472d57ddcce0c10649976e773a8683de0e1978ec41c4b53628e20eb4f9d0bbb4ca746f95f9989240daa985d8d203b9aea8c23b0d6ead74707fc976572b907336d930d52bfa3216c21c0c93813d111a27755082e10312bd44330ae0d235dabaae3cc76cd79531146c93c45f5fa5c087af96e2b047d4e252f960a1824dee316424b4ea4526e27c5ea8c8a9cc1a29d7b50dc298130a3c2ad7790dc43036fed6e6461783b547f7f967bba1f05ee42f5864cf13a9f49dea436cac012838bfa7451a0e100939ce7a4bad010b5a87465b07b4222acb2ff76ea8f11342ebdb01e56a119ee7ffadaa6fd4a70887c069f56a2ae3df898cd9eafda6b582d9dcc448214bcd7cf8527be5e3d4c820dd683616eb4de5f0bd726dea8ac9d27872a0d1af38be1d8fa733a3cad714afec24b9a07b2952dc215716a3a375567d31e0c83f63f4f7907477bafe6525d32db49d86f84803ee5418536ffd3f660e9b73ba2c4bfbbc1d7e89b5801cf69ccb7d0d2dbfa8a0c618cda2160fd598d9e4e1897caca9a5f5f888d54b557a4caed6f9a4732eb6d79f6479ff9a03a8045fa22619da53050eb4f0dec0c131167ce8ad1e9646ac675546f5081e88439122718cb8341353a230e5ec3a5ffad1460eaf1efd8ccd77cd3151221dc46670fc5d8ba854e3b8f24b742603b34f3de6bca919ab304f54baaf803c06cb1b0029021d23b69770425677d449938e9d30b997a5ab7ccd1be61b886884ca1ca1abf5740f2d625bf878a9d52737acff72aedd34f91d1cfeff60e8d1a246aee817804c048c3b1ad5bd99ab0a7616904c3acc3468d9f5e4d2bab0ab5750ab871c24e4a090bdba28d6456ff63720b9a3974713b060273c908ec9147fcbbb5eae24b05c77157027d96d13ad62610a4aafdffaea68aa7c526efe5d5752eeb3036df792b972f705151e082067cda1e0c5df98977ac6b377c61331e4655a15640cff44e19945c44d84bbb5f5f3a956c6348d621d5aba5803bfccd760ee4f799c86c7f9bc8a8f1e4dd124f16e1ed425ff31768486d19b6d2ca6c842afede2f2ec642255200b121e7450b7116d3c2803c89dd52c128b650692070c84489d581f7e3bc4e15190b0d1ad5588da5108551d720464ed8d26404d042fe6aad258e4b64a161b1812c6fc33d23ad58560b806f192edd77b1fe8bec0ffa448e587f28a53eeda63708ef81c47ca26e8b73eb0eea69cdb33640261fc561ba1401ac0fbdcd761218f3074b4429dc3768fa2c3fd2ed79c7ec0e3cad014f190736ef54b3fc6ada19808a6462466cba32983be8bcb715d813eec94a47db4cbca7f5869dca8fd64078676291a75468cda121ebaad937376eabbbbf499b07e8d9a712dd636de10c1a8c2a4c81efde7f31528174975474aee813cc8821bb6564617a529f9dd13a2961283caeb17efd6c7deb8c552687636ec2fe925d93384309e17b41dde2d5e88cc2935f4f11fb852f2415f776fb9da7ce96a07dfcadd9ae5f041fc26f19dbce2bd37add31d3472de8291687c4396816755a95c85778ccfcca7dce9fda33db7a317b31a5f15a936fe765cbdce1e1e614a5c614ee2ff7d1a48849f376e972824af1b35c1a9ccb85c92f59f56d806882789916884ab978fa4b4df397745b59eb2652c13e04b2f63ab3abf771142f095af539b756772ceb3283e790ab570e8a5dfabaef4c7690277c368aa10475bfff2b05e18564377ae33c6b96ebe377cee2ea76d9cc143783a60bb944391abe456d0c4db6be630bee3ab7710692617f58d07c1a4221dd5c65d83fea9783d4be6c29a22939ababa4cf25fd4b31d176250aeea7c6ab148b39c2579a1c9bd36f8dd8ea3820e59956a2a7faef680381300a54160e5b77cc0b69e4ee3f108257bb94e33976b48139e599bf1fd9f86dd7d415efd7cffb662d718344b32d78ee235a19ae64c1d645e6aebe9a3d084051f367c85d9716cfeea63f12e8977eead682af4485ccc241705d999967bf4b0006825a07895987960218e1e9c4c93f0b1f3449c791398a50f4d7510329d65f69ebf300a6b2bbdba4e72ee7b595237a54855325a4c2c0f50edda3e8da07d5a330790ded8dd79d2d0831df28e3d0e8e97a2fea148b9afd5fae227ebab7c47ab635eb57203bb9f7c063accc91039ebf1a6599e774d611cebe2fc33bd293ef9d5ada4175a95d79218f10aa47313bd1f414580ea46f7a219457a8bd95ef24a5d65499354367c4bcc9e064db246efa48a13636b0d89823d618833120b56bac100460a1ede3f238192ab3ae7988a6c6a6fd1014a922d6799eaae9a6b5d3dcc860bceb9dded7e4a7c1b622b9fe7b1c4c4c857d2d3f4a5d2288b737ecd8cfeb7537e1748e00f680d5aecfc12ba3bab981a49cc5e6bb76559f2951260e86a0af20bb99e4185c0add996540e7133bb9bb71bb8e745866d859c27df5ba25120dc6511075ef3b44cecfde3f1ca2e26878a2612573b9910d51abe0fa749012595d850dace64873c42ae718bfc9a541ed9810c325c11d552e6f4ccf0f7f5c413967dcbe2b697449f33b8c7b5eedfd8dda6e431fc0b848d12c1ee841a7c7130ad3956941e7662cdfeea2760ffaacc659b3843a56444ba065aef687a1b38e9b7112a5443fd176e4355e15e856514b9068691cbf080e90ca775bd4ca57fd62c6dfb0245aa9fd0e8d8b5f588b303bb8aa944ecba19def7383f716c838ad51b681c06c3d49d561f040e183cb2017de87028279aa2ee87c9eece92103b27cbe22e58340d1107e4a355becb5152615506ad251016d4704fcbaf458f4c18968ddcc282f6491937197a39af468c99afe5e5d25c66059e7e2b1040d48b0c101d9822395547883baac7bb35b0ac1a983682e9d9c415c165f2d26d76a10f42be9bbee8a0a7594cd3bb752191bd5b20fb202a8aafd6c2392aed2c39f3b2eb5fed0cbc15cfcb9cf21b0eb5630f49f42dfe5ada9a911e87d855f5e1c37a5a701e28663695c39b2426e523b89a1860e6a50a130598339e82416495d87201f792c908175e0eacaa8344ccf861ff6485adaae0a17e7a1e7c9cd2f13be2672923aff07c7e4adc7483075fe6ffbdda4f66ba80a6a3acc7168ef94fe29db16012a76f1e9a1ee094e45db9eeef387980d3a3f217eec48538fb8f1a86731f268956f3f139aa022de932d91253888a423b242cee303259b242149b185cef519a30b8d97cd2e72d2e0a98f808d6d00035560d012be1ee411bb0f2db38a049573fb7095aeecd5bf5a427728c35339fd57d823dce57ba974adee4f892c3440066cea1cb40aa20308512ce72a936c6a47d58f81ac568dd38f3e870893323a3cf825410f1e62292d147cc7670c12aa6eef25d7c3b27581f6cfca393e6331d7651d073fd1ad9cf7a36c8146649a1ce3591b44f8fae598650c746a11a32949ef3e4434061b4fad9e3832b861a7e51b77c079f3b38141681768a86526691e71440a1e6b1788cf3b0156f3a9b794ce454956949fe6b0d81ad0775570ad0a557862c2385559ab7b42684c98e3524f0bd87426d9d35ff7c4ba99d990123723c399fc79735fec9da7c0fe52ed579972a8b4e41d56eaaac3582a04a322533319f62936e21c517dea747b1ac0b1736efbbda5f2af87e8e04640b5f4d749eab7c78af78cbe04f18d13e20f57c4625326711369865126d0811aa3b6d2aa13763cb84704043a9f81b1ee3ce8c15c8677ce1bf4cfc96c2e0dd9c1701552107c6136836408d8d5ffaac18eae82f51bd2b5db33bf51bb45dec03276bf5a689b6c69933db864d4e584366bd555cb2d58c473487065c323b707cb8c3dc65ba846dc018b5ef2a90b9c1c262ea6f88ad17f6c8d021870e835f602cf4d058bb05c8eeaab4cfc0a5ed4aa63beb9f7128776699a052eca355f6e220c987d55367001c2a65c430d26c9b1710dd08accf3f0eac3b8be377d552fbfc875e15bf6cf4f4e33c8321e05d88b4cb3718931a67b6f8208c6d02dc5c653153d8de31694b88bf1f8deb30e4a7449b85609a965de123b5713d2ffd7d66c42c9e703a62e7c3b1d70c6f9c10f8b812cae18a84ea79a2c8625cb26d080f53169766ac86fe2779934dfa12d0dd6443b1cdaef324b755b4655dc5a43df1d5eeea86fb089435307fdbec648bb86b5da67a5caa5fc84cec7167ffc80c215636268b643068427fb89f5a6152125810dfaef23b6f1f255c2a2b7f5e4794698975b1bcfc5fce16944866764d226de769178df432d02abfe6b4202f247a841e11b18c0339a88505768d97988b0515794f7274d52cad7cd5c6778c5d66a8f02d37dc44738ac4f57af1da962fb7fbbdcbe60c469b063a190b7155ccd932e55e70e15e755ef1a2b94db5bf2715089844135cbd8a9f7e84e51a6112ee59fa6164d141adad9bdbe568edc2fdf15eb9abed2537caebaeff40ef5979785525ef8e912cb59b94b67970cac7649dd035c961114be9e83a6e04ad01e64ed6b7c0cd4deaad0dd0eea245b7a0bbe8d991a28a466f0475c4059525846089d6d7bdd74de77756aaf6e363ec7f9e392136714bd06888e8eb21ce431df15f3ee611773b3e6855061712cc21b20d75ca285eeceb13e3fe66ac42461e77d4bac4f1e4953e72b208265d9af831544d4e810c2a88fb6dc92f0c7b086eee25b7b95c7b9a73cd6ce73bc3f2bdf0057da4172d45a72fc9b025833245a70df93298a037294a9e7c13f53e762ecaf05d79b6349ead9d6f81c1023bda1e6b3097ee06c2a808fae7a71772396e3fd785eea6e588f00b569b460d7fd33b321b2b3262cbf43cc44750cfe703fdc25dffd83ef7511fa6b2fff6ffff7f55f1a01135b10eb0b09b679b08008647947339a04d45cd2877c69f102013a8849a5aad50ecc23314d5ad8b2e4c75e40118a23946adc1569ea82ea3cb44d29a6f9e1707bd0813a854a18cfd41819d36ec62175f986cae16da1e0b35432d1e2037408e976d8c0083e8ee991a0483a53ab076c71c39e2ef904a6bb3e7f8263a96b5295b5f9b4488c7438119725f9de687bfd66e6b3f2f6d0aa6abbb76c0a7de9d283829484eee9129cb182678bf155c75dcfd92e51dc47a44ccc8eaa153f7ee475901efd69a27cbfce31041520ec06649ddacfc87f4c02362e4f27d67fb35037356263f22005757295975c8337414b10b441ba0f91367a4a5b95b894461cb6db1d3b76750a9aac6dc9ec23557910924351cb7e43adec818b883dfe0620ee8d5556a371a3bb794208d534f981418202f70ad6c71317877f96aad9ef4eff0a92c3c087b8972323ce6a49f10ce600edb21d57d96c7b1f69d656e0da0ddd2ee256c2e327a9808d50c2cbb26d592b7a4b637ad9fddd0e11a443b8633be1d1837fc938679670ca359f39bc5fbb9bcbb323e0de2110301a27f9804c4abf25cd778748095af9987cfcaf31436da201b0099aec16943cc485b0f09d63f04e2c9ab23cc22ef844cd79cefeb3112299bc728c78aa1946119819eca1830416c7e19088a7937a6e465362e077a1458b2fa61d5956b350b712f58fe06155be8f564f9f48b68e0486a9d46e18acfc93de8b90c8986bdd9dd3362c04add51d1b57f2c915ffcaccf59289bff9413300e28c49a9ec62a38ffdfa873387ab3085a557500a9046b911fe22253f62c1e18148c848fc9872e590a6ce4d224f57cbe34e214bd82eeee46340d8ea1ef0045e491a8e6d584c23c6cf92ac5b129dcec5333a02b4e41dca81c355202b034faf0673271480efc5d0978e0dbc47a523fba9e6dc153e1afcfef030373f8a50162628c310c33ad358453d5cbe78eb799b3a6e246ac7b1167a8fae4e6edb8fcd08aa76cb424f1b4fbd4241acd2a5d5f936ab6107838c65b1ad27ea2d201ff6ae52aa5eeb0dc1895b302d922acb68703258326ec2110c2a6a43c67339d837fbe229b80432ae19102b88910982edfb96a566bd235c46bc373c05222921c394588c9ff75176034d47ef17d173e41ffb618fedeba7583dc7f452a5573745a572f25f666ec6ddbfc578148d71a9ae0c2e277999609f821c4df75077d71ccf7e653414880de4ce24a391286459950e27697d0792dd17f5780d4b86546a4c37da6a6435ed58887e9a5a885e1ed3fd2482054a62466ab469c8b5cc6ac3a05519b88caa9666a35e29609aaa5d61ef22ba49b1491f07c8ef357f68466e59b3b7fc101353afcad8cc7ed6cfb2237958046c877fbb2d0e20f9f351352bcc0e80554fc1be1dc4e2d36f3aeb356128e0c81a7671028fddd422355361aad51fa01b8c9af415fb6049ac7fed0407bcbbcf02f1b353b5b7bfab285cb294164d20920dc347d3467aea4763daec80f83ff851fd749563a1866980edbcfd36442979b4b58d73a2c3c7c3f032872532fd5c7b337241eaf6b15698668eee8bdd548aea36cc521115ff144e7c4c6d3e4837da43276922a7199d10c572f6eb384d1466f8c9a62d832d1ce56b72381ed64d2da0f63a8e2447148b39dbdab4d4a54ac9a7a03bf75b6bad6cd710fcd42e380c19d2857f226afea05cd4bd87a99c3738da3325fb9357d2125803546add7de4cc210bfc32fdf74a47be3c68b6ddb9d04e1cef0f71981b82d9143bdbf0f3653c29731cc369ee3759814aa2132754385c489ae5cdd68c5907d1bdf9ef897074e61329b7618b8d04ffb169d8d8cd55ac7873c0941eb7f2002ed919a5983de3aab2786238564192937eb2e968b55cab4b7d11a1f7184aa452dcacaee738e3a0e1df0557840934cece25f087e9dc806fcbc6039cfd2b5ded1107335608e4799d66235257386f5480988ecf79671775cf155e7b56bd9698f1dba585da71c0bb9e3d5e987dda82903d65a415f16f5954a6d8f854429f6c39d450638c6944e7b985c23a274c9040c29cb5c5535667f21bbc67de80f45c79f1da4c9c0a7653b93559488f666c09e4985899b5ac0046313a2f5b10982f5ace71c12b9d7803b6fcdaa3783f77c6f21213a26d7006d406e9ecd1a53a1fd6b8897dc1bd4abd6f08a88920a86f493031fbfb3c865a7d8680d2319b50baf2f08b27ba24e8e15464bccf0550084cffe8487419b7cb79db5de65415c8b5f29734d0384ce50bf5307ba638b3738b1081f3c2346454b7be7e04a5b11e21551dc0ccd7124a0fcb21c16af19e749a1dca7e585d799745669af0727bcb43fede6d8b04d4f41cc58e9316fc3398e06e4c16efba5a98666decb6d368e47121ad7c0a257c2b5bc33f4d63d25c7dffc7b8fd017e99ca1f88e2f71eb40857f600f7e8bfd1aa4e72f0e00b2cf327d95f734bd59537741c80d311f8a22035df6f662980c5b3bc57e0f81d867289f1fd540c66d2a065fb092fa07374f96744a31e6fa3185350186b888f287707038d044304221bf305ef60d64660efa1e037bcc6a20edf299559d1a951002623576e8ca07883bca7a4ce49e060c2e833fddd3ad6cd475f61f7f3b3352742951fdd5381cf901c028e5fca710dd59afe52e972f6f5e30a00747697bed97b9e7c033c2242b0fc21dd3888fa41e67fc6b4bec5f779b7a688bfc76917628d4911640d1d8b0eee2af1c2b9551503d9e01e3ca757adfb7b2d1912f62d5cab059ed0cfe003894619d1bb852958f61f119a2b98650c52f29702440195e0c015cfde866ac598a7650b767ef229c9c99095e560e06b8ff1d2cce1a31ab16c441ed4189564bcd07c77811f60688adc88d3a3d5c0ba6c4a63c8754a8907bd454605d234f7ad5c9f9cfd8d31f51888db58d70ded07f5cb8c3ed9a98fd7828a8e01573b1bfb86cd366224e4fffe0100edfad42fdd51840cb38f11d8e4356b68647b2513cf392ca3dce34eb4b4301f64c32874b9a5b2ac034b6b7b5e6e9ebc3191b2b3ed89169073ee651b976a16d0cbe9be18bfc3c2fa7e4f37a6783eebeaa4f24ee77331147367e3f460bfef8fde1851e19a33f6ad891ac9c88b7a34824b694ade5273e8de9ee16f417ff9121fce235f4a2141ee43a17cc125dd39e3c69ff0db09f6033b501ca5835e970a1b9ae4f41d82dbbc556493f136fe186789bae24c18a93dd45c429de26f27e008685231b316f0fda0ec1044bf5f3155e7c5ee4fad8f3e4bbf19aa16b474e85ef7467f5dbc6d1f024081fe299b7a713065e48bba98b32082a47c9c8f63c1ca9066cb7b7b2cc4aeb84e55127774281f42d644759c4621949bc788f5971650145805e64623f3bd311d18827ade434f11ff9a6507d465479af40e1cdacb9bcf55460ef4eb2495c563eee282e6871da6da1a738e81a2836abe88adaf277e4e2d9fb5338d33bd68a293af06a57b4d6c403574b4e5e3bdd726a44a5f8c9eedc6a287766c3737f1fdaa16087fe1fcd1a839fdef0110e277226d109691755acdf39eed517e58c97af88bdb2efc04aa5889a3ec9b8c7cddcd9da52aa139f29db44411be3440f22cbd819ce8219a40b8b563b2789f9d38fc1383d8fc58ce1e62de5b81ddf2891002533aedc58de742efefa05226443830362b84f25b1c3fc9d4db065e7fa511679e2fe6f7f01e8c8ec9793eeaed3635dbf33607c2f80ab1eebed08168b50be5935bf3f096573de23d5c38e7c71d3139c14d809aaaf498e8295a578c5202af5f8794d83bd629d62063f9779df22f76decd3975dc9187aecc60d3fc529db5aa240664653b1367e34613d411bb5f6b45393b63f8917e2f72037380707177c946f6a27db6b085203a6cc5700bca51879877ad22d5f12b17f1f3c7d9198600af881c53c71b4ccea77d232ccd40318863a77b1ba3d620542ec7ebcd78fe96fca6b83801ff7e60c73c48f5cb46c4cfbea18fa222d1e20d0fe82ac1aa33d6b7ef904eacf55f46d8f987b0ae362fbb957001ed1a7e2433b5e6c45195e70c3fc62e7e1ce4c8d872b98562b13baade4795880ed1184e29595b6d158486a5b8bf53d43358b9ca60a04c7402758fe3ace0d9d0880f40f07f2076c1a20b41648587243072a5bba6f9aece137f148f19dcb9e6eda90446b7e3faa52fa29ec002aeb701a2a00e94e2bceaa5da6bb83a3f50410e6f1a9c3d35084d6073178a373421f5f7030acd101ae527b62161a5d61c464dfef1c14d93dd6abecb6aa8b4ae958614c8dc0e257ea7be05a46738db547eca5d2d5c1895749a02db8a49a88135bfd541f28458790ea9edb88de869ed1849c907a95a4d83e531d03941022f855897140806f3f9921099b549898f9851e89d2b98044647ab27595b2a374eb7151240b462c5bcfa517746fb26eb694299e417b39473a1075a8fac6d75663d5321140a36130ac089b8bbed65c97a67292511ecd8fca76448a40185f9e5f505c9cc1001f228798374530e57972a9afe42bb9d2bff70d948e4fcdc3647256c35251d47222f5397a9df2370e64cbb4e9ba9d8135df0737ab5f86a12d97bde7109814e6055d8a4379dbcb346cb7f043ff178100a1f3e41a575eec25b830007543562560a6aa1c2bbcef5a626766edaff2527b7fb0a25eeda0d6c046f949980c74104427496f34542ecc5c7f052dce2da447897f361c75329144d530b0a93778512870f414de5d5449260ecf6a96d56b591797140c2759695c9a469859ede8b383d2283c9200bc9e4a243271044663214b5e20e10037d501644ae1d69de12cb649b2fba3865bb644fb305778a1802988a15477c736dacf403cdd22b589bba1b2d5f7e21deffca407c134bc145c7bf1a24d592fdb68e09c02de198dcff5e96ab359d47296121442c43f1e77dd0edca8f79ac1114640f331a545c47b1dcb0a8ce65a5f7d11d35bb0d503c503a1984589b6bebc80d550a9d5814e2e988df2b55196e2ab1f9e478335821dcfb0fb46ce30f9b342a36490a719e2a1ecc2618177e6402e623c772cd5e5a5881d47621626fa141b5bb1d9a80d0b454ab2991b4edcb7b3531bb91926791258dc00d3cb35ab5f8ad097c9dd502ab574967c77cf8040ee45699773b84cf5ec9a4b88216d478754fa4838f868342e726afefaf6a2b8a81e1e58c3a4eb1fa39451587896281e9581efd4dca0c0161eebd3d4f7c4129701a78d8391c56bede49a46fc84047ae5ad035faca3596869482370e8f96b244ea15866a3e157dacdfc1b3e3f30e3a3ac425fc39afc372464178d5f2f58f15fa0a2300b7250e79b1261bf95b5146204ad002db1c35142ad35560bd10a6f47d397e971f4644ff2be7a878b949ab8571ae4f70d27efc86d59884e95156f5ff74cc3deff27c60b4c0e0827c06f77821d4684006e5e57204ffb837beab48b42fc0f66b399d7d78ca7b6bab04ec5dbf577e6fb811805892cd0ba018f3942f0c7b810f51ed0b06f162520c5c12e26f0628ebaf99a7ecd6adcfb69036ea4bbc57e33fe97744d3fc1e6cfc5e0e67cf0866da32470715d712b2b77d56ef8b02033e3e36f91134ab5dbb5ff6cdfb444d4e3fbde50a1f2445ff15136e22f278b2c94b29e0672e29a80073d935cc4af71a27b3465e28f867ef5c5ed80c1785bed986e81198ba5c9eddf0ae2267fc9e6b6614840ba4466f6b2e4c195b450385f599f5cfdb99af6401321bcd6cb72a8ef705a46064245cdf490c54970382654b56d215a6ff4b400f1cedfea26d82ebbc9259d0946bffb68a31466269c7f1f64b7442225fd057cbde610dd5dbf388c044039e1074a44b699ba4a5e3f200b2f768d5e34148c7e6a6bbbf8abcc6c777636acc866b98a3798fedddbd63ff5e43755ea8b9a32429f49bf0ac6720ac3894bd26a41729fdbe84db139dbfccd1fd37fcd02a178b85cd87907e343d5ab6cf400fa0597dea5181bcca79ad9064e53d4d86b9f417db3dc22e8ae1a1071e103b3cb15f9f4b976d6c607c130882faae415a06c28f2e6104b2ea64bfbbd61a795ce4d0a9c6fe307bc35bb47f8aad49d7ee44838a3edc44bf888fdf8bff859e3a6af754e75dcb0cbcaa6cecf9cb6ceda63af6d1697a4933d8cd007d50d2c110879300d6d9eb67a904ce85fa4731c9aaf852b763ad7e775dde88a0abe5a8cda0b585b5e07ad3d9018ec975a2339767f89f403daba09b3b117772ee09985951e303e5c5ebb7287a306dd7bb5089e0a90225defc2f5647562391dfdd40dfd6e1d6ec891c013e483a189f8ccfcc27e0a239fe0e4d3513ca253e6a4b1f7322e9c36d4c197b8201778c8bbf4fab875bc5f50aee4baa3e2b814e7ffb8b98776e743953da5cf6e0e1300d4804dcd817964b8555cc833d2fa1c1c3a3d6c9bf6057f66fe35d7cc00c71e60b52fc9e40de1ee6dad050f446e78a0cc2c3580e0bf57b058156e0a30e79e59d26ae4179c2a777850dc7c276bfd862927348180083304e324ddca48a52e92d3b4f099971bb82ea8fa23ce90a95800ee0174fa6a5a36b5c1998c5b3e388f1020d0f346104503f10dcb89bde7f7f1daefc1fe97a7e83d5b680d5c3461d60ace378e7da1c7895cb9591f39a45ceaddaeb8049a8e109bf7a70f0fd1fe1e7fe1e1dd4e7dd3422e759b034fe28bf28c9c7918d9a86d5cef6367bbbef3b1decb4d8693de529441b0ff554c9916067184e61511bbfd6d07f4b9189dffb3ae9b005cba95109e72decb48ad99a60146f5fcbd69ea7a8e38732a9902acfa281940f02330ec9b72b6b59bbb1bab87f38059889958b6c2355707b81cb7b867627c4932feb5f14e7ee964cea4af4297c26a17b84f1f106131b6bc9dea0bf93ba64dff34ed1b4e65a61a4e863c9304054c91c738f57fc64fc3d962976afb01c8cff6a3a8b3e7a433442507ae38592bfe1d4c8f62942d68d8c9a1f552003db54a9cc62707602cb4e9837e8433eb546c753ca85f57df3aeb6abde52ec6d2e0134a583429ea9a6d5f996f98affbf35f7ad20fddef3b3bfae80be747c573386e230564d8a9c3dad651dd7f681781357b9806f1720b3b3a5d87c5fb658bbed56afe35f121e59da742c0d72b3f1c942e57d5ced0a7f934f24f665d639de84caef3b8ee115273c7a2b9bf7fc8cef137b3389af9ad51260311f6eae40e93f7a2aedb8dafaec12536ef0c699d37b8fe6564bd20853a54174a63ee0b68f75ef8ea8bf4d26e8f72a23ccda94fef2e87890fe6ba03e885447cb1d3162f8831dacbd4efadc0b3f2a2eebb93f42c6218c21ec4c4ecd54695e6b9f46a8c89e2b4a704e0ffc2aea83737ae051cffa8a28ab0fc276d81199ce04e6eee07f1e787a09b103650de861126bcedbbc38d74b98b2a23a194b320f01491b53957a5ec81e457cf059a3e1e8dc65a93a96b46b72b95bc0a87f3cef4acee06a59e77e71b4f7d79a83ab0f64e902deab8a4cf43ac0b0eedce974a5c25feb679015e9a8e9bf52c982c9d2fd98c115b55e52ca65d24a893730727973d406ba1c1bdf62ae98e17ecb6874facbc5eecad4bc1af7052645736398720e001f4c87a51cb800df70e118abae3dca023dfe458313b296c73f4ceeb105330bcbf9c9865c49e785ed07e428153801808f4bed0dd0db5b6b4f4535e8df77237f36e8e557601d2d2ce2bc7f68ffef318d32ac7899a6e873641bb490cef898facc39905f2a4acb41118bba9ce45d035212f2066cc61806af8dba3b21d83541bbc80be115d98bdb244430527658400c1390a62044bf5e17e4c004810a005f20787151510613cba46d23c09cb2e6c626f8816c748a4a189eca45bae0b462b9f5d7bccc9d5be8565ec0b76ed0a60d182ffdb1994f701e53cff8a55d38c16cc36c355a8270740edbb6350512ad04a876fb5f8daabef30eb0e561119e28d5af160892eba2f8a7eac43a654b0b3699385bd2c5e620b9a3df91e2ffda51589765ff425c83a64f57827bf45920f913c4017a1181852c6b5da8aab7fc99f5c59b564555c1e17b8cf8c0885a63025cc2b4f30ba1fdad526f54c23cc2864f67a730ef1e240d746db30fdf02dced54171af5bcdb2744f8420a3dc4bb803d32a831724749beafa11804d8a4727a1504417bdb286eb1814cda5f4cbda302fd3d1f8e4ee68548e92140fc91e1cdfe9a0727b625be992c3ad0d5fc9ed5a91f2d22fe4132dea4aa43def1650c0b7a6a183ae3cd2da3a440dc68655d1f52a51f6909b26470e7d35dd8751257dfd1ad34b922a01b7a952b9c5683c90de34c1a7ba7f48581ad0b7d3ba9e1974dd8029df8d6032ced4d26d6634fec38c180ca08cf2842a7ade63672c713b28d79dffd9fcdd017e75799c0852e33c8bf75654ea99ce56148e93d438c979c1f29ffc09e9180a4daa020eee270856eab21a18fbf3876ab331d6f83cc78a80f85049bf370d1e3940842c5c870463e5e4c414fed2e1c53f2c3e45595d25e8ed31ec7c0dba26018c609ee31da9db64e2c2975e065087cf0c3b74c57abaa44176b0ba30abd3733a87eedf6bb8f95b207b5d26ea66585247b9fa145836914b143706db9fcaa0bdd73a78d7d719ade29a3d41081de7b00a6d0b42038ec6ad4e2a58a01b0642847e57ce64a30bf7f8cdb7058a86714a9b550e3004c8ae74ea3d6472288e62e46890942bfb9b4b613c610835099709fa21329aa09fa238e7cc5ca34f324304bbbd3b189ce23ea6e67f468e26f1ad1d2290b1e1b9ec56facf4874f3f23b4794a343ce96baf00f301807284dbb2dfcef1aeebf6007fb379bb2489aa124f50e7c7cdaf482f63436b49868e974350b13907c2dacaa102a52f886fbbeb0a147208cfec9c6fdb83d608d8beca6b8e186ccc126684f0dc25ef372b521b62c7647a607f5c92bf019a324bc9aa539777cc657534f07972e31711531e56f007e334fe540eaddabe1f73e58d024b97b19139f41c42f08601b128c5a375af4ddc7c531734fe70dd2dcc058e4aa1f73fa2b7776c0e711dfc0bf12efc2cb10a52a95c25dfaaaf47e64e45f6de9b88bb63e98c0c0f7b60f23930ab28a76048573142e1d658a3606dfdf3fc9ecaccf9eebb040d8a09d52bc459c093bb63c32f4d6257706811e2f6494ca1ad56ef2e6f6c546f990f987c7fd0f95e0ae67de7509ecb47a0f7597862b804155fba100ca19fc40ec72d0b1af83361cdc8888234e4877608dd418848e7d18f510360461cb677094a6cd40a57fe1bcad32640b50e6d88cfe5b9ec226d5d52f86baa4ce9e563283ea5ce1dbe0dbf94983fbc74d75464866441331487d061983ae268ad9983e609e6464bb7df308123585b143a548b30f5b09aa76cff5a431f90f1ab6d6be889609be8137c1160c729c3a1924acb2abed3503c2dddd2d7026b5390ae222a40807fb2862fef6b73844f5f6c7cee057d53c5d815146efdea15170bd4f8a3372e86a5370c9e352f6bfdd28a5948a24434bd52a8876f180d76b641bfa0948e58b6648d4cef0a0906933d9344544abfddf99ce9a0c697589b9391b7c5a1ff3f23c547730502778b92edc623e555a2e84a00af59a448714ae4610e4f4785d45609b4ac1e4a9e162c21618535ffe34017783b9322abdc1fa10a2ed58889e78726db64608b9a2862e21ad025c5183772c57d35ca2343e1b736ea957b4266c9749c494ef49f7ae336feaa3ad8d40c5d4ee57d36ec7498bd5a4561895fce2eb7ad33d726bfae7692f9039c4464f279de9cb76523974387d8a015e46adb2be77c4e7c5a94ba52e104c23850bb965304675132eb082379759a18e30f3f5bf0e60f0e5bb60f08ea13aecafe93fff3e533fbe121f81746ad967b29fa753dea447f17e828f65ce1de591d938e5ff3d53896dc61f31767e1bd84ae42d6ad293388a1aad33436252a0abfbbd8d4a447ca8fc4f6b708d22cd0e1c3413558b3ce3f8edbca84fc68a56cabfb68c15829bb6c829a9ddbd7c557ab1aeeec35ca19fba2acc80c1bc16a35c63be1c85bed28f792a28c4fd6f9523746967f7421f5a9257a337db937b06d7566d2cf3a890058dbdad18f369402c9919e9d07b2571c900fb2ea171bae8f6c280acc14d0ab4fd4294a4090c4e5a4b141bbf42d76d7ccb8d29e25072999a48237e49240012ae75ca51c073982a419d3f5a8a6da93a41f582f106c1240ef8054421153e9e8b8eb12cc2eccb7f71f87a9858d8186e38fd746e7dbd8a1710fd2b308b124c88d8e61a9f721171454242cf2c3217553e0c1852f83452a2072c084542c9bf4ac059fc78df1cef96319af9a4fa17c6acad4caf41d638097600cdfff1e27fb0d0219988fa2b0794b86c534b825af4737164fbe2018154dac15f9fcde6bf3e67c9ffe9cc06511b4619d6cdad1f057fd9d2793c71c39b1e142468a60b8d1934b7492cf348a46429ec2472acebb60dbc7f5eead5b5be378a5bc1166d948e0c6978f7f9f98909eb3b189574aaadfb957283e9f59994cd50b12b91eb76750017445cc99c402bce8adea9ef628f630b48f7db4eefe7dd77ac101aab208cf2108fd6bf5e7df5e88bc50993accbb75879a0134dcb1084058ad8ae8f9c6f1d8c1ff1d01a851b06a7d7a5a2a9df774cd5e95c9870fd97cd1feb2f365042fc58b31357298436d1fa8a2f20ced2d0b2ff081bb240763d452d39918f44c026d5c60dd1d9f0b7526f78d804e2ebd199058950dcde9ba80a877d70552463f0e9758c2a0adc913c87d5c53b6ebb37bca373fb50cca057f246c41ac76010b03d81eaebd54897e73599defa2dc3af07df41f8d381aa9bcbbabd7b67525a23ed793bf1ee618de2fac85d3a10edad0d9db7ec71ab26e87d48c040e37399f6d02d0de41e1783cb689ffa6db6c1633be7b59a26089d4e19e8908467dbdbd98112407a1d61f8ceed8ba1cb79b7e8e380c1d3dad5d5742cf730d392d9cdc2542e916b4ddcc7d49b500c64bc60920981cb03cc2557dae39dfb9dc2ea3236f046afd15fe20ba28a37aee5da94c0a4710cf58daae510e4c6d9073e401a8ce682808b0f4a3da668bd1436ad1df56c6d4b966ee6f56a88941d535b8e0e921308e477260afc3ede9eee81b5001dfbee922b4e3e16d53e569826fa15036ef104b518c4d7522580a3bb2d6fc71ec5d5af2c16b5c3efe5d5b29143b88066c97ae20c78b850032e50e173a6b265b18bb9c99d62985e2576a1b21b82046589cea29bba039016eaa3c33c7e16f7585193be5b88d375a83a016dd462de4605dd409d921dc5efb58f3f51709ff9c616c62ae7c27f00e13a1ccf074d6dbc105fb79c67584a85a8e584b7a178cf47a2c6495c0f66f3296065334d097dd0cad6d756ae27ab5439507cf9fca885fdcf6964957ae6f5a60ae99fba021f66326288747c7a478ff7117af08744ae52a6832032c5e4b77b7565a8bc95140ae55162b9242adabc217b26b34270c7546d8849495d2f8b083f4e97be62c0a996e8325178f5ce22514301d2a47ddd6ec1033e147b4e00e99336909c4d12075029d22c65877d7f9c55b0b43340a258b5760e3eac9713a12307c5c11e9d8e78d01bda679235bd35a2cd90c31fb096c65b21b5f6c2818aefc2eb9cd493d128ad2497aa1d13dc0b9231471c433a9fcc686db031a0c7024d3b6dd67800b59303acf440bda99345981642bd68a32748e469540ef31ff05ef092e1932c2ba7be325fe75200570f3a5e7c6eb2adb1bd0a750046b76699ddf502136632e62d18520ad18f353dc823670c5d69c5a0e503396366f136e0d95f1180514e31aecf175a43487e05c6526ff03fe8bfa7bba2ed1cc7e1a1e02e600e45d230684497644b243826b116d214b2683477a97c0eacf21b52e7735dd384f84d0b7ca5e6c9cda3ee5db9ecbbf043a78fa5b125a84f520b4886f63433d074af55e03c20c9f553abb4b06cd78f8908ba8947e45294d0c36d189ced4b5cb5584cbabd750631efebc96f99749947963f6699b5ed6528b76de793a6961a0734248042b6f054693994ae9f3bb918c5126c6c151c8084b32b26b333416f13ddae386b4f8fcf9f76951a116f1c1da1d99b0509c78c294711693e9e94f9fd2d9797928d49b8da4c7906bb0b1fe571f829ab4fc9d01b2d2076594a2f8be0fed0615d82333617dd12a3305202a6fd9379960b820434132d332ae5282c1a393cb6eec0d13dbeb8d5cb74325820681a798fa76e9904a94a5a3a72c5d44d9f1e971cf20dcfe91644e55c2b82501b1dedff45d38bc016a851ac58a084aba3cec46de58e7c27ba717cd2b4b747b514c9b68357f14ff8134f5c6bef79d6f84181381847babeca4e5e3434347961f9aba2675f75c51761b716825da0ec125be012d2ad14be747cae84eb388cd24d407551082c369c3a87f386d9f5d4da2c81620c32e864cf6797be791674071ffff3b2dda48ae8983394438815a8c829132baaddc28bfadf3cb06de84639dabf43cbf1825a22b676978a460794c29b43041d1895f2c6383757f89a2f7938b413dcabb23c768745636a075ce5cdd873c8871bf7aec85e8448cb85e4d15dae2f2f41f1b38d383c501a9459d5f6330cfcb145b2dbd21d2a8ea136dee008b43e57ef7d3c99f6d8406e98ea696a4865811b098dc302c387b1e8db32b6d7309b3fca3b6b5ac1b9fd85903a0b19a2623639631a4ce72f1497c0decd5a864185adee54117b1f2401479df24fccc9f46de52de9bcb0357947f7e9780503dfbe9a70580d043ab0d959ebcea058ce40c5a0f6fd18cac44e7a6786fa5cc59f74ddd5806d15965dc90a8d0ee56491ee687b8534f0a86aa1db836319349011eb6d7ee733cff38b8fb995e37d5396b9f8a941ec0f8547f6604894dea02b9ef6fc71d02341ec0edde4fd40a060a6eb663f3e84143de4cb08e62968db8b8428561c5166c557f8e7fa16d1fad92ab55d3fa575abf75499c987eb504fc4a9201431317f9e4f69998a4d6d2c4812713105d112be8dccaa036433381a9d671b5630c5fc5350f8bd9cfa4bb3ce786bd5b6a51a333abfbc7dbe9c697ed453b7992d2e6909e212801b8b86406215c2830ee4b0d78cee568ca3988ddf0f30190394204c6ee6b3d83ca1cec6ce5bf825922334a2d38812a52a680c6997cbce857dc2558ecc01bcc9d3261b76233ca63044f3b033a6b69f400ca9d984bef5524f430f706a04dc26b2d71ccf969fa72859b0902ee5f68f7a189fffcc074d758afbcfb6072b599ee63ea7c0bfe2b5e66a96044f3d9c422e30508282ab75eaf7dd6aad20e6545ce229959b5cc819b7f8b5863b17aaaaafac7b248218a19bda8b55c0af76a08827c21ec77bdb9d33887a1ebd8e1aa9059d402139c05e916c5f9f536710d25a735aebdfb3e7374c750adfae61f4e1fbaafdd7eff8dc82641cdfb36adae0a0ddc6bb28209ddbbab1c992cfea362b78b44a56b9fad861a2d5e5156c8580ecdfb73ac399ec70e55acf5a2aed5e8fd8695cae802825d6d052e3055e3b55b6323a3ebb36ebf6bec4e2619327901392eb1586d1200b0c5798e8069278b7dc8ac275abb38e33f40c79ae6cfdce367adac658ca3c603ea70bd0f30c2ef2ce6e05466039abfea4103dc245d2900bfe27b17900292a5354ee07dc0556b5a33309bcd4b8dba333032d4f30b476be402f1a19665efd4c4e5ad9b4b8e270cc44d2c8211009262a45b0f59fcd09de471ae7d072b673cde6ae0970b47c9ea3e32d9b033d0d36323c64cfdc92ccd700b8863803352d8387d99d577b717f9a323888a38cad308752a7eb3f2369c255f3b7af8694d23434329817376b0a2540db8bc41fb33f25009920bfc63d306313fff7fe7cc04ca01d00269c994e53dad1a147bc8d6f1c21d7d2d9767007ca9cebd25b1dc904d7f71fc981bda2902c532c5fd15c8ea2bda367b9148be09890c5ad344d90cbaeb012b419a2c929d528210dd706b65bb7bdbd436836360d3f99c4e7d2a2ee8099a9f7c79a590344649953942a6a1e0b90db6bfd94ba796eed315113494f87ed51c15430fed60b98f1a0f216f6f2ffe0883b564581faf66f16eabdadf06520bd3cffa9deb0f649de0d34f87754d48b59096cc329997177d68031b1d134877d3182eee1b7690eb51b1f6cfcadaf67a6966ca8cf0b8d40d10b0cdb6683753e53a6eaf10bec1c30b058030c2ea6f6cf56a76679b0bbed0cca5997f93ea84aa970432749a942351996d526c54e1c333ae0f91cf3452a135801a3a593b37d94ad5a015967c3a736e1a834f402c46099ed87b5b343e7ee26b454a432ccb85042b091b70a501cb5b656c3e944ae703e834177c7500127e3d794b6f67fa3f6142b3e4737a5d698281b5a260db0e3f3deaacb04a0d3bf65f91ed8dbbe67ccc24c963afc57a132bf110c62e8794972386b4381b98b28277cfc3d28ab8a05a41792ededf1ebb7b0b964c196882cd872874dd9e6cf9453b3c8035e505498965444fc01100069d1ef00217ae01ed040815481aa94637055d239b4e75f6743d21ee8a238d13e594e39cf85307d7a97e24af19e58e2cb1fd17d2a893e56e24fd4e55c2fa10ffcd36cc8fbe6d8d207693c75676054a6c75754039e7539abb2b719cb071518baf715b249f496c151c1e4fbae4781d053f7d5805c892ccbca9e8d53319bf173aec9ff3e9bb218de2345ca2b13536f207d559506f54031da92b4283bc38a951a27c2194a4178a4e09534f069b866c7abd4a3f5a37ceb98ac47866386dcd3f45d1e7982c53b6d4da5f984d00a52d7fe8ef63e0b8f35d27b2da233e16b4ef078ad6e284380a040026523c2f1731b4ada4c19cdf1b385a31a85bf5f67bc2b1a8a11b23069ab5edfdcdf7864b625e1b27a6f9b1529cf0dcf26e51ce8a6f5033cc4b800ed108047335878a25af74f12e65ad87b8f5f9828014a5f4686e36e6daedfd68450331bf72831706fd75f4e9f345b42f16995e7c171c95f6e5d7a134a80ff04723827ab2a75e84622ccfd9a0593cc3c19a06196b0db95175c1cd0aebeec97865de1f29436f1a06ba1f9e7019f1abdc42f1133620b411a4228da2c6da509c036d720ae377c78c261e112205ac322c12a7dbc1881dde16e7ad273f7ddda5a7930e6f24a88916de9274711827bf5f4b5a074b6560f9b52e13dbb3b3e34e4680d858990be955fcc2667a4b79d1a74b88be17699828510d083df73c781cfa6269633df2674038aa29b0bfe12a20428cb607647555671340a2f3125b4c6c98a357a9d83bb3b8f1ece758bf871992fc32c59e73fef99d0fc296d5144fd0ecfa81d069a732f476272e7585d80f7d077053a681d3264e19657c8493a9a2cc376624baad9fc888f6eaa43558b03ec578c611c4b764cbe5f1a978057964376feb5e98ca7f6efebe0542b016c47d5f89f53d0d147313edaf13d4d8a73a5531222f24e2be70f05505b3df4e56cb56b85c6524ce815f0fb9814bac4dea0357813ffdb189223d80e35152a8cece71e9cda06e5b826e1db28af2c19a4c0a7fba67a086473c85bc48483d52d5e8412aa442688ef8f352bafdf0d222a9be5eff2a55d542d937ae8017a629ea9f2bfcbfac413d27bf8cfbfa9c3a75696c93c0e30f0cb5bb837d8770ec2f3e3d5400352d5740f9a6727852d40c7715b98520a4cf5e85fd88c007ca5a6da735c8cfb72e98ddf16bb4ffbef704bf4dc9f2a126ca1fe3b5f994c26820679812ed4b363ce2c7ed03031ba57e5d939a799a4beff81d3a5e6301ce3334d4f8384ec2b343ca8f567e55a9d6f238d787572f08c3955b76d6fa4385c595e5316997f6be26942bff3cb7f4207d7d37384622d7f582aaf34fab7ef153bf1eafae78af952ef8a1e1315d7f0e5e34b7fb264b12b37bd02ae2014a7d356eb167723968da1d865102ec6de77a927c175bce643d3637e6158b0129edf966896072d06a948001737a7bb67d78d50cfe320d3464fbe98f93d5a303d740ca60ddd00df1fb917db3b072a076d8a76d9d71b6f4e7e80b891ffee40cf3575c33acb1cef071c0c6572582666a58c3b75c308556af124cad6427e8189679bd815d7d2ffcf88f907e68154096d2f824205b1e641834ef980205b831292b347326bb7a340937b9d078256f388b9b9c9d8bbcf2328d477f3cdf25e579dff4c617a9bf28cc7c7509cdb2f9c571d1112f03c61bfeb577b20c8efdfd9161a243da0019acf7ef3742e8c8f09ae6cfd5cf9a1d8b7617d2a138923a60341c8ee4360063513049155c8e8331ee14a62e13436274e66e0f1b4cfb03014abbc5a1f09f1265966974e4a576937e1308f77c96364dc02ee602e7a4693380836ee3ad23a5b4a89ff6b59947cd68a83baeeaa562bcbe7f56fe4e5a896a920e5f7f26ead3a608d1ddb6e6de7c6ea2d911be5d7a9a153151b0224b4aeb6fae023cf47007a69e38be03a51a3be30bf8f3e028cccde0c1333a93d6a0e769408c7b3a772bc90cab9850f34d19c99568a1ff9d8d049ec4d104216dd64b92d72379ed4a4cf8d4243cb28ef52d58172f513b6a764cbbdadb3711e43015221b1fe74970a886d9d6640859788f75d414667ad01e49283c8fbe254761b91e87207fb365ef2518ea58f8e9116c5f80355caf23bfa8980ae4244cc59448120af9609cdb8901d09327233920dab29ef64fa27b06b7651e300faaeb7dea4b1fbfe689a1e169213e96f64f76dfa30bad37d8086a4aa85458235df7f30cc8c971c7c12c06ae5e1003ae8679ca3e9cb62f3da98d88c154f35b5eef3385b7df1601ce3a0dff88708f4897428ad2c5ab2c851c258e36e0dfa663ac071615cc6e62097c262151903884042ad9ae680768075535cb94bafae6f5e1f0859ebae1ea18008a81fd288ad25056c2df9afd5b34935ba32870d4332711a1e36dff4c7ef16220914162a99f15bbf62e520f0be144c3fd988aa0818ebe117548e9530729d2997201f0786e5443347fa03b12f466e31a6dc7fc5e3c35dcb4072a81fb600a860f9c288aaa1126a9170e4eef61b70e28a6e1351a3acd6715856c56affd201974b1c00ed82aa540bf0f879233bc4685cbc9484ae1d1aba293d19ffa9016f898a6a761fdc5084be27a8dccd3107d39de3da97f68c843b0f8e495c44c85b4f29d1a84906d3c14a12504da3e6164ea3ffe0993c6228f3813d04d37f9b0fdf154df363c731edcf8ca64842b90ea976f37c4655c32dbd06e7a3d0de5f10242293d7094d57fb24883e099ea4d8b64c8b50ed59931e36c4feaed9b3c796df88f96a032044453f64c45ac71e60796b9da4f54e39a44f2d7f65a07a10749e08fbc0b6f1b6759f9f1d8d53d62e0fe51c1ea64df954b1f25bfc48e3c4dde47271366d5ed1582d5ec98737d896fb014f83b5aaf668cea02d9141aa008c10ff3076176c856deef215088232b240c63c10bb091350ba32059a4c28671fdd8e55d853e54072fa8ad349a29bd16e86423e97e4c256277116958445293b1e0020d29c8ab4ffb6c7d15a090fe5fb7405248ca63bbb1eefb442a11490779635795ba3f0e3746eb2c696eff931dc1a369cd1cee6a432c65800ec8a7715dfa2f73ec4df765d3fafc3c7e7ccf2cab229fd92b155ae41df9d9094f337e9fcdbeaa463d4ef3ac85e282ef6af2c2b8f892d10bca7082d5f93567315c670491a33e955ecc65718aaa1ffd008c73d5226730b4c915dc7c8f27280797c32f147a322bb4c25bf6654206a382b9c1bf188829f453b74c3a11892c629b7e39eb8515540f433e27a753bde5de513e8f6905c708dc26098632ef9063f50e9c41a9caf99ce6e6dfc035a4252b20ebfacd80a3cf3dfea881298bdadba6dd9078a63fdc2166447113998cfd4c2a0838d741711f5a0910b3dec283bba5702db940700dee4c5172e0e107e54dda644cca837e4a7fd39eb31b7aa7adf70148a52457d68c1b07eae6bc3cec16a948c63f842de1ce7efbd22283799f63ad7f291594881377f7716d0117aa7316dc7e6f937a9bfe3c03fe458098a928c8961e6de030cf931f6cdb8c799b8513f410a0beeaa899561ff09ff2a36944503a9e0115a53224476d3324657856597eeb50c558d1adb7fb83e3de218cc4cc953a6377de128c29a3fbe6357832d700363a62fac1942fb5cd0c5b13029e7772bb5b87a9fb50f4ec897b396c22ac43be82af8a1779037a67f1394154e9c799c666e68463fbe549199cf709ddd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
