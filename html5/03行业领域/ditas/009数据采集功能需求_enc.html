<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16d0000d53e4b4769a582ede9ee9aa664c5294fa8628b13c8eb2f44e9013dd0116409649b53d33cdaedd6205da19dd2bae5d8aa3904a3dc17cc64bae3df46718fd10281cf9384690a22a8d5a3e35083a53d0f044c1659766ad5b0f55f53060593c4348bb0d884b4404e49ce5acef0b11e56022b3499c98d8ff14c49564ae11ad54cd6d57ed489c4d752d24c04baba29f12cefc9234f9acf2aa19bc6595d4d386fd94d776af4c29f9a201fbb15e5be9101eb95d8841c907fc123d5f0e13969f1482a3380a15f95d94ff3c404f67df17adea8eef7572854190f0df753998e0596e0649dca7774923664c86f252676df925d46498ccbc7e9d8f9291c25e3067982f86555614bfcebd3d43985de34fe8a187c9557744f1303147cf7e96a8c5f5f33c8e19a7a70772de897ff61d5ca2b81d4f00b4dbe506f9f6021125ec8dd4c22555fe60efa674ccab319c0bede4503c05eec9fb3a19a95e5c2ecf6db53173b3370ab407b0c8100cc2fe0b7d51c9301c3e18b1ebaece33990d6a75b8b23b1524996630868190f0703b6623ade924d79e3f976a288f37ca4b4f1e1d8d5b97a7bab9c968c23dd5c0994d628f1e4ce31eb08414d629d550e8c1e1f14a6eb51725da2322a8194c63ada335bb8730998b01ec5107191fc2c687fc1d1330ea9ef8f22cf07caeb66ee10409dd98f4a6432dbed304ceb5b64faa3f1bd0fc62866cb9775eda4f2f4f6043f19593f881a3dc2b4d69e3aa5fa20c11c130daf8c570ffa124b63b44f8512fa88fd3f6141eb9238213d6706ddb0e576b54946117ef0303bb91580de29e797f0f319da8d6f826c750f6c39df52f8e4c8065afc916123615e3c4ddd45ad8402b41e349d0c1278f15995979faeb2a48b2f412af66f4c737fedcdb99306eba1a4ef1c59821d9bf5f274d49ac43c1139f6d51467a477e5dfb07330dcb3aaf564119dbae7329387d8390bfff94fe3a2615f80c41d304f765c81545f19ba137e0d5230f2111154f5cd5081ca11a468d16dc9e6a25403f90dfc2cd03b470831b86ee4e61613a838ebe37f7f90d324f4d7a86709bc305812f8ee429c8d1eea17d60faeee2b95127a5309ad510124d71399569d14e1ffb9f1efb1d88637653cd14482e7fe30fc6671cdfcf4d7972e8fdcc9d23d02f83c9c042d93b408b386be028247f9ecff21eda3ae921fdd74c411ae2ca5d9811d26719dff7c41bce1aaa40654a58a8a25aa8ccddcde95c63cf2684c45a1cd81c63501265eda6aac88d121a61025daa6ba99dd0644f23a184175354403212326438a7d7b8768f79c183888b3d868b12bd8ef57c10608af36a5a317a69cadf2e3687a826eaac02e73593c810b969e6ef3660843d017863621781d8fe3ec2867034c5de799006c7f00e6d1bf2e6cfd34681df0ed855b0005d924780d60f31e42a623c35e35547463206fa5a61dea9304d66b1843607a4fa869dde3417650bb7466dd66aa22ec237fd2cbe3e17847d4440a4178b22fe182dff0b2e14a681cb475a3eab12c355cb13561dba477cdb996754fe39c74055a934b550d06689819a3dec16828dd11beb1e269b471cf741cbe52003c0a89695f26a66298c38de3aa03ca6f8efd335ba681bd1c560263dda6dbbcd1dce5b42aabadf12a87f02fa6f0a4ea92a5ce7f2dab6acef8a57e92a1e2c28df5081764d475263b0d1b8f42aaddc82b63240fd83e4dbc14a9d9bc0c539ecf89bb35dbca51fc0d79edc6bb2d0a24f73f945e4a65007b02eab862c9b14c136138d73c6a322dbcd5c483ea411b242400222b72f817b61ff13b4c24af62c9adf95d08fce2853064de67caf46dc9556cda66042572da6386b7761af1edc734ac2109ca12102effc66cf2ae24bdd4169c6df078c950d8bfcee6390b7364925fb648a38207e88abe7cb24a00265310441d7206fc8017f88ddc26b20744bfe23a6664fe4d30980bf72997bfe95ddcfb364fdf23966b95b1561e5bb55b32cbe3dabadb715357e99ed0b29c544027d1de8888013e979451001299e50c14af083ad971a9a0fafd2bee27bbbaecee9b22ef7015c238c29d087ef34413dada367d6096d2357ca3159bd50550d527814ddb4fb43037c5afaad8930e95dd1af1d88788bbb07662142e3df3f8b97f87c0e358b151412cad089b89ac246b9cf536ac7880eebc97bf3df5ea3a6b1f608914ee6570c3563e13ac5e407aed059a4a80cce808bcbed5e9ada623ffce7174e56f56afc402080bea644d28c9ed3b8a2b5d65b4d2b4ea577704d42a1fafaa354fb93a4a54c532d526c941170d6fbc738352e721355594ecf893e9c2e4e6d992f98cc4633c62f34a923e5a9a8f8ab2b6e667aa5c17de92c7c995f616691d25a84bc1696d3468e96f243448415136f2b4699816dd3062ab24c1e0e1ded4ad544b1f4c5ff3b773715adec1942229ce5a6968aa5022ccbf1f40d3fc450d7f3bafc64335dfaa0dae728fdc9cbb9c265b2b98908f2ab137413746f0ac5cd646578b8e63dbdef075cb75873d55f7e3d1440551e950eedef4e7c3c972d1a3d5b16e9c1dd5298c7167af3f7d62511c0c84804303c78ae26746046b13411787b883ebf25e07f8cb5d2a6bb2af9470a46ee96a70865b65d34a5de0ad758bcca7161581d4b2cb031bdd5a6818595e0b4fa3db2cf657f4dd77471ef780858e9314ef173ed6002832aa5653f9e5c240094e1717d00126e470902a950561012d4a7fe3875687e692e822f62a25ec3ed0578e4e13dcbe75a67fe8f9459ab27c9d5d03fe18e13c813ddce8a0a31e006a522c5465ffec3554c0ef57c417917d82e8f6103c4a18f6e81be07dce3a74f442949cfd6754d5a22605af869986cfbf1491bde0fb2ac27eabf8d76b05e77c070bba462a1229e87ce740dbea348f70535319457515204db23545cf8aa063d8a2aa0fe67d27f59280cd75356f0890d99cf02498317ae679df1cde02ca44b4c8a4eb46d9889a539fd0c98150637ea14451b4f66c14fe80c51404a4f0a2847acfd585c1ef9cb09fd92166c5b2ad19fbab2445a06ca518da399aeda8a11e287f9f554da7c2a8a6ac1e9acc6b7deffbac240969ec4ab4391b36e13dcf1b70a7880fa5775a6e45085bc4b80b6d0a8ff9de78c3c9411386ff09f716cdc22434658262778b743925a0e6a19a514ad031815f0919f62c53949e72a5ef28060b8d8c872c00d6dc191bb2c151efbc303e2b26b464f8dced9341e227f120638c25ccd7946f56a1f02568e44775afb97b04ab7a1154e64f3cc16dcca0893d2317c294dd2c65906b8e30bc1a2370dc1d52383bccf6680c3e8af0e97008e2e85a4749da2c5f77218b270e4726dff0cb830078abf58da3aebfc476af0f39f3e67e5b3c1eaa2c559af68e6c0133461a59e77b127c71923db6c47af24adcc42857b21f70a41f65d874818d7d3e93d59d1ca4f1b83d4ab6f9d1db28c64722b2b9c2688f2b72a1b0ba903325a00b3e5108831393d66dce63acb3c589462cf216e0b4022fd5aaab577c2275686d2e5532426d5e6c63c845f4330f7efa164fa6bb1866bc9e6260e887860d13e1c93c84ef40a92ca0beb858ed48ee4ad574358fa5a1b67a52e8245d53198dadd9c3ab94a506a33b85d869f5426ebc64dba8a640ece5e1e7a821ca3bc66fa7213a838fb242e2808a9d6fc5c855b3c96d5588f82f5c616042681003143ddf3b515eedcada27c8566c85279dbfc6ab388fc68f7a33fb7de8abd1cac26f360d06f8a1e83639cba57c9cdf306f224b990f0a37eb8d8c4e060d74762d3ade5980e6ad77e1444c825a3829f6fd6ce90cd751f334c7a1af7a6be0bc7c210e73025efeeec823a5576106146e4c7313f9c95481548073ea9f90b1a46e052b55c06d2b0fa77ec84c2e771d1414f49e6e9f1feb8763bac3b459999449ec4a947c890c6a522a518674602a02d412231387ddc5773474af6d7c2b582f516d169f07c39761c23ccbc8560367991bbbfa55c55d275bd591c3831872d92be3cd4748f7b0f00c4dd128e581dc5581fe9761310d500b72e852ce18b0f895e5392410fd06215d04d3adb3943a745fd83ba9cce78e5115cdff99d98f8d2ce0c6b1af50822675daa4ddfa62465fa678883fcc86a71456aa6f1ddf198fbfa9981a2fa74984573068c80b45fb4c9c61219453eafdf94f10895da62683f6a4e88e3330236e4bc354fad3c5f905001766d3a094ba4251ea9ea42a946c64e294469188bfd3d012be6c08b586cf1bc8181db7e3439fdd85dd571d87cca57251695e9a843997c6b6b183650366e677badae28407577f67e19321761890023b5b6d0c5eb06825c4d0a4af1de1c293f2b8c7dcf2ef0a8b9641d47c3285788dded80fc4d79fd2d5a059be086afcced7ca39b5a24cb60ffb0ae6c25b8818307d06decec0d02ea1983dfe5a01eb4623f32ff76f4409b302c026e1442898a7b3675582053c1fcac14433f6f4e270e70fd0f5655e55f6eb458676a8f9146e18f5a388b34a96e374183b6e2b09d514819206eb9acdd8abfb22e1c0e370d30155f8a8cfcf94b2876c43e50463dadad64edbc380e4af91abb59143902cf7dc347b33956f8d630dbc4144bdc490b1bfaf10ca3b6c12256c21feec557b1bf92632c34b6079cc8d3f806e9564acf8181b400114431443e482c6129f46e9554d8f24b3aa9cfab96a64f29a2580985ef7bd89926f0f42ad0cb3ddc302dd0c120d69e970fafbb1ace846fe5e864492ff6d8cc134d1744b4e7c703b3aa918254f0693c79ebc332e8b377c58119cf17d18145681922dde86ae9674dd81a2f9e6de76cf8fe8eb605d52c9c0a85b6785d80eafbc827d45a95a839dcbf9de11ab40b024d170aafb0abee12f593c9a6c3d0805707c7535ab51b1d66557103a04a463fc61755ef7dfe37b9f42304acf69a2e72dcc043428df5864236023e971b217fe535e6c5a19932a11f8c621e6bc0207d3a32233b152a09eb88d5a83e534244d22728535837e7ba81d79b0970db82dbeb0f82b2f4efd9b95fe4ede2421c6a1e636510ade5dde49679ea9c46bc07759025a3bbb6fdba763e65409f5bc1cc9fcd2d5b60f81c788f6292b20fb836d19e6a03cff92f8c786a5d6457b01e1ab9ff64d1fdf2a654dc1dfe57dd7e52428fc0c4bcf5df711a2a61200e1d9881e5b96797cad3477b6b04b3b53718871a8112ec6562bce5d803aaad872820b607c0b9552a68ba7eb699bd17acebbe811fb149b13b8a22eb5485a298cc526ac967325de05e4dbf6381e68f1c52d01095c3938e7bbaa10d4b2da7ff6543e0958aa483ac46dd27ae59d9baf6e06d1ad9097487aa5e5114749e886bd2eebaa536188526b0a3ae3f3b88012cc205a0c16d46e2d30ba42d724da5a2f1471b1af13483d3deb7d7f5c65fbf6f8a162721d53b6fa8f76233b4cf4a9ab2d379914ec3fe854f0a6d371ebd6cd23ba5bb1d2436f9343628e08d6df36c44b06f062576a758e11a9c158e8b07295071121694416e2968d084e41ac47a1522dfdb2bfea82173cde84194a5b5682caa113cbb9cef96a6475cabaca8ff35c1983cdfb7a43f2cd1ae6f1dbdc9709ac073f53d489a0952a58a506a824baf28ec4d6bc15d67a50b394264391e64658c0b1ea9bad0ef0ff32493b2537c25d53ab75019be3bfaec7b40d3ea1f4196e10ccc7b16bc2385e4e9e0c5429838752d5f81166c4dc6a9a3cc5eac9ed200c92e99a0867e28ff0de920fd3d3e95673f7a6d79662c0bfee35beca72b57047c8dd57370bcae1635248c13b8566c3ae958309df8cf22a8409d15d327026bbfc7009009228fc39cbe5a307e5cd67b7618c3bba3a94130f9a6cef6d2522448132511ea430c858445fe828c4b46cbf602ba9a73d8d7a8e3bc85c6e142b2ad372057f94bde4a7fc349ca5c372c862c7dc484ab43af0862b3b16cceed8bce2b20db3162fb35d23ed90f82176ff3e4e03057ec445df882994cb32c8e43b4d2a327e463a3b26dfbf157ac7e5563dab78698df7d40ba6738492b654ee933fbc5ad77cf1b34a3e92b04b3d634e3d1912d116bd8b3d5fa62e3daedfeb3c5ebfb627f885b4d91eb97ea7c67cf15aaa7eb58a704a05fbf5128df11771a17041072284fa5f120d8fef27c7bee8d3c97af69a93ed7265509f0a4ebf018648388944a0a227c90467af3db30e3e63496499d669786a8da926578c340f5694a763c6f3f62f128ca92044e8a9b7d5db70f83090ad4a9e7be7dbbd75428fc3c71a77e0facbd79abb0866d5c5c8430425fe0e79e947ca7368d895c141f1cc161b2f534f7102d76832b72851c984541710311e492e3a9413be5f7a89f9110f7711d2ebd253d25ed8ad087f2d14bb2f12a7641e42b3952da46dd8958ccc64fc256337a2c810d5f8e59ab4e572d622a8bb7c555ddb956907da8092d92cc94502ab2b9144da8afb0b790464216979c12326d3a518d10148be3981212ffcc72b7d10cdb802479ff4b06d7c0e971f80d3a639e4fc528628f6e17fdef92a01cdab73797fa9a7b2dc8238d99de4231a2aeb421ec1be4b0e9620e86e6ee50083e6c7c6b43e78b78fc059941dd78b4b5829863d320157e4484c18bb3e8b769fb73c53eba45803372f996db07f1bbff9dc14820b9fb01adda1445aa72a0a820714528b07499aeca08d59ac894c6a08c387d673d0ded7cb1a3c92913cb0f63f06017422772b9c3234729374faa7ee41a577827cd0834dd8e6704141f8306f5afe6848114d0d6145365755ac405799ec498ee99ba4a60eb671240fe870ec044b87ff17fcccea3dc20479f6a600d5073118a9591e298d79389ac40f021ba746ce70828cd005125e096e181eba36a54010c47d3a93ebda901e4f1219e5f58e7f6c1203c9b49d19d25e99075a939dfecf9a264f19c4c1c2370d3633e109c4a53631eefe063d3035d8a863baa2897141a3562378189842e9ae4f6f6ad5a8fe830a2c5f8a286086c32a641522e475db2c9603945b0c61da9bc10e72cb10c36422d36e47bf15f7f87fe649f3c5aa7455cb2562f6734a50fa3e838faf2fd72e58e423484a5eefe7cf2a360da16b56a02090f4cfbaf5d15cee592edbdbe00e5e0716951dfbb6cd3d9667964254672bec22738d8ca1a3fd7304fcdf564c488d2b3ead1cad71feea700d48d694bbe4da518fb0f539c0309fbe8ddffc01cff80a8fd98174b0ac037c861cafef4c725ce95565695233c3c117549414fa260eb5b2c5f86a3b3898fd43ba5b3d122bf0bf14ee8e48d2bfb801e5c10258fbea0f9d506f43cafc2cba18b9e0864a62ad32984d47ffa7b3a4c32e54935141f5bd2ee838ad392ac87b5a03323ccdec4bd9f2ce0f4d88b09c536f46a78ff1417850722302ccb84c40ba8b1df19fcd979b4500b3b865fbb87f3507a8f0f74ec7d5cdeeb108ac11b442bd6b8408c8de1ebf48e89fe63efda6d3ef6bb9f29a68e9ffd306972e63f85ccf0c473deb5d0014dc943ff33ddae3089442dda9ce6d461df8161c4f7073f7fc14e8fbff71c02c27a2223f9b3b3ed6c4bf94ae45e6d80df5082c300aa10f5f35e2d09555dbc82e09827c3c9e261be3e60ffd701ee7e5ea0af8e7f81b0fab7f219057fa1b7ceaa2897cefb1903a9d4b38d8afe7da9046c225e51632383bd5061ebec4647a5832592eaca3030b5b65875c3cdb7b2c459c5d4895efc94c11b34bd307c1c3f147613f3244f5c8f6d5032393f8a163c6357a5cda831a3e199da8cc6b497daa9730ffb54a23e4d2271b2fced5b63be1596ee8f8bd00864e8b7d759da7ad9d9d18ff57c40445982141e846936f61526217a04309ef4799ec46a763938ef77c85d53cbfdefd38f6919ac75c824299a0e9eabaaf23082bb8cd32eaadfedb7fc539ae46ee0b80852ffcaa6e2057e0db208c6bfe637ad45997336dfbd6fd055fa638b8904b3db98fbee7e722f255bd1be3bd9d3aa6fa3ad4fd67b92e2c095c42cd6c32c896aa818c96acc4d678e9eeb3aeb2296ca1ac14f485eac7d011244c66a604cdfdee87c95b63dfd66aa599936a46e04c83e886a6d6b0014c59667a1131ef411ca3bee7f617bb80fd6357356438f5faad0aacdcebe4c44e6bacb9158a0cb853db233d6201f151e0998fa80c75d2a9ba23a04bcb763c6930522d153eb2d8ec7a7e6df67a59a4055e717042b4fb67b2726c3ce13171ea8b5994ad1644c23853f16854ef05e3eefe3166cf19e038e1c7f720ddcedd809444bf9f38de65d8c946ea9063e87334f6d5f39153f86d7a0ddd0a3a9da18b1234757f3daa59aa3c55dc15c7c6e86b25d7e347fa02290265ff99fe6a955b83e3f03b070be2c76179c75463ca22ba707d883b2eb9a65d881e3bc5e450d565ad86f8768b6f23fe2c60b15fb36cfb962d5cb576d629bbfdb6835665611509cbd475e60f421c2b9437ab642c43591544331bf2dac3e9a6be22fb5762f639c9a070a08ef36a0b0e77ea35c3a293f92d07bf5163dab8cc37f93c58b751e91497e091410167324384fe328f1abc7764b12f8cd0d72daeac88fa1f81d9595fc970386e256e3c292e5129d085f6c971e4abf4760abad68d1967b07169823f5da01bdda2e89843597fa6c0439bbf777c12cebd421642bc2d53ae95120c2b9918b5a611d928ae90e1566768df260f6c78197e895885fb9c14742ee79598754a4b2d3bd4edfa8967aefe5743eab6c4d814e0041eddfe084f704796ab8c7021f33417296b9525c87a0cc5bf478745e72352eaa7908279c52436e7aca16e7cdd08fafd552f0a989da014a7196b264c5b6ed12e2a37f60809aa7e6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
