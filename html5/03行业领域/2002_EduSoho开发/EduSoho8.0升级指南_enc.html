<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5f3168c6dd49e1e4e8b1603e80bad4062b38283ec139adb185e7a4d07fc693abc7a9dd4e99b9c602b0c40460f254b90787125e0351653bff67e6ca6a6057758a8abd16ff59be054c750e630a5692219120af71462876b89adb35d8ceee3b748f9cb6fe22c1609e5bd5888da783b5c7633c42d34b585e72c3327cc7ac260b150bf7dcf38f3a89cd1c1bb0d545a40d631748b2b71a40850eef11b0b07da68ce882b88ca0683b00def3a98f228dee5c1f47ff3844f70bb1a9fa94e3cdebae0ad4fc4822e11796730b39e102888c1a8a585f47f34a233b4ab42e3ecb756e33fae9576ef97c6bb2d6e30c0d7f2d5c2b3f1a6039993a63962d0741ce6c48aaac209729b330faff596770218398ad67912232a6d68feb4c6595ea4d6005fb373a59064d2ea29330692dbf728f3714cbabe98a8362666caebb8f6514478dbc536d389931f24597bc3b2d916471c6ac9c0b9c88b13436e2558544c5f2c75d0608a17cf23c19d3d429607aa91bd21d16b9ffb5b0bcd0184834f5b844db3be3045bfb7797f6493c1704c01abada410e01110cd3638ebb07ecbeec0909d09dd3e8ea3d18c570416b74b0ca0a077c33a7bdadd51162fb51c5337358452aa134ae8e694af917e2b7bf88435b9258d2d3dd18aa8fa73c216f78b7692ea59f5aec4f1786056fff8b5589876b22085dfdadabc834148132bb150af0136a2f2759638d195db5235ffe504130ce800d18cc399d0f93be277bf3ff950b5cf77616d733837c704d887ca415c927983deea36102ec5e1c88fec3a0f662c81a4476614eac24da0b64805af9a735596984f6dd53293f767f7040ad9882c6e78dc7e4bcdb6a07bc72e722d3d3c048756321ebca7b3555cea214d7b8b730cd6db28f0e873f7a1454e3939387ed14327caf3ea7029b926be93fa60f773ab83ad2742d43c3ae74f7f0d68cf7775599a7f3f068c6446aa35b9815fe91478e946476888670f604ba357d2bef08c7cdc394f6c2f725615fe9ae70b53dd35fa012a12de01fc4ffefde800c5173fe3d2e155340db273c39614db950cbde2c87541d5a3ab4ae93ff1c2d372f1f5d50451943533b7bc7671448e65e920ab3bdc21eb261e9212355392f7720ed5b98a607172b948d5c3742f16bc2acf20408bdafa576bb8cb2df07bad4e04b55114ffd4fb09b3b94fd445f54361352bf6601510d2e25d602ba0371913bfb7de5260e3eafd29ae07c17015b890f3eccac4f91a780df38a86c3274d6997728a8b671eb79ed23376d9b1108be6d24019fe76b9c49cdb34956427aabcebcd01f31ad1c3d52d28fdb4a9a5b96ea30f033e4f5aa4721ddf62cca1a5238236ab2cc9ec828d6518a9d33d0b6d487841a7a7d96dc685e42b8407188264ccae06641aad67f342c32e35386b2786b984dad6ed43e45be00258338dbf64bb5502ea676a3ab7f476fa0c8bb4c9e2c8a6f1804ae9d3467ca9169a8f161568be2cc88ee53576ce309821d263bfc8f41e1643ba44cceb66c2ab747128ceac9d7c1b41bb3fdfb1c7a786991c9c25ac6c3d2b6c5cdda69e788e941ea57af4213f5b6883ec2e16487b93fe7dce06e788380d827588bb0b540263b5a182408f6ed4adc61234e03e4e44cd9bd2b19acfd901528021df1299509c794479eb41f435d89374ea4492611fbc3989dfeb12f6d09d1867354b8f4cbf687c4aab11ffd01f8d5b709ee3c4c1a2b8e54a9a1143e2fc4ab90b9d7aa43ac89fb6661a88329ab82b08415318dd4cc345e6f9edde40b49ed57f70c694f03bab10dfa42afff3900806b79afbd777927bb0ecd6ad12bcff7a3901ea90faa9c8af74a1c527861b3411cb40f42ee24851f37945bdc92a1ceffe97657d0f139a8e696ef8097bfcfa16ae65db4db55b2355df99e7fff4d9cc3cbf4a23449a6b7fc9fb64d5a48abf1dee080e46e4587a950d33359f549ea62fae1a39af39133604bec79e2b7d70d9497a684d0d2e5502772ed18e4520ab305fb56674771d3e060d18eb19b0717400289947d751a25580c0e4a761cc23dd40e54552a509add775c5b40845bd213ff827849274a63823bbe5a4eb1f3a4f75e1134c51c1589af0074cae1bca7eb10ebcee3317f493ef3a055dd119251f47d2cab4e62b412e35c8b436467398dfe0232250d8f819d111d203e268388680819984a404f245ad190da0990a024875ef5ade9de695a9eedec87948fb49897d879ab3beb6b6dc0bdc127636a3ad08c155c02f3c14a972e14cf6f785a85fab73180cd5f0630345fa6d5c6e63107c162fca7363cf0c813bd06f7672398408dfff8c5ed5e8a663cd6dd1f1abe25a8a16e8c8cab3c56b2e15bca1ff305b7dab089d9b4469a1d261c291cb5f3f12678c60d596136dc4082ce8d1ce9dad456b3390f936fa021771dd63cf0f6389e13841ee6d98848596c4e82146433c48507e93c1c4b5c803ed865a891b70532f627876fa3df991dc794a45aae8451fd5f4127628825ae4de3b373f8cece547f3941e01943b62f351d59a0b953f47cd9cc9df211f5f7aae9a0985d83a5b521d2d8e59a4fb7a390b21378bed215e44360b3e34f13b67e6bea66694b149df11f0fd70d82a3c787c0030d63f39b94f4c3ed084e75a77475a270f0ca94cf1363a0914340a8ca9b8d2fb500b069ab858e97b71302424a9e7c0e5314c4325f2a4a3bb64af3db72f53a1acbcef7d870898c20348b5505eb6fa0bb3c66cf57dfcf9bd507d59e10f7e6380179ac8e81915843b4e5f9cdca66d91a19c9f81da1168fce8ded7963845cae69f7c730515bf8055ca9d6ee63717427ba49eeee7413f2de64c20476d4c6f08a2a1f9b84472645ce2132f78f1f0604d24ef2bcbba3e397807244cd784f3e983202536a915d4858334356655c10b76cebfa2601d184c7b9d67a40f38eacdc8bc778ae5288c460597ef5a84c153553d3b622f37afe79e1d36045ca07f43067efcdb537c26125fdda26c32b2cf65094c99f5073f317631fa84c7323ac06baa4838e5ea9402d0ad218ae690edd4f1a6d2647b04bb62039b51f44f72acf2b28fe4195b8ed9a84ceae18c7dbdf96dbc11ffdbacbc1a8fdf87d1f391fe35c3c8e5a5c904060bea9cc7da83717f3f3fa9164ae01eb7e66ea9c579d754eeb7ef165fc228493799d0b0ac467c3e70ae14beb0422c22fa89f4cc6b72aef2ba8ba1a1677666e2fcefa9178cc14051e3d6fbfa29ef38c6d7fee08607b2062937e7eb387f3639de7c8f754af617062b5079eb1ec93e99d56d6b2568b4c37a51d57ee1af8f0df58d5ee8e642e10ecf3c6ff6deefab4747ab083ab850be741ea6b20275e68bbb0dd52f92fdacc2402f3e22a59198cf0ff91563b29f80eac85db8f077ac02dcce6f3b64c8352d92ea2e48fa6dedf249b32d057fa85985a0d16273d2fb52baaf07204a16ef8e6048cd2043d4544d405f4819c6ee20d701209aa3fbba2ad09ee2aafd9527b6d26473fd50ad650078a5fd6584fdab1ec124edf2b3a383c8c7a5a8bb2580673bbd363a8c84d8ee8b6a00fe22dbd4bf9d466cc9b7f73a8dc50555e1ff79bdc2deacb6ca549454c638a027e22b0f0813da9b0bbccf41c1c0b010c60dcb341e84aa69ab92ec587016ea874e85fea5c6199bfa0264890f4a899eff3a320828230b6f8517e826157c1903f583c9a321c81f0217777762338ac9cbe5eed04142dbab139594584c4f1529c1d415eb2e9a9d5edb6d2e48d58527476829d0805946428a4202f8878ed2f00a27f18180cfb232b1e55435ef5d3183c0b5a5907b115b3d53a15b34b51a07787b884a814e3bbfce5a572bb68b13947bd2108cc9853e05fcefdac139d2e472b4b5e1ce9e58f5b83e674ea64b04676531671ece1ce30e331d5a23086260e7146110e63d2760184a920e1c7bcc2ecedf5cf0917aac21c8ec105365e75ae0c9c74aa891ae8f4f9bb4ab92840e0ce0c142cfe68f6d183a00f97943369e752b9e2248c0c16c1b82d9ab0cb42516902bfc40fb2668cfa75e2c389eaaf2c0d4355b2680fe0f8e556f5690e4204aa172c6df4a2c51a62f22d9bcc80e9908285942fa7cfc03a45cafea49c7babf80fb5b1e3c2b5927fc37bd89b4ed5b86531a92dd2250e27ceef1fbcb8adbb6ba0580779de31bd58413f75b47aaaf83da9c8d5bc3b03b943b3a3f35261399eb1162b2e79548a9c850ba08f1b15719b05f56327208e131b6b29d682e6b60db795920762a6a19ae5797ecd253ce178323a9dec39a924d02a3014275c8011fffd46488a21eb3e1a8aab73432e63f1b9ae6ea7e8bf515e6b031176d87decbb06af893fa334bdaaf9f58a604401681660aa8da1b9f87ebc9ac04275b4ca5d6b6393c40fd5f616f9980f5e88e38a6e4ace84ff37f954deaa6651a165ac6663c2feb79e34e31ec4ee1a45003344baea398097b1c99064baee3583849b2dcc99e61134320da6cab65b245660d2691af034399696ebfc07b14b35102057de0670cede5189cf3b45563ebf2d045ccf5fbb5c07814053587bdbdcc7f2a691fd7b206d51d28ac20c8340abebd35dea9ef98420fc926a4cd8f918bcd86faf14bc9660e56c5c012d69acdd317b6417993daeefb669a2ff78d68201a58b6eeca43c7f165a744d7f4ace1654d544b8c679056ed9efbefbea8de23267f1859b1b4ef5b9c3847498390de5df4bbebbb3b777a9ac1f2e3fd5e1382a2b763e9afaa70414f69a515170cbc53a35313e68558e8db6a9d3f5490721421adcb6823772b823410f0b11d2ac768c5529dfafea5fbd3147bb2a7596e08ee15ba647c884b3cea9c612fd4930f64fbc11d0ccb0445f6f9bf21cd950f1d61430bce36c14eba65b537d44a174b0e8026d5fee865a07f23c5f2cc1af2b74cfbeefe04e80c307d92d400d7716e4d6714336a19b3c153240b1210c29cb8141d7375f9ddf212248f2a731420c8fee90bb450acaea54f86f4dd040ad9f83016eb52fa840992e08519cc6d3f48a6dfe447cf12c7488f7d7fe7d0cbef502311e11f3bc00fd8b3964b720101eea117474f9c1312d4db0989f0d7c6a4490dd72dddb6851c025ea80e7205b5537a2f43ffc837a89d549e5abc326d4d05dfb5708036eaa7c9bae9c890ea062353b911a8dd747b8de4329fdc01712c43e13b58df818bde589a85628a55344d9e68df89fe496a283428d187aff17dbf011212c76f7b1ecbcb2b0a1d6fac98268c513bb820f4674f99af2b8d3b8dd6bfe6ea69532d85024169cf8983bcf0cdacf26ca7a946862f791104f72a3a6d9f1b9b1443cf62f526e9c3d83ce1146b05802cb304e7ea5cc09104c918d6ace63fac0b0bca9c963050c48dd698015c500bb705e1e4254c561753d4c6508c4c3801365fe81773623db66ac35656580e01dcb6502b73280e1ad56cebe8cd68738722c8eb08cc0da812b246d37a083363c0b7a061b802ba15b6d4c6ed1cf29c4c19a6898bf7619543d02ddd76ab56c24e33e968c43a3bc73b0e92c5a67286350919d3057ceabbcdc88d66ee8a5aa24bd624c0aa0af4154f2ad1a8cd1dea59ce14ad52fdeeea231309a26f10ee712c254f320ce71c68a251262ef4beeb1b7cc434522407b6f205ec023fe1655884aa641c2cfd51b5eb9b4f259b2c6ea2cad404c2d1c3d2d536357e1348498198839d7b1978a3cc8b35813a211b7d9131a14a99eabff0fea27a1dec34b9f11bba019938ec2feeca0a03f258daac50d650afa2c975fef41b9307e6c1c595d2b88c609a5bdaee843e765346bb5eddd4ca33867481426a964f4de0099cd02debb82a3da689fe4c0f7a22e27cad3f42889046854e46b9e9c3994922253c97036f5656d6e788116837ae08523484fe9122c87551dcf9be294cc39eab21d4dadfc4ecc951de6b4b25409c82df5038a1d78f627156aca5dd7e3fc04d05221ef3f2c7d3cd5475a8f902f3a5c0d7ce87368ca8a4a7c2ea5fe026e2f15c92948ef7b39fb998166507ea022349e21bf52d19e54112289eccaf379b6f5820d6490e0a32ae719b74d170e594895014e4618636da714f962da5012adbee06d75accac318e4cb9e66a1564982a2e3cbb4291dad288941c9cf122fbd7989890a16cfd42ad86b871620bd56b62bc3e61ad991b1f6446082c0577ee4827c08ab8f386b76e20a20892bd9c81257e35a807192a8a8b8afce91551a93f104acd91de5cc697a00e924f77a94bfa9196fce3da49529fa26ed1ccf82c823af2f47ff26256f2ae3361b527ac18f61633f80eb71a26253ac275002bb73e41f070a5278ad80da790387d8275bcb95dd7d44354d7e9ba5e678743ebe47eda72f37a2c5e4499eb3e53bb2064d64c7582700becd30a528e5c5569927a917b1fddecd9c98e20c9d401d8ff022fa6f9d2e7e5647748a0361047393bd823f69f1615a30dc351c973e00d204d25a5ae9c039b0ac4debe3a18153166e8e9b8855b07fb32e898813186b28ea0f44339e940f88c6782348fb4e36a2b0ae15160dba682778c3845ac2e40379fc3f53c8e5f3538b316c83d4e0dd40c23c338d2b7e07e835ec1e43833985c0cba59e5614a2c5fd4156c353136d599307a9aab0106bdc7579cbead1a049e6f7b1d8909d18f4e272b179c378a965ff4c514394886401dea5157483b08f2f70b3ae38f99940f20e9d713efa86e5f753c5a173cae8ade573e63e05518c36f9959b1ec5a871ed93b98ee2fba0daf8fb46a2fada480098c84b315cf45026787a81b1cb341236584b92dd1adc26ac68d61f197d180d844258eb23ca45dd250b919ac92dc631c5ba1f9e552f6460964f7cf45b0e2043bf60807f55f8730de24834e3a9d994e8ad42d074763886a12690560d37c2d12e6ef64811f3634223872b0c66da605438cbe86e1a4c41e3154652c9825e748214ebfa429adb8fe5567c9193110b635a873f8319c0a7224432d8a5d7b6d8ab239a354cc8c6459ecec8aab36c0db9dec3d06e4f9953ce1060c6f14135fb73249a61af96bef22a86befb1ffd449e2012382631bf5d76b617319448df4ec240b0972c6501e0ab6d7a260a56f9be231ef39b41f30bfabbf4227a38d3bad409e221ae7a3551488b0ce64525568b9879297ce4e0625dfe4821a02f60bf14a1f0de6c42553b6acc38f4ad48d9c8b764d25860dc072ac911dfa4de53ef2e70e1b1d5b251224f02b896abb671c06fba13e059b515ae76360820ba751236c829a4e092d5434d004b90b30360529e73b791e044bd43ce8b58f452e9037c2cddc5d257b7b6d13f87115217622e675a6a09808c0b10f9bd23a54c4a517b2314c91d1b028b2fcb8723d68ac27f6ee97f68dec7501a4ccf1f83bb252e933b6fcdb55f06e47ed389d10b0887779e171feaf5ea4cdebf3ad136f65418cd289a393f074cb5d3438e94338f2a65c81d8f9c9290faa416f3f7e11f930db26cb44c146ed1100edd5a42361b5b30409e0c1373c49516b3443ddbf9800f6469c344ec1a2e353519fd7e9f1d84ba60302a382f2511d56f651edc0b676424aeb2aa5038ad1294a6fef9bfb86c51986bd86392871d06c04277b4dabc0595536c55a8f5e0eae9039012e21bbb73cc556c0bdb4ea4e54790d7e99210b634e75880a619e15371504533f519a48ecc4f43cfabb5b29a5c3e6edd2978fc4e258736df8b18912b8effd1474bfa9e2d0335a0ff689270aba76c5807f3fb955ceae78b7b4b1e10aa1bade5743ecd08ddfb7fcdf1267ee97430ae5a33a308228fb9c7e4471fa7a113078c4d32d026cfbe54262fbb9e59a1e0435401560e4dab09efd2e5d948980de3bb89ad440dbad71243eed4558f7eb5a39bd2c87f1344268089b708462d23a42f2b87ab411f21507d04be1ddc19aa3fc7e6f682b5f9750685a721b9505c48a6cba778b4a8e30964cbe4d592a5ce718f80c43cc820a5296983a0a7f0acb8584262e8b7fa2796a196da44427cd2c79ad389b498dbc081521016159ca54aa031fc34b915564d6b550c4a4a9cd0ddeca3c16b4fe8f38a947bfa11203d7909f47f01c2e738d652138d87a7abbabbec6ad49a75d5cbfe3cfbb8d86b9c8f1f3d7575342624ffae4f325fdc60ed9d42d4c3b4772353b3df164f879bea5aff11bfb4f9b6f42f3860eaa9eadda05267e7f9b105904b4cc9c5bbbd82b67d45a1500d77e1efa8c9c288dc61d4a59534c43325abeeb648cc52396fccb5761f087b0b109e91235b260a1a901f88b0b40db91334f89579d2de0064d77f6475dfc504f33931027cd4902c174cbfc80fe6b1bee967216918d0cc8a884a85443d78d2acba79fc578594d00b82bb1ceaaf42dd5522dccc8867c808d5e9aa3fe479181a207c8089772611e91ea05b3f9c714fe4cf4196f4748dcac63d70881e4125bfd8ce711fbfdd8f4464c54a2ade2b248dfaf155a519e85664824e13a82548683100df76b1524b7244af3270fff8d88f8b3b0f03e1e5b122c94ea580cecde84c61fbac51751d71664a72bfa27e86121643137055bde2067a9439390a697f9303cd6c42e89c0657506fe7687c18d756cad340e2d08ca8caa7f8b008f783e3c099a59365669cd74119ebd7a39bf200f33309095fa3e1dcc2400b4d5c88b315a5a14de6c2910ca34931ea2110baf3f2c8c6167edaeff27db9eda81e141e37e83d938f7c640194e6a922daa0ed145c058a799be8e097a3d1dceab298d34f676eb3654f6eee06581bbd6c327e56025f63556d825ec4eeac54db33963920ded52171531553574d0ebe5e95d42bf57a70fa38e9ebb54044c045d5b4d022e721d0ad6c75b3fe6ba2b0f787398522a3614708a35f579bbb58375c2f1796c03fd1d926c9e15a2d57efea775e85dac0957d245b1843fbc997c0e514dbc81763f30ea82a5fb5138311283ffef9441fff8b98e9cbb760487f467bf8946447a2763343e012e51788061725c57fe4b3af160f49b91ad81214a5eb6265400f1cc40f95e1c918b64ebe23e1d3eeb9a1dfbaa64697796e029a8f3bc02d8b4b1754bd0c87d0fd540aa35e3b5ff6f6a9d0d064c24bd25f54c977c93a60a4e5ac98833454ba07fd1420848d467ef357fc5fc17d3e3a56bfe3f324dc994fd4d8c35050e1e5d9643d4a3c5e61afa1ef8508a8a280e7da465a7120a0872b6289f65f456a4b4f1c805805b621c6bdb009cf44b9f4a510fdb7e2db8862955227d5de286b68fb1fe299fab0581df9d558ee7da3acaab9ac8fe81380e75c9340220b6479eb01faa997f795a41ab0aca706488ff8bb8dbd8cdb71f94c6e048863522efe4f882ce744b85e68c0fdc88ecdf5fc9914486baf244eb98e6a48619e8b90f86b3ba9f010a0a4f4d79264895c5b8791ba82cf05b2c3947527c2fcc89b1dfff69026c3b1261edf17610ce22f270156ca1d73da5be786f5ea7867458db158f2646893e53d33477728afd71e9b0ce7f1e9aa0e3bf42460dff3ff0ac794d43ac99095e45d243ff82027f41a39cf4bcf9d1fd47833e1dd4fcb6a220e3db06c8424bdaabf31ed1158f16cbe789fdb52621fef576fc9d64863cf1802a21335b01e44636b23f9c9a14c3f009bf56b1c9c9562dd2af0ff96ddd4eade91bdb824422ff9b31563ea9e8c7ec5411a74271079111db421120027f501899a1a2d456e51365d5a7083aa62fd350612c2e63a99e6a2108d5f9d2cbaf26a071ef3bc2fedada11e9a22b9cb5dcc01ab76d5f60530226c5189299f146af1bc258516011cd1f4c0e2bf50ce4b3ed8931a50cd6a7fe531bc4a9afef99574faf84544be98fd3c89b7994e4c0d1e4a82cfa71876cd10e670fc001ad1836992d3b6bdfd8e1ce2b013ee69c6fcd98ab673b4f8dbf482395f9761a4825b3bebdc107e8697df94e40a92ff5e311458a79bdd4190550661c9ce2cf692634e8214f310e0326a635604baf2b45ff706ef0c52edfd4bd0d943b55be32692f234e6dd438c09affc474a22b354051b6532698711dfa4432bcced9a0a9a5282be4a46d0d76b13bf3b048ca98fa74f7f9c78be9c68e63a07a1dc0d04167f3cc2143e927a6d81b56ddbbeac6cf8719d133c4a14a7d49fddc8d8ba763203b9fa78eb66a27bf715e0f928d26a5f6313a39f6c5d25a9f59c6373c987c756844bd51e981a572143e32cdc578f8221ce0a118b07b760fd97908f10aa51742457187004d920c635d7a44f38590b743a5f073f48395e84fd94f26e7fc886a330b116ae2fe88ccc535dd27ca99ad76a9809a8bb5ba6b763d7c96391629d3418a73d271d803bdad01b46408001ce5073045963ffd02fbca77ee7136175b40af445e25fcdc023f2a83cf209f503000ae0aae66cd1c5ddcd32a2564d8cfe56afcce16a8cfa99d565b4dccd87a626140f12b79fe8b66f527baf1bb57390886b2927cc6caa088864c5d0803f31abd10095d1dcbb5a6215f91ecf342185d26becc88432e8d1b0e6ee591a28a92be8ae0aac6c945ac0c6a086e3888559ca3b5b3763153ffd2871dd36de3c84714b0b2432f80ebf1d52066d9ca374416054d38402f71f538bba0722568d1d01bb72a4d4809e1cfe68fc1bf0b078bf8a8a1d19d103174fb902c12eadb495502b34451d47a449b410db4d0e239ab5bb8d26e89616d9a8933005af6d4fb664a8d6662ab9afa49f9354ff1771e32756fdbdfb6eec02b33049d9ae91ad150b550f286ee917eccd8388c83123dd34eeeb1327e5f638b976c0e4152a980cb4010604e56b14316cb9ea0f25acf7153ce889b9ed46143a6f02ef0765768113995238eeb50ff85be3ff7e56aa8c4631fb697faeaa7e66b61301cc27627c3cdc19376e3afa1cdc0cae3b1cb325ccca2dce292149ed7239a0052d33df484c23f3ea2726e4842d4f9bf91d9e45d97338d19024b21602be398c4f7fb59155c37c6770f5fbc6e12727268eee4a49d1e9294cbacca7841bd29866f3c46792dac8bb6bfea7d72270127fe206ff87b74e36e72c1d8438eea62b3c4d96e7ae4349ce1aeadbbcdcd98f59abcaa18d800f0e67bdcf5ce8f5830b68b58b5063424369f1968c4ef6faeaada7d4f77122bd30c6b8e0a649f978c524e5f5e08ea668f76d8196ffe678c1e4ca1c06d8099e4c14f1fdbd35528d420c88d020e4586aa8c2b5510484613ea117ea6356495b64c4b9b6937be13aa5fbc34a853a62c8b820f7f121e1935fdaa002075cf286d6a911a22ee1083bb5c5627c0ca1e9b2dfa1b2abe66fe2a5b093b3b718ea4e61a2f63724c00bcefc0fc3179fc46e8ad31d96aa6402c00a177e252a2224c45ff140e02dc16eaacc0fc63305aee79d21442c61bed8a12ba54def4b8cbe9b5995795013501969036f7a512399d180d5359f726cbf1bda6ebe19f3c7c3c3fc15fe2e3510db1574228c3dad825ea618347eb9ff9eb7548043f515730a8015e15607e7da2733c2af52c0816133d6288c86b7a75e30fa8486b320d34010bb159861f1b8b57ecc0f61b06774534d2ee569f39f7be65ed79144a616d962dc83e0d98a0ea0388ebb2baee16cde5e685c4d5e36791ebe1f12f224c6dce5864080177afef6e788c1d97814e8bd3986d7a9b08d17e634512689ac7fe601ba5840e9a9fb573e550ef5841d187158383737e0523b42d8a9b61b5414e1bcd6846f70ef770799bdcb49fd079ec30c2e03b787ac19661f77846fa148802bbd230e38dd66eaca213768959bebf42b7661f5150f3c684e111f8a3ec7c9ce087259a981a149eb3a4b0cf8390131115c68422922a30cf06c979ba83b6ed9de9217eb961d1a4818a2a20008cb3cea73f21999f0ba25b4b8f4ff0dd008d176af515b0e6d1e849cbf88149e99a3a9051bdd97950be74c777ffc67334119668e93bc5e05628a47db8b92c476846328c6002ae6dabc76535b0908675b5ccdd03d8a342e18c1e7b7de5f2e04ad9796d7ddfa16859a7f19996e5a26a362ee0cb515391ecdd71074fd50953234ee9f8ffd60689eb0d0e938fb2bc4b351331a01d5587324914abe841ebcc91737a2bfc1f9e0bb0b5f518575dcd7ff0df69449cd68dd956a9020abc4e5fa0dfd4999d89e42129ff99fe157d0b4ea7a9865849598f00313c372b2cbc13421c9650e918c97a4a128db67bd4ba6211a65fad2bfa261f90c5f4d58c7f5a0dd238ac7415f31437384bf78be2334c8650fcd8eb87292d0fbdc025b31e74dc4f41643f2473ec043e56c8c7edff6697c52227a62716bbaec93e4549ef441ef844a70bf14f9f08beabe4c3bcde0f674a20dcae015fc00cfcb94be1f228f410ea49d40d26d700582d392370b348dca88d981442903cdbc0889c13fbd532d91b85e46764918fe7e2648a269864b1704025c93d5c07ea9778064bca32a5bbcd0b839defb4eec62c6a61e8837e29c9eaf717dbd746e3f52fd05fdd662cba665417c91005cecd754db59306a173747331451632c21b2c3d0831be6e7fe4d240367d6da49a58dd0cb4e802dac7fa6416860a841903773aaab8e85b09713daffe11fbd5ae0c1340d0665852a0836424837557d4cca19d3dca21f63e8d6c605193b88f7a04e4571b0b6d8cfaf8e39c882c4b30d51c2cd0c2031b65d2006bc24fecc3e2b6335f72c057abba6c2e69f74eb5631768c296bf7bdd19c794375f631c2ecbe82a205b1d4bf78d89debfed2710453361c0294811197a967e27d0a91c1f31e7008596403fddc6ef44b94c02b72115c7286be67fb104fddee5d34434b1f3e9c9bc96bdec213e00331407934125ce66a26f84824991e72eb2a1f04870a1dc74315873c458807f84e0a81f50048074470d6535679d0e85a8edd3fc2302d77c43f0fade3087c54da42f19c4334bc3b6cb1f7b013dd179de97516cbe9b9b5be5ad6e33def7b785bea8c731a109923323cf2b4b4bc3dd003734edde6cf6be92f23db4c1d95a33642e807559158f347b7c2a7a2496970278fb10ef04f1fa8b9a4cc31c5bdca04077db65b7e8e917380e8785aab45024b2de8422bcbf4e88cfd7fb3844d666a0acf31403ad17eb943e20e6d8e040730e2fe5fe46809ef39199c257839ba25b091e8f24194eb8ce39669c7cf66ee823fbc0897d256962648349d7fa96cec0492dc39f92f7658c8f5d42fe2d7f126eccedffc3d91f95efecd96cc46f987f2a6cf41952fd888eb6e4ff8a7bbaa8b9d34292b1c9650ef3ce38150807b2325e1ad47cf01424a5349eb628f4ea75c084b9d453166f98709cde6c2f18c40846e89925b13405a06ac57266a35b7d87253539ce610751d9b54922a1de20e3632c04a7b219bb29d0082c11b188e8ae7f246bd17ed45e05e6642e6dd6d4eaf2aa72005a6764d88c1d49f41d85775e9b6c83b7ab12f17ac52337d53c22eb5b9b32d59822ec4fffbcc545d6247c594fb02d8ad3f227a7f6a13f818bb49c537036d86177fb4e3a56fcd8aca6e3086f708ea8607ae26ca9ba759684424fca30ae115e9ca596ff9c85640bbda35937b7bcb5c10dcf13fef34fe8fc67d297afbc959bd49441bb88fbb1604058bfc59e00e89513386a0d52de6fcf002596c76242afd886aad1e1df2f1f756ef90a0bcbdb643b8520f75266a3f61635e6c574d064dc62f1fbc848e462df7756e5de74479dfac2995ea1fb1ed6b2ea61942771ca77e5716f3a8589e8119c6e37ff98e62db55f47a2848d73b7cae882745fb6f80880d3cdc72ac7ba04152e45be2cc68693cf62968f5ac2e6a5d10c3437b6168d7020e3fb8631dbd6895b5e849641e916fbe6ede22a5c352dc23358a1688cbfdebaf5f1a8f921c33a4a49fb803577319542b3351795f432f4fefd4e629e6bf335e0602ee40a898940b783af9a829991c3f2ca0f829c6bf29e5431480c1b2d9a2bf38c2fd53bdb40988a3c6f9451d62a829c830604db9f083412209d87ec15b3b17b9e54045bf45996d62d1c20b3248d637a0527cf5a7d1d4e756b44363a7c5b2f77ce3dbe9514d7fa360c7e228819a681a9f970b7796bfa5979026bb8bf4671dd39e8b6430538404f3782b59155791c14923812d140bac5437ec94c3af3781a7287036b7dd143510286fd8d7fd52af513ccb2efdad4a2a3fead79cc299b0b6fa12863f7620b004cfa7d7dc960a42479d1a98dcbde6917e6c46af8021f8904b509ca3c37090b8d358f5a6fe766288768a55452813ba5405c014bba209239550b9bc3137284b77158648e7ffc471a3f5af6cc6d661a4d4ce5526e3d3b2616fa0964c91509bf3a8c37f4879906c0faff01eb49b071f7e62b6bca21eac1df16419b67fe0a8af9c9e9d18aa168fd84cc93c698de2859e6949d9c40e7c022bce42e50a15662a09e8a5cae552be33cebfcac24b88198b4efe50e1e3f6f4e3f8c24ee6444dc3d55eab39f0578c5b3a88274d4c426c250fab2a01990893f6f4c446666f693a52de2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
