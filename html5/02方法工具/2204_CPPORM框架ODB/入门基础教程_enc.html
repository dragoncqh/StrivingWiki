<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"99a36d98813add9c65228b5dbdbbc65c7f512ef06278a44d7a5bb4bb6e1e4a21a86a8b84044891700b1c3cf6b492be2f710ac61d96d449b850a81d3f85d110200636e3885554c28ff1a049f37a36ea565216d78af3b909a1bbcc2811b886863549436810a6e64a44ca2dad7b5dbfd8eac8afa600562a187815f882de3998b6b2633ebea33c5d7b6e04277d0653b4023162b27afadc5517270f0952a2e5223c25962d3bf0fb35a89ea78aa436c6e3176c53ff7a9a6bba65bd8139f263040c7beb3b35b34f39eaef09ce43201ad817966b0b6ec396dbc1b8ce177be42ed7a3a46d4e134fc9757f4a4c920395735ceb4724dbc017be255856a59c8bedbdb7ddf28bd8c41d66a8540522357d377e710e47637ea68cc39fa9008b230c9d2c175c3d27a3b582c22d3f73a8b68b30eb9df5a5a1560f9f7a68ae7cf6f06e614efc1af8a49ecca531e4dd0919733659ba582226223d74a4eb15ab651145d5d2616c96e22462193c374a1016edcb8f06a557555930d46c407a0143cb2b5127da7b40c38177e2e7a1f763e605145879ce049a766e6099516cbc3db8f10745996dc1e33857a4f17d7d194a5ee62d053a66a55a956265f698d482bb13d97b75c242c0328af34038e93666cbb7f7e0a5bc1062f6bb00fefe89785a38b7f00d1a58310bf9825b8ccdbd88989d97c42300e6609e23e7552e1301398f1007e70c6b7717725707e6fd8419f8f2e54f7b940d4c3ca804c74ee2c39b36361f91faac3a374f7aba04b3121167082f95ccb95a1934cd4378ecadd316410f9314b607bed214b8dbb14bfdb6b131752902b9683728d74dcbcf3eae8f5dba86c393ea64e543aa26bfc9b42d73fb1506de6edb203c57f8545a69608fdb3b6305c617c654ffa24e115d3e731eda137b63efd3e27e4504afea64f6da1da095b1fac707682888264c1d510c2549e58c26105e142bf9842d53e2b728f6d4b3cda6e3c985d2c46ce00e7a063976f4dd892841478b8678269335dd6a1613b77613ff18626b1169d284755c13da0e90dfa35436f19f79e4d2ec8644b6ff2bb66fac11aaa4d855e5a6457efd653d482ca7abd09a166c7aaed19a3eab62e360c6ee74fb4335d9cdca6894c20fceb83ab7b015f8eee01a6188c7e693d684784a9b025b1f207d6194f055229ac12490f85b55eb3044139a07a28e5e680969e9694944f7aace33e718f3a0be5bcff3bdb578327317baf846f34a93bceeaeaee5569c78b1370a257f376a2146d13de5c8f3623f624cd6a65e3a2f330110179a022da0ed345ecbf332a41dd882e7a8c86d4b0abe0ba65476bc6d95411bba382d319c61f7af8ed914f9da5487823cf3eec97bd93dffc39d791b013cd955098aeb87d9ffc8f98a727c0cf786570ea2eaed6879bd98f0f81abeb8e8b63ff33de631bb15d32f952cd4dc7bb2b0b7554c44c88e8cc63922ef53942421d6526748128c2e70eedc7af398905dd21396a0d005bf0acf33cb620f9303414e2f38db052f3e8623b3b574acf46fe6c8c4ab1431c367fff12f7af9ce604e0c20189b4f44036d3945b8d2b34b88a5418cfed68550b5f9c45732e3cf0ca6c119a6ff0d1c88171d7404ec1204d35bc37b923ce546529f0554aaca08c963c3b53c12d96fc72ca895a6f57aa4fc488262bc4ab8bb684114a6be41c8761cd2ccd9a78a08d770099bda80ab8f5083ab3822cd48ac130b00b098b6c0edb67cae346d525a635170baf4081464f5b72be9a997d4a5c54e43bde129ce0b323ceef86e691e31f1ae1a99569d0d4a1a87d72f052b173d1ff0d98d611882e16bc69d82076c185d2831ba5b495bc7374b0150cffc7bfadee2ab37d54d105e696bb840647a95411cf1f77f919c4b45558d7551c97738bd74efcdcdc6d66a4673b1d2ddf1d3487a181bed17302b60830f1c77dc87b8c4a1dae3dd54a7bcd0378c7424aad6a495791f43b1998f83c7dcbbabcd64fa8449ecf2fa92450fbe07373cac3ef57c65c654a6cb815ad0f35a3f8cf3c4da4a18101f759dd775e378fbf7afa4d1ee2ebdb8d2a27e267b6733d2e0e77420fa4fe03bbe75784e437c1dfc270827fb3f792ef53c5c01f8e621f7d13f54acdc19db27da965de3636df21c9e3da821f39758b2fd583fcab958d53ca0cf857fd30601b79d5b2e4d29c72aa3f794ab0d0359dc590c66ddf536a49ed9178356ff0dccf44b74f7990faf5c2a064defb784ae982dc9940b7a92ebaa8087125816a1f2a46da88a2889ce4fdf1c540d04d7538e2bffe277db3d3f73dd9cff1993863f42aa51f7a0afcfb45f4dfde6b79f67cb0fe5efeca1c5ed45a8bd1b4899d092c0f56df0c7fe4b6bc353b8851bf4cc86fd7acfdb579b27ab2157f5fd8a8985bb05a14072ed2bd6f277b678c92639ac1fc4198cf2dd067082939a05ce9d3ca1b7a5d59b5aea1c75a91960dd31fef6aba7d9356fd35967233e013ac1e6a7c06fef6c2d7c97e70b5ffc19930596cb7f6d02c228541a570a153c5f11f85efe0f308bd9c21194505185e5425c608e6795aa6c1c2f954da33cc6dfcbabdc8e2d829b256ad9842fb1d27a12a2cf16aec4995821cd5e26d36ab06fcb79a3cf5d76c7c03c163e2f23f213f8ec9e6f70de5fb1ef4fb8b009ddb36cfbaf192619cf35111b1f0093bfa6902b1fb3deb5fec6dbf36058644fe1bd044e3d7e22e67774b4a8b5b724af71b69b36d8da6dfbc187516d8b4b24fd54e73d3d1f035689646306074ac78680e8363af0843df724699f65cebee97763ec67d8db9e71263e59058d83a9999b1070fc0b098eb02d2bc4188fd55b29943007293d43c32d62226f9c02825fe845bbbe1f25f6ec4c309779174458bc7b07b163e97df01c71373e74601df41e4124c6382238f2ee63caa087a860fd85030157e12986f2734f16e5f7a64a9ffb7071faf0fb4a1be79bb5412efcb910411a69ade3e34cb88b4a9ec37977a7942e10a04ec958b2030898e646e722bb49e9487d1ff434831c61530043ca61ae76283b2e53fd89a39ee0eec0bf2795f93430e694474fe5fb731ea5327ec7e723111b59d0000282f8b23ef497e51e841bb6aa2399cc30e311fad5b65ecb91e4f3bb0081510b763520dce0095d7205f1e8bfed94c3d2d80e76842a71ff6e7ac2d7290044386a4b921f24724c2006b93df4c1471a7f392d58f5aec137741a491f2fcce7666028681fb945c04684daa2a319c0d696a2ce3dcdc949e029f78d7cedc7f6b068c63e3ca4de170aeef4a77904f864d3e9b96590fa45ff18da7440debd77b3690c62e92cce7e8110f55697095b534435a729b7d399ca12eb378de6f33b878af6b0d3b456d097c0d3174964f194848281cae47fd11c47350b4565be132e8bff74cee32b73897ad838d9fcf617f31d4005b96dcd4b9a8628f2134bab3eea30a21e800d01baa932399d63c946bd81d8a905073036501dae07ce12c11b2cf9ba9b0c25a6eebf6898852d40571814c34b62d1dd11cb5bd54fac6f4400667bba99ece46a4d23da748d952c58d3bf05d79d34536d83d190920c8a92f7f88de1c66774df2c40af269ade8a13777d574b5bfdf0cb05e6001d9e53b1001e2e46a2cc9c164d1abc747b9a944de1c14e24d862fb0de0c6a4e71e4892d061c4c60645663402a01bbe3dd7446a305431db36f9388c2dad121eff532f154a681af18645b1879e1fe3efb7822aea6b276b9c4f30535662da5a7da7700fbbe14770d98a27f4da56875bfba69cf2ebe026405c7fc42c0e89fa520445c973e011444f7b05c41538c70e999278bc150d60b08271ddfc2779eca149f7a21a242004e446874586ebde9611a1aabf4dd6ac273358ff9cb69470534875673c10260bb3963045e2a572f7d93c9f921c15f9fcd70882379f51d1cb9942f7abc5dca8df5a2d2b52ce7b5e4121705d3c0f540c80534478c2716ce1ac51ac223c3a9ddeb481aa0855d7dd6349356e53607d2ae98da5a22d7015e92ec69f82ac7c82fb326bdb846c7c431206cc7526014d59e35a682c622ae90b04fdb65bd81586713fa364bf089382b60e7213aaec9ce5880ab9a58264421efa22aef5368e7cd035ce86d89843d69911b6bd048c795ae23526bc96266e554b45a0c177e4ef1f5d9ec016caa46a990322cd03c7926d1a58603e9f4f9ccb9d0f13891293a1f61e158474aee9588d86a42f81737e96810d51e72430a6fe204e12f8a879faf02a7133f5548e0eb2507d00b048604c330899b8037a0eb2161cc51a469fdfaaebada94cae4063c49c46c959b6d29bf4133f5e15bc1f11670138a6d6346d54bd301fc7bdbeb3e0c3ac10e4238c3f2ffd397d56c5302e89ab7f243ec6de227d9a308ede18141e2c15da283682befe22d52bbe0a6d1858d4b4f9dd4d25d7414258aaba5f39b0df37cde56f9eaeb225e965599fd4dcd33fbc4bc67aaa092d3e18d75cf212057b7008a7786fdd1d14b54f813f07bdfa226ba8dfcccee32e1873e2073ee6c6842d9d4b418c995709c13a13d67ee15611a2846db0ac4eba5a639b61b3b8290278761d61d8f012e6018641d2566afff7286d3181f1f89185a073de45a03916ed9caaee6e0084bf630f50cabba44d9e8a000499371184d265c0126c83ef7420e46bf5201238bff57e8f961a80ae45cca11f1fb6b61000117ad68079ff1cee3a57ecc1017a457942e3948e8df1e2b6ae983b3e5087d3c5d1f29166b7687648b1f50f664443f63dbe1a8c0ff7043794c2b37b97c6036bec5c763b2468195f6309a8720136f94b168637ce88312427268e2811748ef856ccbb19ae1180b2eefea75124762ee3c895a0be6d9989116c39792c02ee36113775f569f06da7c7bffb53ec17515179f4c99fe98bc2e1b669ffdaf6077188e87fdbdedc30ed7d91ea1d1eeaa2fce4b52aaf29033ac2c66acbde12f8f843ca0f905de73b1eff9e44ee1e640e4427dcf75888e9d6e47e94ebf9883296c5a2e21eec04dcf831afcf5a62921b8222720f419a9f870a50ffaaaf070a831b8ed4232d2a44efa06bf77dd7b7c7225ec83fa63fbd5988d6774bc97b764bf334984185a599027e95c9bd2670af11d66e3e57dc8204ad6f5ab95cb7eefc89f253cdc0335184b61cdf2d13a673c035dc76b9b69d4c0292c9be014f2104531072b0b29e165f97b6fc2e1ab4eda9b1bb26cf5ba943fa319daf11cab75883beb8c011023680311241b8956f8995be376995d85aaeb64a8689eacf4ab01138da8bb3ed414d3898352bc9a9e76d3ad544ecf4b90788407ae88d30f0b22526a3111d7c14d1b5a2bb1113eef9b87847e4824eb0e14485e43866352cd20a8b4a8b84add1656a97775b7e7641795f9d99b1fbf457df502abb1f9cd6c50058385f89036a9b35e9a38bc00861a6ed4f3b9ab83f05e59ecf9dfea75daa1007a157094be4c10f2d764a9f2a3e677ede35e30f563844597ad90772e1a3deef865d1908fce6c52c8b319b473ee13d756163281a040ef5a4c0f208046608904be3ad1ac19d109cf3b2dc342d114f12ec2feb1553126334b9f6774e8a715456b737334eaf06a4c2a46c3563709bfb2e9b332fdeca0e4dcb754d00137549d6391b0cb6562727931b6d2bf2f0d1ede2f344c339d4c56f8a7feba26367542709e04ac3119fd919d1c27939c62b4a777adb3d7afcc913e7e62c5188c085af076516cd7dc49af12bbb6c60eb9c08884785799a71549218f13269a24f3314357095946d8bfa8b9e8b3eff6c324487cdb2cc4573494c0cddf0f7f9547435afccdbfe1d0c44d61b0910c4e51f6ae914e4390e3f319669cc653073d2986e21c9b3ec0fa108e88952387c60727ade1c79e29671002ce256f2ed97cd37454897513f6968c011003d9e93d3fcb45b526cda8e1adfb2197677e8b131eac70f5cea699e291d25414b0290403fead0900672269c6272bf49e2872705c40b88b988030d13aa7f2d364c0ac8e862a70ab7828ba6cfb8a80af84f8666dea52063e920adbc7c8a9f91a060293ad89772c9aa1790177257c55ec665377eb5993d69ebaf0bb51f3ceeafdcb9a0bfadd41fc201c5b1e0cceaaa7f5cab69e4c014f49415b51f3d85b7f0da13c8d3b764746c4027ea5af65479d72603eee4dec9367db240f89313da1c57ce465e89d2f7c0d7da1699c5c7b05d412a0a51a9fb68a13fb6d472e81e5d3d69aaab047100585d799aa661bf40b11d42b9db5d65a6643a1776e31204c631ee2eeae561812a934627c0ccfcbfec2e5c2f71dd51fd5cb40d464d2d302762f7598b58ea381d7ad962cf6b726071048c3b91c617d9b84d69ce1ac5d26da2bca1507b11afec2ea680c846bfb910e749495e6c02d8985c7c7d9cdb09c55c392177ffc784f7291255d43ddbefb3864e325b3bb81eab1dfc4d018337f60f35d308ad25324692d6950bc40556da69e96af253f829d0fe1609a4c47015422e20865058b72ff5b9f9de8cd07ff2f985ce13949d4304c5ab77f9775d020ca2d4146441d6e36a01f376ea1f60b5123d3afe4ff98a47eaa1f0fea892a41f15e2e6002c2694a5afb684b658eb81e0e2396cfbd4eb97d88a34d4e12efc5bbb80335c0c713309c5fcf2c6b1fb3cd6879c79a3fdbc71d4cb5de353475380f6e9b7794610eed1668d5a417d6573d408c93701f911eff21433ce3f4533ce29b7aec1a87b8811fcbdf15351325a5adc5ff539464412581d64c6345fcd8dd831cf82723ded3758d81e05dc4e413bb44fbe5c17d54c83136aa060293915c9b7a322a56a9b101dc5b187362b973fde784c193273d3b9adb66b5b58e236ba32aca6c72565e44c78ad9daf01b31bf60b729d140a1137129512814aeea2d45c5f44848c596ab70eb92d023cfe1cef0e6056bd73807b56e22d79788837f252814bb868b87207217d278acc82261ae8d4f5bb075930043ce50bc38f363aca7ff0ef3716d879eb6eb60d305a59139e8b53345e58e4e285db3cf1d8f17c13a89c74eca239ec9510e667de033d97321c7a4b9825b9c44a4006f7d9255f2d17f162763b4551b7cc3800963bbe6671b6bef485f6c13ecb06d3a137166ba052e5710e3758f0ac3afadbcd999ece0c6b6c0bc5e39925f87603febf0e42fc20ed756c916e8b2064245aa86f4a895c31ed822567409c1beb21a2d923706266a564dbbe58d0885ea1391f4129ce55d7394df1cc765c347443c798af408d3d06dac8446fef05827c7bbc5e9de6f97ca704eeac39076df416628667c55b0b3343427ddcc3ac6ba91d217fb405437b9bd9366b7091eed61ed9b28dc5643b2a2ac418117f1df878b0bf1913904745c9b8e0b234c7e3763f78678051bc37756324b5b675a44882d27c5ef58be6bcd94a784767f150f10a1a9c72ea666396a9db03290597412a4b85a36cc923dbced8dc73212075b2f0f044f2d6ecdbb082736415d0585fa84ac343b2145eb2a90a1d7923b65d2029f90c1b52453cf816d49efca329924c4ef6a2e1dd6a4ffd36b730217d9b0c7e22fee4ab89146e91542eb1e0a040b47bd9aec3afaacf4ef6f24337836fe3943c292150dac088c21ab4ad20438f6ac74499627475a82aab14bf276e515347eb7d7ada9d29f83584736c24a3fc3961a0b92515d4febe61d70664a0354eda2df2ca6433a26bbfc09fb5c172f1a1f6d0717e03ad7333715cac601b11109850bbdf831731f4795360eb4baeffd96a790afabf3dea31de79026fc73ee01cdbcd7d129fbf922da8ccc1320a62a30e6aeae592e9565cc859306fdb8c87869a1598029549fd12df73f210d58ecca6e03017ce0e1a8fc0bffdd047c37af2fcc81f6239c29f1b17e5843994cd467725d0dc694900910dbfe8cf5f915809263725649a2260cb6335642ec2a9b792a1030d35d49c6710568ad51d86bfffd35380e8f00873800256b81483a347826d1a0e412d7937be47f204750e764e49fc4987557f20bf89a4461c5a4368bcfc32d5917fd45e48f6b8b1844272ecb4ece9aa9fc1f048522bf10993a480fe7cf5df83bbef477f68cdf9248eb17fec1e3be366d0f5de116951d354db8980883d16d4089bf5fcc8703f8d521fa525296edf4592119ab670688fa1cc58daa66129cb33414fb725c81a87021ae91c4480327bcd8ad855a4c752e098f87b1d138f00b8e6bc8a97918438de7f061129578bc197c7ab0b2fe988c18e4e612f1e0d640f84ced878b331925c253d3ea0b114e9a8a02cab05054089ccfbee8be125658ef597cc85403862fc9c8347527f1f012a488a4a89d77e0e43fb843d7538f9497bc942bee18fd07af8d0d41e22e06d10ae3388638eb9abb7648bb132476cbc4ee8fc36f1332ea14bfd8bca589d3b1a7800ca4355a22b1acf1207ab6516756e22fa23552661013f086c6546a89672589f1918a2b968e4bd0717f0a2ed3912e7dbfe20a747b1cbd5765e23f634e0ab8bcebdc46e7fe605bd4af2df00b5ee54a0a6ae756ce95302037de751e3671814a3bcaac496c4c97398ffdceda0f0399819760ed3b2fc6c19e082c5cf32","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
