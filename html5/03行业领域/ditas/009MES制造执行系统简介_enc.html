<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"61b3a18b691f1d179833487c60c72429de709d02be010797cec8fdc6c6468fd0ac757a456ecfd332c9995c9712353bcd2cc56aa961ed262035df7f6238a5dea7afb10d7b6587d535770c6f6f0fc9c97c3d65471b91e0140f5e756d8514856c718a09554497921e0939c0def37e471abf25ada37cf07bc482df5e4e961d342a4b9eb1f268443374622e2aaf39618d81b0c8e1208603985e2aa49cbc08f3cd4b236a7e56dabd9803df2f56e1c963fbde4c11e316ce425eed47a0dd5fda90ace210695a811ef075da2060cae2180822d643f421275a9d4c711e5711bbb34a083bc20ff4055aeabbd981c649800080f2c204f8dd8284a5a449afcb4fe6863e827eb84cea86073a51526873b479b675b9435f250a8212d4e8f7b0acd396ace23ac12ae43fe8a20c7764a4a372065d74783682c69be97cee64dc5a8451ec2a743363cebf8affe825c27d4936c0f41e3f0ee2aad685696c10f78351103b0c73389a7a32ef19377b50367c490e16781aab965786090924cd132ded70be7c956e9dffcad7c22f81abd48e1f387160f314a4af30692221a7eead83e191ba052d1f2e5bdb91d7a810fefacf4411fe125195351d09c7e9c5b5a60fdfa6e14065d8e9bb514d716164d5fdebe6b9508790ebad5e1be20226d9a463bc95776d35fb68392329493d84fd5b0e9cb1fc3268bd6cb558b3216b7a3bd72d1b98a650d8d2a603e1b975759e372b51aff1587651225630a0911e444d478ec30ed427b97c6e397f99b3feb043f82e2d425051ff53b2785abb72a70622b60de12d7ebba744d4765daf709b84f9817fe97051cf2dbd959c288a45866e698e4ce4bb6c9c7bd5b55cb2e94bbeb640f4ac81ddfb01b2d20d08e63183bbb9a36a1407f2f26ca67dc6d27e64db484c7f7c10bce52bdfa3972f937fe0a63c73713151bf2ad331550771ec210827a16095cbc6508c81bafa3378f6f6a66e533aac9265739f732371d9d203ba6c73f70bac36add21907dcc06a33341d34ef74f23a89d9b1b56fdc9a7fa6179d6dc7ca73c57c5e52e77db3edc0cc75a460d913db077713e2e35dd33f3617e59bf1d637e6ae7840ffe0c0b12af4a05904f537d0c0e59364e6860087661857f0c7797807d913272aaf9cf525620d21565508e8e4c5584f0413623b20b76d8b068976ecf23ae2c46d9ce06a608c0d1df3fa21e1dff620c93fd85a2878fba7d6b837c0548969d729e45dc49d66f3de678c0abbc3f49741c99452173a687fb08b489c588cbff78468d8be2e24dfed5faf25765267151627d625b1860a16ac2120ec359ddd3861ae0747aed7ec7992ba7d1e429c66c2f479d4a1822c281b4083274759c4f62227e6d411bd6acc4ba84384459ca42ed5dde498f3eed7d588071deffe9f8c6f51af228f7f60ee5bd05c0fe7c8ccee0e1b8fcd98f29fc858d3205fdfcf293acb50ba78da8595d09b38788f3482c49246cb02076b22d4b43f8b7d7bf33e0dc9d817fe7d2f25ac49318e4ab8d6a82d14e03a1c70af21bdc8fac15926464f2619f8f1cf6bd20e00139106cce2bd3ee6e3e97655ee8b4d5a6ecd5a37fcf402840ca47c04ccaf92a5be47480830c916d4e71755513566456206aadd5443179ca3ac47f2316f5a3599720a0de598422aa0845330035a8f90b01b337d64decdf80afdf1c27b16ad24a2ea4e61afe791577e1fb85caedeaf675deb53ecbaee460e4c5aae950d96674d7db289813adfbb55c5bdef6665747b55dae82ac7f13e1e699f072c183415c28e94e580bcb2e0c42eb853aac241269d3407331384a050ea9cc82952d4abbab7aec9ebb4b42015c205f5409da2749eb25de38f218d9284b7e3d0c4c4f9a8359e3397f010ade96404382b30a89a49357e9fac65a44d04606401a24fdf96b50107c16ee1086727ddd0a943c53e3a0d51aa27a53f230cdac572b97095ca0cf2f0a4c0d054561c074826f4a4f7b7002a97c68bd75defc0da748f990cefefa49f69054674f1db3a4f42754d37f7972900ed6be3af10ee9e32084a30e9318d64c76a26dc01210db34cd22ee132ebd668e65f7d42656cc62cd1b5a082bc758793c8758745d802c8e9724e879677ce2ca66ebd2bb84287c7cb12485693c57074574d96adf9739855f7846731bdfd880a03f44385e4508922e76f761d46299943a5b6080999d18ed4043e8e8835882cf634a74a4ecbb8dc51c9ad7592b4c804812146459e5183783bad8683ac97aa35f369d055cab58ed21f2baab998b7dd2887ae74da04decb2f45b81748312f01908251bcf9ef5acb882e4ba05b538969bde546e5e592f6ca39f92828b40b440704aafd89eafd4b9eef52cfd1d0fa8b714fc139a01d81e10471a688267278b467273eac33a4482bf08894ca41e17df0d5c75877563a3a0cf1e757890d98f1c27dbeeac76cdce6eaeca5a56804ceea2e5b74aeab7c32ac739bcce5e8ed6e243ef2c2e6c323035c26102f1642ad2f7fec2301ab94f6abeab2876dc13efad0dfcb4ba46499e8635f751b209d5216d75987a7b9523c20dd0d1704b0a81bfd52d0b7481766cafde66a4e3d275c2e95f09e830de57ba0be35d1bde60f3f8cc900bf5812b60df54311ecfd5cb4558ea40a8b04a8cc79f304df3f28180a218bb28cb3b542db15fe2cf70b8e98053922d772484de35705ee0a6c1bf2df94b722b1f3fd793ae9413e129e2c1f62ee1547e0cfb2cecc9da3d20fe142da005089479df35f766350d9dc89e5bd72c09bbcdda018e61240a2817712ae6e14276a4ca06f72b2f2055022d4bbfec8aca9f1062873a1551807c2dc19178afcee62dc876558167ac057286313e648df5b242b71a5208e2be6b63321df4f79e7f8dfa8c10f354e3b3f16e6a0b3959a603f2fa5d6b7339acca6192465834508b052c548abd299586dcef3dd0f14dbb0a94f4b37d9c484f76b1d71705a0cb58c62aad768501c574385122f76cfc474c92cb7132d138a73e820379eb169cefdfa9f587b64e157b0ec1e17b35b380c297719ef961ce27db3c063e87a1fbcdd55ff643f086107075d116e106242c39cace358c61252661f55e7b2bd8cf83166bc9ddd38d53de4bfe3986d8ded3addaa1742f1bc9ad8500d4550b792381a947bd27eca6451bc533f40121793922f26979ce42846341145eb3c3bab5d27dfed9dc13838eb6e71ce78e355be10b59915eb8784ff4ade4c14efd3232332679a96e8e5bf037833eb00cabfce923db00978ba3c7d0a118f3062de52a9e34a4d9435642f53946069c5f4ad0c31835857ce396b40c1137b021aea623135a88545d00dcfd406596bdcd64e70dd5536f556a2b9bfb2c2871df8952520e3c8baee9ed3505f34a46fd524d246ae8b2a040ac572b591a47cba1077f71cd143c6ef023a4ba91a435216b73d665e6aaae297e21c44ebe00a0d8491f4fcd927b33614a242f2aad0f528328f5d0fbd88160d3d504e335fc8001bb5fd8abe237acb13c09325dae180edc866ac9408ce980496a8e18bc1bd6cb851ef93c46f4c79dbd53064e2f34fcff92dc1c132c57854eeffd0e99c57304420d596966f148c61f785fb5fa1500d2418196b41062e59c92410a77e1a2ff6c51013be522fdaa26422913ab2fd517f4f8d192892c6ee79e7e9a5f9fd9227e3f8a0990e4a9e0e453efc750e011d0bf26bf101caeb175c1bd0a8979f0ca98b0c4cf834f9dd2fe6a046cb4432339dc645e81aad0caf7fbf4c4e7901b4a62fb5f3a635240b45d81eee5b963f9e71027ce9415369d60fb55082ebd74d8d0c3858885a01880aa982a6d9695965e38b14e97ea5d34f048a2abd0df93716dbfcb710d530daaf489eed8dadf70e998f894106726168c0e6f0f7ba35cc1d10cec7cac1ad9723dad71d52b05cd6a95fc6f559680889c94219abdf4f54362df943f76c61d202b5ba3201fe95fd281b55305537c1a1040449bf1d81dd043849b3a6a0cf4d1bf395769d84f34453c730779c952a1c6c2c759e66d348d9e9f964a442e5e2eaa5cfe4b885ba9741fe6f97d54e63af12902738160f819d93ee86565848910eb3c66bf083e7be3f3c93b1880e4027317645b82a7031c3a50983da8b30c0e96486275c9d5b743e782011af249449acc67d0fc0f18b0c117e003acaa8ceac2b26e6809b41c2a5048920a5327fa4bb66da57c9691bd31e2ccc80214771db395cc489f76e212a5e1444cb668b45eb1752fd0e4e5e7d1f94b670b9d6c308e9978add3787929dfa3744846d7fcfb7416f31f11b943768445e27715658478b9d927d2651bf480a2ee1838b7cae920a755502671c7272cf312886bf9cec10f46a645da858be8040b63a883016fecf1e5f397ab5e143e5873bd1bf811fa523ff2bf693f4e753a6c7e3a7f430acff693c235320443e4c64e1c87f32be92650b29dbdfae90c6ae03f60b162605359b03d0cf06ad37011161bd8ef2cb283fc1724614184a3aff80028c78b9d524279d8e284b21c6d7aef92d51533e1d366e180e489415a0164e1eb849e87ca42505ddbd602af0a2ab822ee9fef548825fb7aa4cbe6a8425d1761aa900d2bc633e9bee8743ea43c5ff99f331dd07c5dd67732d21166c16d449a3b93c8d50a3d8d941e1224713e358b148f64984f7b360138a02a86f0ebe6d5ea165e0da41b007d92bae934306232a3773da9583ae8d16a56c242346a6d7fec4d885037a68cfcbed07e2d7b4964eced3fb275949be6b72566a95ab07ccddce4d090f41efe00d8bb62829a3cf2143e8a339f6a3edec1dff366893e5ccfee00cc0a700675e7e820b075111f2b980c34856927238e223612263a62b309b2c376a7ffdeae38a50b0710fbde44a1849a0a5e7eb86e81c41db59907d5e95ea1c6bf209581ea163669cb788a45487e74e9e8076341e4ef9f88ee6fcc8ea2fb552c469f2b9d171285fa3c22452d1196f853e4e0cedbb902f00d8a0317de973aa7003253b6b0cc9de9f99e7ccf21d87e8c3ec6ef41dcb0ef19fc8a4a45cb6c7334d523a6b86c261fdef9604efd66495c49ca1364864e17114c28a42348f7c69da237c9fa03fc559ccb34e0c07965c19111e381928f105186471211e08c25bccb3eef12655c83ca379b502fa405838dc800625c085f3c6ed5bc55b60102990a4e745d2cece0d5f506bec0b8bedd71ab94a0a95a383ca1c105358a762dab7ff220c61fc2482b7a47a1f2f919928a1ec4bc42119bcaf9ed49d7a38ea6b6b77018db5719f9e38f2458d1016081f1eade980fc634bf4acb3392499be024671a2e110d243d381d01357d1f9368490a43f48b413a6c0410d082fa0937f18e901765c06543c2b6fa9c5c961186b56e527275b3a03951a6c420a60a87930581cc915cb86c86394f38ae45d898d46e17f58dc7ef2137a77ccf1a304ebf10f50b11918627d8a158b4db16eec3bbc5ab9a184b7109bf01efc78c9363e2d7b871cff551ac89269ccf041d3845cfd50e74741beaf8e7c234e70dcc644195c655fcb2a8196637e03f3d7893df6b45fb7ceaf7d6d735b97bdbfbe107fe4b62be1cf53e9226912e1efbde3a3663d61bdf9cf55a8cb3fa5ab27c4771b32ecc671fff7bb27d2c46377bbe1987227d01f56921f5a9fc006646d4fa5753a4e5e87dc33d3ccaa23e6ae0527bd6e1e2ceb0b2aaf7ba0010a38ec823234ee648270b2bfcf3e07517d4114012fccbf7d41a465eefef3cbae17825d6c292d63c8a65d133c691e433e3209d85c2bd9d4ec349ce9a9f41b22ebe2587172338f8c28d846dff1e2b4c0a5e7de4187510807c2af1b3c1c9c46d3c1be30e9284cd6281aa75a88d344dbc1fe29ff366455e3785f3017437246d1b2e45e14e7cb250240d8410879d40e1bc52967f8030d3a228f6b1ea2aafd4a085aec06027dd5f42dedb7c7dfcd5d53eaacd78565f3e6a47f0b36a155ec90d00ad0818071a511e8ea1740bbcdd5c6a8cf76b79875f556bc07a63abfdefdc8339f86ae70f63f2ed9d86fd2c650b67491f9c5393fbb760e0ecbce648dbb16f0f3bed88de7ef3e8d972619e4ba8fa55399ac25dad5363ee285c434f6726585351b709e44c46af06de18a75da86b9132680d64b438b79f83c23542ee4c9cdd268e606793a7f9964181a2f0c44a54392cd56aa39527db55b335f2b3fe86b0c20ca17c69989f88a8c86b4b479930255c62763ff0149c7d90a97b9ef44b21b169a794a8eca4939f718283711ecc13552ccb18264eb97bb6897add9f7eeaa6cd75be9038809a70723c2310abc7fbb2889274c4f7e52b49b8c9abe626e7b4fa5efc1768f6c92e21001e0f643b3b5bffbe456bc920067bafea26c079ea0086cf2377bf4d8733230f4bedebd0d34b915524f057a4ad33a0276b71862aa9e9309004662e11c2ece8b3ce9f03cba6817bf66b70d8a0e86f995fffb6db2515478dfcfede554a9b461d457cd41fe9a874a0294ee5fc76414b12ebc519dbaebbbda63737a8fcd93496a772d67a5bd7f6b092f65e4dc8355d48ef3f1c2aa3bd4ba9c0cc36558df53306b24d1a67a1045f84b4db8d46c75c5c2864ada62ca13dd4d4aaeae55b32aa0169a53843a37b75ebb925f6735179390ef2fdd0517ef0b0d70558d2443dca7e0ed7008d30bc201d19802dadb8c84d55d971e30dd5a78e6e9c798719ad35035b28e46eae0f3dfad15314d37a2b17e804699eb28060f151bc56af3e36b49c62bccafa104a910632b43cd04a77c39ac04784468f5c20ecf5107c7d7c2dda97da0b977cdac28bcd6c9625c5960e5da1e1167ac3c9f51b30a03a550b58a977b1ad51dac8a38229f386d1ca50f555b4af7f389e204060c76bced54bbf50d7382981b5b8c953224a63c916f4819abab6f872170f69b96fddc169f747d9be9eef2626ac86f7d235b13a07e7250dd90b7786de048d66aa7bb94069754692d34e7cada10a2a7ad55874fccdfec3f89bb4443a352479c92baf3707db80188aefbdfb8bc23208bb24817d39fc98473c71fe70c1cf4f5f4ef09a36149b4b0e8d3d526dc1c70e63528750e4da92265810e8a90a4305c9edb8fda14e25522f3774e7ca699538c86a4b57548f1e85c52aa50c0cc4243684a90bb3435cf8e21cf4ebbe129157e856cd802e7e25aefc3e45c3801c7310c04325611c9676f5f8c616f90ef9386a2d79508eee1eab25b5e21cd61b8d10a05d7d992b8f949668533f5e135ddc68b59111aa40df49fc659448794dfcbaa53953dd7833d54ce397913c489cd8cb635f0734d860e3c637263562bb56e019ce6bcf0085add81ad778ba8351257035b70b52aac202f7728072af33e047e3fa8b2faab79eee6e011f36130818611d1c0e57f941269818b21f5f9e96a17d3fc46abfea0fcda35b0cbbcd7047a0664aeecd60e7c633872cf6b9c1f13eda74c3a9459e5048ea78362c8e150eea3bf4e462da84e9d55be513eb5de54c3d51a1d223b4db7d502d73386f1ec3eafead4b5759a4977de50137e609380210ae7f8f66418b0d984e1bb4eec40acb949aa8e49c00108bb4b5e54e18938d3ac6206aa98b29880dc0c37e5c9ffd4a3be0f7158383d80985d207a2744ab3984d6bb2b765b6d4e25b00815c247f02ae90e19fef88cf087aadd006151939c1422e9d8e5ad2eb1e155ba288cc6218aa95a6bffa06506954f1a48e7574fa466602b243a82486ad47c40c4711ec2f2a26127ae3af3af1ce7a40ab6fb98882787779882b5a9ff9199ac2365e61a5a0fda0ec760dddc4bbdc8b9d12f1232e4956b4104c7cc6820c3809ea4f4705fb38ca4212650080abf55b788a752a04ca8ce282ad778ec5f0b60984a9f49d09b6faf4eca09f52b1bad4f1b5fc4ae054f5a27c299a7a2791321b70fd6d4a6799c7f2a5229c714371b352778d257afbec4829ca32b8fc2d01011d71057504b84a09e2f93a3324a728328ea468d06d1f2b73ec9a1d9972d88c7ab10138d89aa99b664b247196eb93ff83e66f171e4b3c6da7d1effb07da5fd02b79d3ba443acaffed8dd54b6593deff8f4a41d6cc1c01631babdc7ceede0a7b9b9126da462bad89a95b87bd5fe0481af0fc4785f6c6c988ffc94177ad9e44ba345adb51e26e279a4b674972f7917a15e87ac9759debdaf170fdca77f41a62e8b0dc94d1d1b34720ba97558c1b9f8d0753e90a55a2bbfdf0936fbd74041c73d1ea7e954e307a9c3f457fc83268f53dbd3024d64da78128afcd205905941ee51a59dc903bd0acd8f62515a406198cde1922bd1bdd9579387c85362ed3b859f642ef7cae1801b07ce0c59f92b2ca0c3048f20e539686f4ef54558f58316818c97af5822d1361a60076e2507d1c7bc98d2c5ecf8db38484a3f0e1fa369abae9ded81d9369b0e9ae27660cebc425d69e0207330a81643f5684e973288c1647a1118cbda9d0460e8253bbb91a9ed07c8671710258ed3b16ac2c1c757022dbb488f62e9ef87a0a755485132140630b4b945a1d3cd06766d7ef1dbf8ca14f8a563602f4019c86028c0e8dfe0fc8db447a9f06271bd2fed59a0b69e374ee721570583e72fa8cbe7101ab62b7a2fefdef4356e20e09868d0f5b18c23f51a140895d53a27d00669b781779a54352cc5297d27d228bdceb5a00bf9f92ccb942ce069d7f58083adafe10438a95ddf08a58c6d91449a99d870f46af9cf66ec1769c5a4b7e6b978006650e5705344d9fbd35123bfcea6209ca28eab46cff246cc3f971cb0a9f3d687fb2924078b753982327f6d483c4c1f51623e870ef027023fff3b2e8e249b52fbc79cadaadc9ad7802f325fd2fc4a944e34eee2fe9d22d20bc849ce32f42c276c362cf60a6e98f5f1b12aadfc1349fa4d6db9aa8eb33ad6c5d79a3a1507afe730f0ac60a1e0fdb3e9458b3f639e7eda835384c2c918b73e4682a82611e4cdb5b7fa88d9e10dd3e88d965109a147b4dcddbe65476fe244988ef306a8aeba6adc2417556eb6445bc9671a2b79eec3e9875ecffcaebf2ec6e1ed9cd08b8238cee11e19f774c38540dca18f6ff06a086317e25175f59aa05343ce9afb206518504b40bcac964abf0fae7205804573f658d662462042aecf4970c998a27d2f32e293f4d056f4d3c43e2cc9796dc40d599dabfa232559f313c4dce3f497bdc0aa605b974523ec8e72fb23d2ae9a1a6357e26e02d9846844a4613b1c6ea972218a2279e6e3b855a90b2b00b83e7477df5d8e44a7b339a82a19c8e8c7c900ca0022000823c1c6e3cb1cc5a3e75d6e1f526f4af493f4324fe59e22b093442e15fea929436d685728ac30afec88e20f2673b3cc661d9d5615f08f7fd957642a5d78d1048eb9059c27170978d7acdfd19680bca6a4836e5bd0f88c619e1c6c67298fb952e6d779163e1df49a372855b65d609aae6b245f550f2a81707803217126672bd2131c17c8c4b0b682471b7c510c0134be46bb2307d79f17654b84795ad636a7de7e05e456db8097235c47761d2b58e9693ff99b80fb8513f00e980410000a23ddf6a4a8fe794f45022ed87c1ea52c260f3cec86c36a30191d0cca59baaae3948366645d51174e0dbe3789284ee0fe345da566fded1bf202a79e64b7aac07af3b02d0b2777103c89699965c90108b010e895111b794ea0592c25f647d84a520df7c55cc2d9130c888dc34b1ef5be1a8e3baa5daa2f4bfd908b02dd94d51eb342041af72fcdaf6eb7496a80fa8343598479691577afdc5e8de8d16ebf45d037d6c4f13959772dc2106afb9c7a2397dc08450a28bea33198241ea08a645d30e2dcf07513eb2aa311f6aaf8dc6a93a14ddd9fae8aa5f7be28ab20ff3e7ff5f94efa9579b1f5a951933734e44e73f5c9ab3a8658f7ae1f308cdf2ca6e67af49fb9d7d8a63831b2dad01b725fa00adf2d8ab266ef36fc10d3b60d2f411575aa05d34ab04cd49f8f607b1c108281384e351e908a4f2f966f04ed3645fc7c7afa5759d53bdd3ed996d688cc54a567d191af9b787b22d6ce6e8073e1e51c537176f7344824d560491788c812410c3164dca193016e4b27e53cd29dad0ad19189dc11e9d02cf7dfe70eb1e943a1d63ec5330b4b2a8a38767d0d5263258bfd8dc1a1d7c7abef0fa4497dd80da8c2fba6c0eb9c2dce3024960e1ccc9e854ee11fc912bacbea1eda82ab93a1b54ddf5b0042010a9c90bc372fef356e769d7ae5b47c880d613c1f943f156fb22fee5ac46c3cf5f9a4d6a8cfe49b84a7e92ab316e04710f131e7e50beaeb705671c82472f09c2174a0265485401d2a1f9b9a38fb5d58b79dc782db90dad0a9ef4f2f09376f678b67bb66bc094351a0d39794f2364d890f43387d9d38fc2825cd1269e33e0d6a2d07929e94b1e37e58c44c804d368499c3e8282b0da8799cb7a1f0ec125b8bca2999967ef5901eae38b84779e611cf64d82e099f06de87624211ab20f941d6e3336c8950b71363c8fe9a3d078bd95623f9cae786c4e6dfb6ceed51457940098321b2474efb4dedba718e0dd0868fb7523e98326edfac1d794d226661d35fe43a991ef90c1185ffd486682228d7fa891a0eebbfe17bbd4dc647ee37760f90b8eadf05c81c94abd2257de1d0f586d5679952dc1fb54d331df63845d5b9e5ecd0f50f6c9531ad65093d832353a54b154b0ee5807b142ed0d4d8a4abe5107a053a53e778e641702141c74e6dddc1864f356c09f12277beafe172c6a15f58381fc21464bcb47021e75d15257793cad0d55d118716d04aaee24197df1ead9c896c9a3e8b1298ef3944f87aaaf34d7570215e9a21579371867233417bcb48f0c5692810b839f714ef5a097d6a18dafbca15cf0148fe13b225b5f75a8e03f9682b83c572788f0de2bd3d887ff0551ca1e6d1e0a66ed92359c713499de79828e8aa9491a7cf4359a5216609bdb1f21198e756f5b98e79d9f6e7fe4b9a17fe1e90d65ae15040d6ad4a546d1502c0d25c5d7f1257d6d70650fdb5cf5c690a9ff4e26c9fa3e5bb8251dcaca7610386debdca378f9cc9bc978153752d82b7cff2617d87756b17513b9e240058e0ac724ebc73c41b9ab5a5d7761d0f116967b2ab9fb4622f67513aa46c6d4da12cdeb1c081a10ecd0819d0b9a4a4dc53bebad9b699941d99421f4c60b4a0e4e782eecbd9ccdaaf6869589356c34a3c0879fae65c267059ecae8eaf0fe01786fe64098b9416e116923e13a50f6ca89f4ad08321125dec60919a684abb582033758d177371da4063d2443c0c612f4dcf3b21b8d207e62854b2e0886a120db959c0d5cd3a7a2987302a7d887bb11f5a7651e3945b1c35147a4e9ba17823853c773665496f0552787f754d934211c35bcc85a6ec67d37f1dc664584d1cfabe540a52b5a1d0addcb574b6c1879e0ad7623d429055f5e960555f0eb7d2d16d41ebe0661a22bc7a135e5c974aa43d709390a91d038cb11ff6855ebf94cb792e14e9651f7110a448fea6f134fb7fc1a985c5b7642c0327c45ec1d7120afc13b40f52ccfddaabb21825f750204652df92960c9cd277ecc35f1c4f0649fd6edabe309ac22121142b18f600aed33f10c14abc33533ec7f65339c4760eed9a10860525586198a82ccd89cdf22e67ca941e8082e997bc6839606eb56342d9da8d512dd9c33380baf3a2bf189d3ce32408f21db623dd4ca88ab0b77a3e7015cd2d12a9fedeb52bfbfc5e304e96c0a674fa9665405b38e167b9c2262414e6d216fa8b64603d981954c9d801a60aa3e82811a7b8bcf040cf8df47960fcaa0b79a97805676edf5578c41d790a8bf9ceb5b155288f51298a438e31d15c7bd8611c41f3857f0862d467128eadf1fa4439d67b18541722842d60f702d61a6634e0bb2b4c8b35e537a96022c5ffcca7667de3cb6c1c659e4dc1253e4ff6114a9973f2a2f9eb54c7819146a10f5110d9121f03794708c12b38d0b1ab04c2a145bc64a757daa614309c21e0d8f7ffc17f18a8add2289228d6801f53fb082e36c43f2e0edee01ce099e4cad9d5ce160e0e8b318b66bd53ac9e9ad2a19fb29c889264e68e8ba5103b0b0bab875fb7413cdba3bd104474afe1e38497794d4aa228351aed8fc2fb5ec380879f7bb32202ec8ccc72d75bd768e17c835cfe7305e2e1d5759393bcf66213187eda7d6014f300e790b7cace69cafbd7fa4773331eafa72a369ce23a6cb82f6ca7c5f8f9dd161f3b616d893d173bce8532ea1d1d1e81d750e95e3fe9b77f602a0e7cebc7b503668f6a1497d94a8f9d3e20c6c9bf7ea6f36e55e348f32fe7f8e70ccd0bbf1a83134756824a7acec49ffba598d1e6ca28d5d6ea2cbf2e4c4d8120161314331526112965b2c4052fd2ad642d28a7f0c6b161d0b2d23491a83285dc9138f878dff18d4327625c29b3203d28fa9181aba7d20b4e2d43c138cc0d2822e91722f1c83b0619e6100ae70735b4ecb6535ad43085987667a3a6d44bad8a475aac1e207ad1f96591f7d674e1c30e8f9f4bea34b24569e374b1f26e25a82cf7048fbbf3f27b2ad1325fe24104315171fd23a4a11316749f3565f2dec10c4d068834b8c67fead55be8ad48f8b52159ca010cbc6b314f518ecffa73ba499d1c628edd7f99801f85ba735eca02c4c10539c9e228f39a3acc39a3d77599adbc0c3abcbbef092dd796a9a0c14c24260c3be063ec3bcc1af5b84cfd0490649a9c36813545e653e4b14145d2ac52db22eae96219af7d13f34bf4dec5a58bdae4a30130fe1d45013b40985fafdc93b1ce3c504e70cab756988a291002e581060d2c45057320dcca1f08209dca7d8f1e98436ba3fff95f64769f1a6ba3f34da94ff06fdafb5d923d77e5c86616cef6ba99f91093343cf27729d06dce96616cc9cfa2a5d233346ce0a2d9820cfa1118c83690e06eaef4b8497dc1e7940479d21ed67e5357cf36863875dcb15100b70fd95300e9a096edc581a43747ac65ce20638022574d99c6a6e607aee6fb0f540e6c512fa4ac58a4a9d06a97e967386d47520d399756d98a96c4ecfdaba1d262cea5de480398a5ca4fc59e1878dd582f49f891947a4bec85a1adde241d0aa43c8328870b905e7e131b7220698b34ad667b69dd73274003bd089dbee0040a77fc8227e0cd8ab7f16ed11019792e475b6404873e6e505c85383a88bba5db81d49a62fd8e172a8c1d0d1abfc4785f212ccd9c9c34cd66e291f9ec81458fbf2cc88847192757da4270909714e4bfdcc14ceeff5fbee86d42638a3d9af1a583d062e478b96e6c0525456550560417e93403624ba31d82eee94ae3bf39f752f77c6624041c7a94c50cd05c34be6de18c92cb09e601a5acf8422847c37fc81ad6a50003a6eb9405decb3c0c69759de6bb3063198186750dcae6d89e19ddfb8559025a1eaaa05cb7e2801d1df53f334cf073c7f2cf6ee19757beb9d802065ade506f585f0f3d08be32cc1934130893fc6449f422643ac111f612fa080ac1a4f511d7c2fe766da3198d0d8e5e411b7abc773cadfe52563d4b9602133af82543ecb2d72c3e19b3f4aaa860e828ecfce000c87ddf0c0933c4771e4114c6251962556c773f6781edc1bfe31be3a75c1d18979456d35b74c961fc31b1d28462f7281a419358f7411ec47fed2cf4926df51967af28e4b0db26bf16e461514cb95635b54b254569776328d8442d18051ed56d539f493487e768169ef214d53838479c16553c2248766fb4fb3e068a88a138220135538968a6baed839bdee9783a9a21154b041fa8fab3a9c26d41665cd4eb622e95d20da75683d45f3ff515706a4c965210c9c529f4ec33d898cd3c02c94b2be2f9ad792939daf4e2853cab1f6c3148c1f0423121f9fa47f16347ec59398bf8c749e2c905b6b5abeab73639eed2f193855d4f8a900ba4a7e29bcf47227f4d85718f46424dcd5606fea9e0f0db6f9aa6133d1e977e736c88581f57c9e20bcc6af452227b8c8d320f7a96dd22278baf966fc480e25d5070c8385cf3a649d18db412c8bdd3e10749005fd8f0d1f5e7deddb5267be1c939f671202e5f2df0f576e1e576752038685063ea9ba489e91aa8d96c25339a4478","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
