<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c4849bb7cb9f7051cb946d3fc7f1b1f79b599f2a8b70cf365396b3382c2ede9595b2d8bed7bab082ba4fff0d4892892f3bf54c541a0cdd89dbe2a0c747196c47b0b3a39f91a42120acb758765d8b4f4998f05d10479aeff99ad5fefc751245f05824d15bd0a628a8784d761d86f795610f979986b121fa93bce5034fcebbd49d0d46e605501313158bb5b434c6edc4a7791f7762e7a1c22d975f2ccd67ca1edc348115050c9536745ae894c8b132ffb5bc37c576c23caf60f3a8e36d2790ccd7df8e81c477138a94da79aa27bb89eba5e4693953b1954cced5f03d400d3ed22cacbe4dc84354126db05ef5455d076cd58e93526cd7307ef2c8d3ffd4aad57811f02ed901e9fd512b9e390d5e2f431d416f1f939e77477ab79d1d40f5abf5f7db81c6ab4cb1bc74665bf4913578cd33c0d5b6ca79b22d615e37478425e718ef0571169e873b361891aac6a42f82984381e6a89f7f0713a0d6176a156424e37e469f73726ba4669e4ab2fae09bc52eaad27cc72a6a6ef646bec70ec31a8e87d37285ea23c309603b9e15e5de068493898dea39dd04f584838763c7da7b4ac5c865b01acf7a2dedac1eef18d1b047dd69646ec412b8950271e5a761cc798cc33b55cfef8442280c3a5459108b73425d3c921d2f9d666f611ec0e8bca12259245eb96be2e222f12e6173746b98e4e4fc0f01f3a50c701cbeca997b75e1c3b90e5e0b12b866eb074b1bad891370b53fac208ffaee2dfccda1f98447a8988c1f41029ba1d1fef9558f9378b241136d26f49ec7688b510dee484e1ab13c68a0ed4a77dca480e5f739132b951c25bf5c1262366f2c75c99af2d224b1705d4cb0d6d84d7c44fcb8b94f2ac768e676dbdefc43635afa49c43ff31856165f9c288e3db4563cb6122e1413c9ac5b0609b8d0b821716c2be34b7cbdd3c8a96f168f4ab2ca6f2069ca799b0c645ab685570565f3bbcfdc5611bb8a1f6199d5c71b91f238e58b57aa5cd0bee9e18abb2750d2a3bc21e2e74eb295275370943e0eba13207a0597d1b2763abc0bf035a5eee5a799d7ab1daeba587e103332808dcac0f8d6445941c667be45535361b097ac28c0f9dc99676364e91bbdba8cc8581effd25af0a8d35905c26c44fe30eb3a6551783c82a6a21fe61a0d74225ccc6af42090053267681e5ca023160f247b928dcbb4e9fbcebf96ccc6bcb568027e491264a58cfee11df4568ee2ea56cc06c86759d9ac163afcc57a245f1d687b598071366a733845dc10c48fe0f2d842775d071b6cd26a84914a7fe56e50d342fcb1415cac8b72c301d634a6a332beb485e890b7396960a892a9965f2d0338a145445e082fa3bac63dd20f9a09c11aa7cd925417dfc7a127b5f257560d67fd59b7b7c0769d76f6b4f65fc377e68b1375fa5e3723c25d3637ad04ae82045a7c3cc8a8ac491c368d9ceecfcd1b80b613113e63e13bcf574beeff7dfb6efe9bf66622ed6b224a277ef798fbd8cb886e83fb582cb7646db3f4f3107e0b0c1c6d819e89b92b1b91f08195ea7666d4d5f9819813d89c34023f3f2184982b2bd43d2397e1323d39037deddce7f2fbe374f0c0ead270f0c78decefe4611b74de82564b74498be06cf6f4513ff88486641c4c93dd9af3b1da7e309017fa36dee994c2f7b2afafcad995d859c0006b69b3fb227615a30a86e2f4adc5aec236e7ddcbf72aa57e95a52041d9735e0efd725fc0de54181bdefea57512dbe3ec7eb5a7635dd3dcbeeb3073533086e723be1be5dc2a70a92bb4c4d01fa0d92f47333d7642f9768b034b640096666f33c87100d60249750df2cddcd70beadb002f9b51cd3cc0cd970d5fa350f387d000b96fad9f139c633c22b19bfbd56e7618f631e5611ed42e4769edadd91dd3f52349e291565296bbfe6e660004b0d93137121d805e1ca808a48517e23aaaeb5edfcfc07f04fcb5f5a3ec51308d60d754fbacb3cc84278257d309cb85b87e890fd2e4b78c54138165b189f5df497598f104cf242fd76802b5975c5d6cfe7360ad5ed29151d0d6d9462c2589658ddd73c11008c9d9ecb6c463f2f3fca467eb610e8347fa9802c4f75a74b5e690be708a5bc2ef96e77cf9e10f6f6c5d2d261e3381b487ffeb4b165ddca191fb94cece8c16f4dca83882e74cf6fa02b6d5e35550ecb560169bdc4e748f9ef28ee7db11ae7bcfe5237146e84deae83992218c666daf5327c2eeff411b21b6b479e5ac2e245017643bab5da37e9104fc7e371a63d74bdeca4625c5134f6c3ec908a7f11fc9b0915544dd242980a06d2fe04bcb6f67d9e9bff54c78bcdcde3960e4ed9dcc302a659b6b127da741e1436a589b30762f14d87b6b088fe2af7def4eedcf0962b49bcbd7bc22ed6c4a3533dadfafa6851881ad9940ee6d8d4791d704a2eccf6dac89223b2f2ed4315d96c6f5f33833c482df1ce2b065926dc430e57586e6b64cc29528a9ff0c60cc2428610c39e3727d5fcb68a5f2e8698bcfe785e54e4453f47be19546573f1da59d6320bd4ab953da2bf6229b39afee4814a2f80e15c5ef5e2c59b6a3052150cbaa5432f7ba242a7091b852e50ad550920c1b9236f830b7984e9b08a29540bc682f5bcfab230cce2718538153b092f9763fd35088e169539a2ed748d5b072af8189d3320e2313ee24d4662d2697d665ccf4e0b1531c1e7fe6ec95af034f9d52163a17e7abb4e2fca5357d6a75367caf90b586cc45cc5adbb3b2355a3ae0da692e2a81dec88c832fd272ee43e0e13deab65e629d73d1be155c54de465447d6f24b6413cd0b8138e149faed2036da477a4c9d2a994c3db0b46a40a36e53138f30d2765df86f6c789d74ce9b15f8096f6d14ed17631c8fe806917defe38d9c91e63f0e0a0a1ad77a6ca1c5a5d32d8a665f2b40308255a213acaba9dfadd2d26542324272829a064347478bf30ebc3d35e66c4c883b06d33b1cb4b626b8d3a42f32e31e22aa141bda1b5833d2fe29d5b3ff24d9b491c656a079fe25eef142915559617c4c580ecad5f13eee7d2acdc97be2e6b30ca792f8d9724effc01ec162f27bc92dbced2ccc2132d4e487b24e1856de523c03e420ebb25ca1d3b1d87822a103efb03a6ba673be1c2c78cd65712300c1415dc2c3561f40c6e73629a23631d86a7ea6db4a79952dde39fb538691f836af39b099fd96161d53163049a31dcc1000f73ae3b125d4fedf2508fdf57fda80b23771dde8d3e8451e334b6677b005c681e3f7986eb0ff4e0f2c36a38501fb653ac88aa358f57f2f416de8ade1e5e3e4ec8b309d52400a341979a04a92c51abec1f496ca9052330d9d87de8595f47dd20e4b6ebfae558ecb06ca77f0bda87a99b9ef4ed3875764ba35859bb0bae9d81c3e148d71286a024eda846865c7c1309f41599235696368dbee6241bfc1c4d057a5dd8976060937eac20a9f5379832e7384f426349d0e0c5eb44d7044937cd261cedbd557e8c3996ec426e2bf9ea10b878f0278d0eb69df5ec93c952671c680ac00c41c2904607e286c2d8e6fe757f7246fa4431afe5ea178ee8544c1ea2ee54e0851354e52bdc4b2071152538ab69a61de423c3ff42c4adf6d553264eea06064acb53012dc3db9b9d5a6ffb04265ae829bddefd7efc56139878379a6fb6ad96534564e815e669a5eccbe8c1cf717cc7bc32bde004e2e79695e73702ed8ca9fdee932350c60636e7bdff83264108eb6192f1179a00ffaa92c799df4efd34d01b6babca70e16a1e905d20966c67e328895b3a601e87f06c1d9cc4331974ce7132cfe9780282cbb79a805fc4aed2e959fe82ad856bcbcff99b2545dbcaf5b31eb277fd1b04e559a95b2856711b23c049ba0620654a3978c00dcc65d4bf8c924b8c8cd99738a2c7de053d5e17b0973961a6e6407db641b51fefbf7517c456eff6bd5697858e7608f91dbbb90c8a55e0b7f5e218170312ea904ccae381a90924a6e7b1f590e8c3a04ee0c8432f762a691d804857241a2b86b33b7bbe0322c317ee6d9e0ae5a34b67553623bec5e69446ea2885e10b608532a5aab80705c49713584765ac09a7d1e46775395c8937e6efdd35b624b1f8b111dd5b5e827bb441760399e066f2524fdf2ff2de21052053156feb81e0ef65ba4588f8ffa43b35bc8d53d72fe5c66a171bc4d583650879cef95537e8aa48eccbc6e25dfd38abd1a59244de5618dc7483b05934d97735789b4cb02f698c1e00fe52c99b3fd2eeff8d555dc8471e5e1d48a487640b5de9f12ede467b26e4ee1934811d7119f06530196a09f2c5d5673840f952e68bcd6b2977a3c11055dc282181c59273159915727e15f732c11dc9196946e45a05d988612a88c5a3ea0d6727cf1c1fe84baafc5741663dd69d208b9717c98619623ad1ffba6dfa09c17c004c0c1a229129f9ebd4a514114363845ea1125afe801a6ab0092ce58ed7bb9685e69b47a2a0a9150a1c619b51433ddc1f419f4ca00bf45c93d0fede3a81b4a2cd186c6804fbcfca3c3cc0de27c1bb4b9cff4f67026a89fa7506eb5b809648b89c91fb472e31c33de501ae9aeac07d9478d6b70235d28618ce7f515b853e58d236ba697dd187fc2f9527faeb0f6e3f30c6faace346e7bc73ff17a83016230739cb9e70647aa3288605c5a0c8647f83cd0c3469b8678d8d080f93ec68606e79b48165deb0a978e5620f3ac8775866219a94a178504f42e1b5569dd00c309a09aa8f1d8dff620b619bfae2832e11afde07d88924890e8f8cf188bce48cd2e1b8229d33f75a7b14af9c123a319992362f128305998098d6159ed1dc8667c5d480f50e9fca2c75b76186f830ba8b4097c2aad68e168ffcfc0aec50c214a3b0b9352c45b46c43273213fc95edb2a11959f1279a8210277c708aed8a23be8a6e2dd54a467e9c5beac94fc154fa30af74844d9f088636e3fbf3f19b96504780bdd78d59eccf8314d072cd80dc89e430df4811c24d869db5dd8eab51abd3b4e9a7643f88a038873964224c5767f826b5199e700a1ad814d57b95f6c3e6172191f4a2ad690bdbd3a14af9c8de5b9058b40cd897303b99f72ef6fbd01fb1d3b04e18c99d54e7932d4e7f009001cdb69b1e52ad06ef5bad8619a5cb9de9ef9683555c400f6c8d4aac9e2bdd8451bc271e3b890b8d15b5d8c76466d6cb7cdc97915291a3ca084a555820f29e72de2f629bec4483f33f01c7cbef977974b846c77bd74c1a71eaad27af5a6df9a684dcc109160de8dbe280d9cd5cb9505d5ecb37e58fab1fdce381fdc690e5dabb338237ed0db6545b86e9cb73bd38a85bbc93eda299e6a4fcddac4e1da79a82e9580a97deed5a574d96eb057ffe7d9f6969de02c23d280f7ff3ccc8a84fd983673fe37b06069f02c44ec1c8689f0f6846e89b3e6050916c63f304c43462422564d784719fb8bfc2274037dfbcb2f7957ac1278947e8d42e6fc5331621edf38daf6bc7b30b110be9ee030b92ad5f2fc475fa2e78c7b5c402eb6dc8fb9f84f117bd356e4d8afea43b4da1b7634ab272f2edec3919899dcc1ad6adb84a124084297aed31b81e18c7bc32654369d514393a728939c06a5a32981913ffd152bcd1f215134bf7d40c86e9940d656e2f5162f4cef42c81b5e650507b620ee1ae2d3141fc96799256984064c4ae3dce5fe535d5704ef0a22f550f55baef855e8d670efb910591fac29378a198139ef984310ce955503dd04e04cf58b6d13127d26f2991151490ad972681a239cc7ab9503214c5e6adc14fc311f95c2e1e29a522bd6796e5b26aaa772a2377a360fc98e2084142cac9ac1853d6047734638aaa4ae8aa3698af25a194364ce7aec0335e31b0cbc50712f2d1af79f69866943397652833e8eb91f94c1885ecc75e48e74ac4706fb7328498dc9c1c10dd31a9fb828c66c5905b6617c8857e0cd6fd797dc75eb5cd0cb7efb0cd4a230852dc09363efc3eb41cd6728682be2ccf08b6e87cb38671964f3bca4c2646d162cf47706eb3644d3116616446334bdb5287a6b0803345ad2bf149c788afa863fe3e85937b6f0b52c5a9cf30159a15daf03707a38720c7a7faa193991b6cd4e62c69d439307287dc6b881ff4fcbc7aed11d3482842cf22de83f5f178edda87d7bfb21125445a7b72670c4bc05900787d25e0cc5d1c4890531fa3bbddc8e11a51dad8af745cc4cdbf06bb22a44a1bb050e53344e4a0fabb3afe13d6f0107fb77e1fd51367d1dff9e9a2b5b3397383451a43f829ada51e475fc2055969cdd53c0581e3f08b3dbc4b7787a341e9007abf9fd4b1f9b1c6c639cbd69440a03528dda73aa67134b985fbd21654c212695fd5061558d9a4feb1b4c45ff705e93ff72927032910fc63b00ac4f7946ce4de663c0a9195e249dd0aba4a35f8c38b86848a23133d4e5c6b580a78960002e8c311b37f21451f685101a2d044a3acee9235b7643f970e273133baca32b5bfcdd16c62fa5eb858a56b10931e512cf9545876d52ba389c5153ff98eb5a473f8ef26652b468aa5c1d1ac6448bb709811b1e7c802fc267088d451b8d60783abbb632f8fdd6d16e9f9e08e5da3f5f3b4fa0ce286c9f569729834094bdfb9a7b536e757b69c6c3de99d11d0ee58929709ea6aa1061c09a6382d7e52f78071447bbaff0ccf045dc917e027b91dc585206340577c051822eb0175699530d985b437e3b1a664325a702fa7352d1b93ee2ed70f9a7a41c78fb10ef90aebc7d4ff22046e9d649ada127fc14649d06311b26b28f9fd920adbb8ffa02c0301a5e9fce1382a62a3a2b2d05a57302771443455866d836f24b660fb943ac2367fc2f8ead43f540c57d801a40983e48b895f1a4cbcbbd9491630d7fe4f133fd89d92d358cbd1e606149ae4eadbefa1034c39c7623d8f4ada90651c7487e6d8e3561d4238503d4fac0ba8d0a19a1e134137f72d7637d767c5913a24c12a220f739c35d48265b22c04f003f941e0f5689326c7f8f278fe15ae872fa4e321cc9d83b12c3144be3224eda7a6aca0ab9b75e41a83c95166627d1f5e8524b5d62bcaa6ad3dafe6e7f8aa125538b872f385ad0a49fa6bd92acf39ad0bfa55619521da7627966f45874ef79e7e0db2b3261c34d84ad31e667a914accdccf364a1856dc2558d466a2f4d09e263ab701b93522c2713dc8a8c083915c5bfff9a6f2bd8c9c2e8d5d1822b1d1095512270b08cfc0d80278b7e6dfe85cc7cc9a93844c4176996e061843fb677940254504b4ef3878d7d9435edf736f1a626c275a23aca2948c5050c4a4dd7c10d58e0520c44d69bc1bdbcfbc99a939091523739c9f43896ebb409f5897c5c59238a2e1eb82fcde56ecf8b28e73e9a7627b9710bb9d8951a98635168a4a56f64fe1448c6d382f95a4a76053572e9ced8605220997be168b63d7e588dd8f8195b88dea84a9e29ebb08b8944407c2cf5325e0e8bd570da09a8da77b57b0c3c1fffe20eab2740fd4061779b6e41e8c7747440bb3eebe9cce38741e3d17a0cfee5095f1cb68641a9a4f81b82f4b383fcdef37349032415d49bf01eedf6afdd74db2d5879bc51f66039bdacaafd04629e759b40b4fc3888187b0e5ac258993653be5409a130bad66ab9d72ce7d2f8a25e806dfedd2e74a721455c135cf5daaa903a38ffe9bcd0ce10d4bdc416179d6c605a61013816af839d1cc6d4ac3cdb114395f05f953e463910ce25bdf863885a608387091dcc45eb056d3769b2b55ddcfe0b7d867d75b3e71f4b7f07f4eaa42fcacb18aba08b5600f4eacd760f1e65fa088f59d6a86bf458bf914754f94c95d97dcd4e524403553b5989ec769686b6053f548adda008958c68f4e99797eb0872d28a0544a66a9165722d3fe50e1559ebfd3a6ca2b75a28eb01c96277a7d0a65e160ffd4e8f6d78d9f1fe7c6a4705fe43f52cbab75e138690c5dd6fe8e5e6e5620038d652b780c2960a497011c7621336feb179b3c029e23f56b36e2843daab39361045951580e455aa183fc48ad564d2ece7436abd60589e49f010fb7780baea5ed5442e6116c98a69fd04f463e206bd5a40eb4a5125204694b42096bae056431efc653dd52067daf49a2b6d75d98cf59b5de1ffbdbabb2b783ab9868fc2d79c04468ad6d5a4721b56bd384f910c4edfd5cd38eb5fca5ec01a180df2547f2924a55f9a3970f0a51f7057268c65311a0f911fa51b2a94ef42e345c3fd84a208303eb2a49a7568ed0057689de15e33f0a1a53b5d7180f6902b56ad7cc04218fe5dba334fec067e63d3cbeb6747310e6173dd7e3158e8c29df2ad52587f8eb6cd2e6bc11448e3363eeaae5da17dfcb9155c228ff60566ff01fab30bb32d923fcba6bca7f88322a9d4d6964f6561e10322e409164d138d495f4e136a58525358fc86ad1451e873107a9f7e6a0e9724c0d97d0896a8de5a0a310bc840fab79904faa89376410689337b30bdd8530ef566f26d73576fa2d969a374a352ca83d21142c2dcf1e859f5a9a8142f67461175b231cbafa8058e2c52a6a5db753a52a13316540ebc7ecdf9f0d825fbaa0fdf22cf557ec6b4205db651d14f5cbf252002599d5c924fe2152873f9f498d8f8a89e566e37175814bff7ed4f1c54162ab144660e610acec846a3a3c2ecf158898e201c8df2482601797f8197bf280360fcc6c93151f04fd55ba270a974051bf08a595b42b9a117db1c86ccff0ae3621887ee6bed74b50920c622d8e4760cbb6a8673d524713596e692b1a3d81624bf241cecb1b5055f60b2d263a02a35078fba1d65dc2374aa113c4cd3f829cff9042f69ebbf3d2da0a16109991c771a88428fe900ad3a7de026895c9bc4e58c11ff5dae346dad6bf7f78ea5baad9b3c9a53e1e8dc67625007638f6881710b167e4eaf2261332d2e2d26606c7e8ebedba84febe4a02feb8d5d17cf5b8764d87ddceb4ec7ddf68e4696e10958c79b4b8b4e94840db7f3623273caee7eb591d2085b69b3d59a76bcb8eb459a5009f89eae145b28f5b5d0d7c287764e261826b99f3e8a34528d578a7cc4448d760a831a20b00a2165b5890e41426389f5ce28586b03a2e3139f85cf0b4772c0835da7054efe9f18fabd8c729a2932ab9efc405426076885fe07c01e0177161b973935b43e963a07b62205ad040a47b7377ccfcb320bda9b066a577b0d990d4ab226ef3b0e19e8d8f00455c1888699e410176af02751f621cd9c166c8d766b4d2b0794914a7510bc4e4d8505ec0ec5416742533da8f01980416265bdd81cf3a2361818e9e7c21bdde361699b51b9f1651f414bc866e6e7bf6125f3566039e571bf847eb67892849840c8952ef07134aa438e5b2b1bea9a13dcd504eaeef2293d83bee2565c229f90001091139fbbff67881920f6c56860060095c1c404c3a53db815c946ef210e4ab8b4e61e141de7d703945541f6a82e1b9e397891dd16baffa48acee43afab6dcb7f41fc7b5f91bb30b27595bcb4bf114b71a7e671063c2866da4fa40a8f94b5ee68cdacceb6e3e4feec6475e35c05a2d4504e0abff1f40a06c7b3337595c7af9e4f842bc43bbdd066e326d53d6ee802a1cce6f0ef14c1dda17254e635d4b091fd09e19c6324f8c7990f43d9007b9cfbc9a2205d2e8a52979d0e00d0e881f6b3b28ce84c208af32e20dfca8a3b35b7df1956e4b34abb0b581181a0138a67f758bf76c5b37a0a619201ed502f27b7e28da6279a04b9051fdf26d18a8f4f81d3586ad8a096fd1feb7c0940fbf2e8d59734f2e800c5cfe961836aa83f55e6e51f4255d703c1602a8952afee8253a8e24032bca785d9d704fe8cfba7b9e901edeae63b9e1a46fa52e8be7acd6bc3923e88121a9057a119b46112646c7bf163ddb9ba5e36170f4b4e209cc509fa125992a595ff89beb443ac7aada92948d8807299c2c885d93765e86b4eb1f937b3af102c3cfb341163ae9c9f4ec55b1d8ca58ae92b922e966e899c211e991094e136f8c153691bed46a354d86f22b87ff43fc03318bbbdc98c269a9c729652216b53e8caf700908409dfb227f106e11e1590c73e60b5dff6896fba22a1b10c68989417d858cadbcf24d1c9818cf7ad77f450593db6a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
