<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d7fc56493b10465b828c703a69719900ea21ed557e649d54b3ada863c28ea6f166da80e87bdf7c565b0e951e556b02221fa5db55094f8e7510b82703a6c6e1c57357ed155371b1b46e0d3bed5399155b9c14c80c29f596c7d7f82f8c6bc83dc8452a762204dc3e7bb2a478ef56f12d70b8714b68dbe34471099330c32537057851ebd858349cf83442365a459a18d90161fd54a9065340b6b1b12e7b859390c07d48508b60eb1780240a10909a27ed1eefa633316f86e562621d000c768f49bef638f51040ab534c3db64cbb39bf3dc175ce504b1751db56746eca47f1ab4c653f3a854c3718a5b4e8489bc9bc504f707df9e4d40616519e38f261b0927e493f40a0ce210c59678bd1fccc51da2de32dff39e3d87f93b5719970b08c1f50e2f99a694d3ef45a60b074e119dbed664c41fbde38c0dc4a7c41905e43fb2177f828b1256fbb53d6ef4d8c7d8b0744444ce8438d10f4fb8a0adc6dc1d319731af2eef9ea038975d20b2d474af739f05fddda4b46e6d6fe3920d0809c51c74cad111f546253df4513da58424f99dd54cd73de3598a1c7dcd3b1327791e4eb9d09610eab45adf9c513bb1c3dfe3a991065ca7f29ada0c2333d6d7aa95e8ee684780b4735e35b8a0b07ccb02139482c13681571f46c4c52382ae15e4aa87029a75e16232814e797c62c6d727bf85df0d395e495a297e15fb4849bdc01079f4f7f05fe9a78bc7457fc53f97a425d466e5a167d76c852fa043e72f6ccd19e6fbc20f65765854b3ba35942f838347c5d4185a7a84e78d7ee6e61dd8ea92016c4d7e61acaf3e8fd7ec42cdbc3d0dc711942b24be7d60957758ba8f25a86f1115f478a1798805fc5880b78dfabae0fb90979ac209579f7fd2a436ac72c42f5f1a77ebb98f3674a7ea88c3585840fe1cd2fd258df8ff660734b0c270637956ee1b5b53ecc17b8629fba8b36618137d9b66b10256e540c463f5c042e5e0b4ae9d26e4cafc503040ef27cbaadfdc22fd02bc98bb5a1464e89871e7789b43a728f2e473c4d5b0f9af5314aabb4456a070992e86e5133f08d24d5a225ad9f86d6cb74f4c6706828164143bf4ee344d5bc6e9be3d7f20cc236b5fe4999c43bd1e9850531b3d249c2ff557f164a71416e856c904d602852bbeac8af882cd1672be3f489ef87f485a415251790856ffbefcb063daa0e9d0eae31f3001fe7b3ea97aabcce7b65727308e8a9f3c67efe365489880fa13dcaeaa909eedaf18ec71dadbe45b67f8605fe0dd2b80043a098489775de3440a7f3a0e2a6954cc2991100778c10f3add9a8fae373fd852082382996aa327093e259442589446f077f56df2ef529122ec9fab9f9f95e5aa2653e64dbd9c5d4ae7ad3fbb241fb42954255692c9ac2e10edde4869d22ef76702d6a071b381f5fa73bf7485c2c915dbdd886e1cd2857eb7a59f509695f67602216b2551162448522874cf53283684cbb9793e16e30fb5e429790a43d4d05ca526ec20c2bf45d1182fdfd7b92ef89e8f19cd7d0cb9059697573f83c04abd8d7620b60c9c49a21d430b214079a083fc3fb10f7dcfb796ab061d06e214fd588a96c6f644907902f27d6dff1684d771c437f9761b6182e05957b0a12168ba818bd8210dc8d11939e350fcccaeb87105bd172a61f5a8afe9300baf0aa695a48c0d95bf9910c59d9e36e9c9089f428ab3266d711a84866ce14bc06b4d8992b0d1123d2dfbc7e0e246aa36b1ab90f567dcd999cf0131f2d7227669f3575f7248b4684501caac474ef37a1b97c08265454f035debc1a96641a74945f586d790c16bc922013950261146af2007c1212b1a66f995fd207a3076046a4f69e63933c177e18da8f8bf0d6947d3a669f23e60d58d07d0a484a3fa656e46f8068797f6731d6ba937eac6f6acc07dcba16b210d36dcff864ad7df88836367e34968da9a32ddbf71322d2ec3dd049ca906275103d0cea5959949729562b4f4f22149f1bc99457ba888f2f3457b9e8e1dec0899dfc28b46ef7ceadab73adb9cd634a50ecde161796db9a02795953bde594f845ee4163297fb13f6d6e2258fcceed42b729a6c61cc0b74889d52eb66e007e4fce08c5a08731e9adb96662bab43c221058118c6eb16cfae8a08997ef294b6b60d506fed8dbc5fd3cf6df8e1a4250b1259d6e47daaa557e3ae41ea3014ef310b98c8feb3c3060170cdc51643c35ad1e183cd3476e5ee0825aa181ea0669bed8c78d6beb18d4091fbde6abaa51688cc7370be7408303c30e1ad69695530d48241c1623a54d08b2e053136123c4eaea6f259cacebd03cbdcead06f93a9305a486c56d2d4326d8cb30f0529095e2ec462fc8472326297e41a9d2c8a82f244a322374438307dea08021871fd84709e04beacca8655ca43f5066a1b905276c1ff4975490b6bf5209a73b36728b01a81f224f0d45467a13823c1fc8e0567d29ee551565b56456e3f68665810b507506350707efb3fa77a1e39e12e82a576cc2a66e8e10078f36d7dadbbc2a3dc13334f13815a5963486e49d67b074931657b507e522db674651f2057d8ba79d48cb2c9861dde30089910a6c75a4c9d844c1d523fbc32c349941b71a83d13f152765ed14f08862af951c7de8ece772b834102e79c99437186fcf7fde182009f6e0624a58dc25cc27df9d9ba515c6178130c9abdbbeb7d0d7c0c349802157b65e7d7dc169852bdb434fd717281f46b20d2fc4ed8187e6d6f303f7b0e2307e814bc71b16ae0ef5b455669baa9467d3c1764f32d6297cb6bbf11d30a2f421fcea10227194e81ac1cc893f5b164b91203b4c9af97cd4bd1dfb642a896a4001febcc8c7b2e87151eea3e222d666bf5aa89f3c953ed4e4922a5172c8bf96d3f4907fe3633bb57259e1a6229f77604d8b8565161291cb675086c7fa0a19851ac356bcb9f1742ec5ab3be8efb73a86a158736d52a2d51ca08c15b37ffaf765f94525e46809e6337644f3547851e1cf2fc2eff914c122370e5c9724b569867b5d76c15819c6ccfcf105bacf3b72da95ed24323c6512dc2a2813c71d14ee280f5bb1397587ad26235c8c8c995e51f4a17edeacd33c69c5334ff1289d006f5fef3d4f3e983b0a6a663ef18589a57eb229f0fc99620ad7bd731ec2e1fd6c2920de2a8eef5e38658da60341b294fadffaa63cb4d78936f83ff38a9d485871db2fc1287134f55af682ef8ddcec1d70f469a4057ca0d9654abea13cb68fc95a4ae91a3fbaa09957909ce89313f4471e39ba24e7f00860816c7c75101ebcd0393a3abba3407e31110574893c3f342e40bd9e864374869d3f2a05f3be65034de3ed8e0856135612e006426807dcd5894e3bff3943f4ecedbb1cf2521b22e2fcd50b0798b546d87b4b9821b6cd380ba1f3a10ca26bef93c0232c9992f3aaf1ac689a7860e53dd6d736651adbc2954a75520d85db95d9ae32a7f1b51efef00b1617ab363269e2192b0a868e9ffbba21e9a17ab0187e586b4b621cd83485e8ccab0f125c902ebbc6b3ed60eaabfb1feb490f520e3a88969790ca1c99c6276899f8a0cca6154d5bcebc26bf008b0dc91ca0b0b1ca29bd6dcb5bac11e7d5e2d55990746060bef725cc0904e46a1c92693a77fcae65860fffeb0a93b11b8abd808d55713435ea8ef2f0aed70aab89851ed0a7fa2f09d6aa34a0c023b5854d8606c09530e2a01c0514cab3791d7ae47bbbb2a4bcc3022d5ad6430b0618f3b519dc3a57fed83eb35d9d5265958286a8e44f891e464b8608bedf3b64dc6436965863be97a283a6006a7427872be708b4772757d5f973ba9b6cca1f0399323171fe7b49e3a0a185f21aa6c7087b7c6eca088d25834b06b1ae011c6fee114af53f32a63bc0a88443ea5ff719f9afca2c21ee3ffbb169af749f67bce5609fc8f87c033ec3ecdd745397eeb6105d2d218bc7b3e621af89cc77faf7efae5d58318e04ddb57a396ac0c37a6c4fb6053f91782829140074dedf660082104aa1abd3e10055f57e4795b4ec801b36ac808b71659e8369c546fa690e318b7583c474a20cfbaf0b9b5d6579eb8026cedf4171f30be2b864a73215498a71a0f62902cf3487150667e24db98855064506bb20229f0d19dff3cac48ef1f389a4aad6cc637690289031f6947b9431696b7688a5358d35fbabe1e50f79a3af22249855bce57faa387b4af5b570a875ecbc9d87451424d0d44f6e5347b3f8c94fdbf98fb7a448bf414fa1ae83dcaf7e33bfe290fc9eed4a55b475484e0f028ad9bcfa5e96fd147a9eff4db25e01005c5f3a8c3b3acaebb27e162a1272c9d9d15aec4f08a269a99e97424a3c6ea99bb576e002cfea0541526fdb52f5ee066dfa277cf98bd7b21fbbe8e4ac1228e7b4065efd71bb300f141179b851469a06aee8b7ca86722a79d05e707fbd5c1f4e2fd0465fca78c045228ee64ec28905e8105194427ca05e5ce16566d3587dbefc3d5c35df9dc2d18c3146f27f50697de01ff13a3509b3418e608946e95305f700b80573c6e7b3b582bb5d10025f9ec817248bd58744549abd4859f6b748cd3aec4b5ca14aab2a1c49893a4356d1d170505423f69ac5a1193a288518db7f32ae8765dce6039ecf92286a6603b445c87acd4b7732b5a1ee0abf05d35b7c23b39e655db301f179cfeb6bab5e291a37d0a5127ef30fa7f662618ecea1d0c4346fa3cbc88229039179b4ce00bca8347175fbb4ee359b7cd0d0644574093afa6e7d5d3cf35ae039a3ad3dbff61b8b8b49e184ddad0efaa93f8e5de1b5db214ecb83a882dd6902b56515d6ce292d4644be9c3500e3ebb52901b128587dd0194bd69cfdecf5b784ea2de4f675c04ea51c08c16dbd1aeae74db105bff5aed0e89a7dfef2c74e5f9f9f35a3e84eeac30251fa792a4c70ef2113099da8fe53735cf9ecac8c1d30fb6d641f899a776c2d00870cae69088a8de1d97d631ff177a3f7dd1d357b4b0d9bca5c1b73b9870f867de82afd94146d9f867ab8ee5ef71ef2e052b206fff57002b5eb52dd385e85e8f3e116e57094b0de7fe66244864c217895cca41ad1d546196d43d23bedc86452cf3b5217eb1d2ca7f01181024ac5b7356ce14d04709d6113dd0279c596d337b25f5b0bfaecb174a6f58dc6b5218bd5e37b7cf96dd16adc302384355fab897382b96f11276eb1ba953ca92ee3905d22a5785ae4df6350860e0c25fdff42c57a657fd582c8d1e512e1736fb00b5ba2ce48469817116f9588d3562ee483b69b12ea39e84f515df396cbedabafa4f8d2ea2b141d9054cf47112ff0772b7d063a4ee4be8a0a095f6b1197a9cec729b867d828fcda38fa5b4d371c7a0b40a5a6bbba52d0a0bb8df679367d175528483a81caa6e9ed20d1564f73948457027515804bbd6f1074e0b7e423e1ccaa46badf4b57cf61af3de70568a7783e7de7c2c9ba58f2d36a4c439e348788a92cbd03d8c2c86e84368ebc9a8aa4d58f65a8a9dc2e3e4207f313c5ada26ee9755f6a98dc63e678ad0bef073f4586eaa9b74b554bdeb5e7a4ccc53e16d812e4b6d489b77bb010f25677c292e8975fa341980d6db1868c231e433420280e7fe29371cd56e986dd89db2f154c0bd24cff485203742f7f333e79ad272ae4e9c6fddcfd45564b33fa4b0f98b7b000f5f9ad60df23c7dfde95929caf412643df9d9f3eae712e2d1b1363bc74c89c6467f4c75fce92fdab66d4c8cc819fa61b294faddacafbf1c3a9cbb2bb2b155279a1dcd5a2c88d99449c2e35badcbc5e1e63bf81829274f5a9be2b19fbf696625be73145f86d9b388a2130781b3eff4bbb03346e1de4876d3cfd60a518ab117b7abf0f2098a676cb7a7f893e2730f11bfd68c5e86de47be7bc39d1f5f46ffcc68ae10ae17299ad9779a00c1a8f32b50e5ef9f445f662bf7c9f0da38d068724544cdf6ff4c76910e1f156f7fbf4eb1072871f2f127cdbf65fbb54299ef4a62c1f6db5321e855d92fe0b695d5e742908da9511b2351b8744bfbe2bb5cc090edcdef56bc55fd64d73c2fae4b8732998c57f330f17fe1ddad9e86f7c01ae4cbdd807253952c6b75d9ffe03cead3315bbe0ff6a485757c2aca93c9fdfc34915646a0817defe48b40feb9f9cc93bc7d0e26836ce8647366823162ea0fbaf9f5cf09e164f77a945acdae6be326a552b18798d11b29c1b351639d977876a12a2ca74dc45891ff9b17440f2f389f3c59d2167a4f4601d0bd9fdef3eb7291ce8e56611af7171904455cfaf9180a778842c9490c8673c348f0d166677f655256a7ba59c5091d90dde1916a4a352a61a2f8c6b1f56d46e67ee8244c718a467763f4001a1eb9f9fbdd45af01f444d441078a5ba0696ac3d7d3f4ba7fe5420b18870ef7dcb1ea9a4d4f167bdb50ef0c5b111e760367384c24fa62b2693632dfa45f345b17dd716b61245c0bcd124d449eeae0155fe14dbb93e3fdf2970286567c817cddbae36da0a9825c4e837362556e610fbcbe0d7329a7f4c93a5fac31a6838c5edb1a0dc39cf948b44148c09938af02d99d4021b088cca565362932824dd2a7176fcf5dec60967879a38cc7bad1701d2ea9f416d67f200db215b3dc366bc3bfb2cda876229eb8277166822855382d3ecb3486ba96026ee32e4df74aaa2da79285a0f11c8c2bb7bab15e42bee4a4786af0d4ddb63c6a6acb01ed1c95044de0672f3fcb72eafa08b7e6a80dafea390cc732bd405a55669d8b49e0d60b486ad5e9f97521f5458f87b9b52a16816d1f1d0ebbee67f31d8c70c770c330b6f7841404b295ad4d0f0a83c53fd3e9ddccfb4f09edf1653f394d37bd0abc393a3c5394ccbe711f4e2610d45ef6cab6710a3cecb304bb4aa7fa405b1c567f6018a3f7341db26dbea6ecdd455e6750bb82f27cd05937877066716ee6becae312b9eadbb2b6dd2de2624504098ffd883b474b6939c59f6cef302025959e5cfbd94d2a3652d4d5dee5f06859899e2a0f9026bb51b794ebb48553b9a965b1e61faf05c3767fe2c90e594077fb9f448228278e5cbc693c95953d4805cf9eab94a8b7a859bab222275c94cc81e69463e1dc2b0901b41500499ee0bd05151ef8508305c4bea12434275c65a18b9c24f033a1e2ab1540603994d03d3f026c4542acc6251fe7e64e65ca06a9413ee68f3d46d5658b43c2f55dd43267a576aa544bab12cc0901b2e6d898ceaaa9e70df2a4206d5a50df96fcac5894c9d6c4b2b3ccf25af195b8593a9b89ec84ba851e6da6d27484f419429047d683d104463713fdafd0f8559f6d288b255b0db64b7617071c550a19a9d0520cdaf80c666baa304f60d3da5ea8952e96543f88c9215e711a8ba45d9eb46830dfa294173a9a4c90af2c4bc8679c537dc947b15205f772cf34e1f2e3bd176166745c3c71eea5de2074cf1b30668acc4864e6417cb8059a4c06324ee507ead9d4fc34f76ff83d5f761adcb68cdb43c9677bdd3b5746a4ae39216094dd11a50cee48dd75aacfd48d1a10e68b00ef2fa2ebf85f85835cd55033a696ccf417d01c18c369fea0f53072080421cea75eee44dc5e0e7fad2e4345b48081fd28725aeaf0f59f2f9df204ec2c9e451f4c5eac2dd4a4d9286155e6ed0a196d386adaf79be9ee303a8c80f6767d904c2e4631c6bef7542dc1c14d06f465da10b6f7dbe551336761dcf90e2dadcf07537bed2a5a5881cd983387328fa6e38e44fd4dd23df8997ef77727fc6beb61a5f07e19fa7cd4e62584c6d6218761068fca323c118e7dbd366706d57e3143ddb1a1ac644b36587a64336e116624213b984a0bb2f1fca114aef5e7288a5148b247d67ea400f512715cf1cc064d9ba27fccfd90f5f2e4f3c47fa8b926adfa4ac6a10277c694afef3813476cac1d6102b04d510a42fa1bbadabcd0daee11a0e8484c88d8e855466b2a0e6164caff5bf6b9cc67aa2c1807dbb593dc18f3481f1e8f9d51ad6e3b81ffe1edb4b5f4dcb3218d3cb4a7e72a13e93b70d3c2c96b44ef6f164434d8b5c6817af4da9bcd6fed5e85477bad9b4ae10d59a1418416822cc0ffffad246f07cf17435b538d6886acd301d400e8b7996aa05b3eb488c98ed2a8ca6e34a41dcee7abfab5843bb6e525304312b1076c54c6b3344546d5d705ba989becf00dc7a57740ddcec685fcaab6cb5156c0abdda26a785ecd245b0b7c170ec3241e6b00d5b9704c70f4748d496dcdb38a5b72ab79d29c368884c1ff8fb93e79e30bc759cacd591047a0ee32109d510f7b369eb024444cddbab5728f0288a34ca4e4bc4a6a90d364fa3b6adaf23c861e761b11da8d92d225bf34df418f5369f41bbda47f389fc266e0d4d48d15e2590e58e19246ce10d1ef19a216ecc56b48c1ef23c7eb9edda46c4c8726a84679afe1187e5239780ce31ff974e9d93b76b30f2a1f8ca3149d044b4d7fb130b73f3e31a8b75515bc25f91ac9f1b464ee463f2ff8f0ff718517623ab73c07fe8c91f9f37577017985bcc4c0e9c068dd7696596b680f63ee720c8b53f05affb914e79d77e62e808ef4deebcef19ba1c7ac2bf9f7796f412f0a216d7cd268e055b5eba04e5e17df12a217a9477110326e6690936987084196e2c30fbf828484d404b761b03c8cd5b57b36f133a273c9dd3bd60d6fd67b660a494ea40f9cd7d453c2317f37c8f4e8d3f7a9ab19084a1f33c4c36b5a52053b857c00c064f8ea80472fbd8f3ffdbe678af3e60adbcdceb388c7e62b6ad6bda9ea182fa7bff4679086489bec763a20b0c9bc37f514831bbdfd7682d8d22b817e975d1df1a6e754048999247d7c6835a8801780e2f0851be567cbe29a771e6c52219c46ad18617f7452aac990ace886a447ff4044b8a13d7d73c74645c404d65677d66ddadf8af17ae2998055b9ed9eebbe90949abbecbc940b4f9c1e26005e2d7df674625afc35ed2d5232857d7eb42ee74c3d3592e298dd7403167bf39aa039b72f25352f640080d5b74d61a3787fbddbf5e85f94c62cab0650b09218f0cabaaadaa14d6ab330df4bc790bf30e37cd84ff1683bf7614a723ccd8665642ddf36d0f70b369c254105cddfc58a763b2c5f65cc43f276e3a9d128db63a386ca3ed84d7d1e36fccb4d00216ab1d7a5e7421581ef74520a7dde3e2f744a8985e0ff8579665ab83c23ac8d415993246c4a1667a9e6a08bcb6137a24d394686dccd57392d6e716cb6d7763ba427eaffa3cdffb312877ce9ec613be6119a29193c9c579504c2e2b3cf56d907a54144d5f7dca8a91a61e49b9683e608d3025cbe6f5c7b238426872898da8803dcd7e318b724bda05bba6aa4eeaeea0fc5461ca61d6700626e669f8ce7a082c4b70036d18eb3e6f99122fc99c1c4dba20986cec69d03edfbc3e604497ae3a96d6402e2776c9366df08a2dc31f535ee2261ef39a2efc39c471a5e755f97f318b9de96ffe308b5d23e02247490dcf6af4895e17f22e087e9906349ec43a333b85cbdbfe4ce6cce52a3ece7db8e2160acb8bcb5288c1b8306f1b9615f15093437d4a9c55c2b1dcae526301f77bc579a30fb9d7c125ebb8416ea6a921660c81115cca421fcfaf66bacaf1a143864a189d9af3f21eed1f03bd26616f2a514e6a84da4358682897e6fd6a6cf0d1c9cf594bb78d1273943d88f30109ae9bb78af1fa00455a42df9e3294ad1cc08147250bb3ff4e0c700607ceb24890fb8b92ddff1222e77f112a996f8f9c71fdd5fc0390256a12ee363ec1eb60625987837d1d2ebd585b9c0cf8d920b9567438899c7755c70e09cfff0190d4ceac5d27cd1f2c45d7589720e71c01c1f181cf9fa1c279ce014e2de6f8f0e8f10031e28c162d4ace0dc069bc38c97dbcb07915b4c1f7f018a36e003b538cc727d99e298a349f1c80f85c23aa78c3f1c98811aea84e3e932ff1aa2d290a82ea3cdba17c578ae98877a9110b1ec1c3c282350c6c0f115ff41fb158b25ce838bd9aaf9ee9f11f65bae44a05d298c31aaf25de51d69efbee56e50811dc9b03acbaca8c262b27df9eec0c75da30ce2b556c1ab066cb4d87ad437e2c560aa6c74abc5b7b9fb1a881bc18a024bd9130ae17c3c18ef4a682f5286fb5703adc4e203247370851aab7bdf7d28a32d2e4ca7faa33aad587c2a2285d53adc33a078014a6f8efb4da90e984d8af0956d2e085aec5f7cd3c01f6c594b1b889e1f4f24746efb5f48413e1bc24e8eab29fce5cef24eff3562c23dab61b4b094140d1d8288f85f8e023ac12a7642152178a99c6f9be561c8acf00d1e5d403a93aa5b46de18c8f4834749df23a3fa8f80d84ee982fcc20a6bc61ec9bec64ec9b645bcb99fc6c9219f528e1e49fc86379fbc7588bad573c8c736629c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
