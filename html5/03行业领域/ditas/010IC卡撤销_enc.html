<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df14b5f3fe86aef754adcd6c04612a99c42579c3923c113666a032f178d0f76dd9fe8c1c706f59d1cefa78c16670759f748adbb07ddb587a92c7ccd7011c3b3557eff9b8612b6cb400ea7843a2f4f581cd198a5fd0ef6506c7202608d3589421129b1f523d5d754bd510b2e267fb54e692d7ef6858e6e5f8c3d55e2e402b50d810e46acae7950102eb990e14669e0eccad66d1a872ddef4778a032c93f7e1f35db34002d69770972bff69ee5d1a1be79707cc30cc4c8c2b972457a44a3183bea0f65cdf09b3929cad4c378827db64268f5e0b61c8205fc955c92031b0f041b8a56ab5c328c3d712676cd004fd727d2654854e0cd275939d11caf097945efc6076add412d14dd127bc1fa7d15879d5c4098648df6ca5b9e67fa0fbba0ac4ea2d9ed282fde9da59265a7d0603f857b2e111b660a9087d5cff076bf2ca53e5e10aa956eddf2f5723281b49f45962733e8c3afae4e8b0f00fa576ee9572f4844f83a8da8cc36ed2a8deb37b7dd14cfacd960042e6f4e8ad40e5c09b26728b96dcf894999d09dd686f3d895423ee4b02ecbe35772031ee4e5091fb386b5ea796f708e43515c7c220cd98e717cdb623b8d953986d6212fe0dccabc13502e106abed222e94044643aadd2f2dca4318ba4d57e4489a0fe6fce28b3f28d324b8502df3aae43bb4c26f794e124860acc50cb20d306972221284bafdd362d350a596b7061abdc68705d5b7f9a635517545c485cdf2a242dc078928cdb233a713bfcf5164e6908045039d49c7b3d641d34b1022b8b192a24d5b9f01d6ad9bfffbc9ab9e8ecbe38b28485e122e9ad6e196847f4ba2512604947e4cb9d834ac726a745b0e67709305c310687839615c10f0f613b83a31b67cfd4f9d8f998c2914f83d9a0ae100a4c3379c119d595dd3fbc7d30a30abab3571c5e9c8e1e3e12891783563766077ff7796a90875cbbc3387e52d94c85a06e4abfd9abf7f819ce15822f4a5d839f8c2f88fdb9ec0334664c7f78318b997a27060426f1424136b1c8a518caa8727bacaf4f531b9ed76d96948e49e18614dcc24a5254f0c6b32a69e1d0cadca202e2949df9d43d13936ce793f2c0c53050b541e430bbaa753a27275fbc95d2af902f332a4060275a3270af73556792ff3457c2866d1e3ebd085eac400d8bae73b8216ba3b0a92c9a72aacb424fa6ca29db7c89de20ecf5064175535294b6db84b8dad150cd0a642b17d66f58a891a9313c8e0cbf6d7e8f1b20164e78240435b2d694d5d1df1eace58c16bb02381b0f2a70f8b928a42052294cd05266dc9dc25803ed21a5bca8831b360cfbefe8e3e4d5b0fbbdc00632f56e283e95327fe9e5801f3fe491c74dd471c43ce41f86863cab9c587a43f4facc2bd2cdb9fa1adf31259efb598e37794e6d9b34ef7d67d530018e11b8d887f2b2422bee3620e7a4e05f412af88e0b2ece8050254eefa5f97655a7745399210ac99cbedb8aa063d463ade54c78faa4c8a152697d6e672ffef53e8d37f2d68b0a0af4bc5ea3e431458cf4c4820aa32e244907a3cf66be7729716f6e8615bfa21d6ce100a4666800151d8b5eacb3cfcf0969952f28926166e1350646828436daccec56408683b506a9a592c28529bd30675b24c6784ff900e4ca581ee5293352aec74f518dce43dd5a9e4e89ee1bd08e062b9d23c6ed36f246e7fe3d536a82bb079e5c54806bce004cbb80b4358cbf42dd065d8fdf7459c6cc2d22a4788219c1283ee55b2923aa9b4e47bfb53077a6f23679c9ac62134e70556df316bf89d2de6efd2b99b385afc66c7eff4c5be545c259b08a5b37f39c093eea3aede700efe6c532772ed09e86bce3ea1e52abe432b21e369f398daf6754cf83e2e2085143d3189cb116fcc718193fed1b548f3f42e0adff7e5db23e169be2ecb03c9464be9814c094b3db364f008fd5b7dd226a45267b3425c2714e1e8958bcdf88cd6fbd9d56e2d2ac4bafde4bbb40af92abf9072bf5fad65a74ccc1adde8371c76375e30a84ed8450bbeb2838d6f39079c832c46013b58b7b3ae5c97a99b11af897b534a557f8f6c8b0c2712b1004be54c7042751c09c6c2ff6256422ff89baebab428514fc26d2988049f29556f4d09510fe488e471f7278a8ab012e9f76032e73d801e8275e60f1ed2f1004f76203e08e6e68075cc6feb18f10d54918bea913cb00356a58e8b87b9c998805c860efb2386bc9e8ebad58e25158620f24767fccb1c5e0eb9defd780a224886a057fc3818c9f2bb22d817a4bc8c566fd278875c00d0888d205a65e2c3f581ee2a89ecc3c2276d9f78e00d9a83c9ddc45ce7b55c6c464e289e94a41079a8b232a6e7daac3f390ece7530bb59aceb91b598aa14e6ae399d74ff7ccb2c6e027a72d03053c37180562fe82200ed28f8995f5b5686feb4ebe1727ac3c8188a6aacbc1d51df27c2d3151343201424bc14caf18c9e038dfcc81bf1052fc92d46462aa82f3f85629b7f9a20a3424e064350179ac185f3af270f34cb1aaf7be04f8dd59f14f3c2ef0e1cb8fbdf24460f4cf8c7ddd8b5f0a14f360386afb00da89ca4ffe2fd4635ca5adc477fdc0b95bdbb75d3c293cdfc2f65bf7a21cde1838ff277fb9c208ec3cfe6eee0b20e6bbf005f2e8666f2adcb9ca1ef5e2f95339afe69287c96ac379e0a3db26a998882dcc60f18b7649875bd71fa615833ae2534de702caba8e1a32108ae5a794f72852c2d2c7d06c0df4699470e4b63a9a3747fe00b9d80365fdef6c66bdcac9c13c391d6c73d9c94ce2dc26fdd4448dfea020f2af9d6a83d9a8ce117d0367fbaac4c06f266b31efa8c2c432fab4e23f3b23bdd437187bafa22a3bffa62edcb1ddc41441dc7b3489a9d91bc03b09673d7438f1886b9fe782e8464af64e65bf36d7c181380f1cce3918a79045a0107336aec60328da3132a427a25152d119545c60056e471def4999907673cc5272727cd8b8e22b5676bb3fb6c49d842b6055d6a67964e47269545359ecdf471f4fa79125b0acf3f2bc157301c105aea9b4b5f4b433eef40c8f35e50e841ebebeb7fa31d13c0219117dd15e395c09ba3fd65608f44902f45418b4af1bb4421f45ba1c171f4b6996e41af9d93780d3e3ad7d138b130a22482d28aa151dba01813b79a18471613ddb4d3ffcb7a38083d85be53367433ebf3a3fa878cca6c8a5aff92cd4a35001cbb2605886e29da42bfe844d59a12d877fb8713130a23ec910f12fb60a35aa6ee9f0488da1a739a83f585451a0d3e31ab2d63d2a2a98964ae16c6affde96597cf01c3655ba798f261654062cf3095e4824c10db787da19a4d65762a1ebda7d917fe0562010e304c9db9c751f639f0dbdc898e7deb25bf317bb1d781548fa542e79308dc2290f30f3af338edf9d51878a23404c882ecee127681845370b23c8318f07ee957e7abf4bf9c3804ae12fa550c0579fe140ece3b52388aa9dd6b168ce60131aed357446f30b288ee9f522dbd3ade1f82a2fb2b6b35ef2292a795d512cd9939eaabffa097472bc401a0a2c32ce9fc4a9fac2108434516434708f91b9204b7c88921f45893904e31cc2c8b3b6b7061f2a54baa3724add0fbd15b34823e07021a6e0ab2b23a7e3c1dab1cb4264fedac6cf872f674900cf86d2309b81e2c375dfeab1c855faf969b9b7725a7434952c2cc2bf0237cd4db5b0655aca573e2c809516eed877143cc33a764dab70410e97dde1e6017ecde7f6c50632f0c56ec7e9e5e67514a7d91cba362dfe783fd09373e812b5ea1e7317448c2ae86975a19bbfc847040a629b46070be7205dde9c176bff6cf36eef4ab847d2f28de026c0f173bfc09b51760a0cf1e667e581001414f1f964d8b40905c9a94c7de5cc16611ccf2f853d956dc2c1a451006622e61f2691949f706c51fb141707a5bd3e2dbeb95a93a723b1ef540fa3365416dc89636c559c2f3be8089bb62f87770e4322ae2b86f11855fa3f086dcbcd2670a8e7b3b64f3e6996e4fe046346abfa6e3510e7fe31f4ca5c1431d0d431f36c50218fb497661d609c2cf6ae27dc638ced8654842da585080b41352ea3255885e1b78c1c2e0e666898a397ce5674c1d3bcb1e4c3302f52cb80470ac957e21c2d4d604048a9a49d3fce9b4050dbda72e2cff57b37337a8b4c77d7c21893ac50886baff131c3837439c69fd44f6897c0fb39eb771d3d63dc935b45148c4bd4c2b1aed34223f502ece45cd7c8ee345971ded2f29977c5aa3a102e83a23357f7b0283ebde92a9510e1bc466dce0bf0a3c6d139bcdbecc2e62a4db9984e5beac2f11dbded9f36d53cc10bd80fa3236f8b98dbda2791719a66ddcf4f835b97339dae12e79dad45bb15b01b91a8549c39e121d91c1ea6fbb7b488a675a89241e5b128152c9581fbfbf37c4c94d73a331930822abc30030710d0661e5a19f06edaf648bdc4cd9454aad633a35af6428759a4707061fe4c35c9f4816291bd05d1c9aaebddb0bc313e74336846daa230b61827104647d07d1b506c7c142b6529765157ea3f10e3696ab17b3afc8913369d1a52cc23084e3f77eef6d74d9c6e1e1bf861e5eb1cc3a5d7290ce7e501107e4b043eb65367a5525db064f28ab97f0d225f5829155347743981cbd36730cbe9f77863888f7a6ab0726428236f4e2a88a66568c2618f2316e88abad9ec7e75430b355dcee51271ba9f32ba70402bc446380868def39c639adec9fc4a58d3eae4a79cdb04a97b5f8a409caf1d0ec7c406f2223abcea19407f4ae0a5ced66306397cc1d0d850d3b9ca87b1d823c33ef209425297dd5d135c068d2a27714ef5fe22cac3697a3b57f6180e8a42cc75296a4221e5e55960fe797dddfc111bf97b996ed4868bd6f5f29a13ea239fde562b9e3292c2d4e2ca590503ba237dc2eaa08a7550220fa302851f77831006b00376b84e9fe9582b9b9196213a17d4851c7a3a1868808502d02f11d916340ed98ce9e17a7196fcad807f07f36f0df917004258c600eab3368fd148af5847c8635bee1a1a71eb888bd4983507f5f483afb1b51f6f28e69b8bfce5660b2ff81993d705e0aec95b05ac6cb2ad11759313fe6a2a59ed33a7bfa67868aa721a659b3cad305f551d4634dc9498f87a36f76630a654344e12a14a991518c2f563f537392532d1c0ee57a731d4eb7df09d750eae1ec246008a657b38d5a3a2df7d67810b714eb7e466f8c6a131deba6717b37f71a591193c5610414a591cbfc2b9db62fa9d625ba8e468edb7b71a11f7f9b1b9a2a11f07271bfdc46a9b56e01078221e111c829473541d439d688c6d940a5db455ded41c56071a39bf5063263323a1599c10b01aa5073d2c5909f4c41e5397b6cba3c047f26482a67cd897442d3c10510eb40407f69d21ca7cd94f2a7a06af3b9cc467f83e298aaff4f351470117ef3f098543f8848cc765bf2723691c3213ae648670b6b235a84739c4f439a637979c68148077e1fd8262009972b9a1fc4c7e860e936ae77a853346c443ded2ef664d34d56ab40360e1b4f8400474ea9ac7b38a526a03e7f06048ebc5d6379ace2a7aca4a77d6bc195272d325fe1c3303068bcd47193f7d2ead609ac73f2ba295d5e08a55e3d42d870cb03446f71bd5e8fbf27d8edc4fbb21b174cfe671991133d73f62a753d9f8277c37234894d8229aad718e249951880ca8304af29c5ca0b4dcd03211cd265c015b9aed798165809204f9d6177711d691dbe1114ecb70b5c6920e67aa4883bfaa78b65c1ce6ecfeee9ee1b099b20f11f87438769527ecf97e286341c1f9d27679b7efed70f86b8fec045a26c6d1e8d6e78708684af57d4b4f661a6d509cc083f2b408aac6e234b2bc1ff0dc2f34cc9d1aaa3e832a69b14fec3397f62ad4fb439fb0b6d75aa2bb0eadbe82c8896cb633fb2bebc15207799988d5850aec8af951743490b7f1d3a3bec821bdceb9a431934b5eaac4ade50af907eb687c82323636c84fdb87e1a9f430ae11ce5234ab4ae845ee883e76c73d59bbe750da0821d116ef1846042f71c94e970053649967e4507ae05b6ecb8477a2501261b0188e58ab1282b3d18aa87712bcc0b43616f89801b05a5b08bfc54afc9aa5025defbd556d750cf333981e7a6f39d595bbe63a01b78cf562f161d1232ca2d763f0a952c21de3f3c239d126dce938832aebe73f5f36d20e3911c9ba455e64f45d3831784d18549fce8f1ca7e51448f6c86580fc1093e52451a26297387015cbb9e6fd1b5f3e41ae819db764896564e1b1c6a6cc21063f6455759d42caafdbc20df48516ab439cbe0a18ad8d1f4334f4662898dad2788e62fd5bce600cedc925f6829ac5711d4cdd49c52bb4c8d7fcbe15502d1d79afb26c5590f335a844101323781bb74c3a8d30255040b139954d76d802a9918923854355385fe5e81c0ceafac4533bbc798e0a480935b3fc973ae6f5443f289d6e38523329711ae100ce5b6a968977ca3934eb2e38c35180b366c1e34c545899f86111ccfbda99c3a41005009795e690cf5e41b3ecf95b290ae7d8eeafd9ea2794ffc5a7de709c94ed74e74c9481198e6d93f40b0c21e8575067d53213d544c701fee89fbd056e3b5e21115dd02359bb0ec38f535df6e8d84202acf41b24b07463b6b52845983462c09aaaf3cc1d8fb87c9713a303ebccf6a029e73ee96fdfbbb0f299522c81caf401ae5977992838a320a0f16e16042466c86ec32ab9bfe9389d3a58f3f69561ac998bfec1230d6eca4e48f5d0c689460e877e3d0ce589a0f2b182d2092512e5996a3fe40b75f90a0f36ec0ebeb00148dbb90b9a515ba1c24be5deb4c31b3feb79a281a6886734a92e6f9a54f29d717706703c6c1f7fa55fdb1fd261d4ecda7c71537f31cdc2caebd0c0ee388e391ba9c9afcdf6ab7b898ba38ab6a49d6d6b306bfa8e7e5e6d961859374e1553b282e81927bb40777e56970224f438b848d0fe82bbfeba8bea26b441ad7f8cc815376c266c7ace1382fadfbe4c0354041f2411e841202ce1bb8a833358f843fe26368090a376b1714780ec35a3978ede7a6d894319cb0292dc3876e79543a354eb983f40a898ca860cc1461aebd774e491914187a6fc6ba2469ec04ca2e0104e61bbf49373e5345e85c9f4e305f5bd09a26d3646f22b06c77d48e5830b8b0e03a2efd7ecf62d7aa5d5b18710aad9d2cf1eee441b07227d82b4184f389fbae8b5bf503bfe69ca97792a09984c7c4276aa6f86b0cd1b6da570eb159ca9143fdcba9e786aaebd169e35023e6f432bde95847e8bb6f34bebc116e7f9250a1a00de3e6d788b9d09528af56ab725c9fde91b6052e7f3820e4d1e6491ab532c00fa76d94b1914538eb19374c2cdae05b061072f3ba92f9120d18184f301d94993f88611707d60b8721b8295a15b1087e7ee497c3d766ea0a3cff8d5d76933f5140d3be8cd4136dba1af05fdbef82e12fa6005074e0b2155d6848d09f1e720493222215432ec84e6494c6f273e180f80d51adf84d51d76c25ee5db723d096807310f58e426541624ab45f8ed635c32d93b36ea3ecb27fb11aa56cb766788193745db3c810a5dd732d9fb70c8915b62a1733dc09efeea3e29e5a9cc419e9cc7a5cb014d60337984e2568acfb169335561475ee68f3001c1caad7747e059a44a7989abaa8ec7129df89d1503eada0040b7eefe2c458718d67ee3fb782a2bca9147791dbbc72badee52dcc3cce6f6cda91a996959bd2028f484164baffb340f1f398f8a0b7036f82b8aac52c3c0890995e508b3bd8be7d296611d9f66c729326b66ebe84d82be99d3c6eeaeb5a56a8bc98e03fd2d36d9ef6dfa530b9a7bb5ae8da98b438ae1c7b1b2f614fff3630f5325b20b3814bd7d8b67f5aef2093ff8fd37239b8ebce8f8111eb3b96418b4cbeb4a1548a4a4c8c9b7c8d24621b932cd3b4dfa29d60c1649b7ba09dbb0b8bc23621dcb224a9c2fd45a23f523418105551181ec6ec131539a7d295e48e37db5f241fe85072898f83a8575f77379d78a2d90caab1cf53faadb36cd956997105dd992d05b88e40400c99305ac8a9763ee2a29c2f3a4b0ebe6b4fcc299c427e12d7e29a6f9a38f28373843eb622444cfa020371a78cf3ecb14812f2018a16b26e28274fbfc1f780aef593e7deee98f709aad8c7ace24d2ed05cfff1a600b721effe863732ff76d6b577b2005491c8854c9d6c87c611beeca712858e7ffabed1c3df3b4c8a105b66ade3d63ccc08246ed0879795569a7a9503e381a9e986cfe7ccb4093f7bbb116122a72cc7b30e6bb15fa478ebe0eec02198c54cb6fcc6e7157aaba5394e4b3b789533a39cb2e8f5d73f81766c854d1759849e0cf32b0e36e9589402a5b503f5c0d7e76793737de5cdbf7cd6a87f667e6c6e4c7ea097a853055fca6c8fd9acbe79a2cf2fe5d1867404a8bb861d91f7143429794594ca71d388af94612f507b10630d7a15b496c9eda4736ffb765b648f669e6f6772c49eca9676901a2c115ac21668ef913b9e1bdc2cb8fcf52c08f3b13a881e0ed7eee7b0e3ec98749379d1a16620b94aacbc2e7f7e4ad2cf669a5e7c080fb08ab9ba18db6965056ea0255270d41a696b6b9ae3315f02b900b694a348beb6dc3d9fe22c8aeab1d70190572586830d5bfed2ffb12f3e84134549823c89473b197e955a619f266c6f9002883f1a4f96892540d78a0f39a63677372396b0c53e964af2c8d3e29eb6e47fd8dc79d4decfc88aeb32eef3c81d376a692b79abb3c750fe4f67fb875bbb2d88dd105903f283df8b90813df1fdcb32caf8c01151df3bc20b2816197e59a07e008e37ee908829aecfa668b994c438ec9f51bbfa87d77a74bffe493b254e7ea99a5446d23dfab5b69ffe5d628abc3b7d2212beb89158047939a30002903c94e425db2e5f52a91fa69c40c8b77e70eb6c29f608e2ecc40b7a41af6be9d697fe1a1be0be26b0f96e7b47ce3a72251eedf84cab9510dbdc4cd91dfb9ff26004dd6da86c99fe2c0a766b5744760a4bdc5a030ce8123a93670b191625641787dfb3b99734197dea23f061edf986ead75f064d5f3bec4a5a61ec61b16615cc04972ff89bb23999fb930dc45ee22dd2dbcc054d65503b6e0dd2ed450f93bbbf89cf97e0e7d52b8eaf1a0facb9510e449e0be370e8439478c21bdd3ca2f05b91b895a8b8e940caef5ce9cc87c721297da2af16475d87aafdb476b15a3b3f7d7228d6060e9e68b305a4fe185940c2690d67753b3c8d6ca30af0079ba8437760ad4093442a122996702c233eabdce1d4569ce3cf4a8f8cd90a652f9fb8f835df78c562bc604c14d25a059bd719b3a4312f4817cbc65f8153e3337e1aede0cce4c0a4f30f8601363688dc54dff45da1f5e5871a5e7a89a8f097ecb36394a09b946a19155402831b2fc438b4a184c28fb6774ff01919f79f3ae375e10541ab7f7afa6022cfa3513abd2ec5eb7282ff3c2df6f34d5d99f9a4da7773f00229b7a860fdddf55092bef6e68389728e2840c82a7ee536076e8143d42c3f33a3fc10d1f015008f1bd6cc0a46cfa992b00e149b4ba1801f547fe50509dc3457707bc34ca71f107f57ca8184d92c153b474757c37c47ebca66cec532f6b4be54fbc8f5c5c91699b7bb27bd4b5047a37e9f98df479fd24c848592f03e07d8bfec2c73895befcaf28711e02357e52e129ffc5a6b95cce752d66b17f5bc33cf3b6f63bd2ac3006eda6a52a505fa50bafd43d27065dae297c70e93171c9dacab1af30574626afac7b5fdd8ae25a6a6b6de33bb76641536e0f551978bc2a142c5ebd8ff2208348607c776b747c2dfe529b57ac1fba9ca2451bb2c595bc4c6e8bcb6d727cd26bad259d1b8a2d3723516b731f002a2549aa46dc6353a6327fea50908d1ee985750df9145417aab91615ca34c033ebfde176599adebd62defce968adf5f1f8d00ddb2bdb36b225f780c94f940d19e6246e4cc34cc7bcd9443eaf71648d3afb07c49e7809d1cc2b11dc011c2ca110f040e8a25a26d9e37def8c7b0d885217b807b3b2c643fb5bedab6b951349de378a3ccae1fdd9b2fcb47cd868082e74712f4a1bc7bd57758f28a2cd6430a6fe469fe6d131dee451e4c2f9cc4db7b2720d64f86484cd2d643adf0e6d0eb8057e6c25305be9dfc6803d1347e83c28ac456f3133edb6806643b5e72e2c22d50479b2b24657b225b840ff7c0167f9f47b78fc34e33fa235e1b6f8c9e8297cd1621dbe671e0229d897d190b1bd58addc9c05e1833d656740ab05df95ddf3e2afc9bc31528565b1bd17457361871651c32f8c29b1b292ca2512b976d9462f6191962ea97369d5d275048dd9c8ef5b13cecf7cf708585f1e0380d1f8937a9e28fdaff3b5921e51c165dee5ce27b0376ecaeee843808cb0ac7ea737d911df034b02449ec0addc87912c340ac503dce1c0274389119c8e9dfdc6f04255ea8144901bed709b9993f74c540a1301be329842755bae71d9a50c2e14c4bd479639e6d8ba6e94a7481cecde96a57034ae668fc508b5c15b56c830b24918bb9018f1e037079ea88f5cedbf7a66c222dbbd6e6019430203d983b052e84d9c56761d699ca51c6fc21e45830bd4719d958f6ce6f27ae5a777385bf66bdf02264c33454e0d8fa4e28d32bea0ff545995d04d115f5a6ee2b2e7c04f2891b0633054f1d72ab9204dabb38b3b56ec527297288ee064e73b4a6da480f327d175ba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
