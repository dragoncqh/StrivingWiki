<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"89cfc8ed4ec3331459566f417aa40288b99a616f6aa67af2542f4c21107eb849f18330dc623c31e1b50ad7d17382a007b5d45356e4c2d0604d8c9d6e802eb74ddbfab90078d83bac6543b7ed6e3bb2ae3ecf41c815de98784e3c98343ae268c1ef33da9836a5c04bd8b17c2c07710e2e05a92a55730a6051dc86b5165caf8ffecf9ae8b836c96e8b53a81f73e27bf1e464be135436909baeca8ab19137a57e8001c1a3e05ad15ad2166f0131d714f34102b8939efd6faefb95832b2cc457f92f2e10da424d00d6d357321f8409b8b039d3edf6f0107576552b15d0d6e2cbbcb6661b787d22b56c22acf0dc95987a3d0c6070ebad26950a2d56ac87b336a4e8b7c34d91b83360aa7872e119991870b0b4a3f53b23fbddcce06c563e00333dd1a6dbb6451cde6023f1c32f1a78edd4f374c528c4ddfebe13023622b34fdd1c9916cd04c2cebfd432b167268f883e72f32235aebbc5d991a478c4ffff886d2341bb7188d9f0ed721a0e0545a10f8602c57cfc5810fe43399f095ad3d4521a8f6d5bda11895186feb40132d9646972599537661a945cc60361f8f23c2e28f44d3bd05b4a5c3c99fa41c220c9227fcddc71160af7de7ca60cf0d625dc5c44fdf1ec336c8c9368474d28df4dc15c4f57809fd5cae3d5998831014584580540528bd5b839a5645591d678054e8594a61d737257f843ea9eaffd4f58f259e66b4187042bdeec297996e1de6ba21df0d3b05e347d4a29ff8acd38aef6699642f1c06dec8567e1a864e33538b0815f7be37dd2b910e92593c22ac5ce93da276e02f69e49a1a2ab2375b5522606391a1fa6229b89cbf62f85778a777445dfa30c695be6bfab9e94584007359365a593a542ceb0aae59b81628ff0b20ad72e9c13b1e35843eba6d22ed7d1aa0822b0ba8633b521cebb1de4ba268730bf59e4cfecd028c5fafae505a5372b9df0804327b1f66cadd47630e7c80e438838a52e3005a71e28c9940a49739991b1d2b44e04ff5615967c388247950d0e57cb9e44e5cec25002b7e878cf23bcd1a87f82e794a78006dcd1b9fcc494b9e38bf6116a355b4c2ec19ea83c648ddaeeddd123e0f7275ad9c562103ca095c3897879ac45cb4ca3f9be7cf73bcfe13d19421b6e643e5cf59ddbe05fa27a27bb54761f4ae6507fd6b4517eeb068a40e249288a564eb9db14d18f84c1d5bf147c4c4274158f6b3c1f750489dfcd2f5ec9b9ba09c04754927067607f3126af6ec76194f4bf2d7a058ccf2aa67391b3345bc569883eb979c4b9cdce4b91a9a43b85df3a965204cfd6e203abfcb602ba5b808a81331a22d2062fb5c2e2bd1f89a77d4852f8815437f64d668b1b5241f79d8d19b573862515465d79fc720151b9099e999ee7ba7ac42bc9b6b06d9e5d774b9be53ae922aa419f1c5a1be7cf1b54bfb54174040f7055b9d3595e58ed7039ac69d9cbe4799b3587e708c741e04d1f1bff39256f9149eabc63ac69288a79ed5484ebafd8e78adce706e97e34f755620432041a8e32a7f9e46edb20a4fb28f9f4a1f18bf004e2865c94d3ad480c3d7f1abc88bc643b15e2f955df6ebf1eb61ab4990e2421b6a18fcae86ce590bc54357cc3dd43cf27e636c745e319f6b3b70f9f45ff8d16e391c2d3ed3a3c06bbd77aa90c26d63f190514b97fb038ddde37b503b4a00256d9b8700c5b1fdfff34d735f76668d731ad5c1d90288791a3963452c75274a14881d1211a7913717131bce6940df338fb34652f042ba46f7303fabc6ca788d239bdd019091012431520b268619dd0f3b40dda7c2dd914fb4a94637c856af178c2f5ee84b26109795cf5e7aa35a3ddc4b957a50a573b169066270bbfcf718d7a2becb825166272fb75067b9d8ca7d6bcd22224c247a57ad4b7e6480b4ce56196b3c992e99c8402786ff6de13138a8abd9d71b0852238d76f39689feba58b113a1af7446da14282723c9c39453ab3178cd6ec9d54f3f75ad7f21f6ab0de62f6f4968cafe1b50b6a567d253c15ed9c4404510ab2a952f13370c583d9abd229c5d51f9f46d2f3f9003ebe4e714ef212ddc8519e07c5c99c6caafe6f165b73109ddf6384871afa0f91cdae77c161e4178193dbde5b1afa0f82a5070174722b75c8068ea920b622cdf9b48c2f4ffe3ca887ca305376c4340e8625fd33eebcbdffdd374e28e026b900931c4ddea6cc2492edf22b5432b4b04537fcc5ac5bea709073606fa2d570abd086ed2713e39dec2d2648daae24bdd8209f953adc9578dd08a3fe424372756b5819cb3df1a80d08f3d5edd953dac5bf33d2d71034e08caed267e62e9418b58425199fd49873dd5d79865e493899c3996ebfe51f56bb4c7e292a2eb207ce5d78a24fe2cdaf39b3d6ba0186e84369553114b7e6ca497394f5c9086fbb6a1a3a028c0f51f4eb03916c769e7082a800bb817e5ce2c1c2739bbb93958783a6e85c9f3e8338245c2523ec5250cc73d2493fb68c280be1476f2b4a11710b5bdb9c7b270a4d1c8796d878788592591239c95f091186579125e5df7fee69e321914a73f9dde2c58d15835f9bdbfc5b43e995ae95b9e1a3b90e291541ccf8161b3744f0fd56722f02a086a48af492db7bb7f86f8f19094fccb2fc097df83d953a5a7b2bd8a0cae4d109e7b05f4a3179fc9397abb5de56765f5e25885ce61d773a9118bbfc121bf14f8f75dab487e7cf2679a99ccaeeeec6d22b0edfce24ee6886cf563bbf36cbb92ced0cfbd81d11a12e7e084b532ffd0b33915a711ee41e4b5da329f4de8b42dbe5363ce9f337fc3dcc5628e575799ec6ac2e825555375393a500db7d4ea0e7adc7038872c47c4c67a65b3fe3d4c105547b5d1d781a169692fcd907c7cc9295a424c335679557011f60361f613077ce20265f1acf5bc904e310325e3a2e1d9ac1d7183ac6e5d556f6cf9e94f4982bb025bb07258e6cc8500658de061a52782b55f90c916f3729da6befb0a546d360b8c3b9ad537281b88abc3f44f44d2d4f27931b31a01839510ff14279d10bf2564ead10ff0e48db07ac36abe930a06f58a249ae37a3392fbcf4967a238001d2c43f1fff26cc9094c95eaa552eb59779a77ca6854d5bd8c0168c2691ee2b8f6fdcad4db2e86e7ebd5b9348bf2b1257d3a7995535e2b993f11ab92164f429685c3658410b1c8195b79f8aff575662e65e2b88fdcd127abb3926ee8ab730105eef1915625dfd63ed1ea4630fc5d0f19c481ae29dffa327e26c7cccb78b9e4f93df3076fccf3b1094e9773993926e57d23f4a53cf81570e4f0c6f48af3c34de58d4de5a9d2f1452584c4056eb1a71d638a6e2489a26aac7e07c558e846606adeafa720c6ab5029518c6f164f8aba4cdc101a82e076b6efcd42ca20619cebd545b9a265a2acb087c4ef725863707050583ccc7ad13ead5c3610ad7c6506a4f62c83f4898278788829c67c9ce356364188b0fa5ef374a5c22ddb7ee7cb0eab980386e892872d4742c8b29319cde860998bcd2b096d50ea1f3e06054978f0482d4bfedbd439e4ab9d7b697cc682478f477c68138b04f4e6c23ff4338f5bcd66776a84b2013652fbf035d10604301a7113a741839c8359cbe4df67dccdc1568b994562d4d93209a79071ee1a973705f3a3b8f404ded11f41c3212913e1e2175ae94b92e9818e98903d5c1c8a0e909f1d083d3c1830b6ec025c6084c6dbd7696133c02d38bc2039fd3a9a376e1da4e00e84fb084f30fbc74316e5a0dc2581574ad3adf10674a29cf22ed5c70a4864e5de4a36f46661d14ef44a3958aef74045b976227eb318a03517366099349aa297573170d866fe64f860363a90990ff9d9502eac2fbcd6b71065902e83053597ae7bfaa868e20f58f36fd0a98ce4722554cd8c226905fe8651e81b0c412d9a3dcafd0695b5fac99fd9948449175d75ed4c71cb3341db0d977eb8d9bb60fc1880ea958da8e5ccfb027565b7b85ee3bf538de06ca94ba07c8076c2f46a3a3844bad0907141596e4745780565a55dc7db8bff82a083b69ffac50203b2e6762f1a36da3c662fd6b19b3fbbe199bd89bb5644b5487daabda89aa0b723afc5ed0d22e3d6c5c0b4494a6d8184bbe4065e7b2331bc1db74a7d9e324aaa173b76f442cf26437572a50f318de2384acd2fe1d28fd4a14dad69b8e9da53cd79314085c092a0f758bf646316f270f95b6b316820502e4b21d41f3478496386a13e046d6eebbcd652e2c2adbe6272367b023b25b5056a2c0a62be45a645b47d06f13c8c6986c1201ce587319a010043ad5593711990685b24666c8326d6ab76523adbebbd5818c7c55ff867c6df09ac531310d449ce2c624f949cb8908a2abfecdf1ae287a3105627d56a108c4b24b94109d51e1bff63c554ffd6e489ae0ca618aff24d2437f9b36128c82877538b32f2bda9d719602318b683227cc80a8b1ecd026b9ffdaf01136028b647437ed038df3c0dffad18e64e6f876fbae1924d1f211bfc4bfb7b2ee4f59939ef730f9c2eed3c6f2754434f9399a85da109ddc783cd39fb8c42619711d8471b6d6e25d2055324657865e135072351b049fe410ad3d1eedc7dae8930fba7786dbf5c53b067f97133fc3215c342678387211f331f0e1a27629993c512edb7c3672bd04fcd5b57a92756d4fc9abe2926c37de2921b4550e8b2e098bdf3c1d1497546086dface653ec8cb9b9419f6fa403814ebe6666c6ee47fd166c4a02b313f46bae6ac4e408a08f1be5fc774082f49e394ec3e3d2e8a0caf11fb7161ae6219795662fee9f7df142f78b18b414185a2a04c61b725cedd81b00c644e31046a84b5a469ea42e9416b0ad5507a8a753ee0c92d1d9b081ec8bdeeebbbeedb4276f4f83330ea5c1d13b074a31da687114a31e9cfae24b86ea4aca0167e739bf2912ec36727f64fde69f02b081d10a60eea9fa4d73b0f833b1475b8752c0e2699e6a256c646071a4b1c543af13d47aea52f1ec1e06aa153d0f9fbfad7ed88f0d5f194d60b96f87a409f42f50c927bea7d588dc78adb942ec10066fb86acf3962bab1b7b8038927b2b66028a069e22fddd7e5d0541a447aa5dc0ecea0114d510ee1f228995246ab788ee9c42e6bacc9c964688c59da85105d1dde8baaddf7f4b34fe438caf518405850d7759ffcf9400a024ab0b5fc16a560e6d6cde909b7fd8b8045931364d44b8ad89699e25bfef110b157a80be921e081dd43aacb4c8cc437b742bbc927c7d39753f70a441ec2ceebac6866cebafeb3c67f0b03a46b79020d19ef2e0ca8a9e92f6c186411c4810bacd8b73a2eb86664c0e56e06ce9f7c94c8a727e8c7298bbb8fe413906fbd8dd627b23e9da7a50ccf3539148cf49e8b1c7c41c5a711e0d5f8080533faa3bb894068bf8624546bbe8c358460808f3c3f689b31362cc6ee338d2e8ee7aa813d60467bceec8a115e3bf8531c08a38db45b075c4a2203092d482116f48536247863cda5fa069d28c1f225cf212ae62f28a5e566a6cd42b051301621c84e578717c80798e530b0282ede576323199965a4b2bf61e26afbd7e5f1079dd996bc546c7cf36387eef179b9ee0b22be703ec8b6aa1da349eb6f7f1c37c8b3770fb2243a50f42a5e62066737927a804b7210a97604eb103a1186ee07c332576262b1aa5c8f8341473d14fecca9ad180cc887cc27fc9e390d23dd588ca3555b6014a5965a0097ccb215b5f8a393e22b5ea8340c30425805fc43a0e8cefb67242fd751ff25d8e477ef91b7eb52f830dbfe7cb15cff26a99ad0a8b374f2cf806026b9946da1f5931626d7cf4abe1b017beb593f07b1db66c58a76c4bae477ac2bb7debcd39b6bfb7c2197975745c4452a89c86b43dc12bb40c7c575b14148980033c169fd092f9cb36f9e13634a388b049e11917e8976cfdcfa5d6307cd98098ee5aa89ab1d59e3fe1a9ea88d827e5cd63fefd33634c2f11e29529e182426395525357899e80ae0764acc8f66cd35154dc9478125d592fa785aa1c812dad7fadcd9bd113b1927374d9d73aef09aee959e249ed8cc05d34e68584df0533c2773544dba0cdc796833e5d818598a0694173e1e1472e47ae0c54c7cd8041cadf658e4f4bb0bdba9f45bc49954a4d1dce7248da5127988750b7f363a50bec9ea6613580910d2d67c011ddd004f3e9654dc937022901f43a60456e832e01562fda93038c0a3aac6237f72e5f8a52803023a819e4018ffdbc44fc352a8325870ed9645a49c4dc8f6fa5dc425f96d22776b301f16c4a0e8e53ebb42cdb29f020b536b4e0820d6d982aac981429b557c293c42572db6d24e490b57e7855e901ee3862ead2df25740ca60f237a2174ac7e2db5f1b5f29bec60b7e81c6753e79888513a8a976fbf300a7e6f77e48576831db719d49a9d233ff5ac7f18cedb9fb4372248b79847971d5b141508ac5f58eb3fbcabde68f0902e4d653ae74b62b04c786fcd300ac67d71df312e77e2e7c52f9c2e398574f0d2f372735998afd3f82b65c7387ab4fef93666a0f1d21600bb375770f1e84a3466270b6d1bb1bd48644381c6e6af5f242595405e6420d1f135d83ac7bb6ffe5a814ea8236d730fa09f9ca70cf4f2e91008b4c18a1738cee6891101ab437d11049c8a7910c90eb72dc142af619e37b3d0842a4397dc7f36e7d2218483a4ebab34d04e988c25bfbbd0b5cb5e07acad71c07cd759cd30afbc428ea6ca08bcf75a6df8e6c281b29b9b56cf165311ec88820029072bbea8b1b0fdc812a8039b59f0c268eed6bf4dd11c33c4a486539ce95a968e1cef19568bfab50b4bd6b90b7116d386b5855a93947837386ce927475560ab9fbca3cf1dcf38cb83d137cbf327e1a4f63df7f1d119dd1bee85729ec59af96b8e2b313f85fdae3386b44d5aadb6f6a6c0c53f15fb4487c4156927081ceddd66f95d4cae8d8a8a70f80a8617309a26bee5b330277b49f894aac2080703a8d646f48dc9ff85b794868e335d45b7aa237fcc615dca063e1216ec4f548f4aeab46962aae507e2149ffef5bd1b0cf6c1ea22f1696729d461f22699fa3b86ceea61a6ed7a068dd7d17239832815b6ae6e5711a657d895151489137d0d0e4a1a556d5c0dc96a53eb7054bf82a3622f4782f637cf0b22bcea87e6a99dec12e41a0544793f9d4216848ef185a37611237cad0d14a0f0c358caec5163043cdc4705c403c9b6a2f8936d00c24a2ee8ea2e92d9aaeb0d63d12ed13c6a4c95258f581f2104e3d887c0a043fc36ab95c7cf6050c152efca1fd84301050e6180bef37b3a3a3ebfbb2b08f837529a893d56d2e5900f54f95c141e626d03e22ac7d52315e618a6ff2342ad820e3556f69cbb34807a0a504af2d5d73d8e118d06e8fe721a7cec40964ad4f0bbf830a30d82eba081688cd7b734941696d0058ebf3929613630de559184ab8c170d06a7f816f8a2f5309acbb30cf40a4645af62ff3f470f515cbece8512cf1728c44e3d2814b40fb9c3ad0cb285eb65579274c96240267d5ec65993e641c0d7f4ca8ab1da5d506dcadac533e21a7403970d8bc30df4d50eccc0125f6641458fe8489b7d92960ef9367cd13f4a27c764fc2a2e6b1168b1611ad30ada9c7de99af4759cd08246f618ac93298ed69d85655d2201007fdcabf7570cca404a134030ec09990df50d026ee45de412d1f36408e6db844354b132850a3f076c90470286ccb4e4216a97fbc661d3ad3fb06474d8b1c2f0af8dde10ac45ab171ea6a06a5e377299cef1b333b1d1a7cbf55a583147c1e44ea74600a54390894f25b3d927c164ccd8b88e749f09ac0ed249fd5590bc2d37a963fb4f0fb6601c103b3dd42b9af8d533173c553e4978910056b1080e78addae8623e8dde5855323ff2b0b042fb5194f61207676bda9cc460adb08ca0aaf88eb30b7ba0202bb787395e8e3319d010387310b141f8328ec07cb377c2a898f620cd684f47d3aeef2d7b95071fe858cf261f20c2b69faf1fb00fd747532c5fe1e8c86a41f5c7ca6fe46e20dcd278a80a9acd085bb59b876662159b0bf0f10be0b7b346960f1a28af059ffc1b96f892c782f621159f93f1fd38729d70a7f9c44f2b538717daa3acdfc3f417e60a64d5395b302120c61ebd12d61413d2ce27f56d6477713ddffdafa6d4dd7df2553b33e730975efcbcc8c3d99c8e6ca0fe8b982742342ded756a623d695a17aa3e58deb0b1c78708f11179dab265c6482e902f8b99937b04ea3c26cd124a7db4e9e161cb227de452c53ab4c81f6ca6aa88a59a490e938479ae9529d8278b219a9fd180e8c0dc84f780810addca0c91781efd62206ec9bed44d76d7f97cff0cd3760b68a7592bcc2e3b4ae4c2f41e74484a80ce145cf0d4dc0876d8837fcd9773e3abe1741bc8f69832cf18887980bd63dde28cc071919568e4a9b833f2adbce70b77aa279e9154677a3cbb39ca6be31296fb326061e97a211cffc692b8e90c47a8cdecd6f7808a64893a509948bc6a6f2e103b02019f46f95b30b3d324498a9f658fd20f6095e2a4e1c1211a1bc6d6d9e89ef23c55a1eb7969d2812bba540e8d9a535969b47e7d141da9487b918924a0d5da6919375a6db515e29abfe833a826a581f076103e4d72896dc7a8256047c861b2a83c51fd4d749057b8a51d3b1a5cac0cd5704f40a50fccbc5d76f4cd5556ab02574a38be09de4207dca34692b8a8e28904ed50f0e92b7f49c93067a005a46dd207079294d76fd4c0d855a4b94ac770aa60596ad641dadcca00aeb5dc16c45aa816649f1191e05a2635f23f54873bddc6554d719aa32558afbdfca3b25a3bc9ec3f1e423e0b6390f4ed3c4e04cad78a2c7f86f92437c0314139acf4d22c8e70fbf2d8b10e39281ffcad17556aa2008a4867c47ab5a8d292a3bd05ecb2b25f01b517da467e10079f0468d7a1c8cb0996d796b5c517a86ef567d9fe0aad1b16ad355903c72741d0aa663f81b3dcf94b56d8cd2de2a71c799090de25c5e9727bd725448b0f65885b462e8ea280440b75e7d4eb7a22330c4f356afeca92bd8e7667fda1d3ca00e8b5ceea0c4d598c6e1160ca9111215a9bc6eb8cb52026e7602fd69bceaf73077c89d4dc7955fa577e524f6589d90a11d99d8d94673346d2d38a1865ade992321400a9997417d9dab9ab8bcd23bf55b244e7167bc7610b0f00e219889215b24d62f43ba71993d5f5f2caef239c0f686730c0ee4cfaa976756f302f98247671fd8fe955714edeee6cee14ceb88f8368bbf575feacc059fccd54e75116bb68900b310f7132737ba9ef50357e295ceff26ed8fe84a41956afa3a073cba85f11fa61db8bcd559a24aae8ad5b0cc2f7ac853245cbbef6c2d88fbc9b919c9552915d8c447db42174b4d4b922da820dded5507f691b520aaf2a591ee9fec1e303fd55c7b11146bca10c1e4f0f9e7a0bbdfc7bffe3f0a0fd5290851696c6617f16f71c95c8f9bc282682a4a4181f3d227bf9fe92e3149c0e0181350e8ff8bd3323afc66c9157fea18fe2e57dcb66de47dde763172b8c2abe20e9ef0ff29ae866908b495437b685eeea49b6ebc90d2960f8faf13441f09e01c1d2d669926f3e4982c5d239e0de034c41a63c133da814f3a9a931c955320a9d7cc06619d637734df7de32b8ec922d8a042ca609b6fcfa9defe57f0ea1463805ecfb6285c788ec10515896e4d17eb618246d6c3fbe13a9cf359d2797471ced707d9afb6250786eac67f667df07730430e10e9c49d6f26712c6209e3bf4db5cc046acd15908df001cffdf3cd756d55902db9f17bec369abac4c366889f8a9986013f297534140896c5dbd85728464607af516644c440892f8dc050b7cc832cf720b9821ecb80f1f3e7b726da650f2b85b837238f803e035f008bc5e2d0db414e584e71b027ed455f9f01a16b76eba8cae630b34d4d4936b8c3c41db90e2626dd4c3623c2a96333a6a2deb19cb8ce8bf93d1438283122ee655e4467f11163c2cd60dd276cfcdedb5f638537016fd58cc783e8536b76e38d559d114c39247eda4f2eb560a135496c09c733cceb031cd595b9ef864b18d6d08a0f86b0e8be540cde613eca8323461e4ba698aa955d6727b8d2df820affa61f0d92fd927020256240ed0c43c9e56c6e8f97d66801b04a82b5b42afdaa1aa5f4d707411ca3f808ac7dc3dac9353de4f7cd5a4d63b12e909100de8e3e63073876755a35e4782f1d1e6d5636a8acea16a67c9a1f3c5001a51ad32ba76057326042f305dfb5e7e7e2b751f3176efd03441379a456cb7eaa33a8afa562edf5a30ba619b9a8b43f86f40b165d8e019e4bc61f4d21ed4c0ddfb8a705d245935e1141584dd765dd81c809cee9c72aaf9bae19a77dedae44f7528abeea252e0bfbe2ce903a8e105a51d22c587c244ac1e2af9e32bb5e49287293c95253fcdf8ec4b3d10d721dc40479f237d6d654f8e6c8c2f3257cf96d2f4fc74a843c3ef35a4a3216e274b85bb1f418155473db036f3aade3e9a39afe57d25e7d47c656498d2aff52fc824487fb9a81f45564de78a7aefacf857b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
