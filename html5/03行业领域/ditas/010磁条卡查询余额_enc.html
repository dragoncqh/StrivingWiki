<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d23ea594ba53578f4aec3bebd5f921df84e1e15a35541af18c537ddf0f871f13ea5e80846a200a4bacfc2c3a4082f08b430ceab74cb5ee7954d43c5755c94052c55c505eac21029c881774a3968c35caf3e8356d2dc5ee7265be27a1d97b25206694cce85076ecc7155f8f2e4d857d4bba9bc03c7d4efd2e5e115254eb5904c8313ff3a85dbfe3f6a43ef4338b68ed0533b1cd52d4aa99060c402905e2c37da5c508c3a202d8346dd7def0b4284ee2979f79a787f460b29bdf765dd7e7a6efbdae3040c7e6bd8ceec0080d3df7aff27ca4a435411104d2aeb418508106a515931fc5a29eb977da891249cdb24b07c6047ec6c1f4db114a08b7d77b94ae678cc8e1950e01e394c33f7d3d40bb5fe2ecef05e26215cc71c454c739ac12da574b23d4481eccec1f2499828bcf5cee67e92175fd867d6727c614228b3f184bfdfe871b00dd780084ed54331d6b0b7e6c0ca3450f71340358c0901e9868bc5dd4c8e956090e20000df2e30aced1525c7467af0b9f6d25c66864c052f125ea47e2632f12d6150e41b880c6fc6a4a77c44a0341bf617c50fd72bc7fa53139b7b1839096ee95fa9636955932f00db375d8d960b5d60b5e44c9f6ce2d0fc86e5794e8ae9a1ed55659a42cdf94ddb0203f32b6c26adfb97920fadccf2f209510d4d550d04bd7c056f35da70a05bed73a1fe01acea84256036939891064b1cfbd5dd21d64ee014f77f8d62078d1538c448ae0d51cf7706ac931738aabc63e678dd14a07c73996a7ad5ec1fbd664ec6c43ac31cb46dc4138df6236ddc998c48b6140de1c18aac405640d891804bfd9b6c4aeade933f7b3189450da82e09740bae8e5251f60322d9e4f1f1d9895be081604291511f6a095b91eed39231ffb88002034447114b86a0c060743709f2a3891b258adb1269972bf7f32b7764f6e400afdf87a107e8d7cc948db0824de88c86a48b8d95b9ad57095f312d5806d732e48a469451e281b509b05d091699ac0854ccd8085c042519cb1a19678ea55892318e56a9465b0c2fb061f9bf90db440a8c00228b82a9b3f3743f8c05c2f41877490d81c3fdc98c4273cbfe0a9fc5f8318f0eb74b6bc164eae9b31b08b291dab1898fdcb5833643948591c273c447da3502aa65b1f7324ed9dedd6509440a2bf33822f599f1dfb89c3feeba9b68fa575809b75e2916a27e6ca88e4d79d96a3c0c8af87610e08c353ca4f723d8679c2983d2fb00d9358a5ac748f5845e46ce4d6a2169a8df09e0bf418982910f1c45fe0b868f19f34c0114b71c28673425853b128437e980396693b4aabf037101a4b3cb675a8632ba52e4f6cb50fe4735ddacfdcd5e5461743c0cd9ef8fd7979bb9aed4239b4b09a8ff5157309161687f7e0d597b1108262ae3b146f9fc4140ac2807a02e32b5db45a8243aed72d29af6e2ef06b09f60fd0e5b47e95913051d2ea8302509df2f6dcd3f03520a363791e4f44aedba9e1a4ed63a0d71870955d45f124f2f472c97d76de2abde767ba6b33c355f44e07bb53530c95e45c3d221426092b99c1b7f3d500352118fe11add32c139e943bbfd32960723cd1fb68066ceff74365b3fc50188289811382b29c69d5011c715b70360641293954a8f2de89320db5007b8a9930553587a0b6f376c0c8ae05da99405679c4a692c4e9facf1cd8a0468458ec420e3aa746477ae46e9006eee7f1d46e828525bdff529bb2e35a3232d7f25c043ebff2eef9cbe3c3c367d49a83afe8883c4c4a8dfb6929e493bb4e612b2c7d43072703af24d6acfdc0033ca5d6204e82742afcfeba23c0f18412f57a2d3a101f7d8b2493eb24c81d0bfe00ba1045cb3c0862ed8bc4a84124dcbf5f8d8afc61dd78ece7d596f00787059a480017b2e2fb0b8fbf9c3e4cbb46c6e12882d86621b9e21735659638ce85a7f786cbde40bf921f474dd770b7d2dfa8c345feb4d856392fd5c2ee888ec260aff45030d0bb7397aae52db97b1303161c17576514589f8a386a9f08a38eeb0ab6a66f00d10bf32d20104dfc81a3f1b7a1b655ff7f4cff50385390121945c8f3ad736c9f8deb497c0528c4b60bfcd28ff54281b1e4653b511f6f077c4db2daf410deb407fe95a103dacade05b57782b44a639adb8b159ae6a0184860ce359d059304d646edd126b287c5d46de6541a4a9f18f738e2caf34c1ff0d4a3ffeb97a656503123e42eca1383123bb04e2a04a4c466bd25f03ccb087d598bd220427b7e0c94cb8b3d429cdb3bb0b02c8d3e1e49fa19347d6a14504d43ba693226d4a93e74d8b750e0a56cb36a75ab7166e294962fe6188808650ec4bedb0a14fdc9913912f3f2e9f109310de972734ad5b284608e5d1550abcab43efef68333ccfdb5467ace2e9fe4cebcd0436137ad533f6d3658f95689e9076f7828b1553a2f65fadb542ff24e063c130866caaa7e985bab0901d9828307e8ab690c57fa1a2cc91b81f390f1213811575e27da547048421b3351726e50fd768583ca2e5d6cec04b8c4a44e95c825726ccacf9215349c1c6d3d6eb0e017b81e498de9e61b3e3b7868218925394f9ceff527d3c9e30dca3b4fc019aa70d13fdd5dd5062f970da36fbad73950761065dc1c2c002bebaab983903ff902f8726ac549f3a68ae895e5104e3423fc1c45991fe314cbaca915e68814dc7e7655bf31b70a31726ca96cbe11e4c06dac3fd4adb512d901a183719e71ec68ed337f8789263120234f3f7e9465c9a2f160da4d126e3ce08775fb0e153430254769a552295b4d39cb150059dc2d37047e445ebd7bef84d0474efd3dc19403d1285893c1f925318ed1d161a2a9221a65c7e1ae27f3b30b8f133fa90fbf7c9758f1e94d852e8b5773a74e32bdc71409d1bf73dbf2b9ed3c9ca96242eb35728b7ab744f8395f3408e1ee140e21c77c4c98ea7631cc63476c0965abc08d0b8a0c9ddb99382aff9b4566b3f79ef2fe4a894e56d2216a71b7aed2aa23b5d21aa07f03ec4db0a998f64ed65dce4fc5ec4f5eb273ae5bfb923f1fa4d8d1fea2d51745d3c23d157b1c609afc28ee6cd37e376e77d80d7319d8f3b9530b9dffa809dddafa606abc0a4c03d7f7188b380d2fd97dc0df6f563042bfa85265d8bcaf84da7df48784e8830be92fce44d542e8d355a0529e9ad368f6dba35bb3c31e738c17841a227ad2d35ed5f6246c3ed7d7220ed8dcc7de41d44d16c935a1419674fc961e56d5893a783a3ac474dbd881e5dd8ec47f67692e5a74ab82b5c25ccd3da7d9f06129528497f4a1e576d413479b7072016a28c8b283020f101fe94b3837a97c77b1fa6e2b5e39e47b1a927e30115245d5901e203c265e9dfec6dcc9592f0ed07669897a3ad6ac33e802d53051560ecbf231c66d75f2797e8c9088b4515fcb651c03d98305dfe0c800705168effc89421d38634caba4d07c58ebdb6faa64cf750f1b597c8f4a2e3fc1f857f1b0f9c8145eed3cced24556996e7dcfdaf3fbb1e8a7780a9187cdfae0db6327e16a0c5aa80801f46e5c9a26d89c53b344318d2263655b48742a970ccc5de098e647f2a6272ad857f04565c56e02f20b46594a44a13fe0ec6e5ab47b2412f947bbfd092d4cbe1114cd4bb7562d406829a36eeebd2fa45d4163386fe6d1252fac5314ea5812c8ec7b470e1d1b75fce490a55276fd0b842b4f5bcd44e1292cdd138556af92597560dc8c70707d4f40e90de41eecbd19a5e099d88fc4b4ab372d9b0417853ac3794c4cd032598d764b962926faf30fd9047e77b9071335d205856953068d272d8667491da53225ba2fbae2b8d6451b84d6403ff9383101f2a3551d35af1be15c43d51f27614c4925edbe0ef7d6e3e5648eebdab2c37e0eba9889e80920b1a39ab47cf22bac753c3020a378ef2643dd99d0c1d3aa95e44ecf95e79139a4879dc3611660b347b7e825bf25ca4baee32db1a271555791082f45b03f6a71923dfc0d24368fd829b8cc23495567a170128427c3214f00e672f843af7b44e620dec0462d70444c257195518595c0726eab89fd5d96f02eb961e8ef55d15d4f5f79c7cb5bd28ee9db05fa6aef911da187974a9633fe0e4c627af0ec0636d1f66ab34f1e9bfdb3cb3cf9f0acde7374a1125bae06a0ef11a15c4ec13f86c3b70ab3f8f90310cf8dba43833b0e481a3e4bcd4fbcd2bded382352cb2c4212148a6369d405db04620a4a0432c6700948e758bd5179e29171bc4f72cf6385b977376a0acd762804afea4547eb8e9c9493c1a983c33e8d2881e1dfdbab1b7c3b569ba42fd8a035aa337a74606177a260599a78f0848f2a08c376620fcb5cdebb9b5e26170491ebade3e6eb3164325c066f6820dac107851d40ceb1276d1a9226a957c227c524cf35ec8e9fe799e64fe530c1469f51092b9fde85e6693d3ab99c68a730fb848aff6b7f38e535933c2863a7a7d5832b4cd4dedb2724d4c3c1d457480ba22195cc3f38081bb1906d809a1c96ce1a452f4058eb06f4df368af83fe2ac07bc10986d5a8da6001470a22d35b9955692f9fada75869595f1f2e000baebd625fd8cd651caf1e6aa82ca2fb8a68bcf1d0c3bd74c31a7acd417b87a5ba1e26e846dc138d3f7436e522a6f439b0b7b1108d35fb0af6fa95fe7410af836b5e5330b88af8d40320f98a6ddbcb27a6f09054d94f6d46db7676959958e49cd68da67a29a75ee68eddd151f1a785fa934a0abe26c0c494dc1b14e6d9711d37f5de00e85ce1d7922d9b98be8edb21a10116847e478bcba15affb168d0b62363b9cd08720283dd989d281b1111ee7a7b76d86b5953a3bef289554b899ef6167a14ea183014b1b568b4599e679b793ef857fccd54aa1d7d8607251485c9dc294160510bdfb956d1d789b7b3c8e0801440a760702e73e33894ce4f64a8a23afe80a99681977eb5fbe2320ccfab4523fe984b41b1ec749258cb359379f6880dfb5f53b439252b5e15166b99de95c7a0ecef515f22724abf5f4153b4de832f37ea9b6289f38157111bda09efbab63200107937bde9a1dc251e5c7f7c4d88717ddc446c361e072c052b2b8eeabf6c6c12252019145e71519b3af89c9f823ccbf1cf4b9df96046a70b26c76a9d4bcf4e33f2ba48a055107ac9ab0a2c7872f40f3d0c308f31caab95246972c74af6d80325fcba74d8ce015b8d2f2e0165f02f0626288d80df407706e6de14846ffb9e908ff49a1d155c22d2320e64b9a4fdccddc641d3b5c672935c514ae28f52f1e77da75b5ae4364e34963edf20bb0aff17e935df5185df3a9d919de9541e5bb7ff7ff2593dcd5112adb8094bb52cf6dc554af2c54b439f74a6539cdbf47581f96b665a220066ea71ae0de642b75c18188fce3edfacf740877c19d424c57b2abd6b463bd5c08cf33d6207f4c94331c24ac3d518dfcb13f4fb24b1ccb785da2a5435bb7410f9f0f467a14c0475e7c7db6f8101b74d291d6006eb5828ff9fc4960e20aa436f4a1507e92cc8a9c2926f69a6f66b73157cbc17eff2693d2d2b0fb83c283f22fe1173054d27e3e03ebd57e20635db884969baa5bf438756a5b3fe5bd0ca511cc797462f77bacf911b36363324b20d8581d9e9303aa7ae6d999531473dfe787176528b5ff14d33830f50318c9aa2921bcd1c59e457f129a8328cad641535190e1a25ccb3495dc77e101db68d38805ec145ca254f21209801e0649ef2e57fcf98717e00a6c54c4428dba47af9110144e69754ee788bcfbde34f1c81dd03528aa448f9696cfb7daec817fd68bbec8c34dc510e4897d53ee848079dace49e621f348bbcab57f85a389b9913d8228e3389e25a4145ece6f2c2196f84ced2cff434a994af665100ce717bdc5e3e15ed70b471bf8e02a27eee507fa11154e8e0545d6c6e34a15e584c2f0cb2bc34da763568e1e1bd4e448478b8933c32866e285f0a51b83f428230dbfc61eb6385d66d7074b4dfb331353494249f62980f273ae07d0826e5a273bb4e1d9cc9c0222731bda72c10ae8459cc571068d2b6e60e2c5002f120e3901fca32a49b85c83d44564392768124739b346f9930329aa00d993d4edf7dc50a4c1992bf5944fea7d549119908dba0749bf0a53f1aa70ebb10826eb80af7b81234dbf2ad19b3756ff5ba3e158788f674334120ead4cc6cc51e5b272b6d0207bd813a6723eba1df5f3c4a89873d2561b8854bae7726984bc90c971fe5c7341d505bc65ef160f207297cde2bb44d012187f7dabf39e0fe5adf37b7cbb37643bd0babd7a4052a84fa986e2e05120f3e9af676deafc027248b809097281f5ca15532733c2d877f9458c5dd63142be0c6d6f29a3482f3a039eed95ee2b19be9a4b8a83b9a719b0e7ef5a9691675541e91bbf4b83203851f03f713573de5b45b5595f73d63548bad04606db6a14b5b959373a8cbd710ccd148c98b938c1165beb7a68630a11388943dffcef967bf637215feb7107b9560b8d96327c6c45232cb132a234f2723482c75217a046b8d9775fe019e8e38e420b95558bb43e960ea8d6df4da02c50ccc331bff1a41a9bd05ccbd05d74a89a68f3da22ad2dce67e5cb11502d913283374eb434bb4777fe9c2f565ed5dd50b2758caa442b143fef3cfcbf44834a8e018841e70b215ed129bad24c483b5d470a774fce18310da583488b1f933b7f0b64d4b7049af4c77176729ae6bdeda93c2c208bcae2508e500f623988cb0d901d1090ffb6084cb7302feb4edb9c89c0c4af741a8ccca87732e2fcc98a8d0ddbcddb22c9572aa83d3ed8e5e89a8d6a238f394db0dc8ee5e2afe6af101176aa6fcc03dd63bda0ea80dcaa5b4224799be22e95150f04198dca34bc9c5b048527e5728984ea1c375613fc996e77576186faa22140a88967809745c67ffec0809890be7c2ba1497463b66ac4e6e2272fcbfb8143f5643c9a928625dec4b7ba483a22659c9d2be2307eb5230eb736d91fbc489942e4ed862de5dc7798327b0b9d9a3e115a9b04e2cbe82370e7b4cfb4c35f7a088180b21d151250773d9b2e15d897fc4ae684c1f340f0e7c0f0f1ace900e63658db08963a96741e3f9059f2632cc5a3ab4e07cd6c2f3f66de38270a38933a6b0523af08602f2dd59cd570d5adfa8f0ac0b66b613e2f7e368cb65f720f3ccc3f6da5e81f64da97647e8128268126fca74d951526e8564af33fe96d72ae6d4cfc221afb07109b59f63d2895966666b3dad15a3c36f0cecd5fd1cb9dc2f18cd1a84a636a8579be3c480a9fdfbf0cc242428f7886772c39f338f924c464c5bf82eb145a415820b86bb16cb17a48d5d58d8258f9c5eb1f7226e72dc961250c06f4e672513666cb7bb5a437dcbbb6fc442facc57b1eb37e4252a967f205c3ce5c47c3c3e3b03f591aca1a86834ed36e51e457e19cce83e1b801f7cda23cafe6bd0df0df6b8b8cf1439af94066d2456fb0704d44c779edb887a7f20a2edfaca6b55c3e8252d148f76e0606918bfbed879aec8c657b393872ce6d84bc6e308f2d1987eb72ff885403b506634d494404037a799e15cee72ee2a0db1d9d0c7a7703b2992e451b078e9dc5f22771f271479ace1f963b933bd7e3ba332b5c6b20e9503fc0a1d4018a4af04dfc3e6b3fd7adae7938baae075667ba8c419c5585191983c1ab2d7fb3e4a75a0b2f7248c35afff585f5e6b68643d5cdcfe1955a6b1c65f8039c4a42fd3d3d8fb6c752226b2c8bf5758f232660c05dfe83331e2f973787e612dbf79f1587176ed3d55d4303a808c91b6147502212230ace72e19817dc2d524f0b739635b14b1460f393f59d113ac4937512047086d0b2a93fb0ed438a0882b200302a4d354bd088aa8a718362702f0df4b530bb0c6339c4e60ae2dc365286a111bc457f44eb556c9e729433bb55f739dbb9d3da49c7038cb6d64a2948461a79e3af2675509646e792ac1b010e69adb2d7cfa11fffedf7434b35707dc92a76f4b25eeefe286be53d8ecedc5e9d62bd1d3ab1dc87c9616c502388cfd2e0a6fda84822caee2238721d3731ebee4cfd4e1b4d938e888b3090b769a16a3f5b2c6074182823834e94a99608f4df447911bbca3fcd2f0bcba46d9ef700ad91245efa16e25ed9a3f38392463952d95a44f18afdf651c37f9fcd4c28ecb24c30399f3655a476eb7f96dacafb67048ce8b3bfa99eb21624e9349ee0393f9716e8fcdcd4ead691205a7c4d420db8c532eb577d1c33c44076ddd66fe45aa2eedf0ce85af342d78239331df66241f3b8296ca8d7c550ea7a2c13b51d2db1645ff17cf4883ee9a37ec58a6898218bf59dcb7bb8c17d9c06b0f16b5e51996089f55f103dfc37052456c897be343a127d4b591872fbc520b9f2f8e21aa5c482c7321c5ce6b00415b98815988f75829da403cbb0f1618c706cb6534f7758b6933f503ecdd66d0533b408e5934440af8812a019be880f7c5f4248280a0b50ea2a840503a7e3e7a42ba0090ef24dd54449f59e6a033334a22e2d5e6739632d538593bfcac9ae7cfd96b247147eff9d8ec973bc23244ba49af7064d7ffb46d534978e1856f633ed62b270f570291db65ada4f3ba0fba64e801c7136d8362763ee66e9eac28138b6f1fdd6af81dd789cf658c00991f604644dc351e91939e869a5d4c3af5fb3d19c81a7c5bb10a98f9913fd618a6026c0db398135bd2294d661b1744ec1bbc5ea5b6f4cf1c8c1d59d2c0df96181f92a9d4cf4b4739d76d49b61ec344fbdc1901d245da867890f9dfdfa98cca35af961fdfedeaefb87134c9f6b94564e88cb334f6b73fdac495fb3326142493bf8dff3315fbfdd3d618ce4e5798eb5174f5e1f7a8c06fc7e18bb6e3fe024817bee25c63effb17a72ca17218e6d39c10ee163d982d8ac99aa120a41bbb83762fad75fa274bf420ad5398a637eba153e3042b907445bc8c9ad939fe516fbebd558f4c5530f5d03e0bb6f64a74e9e8514700526393380af6e0a2e6d91f473408be9b4449c7c8c79dd32772695eb67f96655eb2f7ebd72b7f98bffc7e233380d383b6f084ad976242f5990051ecdf6e1c81d3d699af7611144f8a68804c07c236de6682f3eff81a484d44ba9326e55fe4b7f35413e276f104bf1a4a6e466a24d6f3e11c0b1fafc4dac425d61dcc891b554b7a3b2afea181f504fd94b09da8f853f1fa6c9fcec37f05019390643905279d3cdf0e0dfd7f770dd4dc3503af70e72c5cff9d908933f0678e06f02e849c417e3e4230fa87d6e2070f77fc6eebbd5c4cd0bdce9f38c521f9157f5837ff9212241a1a0148ba1d69ee7be27b844ddc68dd8cabb4abd76511d60c9471dcd4b9dfe8681711b89db19d58f27eedf071b3eb8fb4e35583e17b673f4f1268e92926494b981ffc2d688200c0bc6e0ed515314b1efbce3a47014edca3185ed749a8c2515fd5d040cd99f9a8e706f00e5069b5e8a72de2eb7fe684f5419fb00e36ea28453a27dd82f0fc608a3c71923e8094456703365ff4e2eb8c8c666b64e2e279c2d6ce783ca314ca62ae2333b340a31acfa8df9c34758d5bf91d6167a2c4eb0e812c80ff06369deb63cf1fd7b945f0e477fba6d11eb67b636fab0d04d78e4b2931c78de3114020cfc91381ade54051a6bd336dafbd56d06d86414fdd754d15460a3caff56d17f062c292e148f0a075e2ee0d7d4e5ef0e46d549e8f743190927584d9f6d196af1feeb8ea26617a54c097d5f52e25dd1b7d3169ce4b301da72f6c582842ca8557d5111e7dcd37a2655e27b9683cf9312218b55bb725a0693873af9d3e34b7a8261c58a4df9139fa10496ca9724e4953ec7d1e56e8aa477abea4436e74f56b2740104d49c0cbdb0c345e70c7400ec03c5d37479f15fd16de42b0a5aec9d131420ba960ec6a133f66e6aaa4e2180a5651e9203125429dbb727678d85a7d3a62dac5ed5228a1d88c67b1dfaebfcf78592fea89e66eda07d7599cd8fce7be659cdb735c2f74d7c30abf6783e9eeba7faf1bf4b536a2fb2a13cfc49a53f80353558b28fe9bc2d3479db34712c6d7231c70aeb8a7186dd49e6185b3a6b808a90a835f6715f542e528e4af0f9c74b5b7e341722c660684c52b2ea6fecd593057cbc2bcd00e73e89eafdfa4d48d1368cc3029137ef9f112011db8c53af678bb288c2f2a02300b97d05d6f28c19c51bf3bac93c4664fa7ca10ac2a0d92dd81e5c770baa0cec38c2890843e6bcd82cf2027edc6dbe42b8077bd1aa114594ffbb48aba42b2eb168f48d6a77bf38bf01aa6a8a2a51e0ae63dd16b32fde7202e87faace4c48beea198d6691818ca5bcb159ab18c2e5ef307569076279b6e8ef0d9dc4d8baa90e338f4a3b315b4a8c82c517c65485ec900397f2750c3f9f6451be46631f337bd68434bb8af2f44188365380403d8e4afa96294b61da33df75a8658105549ee6cf2365869bd82290440257d25a3b7ad4bd1f94ece4fd5b9be24c985403085cbc063ef39f6ac0c263c2e9a09f248522d27fe93a55dc614e3dff0656fa4568f311d305992fec794074fd4489edaed7ee53abe8ea421c00d54ffa23f8ecba15be60cd63dbca37341009bac082bac66575a6ce6b6ec455557febf6b92bc8452161e6417bebf6abe41dac2e10845e722e8c2bc3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
