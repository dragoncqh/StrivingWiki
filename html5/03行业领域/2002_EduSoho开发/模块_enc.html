<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d4c5615af8b73ff71ac87f056a7543baad84722c64d419ae8f4d03baa00e22b44c9a841e7096bedd0fc189e5b566daee21cb751095aefbac5d487eb6d5943c9b241e48b5265dd670aef2a5cec1361bcdba74e78a7322ad7679c3301c396590f9f9c07e2dc5ceb4cbf3ed5ca04e61b08364ea373789c0707c29069f736255b96cc56f524578b483d7bdf6587ca1abb07c36bc3de553972ec5e98c6f4b96f5305ad745d764435e666797f219aef31e0fa6f4bb7c80a17ed4d176bc3496ee814bbeacca08f309374e7738b2cd799395c36f3f5b58d38b28c7a75cf276fab1b8d4259763e90fc18c6b2a74a0e637614adff3740fef2c137401a604c8c1eed998bdc27797af91237c22728da9cc6715664411026828ffb1ef339b1dd95bf684001adf2b14d00693897c261ad988cba27b59d1c027fb064b18c0519a8e945cfb9f34b637cf581ffcd2839d8e8fa3a426c27f133c3cb27846ec82c344ce884af520aaa49d5dd1cb6461d285bc74e8a7e8664bcb94e3beb6bb32f5be3cb823b09655d1e83e6e374e3ab25d7fd1d39373952c2275089d2e3f7c502e5e666bc1f124c27331c8e4f69c07aaf8fc07f489a81e902666655c16bd745e6108bb36bf20868f21dae4deda857f7c5baa2ddafe3a17e15d6172b8cd4caf1f1b9de12e449083d7bf19d389830b0b76f20adf3160b7e72a38f417ab5ced557625e7b829be9a2cfc668cf05d280ea0b552e66d4027cf2af923f94d8b2fc968ff3e7e2bf0d4589fd6823d6654c0bd8a49e3a92270047f9826d7910a15532a29ad52ee8013738be98d30f2e9c8e405dd7cd883a857a5942c34a97bd62a9d6ca557a58fd651aaa14c5f051c7de40cc0e8d1eced764cc8298dba52a2aec02bf0a26f4f5c007bc1b2c7b95d985b99324871fabf97e1b40936d430827840c9a12bc1028c33d96539baa0d82eb6cc7644a703c7f225e735214c63dc0671ae1d0b99a36ea1633acf749ac43507ca88efd2426b266b06c93c67bb8759e8a6fb02373ede3c66ad7a5a7d9e0464ef1d4505e6bb28539b5dc54284f5dd07fca926d99d470435a7703a324bf5c1c0fd0cc6869668f268b400f491a1472515a754380362c60c561f194dec06df66663dbae8723b130d77b64c47e74733c6ca360b820689a2722adf493cdb4794298807b86fef0a6484bd7c5f195e3ce88167fcf57ec26d16a9e100107f837b13cccead74eed8b09cd331c3c6d58ead9e91ba9299561ce2545de8cdba54078e6606e096c2493dd0b999a5d9fb1ecf6be5a83afc69aa4fac8ecc881b3d00a8d016fc3f5cea7ac60781a5e3d50b336f48fd64ce9d8a3ebbfcfa5246b2321ecb7929ab9e783b6d96d2429c1e2499879fe65b4b66b11c12b1b27e46a4ce57b98a5eab44a070add88edf3692941df8fc7f0201c5f668d19208aa60ea112db48b7dff7efcd5b42d34ca2072d0992ac91405addea16b3a11c5d5aa21f133c5bd5a4201fccc861b6c3263d706fcdde0016dbb889a7b6b31d00bb8c99f5634ced7ac5829472fb0386cb4dd02612a0bfd69c1bbfdae3b717bf5c93d95db251ce8539791cf6a12cf9d6a817188da23ae29bf2c121717c6366fe0a00a141396f352bcbc10f7c6a5e0ff6276e64a6fcd825ad96be67414f4c90cc20608ffefbf2c27c5d6bbb116a229997059c7b92a3b646064e5725f610639db14423116c473a479457ddf66ecf6b710c0be3c6f11dc2c6dcf6b6ed716111cce1b48a8b70842f1b90c581818d0880d6d85485cd602dc63f6166d1f53d9b6eb5a449bb3efdda66ef2a2164ea0e8839113192bf86dd4a8974d4c7e3488c031783025404fdf4ee42d148e8f088b678965286925fd62d01ed0162cce8aeb2b1a62acb89c6cf3eed5c66bb84c0288058ffd53ae548c25b7ce21bc381de7d9c2f4422feac434b70beb19091945a227e129a9821dbf30d27dffd65011770183c49a20de56ebbff6bf177707f38d76aa9a7c41737461491ab196e12a04ee87eefc165f85c7a48260e5f2a4528f9b382aa0ad39c960272b7e2c1e5921920ac17432d69954e9f615e3014793323d2d44a82f34b762805462ee0976c48f110b94de08a1fcf13a17eaab25919bbc3d9550ff50ec2b49c2b17e8a080a37da13d5c84ad580af6bcafc77993ed0651753a1cd2989d5ec28a1b7fdf22c45c960eb96f305194fe72f42e2ab1c0635dd8a104a4f1c4eb2f7879ed3ea35d6ad2e98f380b0292d5bb76f48e1fec2f91f4533bbb12f6d9da4ed69d69e6580eab8fc93a90bfdff15f323c57c693074f1ec8c7acf1dfb4647faa148a0e53543dd2eda013e4175ddb95a101a4dafbb6c293853ab0ef76e32ef15939a7a0906776c8da260703f4a3d397054cd601688c7433517da86f0d8d40925c350bd5cdee5488e5c13229d1dcc8e22b2670e16ee8670f05347def15b66156271e795fbd7ba466d49fdd55796e1de0e49c042349eb8b8fe69d625ca4fd82ea556eccf9792d4fc89442f41fe2eb22b37172d611e88ec066ec99b1cd7af7ee5475b2f3d79380b9b9c236ca2a360ea18adf5d8ae89677251b3619c1c8a0af30568220869b4dbe3aebddc754ecf832f5d1826af94701539c2abb84969f4273fefd6438184fd419ac19a04d04b45387f2495ba2bb146b4af0391dd5f28532eec107a349855d4277abbcf33e6a2694b44bf4e73393e5d98f03d6f8056c277c5b1f527db5d3d2672b382969539b07acfde9b635c5e10b03e89e964e1db7e310220ec2d85f29d4df614f2045739642b77373649f2b4718b619e8fe3ef8e5c1092f4c3fd0867a0673b9951227237741091a5031d94def1554ab96e717d903c65228ce49091963a768fb17871e34a5acc76733d0b6197e0a573332aba4e438073b206e583e55be5a9b6db52c2f4e43b5146038cb535b317fb596e3ba125c964c84d376cb2a41cdf381d54123d6215b2f7603743341a244c53b38b5c93de365e1023a97ca7479cdd5dd66f18a6cab222a04bce7b26c19c398553eac2b3682161cc939a7823588b804bf61007bab372cb84aeedf67f6c23736ed36ec3f3e6e1de26ff8a0b8a3d3ca7c6218e4331c8c1ff7acdae69461bce71c698bac604315e6a3a6c67326cd1fd177900d28a3183fc82b6c7c09054f31e7ba9a44ed0541b36e2a2343df3b2e72cc7b4906678935e57c69ce8ca1d14f846fb3a181aef05cbc5d17bcd21f4c1e343ae19f70ce1f7c3ad6d4f379ad2c9be87ccc7e8cb07298e82b4eb248bfe54fbc03741a83d9b130a55d83ac26202d5e627f743fa5ff62dd66791da61930aa7b84b80030e40af8c791b3036c31cfaeeeffd7febfd5350ccf8c888352e2d5cdf745a57f5f5ebd10d0a3e0dda28fc7322da9e0925b0b110e89278d6d491ed3817fb8ab265270e222b6df74b69dc8ee57f4513dda4dadf7a966898b100367497df791a9ce0689d436bd2b4851af8ee0e31974b1417d6f2370de29cb1b373dce5b124d34c8b3500dcff48677849c6c01abe5daf65b473ce3b972fb6fab26248a418ad77df1c552dad0631baef2e4bfcbb74b326ad61457527305efe5c61e4f039c8f80637fd7597e28d31dccc8c3a0832cd5dc63ae4db65d7fbf04fb864d9c86f3d0b7ac887d6798685497e026fa4a4e10dcc1468c2960c2c94c3b60df40b9231de225477bee15af95d11871729ef60b3b1063d7248fa10bb0e6e03c20322134eb38742be55743d57d31475eef179f1a7f7f938b6d79f74ee6f234f2f6e912ceb36d80555358511e48786253ab4b88ddd122dffb2f10e1786f185ca29e94a3369783c39ce79bc3ca943c297c327a58df8fc36c311f383661f2f2529a7dd423a717f3ee44e59db82ef6ccc7f8b598b742f9f240bed76ebfcbe2caf7d84663d60d9584d7b6c852bc477207a72dc75964b6f9e3d2ee93909c3914413ad240a790fa73462420a2608d2b4c63de316d7dcd09a1615deb7dddb85a723d91addb5eacd043790eb066f719f03e96fbe743963102a679f51522e0a0b5a12140e745f4028d795c13f89c1003a3cdba9952a63eb0ccda0ee894107da0bce0a309648ad6f6d5d53db8d92a77c3b6c2fe2cdaafbf11d379eb628e6dc0cb94213dfd9b83e26619693049accaa395d5429aefbdd6055e3fec20590c091a9508d958ff813a878e6270c2949c628eaa6d884246c4c9697bc44f56457986f39a232826ae8df49c1b9323931118af91dc2ed55666215876aa544d75e2fb6a6024d9919a25f643191594862af3d389d076a5307aab295d307433c1dab63dc315cdacedd3142be539b893efe7f11a7619590822b5c208689166d0e275df568f33dcd5ca557bbda989cc172303f51938f8d1d96d857d6bfd7b427a4bb1521bd0b7921ddc4ffc3870678d60d95e38c2a02a1d80bb87d570e160de363b2c84bf2298241ce175a70b3f6ed99219dc236bc934e0aef3f18ac7f21b68312c50c034a3848629bc7662cbb6619fb3c1416ab8f79c65cfad256c6aa37f82741bbeca09ccd8f958751821915fa5ff3707a0556e23f823541092c7e155f5b6e7234daf64d216aa381e47c5c0de8246507f9e5a8afb47d854d7444562c357d020f26f7c3ae8238eba4bb35fd9a4b2d12f515286edf19d53aaffde768699ede955f5998ce61d4c41ee1d8f51ddc8b45c9fd4b67bbcd9a54f722334a868b411b8f96fd358534c37ba9112f6d0000a4fdd42878ecca68d24250ffd31bfc2c041f274a97da5f2dd10f8cd160ab8cd424511294db7f08e6325ee15ca66df4716b9895bff0adb0feb55a39a4c5b1a5fe60b9dbdc3f681158717024077674346a85fa42dfc7eb7abbfd22bdc602193d42c1d0459d694edc0e7a015fc68c8b3fe59e1a56fe7ab55c0ed21cb2048e150b1eef183a46a3305762145c46207e09d9f631a69d0f8d9eee2b74f3bb2216f69ff59f40389c2ff38751202241fe509eda5eda9a64ea87204f9d74c6e2eae687e8a9abebe1a9063fb0b0034db565ae1dd288f925555b2fdf2db570cbc0881d6d0a7c548735d8ede2f07027b1b17b5f7f4e85a60f5f631d2ddd63c7662b8d70e681582309d085b8e4355f5c2aad59e6ac082f00dd1b00624b794b1bce8d7016f4ce64b1ad1172f746d58f0cf843c54ae4f45335f4c7d62e33e72c2e07a5305b88a708efb8da690da018db2370760d53025a051775bd4c9af186933868ed970c5e70165478ac098d81004d1e8a7f7b5a167b34a25b54cb09e99c1fde897aa386c5115ac21fdc5841969406b495aec9410ab3120dd8a05e69ec907c3314ddd2afe3d780537b66eb561e17bbf0928d4569e625138e9c371eded347193148bdfda9074a6a32e1e64e3e460a26932981adf7fd72eaa519e1614dc9a4042a0e66c495a9871deb421145c9802891bbfcac2ef17a07984631dc9329f3bcb0a5769b1b5a95ff6b9ce6d015f3b4e0ea4855d4dd560ef1cb8e8421e8b6fc96fc7c60391c99487bbb13246c15395857a8fc2569d01450c6434882fe886c167b0c07a20aedf32e25eef4f1f948ce2ffee0eb00e992606019d4b74ea595a2cf47073031bc70b0570ff882439825e536af827802406eb8c77c9145c94ed75409584c30e30f0b8643878eb63b518d4eb4170aa807a4949d4deb83debca91532ce96dc66f0c84ad07764baa46854d2093a1226792e0d4fc44a083873323fe1c3f235da2e79a23a6dab8d969da188b6ca93a015571d0911e0c785bdca4474d591b33421ed1605bbb4e3b626a1b52087982d8096664032fc3055c8323ab0652dc137e5044c97467d5635eaaa9a7673121eb5bacfb077cc948fcdbb1ae641df7d9f98471e91dcf16b28921c72aa19e25078deca26f2a8bc3950e052fa55245aad2c3de8258d2e79aa328ad00eda084e44c7c96219eed0ca77ccbb2fc661ec5803c32a6440a39763a6718378b124950c8162c114987d27e089052058ce2aaec732bf983ad8ecb711e902a3cc6717103f672da1ad739a9337dada3a25571cb66d6898e2b6d40ac80c5db9b8c0687fb72d43c4cb8e0d9171a7636f8089bcf76da19ad46c59a5942fab27cdb72deb8e9e2fbd35b0ae20c0323b7514b4b67b8ad30de81dabb75b24d05807aed1446f5a1c4ef4ce7a4005862c2d9dcbef4524ac7abc3b92f4bf740fee7e3b860cebddbd92e3af32b76a5c204e273cb645f238f908a3ad40d2176ddc0be91384e5d2b57492172a700d895d310d4f5deeb6202721ef482c71c75eeeb8e8ccd30f5d8c149c9cce4c8f7b6af729d9e67bf085a5a483bb00f775b9a88df7c8ac0c2aad6d0e9dfebf6adca85ee8a05535c1ed881168c705fe42e75861697860987f63d33b36d717187c417d214b391296b128988b80efa87e7b23b1ea4a64446b18f0811a0baa4258bebb6388ace02dbfbd119e9f2e21cd0a8cd3f625a0e322d942068d9d943ab280e0120aef81a1f88e5da92679328756d8b02e1bced1fef88565c897808a3aa3e336bc57468e5bee23c15824c5ce2bf33c4a3cb93352946065a04ed4ab3da26f39a478d59e45ddd51fcb49e42d27d03f01828f379a078a323ff01f6ba7e190bc7a3bf6174f42c4b7714683e99ff35eb1cb96929ebbcf3dc31f31a59237d84b81fb7b3aea4ae77e5f4b867d1e92775d8d5b93bba0ff79718c4f426df42af440e84fdec98138ebaa37d74daa81bff6acec0b6c2c3575ce4f15f59d154047325948d4078c49dde56eb9ce86df9488729ed8b845f88f535f42a15df8481a2de85e5679e38bdb06f0e31fd4d6fcbc5c84870f23ac6dd2db6be38019e0e7526663475205f9b96a4f41703ece3ce1d1eb401547013efdf58f513403fc6856e04d63d5cc3ac282235f10c73afe5bfaf25fb221b2eccba79d9923e5b655649c2a8701c2234bd9a41fb9ed60a3d9413bd1959280ee2ce66304d18f1c42a00a423cc999a0a71b514c4e1f8288afba9d60b1f0457c9b5ea04d81e1b0071da2465690663493a7eaefe80c2aa7f8eca4488c04d5fa56073b441a185fe43b78da81537c019c32340183b66a6008192e57143e3d9ea44490fad4dd814c8c0cb74d96e62188f64d01bdc7c4f126b614e9a717ab3b4aa65c558fc56eb3457445d814ccc6776344a844f537f79e9d2faf762a28c9b9740303d6a50ecba9af9bf167250c30834b47c530fc0f7cda82e976eb8776c4d82f6f83ac3f2cb190e1a8b8e39024e041b654c14767b27220828b91cef35550de7fd4065542799cbf7171c5f0a456f09c5a28923a2187fc307280afe92293f6befe199e64c833a20412e31a65d41a67c301e142de6176de0d262202ec24147f80893552a6e270f35ac98e35ce662f3283b081bca9594c2ef6ef3afab80da4b20c8459dc9cb5151eba71078695333f1caf38b0a1b44351029083c4bba395ef74a1fc62620529bb6ed3db6d5d6d8e7bbd2e93e8e32020650f55407897696818d97597443860758aa547bff92c58c2ad4d17fc38345c90382de69fa5f505a5673a16d430a2d6fd678ea035cf9110aac0cb4cecdb4723dc1936ddfed370e27129d2342aa7b4c844c66f28c0a10c1ddcae11a2d6deeb03345cd7450290dc9a8c642d30685ae5aea639105f1766e0e5c1baea582da7d10e2b595488de9eaba5e18fa0d2ccd3b93903f654e8d71804fbb8afede1ef65bb08082a85acf62b862a69818bf54e225deaefc18f2a6fbab5960c1eaa9da7e7e6eac34f43fc9662590efa160cc04f144d660e8fa05ec6bc2bad29ea452a92ca5848c811e7fa2f547dac9501102cf649da3d0286a76974d9bcec93fac3c0510d985bfa60caec8d441b92d6d722193cdb02e7d707e224e917f451d4e6d6a616dcbaa937321f38713d64033217519f4c884a9b2743cb9dba937d12ebd9b44dbc174f4758e447e1e9e04187f7ca87ef185e0c01bb5ad285907640b0b3dffa5e919caf95eb229d8e02219c353b8d224747ecc5e17a953d155d6cd6e8db2471a933f0b2184e7940a151df43d0777c62e3f492e6353dfe4b2d92f9c4ff59f4da9aac1c3c5309f1e5b24926a0db2135b4d9450afa0e271587dca03abf49a80090b9299532f768ab28ae0b40412b0968f334c9c389c224943d4474a0f71283f807d5e27347607547c3910e4b99449e1f553ba88e38a4565cd3384c9de2b50cb09b7f35807eddd044d963b217f19519c303a966d146b2ee2c15ead66e2c9c8b8f82accefca122ded17e916e9414af2cfa7a17b0f0f2d3fc33ccad15fe105c9fed45aa970d8320a409e4b8703385c6ba30cf0dbf0fd969c7ac3d19066cded7533587261a88b63d0c6c05bee18bb7f7eeead27437a9b2ab0af379f95f2245f35c4b555874b3c2d8e83d0c71c6913222bad73d03f6df5c856e110537717cd3ba023c61038479ea523f0d1cdc580f216e708cea9fc456c7a67708ff43efc889c6839b254c7d6ec7389a781f36a15fe00387e7a90031395a06fa1e88623d674e87d2fae4ac749aa8559d16cbedbf4fc5b282a09120e2d170c6cb21bfd3414a7d338ab54b69ebdb817c1f7c5ca166630c64f1e3bca8644867b4bb12d2a9003a072f2fabd8f3d312287d45df06327d1cd6fc8dfb393d3b7c0738166164c5f4fc30fb63d966fd7212f9ae7aad410810523d6383b4da611d89ccbf57fbc8a7f62ff10045e5ffda30319de51b71844ea8516dce06aea0cd9fa01fad802209fa8965300d0ba8ec76d745182585989711a838950142710cca768ca2af9c02b57527c11675b8a4580cd08751a504d1f6a2125455646993e4285169512796f06468b37848a7b4b22eb32ac2335a9bd7df131b85200e90464ed04c267f3ecc0938620b7467157d92e090a64178adb7d24ee2c2943e234ea30b88ea60c470a800d7c0edc5e43655001d654939217b0d6fec057fa078169f20afb8a8cb85f10682bd1acd2cbd0ffcc5668c767169397d71a95f9e7e36b643af93bd3e0cfea5fcee26f90a2a3e8d5452aa05e91f465fbd51ca1a965a564227b33130fad10fe7983f349b3c52d3b84538a463d85bda8c6d3c61423ce45719afaa897278b45a9895ebfb88354345dc372fb2c3535b709c6247764eb8357a931f13eee38f30c12ed4ffc3bdf288b3608dc36b309e1589ad942b7f27d2aed75065b8e28d7ef4bd023a921335b45566438f0fc2b35b60199e7bb612cc685d49db0fe3c67c43a648a7b2174610c971612f80cc12917a7b95e3616842c268bdd654022f9211e0612af6170c1c4538ac2b17fb8a600928cfcd92f9de6422590231e26e27f24936b067a7d5d9f069b2f3a9b2f3b07d667712c289ccdf55adb4ac0fccc87521fd86294646d354a76a0b5d4bee082d24673e53b00747c50102153e47b61ae3de547b55f39b4ca1015e2be8339a5b3072981919295b2f7e7c97e171dd7e6446a90992db22315efdb9ea359b2fccf17b8d473fc8b0b6da1aa2d61996c7e46d0cee11179ee5df34fb6bd391dda95b847b355683833cd0d2dc06a095d61da8d576326fdc815272239b421ebcfc4cd04c744cf7f97c1df1571f8e4ebb01cb809563033a563e74eb5b23613ca8914523828e43df2d7d927d47ef5002fdff920e786686de285a55bb3cf058c4ab30e8ba04704de839e915477ba1d7de31e26f11f8788f655e21b640d974543ae91e979b3ada67c53330783791d801a20efbd84b30d9026d92191aaffd3325754a4b6ad3796bc2cd2eb6ad70cf0b86fa72ce76e8aa330f72cf4777ab36a5989495cb6f6047e4b0130d4b5466d3d691f27bdbb844d44849dfcf09d632788fbd33a83d9dcb4d8f2f3b7891c757c0f33b0253519a424bde82b2791f0dad368cb24b46e3e0443439bf0b8e59827548a2cb128311b13167d1af7c0a5e5651a9334c6060ae4ff011577e29f127a5496e4cdb2d8f882b295338bfdaf48ef365b165993ae528a05ac4adc47cb27323cf5c277f013fa42dde66ab0d1c0d4e01563796056d2aacaa375f527ecf2cad96cdd649c08f376b25c5840f2c626f8d4a38c4a321e567d24fbe44f62477a80730d5f1282fbf23ba37023a5d3906c0e3c3afcbea32bfafab693a656b74c1cf2dc838e35faaebc6bec0cb8f697c198cb52ba9011e08c9c18bd3112c490b9f48bbc3f070cb6173b3ea09b451ae0a2d2731c18c6bc11867ff5de534af28f137e3bb7a94f6516741207dee10c42d7a12dcd8b61216c7215fc30ec4afcf574dd73f19ac5f3270234a026f5e7ffa5f4b9adb0d4cce643dffad40e1df19db92903f5d5c7c97cee6a779d489d22977bb3d276987ed73434e6c242a68ca52868b17c1a28890986a94e583aed34fe43de45c7bc9de58360bef67e202d19ada70914dd0669c0249fdabe884f1ec32740bb641f36b5352b922bc02053161f2da90d0b0966674b7fb0eb35095d1c6f535548d814ef048250bd9e585f7687d4522ae3e24448761cb3eb8c12cda8653d7bc56ac323dab91c9e9058c639f5c52434ad701a12f4c8505d6b7767100cd322869a0b516761bb8117ea04a08df9b2ee2173e476f294814170b4d3ac9724423e9da9eeb222b4359d15df87df8f5a0e767594af7dd4443b46a8e2f1429db818271186917cf6c4be1640f6c8d026c17556217311738d4708cbba5a21e2b82220d6dd333d7777670fb6d8caeafd367cf9a39d3dea7926de08a1421771c370218922c66c34e7d85a1b1047a254e7f34b92b192d634804f8d400ea9a2f29761e2cf24c32c6d6b88b8b8e3c8c8e377249a84aa200f2657b469c34850e14f0fc1d094510b4671afa7675497c9a6a8302b4a9861b3db91dbc47bd2cd5876c2272faefa05d4b15398629dd2b90ad18732572fba2a1ba9add4ca714f507d2e13a4bae122b58d43d16657c8376962adb392f842804ca4c0c0296c6bcc88da8b05ea8b6e15c767b71969795410dfc6b3750fe35dc7aae500e514a566bd777e2e24c8668876cae3e6564cfaa6f50ff186a9b87e859259e63cdcc3ea0320042635f53fc43d1187716a4b2141c4254c678dc3a0c76fd07a8f768bc89513d2b98cd5bdbd143df78f0d0fb1743380a6799f38067645a27c8f54a3451f098babb53fef281d315e0f2c681b36f2ee4f6dce536f398fd4632e619a23d23f53725008ec9dbf2eac6a704b983315d8385b21756ee6ea144117289cfaeacfd8f2c548eafb4f23a9689eee5831ac4f923ec4255b53b18a5a330f6b1ee07cd7f35e6a3bb0dedf22b911bd6fee13e3c4a9fc7f83ac5d5e361f9769e834ebb55e1a62df6bf3a48757e52ae87e01e3dd9bcec64f544fa62c6ce6c21b2edee2379ef707cfe42d801e0e22b8a03f5061e370e6e14be8b9c8ca1f2fcdb974895dd666815b8e04a09dda4ba584532217432dd5a0de147fffb13af91ff575803e92952c430a0db01ee2f0d604654556900a46dab0be1a3d3ec68adfe0510688c22f04f875c579e4a4d96c703a0dce76d0b461f1f2e7ff3858a271309861da47dde9b7fa16c145d99017227388780662f5977bb040a4dab39f7804de9d486e40ed0b7e0d75209f6cb6d069e3348bea55aab1c754b7220b49fa659b8f87b5176e74bf5a6abe29b177eb012ec574257c687287e340c959c2048c0832e32d91d71af2e386dadb22d2d39d39a173bb6dbace3f52326cb6a45ecf8a873acc49a7b9371bccdc1901e863a748a4400f12f74b674cb12dba57983d5e1cd9c14c8ebebf9b8297158227827c1b06d7ff2b6c388bb4d6b1e65e122b7078b263e2d3ec9ec1b50153ceb61aa44dc6b13a3752c1f8d9bb61e566ab6d6718fb462d1f9476426c4bb12024d69f53400e18b8fa48b12e0b20361c96dbaaaa06886c557476bf1da2a4fb0529ef3bd541b417cfa5904aae22b9ccc3df1025b7dfd2f1dd5c3cb3d178fad84c4873c4de6215f0b0fe78b8599dd175edbd55ae018d6721cc572b84ccaa63ffa131f7a2f023e89270886a2cdde3155e9aea9f41b5990d49f1fb98597443bb77e2316f3f0a6c7cb33bfd7ad7e5f51550f0663018d7fe4c4c257b39271028378f52b53f2d67f9d7d1a05622b29a38e49688a68c5baa68109413a0bd1799c41594968a59936821c30c4e162fece63c35bbf4a26089c2a645b91969ad33ef8d59f8c3f7e26005de21876a2246353c57dd16f31443353bc540c8e623a40436c7b5ce3b9d9b40bffe586ae04960419557ba2433dbdbe61416ab151d62072b2ee510161eff0d33f5fc1126c2e73168ae6e127bbfe82f54f34681e8855fbd0bdebf7b7abaa34b568b033ec751d5feae6beaad14002d0267bbdad864d61735d1d6587991a3eb2f66f69ffef456b523842a24e0920980e8bb90237239795f05d3777ee5a2368c84e435bd61a2a7c799e411a01b25313799818484b81bf1340bd9ada4298f1a22eeab81c70fd9e05f88d3d1d2de8e57244cd59551299330da3ec13e181698d725c134600f656d3d6614ae138cb6a64e54d131c88e5827c5df7a2f80882be5b374b50e6a74718dd27f84e3afd14957f7ad90df796e47d644632311679f72480b6b4c2fd13a636297ff0995302d59e24f66e6b5a1e002fd55cf7be370ead262cd4c00ecf1727d2d1b96e5696587e48e54b23e7cc8af15db70668b3fe4ac84d665e050d93603b4ae6c400affd41e4abd4030e47c5b0371ea9db297d1cb2252b640a2954c549b6d2f8ff2f1de18cbe5aaceeda4f3ccd76a77d14fd7fceac4c572588990640c83b846b201b16bb5340f232096c029be589391e8ff2fc075cfadeb8bc04cdff391b269c7e36667c36155bb3ab0308793631153fd06a78db3f40d76df0f84573a94b0d97971e18cae8f18a470e6b9d8947316b848390fbce7390c1f4546f177129f67039e9fb3e2ea218064dd002e1f3f82f2ca0bf82696e09fd2ae49b3fe2a4c0e081690ab1f3bd80a840bfa0b3e43d539a67edd5642281d53325d40f43ee6e6f2af313a109f575329659a7dd59cb54a985e040a2ed3cccf2a0cc059772ab90e0e311b4af5a5a974895c402eeeb1be57075701651595adf7ceb5470509b401cd6a1db1f8572592816ab612394b9ad041001695eb503bc3b832300a52e50e81f9cc64af6ce056a2b0d3327e0a4157b4d54518c7f76909334c4b93cda0052c9ca858d9a6a2f62bba143ccccfbc7b6ccb04add7c9c0f279ed402f2181d19c10cd37f2cf96d3ea4c95ae2eb4d7fae7da4d80047e30256fe378031c951254997cbc022bf534f760610ba438f788c8e28f8bcc43511be56609862d521bb1408b5ca1d4ffa1b683a00313f6a71d1d6586785bd4d7f95353f875801c792b97f73c8da8a234259b892ae9a3608071a0b4f09bcf16fe557c3bb0298ccd879d14cf7f9bf49dac9eeef7d6068cc26ef0092238d9e30e9be4d2af92a1435d2c5f5b5bac2e69ee3097c09ea2257b9f9599b6f9a8fe284621888ff23cef79835e24bd7ceae6b6463fe58b6ab92ec7223a967dbe7b320bfad6ad5f77562f193ad2fe22d49531de48aa20018223df1ecef555963b569bb30f3f0bdfd29fb24d70c226014ab6e2d349c3c824aed8868cb371ba598bb00268ec23f52d48e5579d76fe021af285cdf72123bb982333836ab42b52b5ef767a40cd53f0d5564bb10e1302c16b9c422a734023a9e5a2fa86d29814503aaa4af435d6b6fbfb66a7f65feca208dc0f95f61a0ff43d79932e8ae2e41b9607d9f349f919f4445916e8a111b3a7c511839620cc44537546af8b67c6ac3b9e4dee7706ec003bfd60169e5027fd181788936de4812a1fc0aab7dfc07770f236a88e6d349952ed3e99af887ecd3d6d456f27927b9a292263ceb1caa94aabe36fb2bac3dbb9268aefeeefb5287074e1a6879b21f4649a454490f6bf9d07d181da44e0cdc726015ad64ac0359e5ef5998e8d385fbf57f0353b772c35a55c21506452f5442d8b2d27fb794aecdda74519979910998ef1f5b897ba6b504ec446861c6e3c18348f0c061dd74f1a32d9deced18a6b152bb65cff24c93ae69f0662d60fca937f364fdfb6cabc0e4c0a1fbf6eed04d1291d20249fc83ab58e275363a97cefaec222a3e0b09c98996bfe86be50626ba5738ea1d6d63501f0e0bce2209d054b388197ab54cbf6cd67b352144b2fdcb200d662d05557deba524762c850030983e6026405fbd237e30adf93a69cb7ffbf296af57d09d44b0385561003fd29ede2d54382c59da3460c7032707443bc134975f0c2a8bf004ba09074d7645d69ea1ef278c3646d1de3994186062abaa4dacc4dc5851e97399bdd8cd7f0f806763d30fc0278834b7ee09a775b0f0693475962f5ee88c3af6b624aa7cc36e1d8a6c976d30110e76e98357e510752bc91029d9ac11465d188c69270e4219a456c281a857c08675e6e8ba0b5119b23279c7297b9f0cee5cb2872a9dbd327bd0f4434507e884a9afd3ab6a978416cb9434384586f7c49ee2b9602743bdbaed3d0470f167a925d68d837d03a024c7f454d7ccac0e3b1fa46346fdfcf817ebc71f3137a8095a4397249babb3dff5aa167790517d41121d64ed072530dcecd6cf14394ea6274a961221ddef1c6899df27d32a790e3ddc7677f997f010841201922940b81a33c23c1f1e8e3df41812ce12bced7e778e0c7a06a3f1d8a4146f33a6faf6a2fa2d21c14860d94ad72d7ccec4759f641432493b4607025c79e3fc677d29e119e6b6b41ac0638a2fec29151222971824fc2429208fd7894bb5403cf4dbf8172968f473e79fd58e81e0faf35cc848e8003136f565bca7dff3b4845b482c4029b3c8cefaf516e5491bf86a89682fff593a44782049f05c5b93428f01cf304aba5ff444cecf8bf3e9541a123535c4b2ae3222136fcc846778663a963c48a3ada71a726b51b15315b9d016891f9ef670177ebe3e81fce77c2cd05a7d7ce1f43298dcf89d6a3d992552eb7ac79c865d094208548beda4683fbe37c3369f80a972df5ad5357920a54c941eae91e757ab29d17ac58ffe90ab980b7271bd7b5a7520a994e5be4d51e5057d94f6f7ccd2f51a492d3b3085ac0417dd392574755b04ac93081dbbb5502e46aeeb8d2c16065b98e8bae7e4ea8ee73859d4a5fa3fea51fe6fadd8c2c0c24206d6635d3f55718ad9003a477d8a5e5a80c7608152eb5c3d32139fa072c9c15f001600439ba5bcf3cc65dc6d92c6f7163f4cf150cb94ae76704a268e8c9c98e8c0ab4c3dc5ecd3230a588970e573ea952c8ed0ebe4b302409a7d4aac142c1cf8b37d5454731a26681f4f009fd1079210da9566c221ac4a7469d1914ac0b9b4b9791412fb00e8b3407cdb7c20d2be980b94ee4effc0eb1b2110abe89d127db2941786f2284a83607d79abb4328fb03639ec380544065d5fb9e0ffe1ba7c99589a4f1e90bb981a8f51f7d13e17b1cea542f3989ee6b46de26332435749215ea4d24561de990a586d4727d02dbf4a1f0ea6e7b3e54f1b8c6b6603c50c5a72093520d4bb793709e6b8302abaf778b10cbc3f460e672518712692a2b4446040ae242a04b91d237d6399e8b659179a5759f3de72aa33b261f56a62f2742f2fbd3f6961252526d9520145fb0b018d0e5aaa62f19760bb732f3a5a9b5ecc967c6c89a98d772c4d365dc63901fce64a0b3758a42aa86f0d6b832dc699dd4b5f8d058bfd504ef50ee930359b3b3c9440791ea24cc1bab8ed04668b81ff304707c327d69480d67af2ffc4e80cff44f4201b01e9e45da61ca058be14f0917431458b88e8afabc215b2683c7269323b5ada8be757b926f48f8f43b7b57319c11da8a4c7e9233b5163ac57a04872698e2a44534c0cd6e4acc96d8180968fb27d0cd80e146513ae74c99faa278cac1c230a961f7b1e03c1d13963f8f1f72f3d4b359a2759900ba7ab70e093e950a37dfe2be2929f11b346b8b21e038c0e8dbdaf2c632f92b5b8d8df209126a3a3cd966c32747d2e87998fc0e7f2475d4ccf7eedcae14ee4c15b4f395b71c796b6757738b3b5874551e59fdeef17158ea8ea1e0de602ee7ec3976e59f09e93624ef61962e442c3c5e877353e9e81b818cfcafb1ce3e50f532faf83686b5c8cfee76caffe385d70888258e042b1a271753e4f383e3929205a10f24a89d7ae19872001d011ac33277e78f202043ad0a3df650476c2f51c5d64b96da937dd598a7a7c073c542dd7bc4397ff6d42814a722187512d90e37d587716b3437d7e3c8354093e9a61fce1a494a7f9d722e7f1406c4877a3655a5ffa2f9111ad0b745dfe679a8f0940d806a145bc6996ccdc3e2f0c068862e3a63d689a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
