<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"67e7ddfe37d53c38c41703de46c26a77344200ad4dcc39c5fd93b1e4a09ddb2497e588103a91ff18f84a034785491e4d54656254fcfdea38ede673b5ae9c0e8981dba3ffd173f8a3ac3f0d28b1b4e0f1733303c0435faa851fe21a5eeb2ebb88d3820ca69b124da480431637e32ab56313c9ad083824d452e866f801421f60152d767d76c038796365cbb615484ca0a975244104241ecbe5ce21544d43db5d2226890ab1025b84690129255d7c42611194586ae1e79a8fbdef8bb1b270887430b4d83a7fb2ab53446eb1d473578b58a062afcc99719adb5eb666ed7159bc7f0a7bb6a6d6484cac2bebb31700a8c2d60d8dbc071f396c39d49e75648cb9542ba8943b62dbe548a87b4bae8db684d472081476d2043a50c639d3e3a37f1033122785eb989a1a5d78cdaf76ba048691103126b5747a6c883b1f723206fb536385dc3adbf9806fe196b7e3b595f62be89d0b6440d05c2f56062e31d191069ea2a97ba7960f7b8fa1d9bfe18766959e3ab4557f63aed428cfff70e02e93d41e290e34d5d8d99f7e53e2d39dad5c953b7462b4e0723438c0b623aae2a41f8547dccd225f3115b9be8ccc97d2bfec12d7077000a835ed7ef22a5e4ae2474279e2ad6bacd315277455e8d3f59511a37d23a8612cfc7c78b00175a3f0223e24ee1e1df4904c54262d41174f139142f61fb53855d6052c421cce8206cf326b81870c88f838b82267bb02bdc88b0f58c57562bdbbbb7c4f9d2475e67e27f22193be38818b85b73a11d9b4d67cc862db760c0a9d8ac16cdf3b6d70670b4e156f49d85cd592bb83e75780fd93b2a936a7fce8cf8d95f773e8837deff21e5e37051f97a06416f145eff0f62c05d7fb3dd3f66ef3611d7e192d87ed6291fb5a0fbb880c536fe3308c114647bca43b652edadee846bbc54371a30ed4d41f9bc92cf1e8f9fb82f0e4d958659d1d0f31a8833130e56f7deaa582414b64f702707992bf3d94293e7d4dc77f0b3d2a1c47d66c5ca2b4daea84d8879033b87ff74b86e434e4232a3ad2e51cc4132df5bd91355ea803794e80161154210cacc42f94fd756a769e38ede1cd9451e5511f20d2cb87ca9c90e96ba0a6db6a38d1fbaddb9cc3d8cc12532fde6b8c4f2aba14dac0972cbaa836abb127d0592d8316d2bfb90a65cb449dc2017da9d16febc9af81b2cdd887601556c7074c1a6cc5ba64d128f090e1bf850be3cde50f675018902a400d68e1251a57cd2ef60c33ee0e1673fa943b0f3bf1a07d333675d8b4867bdaf403e8abbf26296fb59745ddb4c6ff1246b687fd6798ad12aa50ad06cbd3a74b876f3dfbef68ccff682c8fbb0a3214a633962b9858bc49571a9b560b44f37c9d238f3cf9df0acfc354cd08428a476bb1f452eb06375bc1bbcd903df41e6bacae224904c025cea199ffdff73802af5ee9ce5197368aaddc0ca72a6ae278e95376270ed5afa6a2dc4b42951e79e5c4d63154c50adb6e1a84ca49e76e0eeba6d8d478e912b1b79920de7d0af4be9958516ee1bb299f84592998ea7da045ac068d0f8d7eb15be03d233c3333dbafcb932ca5e57169c49972a8fac14e35240235d5dfb1adad6bfc7466a9e6c05f729cf01b3b92869856140766ed6426512229396ccad625cca56df27dbeb2a22e884ab6845bb5dbd0b4e8540d61ba6b0be454dac3cadcacc1c7c72056118a282a9843d47237cc1bb89cef5de33db5a2c3228075a7c0f5dff03b1a952ab379bf7c92fd659812c1eecb7ed02ac10f7da4ed3f4567175d1d36c540daac57315220d955fa5ba2a94d797e1499331b6f35ff02d155ee0334bfd4a914b66babd56bfbeccceccab333f3007f8d5ebf81e5b5038b7871643b9491f294f295b3214730101a7859e0897715eeb4da830dbae4c5029ca89dd49574d58b91e985633e5ebaaa4066125e494d10bab1d25949d6cf4b9e499e68f154188829279aab80d63e56878c47260f18b94b561d76485eaef4be6640771a0cd634a6c146f46bf5231356e5605003ae0280ffa9ee4b4ac3c1f52de496ec84b9569c6c4960452bb42170ecf30d61742fd3bcb2e104dc14a4bf3e58e9ff48dad148a74ab34d599f6c17908b8c95911083bdd5ed84fcb00bc30fb6abfd2523cacff292d3c61b6e3f340541b10b0cbca022049fdcf743708ba96c004bcf1d098c130740ff9b801c687d34819601fbb7ddb4f3c7a3267845ae9b2e099e079a774007b40f56edd0d5affc96de90f92087f7745d665a587cda3b1c97e149a69981d944f43289ad393b52d5ecc20cf169906d4a1d64975d735e2607e75d080921a1d46f3895eae807a97bd683607390504643171b391e1c271c8dd950578c6954648716d29c82348e906abbe09627eff48365c9e4c70fe942fbf6d94339abff62e4dd2bc914837ce986416d50ed1a53ccdb3220b1d7839481797e8931171e21f63edb62b5124751be0ccd740d2ba96292bf824ed698f521d3ea7adba390eac426bf10343c7cb38b898a66302883ce9eee80a1b0a56b2ea736e24c398d36dd97efb1c368819fa49efc9819043c60b1afc6c02c00f1de347e9e8d0ad96bfc91b0e24d2b59b40b2fccfc7c343a56d5e3f7b9d5a79949f5dc232a871bdbae7c47d55284cb79a8fae8a38f769ad6bef5a4d69e1da3a43ef4579b46c731b6fe1af54384a859cfed7307c0b50f989623408a4afa2c4e0300de0e4700c42130c8c75edb8cab76d8fb7c071160279cdaae0dec288d68493866ab8d2bf33eb8f69a04758432ee08ef7e080a76484b8a142e2dab607ff49719d26aa20460ed42d8edc5a9898ec53ab83e63723dc2de7e3a884f4617d6e57cca1fa82e084f0b501059566ba2ae2809a476a88a9353ba79162a7ab5bbbc29903cec681b5b53efb7d41acc2034eff3bfcf330f951a7183174fe4fbb4864e7e066b4deaaa3edd8b3df0705fbbb682b6744d396affd9a83a4ba0a156472199c3993ab4a2ec2927731401f838a1316a6a9881c8c5374f497eed475ea85f342895e0d923b0b12c155b7cb760f05ce995771e6da1084aa820b50c700061e4b073739574eaadf63f86cb065063d28298a9d3e6abc23580e40a25e8c943c9abf0272da133a381e2f0a38115b5129b1903d64b82e5c335fb94d3ddd496aace2fef14a7219485b4823f89aa6ffc1628cccfa32fa95a4f4226c26859ef451b90d51e78593cda4ca4790fa69cc23eafb2afe4e9f500d1916ed3cec4ed3322fbb7648d51feff86edec097f43bb62016b1ffd50e52f49748a4b85690a864d5757766b0a240fc1e0e50805bf932bc21697666984693c313fc81d963ce01a7a6632c9ba2f11335959e6f8923529921db494ab61e31074583288d19a3e08a598071c90af675d3fe3d139e2e10b0b34c32d6d8f41202c7b495d7c53eae7e39820d55df7f6ac5f441a5b8b52a2d2fa8e8a6b5471da2727420257ac7a687563bcca66fe1818921a4d510769fc3a9d7c0f6e0e495b817d42e84fdc3816d3f8fbe57db3a46e062e07602e339953e64edd37f308e8b67d7fcdcd22f213808d27b3ae30b7258e1d6f121bd60d74422c74d480e971642b57c6ee7b6834919346c74215341b027314b7114ed002d698ac9ebde1051018015ed2fe1266726544445662ff5cb373e247187e1963bb21c5088334370001213e78a296daf9259145c294124640a14f185206b63eb6c71abc0f2fe5e316a66466f3e4e4e034db4f9da015065bda7e10c5b72fcd74233ed65347716e6cada2ed3743f1c5217cb40a92524f2947cd6855f437fa4e6a7955bc7261c9d0e0a8a51e2a39430aeb6a3b7983b959eae80a5a7a8cd9242bbc11c44e35d8f0be69a99ec822820d6c5751748ef41a9b8ced01153280bd26581a8c1dd1a6328caa01c4f55fa296aa3326db1e6a9d2d7881f713a5ccf678c73aec8a3abe4ed35d1cfa74b32f1aab108ee074b2e40dbba2fc4630c0f0754ea5c3e803d14933584e41700112e8e1026df184508845333ba25a12075fd9b47420195d68ff341d957bcba491ac41e5554d07b015f3df66d877e1d3c477a27796f27b66f4e7249dddea5aec6c2a38c5735ad97e7bb0f03b3a201f20c5c2cd9d04c1a4bb2c812e2aa9afd1cca0c778e4706aec27b65fbc6f0c8e4e8f708bbbd79fee9058cdb1b9ff6c6568f70f9acf3bcf84c082e5d7cb12e305184c7abfe68ef794cde88df8b88a3d9b1121cc2b267047114ff1716b4426a806fc0bc42064507b29bf99860f14d47f400b063941694de1c088d1b771c2adde79d0909b57fc78b70160f8e0d12d33355cfd0443ffc83eee32e1fb35bb3573b23c7c03a8815c9eeceea8204a8e69a11dc5ead5648c6045257727d3c8f0f1e6cea0c72be55d5da554fa6ff2df861569f7ed01443a7e91053a0404ce28213478781c7ded313ab9bccb757b14fcb5faf5c28bb242ce9c151d4251d3e8c6e79d35530abb70efe5d17527b24ddb7a3587d178e93b816fb034bb74df5c73d3f9fc0e11b0c58201f53785f30deb819a3716690a225e9d7c1fd52ae5e8be5c1c96ac8ab56cf5329755e97446541620952f3c53b6844bf8b01e7ffb8708ebccf6e1bf75157f544bd99933d858c6db61b7e48c21fb7d59c9e120725b37e1dc417195247ece2a203d9d151f6cac42f72e3a906d66409d331e8daac6c0209948ee17d179bd3d3af5fbe5dd550f434cbf42a6abf458e480e572a9177a9ab693a42f6246b58df28782c66ea10c6cec2bc05eba8c234049ec0c238b7c99ed2319bce6220032d5b261f3f1f5a1eaa9ab673734caf2355c17269694a010f9fb89c44e3bf2e7474f741cd1d418f131da204b5ae2fda9445cb9b8d5cc3a77572f60ae48ab6e62ff35e5794c80f13cc9e237b18c5d5c705ec1437a0b3f359cc89febdf8b15dc9fd2b189fed6c24b612c838f31ece28156617081a003d531480bc0ed0adacf06323e12539becba962a732f9000c4cad1b5c43f67d3f16976e35199da90a8ee4b205b3f77ba2e299112689ec27de3be26199886fd547f1737c65cf37d9b8905c0ad8336b34e4d6d9f0aab1c3bb5a2dcdf730344b1163ec2dde41e3a6e7685fb2bf918ba81dbabd65fbe66313afe3a2d7069c45b6e9025c060fb6435ca882f4c1cad8d9a13dac66f62094f4dd3a3ea1a319f17406ff8e76b6966a2c66ed7f21651e68514584aebb88cf6ce8631706f35b9450cd396997a687c0485d4b267e852c81a394a046a587116a8c8e4f04d5cd6e288bed0de3869b6f8d31788df03c54d4a5dd45f8d08d72f046e10fc892739eabf7fa8b6d07313b7d0b97ab844b26b9103aa75ba1a8c5c263254a1cb1aa273c9a16149b17b1b0b63092970ca499fb6d3bf44533d37d0ae5af64d4cfba27c012bfea1354b449a9921b9e233f9d3cdf6f9a96a2ddc6982c23b52749c54ade57ac59b76c8894e493ddbd1a50ae49fa5e4cbf23ca9e618d71defe7a271430a73501e888a194d4f743481c72caa286fef73f09bf1b41510795642ed3eef89d4dcc15672357b84f430be20ac482e11445654200fbde28d89f76e620110ab0445faadb1e8922ccf4b502b6cb15f908d3877bfb88a09164a95c6adb23ada98d1ec11905d26a5c3851ed3aeeb83c395f3d40e77873b1ba8f07e2d3c3d9563f23503586a85f919961b16a098a3e3e1e1e1efdcde20c2f61550ce1bd906e9e2881480e53396f34b1372f55c7b441c83d438aa8ea8f4ce2ba783162a0c32fee5fafcd622c3ae6139791440d16a30391b16c783e54673966ce1ee73bf43840702fd680af1870b6607ac8c0fc3bdd64c81c14778350787de101df28c7a634fef5db3ec126e60003e6cc912de1aeee0be1ebe6ef8cb71ff838a71688d35b310ce53946f9383060d1296080b7edefebedf2d109e4130b27fffa44e64c2006ad33135e9e41d7cc5a41ae9e2f98935d778ed71273670c7f9e8e1ce5f97eede59e53c46108d3bb8af375de6a4e65932ed94f5bde58d698882c3d9fd9b02911d7e0f6996dfb3449524931f86e7cdd19b803056e3e0a8c6839eb8a4b6f3129b5c493c2e2a63303f41b97eac83a7fc6a682eb05e22ea83ea7f1f8f9611c49597667c6252b67f730a1641048db1350b6176f4e66abe5812b00ebeb955b37aaa1adcd0e3e22fd9e7c8a37696338d4af5c8a995fead6dbaf406cdb9d5218c29d817a889bd0131f5fecef497683dbd300fbfe00b3c2501aa922b17e00ff9a84c00bfbe19e8b330d22c1894818d4582583a7bbb05aea47d51721de7c17129bac4dd96ec223e7e4ee16c4b0471d8b19044f8952d180c720fc7f4deb32d7f855939a0b1e863e70b4516462e18c0f70e533a6f1504382682304a717c797eb71818403d93c9e592a6f4d2619668f8592c5ab9dcf619d79cc5a8b24e54764a437b7d742fa11c3fb590dab0c1505217e2b01a1faf5e57ac508323cb54e1addf9458ab30e4794facba34d0ea35b6f08bbcd044dded65fd29066ed4c98056ddb31adec335f7f3d1b595242ea2f619369a5f5693277e04f5109c59eb0e22e3b1182a0c69513cda6aed3e414374cd6ec6890fbe375ee984cd4f99d67ea0f53552f8fb3e7a24355b9bed8d2a4f48ee9d1d0f44e59405e0277cd345f57f19fd8ebb4a20043ef1205cf32b8cb3e83a25c8b9ee6a7655a5a161a4ee66dddad15ce396ab377a160b08705b33b10d1163ba29338bc3e0a3cd530b6aff61757641c8439718521aa3c9fb6a2154206d3189a154c1e60c9f269b232f51d85020e0efffc15f0141fb3059d1f1f7aa376bfe6378f4a3176e024491f58db470c625103b35ace5686587fa8c0da367891df106d9b848f3186ce4acb4233c17055e09145525988665d70ecf9be9c0855b16a218aaca621f0edaf4d9d68125c4905cb7bb7106c69f6e02c1d17b03f86256200316e0b9ccb8ff2191f0ae95e47f9299de3398883746caaf87890c7d6eca30aedcca2f2546fb616fbdc4fead31f0e23a976ca9a5976c93609654301b59039831706bb02a0be234dddad759ae32d795edc2bf03bafe66039403aac14190b082e89248fcdfc43925ab167d4dd7f9d075b4704cc0904cf1102997909020cc1ec434fea0b7a56178e99a14b9b9a0ec0062cb896926ed9781f98c3e4844391dfedf429f7c93dd323f8b145fd7c80d2d0f0a2ed7bf57d7414a08c45781270adb3882f32ec7757628936b24b982aea182d0566c71620d232668dc933e1c67a3ecb75e38cc8e1385ffd605fbb79b3b4aecb1cac6ca6010767cc6307024b9d0b3a2843251a0d3b13ab9f65355f7b02f3588e96a6207505924626d03b144cfe2a145bdc5ffdeaa8cc34f76fc6351c3ba97d1fdc13ed3f772257132502919c4f961a644880e14a2205f683a79a73eb4b7e87a43d1546267fec98cd462cc3759d8754aedc4a669883fa75c73cd87b998a2e30f016ffaf30758d32307d8e1f431b3157b2d0552027c81d3ee708760ce23ae3edeaa952c15e863b4c4f30c7cbae20e0fbbe6673aaf0171bd17492d099fb2f4baa8f1a53ed29bde0dd9ecbd8bcdfa315636707ff77cfd7b104071cbbc22389585dbdd74021402248011dae5fbc64ff1a5ed1d50ab0e501286aad0544767c113e5b6a0e3da40383efdbc3983bef3ceb7438192d6c4d40df8d14312f09723a20e9abaa7f76b9ef66acb85d1fafc00853f865e2253c9991cfd5551778a39da0482f249ef8ec15c7d3a47f7bb7334d9837e13afc3847746997f25bf3f694b7833fd523f41257adb5ed13b0408b627625425b1813d4aa8073e0c512717b84186f2d0b8ad47898839faf7230812a68e14b6bdf1df35b4dc1fc373ac9a940a08ec69926253e9c08f4b3bc3c25f071d1c8601e55d7adeffe6a948a0c6386389bf2dce5ccd1770b346211433031f6c46dd0c6f419efc85124d328a511b849859efc38013737e454edf8894682dd38f068b556cb594d6a44432c9dec85a4d376155b3122f6056e384aafebf5c46bacb7d946386a5f5c062b1b692667a2ff99d7ed1455fa2aff7984ff9190689470733ce8175c80cd8443415f93b5347d00145d990394caebbb08c7e7dd409ab1c4416a006c79cc8f632007e94ea5fc659c6323aec0f885e5ccdc22fe47d53a1388e65ada48d42974aded07521ccb27d41aa7888f27434a8663deb4215255a7902f7ca0b08cfc520c2d53d48d0f620c1c44396b86faeb968f40b9e6b9793fb01123b77afa27a17c22a0bbfbd2a752d9a2b54d52864e8b21cfb835f33d1948fa3e52911e202d7566c4ef276096611043380441b4ddc0a51092bc0cf282dfe4efc64c2313c0daeb0f761f8793476e6e85d745fba9bb432a75490164a58ee457ef3e99ba8fdee8da03ce099e063111c4ad7cda19371b0ab6abb5c6d0612f5827f8a4785a42e969c4cb4235455e396ae60497745d1ad526063a7af5d100fc9c0517790d5504821cd7863d460992649a9ced5d8432118e0374bf554740ebcc42153e8584599333301c6122024779ef2410748ef064e57a4fc26dd8a3c131846840ccb5afaf3184f29a19f269015b3990e6c625455eccf8af2762f4b18902f617ff97559f2bbd414081a45ad482cd33fe7e09904d735f07b6269c53d5cc678aeae68f3c46938bf761301edbe7011c0fa2fdb38a289d2c0f04f5c6f595451e3c06b9dbcbf16e4121d3badf52245a85cd4010115e1415ea7ef711b80b3da4ddf2ddd969481dca91a730fc9494b11e417274ed0e5ca112fb22581ff4840a817528795d6f80fb909447a2467a967ef5f8d5209e7d5a9f58eddb17577bf03573c560a2b00176dbdc26249860b6cb136dc69fe949d7fc5f86a719e5cfb73105f213af40a485306ecf7ba78095c39bd979836fd4a3742abe830c519bc2ea40643930da7f63fccaaba3e4b4c9d42171a30ba8439e1526f6c939f9d41caca5fc484ede8846ad30105c09f2682b66398f1bfccff2fa6eb41989a3f868b17abd818e9373fed1e585bf42597dbf8129c9ccd8b6c48ddcc7774ab8b8fe67d0ba3f03d6d70713cc1a94a1244295066dbf4b343e3e3a1a920c3a3f9e2a5d26d00837b663433cfa5aeccc691360a775cb613ca3dedf240851bb3a79a864974ab4424440a79cc32188546288a020cfe68d08a87eabde224d17a95f2418ea94022152ccfc5e061221709e6cdba47c1b8977d6f72ac0217cff4f9024615a8587104c04e42ce6837572e6fc80cfdf1d35b430b5e159989d2e198e747725186d734d7f0060749b0fac12446c2353b70a8feb27f7dbd0a37c809a957f672a27e0c8a64a657a623e10385fadf7f7558d9f8f480e030aa7f326bd56ef72f01f0f73791088676652949dfaa39d55ae503a4dafaaaf5141163b1e92c64d33448bc595724cd49d6849d86c5b1af10c67ea46901f6188fb0844ce5329b0faa31028bbd389268749acd45a2c0b8c5fcd9b5a86a267fe501a72c311a481b2f799c39f322fe1dafd3c8e60451778a41e11b3d4f2a62ae40d420579ca97b3f7f4883270b9b4f856717eb4b7bb0bdff58d37fbda0a476af5459695e48448485e8d6c16656cf3b7c9c6280d35fb079eb6b263614bf851a3549908b05349dec0dc139d2afe85a78941b217ef10e57b703f15270330ba993879404dc4c850eb9004690147a91871dc04148d00be9f5a49927b55703676ec083a09bc46e7861536f904e6c7558195ba1590f0ea902cab906146fbbc69968812d5489199c53edbd32ac451d1a0b59c2f2305f2a30719c0c7297692ff107dc5d3fc5030f1e3fc2adecd7c450f0621ea2dc079cf499bb408b13bc432a55f3bd28c41b699596f64c1dd1e64d34c95eb24d4e137d0a3fb3b4bff109cf53d142894ea27de410e23d33637882b3c13754d21ac54fff6d2e3f9ee5655d0f5b316f5a6d97130be4ef3048626b172d6c1da88ad6236a12b3e7cc83e6e191ae9ece67395601edf5a6842227becd4f2812cce34737f100e401fc86bd7e4ae14c4afa78e21cd78101d762cd15235127b18bae92ba5fa83ba403c8120e0ef4962d9cf0361e3e51505b372001c6e9f95a98f6925c3a33ff9d8c6ebd36d1fd6ea23c0e5eec8357dad99c5b6db08cdd7dd253f531354ea1587553992a5bb2dbc86b2a0458426369496d88d962a018e07faee119e051b0761bef60771fddd60879d3b6b12ebbf6478f9d2b8a89ac03d0c69860158a5268cac58010f769be69bd6ede7687bcffe0f9a671fb61c250ea9fcfe04e5587c0ffd7b91f8562b7504d226cefc8921dee55b40dfe92ffcf1bfc7ee459eb297359f13833b9a8ee6b3e08cb329418bf25a0297018f33371f2822febec097271d73d716992c51d67ceab95ab7c913d1ba8d9de7e53e188099cfae9db64a7036f274260454721e7b585b19321295a909134a2af584970d217b8f8383ce6d7f205c744ee1d8d171a868f506057b29438b9ca33ce27d821581c78f53d1149b261afe7de6d802c35cf6b55d1281e5aef6c1288c4b70056d44baff275b999aaff0e79787eb5346f9faf4055cdf345bcbadbaed6d26314071edee3c0fdd4de4fe0b6480697d3fce643ba1eb1094c6e8de11a1a89340130fd2038ddf0167b8b7cc010c4b1c6efd4d1dced74cb1cbea4a6565e40381295a96d72908edfd248ad3c6dd75e7675ac917c185ccca276d0799b02d7e312c288bbb38882ee0cf6b56cc47fbd17f8bd2547216acbb8a52e1ffeec1ee2c490455db7f29959ad5c976400f3e838f362c23f95dbf2a80f446932c6d5a8bf98671fc498083f49808e16c8077aca972cd320a6eec33beca4aa9f743330f15a49f03285634e992b9687dd7302b9cc46769f44786f8a0e6b7c2bf209777739f6e4580871191a2876ec2c4683a36ffea9415188a4e4c76dbbd76f8700a22b59bdeb3cf54b7a2bd1895f9302edaa3bd37250f2ede0870f47705f9cbfe12f0c426d066a3ab451028898427b151dad801c532229d6d69d7c9d423c504600b585a001f64d2478030071ec63a353463fa52fdcd9092fd292fb388b3100959250d1f8deb157b0cb134d6fd3e7ce3ccd58e68b817a2d6a170a6502cb1166aa836d466c1ef93f34a13551ef6d0ddd102f36992b334414da7128df7a9bb6a27a2cfdc1d1c83dd441228995bdebe4b182c9c9ecbbbb5da2af03d4d5bbb9815f8f6a857f861e133f32e8adc6b31acd311604a52efdbadbdc95f9d83d237e61741d27e663710a906d872b9b069bd3025f5313e346e3da569a389ba4491c655bdf7e87680bbb2684903a1d9254c70a5c282cccf3219bd6fe9b8d70955ac476aa4f0631eb6d17794b00d797393639c54871e784442ec0ead38051fc6820e741bcc4116ac8243d208074b681c4a88b3c82353f1465c122683e06caf6101d7c4d06bbf466284d8d3ffbc0cdfb91a7ac32fcfafa8f7435afce503d8e9bb25db98dda28d029f97287634c2fa0da2342855ee176e8511c6f8d2673024e8fa0fa6886e9ea9cc049604a727232633ceb193ca28d37652c3b0cc2fc4f6fa773717def99d7da365a6130a7a7582e8d5cc5c0b300838d2f8f7e1974c31de1d68f9a3cb97841b301eba3f8a462d04d7853c2209fc25c7e1719b83320796a49c64ffeedb65e82b9c82a3e7b3f56dbf1b4ea002295ac762e520a2652d0068a4477a5195e6808ce9f1b386a902ff957abf9105151409d60642d2c39d4f897d492610137b7afda38e98335c5991f626e88f823fe3f777a38653afe1862ef3f97c601f6174920050f4144e895273c702f8b8b8cf2220068188b19673296707b54e380950381f95990da6d4a8da7d48788dc4ae4977c5cea88f14db7062a0d3a872b7e00c310172441b7aab40b3582646cfdbb81b936d9fa7be7557c8a785d0b0e372a0e7d57e05f135fb3f069d21df16ce352ed548ce6d24afc577c68738f8a6a8b2b4cf0ca5f6575413de657bb496a5c0220936020e543acddf66082c3ce22047efaa05bca08d685a3942b88d422bb888a3ec3a2a61bc0d09af411c0af2f8b1510bf6f013991b8f274502159473bd77a77af6401c8a9d748da865396c6120410ba27935491d700a1886822ac7d38c700296863b10b35f38937de8d21f4fffe91c9c5515d6ece8f392e5c27d093a757c4f1b1ac5ec92c7e78ed20af92f1f4f0f0f53586590f8112368f73508e863c2f5eb933a4cbf3011ca6c9a863cae36c60dcf19d88c717b9f1bb8382acf9f2ac8f0f328932a1e1262f4cc931ce55421fee7d9fdaa135fc7f02e81ae15f05258166481563377d59796b3453915e60ac711d475bb586d282e93fccfc64306f25330e98f0df0f4b4de36a64e1a0bd445247d61516075531c459fc2b5e61d65ca8fa523027d543ede6d9a0807247cdb5d064bb72ad080e9463ab42d2cc6fafbca1f81386d35388cbc64c17d5281cd32b4baa2873d23d66a94974244613609a11f8828677df7c7a4ea54dee8bfb0eade8fd88bca48f0a82f96607121e71b3382a9d5e46b52b40ddc274ecee25ca0faf3d3014d80ec1a53b1c4157b20380f036af7adfc331cc981354213e63092c6ec9ce56263b7114442dff3d7d8131d9953fb310c7cb3d2567998466e0c4085c8c47ca39c782582cc7ff31ffba88516a85376c9721e03170fe0a4e052a5c00695a428889430c5098749893d9a449c0d0ed503e1a8fe2449ebdce4703c7b32e11f079334984670355674c4e8fc615befc0989683e42e2c902c06c2d48d0173846c709632ca998468db0d6182e4c2712f8c0d4feef160e4fd067a3bdcb4742eb0eafa7696a4d22eaab95a2aceef9e25af59907c2d515fee95c05c5a7f3ef19b6dfdad3e9b98c45fb09bff4af3dc7d917e042bbf0672911cbe0e5a4719d4593d4f6576506279b622a059a4c1df7e2cf8a946fb764bf87216a9c003f3fc8ba153430c6587fc06d33119080a91f0ae17332827c73a974642dc5882d0591dc44857775331509bdd2852ec909bb4d9d0a7af73fa7562f3624c6bcab1d7beff9cbc108b739e34ee411b971443d11f2801e12e507eebb61fc8733e47ecdc05031b0aa80a9e850dc7acba89a5b81dd2564c5ed7188ff8f4f0c345fac318563f9e2c4fba06ea1f67213ce218d9221fe79ad2f8c172997f32866d1d53968ee3c64d070934639944e3458ec75e77e0c8ec5230356485b2d38a15ae98997be2041f1964be32449192330ca90757a0f83932798e60043aea12c294659ccf228470a1b3dcf78246ce61f41ee7cb9afb2853316ea47d98070b2788bac81ccf5f3b11fe8f5798aa059d40b63276c125daa0a81741a63b5aaf03f2b987f3bf25304e4312e9f568d2b38707204d87175f3d47b457e6bb90ec7bba7b883aca2e1494bb7ed313c83ec153336e594d7985092f79075b048684b0bd60bb74bb5621dd671e379e95b3542c9cacd4af9cbc8fe09b9644f7a90d9babf4d99d9738ac168d35166d29ff72af79752b5674a66beacb31d1e859ee95e8229bc7ef83a51a4466ebbf4d66fe43e094e7196abb1ea294c90123c964cc61bfb6ba843fe1dc900d3b4e5ec2bf79d22b23d60114e4089a81fa4a469df24056777e9c9285fd5faa030b45c51552cc9bf8b9c5e4d409ed778a6ac5a698b464597d7ea2ff2b3dcc674a5f56d82b560df55b0f0c76003565ab643d312637c70ebb8e20e7ccf28c7c1803d57c33406f7cb799466c43c275a0239af77664bdcbf2633650c87cfd5fb15a4a2017333b16ad9e889b7a2337752df2c7f54cf3789f246cf582a9189a602a23cee9775df3a19fd71a15ec5adb0675e958890feab568eb6297497e8a7e40c68ca4fbaf5c9257ef1b4d5ba4ae0462d3ff04e3d8676070ddfede1a26c28f986e2e51dbc898146b6cbe7dd35242005d0e72ad53b991e381b2ce85f0b9afd906b112f74684ade2bc3ec4f8c4e6cad9915078c904b7772e9546a67ae0a56b9d26538cfb59d3500650c1bb5f9cf8fe82b58ea4b5e2e19fa3d5a64095d4a851edfc81435f1a631652a18b655bd75507ed0f629d47f81bb67b6e9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
