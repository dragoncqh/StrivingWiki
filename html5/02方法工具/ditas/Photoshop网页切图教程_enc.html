<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7cee60a76fad74d14ec13f3a1921691b01baad35330c6190855a5763bbf823bb032b680cfa7bc3c3c5c9626cb87e06135d045157e57a72e27052affa51f1f03608f74ed66dcf48c59eb745b91adc2ef2f13f18db314f70a94ceeb9d19e1b83d3aa80df6019b8ef6b5672d11aa90794860d0594d5790661d11971a56a6fbdb83d8b490272792ffe8a1f6d38e7112d2c3fb88895c40d0b1d910925401162fae92e4f289230e02b3feca185332411b2dd15105e46e0371711010b7d6382897eb87b52dfff0ebf0ad40c980b0bcc841b643d41420ca6ebfd88e32cd672a6ae7610f8077d906f8bcf20a233e482a6c02a15c576b1f9b13c9800200099b7212854df0976fa46803b983e0c94e43b2597e942d845bc0d21f5e8bf201028a9d3e934b661b866b4af52acb8d3714ad738d71473e678d5cee2c557bd4b0bee0476ffaa89e8d85c634112b72424cd82770e88075f5859fa9d4f5ac75c959911337bf7fdb86e095e2d369db1630090cb5b387737c98927a3424e81fab5abdf3d4f1d32557cae6643d309e232c050295b2f3254273383285fa79c9fbdec7082116eeb8c50bf184d17d08bb4d04e2fb8464b719c7133e9fc8a18b4e908fad5de4b6f5c558dd378020e99175fc930afbb2dee5ea095a50baecfe8b3ca78861025b4f445880f59ed7fdd6f9683ead00db9510a0646bd72a2de4a47d9428cb1f871124de9d96ef57a1767a7c42948fa34384f7ff3300b28940ce7b84574e81313b089548486182adc804f62d31631161a32e0b756b78855ebc90b3cc378b475aa1fa691e02b13b90a4b565678116efbce43d7104ba9fc3f6153598bb4f0aac762a335bafb2d98b559d87d0e672a8eb75574b44e956c96a4589ae0e5fcfdd6d31d073a6e810034939f6021c9b6474e47adadbef478e5a53b9af9ac0849f98248ec5df95eb9f4b3f70558a703b70f30d30fa180a602de2bc955a5ca328e4864e6bc9d131d3253c24e43a5ee25d9a4651a0b61f57907d7657d830a31f9b00a16b0db1d3d52c0d9295ff487646509e1188bae5c3942f3b3cb39e3c5a468c6428b1c093f5ec4f73324819aa8b97dce9de68dc5d923bdd2bb5638aac203edbbf292e9932b93ce431f5d6338f81c9d9267538fbbe32095d963c3ee5c9719ebd8096ebdf2a17c672d5469a654b1051095cbdf17d453e87dc2158ed1ce1d0ab0fd8d8bb0234acfaa828f53852e0d4b2ee7ce6d9d9c6be804e69d0fadf9be684fb44fa0be10858231ada10f7356d90bce0d758126def9e68623b15e816c23d52725ae20f8ae6c1346a573731b1ae9f8c4e774e8c55aa9841a683800e570e5420d97f121d3444e9e64e9334104b3ad79d12101ece74e50bcee9fe27b76cb49b91a1aa0e92871ec3195a73a8fcbb8ce4bc28571fba2993fa8a7ef748da320dfb1d6947ccd77ce011f8c7575bfa83c7077829e865374245cf6727575b2ed9b20927d8c4e093e988462bc2e6ec1d27050ecce4edaabc813eec9394979c180117df91173b6ea0d80355bf41963b5c1b1ae583245474d324ce64c8ad59aff0f1f754e03a666673a59f520ce7c6ded14dcd42fbf9dd94448fe69da31fe27554854c2f32eb3d7a5b7be87faa9f0d2a1a742fd11ddf8ae9a671b3eb9ed3f83c49dae577a3eb2f6c4d0e98afd8969f33fd678b2c3dfc7b064ffb81624b0aaf3471753739abddf149a44ad8d3aa2c147439f9a7ed47d7ec8fe8f0a0ab75816a9da9d329f9e2c1153bae67a22346cf88a9ff2d63e57d42c4025c98000fd6d3c12bac43971109f8c77db92cbcdbfdf373b4eef03305536076a3abd5fd00861ee0b9a8e3282ba45eca67eeedb583dc010ed2d731674384ff1396ac9264c06fe06465afcf4543ea056f175ba6ee95f5e270c44689c34ab0107bc6bdf3c0f2956623b17352d4954008d80f18563f9d0bfe52caf6e8d4b3c637cf972d684e9315b2d18de437d87918b9b4a914661fbceb16af0caf6f066b22a3796b7a5dc279a2375a0dccaf5a2ff9a95743b4654c367fc7f5ef83b148af997bad5a44b0e95da32c5fb295a8a181a035947cc4637e55fd6259165b22bec4fd8158051f38d6df6820227e181fa859fbdd6faab827666fe01b9b6e4f7581c03451e69d927dbf7ba2b35b8d6d0f7e5a1260fb3c569ee63d3e7d4d630155c93bf6081b738b891a69788b4bc52ce0558d74cac1eea12ff809b1226f9b8da6cc5a0c5bc3dc28b9346f3a3df89790559be3c8aed3a1d3d90d8cc8d619beed893ee81af292416a9fe4213c030c97ecba6d6640d56de829ba92737281810183b0e0e6158e087f0732256ffc695b31c8f8305b58d5c2c0f7029f1136335d3356fc8f9f4903c3314558ca30a83303ef0c17025b6d4990d7840bff83058fb1baee443c1f3eb6970983411f35c226df0749997eef5cb76c75240062b8d9d2f676c7f5d7f3ac001cd56c5c9b17c4e4cf849d37ba7ca8f74ddbb2fcd0c5e5831f58e0567571eb740a7b0639be18ceedef87d8788c4152f5d046af36843e3ee9600f5d0e47d4d5f41dbe1fd2e5872ef34de36a348168a24f16522fded5e660a3beb3913043f668b999ade0fba469def64d984225bffbdb59967c158c11b2d52f5694d1af26a8963d1663645b31bb4cc57b4d43720be58790e433e4a5b67cb20bb9df85666b81df9ce94c1bcd08013ed3efaacc57cbf54860418d42924b20da9b5043c575c4b94b7f97f456ec533f5263e0a27332ad61878c37e63f544b27059bf9f22cf14676a6144dea34bbfdd20f12ece8f4e4ddac008aebc9bf62f04521a3b1bb74d40d37b852bc0419ee9ea023c1f5174740d7626c3765b95eb8ad8a946a795efcc5cecf0ea401645d90a448dc602a1e1f6d243218deaf6d2da3ac0cb61af7e41b6ccc2b57806f699323a74fdf3298fc02aea6cb007d8274b04636df57320a8fd7c5a732f0be0c05cc478dd4003990528606fa29b4fda1f7b0a578a5b1d2e76ca1308d6e0b4005f994fa5210a7658bf2c20ba9b0cfc63968c8549ef931cc4c91fe8dfa78e3a4724ac706b3d09f9499d2694c047889a3cab427f3037f2fd090179461ecbf76076778c67bcb80d1faf97c86d1a985aba2fa9e102b434c51c0b7acb3519277c549d52104fcbd9b6e2d2df1000ca1f699898ee5fea61e4ae593be4e0b73044ed3971e8e9480db7114429e91bf55ab26a35ff38de4df98f0f1d75ec94426f07a31f66e35e952e30072bb2797a65eb2009d186b0287352ff69586367f66a84e8d33a8a874be01ebcfa2c203bc23c979d98b87926b2003e84ff7bd67d9baef9693c05339833a60f60eda994b07bd1aa90ff6c75d851dd27765f83209a3ae34813c988eb05baef3d94f5386938d90870c5188f831163699d64bfdc951d8ea1d046e113a08d08dadb2a4c964d69aff771dd0a84b636c0bbdf907655b0649f2c18e97fb1b930cb428a4eeb991c548a106458b9c2d3d21d315c56501138c656c8b62bc850341f4bd3555a9423a2ec1696ff2cf36dcc98ece914a3a3c47b0b2982e29d47f4dd79ee8d2812bbbcd4b05a8827e41c8320f8d569e66ce2f7b391b415e5c8e421f032952f56004b2bbbee2814078272922f43ece9049b87eb345dba21bf1afdec44c566751bf8b987aa09aea5be7165d7b6d88829fd06c2e0f63829c971bbebf22f16f6af98f217168cff3315551443c08eccada6772901362cd2103195d6caa505ae8359b8c202a858b53c3706e0c3689c841cae594aca22e5f2bb56fc46890c6eed5527bee696c271153f604ea69fb2c7789855695dbb70714f99adcafc9de46fe04f2ea6df4c5de58baff8216b4865079e00e417bc81aec93057b7a7434a45cf8139100c99ff1a20105bea11d168aadfb4cca8eda887a10fa78f9157ee983bd383a8ae2c8adb18ea8171202e912ca2f92b6bf6a36aa20dc9470fde5d30d987f769ac4ca42b21d1a9a8215040fa35b9e2f9c433511c049f1802cb4687ac3b20dc643f0bce26b0f15672a683b92bca994b395511602193e52a9f443bb843e28050d39c9f3c1751355e47b6fe30ce0848f106129ae4553e938eb6ca2064183d0f76de36f1120d3cf69b32003a3abe5b6faf838341a71dd68f27f584bac2972fb34f51a2c1666fec6c6b83524604c23777f04297c279f5e1a780a8307bd95e9a02fc3bd749f632f134e9e4dfcb9c4af37de9c97ee2f2d9ce3c7fbff7a8857e3199e573e97143c7521df62b9f793aa50957a646dbf85c2f5fd04f132aad4eadfc75c32ac90f5bec3ca1670c931e83c0774ebdbb928fa706bb21eb66abc5a2c414b4441fada5f18571e6837e375b0e53c2d185f5124e09dbeb3ebb0525e21ee3b6716e76c1caea10a0928d64967ec26ee7d75d93b8e0483097dc36b687e5cf3f0440b63ffb91c4cfed56d8ebf1011c158c4e71e1a751e90e939aa275f2833c64e8c466d4233d23371fba5fd787806172644d2a618c75abed24bad5bace2be2faeabae29f5bc4da97fe61278c529919f8f43e39fe6eab1aa7394322945b9b7e3ab7071ba2d316f200b39a18ec50b02456313fbebaa39534e449a4b17fa482be95376b19130d1a3f52c5c3941c1a4adf6ca0133ce1700537e497292ddbe235515ef64889c2b354618f92395123ff821de87c3d397c318154aa8575e812e2113b0ee0a09d5f5e5bc11e8e5c74a1c2d1ef20a21eb92f76dc2284341d99fb1d0efe1a3d2b2bd368603d78a5336b837e61f319458cc6949ee79c2ca8a2a63fcfc07ffd81d6e6ff74c783a579caa8a0b2ee1c01332fe40fc59deea699f64ca505855ed73a48f99c74708b1f6c8ad6a1bb0a1790d5d7fd932ee6f878c73f84e46c1f98ee4948459ff13f0e21d6f2c2b93122ef3651205e53a41d7a6009212e205a831e5eb732d00623d1a32796b0968022ffdc303b75bda9b92041d9d20a7cec06e56151fd3d97584b253bb6aad7d34d2df386e5d40701d6c5275a9bc85d7b94bbf3e7d52bba0c497137f43d8eaff73e470aa4cfca4296c77e32a838272ce28f37292d9d072e349ef604c752ab9a01c2325f002eb4e8c775e611431f3585d7be2a5ade43f429b662a3bc64b3278369102a9de0eb3f621f8818b33b819afc951fbbdca4427fef7acd0e93184bc614074dd361203ed7f16b83afcb0b0ca9d157a81ee2dc35eb843b4cf62764f7102a9a7a31fe714abf7bc34bdddce327bc0b32b3317191f0b454641edf4bd7392e1b2ffdbd3a1630e05db2673f6b3672168853536815a8be9129b97c761806aae169406b230f70ea471a21f7d942ccf1e2983b182ecbe5da922d3c508c9f4c282f260d08a34f74f4529d7412acb3007609b33f36f0a28173aa436d5c953be7d18deb860bf5056db23395f98a870197c25c22533235601bc1465ab7755d80fc858f14042be5eb4720359128f8401a87ce1fbf03147c10a6e2dcd185fa300a3cb870ebbb040767bb26e6bd0e8e26047ab57e2511d47b24a95a25a9212c5a0179a82a33a6e4ffb0bf02a74fd96fc09857f02986f86cf9e31b9d211ced0803ae49198f4039f26033c44c32f2be33572f30b86a4e245c0e965f41d18ffe769bfd3bcdfcc4ea44bf900bc8d88faafe1a84e5d9bd9b8453c3b4fd86a8653f0caffde553bc74d1ded38993b6d6b7a7b235c5b3240763754259f19147f99b77f8ba7ff88aeb2c5b547d817346537f504fc00f557ef3a3576424deac42c9af3a3fa7830b8bb9e93380d46a92a1c7089ffbf60b34aa87314ef4af681e165b18f5da976e106270d188ce28910be80c79db4d3f94419778efc06e99924cb0321ba67f828f4fdc06387bb61c62e021b1863922e70ad30c5ca66814f29a4b3e6487eb90e62fed1a1dc8da696d93ffc75e4d8286444e4fdf6f44ed8839592159795ec0fd99e645f1309e4a170f490007b796fa3064509230b807d8f0bf5097854999eb78dedf6b4acbe3ef30ae995b21c0b4f01a54cc0c51325294e66ae5c0f56975f616bf1ce427f47dfe1dca2f217a66a3801144b90cef9f50376f12890df1a566863634d39d3749d82beedf56a697f723bc87b6873281a05cefad13494746f78d7f8f8cf65702e73fb1abf0adc048c928968573f30d9a04e052739d69a2be6c5e6f15e6ef7aad2d727e69c6a86c0d2247d8a838dc53bffa6039051f1ccb34a094f0d1fe193c65a6e5cca674601a31c1f4c2f050681a696360701f2774875f75c9584006ae51eae358b831aec07058efe7fd6e64ba80846c02c46c9bdc33f51d9100aeba084f8c7d568d6a7aa59e8908884b59084d9a6b750bdc195fa967dafb359b6c2ecef7f1773e6536c76fbcdbf30e01b17fa0e1e18f132ea2e2d7a086f916768d3f13c08f5b6a2c342c6e14c249ff50fa3997e98203c00360762442872bb93e5f7990c671c079ed33a6f4766ae4fe1e76f584570456f3fd5125067bc06e348b8a28f4ee742f49d8f2fc29325c0186a0ac5205c536e16e4cc93571a21a965426951492ffca47a8c75b0e76f877a37aa4bb65bdddf4f8d74fd83b79a31093e5272282d6bb4451df38be852ec5b5918c7526d7604575975862f4470fc8bb683386ec46f1ac9c635b435833ac6463dd55a340767b0c42228bd15c39c03a12bfde10bc632e8c9c0abfa804c3c8be70b2e6c257e55525f92fe66df1be4aa3ab2391f3c8a30ccd3684548850d5f2bb5027c8a2c8cb4d9ea1bbc70f4a088886fca6522da8e249146ca86f4db69199780a1cdef010efd8cac7e3a0a2759b144d440131ade626ddb4389f22f717d665a20d73e1adf5fe6fe6eef01b8893290af89c451d1a8cfb88da3c97d8d02866b63f8f69ee347d489aa0cade57cce5af224ea0daef377bcdd3ede0d34c8c78602b69d23181e06d53cca6893728d9219abcceb03dc29070dbe096e0815e6b6e5884b8a6a292305ca842923663cdf1433576fceabcf55c2153c72c5f16f58e6e49d651f45e573d53810dd03c1b58006f5166333bf8279abcc58aa74cfbdc40c4afafb062750bb172497858371ac3e3bac23eabf9764b192a3e62e26ca535c7837cb77b81fe1aa73f4f79a3aedf09301571a2bb6f629a1ec1ffc4c0e87ab0a53004cbd45b0c140affc14a5dc1061cefd6a8d728b864feca458ebd7eb5daa4666ac4d155cac1279d5f355ab35df590a791bd0a127bd5f2a62e6690f428653187d10737013c19cb871c40fd20fef46d61c19f34588e678a7b4964f484221ea7b6843914954461e53d65d5a03e84bf673a76eee8e70e5fccbdd2371c996c9fc509c0e8c1bab119e4138d560b244caa7b23cdfd0e89e123188d6aee405da4183e1362e28439e2fcc3d358a52e0caa471a4d090836b37134f31d88782b0be768d002829a12cc12dc1fc1aa74300a5a3e0d372948a85be6753c4e8b9f07be7b3c283a6e13431ac9c941422c200b43dfb359762b7ed1774f6ea117da13b7824f6df7544837bc8b9ef16d452bcbcb4d0424fcac7eba3a066990ecec5ec93254dcbb1bcfb6fc4b7e7d6005469a5f18e672a6e5a83d705d6f6de836e4f80be5576a9c7fecd6d7c6e39965069b2e6c573ae6e3b71006e101f9deac6e2aeb4aa5c2f6664417e88ae8f1f6006aa5b53e931687453d1d98d540f92d4c275619b43307c28a7b16e932527c7a6f5474f7a04431b6a22b93e024422979eee2e4e21cad9c366289ea2d85c7b1aa81e2c9c697fe3182df9d6808a11323dda7a9245cd03d8d053fa6485ef8f16e031363ff936a3d7eaa5b75ce4d0072906d891cf501216ec5503e922ca8c87101066d5aca4ac0f361ad7c720a13fb7a6ada566ac0f3fa085fa1248d108248cabca5c4ea1de22c76668113b01bccd56e3b0e260ba41ab23f91c239db200ce3a9d5910afd943a1945588c507ffa7401d56e3240d2355cbf9be0695ccdb39da4f23d5ba1fab78de45de18cc46cff29de59caf567b1e63831026db6f226e1bf3f3e4743323e26f1a962d8af04b0eff6532c8375ba21925c8d598b5d0a696e3a5c0da144bf7cc178d808fc2c8f8bbcf3f159b467f44d1ff30a0b7e9077e2dc13af4b1e407dfc457f68bfd8c28b0b9fc51555a5f22349d61b968ae02b18601d71ce1527b2450b0554e3e4fcbab50efcb3e21af7a09fbbad33b38c9387e8171c6185ea267d5c88c94abe81c107c36de1e63cbe5a90d99e32a49ace357ff5d4e9812c991f2ee2ff8a894df8829477a3dc6a8ef29a299d6673125f646bc94488a1af2b8a3aa49982c59546fc240c276d0952361334bc6a8f724c1b2c61c2b0512683b5a8960d227fe98f24a9fa6668387a2c2a0dca9ca4de9d509cbc1a12e740324aba0e538ac34d7d307417958ebf49ebcc90a5b482be831d6e519e0b2596cdfced13df676efec4db3adda617503667bf8bc172c3b307548c1ec4c1ad51b49de5d772bf3d350f9ec1b695e70407c89505eb85e4c439416c0fd86db366e782a4455f56c6fb45d46bcec459d0afacf50a325010610ec744ef5b092b8d183ee905782968a7f0a7d0ee94ab8411f2d3ae2d8cfb3be699757d319168645cae48335918e923b262cf9887139e678fc96f5c78f3d7c843f8636467460c0246efd2622c25be1ecc9998b2f1b4b3b53ccdf10870f9eefa6104542df251485d8c309aa39767f69fec16aea2ed165b59fad009ffef4d6d82b66504b9a395b73cf20256aa0f266db97b1dd6cc86ad5808e808e120de2d94fbf8645fc472b1907ed53eec1ecb6ee0367d3e3934c298d90df46d0926d4875805e503d4c718b4b78a8bfc56bfb26fd79eaeb2d50efeebc0d6a13937e34189a7e5116268dc8e72d1ae45df11f2483ae2ff1fbb6bf2bd92b282a13b7e8341a844b2c0940a00284a77147ba2fdf8292c8d2cfdbb4458b7a622de4e57f7d9a3f783e09fbf7e4550e3650297c26b3277e7f78ceb42b0d6b43f50853f34ceedbdf71f82a76a8b7027712f2896338cdb5787824ce27e593f99e4dd540b257471bf720df926785271304588b05891299bd643eb15fdd3f143e6682c3c24b18e025cbe41e1952edf331e98fc1b5e9b588b1c97790b38c69c2f376086659386ae1c9b3be36c25d4fafe18e0605d6165d8542ff2a9aec72086c84ee2fba85f6eff27cc00a81940e8104a079828ad6e20f6ca94590516f5bd592779fa43a000c593f8488a38b45f1e9a920ada42702782f82d49705653a39be03caf24c224b677fc554fdfad74bd6cf71f1ce9d4e190a23ece6919a1735141aadff5f7ef6e88deae470201452aba57b47414466138948f16c6f8173076179a5d0e1801569925eb607f0251858dc9a4ba0299485677d7278f46964bb8a423438d763c7612be19a85d340455085bf97a9c962f26549e466438645cdf809e57c15649e8901ac9be08b33befaaad3f497d82e7f5c2067492757892065ae3d0bc1d82d13102e4afe620484d46aa044e438b1c166ba4a1c42416bb338e70713092d447874c33935a3741818a33c45eadc8718b26b23dcacf9f1db70919d0af0f3f9d536ad647a658b6ec72e76c0fde0a0b46038e606cc212e4f4ed3744a1f9f745971ec8f8839f7c2dd42d21721b80593044e7864b06df262bdde8480a8dd6a77d15b51f1bfe0bf968ed16fbae9fac11ff8221f653f94154b9a2233fe3bec55f5e1442528639defb1fc7d39ba9b28abb46f6c9ec9649ad494285cfae4f29b89d5322ed96081935e5a4cb2ba78d954e28227a8139d8e4408451bcb566e073adc732f141d500f87b575aa6bb6667dd0a8f065a7b4021d40156e4bf86585c71eeed0038409425d31db2189eb0f2794d90efdee94c6334d569cd804323fa4c8fd9d09d7e50cffb46378a558f9988640f77d0790cbcab5bf4c313f9504204ec3c118a12b217f2638e5a6389350acf5d5f036b7dc0ec60590b5e73f49771ae0d40598655b60f47f7f4426542b79034cb5f026509b13a44649f0833a264dcf9139aced06ec50298d78008d058bb9ee573dfb8dd0152cbfc49a35b2cd8edb77f34960ca92e99eef00c88580d59d1ecbbd35a24d7b975539dffe8d1d24cbd3cfa1389eb4ea99497d0805af0ba00a6d8c3905bee9a0fa0c770950575caa22faa17259bd3b91190fdd8a60d48c633f4e83667c0e965a985c561389c1ca2fa0e773ec2e2bf4572e8a9bca5a2b3234f4e8acd3f2fbe63e92fdb023c2cfd603b58efac1c9c796ab42a258002ddb66ad818f1ec301cd01bd09b7bd8e98540ceed7d6c4c0b623355d062ac53e7b4e64acadeb967333f8a499a17544f23e8edb74193a5143a6a2d1214265f6ffd40be4323f52c8f77b46d7aa55ef9ff29c9d82c97f36eafdc87226f7bc51c9ed5bb86aa100d315959ae10cf46045e012d4f4cfb98719cf8589b9bc9ae4eadf0a8c9f0b37b3ef3b7c90704a4c9623f834c20a328a9ed33a503f9455d1b39bc49117b34918759f132bb06f2ab4aae166a1405a894fadf88b7da7f37240e6c25283d40759b0e74327aa789a3021a1190f95e197607c257520a16a237a413c272c86fee79b33d5fa67df81fda1ea54b808226ebd3ff652cd3f76693ca5e7b2fae65189ae3405204df65ce469ec06fcb2ca75edf0a2cdcb0bb8855b68aed07381db1fe1d91cb2db786491338350d7af7eaca8d9afbbe521fb2801794adfe26d1783d73b54749417460996e6a27ff6a1d4fbca0c611fe4e76abce6e76f15306a51bb8a0e2329545caab10eda287225742329c2e9b26b1b1fc8c5ddad77636a5d9f3656fc8cff558fb2a7b24a29eb2a02b76d54d1ea1f472e8622b739d23be67f6bb097714c356787bf39670ac5faa6865297a453f2c3185447ea59811c090322f8460962a1f8186f0ae1643893d0f0c70b3bd7664acb9fcb41ce40da253c3e6c833cb565a88693eef1ef4d30b52a4f79720120bada2686665afa305e28ab5b0a052c60d988f8f0d22b69218069379fc0ddb4535a67c472b8e32f57f88f27ae609942a754572ebe9bd043805ecb2fb4f1535d389767302c1d09a3c4b1caf4c67daafd9f631e2680cfe5a6cc7a2062f740a791f70953fd568c04ab56aa91710f3c2926049e16dd9a1dc66dc6833d0f9e5e49b99ca5fc15e7ca48ef8f5e941177c7a43c7d6292d7e2dde2b8f9841b11764fa2091ce0ddedde7ff1f301d7d79a3b5c8dbbd9e3db4c6a4382c2ec2f0799cbc5b2e54ab9de4fba3a4d869be94f06a30ad4cce4a91b9be37adb8cb15efd3f4090df3059e480c54a558cb3ef26c44899161d3e3957baad10a877e18240eab3fbfb5963834f8c14583ce2225a26365ba91d7dd7987dd5d0057c5a637ccdc8d0e1d5ffb3cec8c81440b7917268ac23b9d4bceaa832728d631d725f75ead608768a7d3eddc0397ff10fe87d45d8155a81b0cbc440206f28859acf5397397061d59b0fa4ae0ee5db9a081c9c2dc28772d64cb29394ecbacf426f28008c84fa7d8035f56565cecc1bebc8def2fe6926da0df23c2d0948f19f778c0a3c489f9b47561ed70221e44d5bd73bcf1c68279e11051e843b905847c20b2fe3600235ed6f4a8e7018c4ea244e8fff487ad2c6866d57fee5792c56f8944baa33ac98ce23c78580bbb9f7d0c33e0510373d75158f646a098a32e2eee4afde6e58ea584ee1bf85339c2f90565835a699d590902fde93e769a40e0f00a3ca31a1deca57b93e52170d664e672e332cd6e2241a90335b9468310ac8cbc841e381717c35966f7c25f2e95d19d009eb3cdea38d599c64671218d1dfe3b935d38294bb77befe0c6f026f45d1956c7aa23ec9fa4c40dec28cf2b48a64e23f76a0d11619297c2e1af552a4565379f16b0f5e1e493ae0174dbd7c85ed4efdbadd8d87b28a1fab836a4590df702351d5a1b2ae3c39ccc2183b404eb9e5d2d8e615ada99d4fa4a075bf5611d518422a1635fa53c1a335e26193221a4bff1087b9b56ce9078dfd32f61c91317e54094c8488010347e9d63fbeb2beace9f068a0c8dde2a69d07c7fca4a6913d0969925e7ccdda77cb00498f4b1592772059db711e02a0714d511f235d3c1cf89ad40a66bda8a00a56d08ba8ab2eaa9c3b7a135b55145311a8fe3f499ed95df73ac0fae6ac06d7f41b9b7b002e52fed48991d7d830e478ecc023d539e7f2bb28ac5ec4d8d9b2be99244b825bb9b958bfb10c7fbe7434bfb54acbc307cf1d8b09129fd1b25b9e760d01f55db88cb6c97dc7f987149f1e997ef30caccde63981ffbd0992c4ddc458ba51aa0c3afb11b88c0473ac8bf2fb478bd6df0278e3b530124ea71c76dac8be50afa46117f731f929f6b8c4f5b996c180158988e10df50c8953dca8f5be398f3694253c1fdf715d1e1b2ad2eb413a06e1d430bb25e67730177d51b0e4f5aa7443aad2118b158e333dc8c453447fcde90dc675b0a0e31e811ef10482ecc89c679751e78450ddf71e7200ffd0dce28a95d2d8fc40aeedf8623a68db41824da1c17d8e65e9308341458c4cf5ae63ec522abdab9029038798a731a66f0e56dde97a8db1dc12bbdab7f49706e50ab915e4c23157aaf37e5da0f35edfaa963ff3464033ef06cecc84d0625348cc8911a14974472d21d05e9e2a3c7285ba13ccb144f4ab5d48367d9913c98c1812c4ea4a961ba148f574815796b674934dde7c2025a8b1f5ac1f354266faff9de83706884485be39ac5fdb204465b3e9fe2418bd1a008d6c4fedeb3e2766eba5cd82b917a991a15a1afd17751439c29eebc0ce12d4fb4a1138d0c8a03c40790178ca685286d0c56c8b95cc810edf3e19d1c78fa51d06bd669a4dacf8c97466e3479a789fb6e6f695d53ac1408557846c37f026b2b76df256586e622d6a2c64bfc10c1065604d88eb012b3ecc9702aacc23fb8c3fcd945d858ed803f1d73b37781b3eba12f29ff5445ba3d11da7e602646751203399618b3d8ea389b9989138655cc46f839e572afe2c8715e5c381d162bf1c29f5b784d62a5ab7d6a9a7c9870a6da31a1ced003ec23fdfae39580d5e55774e83c9f92227bc48e98d525999f147493a3c778d40f8c4436f63a95d99d6a8bf7dfed8ea19a14c7691083537890a9c9fe0bb7694453022167c768169d4bafeb722e8608b85e3f0b83181a6edb9a67de9b451f7c9b00f73caf7148bbe194e798133f676c645444cde2e9ff6320947089ef1cc009b09b169bf7b334f034dd1c40eab541bdb7cdd23972f8b325d55357e030add8c7a21b01345ec4b6e4b78256d2f3c1172b87039abeefaacee5f15ebcd1a73d0bac436219757d8dc6b0cd8d7658332c686d887791cf9420493080e14206d75acade1eea632f328fc714d237b2e53011f38f3e942790540efec85469d53195cc287f17098f7a1779e069313f270aa07733627caed93b9812ad8fd405d009e04a2367419d963b7035b95b3706ada32da3f62ccc6c12a4b7c9445140656110bec4b4faaa7f4e822eff0014a5f55a7612eaf6986261be7258117cc12dff2199745dd8e667dc3be4976feb93471acd56ef7009ed7cff5791771bd8248b4ab8b25839e3365f28a7a121153b741fb79d1ce3bfb3b015329c04ad9f495754c4711e491e8c34c90aa9378fad842ad44d9e67d093","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
