<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7750b13a1bfcaa70d001947cc05e03a5e1a1377cd6cbab94b5eb290e2e53e3a9b1caad233ef33d52571539411ec211c7977c37eca02145d89def084c8def2dc8b75e8ff21cb461b3cd912b12e101b73de8ef573c66f971602aff449e2355e1b5f572d8179e9aed09653672aa9a258861a5757bdf3bd0782872860bad474931d74275cf4e707e343c6ff5f4a2d2c1dfe0f0f8f5fea200586b63381fdf26310a54db474cd05659813057a64c7586be2d17c0614831a2f36a5a50d673b83080cf06a1536acfbf6a4f52a8ff4bf1f32a9bf15775ec5d6a1add99ddb3ed2b5cedd71e08f81a39222a2de5a57b13e8d09dd99c6e51d6229d81bf72b804b2d3261e1ac5de54e216167ccae09f450074addea07a53adfd0a907190032779108d2508a505a03c8120d6d64595f8804d01ac4f07068d7d1844c2b3f031ff1eca03c30b9e76af0626d01126abcb41ab46322df52d3bee804887f2f86d80a7501aa8427a1b0a623c1b4a1494911e7f08f902577819572c2441bcb3ebc86cbbdc5d7317f4eddd5e45ac4111ada6156aeb0e83a9b0b3570bc21d63deb86428602da0b5ca5a48ef8878ca08c0fdafe34b111d67295fab40670a834b29b6362aa23d8d63b3c9ac62b8395c39e3d6c9165932a45db80b18876e2c0b629eab68c1a33d74658f8dbc9d3d36d81a98bc334841f6b05c400e9bcf5902e8252a53ca3ad252da24a4b2250e6a7b16d3a7224a4f89cc4dbb488ad4c324ca057bdbc1c745e5ffafe1b95ba47a93e72f0ec7f39d50ed063c8abbfd85dff80e0f7c1284845f13a6b3052ad14e52062c9804b0fcd8c83d4508f2d09bed95ff3a358addc57d9f3a94ba541f5d3c172d9f80b101003cadb0b5d27a9bbd9e8f918361808a60d64b80482de2590a6348096fe64b3e63d78775bf458528e39410e326c35df93431790a9e03399ff579c21b41f7ffeb6b119b92df53d339598dbd3c6ed3b841ae7881e4ff5cd4957703fbb9b7e07bd52f8af484890dffb97c87374556aa69ab7e72e104456dc1af320934614f2ca39e09f4fe169749553d608dd0caff214e8c5020b03afb9621a5418335eabd186ac40dfbcd07b31fe4ab1d228a5907f92a6c85ec426a68b96904aac95e4736713c9f736c6e51dcf1a8c11826415b4c908688307f7725ec2bd2a45452633c65f37fde91c244677ddeb5ba9cefeb31bc478dc064639cb902c4649ca225c0c8c70c55f1234dcdac95a0d9d6945db4d4ee048d685440348a61ac56afbcde69cd924de8d629e54abd72d5a88d8e016a3748669557f674c803ff7aa5a96c959c538336c8943fa1eeedb899c758764d8cc3c464755a64267e4fa1cc907280fb3264bca8ab44a7c4be1caa081591831c8970fd102ea8714169e7a2df967dc812b990b3f8322964ce93a274c58ad67c090ddaaf7cfc3633d75538b5e5e9868be5fe806932e52fc858cecd88cb6b3dfab3c3844aca26d8f0b164ec7d607c75e1a579fb32fb2a76491e2d45d3a4d1e1f4e40a6fd88243eb170af4850586bafabe23eb5b2a21ec482347e821cde29a50ce7a3790ee1af73fcd2a91624e07292523f75131cf1e510492a243127522882ad3b9c1c06b7ff27c3bddd971a9316821d62ddf74cb489be7d94a3328098765f97552564de62a77f47e013f3aff566fec91de14cb66265d0485ea99a14262fff78ae5ec945e35c62aec18dafa54f14ea9fa3114b4d550393a96e94f8ee501121c61c1c8cab7fd7447f5c6d205aaa8074ccf7e8139b1cac8344598560bc7d65711fbf538e92a4c7cf5cd79db57c9a9b9be9b94218d0971eca32e0e8d8c0528a2ea0b9c77622d7bdfef920208df3fcde3586d637a1179a5f59b27c6f77da9179d4fc2796ee473a3f60f3117e0f0b7ae3f92b578dffd21e9d983c375f5815f04909b5712b8a49ad156baf5b6ad28cca78ead85f1130e7e4ce43a1c3b1c77110063120fc06c6fa37a9be1a51984cedac3a1bfe584e29cae2707a6b39ac934de76f3e15ede501bc44c09e5ac4703d6c3acde44bcd7a0e171df7672960c586d617fa874d7a3376cc52f649fbb5bc2b34b463477ccd1b085e767f1be02062e01a6d5dfc29ca64f77af54f6a5f6452de83057e217798caee8c37878e47dd625341a25e1696c8bdab40b7cb9215ab7b8d380977f044d0fed56ffe90389d8e8d13022b634e94299ac4f574de4df6517ccf867d2c22d5e696f34c3bd99b94490e37dc5f574c4d93327837a6caf90435644a9760fbd3f7a1d530e5d5ea6c3b85389a0bcd8804673e8733fecd3bbf4ac83a212b897f6fd418c9ddaf5bf5afd1141025edc37295ea615422e4668a122df6ef53121d952790d469588b1647c3faa66dc1413769fc40fb32dc348e41119bc7ffbcef6f4ae32d8c3c6a53efac610f7aad4e8e9dfbff51078c9126eb04bb71d51e43361f71d19c8fa0a447634c5e25accc61be6b1e2ed5136637cc9aeafe7eb3992703fe9b88e638005506db871a49761d7f67bfe8276ca5810c2cefdecdb87bdebc3930892c1a44fa40d4d0d26fc21976e62179fcff0325ef6d25c6f38a5cd10ce259d327da2d0e4e965e1086ec918f6b8c2ca8bf91c4e4ae7831af8bee2ac8ae1e5600d35ddc11f5ee60511ba29136b2592f45d5e55897feccdea3c831e1de159ed13d7e6255ba0c15b25edac2d01cd4607ea5758f24507f447187ef12b5d92e81c668dafa010288514da958e7ad9765a7c575606244fd4b4b6a4a193be755ef682330545db9bfe92680c74893d134ed95a5ec6fd34c91cf9e8c181c48f81d6d7087c1e0cb3968455eb1a5e89de9fd5119ba3a8f7fd952507a06a42815b2fe648f7af81f5269fa4628fc2bcbdfd8098f5d097d47e47dca4c6b77daff7515da9a686cb2724729fa2dc09c1edaaac5fc6819edc6fc3e065e1d166d7a8f3956819c5425f41f0140016822c7bff6d0fa3ba7f54218bb2acef56aac557476341119d305540806e9c523fcece9c6b88bda7a0a6ad854b184854a376d82e80960c3832d3e612c4e39bc0c78612f4cf225bd0c3bb8548a33b1c4e090db16a9412c8ccaabfd05bbd8d1fbfed070a56c97d59a2e94a34c1c36f9b2b3040396fc8d77309123241b35f81e7104c63ad825535170a3b7ceb57d4eb417558ee74c84639577e757909466b701dcfa822a9a3c2eaf419c6c091555302530e88afeb0bd46537c70128af17c1556769e1912eaa1319b6fc54d569bb43ca47c668aad44112d0d10b6169d229d6b21b713c296711c20b92eb9ee4f32868950bcd60612f20111ff619e61c96f8d0a1b6c7cbba3c3bf82d17229bcb115d89ec48c0d8a696cc5a2a598eab23bc77afd2be50c3903ee4a346764949ad83230db43237ab12298ee84c97e304ec2f7b50ae804fde3d5c713a426989fa5579598ff436dbd4844a8b30606c5ed393d21124e27ace92b6c4773bda2a87f82e45e1c912e645794765c7624d8dba49cfcf05319e74be6e99481b7192d19c7f61d85ea529a2319fa75114e34f628f69b085fefb6432db9199e912fbce5c39102786cc2486d61cb298f59b212b79281717902d2b02c84c4df5e7c7bd0e9a1994d024498af1abe4313ef09264e1f124b4fc77d613c634d37d11597066d9ca2fd7e0f5755292540afac27bae4acf426dcf8f249b6163712df39adc55db7fa1b8e58ba236f39dccfae19d92b5953198cbf22d3c8a1e957890b32b661ff59fb3340ab6cbee96a4561383769b61b3dedf000472ed35f7f3839585a655054a405971de70b9b598cbabb005086b553d054e76894283463f7090cd280487a0c1795e0f5c4cf7a31a7b8dc113838c59b93ba037ffdbcc546cda68c758a69063f949b07f2a06358a3f489cdd6e2cbe401c5c54547d4575d0f68b473c87c86d0ea2710ec49f4a629998c3b2466c1e7ee5135aa73d960396a27f1bd73a8dc1a5e84277b7ed4573a649cf550f4e4825b38a1c91400ef1e212254050c8e3dfbf1f08c06a10234b910079dc7431ed916741829275da03ff7708b9fb9dd18ce6bd450231a818e32ae7358e0b78b1b631a01cda4e4e926c600f80ddca4b9b85e40a4e5f8e1b375cf03f7519368465a9a73c32a97121e7ea62c2827dde38dff949a9b181bd59218b98e64632a2fbb1b725ee226585abd1ebb02e30cc097cd0f153a80e8cf0e600cc1e77bf981f92fd1cb7af2acf232db042579dc5745789fdf3645b178fa2a49d7cd03c2cc0a8215c7a3bf81db5dda2aa52d95f42f8ba6363ea8fe50d4f3372025b74875ee2d5bf703c127ce6cd81114c521b99979f28306ed3c53c7a20458335716bff9244c61c1227d918e1707fa4f89f6cf51244568d323dc1dd4302b2b829c26559b6d62a89d284724b876d760a1db3ce025c0fc6612c0196cad1fc883ff5dccc1ffd800d973832762699c807956eaf1fd225d32df1e19509a44d89b738daac9d43d22fcab710004d16e858179390158dfd4a4749803a056c422272c485593218d1eb551ea247fcc623a79779f73198753481e860436255590d7debf30a298f576fdfb23c5ac82afc4ef76d9a56a315c61b7784874ef23fbb69e9dac809a9f16f2c1e0b44a4c1ebc50aef9d0b95bcafacf5948ca299291024bbb351834b27c9235de1302e2320dc121a6f128524b05e1a52d552722c17a4c58cb8d8780117ef8af3bd7d160386ed55b562c44bc3188bf7931fa4d52bd8660914fcdba3e06603c0a2d4a12ae18f0758c12429e944c74c7f8f1a0da5a499f87c6f125bad491502cad1305a551456ec8f92fb87a35011fb3ddce8427e1ec59dbca2430f32cf844d6520356782ad65a5f2f2c37aee3a7ebd7a542ec286e8e8b68f800e8e9fc5f0e8c5b74ea89b62cca23f04111cf414a238f4fa905536acb75532168c3796dba599cc0f2776ad746d3f05e113c50c97817f7b0121e9c58cbbd8dbec443011992cfdd9956aee8a5be83118a1099926357b6f25e975fc130a28f4d83033617dd39ed4b30bea3cf1e8ec43ac540fc07de8307b31887813e3890e47e38e318de9d1126a4db5c5a3ab2f8be7ca49020d34c3691a7f6813b2546326d55fac6bc9ed92ef7e84027fff70a3bf3a4e04c57f756499abe1c59afefd563522dbf118b37dd71aba7bdbfbd941ab0207551d014d2e1ef852d160fa86c412187597fc79250d06a56737a0c4ea1728fef861d8626218bc3c62300320948a3f26944cfb4eb5698532a9879752c4d5b230eb54321bce746585e799e02b0f92e359846161b98e21051986caf6682a329426ef9b4e93f1f2965f8d67675e511592477f7f14b9a84b9290f18d4923ff3f3f2342cb365942b5ba2166ac473e8f9db355f3bbbbe44bfe9b6c4214b4ebfcd59cb64eca80d10278ba27fd31c0b8b9f35c58a88123b1786f18e6b8e9017862d1d800dcf5e2ac8f4d3479196bc0418ff4d05de5798dd877b7af08b8a14207bd82368a364eede5c4ac7c970906c0f49c990b5a73e1b5896a0f233f16c6e83685b01cf564b2220f68b09feb01e9c38c893be7a9ea85e007d6659d77a0b0e40e145ff11f649affbfd7bfbca98c08b9a481aab689edbd1ae4d5cb65680b2d928e50016b147f76c418e13618a3e1982b16c2dfabbfa39b6fc3b9b65c675330d7d4b2ec7953e7838530a46c80c91dd767eb7ff366bc184c431936443b9d16bfbedf888d21b82f6ca6b1067908988b4f915452c966ab1979241ea1f894e61d7d1a400b962428b864713e90a8769aaf36bbcce3d0faba20ff9e238986801a7525813bebd2ee9c5113bfb9c0fc61d92ba20dd07d2057eb2ee5ce5530665cf59e97db8055519f90f5499a710133039efe1b498e3119668c8a57c69e944734983fd256b7a17216af99e129e57d9b09eee375180d239dbf7ce3334ae9d378eebe3db2b030ae6eecc6ea2f2d2952993052e1bf1a64c3a54a51e984cccb2599f0d5a955be7a916cc08fce777b02e953543da39ba45b0889277f6c8119805f2e312c1c9147bded05a9f3ffafa2c7f7962c979c30679c937140cfcb860c1b83db95e010122b9bfcff788c6cda8fc30f937d0e155c33866a85e40e2dce955467995aab0e1547c219bcdcb8dc1d17c834ecfae4dc6c84914ad74b5570321fd8e3ad70c5a91205432a9ff0138521dce489d12d558bab1c2fcc523002c7fa5cec013d5aa086b0b632bf2e2ca714ab32f9713bf7e32836f87d11c12dcc9bd9a0a13e288441d7c9a563272fc2d8d18dd9265dd7160cf2d19f4c107fa0da2b2ced17fa1356464fe408227e685f35407d3e46e093ffc28eda30d7845c390845637ba0df67b7935510f1fbf3cf8e9663df91eb5bd0999622df34441ebffac79a9f00e1c0e6e72c505df03952fe34bc783c79fd8f1184e3065296513dfae174817dd50c00bc47815c82fa83523a7ebfa56dba6238f4306f10ed3ef0345a66a603396bea681977463d70922ea162e5dad28d0742252bdbd70c3a6d52780e3856ea340dc2fa509e384d505f33afc093d6fed88dc93cef363802263c72c4de27506221edef653dd5da01b68325cb8081bec2f5e14c1edc552312dd391f97f9c591fb041ca9f30ed742b5299f6eb6c5a2720003fea8c42f9a19b7eca89c2dbec2e6969240f152e845f2d1af2e55326ada59c2b8efbe8fc615640fa6f07807368a9a215bd138563029d200453c769824f4f3c0a1b2917b8bed307f66f63d82d9b8a137b87dfc68e5786e6faeb4d3c3814f9818bb966d5abf0e0d27f99d2471873d2f6578c587f3369b1fbaeacda1e00bb4aaad3eaa5321c539b26ce37ece529271941dcf659376bfad78481939abbb5d17ad74c9e4838765dd20e8befd3b78920726514b2192d29fccc04fb1465e75ef0466292571c49c5c6868a9fa0969b3cd9b2e7f44801b7bc880b42ee449686f6ad1d7245bf1c41678d8b39d1d2c3fa618c5ea0f77352e54e8133db36932db4abea39cf7d619f473687cdae0f3a79138471e565a511676424cad820fd4ba4808df084ba8749dcfb8b0d94f561c5168bbc70f3ee4bf7becd9c997ef3641370ffc92850cf4a613d63f4880376fb712174f0b2b560e894afa47aaaaa870422ae43158500a92e4600823c0b0a658973908743475bcc848041c442702952f2bae1b2b0b16f74b987fac1d3e36721c638f0e52b59b9acb4062b58e7d9caafb6f9dcfede3a9b6a89e44ca315669be58986352f8e819ebd37ff64ad7823ad37bdbe351effdef86fbf7b29d50025a3632da8a15e1021ff52628951cc0deed246b8d6a6ad6bab2182231fbd68a392fa34deb104100af5e21dcd86bab867ff30820f8f0c01da667e52598c36688c2b91ac449428f58d1fd8e62dd30fcf2a72faec6b6b272a8c537acd8935147ce920b3e99d11e7882932d159818109aade57792e38625888e2110bfaba27c2db87f296490e6b50377297d35ba6db477410e408d6ed042809a82da0b15ea1f23b3e60fff187b85496914ad2871297a2bb32a4238c23a167761700881abde54e0b965b332feca8eedee2e8c82193b39c092de37e450bfaf5a2b288157ad6c17250abfd7076d418b97e99d0629e9ff2c1f9282e2e9508a1bbd8d57094f96d9903feccecd50d54f89b99c248afa11078753e7a27422116820a75cecf597b9792068735674e6bb32450b7d83b12a8e5663edcbd0b4556aa73c9a4919bdc3046f8a21e13bc0b03e816b5f08fd1406a62897b194f8637a34cc1794d5f5c3ab2bcfa91c73dc63b31aef6dc83984b202ec912b34e2c0e6e8b36178dc1c3bf71df886e1db2bf72593c216d0c8e16aae483d00334d0c8c4176bb2fbaf56dbe9b9b8376142c6a74d2c931ec22e0ccdf43d81ded39d8f782844d9e0cec00b1be319ea1751df460f95c3d9648a9910791c809e7a4d220eabacaf3095b3379382c376cca7da8951fcf8fbdae360a9ff2b0191cf2334533eafb955763aa276b259d8a36f78e66983bd66491d0c1b59618451c7bdc3c31be6796e058c6d708f27e7097f89afc16fa259a91a35b901141aba3f505ce36ae07bb80ed574690094d6ba46d7b0baf582810d0b7bb895c03c205cb222202d4abc1d9820768bf204a2929118cd6ddd1f98718a42ea174f55c0941de2b1f99dd11926fb65724796e45855ea9f99ba23fdcd6f1d7b2a03dc5fc9a949a0264fffb3a89cdcf4bd0409f4ad5bd2a513509a748f2b985d5690e1e72b665ea3ca673031b0a216e12481af53691c969de0709179f0bf074cb217289f9504711b3c298df58c27d2922d2ca1489bac42eae4011d7f33708923457e7191a9b304cdde22a7b5fc6c89af1881295e0e4f880f60dec3950751b396335b400b7a71f2f34add6689c14a322659beadc7e9999f3530f91559558fb1b315b0866d5c9ca763e2efcc6b39c1021fdc7a8ce509c9af94bc08123a4bfc55fa922b4f969964b2c663846b83385b082b0281718a14a47517be3a88b2d9733331c20785634169c68eb242f97e7f50472bd100043bad7cbeeaf8f5cca7192b65d5501e09b95e1d072cd8d7ea0440d28b219c3957ff5d9faf1e266f9d6ea2c56447326c860df3b29099c4c101b0d5212cd97cee11aab5c9771c5e306987df49ac0336188b0e806d9bcfb712c26a55a8a79d05c241a62d04b8176eab7c2317644ecb61e774f8c461f1b64f78635c958b7bb6ff2436e16395e1485bea946f74d98358ab838c6007da12b3e21b7a6901f38826ec90697ebcc230080322a068e2c253f5f65ee4bd5c8fee4d3da24043ac4ab1c2f2d88b8d6887ba4e4a95faa3fd2b531b2b9aa81b857f7f3367f8e7b2edf1d667277355f8ffa7b83769e0fe318647036894c92896ea6054031485e884651988c183158c0c585ab583785286f752edeae9c9010a3207c5529c1ad95e7d6da5e876301ebadae38052ef02d821b90b43838f61eb054ac5e8cff3bca205b3accbaa3286c27200c1b7eccc292cb113dbd0ba625c29a70856a661bd470cbb7b2e607a4c936f5aff04679bcecfbbf4d5b497be91ef0f95ab1aba21ad93068aeed28d1476d844656a94f4c86a129c45afdb1f7b6c8caa24e1cad5fae2dc2c5319e2599d3bacbd828b604353cffacd04cb1d7722a0f2a7ec64fe5b7a045fb424fefddca77d8fcb9804bc6809f03c202b5acbd62d3e100d3c063ec30bc782b461b90efe24a7d1308a4c680a3599f98d40a8fc107d376ff4bca8830da0fcae43ac9c908f69d7ec6100f582d0fc81c021425f3064bd22d6f6e1753b665bea61f9661dd62a16b9234475c38bdcd37d68f7a64a66b2213e7c07452d69df4a47966cb015fd564d2b348632a98d06bb22b6bc84d9508ad2378aea7d4a6d713b5951df5383bc2f69e6c6cf36a2dec44a97b7cf03a2e010a6ceca05c71a616c5e752f286d98c43d4cfd96d27ba6aefc5a3951e431ddf6205b6ae6a8b7158b9ca89f542f92eedb85380ec1ccdbaf0f35fb6d0b0fde40e5b8e1b06f6c3c55ff8546685a583071a7b332bdd4a06ff15c41a88b6410793427d8dbc9f969c5f9f03adcb5b2ad0106910e3ddd5bc9a9df003e35cd35f53e5c33ea3b7c94bdc7dc5a42f7d07788559c4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
