<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e930defd33d9692083009be5645441875da65397635c6e8bcdf0c133ff6287c4ea420a32d54bded8aef1b47e18846e73882d0d22229ac4131391b99c054449da6e999b1bfef0d269cc6f8c2cdd7faaa249ae4057ba6a573f4a1f95260ca877614b4a8ed553caeade84adb287987b52dd4a033618f2b4e5466fcd79f9d354279aff6a0c317c92a7964ffd848388fc683de170ecb6260302e9b2139ba36e42b9f1acf88dc3571cd0b769318d7ca474f874c9ad14cb025e0a272d043baf62b26416cf03a5ec605780cd4baaabebe4cc65a3d347e1870838d162bc1badcfae7ed40dafdd309ec6b9cdf02b6c948841b8e2f60c478adc221687487a53b7ae09eeaae437ee791070b6ed345c138ff3a10b07800ccfefb86b30029161c8b41f5c8e71dfd937d7bdfb7d3e814ae9a74931e6691537497f7886b8f69ae24992f89dacee5a3049183199b69706c71a610900934f81887e6f0c9210715e7d61f9a49fb60b48f456e207fbcc45b22dcc89f6e20e46bddd1516299d071dbb6a7454dd1f662a04c3f4149a4624b535447d6371bbc7d4dc00ca7990a590e5f24a598e8481b312191f9f30884afe3dd5a68434daa5a1419e82334395a4db062a69430d30ea61b3e36440ae82289514f9389a6d5cb8404b3a0c035633e0c02c0be7a7f8bb5cd1708063adf2d43545aded1cfe201521189a6688bb297082fecf8984534bf12ac2ee610dcec56da397648a058de1607c2755df5d716cea574adb6ff86016a2bda773c5c7bdc3b3b66c1436a36787621a6572df15b1004f124adedb73b19e571eff539ce1c109ff36a6b4ecda16bc176a0496a3ef71c5e5a6b4acf4467e2a514108107e701274096f50fbefd9a57ad65f0ebbe0e0fb2764f835c57b0fc8164458d9be75b09d751ec664a594bd8079df790f72ae01d4e739c8b9281f07532a0907a891d23c0261d957a05183063c24269d0d9acd79ff0503e0b1d61ef6c97cda37dedd3b73fb5bd55ac700e0f21abfcab7f90ef33cf06ac20117f2d78eac6fed62a3f9c53eee917a4f176a6580d52b0965e8831c4a0968439693ce4154fb2046b7e479a061c04a0460ded62885de46a6adbdfc4f225f070edb7f0bebe7e6a7ad818b091e4ce0b93d843ae0bc947eb3e08b0eecf47bc60e0d3281af943c785915de3486af2dcc7db84e0f35131977a29c4bf3043754c3751de988ac00a46968fb6d70b91a346d8a5c497cf7696a718ff7b2df07249b934286c8ddcbd35d5a50198d2c6f75c76acd485d2edd0a567f5eeebd99c647153fe82318bf662f811a84bfa2be00549bec1b726995c652b2080d3ec36e13c8e87f392ccedf9af2e1bba84e3b8a9b92878686aae7a159d4a902f92b35aad64bcb1d2f7144a4384b68b54beb1c46a95f1cedbe8a870ff6bc2bd38b7142541ac7059af246907533f183a7d73c33984afb075bd315ef48705143b9a4d09f0b55083149d109364df56d9979ea48b34c3cc8358121d1038a4019df485faa0e7752fe3ed17a966dc855587f21a4333b7a2cd06cc3c6c910d2e578664bdbd6236a6b708006276ba897fe8275308b883195254fda909dc7310f2d7c054ce30307eb6d77f3a55331d59b43dbbd3253c1052e03e480323429bb5de437d1241e2010aea44b9422fbd0d7e3cfe44de53f0e9528d6591a71626d85a64ee01abf15b546423e87aa1796cd05bf83b3308ffc9b21a5a2011bd532983cd576a8e1a1b3074d108d24004281970b24494e4b4166f9b4691214a2eafde47d70055e3f3cf3fcaeef408f55b3efafa52559766637b67a8f39e01368f83cc0e8bff0689fb10a05023a3ac153c77b5b638a5fb7b93879d1060746d579e0fcd17e97ab570c16adce8c92c858beac71b0848cae167d74c04b82ecbec2bbf9224eb9dfd18c3d79e5d0286b0098f154b7076c40711687f42914acf35d4ff8360131d107e5a4f28a3f812a0664c21f9dac5651528cd2c466d131bf7ede15ad78ff28fb27863567550b65c1aeb052a9ac66ffcbb4f1921da48254b97b0bb03df02a52350015ad397c2be8c3441df8648220bff259d80dac2fb2a75b6b84137172fe1172fae483f41dfe223b69144a6ed31fc2fd476d8e2d89c3853989eba0f3702b58be69c3a100812d9c39557573c3d72c1df156ede2a71cb7dce774c7aa0d9ca93c63262b6186e568bb79aa3e44a9ebde0fb0ad525677f05cd5846f243998cec63f1062aa4a7b1cba52e0a0b33509b6d388a2a538d696637f8e3321a8053ea4844a19537b4ee4ee2f3fde73b908f34279647cb104a893dbedf80a9b14d73c87d1e4fe72160ab60ba7352b2546c9cdf7226332b89c64ef8677c6a35aabf208e85059c4e07f718fa451550756af150621f65cdd05b6cb4f0044b21f32b5ddb8fc83c8a45419b0bc31e42ae50492cc9652abfd15cb19a7782a101af91f89a2c366f15bd8420a1ef8a7b83682fa4b2e60180371e93ce77243df6ce726e5d878a723efbd6ee05982258116b3e0228f81c6bee7f7a594e5e3183b310797f00dd4d5ffdc27ecd26878fbfd950ea47e2b32c8e9edd3aab3e3821260e931b0a11ff91d3d9cca15337e67d5941665fd650fa4abd4cfb4086703025ca020b1a0d2881e7e4dc69f0fca13615f9aeffb42e16a8de71d319e719aef59a2d2046e1fb103daef7f054949fe7d2660b13e0619148b309cc6181a5fe08bb661240dc889aa38be3df0b84b18b4cc3259574f78e84b43ed000f4313b6a3506703fae33fc82ffa1fac6bd8ccaa0f396b9f2b3c8f10090e3c2ba556acf7ccb1a6bcaa7b27d85de7ecbdc9841e87550722d03e549ae0e797cc10b4840fd596025eb826d4871c2618e2dfeadb1c9acabb24a5422e6cad151cc092a27bfcd8f4dba1c237d0d043d3e0f9afd762da06b9152a2d3994c5a6e3e99deeb6e440d3b5bd091b8650efdf0e78f703a1f2857f9774601b7bf56d7969b470023b4e9832ed9580da1362d982459be27a821d92c46c3bf0464316b562280f5f55a1fb9080f075fe53eea5354f22c5cf7bf9655b792e8b1a7c91c23e656b44236a6bb6ffb625f43a8a63f2fad9ccfd2d1cf1c0b6f3a8fea1bdd75a2b39a5a8bcc314246dc736e86ebfe4096ac13a6d453bee70230b379752a86b19b0b7104f4ad5473d0d3aa4cffcce5634f9849500643ca037e3657dd3251dcdb0c304ddfbdaa0b26b4b53a0ed8f7863ef7e416aaab168558a9a74c9b1b65c75eb203803d9be93ebbd4bb207090d86d5a782a33c1e675165951b54b2e92b14b78aff80b079f6d4be09fc3e34c6a57ef56064e96b3b551c70404739e278bb6b2626b71300e0153eb98ad1125bf7f2f9958ac27264c5c2fa5ff9a3719a33d2d0d04b6f3bc5c4dbda9e39f0fbfaa90e86ed4a5a3e5f06d1a8fabad272cca59fbab39dcca092b4295dd12a0adacf959734923eb585c10dda947ebe5a5c04f71e4a2a66c7612c7a9cfbfe05cba7c6f6a90b9ceb94f96b4335af02ef9f417de4d1152d2f7cf2a42043d68312196c0331d1e694880a6b5a8e3d6dedccb532cc7d718213eba115d2a673e4ca8479f77e265e77e192d220c2555e5100b2f058d585151e2147708b0e94ed48f0659d754a67cc5d774f54ef41b5fb8bcd516e8e827a08e233c003d372d983fdc2aa8530024e96fdf359d568259d52c94236af5b24ad5b8cc11a71a413e4f20eef3187e42d3fb5fd65b3dd95bc9282b4b87a367d7549de7d9b173e5523b2c18abf7c4ff218df3abe59e4eb90882a7585fd310fd2e3ee94b06d18d5c7ea72355b250a461aa84bd7c24d3fb2f69a0da9430a5ba6db4a2443070396e447b6224b4c336a4937d135aed708f3c18137157bfc0806a45bc4a25704d088445d91ed98227cbec0ceb117d28ea3a7c037e7ac66b843658a6e28b52d0041f2a6c904c1e4e64e42060a83c1374181cd69237bd7c632b84bf1b1c356c6aa7ec5d309e1f550ea1df5a6601350261eb176326a066a4c31178075b59ce3af055594c76cc024ad0f9ccf25c77279d2e1cecae10950f4ebb759da0a749ded32175826435662d039a8b8d0015e496e6178ab947113160cd4c804bfd51dba6b09fb6d0ac157ab0644d2ed68ea750d77b9f7d251ccc1fb5f5d525e96879815ad28cd63c912bf6974831508a5470fbca0ca444a9ab27b99f29b34148d33e27d02bff3ee77fb6006c1b44e91de9b143519082e4f0f67bf7d7b276a6104277303402099ce43ceff7f26e054e45cb20952b02a4f310ff9f74e6cdbdaa3c249208e7494b8d656b9326af4941ad1f51052e7d0fa5939ca9d5f454eb0cda92d9f0b9beab388fa08bad18ca3f73c6f616ac6a3efb4b8a436c8433a279beddf931dca6fbe0825790211ae0a4c432e736947697f81c453010ac984baf1bdeb061ec19d8d62cfa18cec2e5f723196a0065cc3d68a185234486cc04d0f255b2acaba06ea12dd0fa23ebd9d6bca4c0203d43e1230d4c85de8788cf4cc1d4e8da1554506a5c49f646e980e69db6e79bae06e81022715ee9860374698c9cb344988ce7d4711dbf0699ff7824c5e5dabad9a82aea8e1577f9d414d9b56a4e1d5ed7569c3f495b1fd363fce68c5ed93dc334053054ffe8a21d532f9648d8a510aa75d5da58859fade0be072670a334a162cc91a0fc83051f83e82b94b1c302371dcdb02e7920681f2fce360675dd6a563e07a9dc0dcd0e295362f04e33e39c104183707723c3ca527b9c19432ac320a101f2d7ae838acbacb2f23f661eb9a24d20b723e9753616ce75195db8c6387123d29b7607f38a426c1cacfe543fec0f1990bfbcb32a358ce336c876f1c41aada9816df03597a436ca511e213e00ab5c090d417f19fa30da8bb23d9d97f76ed9db8a177bf377eeb43a2db59732b42451b647596f5967a00734bcc13410d81b655b71a47061516314d22b221ab1300414aacac3fc8eb29846b644cd7cf52fc0b3819c42aafc9cf87bc4f8727e4655e0e582698a12dd7452395bef63eef644ddb58cf426a2d0d4499d9a3eb48ea19ac390137ea3214a86f4eed6f2251f3691ce78e925d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
