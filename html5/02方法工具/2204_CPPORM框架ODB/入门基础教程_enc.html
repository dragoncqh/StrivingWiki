<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d5466c0fdda89126a1738db4330bef710cc0f10b62169ee4e2229a591998745cdb745423ad17aa26391b92cf238f6fe664ae1f3699fc89f1f37563766337607ed89c5592d7822f03e7ed196bab4e96423cc997dff1f9346f034a909693b189e9c236e6c246e4732b5c3f3209c40ccebc6cedbfb2cd7446c5ba81004c364b59509ea4f9cabc9ea981e013f54102c859d0f79e77d11df75a8c025df640ee09c56d1d2ee71fcc09f50b32d20cf0663ee02f082ad638974ea5d52ac4ff2380405167b6a0939acdeac67186ff7aa25941e5e9e14e51805dba302d8c6db9172fef7d1f0f016fc2e6a246c154a5ae4ccdebe71bfcba22005daf081e429a7e366f0cf94ca9aa2ec1bd53692712a3ac06e0795340a1548aea40671feb7d32d6f0b54473f82923c39394f0f2f9aeb629bbbe661805e2ac2e850a1ff8ecf469b76750d6d90cab87a89f8ef28057a3442385dc3caf057ffee10e8b41fbf631969f3203a2e257a0d18793cb96351fd06a10990de19e2c5353e76e57921e9446c2ddcbae8e477445abd70fbd25bc596bceca903c38e08d600765194c7a424346883a17719fafdb5f91a85f9a9f57655ac11c7635fbc50a6307f36b0377eadcd9927a4d337827a637cccac8a9e12f7d26a34fb831d0c8966e41a1b0a8c7287292ea98970a5cf5e4f51ccc99bf3c197c0112d29f953624b419c5b70eafaebd6ea3373222b89c504750f3df556d826867168ee9a77bf8fdc82777810e0e36b1f9a5ad1a5f5935376420db1a2f7f5f1527bfa084e9ce0a4173ef8366240d2faff452f1e457b9373a631bf08d6045f82d8661966ab21a4fe8c2031745f08bc66c4ddb5dea71f9a9633c3fdd367c845386faa881f8772aa200d1bb6275b9b424704d8d6143dd9890e4f97accee771e7b4d0339d329e84e42d148936fac3711623f3a626e9c4a3dd6c12c09207e3780f94e554807fdc43315ae823b5abe02089a41be7f6aa34d238cf0aaee51d0598126abd17a715c6cbe98746dd32ed3b88d8e7e69775faf1c2d59e959900c4290ed31a5d3767a9b20825ca92600c5a40a8dc78469ff9428e1f9fc2f4c978e52cc5579492d8494cffd2b16b461b2039b67eec41c3229931b26d6fe264cb9cdee48777483e24206d3e2046bfd20f48531af05a1a047b93488a8cff4c0838bc38338a5423d2cf6ce9385dde3102da14af2db939444134196921f1edbb3e85deb74ed6bc56f3e18a19ed0046f360fc7bc7307f0e8211dc95e00f6f7896118d9bb3589f9af2460347457e30dcef743a29b29b5a5e7fd2e82e9c8e168c08aee815ad43205941117dcb3e09e99c1c18cec4d2fcd7b51708bce3a15d216dc11900e111e31bd4049f43b21a2a678a45d465222974534e7e66ffeaf8ec9a63cb2b8776063514bb48d5e2b21359c7b8027597a624b4ca63e6ef76bd73508dd66b59d46a9aec617deb62709a04ed9f5acb825618d2d8f6a5cc3b6c19ecf0cfbaaec39b4cb97ebb7f3a3976a6d72d97938915d7e42af5d672f42941cdc42f681dae796ca3bbd8bf810ad4481dab33eb9993c9e6014cbff662ca38f648f9d8cb396e546e91dfaecb75537ad1ce4840308d1d5f237124a7cc221d2ee8be7c7a0a35fa2a4f6b46d4ec24a953fc45bf5174b8985043182480f4afc353810252c51bee2af48a99952bacebc9fbf03104d617d979872a590e05128ba587cb9b0c4229dea710f2e57a477144308c3569c399217338e6c8bab39b6ea86ae1228ebf50ce3094fa0e40f3eade7b44e7608acd3099023c56483d4d87f7ed45702aff5eaca0c06f9b96d4affb12884f054df469b5ec142ca4511b65458d8b76b79b25bbc919160038851846147832f6547ef77722e44bc2e9f44408180d48fea61a491527eaa4be8f2e71fe8e72cf32eef437e43452dee5d9c09d4a59d61f064ebd705265c9c3ecac56a3c70504ba4361a1ef56d6d5f80421c5c8585287e8b823d38668f20f80cca2beffadf701e74463637a877f965057eee64ea134d1c3ec71d0ed2ec68217160b237652bc6a50a7cbf97078880e60a6ed41f33c08216e95d2b7c1b411c03eee8e028df67c8265413139810f6161f15cc59c8987dff56dc4fb649b25d4de61ca13fca2ef753b93d1f1b9c2b8a97ddc94af95d547499f1c9d0429da74a1f1cb5c27cf8e34a5af0a85024c555d24f9798342cf7419406c1b0d5ac15ad4b9720e94da890f58054989569a092f32824caa21f830d8288d6bc2754dec1b113a521ce0222c8c50034c8e51c756a73ba9c028d55dcee391b45a2c215e2a7401ccd11c7d9df707315ea46dd04fde22e7e5ed68db3500f0425ae2324b1d9e4c5ac560fc6fbb27bc1ddb83847d4d0a6002a3dd8af7d279c032e0b6c6f371566210d3ca289d4bab345acb025c221d598821f9a390497bb76ad152902e868cecccc5328b5a96572af7022cf080d62710e3f4e9100f3983bd26dca5235f3d2e20fda2310b6f02eba7e0827240937ae6a77be091e179eb5c2a9e1639945fd24e2e993ec4de40560599b2516c746f946c4d3cab1906149f7cc61e2c88723dee5d7b7216a96bd4b093d4952953143f64772334dd463867e86e167a9ceeb205440ef4bc421788de9a6e7536a3e0dfc332cbd5888045509a0f86deb2017d7f4fbe08b07371e4fdb1dc0b3d733bb5ab1c99a83c974851a4699a886ea4917e281f186decb1376050ee1530ce5877e6b6ff94b43a7186fdd93657a058b652e365714626c81c776d685ae090344763d239e59c38cdc7f7662a2ea21590868c53fa0b31c934513482ce8ec16a608205e8e503aa0f9c70d94947e48768e93334f04e583df9682233568cce8632d5833f63d6d69db8a465b99a944e764994cbaa93221c71f1154ee55d7bbb4d111c469f2b7af4043da22e00a4dda5b44a45fb03fc287dd1baaf0033bdc7b8f54db4f18f0331dba54e336d04cd80a86b0cbe89c7c3dede3bb121aad99b53af8c54485a5cb1025a7262d743d3ec3abdd131916a6209318437b5e1467b7bd8aade46433181183366fd2e978d5b091884c07ef86cf1da957896d17dc06ca3219c26128b315fbeef5aa20799f7f388de75a1559f99deec569537cc0eacb169bb561d9ad2adc1c9298f18c745803415d290fa5ceb1408e589fc45431a2cbe74c264dfec5bbc165502db887806f7b4a6c926a7340266efeb1e647645df1c43c12718df4ff19a50129168b21637784dab44e4799e410cf17cdd5248441d9650d40ba7907e51296cf750540cf8ec3886fbd69d7e362c268b5cd11f1a1825bd12bcc24849696e9bd9cc4c6cd98bf7a37e9ef562b2d74ea4b1a806846f8d746179f9bbd0dbea75255d6493666d66b147cedd2d36d1af27e3530737a24ea4dae64659bf114dc49f1175e6af6a1d050fb8db652eb4ea53d0f641b743df05083417498cf2d50858b4e950bdc42905ac60ce94ef44fcd2ea66a351fa4e06ee9842b5e508ce7ac0ad7794572d0ed2168dbb5223e76ada577621ee910f3bfd7fd5c494b7a3c8b39f45c38f2dfc3c5c8416af6daee7743c36fe4d607e0915037c02ed153b55b49c66f00486f1ef6aa97ea33406760f9b2a31621789f2f293f7e1276002e912f675490a612cf177735e22273f718e78a6e45e6f830881c1e43d9de5d48926addd6c347e33239926cfd3a41133f231aa2c710c82aa54b9d60e6a7e3d0abcc5f60ffe769b87714a501b5b0d861adbd629c90eef79893ef88552ae4d0c8aeca496e6e6d3760f53ebed5480d14aab665a9f72a3a4f088b589312c23e64b8b47d971ae476ba2a483bb7382a8c042831013b7aa0b4b5314dda06cacc1c00dca96e8ba18666fe13b51b20f9c042a05804a9c70c4975c11ab377b0de31ace9c709b8f71a2b52dd104fbfb4e661256dda73fce1de6021d56b2de41a84132f6da2d48abfb99df1f59f11d9c3b44bfca11cb5c0240f90182128ac943bd232b510b017a91ff242b91ca7e6442d51cb1ec1a13c940935ac9520a20823b6db1716fd385f9cf32d9da5cfb0ae7ef9c356a0a3b8b5bda99500855e9358f08910bed9afb357ed4f4e36d21fbb0c85242111f61bb7796abd7ecb221bb1ad2d4a0d09b7846512c68465fdc33d063c6468ba3d7115e0465aff6c1b143d3056e1cb8d44dd81cee593cd91ee25087984a7ae2cb9567c17041508c77da62342f3986487eab97d8f74177f229ed726d50ba202324a6d886d5b07bff9fad67faeb68fc598c6e10edf14e088b93ee70143cf7d0536467a08253f69f36f9a6079bf7f979f76d3a109ce37f2fafc84ec8ff422a793b19110cef3aeb2cefa45583aa774650cb4754bec1db6a084fefcb0766445803a0cf23c00dd168131f1b37882734fc82a520a9b0edc7c56bd596870bc333652e87c615cb82fce5fc48906492ab88f4db511a6a7920f9b5e0ff93099187adacf7359f4ee49bb39fc9e63727720a799c7ae894219a772d4f7d315f5ffe533937e5f279908df73daa0e3b01dd7f499974936d21e27a7b75204604bbcbdf077d7b92e41980a84a0c023837cb4f992650d36f8950176ad6a9bbe505710173e034a45bff40c21fb3c335c3a841558781557a531f1baebea82684cafbc0107ba749939e77630c5e7d69547631dafce67532ea177040e824520106caa079bb596b29225805a494bc5065d4da11e3e780268aea45ec66510fe82dfb5f58e8509215d366da5ed144d0e31700c8fa6078221d484ce769ac97fbc94c6b45c90ce639ceccba118a785d31e0e85d24b5a6c29253ddefcec1e883a7adf3c1236e7378433c617549106a272205fdc8bd60ab19a9578fa2dc18722adc1c556f297ac649ec924963d556a331c3b33533a3bed97eca2a4f2307daefc37388c289efd573e826c427c73396771903c2bd88967bc7fc50384f509ae4b83f74df2e70ed7d9a7999c1ff27ce2ebc2bf8ddcafad87b4872fbe6514c269c2b5e862582decdbf6424756677809c2d2b29532df04efab986496fc49efadfcabd280beef3e8d48dc1d4ee1debcde16b2eeb3b957a4d202022f3190580e53521b8044aee19699a22ecf08259c0b94326cd2a513ac8924c71c2c7b6d25109f643a2b63471ce499b5afb34a3e734500afb57ae3cceeb795f3f8b3da7da68db1cbf2333bc3f24cd571f0e3554373f453e0b1adb8dc39f5cfc1b0f6a63c2e2f44d9a678175770ba33f39bb3f43484b59576735f58e7ed16f8d1b9d54861b3bce7e198414996815c33307ae176da741520a50a78825fbefdaefb851668b59b98ec77af83b55882300b169fdd37de7cd8dfc16f9741bc13b214035aefc7ffe6b0dc547ece86c5eb851757a2aea66481fa5c1a4126017284b9a90a99f5f0e9460d3eb23de04ee7dd7103e6ed0bb74d5435b422bfb99f8af8ae65f391cb4ce4b3dedb0f70e22d47d0cc723d27baaa36400e1fc5551587f82f500eeea5cfa1b2c8a06000b15f6f362c0eec966c4507d40e0e9d5e739321bd91d88b77ce45577335eaee1564838bb5a5f9a3702a0bc7d74f6768f51c16b0264f310ca017a69ea3b3683df11e2c76e08b3a3f9a1ed01a490729f4cd8f756e1d3c7590eccf1b374c099a27512e410fdea68220932d76fec2e3a713f1f055c5086616de6224519175f6eae0e468f4aa799c3f72c43fc98856be1024d7f3ad6cd7a2684e572825f5754d97fccd439ec1174056ea17aef0341e532133b93b5c613e5856fcd57679c071c1ae36940ca6104439a5172bcf0e678f8b50988e74c473983bbabb91132eba5ce1ec74d7059a3916aa5285b3a2f5338a99b51bbf094489991331ec603c07c28aeb980bbca643587bb4a7be231f684d5ce0e1691d6903e5f5c8405817fa4791ef6fd77a8f066f322d89cbd61c84218f5c420e8ea5d0259dbac1b72537e277ab8fb825fce0aa340a0bc8ef188d7f49d720073a2619f2001fdf0987dc949ad9d3f229a636668ae8fdc08d0a043414c03ba721d785defb91d5656371c6a6c895686aecca8416adbc14960d5b8f4fab83727510b0d244f3dedae9c6a86fac4462e70d780f0501ac93ce07fa49349539e06476b7f89f32b0240f1a789ef441d36bc17b827cda3acf11e3c56fe3e28668379fd7c65476a5c9fae1de55d08608017c914fa893c2c711f68f3b4865ff2a11a62c9e86260c396a5febab177cdde8c708d3dbcca559bcf2fd399964a71443fcf1d142eb8d27aea9d05e8e137a4435a291fc1cde6886261f8b8c391ef0bdb3d4e74108eb37de2522abde5bd8e9278e51b2ca6ab0c1cfda8f823ff47c4a1b146c21b687b2eeae774cf93160880461f53e5a4dad6ed2b8c593b743018453d80768c5bb31ffc45497b0641d5308076102cd0aed18fee895db398437981005f6e4f0bc768067562ad06b1d9d59510aa3672a9341f0b5c4ac70f1003c201e2538621f346e5da8ebf8805be0a5ab5b05f82f60952cc4d7e46640bda76c1f24d02eddf8d49d007a5eb2a55761f0f81c270bbbd5e7e19e4eb06851c7b035cd17b275c6cf860b14c6ed85dfc44bc5eb29e446176665516dfd8dc554d3dee150d166e81ab18c77daf96324e57408a5e0dd7d2846690b0384e922b0ac930f8a7970f28a394e34863d1f14694b20e83ec9f58419443bed4dcebd2e2efa2ae1836e09794aa60ab2d91bcd395ffae1eb2f9096d69d42eeaefa929ee56c26e11cd4d9d4ee2413e7a0d981eb86cd8822d7a376729d12e6e5f33ff0c004099c3df42b6b7693c73f79aff26c799a7d3e4c11a8779b0d016eb0603a5f54ab5182d9f3213aff7fcdac3375e62ae23ba781b5e46ec18fbf6c0a0daf41dd6384fcdd722ed4814a2192cc7e95c49e483102802a09622ba0aa62e96d0c22b61811bbc13008f2f9692315eeb29bbf1038457edfb0f64341039e02bf8089b04e57f5161e2ce7a5d8e99005e20e4e7809c2cc2f37f403d8732d8fc1cc78630c0f110fce11ca422889214ad2d52cb05f8181849224db042a3578e1c0a96a1b92564b71e91e28cf14dd243cea61a248db9e9c2d8e6fa45c7f94e506c54b0f94ab7177ec26ed650fcad0feeeba6c9fea0245147d4b28bb1912e356ce260a763aad7012f83e4d60ef7b510e718648a11952eafcb34637b6a67e939d6335008dcdb6a44b643375916675aad8fe99c707bfe036c1f674322aee0a2ad8950a9a7cf0d6f7f1d0af194ed4e7ca0425f94647bfa1af82f52448627740ed9b15dd8a88fe6bf00a75a34cc7962f087394eea00e5cadeb99a4fb33a92cf93689e3edb39c545eb75aa705926b271c80abc2394e7f68b671f2b13ca8e3acf28b18c0e8d36a94a02c59c28de131aa138b549abec745d22abcfa9a0f7c1d57c1182c15f30093a0c4401fddb88cf90122a80aabb5bb79a3da04f32a36c7c317e9fee6b0fc331072ecb3e39e240790dd7bb39dea6e7c5c1625f9fb5dd3073d25d7622570368cb3ed2199d28532b10106c503af05e925a7a423888a424176cb34d9fc9816717f8410f1daf81f5f75ed66ce737f499b882cad351426e5e8c3d7e83410f711894a3c5a78c78ee1d0e63d97645ccec679d5b7ae63f91c0ae6e7166843355c0d0bb4db84e7cc9ee2debf2b7bd1bb0ca13f6a1e1c683f24188b3452003ad361b498ed7ef06e6dd5059c2dad0aaf42b03408e12db1a0695f5630c839c01fc55784b03dc0e427148af6e6a77396c768aa624d8cf33ac37cb09bf7074aac57140be33f7ce5b3564b097dd51651279012f132dfb690449488ee3565aec61ebb088d2c806318e791bc1745fabc85155fe76718eb2329c952cc49cf0694ec80f2960b6aa56022def97b71429144205bc2899feacef1ff433f51e3eb05673f81d1316b7444946c53299b51c4e5c56fa97f3ec7d17e2f9f153db1133afb89cd73592125e4e74ef9a3a9a49ad1097927d03038043d89f25886d22b6d874a1653bc0499d6e69efe3d0602fdffc3ee5252f95953b479b7416c90e1b0243920c50d3c64c078594d6baa1e363c23ef900e58d06a1148bed7ddb9f012da3bf8f999eb559a4bb2f75699fda50204e409a431f9a8cb0329eda032b3c10407bcae1978da7662111dba3f024eaa27d048f660da01dc92e5e10172d1739509743190f6c5805904ce6e70d698b610dff9f39e085a76e26242d3360849a64a2088b21751b26a809129d69674770be6477596ceb0178cfed5ce37a046c2b305c7583121221e2a69dbe10721de71d3eec01ab7801658a4b84c6b45f7ed92754de661c9f4f5ba6831f4feab113ddfbe194c0de388d495c5d26a37e1f03f96cd14f3d1f0b3c504a5a58574cb8ebf8c9e20b28c3a57d4167ea83c25c1566fc9342fa4518c009f38a1d7e890131150220a47c15430455acd0c766311068992a2d9ef3bfb9918d606c4f53b67d5250b1705181499aa93931f0e3180f8cc5936bef07481c23fe5ca5d95c1e88e955009814a33cf84a41240f9fc3396a73bfc4dbb600262a1d5ac783af4ad8a8e264787b3d63eee949","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
