<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"efb5ad677aff18ce64a990d3dd1b7e211fae307cb61f49d81b99838bf23814d3c6e2825a2e8e53e0400ed10d100e25adfdf75835ff1aa586ba5ec52e7a9da21ed3b25d210a80ebcb918afa466e121a702e094fe66e0b821944650e79fb684d12ed34cca3f4559d0943d729c2b5035a010d0325b66ed7eb2e2068898f542e713235e4b4850e6f9a5d817b1f04b0ab60d7f59b0b8704739dca9f7575b527b23c588971d42e3b881fec93e9749a212b6292b9ebffcbaacb3ea2c4df99076996ac601db11504ba98288a8226b1621c4a61b36978c6e0a9966f833ccb2b6cc0ebb8abefb9c519be9eb4f57247f3df354524864b058327aec31fe7fa6c73a496e692c4dcfdcf39691703e9650bdffcd2563b35d77366a0d3e2fe5b0a9616a33700096b1dab397e1d68f6544790860dfc40545c295e6126ccd0563ab84e491c5cb64d1c27be3af898819d3ed060b62916e9e09fae6157047780e4d6f47f394da2d2b9341d339db7beceb1063758ad75e2c7cf7468bdabfe35f2cd104d6f41c466079cc79043bb0afd982eabfc0a8855fe9dfc037170dc134cc48030c35e804f125d900ac2f5d93a9ee9cecafd39e6ff92a3c7b11b658ce9e14506972fe087d05cf195771ef02b76c7639363d3f887e0f900c172ba1f13ac5f0bcef0ee2befccd67096fb1caf5340c27d9c8c9ad4df37f2f9b8dbf5bc0f51f59ae5c1f19f6255a07bc8ca14038e8a53fd8098717f9cf6a41801df68af58472e089512b2b14f7b97c6818ac3c0d5c451e0baf235a5f9082fca8f626505e516daa164ad51f7aee16549324252d01a23f7aa13717f5b3d18b9c2434b23aa181b41eee4c255c18ed1038eeb009bb4b13aa3f1d01a06912c25aa9e1e030dd31f25ed0c943894485399c1166df24acc3ecc1f512a5a958898577bf2ba8ca7eee7f93a81278a25c5b3367cac316f19217b43f06d5a8c70289a04542d07a7ab6a561dee50b75f3128e7f9a6f3cc2c593a7c678b5d3a85b16499097c36a9617f10be53fe19af86500d720a958eabeb40ce27e9aa9663f9fc33f46b97651bea4e201b30b68f65a5e374c04b378381ea24c1d0ad2d3f736f2688d24d998e81bf7127239c3a00efd75e34398534024e2dd0f88e8d2d39a753c72db6e2c1267eb94c992100c3a44c3445e13598c5f03e6b3f93c995478efaf37a4ab61b04a672f1e1500ab7494923ed9e866f16e8026fbb08b4158698f636302ad84af336fd324b0f9b63e6adb38327e201c5addcfb6ac8aa2223c13f30eb1d236dbd6245f9efc706e89a22e542fd37cfd847de4c327536d8a3c8631b7a031f26c7dfcd220ae572f409b51215eb664d64192be518b53b52b5a5e53e245fcb6fc112cdbb1b0e846bdb3ca456668fb6e61b44f390dc7f83553a067a13db5eba418ca7d262c424479308eecf7442f27e792c98372de5d6f85578531b1b93e0a47c8795a82ac867e8e2b20087c0b57c26ba06d823682a953da3d2d878733334da62f85049d0384c4d78d7a270ca6ac1a08f0bea17eb0f5c089b48f66e0f8139a1d5593627b85eb3e19037a2d09a58187777f09323367fa512c86d6e6f241227c2fd6ad459626c6fee289aeed368744bbfcf5a776f42873079669459d37f2d7a1894732823a83cd4d69d31c13d47e3ccdb30ddcf13830d0892e8bc0917effd17cec91fcca9f8568e3caf6441c933196da58e231b42bca75167606a99851f52d478df743d79f8c9ab8fa88dd77a6049ca95fae1f5655152777a7d0833cc4a0bf9f4f209eb4a15d37a54c7b1e6b5196cede5165adc461210a009bdcd80ec8f1d0a24a56722df360f9d63f844a56be0a7ec4e93080903d56ed6814c28a2ce9b189ad8ab32c06bb7228f7ec9a2787182024e4449521c552dd3cdc84a1f9ad8310c40d3246fa63df7bb5a328e7a04f6863c89241abab9041008c3dfbef5f9b02a1766aea3bf770513452a5cbd1d773ae2e4ec03f952a51d76368cf3288f8e54a598b94c8a42b65fa5339264642991efc2aab58fa6d9302d69074d209b4562eeb956c91a685d86da92a23ecfe50f31be409307b9f50208b17e4cfb5eb9d2e3fe6386af8b075dc7840bf8f16f97eca8bd43eb804ab333c61d1df009ad430d5f99c55ce6e440e2367fe39f66ecfef04f864841e41d974b2279d8959acf21f2a0f311cf6ec4bc91043d2c4e629fa7b34e5a54044b21b28fd18d1316d9ab38b251f02d9ac6a5accdeb4c66a70ef9dad19e9daf88f3ecb9d5063cff4dfa55831a6cd7b08a65c7e03b265d41639aa033800bcec3228854784b3c5d9e2c43eead7a599d79e1f2da6cc52ce80228284d18503fe9ee7a6f5da9c5f73ee843c2ef7930a56ea54c6ae31abff4625a412706ea679111617952ef6f05d7ccd3c956b4f9e07abac06294830306210b7942394a5e23b67b213e0aacd3535cbf9ce2e9ac5cc7ac60adf90cc09e0ccfa1b9d492d6d0892a9044b91f33069585f4f970efc19df0c9ad9ab4ebba56f16bceaaf93e4e70af21ad44451d02332138ff2eefe5a8318531490257ce659ab83155adca04003020922764f27100137c613ce528d73dcdc6e77304df741d53d98e3167a8ec49c9575c379b9bb4cf3d502b0d99f2d864efeae211b8a2bb155686d81ba7be1a14dc28170fed76e341b8f1628f116e1f767206b62bfdb7643c6413c6a87ffb060846b7ed1d2533d4bfbf43001fef2e056700bd2ba698cbbb507b61768f63d0c73c16c0a5074e6f01b67f183062ad5184b713174961e0604b0e49cf161286949bbe0dcb4cf384e01d1aead7cab80252e92dd5c6c21604081a42be988a74d28860cd9a0f36366ab6482e86f90d035e697c6a320c9d637add962005a6e2b014923cfbdf43e4cc4a890b1f2aabc2fe71c7ca4289aa117a8a2b1d73aef603e40c925bc279f88c40ad6b4f9c9dcdfc88cf8bd195c3b7ca839a16b620607f0d3bdad2524be4588012e67f93e0997153f1f603d144b9cb207c3087443e5917cf94090764016805e6e95b16901dc240667e9cfae68d5843820421aa1108750c4a9722f5304f30c1448d000220838821faa0dda8b600c3c2b6a43b5fa63015067e6bc51cb5423f3fe19d63c5039c798a531f4e368590147a791ff23b41117599581a3c218c32aa15e71f5ef27b6ce9ee09a48f0a8590e9538f9c3924a3499cf6fd5f2aac38e02e5586d49ffd39529c1249810a579bb315f8dabca455ae6382ee9127ef0bd6568a3badbe5b227d5efe7a663818d628a4882f77e83773f62937a5ca74ee7169790176ac3306705d7320ebd188cfe6e61786e1a3ca47ca04bce4adbee95a8770415744b3228054b5fcd37461710584e3b6b6662ca7574520d83fd23fe2828a28f949ea0f16b93f7e6d53bbeb0391f85f8f53cc7aa2ead7976d8ebc15ba549fa689d2f7747b243d2cf415c1b962dc36dbb6adc3f79bab6fa05accb14f1b6bfe721428bf901e4de1016e3a45d4177f27566253b12e37cfb7937a33561bf7b98e620bbf9137fce893df7acd92529ef5aea3df10bdf410b5b470e48399f65d2cbd0c62975dff2c9a810fe9e159a457a76f8bab34908341381a68f83029ccb34387a2d67c1fc77833fbd50cd990ae5bf379371c9ac20cb83bf02cd63c0d4baddf934cd2917feebacef4867002cb59208ab3baf1b28a18a80819e2ab08ff9721de5f06a13fe5c39875d33ab43da7391127c07cd81f8147201f13f2355e459b7359411b53b3358da469669ad300580d9f3d3f9c046a4462d9395b6bdb0b4a9ced52ac5c36da0b2818b0ccc483acfc3b3d6fc87795c05fd761b86f4a47f0330570d11dc9f83c7a8cc0444b80d65ddce87a522bfd0d4fc468b663de364017e54160cbc7c5d51f07e182b3d8eda07760c972c60323c9e1a6df1b7b3001b63eec5d35eb8a79b2e6f80fc8c5ff74b8f3afd3fb0414c1b8bdcbcd04abc19a50e58290921664a608c0b72a852ced6846a13b2b287b3022972b311dfc12ac07a87275c1ab3eb2116317154ad24cfd9596fd6365cbddbbe7e2119ced2cfdca48e5b967dd8c6a59234456b2ee572997e3b5b371000bc3e103d25a4c7ad2b809698c202bb00fadf2ed7ad0a26de61b4d013c7364bcf9df10fcef5e7a32a91b84b84c642427701b0e174d90106cadde727172b92964d0cdf96cb90bf2e70ba99295c307d2edc3a215dd75b4f5b4cdf10781a832bf9be906980ee9cd8371c9ec80d7d3c2517ff0c301252f9c295b0ebaa59db612d751c66fc80c0d2ccc629b7838d2976d61f491250c50c43d0cc4e5d069fc662b38f6f4a9a80d0e8b734a0c3da73f8cde4ef0f0cf4318d71bab44c927df441c188bbac56124548c32f691c695dddd2459bb14b932ce2c859923b63b3d66ea6084b2bfdea0ec001a7444b43e519fba184052b64a69ea98b076605f4bbcb664be5a0845c441632ac8fa52dd8ded45ebf1a21bbab69851d3ccab295cda4ad37594e3c922d96cfcf361762e34451819fc6fcf62d8e715c9380d4942b9d91ebcc5f8b86cfc4d7f1b34e760ceb8c93fd138d52e83cf06685e3b54fde9890ce23018d1c250ccf42a8fe54718ca284b6eddaacb69f801c8e1d86485513ab8b8bb50e509349b8e7872aeda6db82cfdfc61689d64d753307cef8389bbfe462b01ebb91377492c65053f21b133e685a385930d7f4a2d637ae172d4d76a8ad1edaca48362464b13f522237d636b1ab3b0fe7148f19024102205c4c0a1802af300f398dc3a4d1cedb0cf710145acce5e0dff8bdbe9bcb35d6203467aebf7779f098c85d7ed694acba2266d735da8a710bd228f3dc2222a5c89c646702c6dd36aa9154a0b02571cfe99185f7c5db401452fc742126b3416a00267fc15a00c117b12382183abb2d8cebda2319872eaed7a729869e49280d724ef9bc19a348c088051eb93f050f502a56c3d38431ba4ce5276a5bb30dc721dec0b7d6994b73b59b064e7367216dcb9c5a86866bcfc18d35d7078673d80b332017de8713256d31227cf1b29a459a5ae89e40269dc98c5763d2ebc51c0922f1fe3fe22b5b9c6f0ff194bd76c333111f88ebfceeddc8e85208dd2b81c8b2c1061727661711f168588343a8c1b3f84bf9228cd1d19348691f3cf9809a31d403c1441c5544396ab4ee68316a7f6392c487f56e9b0a27fc3638bf0b373b34cc6d223441111ef44bb15952d93019063289d7e23ab70adede9b032aa2721005fb4862f84df12e639a240f1886942281a68b0c0ff2edc06139458e73d01280bb1345b67e9d3d32fc9df158c187604deb132c75845aec98e2694e397fba18f6633d05322b1b2f2cb215f48737e7eb8dc457ae71b735eefabe55f64737fff62f5df4db716cda05521501ba07c8bb1fdbe4387aeb581b431ca18770aa4c9fa959a43b479ed96dbf6168e17e20133b79f757d1c18eafd7fcb27475a2bd845e4f9a221baafa48069169ecf9a6676f6c8cb27057ecc7e1e1fde18eb34815a84547a04fcd350ab50332f36c342fe35c8270e4aecc4a4f63d43d28fe668c7454462a337d8af57927e49bf704d00a18827f676e10575c7ea287e4b20925e9e6106680b818eb0e9b94abc6867ee2a79b971b290f321b7d2b0303c79a95bbd81bf092113f39358ea2a1b7249d2b2ae4a3ce37bd84d2dc8e05e29c3e9cc5e561b3deaf70b1bbe5a514dc3423aaa75947b64f6b9dba2d4257ce990a1b3cf119ec4233faae5b63f93824a28dc76f59f44228cca00ec0520c9f294a261ae051c96133d04ea8b7f2e5eabebb0062dc578593e104a11f211aac5cc38ece18fd09434e23a3e9ff9d671b569596b989fa76499eea98e7818f49b61c20308670667c4059b1a3932e9114c98da5dbc05263d593d69685020abecbc32321d3a71f63ff378af3812501aa389754b6daf90d7b1477e341930b2a5ca36540836284fbb2f5f8662f00bae1b459650e9d5494ce0808f2f345b90d55df0634c9c315d72a95bbd8923c82015efcf135c25b924e60032b09ae0749263e34ec921cc79e3e0fd8b5c57cc8e24f996871d1dbca8aa83e7596834459843e5acf5530e8b83f7dc444cd0c54d22c657ac86c65b915c3303ab465d56dcc75e65fc3760ce7dffe23b075a47a406d5d27f54f14ffeaa5354cb4977cd0da5375da5f43c3186aee6e4d9da186845f70ffb309b2a8175b55af052ee154ab080f5c554259c09b5ac851491b5a2b6774bcdd4467dd840e5e51a89db9830f3741c95d9e728c11ff6bb0112f3fa5119705c013460e3267d4704465675b25d52c7e2f49f0ba2feed676611a6e344e1aaf5a1060e0607517f9d7c126930d0daef775de459c88b57bdfd58717a3d3cdb7187b2b0ebc9df9a0cb084d154f9dcc71a0b359d0b8166267cfd2e5dcfaa276c6d7e4f422ebfb1e888f2948e46b02f624ab5cd6d70fe7096225bcbc2afa64e99eb343ee5af8af40e5f16d991314a34551b30c0543e7348834a3b42473036988252a977970de9925d0a1d365395fe65ca3275ab53e83c3047d64fcea992e4dc32255a136ac03bdad3eae155e949bf2b4bcf766611334bc1c55aa400154477c8f3f4d62d2bb91fa294c8e93500530aebb918db5ebfa1db2b0b37af192c06283ad01c5dc674d1eb22e5a5553e04646aba5f8792843ed1b29185b898b9d23da6cd4d40a3a6a0182c5f9179c52179b2c1e700fa1f330f3bb1a0491d92055bec7a738fc37535a0b5de55906225627de33695ad674c4114417192509e50747d63b18cccbd5c41d8294a451f06ed3c3d4be89ca07d0a8ac6e6de1ab05f1357dc3d7ef3ec49b68e84f0af398adae56e5052b97a6584a05569bdf3fae1b51840ad142011bd0a51282828bd1af9ec41f7eb292e6870ca5f8ebb54ced0d1209e0290a9d1a73cfc5a1225f2512b1b7eef859ecdd84af16c83b492bbe87b68902ce3bde596cc2d7d3abd61427650e6534c8117868ac247be7e96f257ceb1f118be7e6105e0f38e9002ab937fc0e20d4a41dab48072174d3770bf4257c304d473f9b855b371cba73b401b02a4fa88ebe21744d93e2b6bc9b30a67d0a55a88726337eddf2956fa8c518fff1d64b7310bd6c2d6b68f592175b1a7ef4013a42a703da2a2a1f9dd43d8a81b5f35f7ae83f4408e2bbd867ceaca8adc971d89d14c70fad7a265fe956b6212dbd3d1b2c6f5cde7da4987f2e86ad861a7e514a4113131265195c116e52a3dca451395a46ce3fdddb000dc0b41ce784a183301909a921feec100766b4a7a2ddb575f89e3de4ac4f0f2bb31a695a37b8510a983bf4dffdcbfd79f35cea30db850c0804fa07e43f2b267fb67e718a54299bdfa1eaa49dd1519051219afc173e800afb562f0da3af52727fc5c8bc805bc1bc863afc67cb7d755e0c0775b41bcfda9456b25b9dec7f28f0994a0065b829579ea3236587ce6d9aea50a978409bf4309ce19e34a5a6fa4894738cd5898d4111abb6d1c5250d93aad3a3ec76655d55eef021c559ad1920229f1a0a580b93b9829a438e2ac3a27d7ec9806c3f1635098f8e67838c426191c5070480e8e856a1849b7e7224040dadcc69356e6f4ec1c7b967c1ee1d2d728f5f58da3bc3b08abfd03991eab0a75ab4fa0f3beafe70a920dcbf03305cf22b9dacee2c24ae2400b3c222b1d64304d0b0cbd9f21c8ed2ea5d2b1f55c517b8fad71ef8532a9925bafd292a842fbaaeed789310ba5465bca8cc293b291df16a782c72a50e09ea3ab4665aa6948468b847a55cec8190c2240cf7d2ad64ddc9a42780b64a6e087bbc5eade517b0a1c852877a57dafcd6ad6004149e3f0890bbff2f39b6f0c70a04164b7f2fd4cc0f1701424b62a3d3da8b8c3202dfc2a9a355bc8fb54fcd9e56ea5d2e678d7e16059338befb90a2e9b35b19874373fd24599f99087b9f800937f90e239fbf1b3ade54ceefcb09492c1aecec119b8c8577a7ca3bc421a7e7544ed18d72ec7df991694934b38c3372054603143d78cede3b5e2527977c73c7773a3a4eab5d6f3b9767a85d2ff0a608e14d5b188e2803d6b196dd09b7cffef79696a967612a6923807007c8744ba022469f5c8302e90592ee544d65eddf6e4ff3724fbef4e19a49690b7bdf0f54beb74479a290cfd9907908273a000a120aa5283c973ab4a0c6be6409b50f37fbea1e64d8f6ddcb4a7165ee9c8d92baf9e93ca745bbed6bd37381c4b7bca25bb0092ac941b3447d38fac0a6564b8df3983b28a5cb66e992152f912912e668f549ff83378adb1e2efe1493537fb5714070f519b9548b9563ac6710db29afcc6b0354e04949e23475fdba9920dc1d3edeaca7214246fb3c83f006b31a5cc8ee06a0263b4723a7f62f5947e126d1acd13b03e3af9ae0eb047e2c54b6ca4a6bfa702865139398fbfc741dc186148ca7e5779de282c985db72f64da514bfcaad073f21896f6fd1b25377358e4fbf6c988b04d9ffdd7f7668b9fd422d49ec26ae653bdf02c86bdc00fbd6da7b6a767cff7157bd5885016b8ad3dece4bd9660a9230ca9d9f44fa3f16002e0b49ce8f1f8c09bf60142bb8596a1cfac7605f9a3b4ce46f26b963d81a0bee70ac716736ea8adcd95918a4cb7d6be03da5e0f25c4dbf8d5c959d5ec890c3c98918d1486441471ce3e0bca125e146a3b95b4fd72b01f527c584585a11ea1aeb7bc346c296c4523c50abebb2a7ed6cc8f04cc354c7218c783a4d5c20cf6616359cd1048c472d4c1eee88108affd9b402002da2a2082df09ed934c5f135588f6a0a6422d887b765a3104a1bdfecc148226914b419bc2f7519e5eedead477cf10d659c3abd5d9a3419ad24d843609d840935aab54243e64ad487f041c3f4ebb9ae77b62638413a3890cd30542225e95b9e6c35de2a30f37fdbee094d0dbc7f0b1ceb931e15645679b6e61e4aefa1b7980a3fe2e53720b3d7eadd805d2482674bb4eec8b28fa83b37ea7d518b4348ac3a5ebce1369552c88781019199d03fa756272f37647c32e717832f1a94204be6397fc7cb8c186b10f693728e8f190120ac75bebe2f672664e1d257bf496261c3b0a66c18c7fbac3e50c60f146c66214192790c9c97612bcc244322c71c4acbf43815b756cd320792699d130da43508e35616f516fba239b4ab87c88bd8917323bc5cc4e66550bb06d025905f0714d8f11f9952b68f7c1231c17e786e8eae7ff7367b77c03c804422b8f0f9107b9d2b40f677a70f1d27610e891612bf9f892e1bf71ea548e400bce72e2d29018e2fd6cb04ccc8afe6e8e97583d4eafba9cce63ae3c8b6d5d8688a73a15ad400087197a615cee2d671b9273a0c067aa1f6c6b98ea789ccc2c1db478acb3423c959f35effa8d0d5f6e1cf820697ec3438574b2141e0aef89304fd2dc341ac062734afb898954bb705882567875a0d94764953edd49348c3e1e9bf260213e6900e0cd513bbbe77ac11ad118d58d40f44204c1ee5ba399d4c07a2bd9ae25f37d6c7fcce266c00149b2136c96ae78ca5976d2456af158cf8a9d46c218c4bae5b6ff2ef0d16d018efe4376fdfd65f27f84e2898f3f9c9b60c2ba65c23c74d0e40aab6c7217d3d4db7156d99df36a6e373143c834a76f73d649ed3bc62ca84cdb00b1a7f5bf7282f58efb243a5aa8dafd298c617ca91ec72e6d19389d8f014dee2585cfcd338d73665b0e2fb57074b59d839a19d49a8ab12c2532a618f195ef1c64300c7ddff09e7b27d80829899d05253fddc858ba6319932159a28c81ccb94f431bca8336833a3e922201a14127665547cffb53881f976e25fefcc3dde2d419bfe3bb32b725e3ab902e1fec21eca8eb35e74b855c9395758757fdb09b4a4305976d1fb98b927818671ae4aa30fc521a6d3da9eb3424e17d634e77a549c9a497d889c1d23ef49beb5498362661c7b0f38dda667b9c5893cadd1ec1226e44c3865e54d0a36a8e2b842f70ce443ad9b27a53368ff5d40b29816cd799619b95a9e03bfffebe2edbb3268c6fb268fdcb081792a0bf9a6fcc3fb7f2217e4b1f2ee8ab99a21fe2e2a331b4132718b382ba023d96a43f121a98686cd3ae72d5098fe9f57a0474584e7656290e2de7d326bb2e84da4558c0af592381a7a61845dac8706275d7f9a5b038d135869d8918a4bae400d08528829c989c6c562913b02f828ec8a277ea08a3497d10f4a8d49b5393cb2a7cf3af69028392dcff16607ce2812ae6ccee197dc22752f6f547b658b5ebdaf0faea585a26a7b4688299b9419708f83d12cfc5f711ffccfa06d19df720553a65ad220ce0f2d3a6b43e88467da5d9b1bc075c3a1ca60813adaa748e247ee721dc2582ef68616f2aa052482be411c1d8c7cf4352381d49c9a9bbf6898403cce87d1c1770503812ffb009e3f08a84302f30971d5876699c282f03d89bc6e26deb87f21b9e74a91f25b7458b23cd3bd6a9ffbd7d65a019d2bf3832041d839bcc097f01f7da82cc56f9e526e3d255eeb8d15bd068688d4355a7ae99d6a788e3510eb50114af1b1cab903c96af31fd645bf1ff9b95bb3720d6393ddb6012ea18b72f4d3e8707b18ae0f3eece8b1749bb76f6efb65fba741a0da2d204ed814f34f034a7d4881007908a73bc6f2635a9eb10b0b4c0a250caa162abfb6c8efdc35e51e96fbe5409f5cf112f91a9f1df1f06d36d978e289871259d6a47bc5cc1fea49b2c081829506c82afe83ea4e91af63b9960ac6d27b33198e6e2b5722151e1586ecdca28663111309fd3d75dea99a1d1945656c902d8c9e58472c48b7e7e472032797180f6704f9b57dc640ab51aa450fd3d71d7ed8cbeb087f348b3cff897d71bf8b6cd3656f965be798f430e51a10f6cee25ecca44e8224b6f8c246d0c19d949fa60cd176f2140071bc2ef098731544bbf707a6c97e7068b3da5ce533e449377ac160ee6a19745dd3b3b8d064b78eb1f28f18a9b74261a68d93f11e90a86a60ae3c175f6230345f70ab2bcd3e93322a8d316f4be53e4e38061b494d3f5e7773a0630a9c3c57b6e767a65508ede370654780506087e5b1e78e09b5e5d651fc6490934b8c74d12ddb8986ab3c65fb710d90ed55e63a7e3e71d91585b76ec0f74eac23f3d7cd9c16f5d35b8baece09c77197276d9187a15b7560e403d75e7a8433c7dd6ea90a9955636e700aa98a77002b5da5f659a46e0e19bb92fcea9704b164793d691cf2c6cfebc662785efacb9762ceac3b1f505b30bf08991f76866f03ba09877a52376504b53853377f11d9972cfd3b21b3d137e933f37b70b5a6bf7ed5723f2df676b958230c9b40ee708666d195e18721d4bb95c5c0fd1e3df77585f11f0a1d50024368e56e83cbcdbbad3ba56d7c663f007854802f659ed6b4022f7980c14cd5c39350c186b28b399cc6ff51c41179eb583c93fcacc2f4e1339316fdbb0715c2b7d27d7a95f02b02eb1d8e2846f262b337879ed633e5a726126ea66294f99e3f7c299bfde9160c6531f89cf05db525c81fb83e7d0f822de919de4da8b533fa99bfdb4d05348c363481a5dbe61a9d7586ff9483eaf5dfacb59658f4192f0016e5a90532a484410bfe1b66f27c29a2c859e0d45bc92fc65c05c572bf6b2761bd23abedd9fac1f2cbf6bb325b3b70a2b72ba41297430289630ae4d399743b0600a687c59e18b9cf29c549bea92f31e249dead61e765c3ebebb04024c05f19c2f793ff91893dafdedb02c15c2b2c84acc22f717cc380a7311a719d661a8c269216c6fa6c7e35768384b5b05f5beea3619891b9faf8252081e76deade377c4f48829dd75269e77978ff11c08dc8f268324f6ffe13a2667ed03be596cfe2ac4dad5d20e7bce910102e02f9f958d4dca808b220ea2c6c41a87679309d07c2399514a9300183f00faa47c636de2b468f4c43f114e3db612568036bf015aae490f1247a5ea1ab7d6027c16ea810554228f3c7c1f6d5606e9f9e48b7d5265c41161ef9cbdfacdd2f23739714fa1386d84a862c7c5bcc90eefb30a3183653eb5a61cb502a1f2994344d4f5bb9550dcb2b8999a8c7953718d897209352ccbefafb2cf5e69ade0870e8b3a90ed0ad5130452ed23f5fb818c6af74e3a621ee64c857992465a1257521a4b3a1b6bb577dcd618ad3a4c89b865bf417441d1c0367cc48f670d38cdf625d5e27a6bd964ad56fa54d7f5726d841d3d4c39316a7476f2d14c2c965ff98b9617b9ae2129d6e03dbddf687ad3fcb5b9f9b2deeec138e71e5852f91bbbfd2ea5cb7107a296bea89e24c1c37b82f3eb6f348dafc10c615bdfe85eb3d2a44362ce040bbaae146bbe9164126c6c8b1b23ce035d64e560106e89c4791c675a30224499702aa14056dcbd422c3eaff65b83d81c4278effaaec216c2025c393f6f46195dcd00cc3b74cac1ceddb407bbffa22b8c968596047ce0066b1a64e93e6265dfbc31d505552c24ee998c2bfb8a0f0d3ae2f493097bcf266c7537781091753de114f86ad1b35bf3c15ff03c6de2f00127cfccecf1da779a792a248ebb3a173170b3de4e360f2ff6d0e25bebaffccb44b0ea15521a9e8e5bc84f7db68abb4482dac73d653a0635d29561934bc67f1860b3823d3f2397c9e2df46f692ff443a4451ff5147f5231d143b8f842d3964b07088f2e612459beb33c57cd8f784907170389466770c8a9cb677156213d85cbfed8214efd90ac4166dde4b5a8d74c6844add24fe34cf09e8fac921704d4f7327d7006e55a9d328ef1f2a447772df936fb0e177aa15f8add06b023f95a8f00b494a30c76459e393e94ed933b00f6cf5dee62c73fe514336925b027bfc48b8c0fa3fca38f5ef86eb450b014ce80936636adb4eb903a3b73088eaa6c33c00d1e48465ea3320123b0dc408f7101a4f6d1ffda53005ddbd676c7d00514aba61a41a66397dc198dedd1bbed8ce1931e0aee068883cea48ca33ba43b3eb30f39ca62efdea0f4b116710f4724a48992cf446a5e88305db4833c3d5282c2abfe16525a6043b81b49602cc672cc4f6447d6374cb2416e237b353827a4764ca40c1a9629ad679a47bf390c25dcf501a2d654577cfb68c6fc37922a7f5407a6ac1a1e06a153e65c613e88f0979d4b973ffeb92363b55e717dc45d26c878e647ade1f345454e7cedbd8be3891ae3ae3f37845748b50a8b45227ed434af1634cc1512b9da1efe7d3bff60300bdc19dc18e1721d36e36cb7cc8395b032e5be2ddd23aefb73f134bdb932f6ed37fef8ada103720b061c19c68e5de416a329a24b0d62c097710e4549332b12a823332c39269a63151b3e650ff2104adc83551fe76f847e2fd173e8ab03370c8a0adae68572f120a38f987a0ac9d96549dde4b430705ab78aab7e9e9124b632681b1c83d7d120024fd30e12dd99d646c9608392a189a9a98420910a6da819efa08eeb18d9cc6bb4da35f98732f2d49fe1c5e171f70b0770d2f845150bb3d2c4271c7847cfaa321d50ff17c9eb96874a263127258f8575a2de5057e0ec070eca00e206c6c7e2091475ad828389f2c0c579ea40916ec517435a5ab59915479a2f8482eb93731cf47423b32200fadd3e3a85f7d781e75ebd011684d41b33bd155be5bc090795a459a3fdd34","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
