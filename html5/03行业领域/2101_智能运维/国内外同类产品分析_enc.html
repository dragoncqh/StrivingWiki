<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a29f4d872e48c844d136d1f0b850c697fd4c0e84dcdf0b56af37525b33f9cacb92277506c186c2ed24f3419a158350dd370f85ac2f4c5f4a5ffd4c8e22f9188c6ff646b5e9cea1a7fe2c605a556fab7aebd47cdd66ff6912558815245ad2510228007f9ade6adf01429cd0379ad0a81ac7656fd78e198bd3ef6a8083eba7f39df6706ff57508b06abcd2c809ce900ec70e3300640773f9a4bbe8c1e639bbb3edfe288071f69c943a86042142c18226c3827d16efb71173b611952cd7bf496ad7970e95ecdf2a02db470bce4e41ffd223ee96c417326888eb5a4bb2e4146e1baf731f425a896c77929ef7a6b3faab6c0764a7b7d714ca1a28fd625fd9200f5cc8febf176680b8e1e95e0508b3ae5f7db465e3a84bc8742cf45d9988e46072e50acda9c6afb8b5eb32521bf5d7fd291baefa12999af5bad49a3d0959d17dc29939c70911e90138c15f03bd2f596e5991b63b659eb6e201fb9b275df69e365f9ad311a3d6e8c2680c2abd38060f3af93923d7870ce94c62facbc465dfd83f44fec47ff31f04bcc9bcad407299bc97e98a8137026609fd342c9be12323119d26bb16d2389e0f7700b66833d1fb5a1a49f3f05e93bfdc53246d35be01552de0b67da5b9965e37c6c769ced55b2ba2440b76d794fb5a19d35d3cfeb505f494b07f3bd884d47706da0a110a8da34802da402b88e8912adb8490246b5600bbfdb8f6e2eea8e0304670b84a400bcd21b28122589e135b4af2bad62b6d52d3866f7580871243812eed23a14491828c38f873ef070a9146da61cbdb09beb4f44d4bc273371d344a7003dfefad70612bdfdc2ba11c33624b614f05a2efb54ee57d3fa956d8297db5f44de8235419daf80258f351c60ca23265c46961154800711e45516b045230f5be601651538d2a63d55cda58863bf0bd3aa6077b2ee7830d557a44e62df823a60df0775673c64d3b800b087cc5eece6d20cf243d5b990fa37b0bf3d7ff701283c2a3fdd87134970bd811eed066d208848a6208bd70eb40f77d9f1de93853f841c8c6ba1845b110113cd1fd596d349ac46769fcc3bf32513e0585a1a2e24b8880fdddb9ceaff6e365d8e094cae1fe476df163ffec454be300387b02daf35d78f91ee6b415fe4430ffe9d356053aceacfb2ddad35d373d45a0cbf63b61c98c38e9d7206976b018ede472c5bbddc602ae3f0cdbf816e6758c93c210747c19339b2b30a471e507adc1a95bf179ff8bd57a0d79877ae6fa9b34d819aa63db2c118a8924ff315c21ec95decf30ecaa54143663aee9e9a5a03098a22a95f683579af90965fa7fef59b4d56eea0f296e86e2b8964b2efa1adf82305d9f97504f2f25d8f85f5cd6ed42263aef2690a6a0d19a621ebff6790d5b5f154860cec1927faf952a8621a7a343ebd2f84f1c77084408327b6a6e69c9e828638914cd17678f01235899ca3ce1456805d4ac6a92d3cf93a31ec5e2111afa4fd88cc91fe907155e0b618734ed9231c7ccb92fb4f6aae4e4cfe4c5e04cf03d65626c88ba2d505e19276fe2edf9792a67aaf3aa5dfdf5410d24d31b1680f62291ca7d079ed1626f86e41cfc57663f11edf4f3bd9e6336f5cf8d7db2cbc7a303622bb6bd4bb38b17b5cf3de709d30037883268419c9b94b68a30aed544ac4ec2f174412fb7197c3d788897d8fe30ac6b2c90cc2863f6a17f393ec2ef7ec6972d7f9ac4ec0a35c75b07f00bf0d8c5ba337de8f0fde40cf77561b542d2a365e3b619dd5c3f763f38b376385225c570ab8653a9b2c5e1b620a0992e213f9d61a04f7a42d142dade577ecc521a744d038a588e32f0220b4b47b2276852de25e0750a4ea90f89308c4a9fab92f54b2423b2aa651b42b1eb4ff30abecccab18b73bd7161d2af1db99a14d673b0f219582b49afb6ce1ce02de1577723ce29898d673c3d363353b17a57020b53efda8c526af00faac148695069e2494ecbcd844966213f89180302e5da30556a1171b27034a30929928c16a6e2572f0897bfbcdfbf86bb26a7032a5074b3a1101fd4920dd9d8cc2f7423a8cfbf4045d04879984033bb3c056b5e7e73bd7b34af478411eac4c835b51a327a3b65feea4183b22452910f29fed984b8f59b1a2088ab484d9c5e17ca54d3dff1163df6437ee65d9f37bc4df308c2290d534934b35e80572958f463e8f9c561fdd22d0115626ea7ba8f7131c2c0650cfef1aba24ef8d431506e2f7493f5af96d03d180fc71c5df06fe179d794872559aa6979c89a5cd9b42b2a918b7d7c7e2ff6e595812b95a7597716065d5168e2af8fd536d2513f8e45ba2f31372f026ff62e0bce74474d2e221338944f3f8425b8f93ad4b820e8f5259aa47365d3c7f2e6581ef1f0ae84e48baae9ae9a3dd43aed380ec03ebb015aa0ff8635ccc285f08d7c31e72548ade70b1301f66e545836a984c57911c77b71021211de1f1bd05ac8f78695c7241d5aeed4a24bb80b8ded53f09bbaefd23379bd7c07d9840d42f1c34fe872a42436f636afb0bf224854a3c70aba7f2d7417456331e4c06ec45c456c3f0adea07d49aa43c027004f121755288998d0de6492cf757ce7411f0ed81f659c3f3e638cdcb469d70836a162d02adf717d04ecc487d205544976a0294623249384e27e43c094aa6f020820737fbf47564231cb66da8126c74a429ddb97bf66437455c15ff14e023ef13f67bf50eef27dd2f1530ead4dc8a62d85a13f789d7f1ac920bdf6eb5036b7cfadd22abf2136b38909af4720d141c27b23473d22a934f1100a7845d9916c93fa643cc95c648d6637b34cc232ac0f69deec9760f49d6f3d09469a783686cdee0a2b3d5f2701de4091c511fbf0d49523e133144fe6fa82c14af2b60e1f17c9fe81bfee6f0d6337ceb962826a83caeb8a0bfc6274f849ead5a03e43395afdb346f6cf0b5089c14fc5f1c283534bcd0e4a389a6d5d1a6256d5ca0bcaf24d7849017e8be9e4ff9f6cc47ea9bb58d488b02627d811320b12d4092981876741569036ec133ab079254ff8493f955b6725b929b90d67dfb9ea371c33c47b2b8a8f9d2cb72ebfebcfc6c148e15eb899ea1aa75d2937ce6c13700f1ef8817ff56fb123a2e05426e79c0836495d8d7f377d172f9c1e9014b603a445a7d1fab259f1808de0cb4d0e03d1f4ced1879123eae31dace18356dd1011ebd35153e6f328b7145bbfe271060723d277324cbafe30786ef8d23fc30051aab11c05097ada404292e13ecc7ddde5e98c2c18cadf912853eb04d339b95ea74f33574f656b1e6e548227c997262631df9ebd77deaaf74007ae68c42c8c96aac4d3ec9e8303d4078a9177efcb0299d250fd154320c499c19839bba47e2ded8c45aa686f05f84b51110a12cc244974bb2c2c4a56b22487c7382eb837536ed18eda751e5eaaaf086b2cc80dab7f2a45416718e30e415d467ccfea26629396b264983ec3fbff3008e1c7b7a9b64cb36590020c850f626195c13a4a17e1841a7fac4340fe89250d5c6f653ab78e52294f146349d9475ade58eb22aaa6c948e9a57ba74021c9ccc7702799deac97ce56b191f12a6110302d398b8af626c6f7343cdc05b915582d8e5eaab61fd304025bb2066b79712893df4799b739d950659c0ad4296d83b661fe481882a5af6cd3b95f6f2f778fbf125ddb363ca48389b90fafb6ae2daab2d01e99c0f3b6dfe8d8c5cb23ba2110c6c4ab47677f2dae54a23697acf8790dab7bcdbb5835c9ad409736c311cf3d7ec60bf33ab8cfddc5fb978d2fd7cbdbbff6e4caff031f093f3c1378376d7fd3635aadace2564d8b8131ed48adbf39a1382f28c4268f858581d135ff4b02601cee662c31ce67aa951b06ffb2c7927b62ad45a9c224ee86e80e1ea97f3a4bdf9e52384ae5d2c01c1a1eea94c04e2b0e156b6289f53839652997b6cf23dc3751881cb140aaa53668ba60524bbab1227464c9ed1f0a4fe674c47624ef7df7a13894dd15bb8892a0cada32e774331195aa0c9a3a50a65577f6ee138205e2d39bea4a84ad869594d32d2caa347283b231d26a57e3a3593669b89a06df074acc46ae65f9864ebbf679f6fa86299be28734d19ac149b4cccffbbe1d3eb0c1468d5f43350dd953db3d53ff0854c1d05cd441d908463e229be02f91bc5eefe2b8fdf15399e033be73186bf66214bc7c024eb9d5881a4aefd13c82b8fed3eafb652900e0b27cca837a9939388c01f4194ebf4fa6492f9332ed7e9808c61e5d20e7d20e0789e64579ba63b934b1bfedbf5de708d29aff08dba42f0245434e5165d8f6bd40e34f7c7d212306f4361101f58495570b1790c3b0a181c0d12042a7fb0486c0464bca91541cea5ac253e12b4652c87c2b685201f0278b9b5b093d96ef12e9ece75124163c5b74602c18a85ec83ad1ec878c3e30fcd550edc288db5dc7562328b3dd39d2129dd75ea8b8f6d72ca368110c3a0d620f4c0615122ee9f650ded450046acf81f8ee8c65addd85e4b792a0112b8d0a3ea0e898f01370e4a2c8ab9a3dcc3a1f231701c549766e9392a2998155f3f8578d83984e494ee2470d1e890c116eb6b5555df088b23b15590b832d9665fa9fed43ee48b70ed534903f84abbc0eb27ef5abb36ce75a007d6662487dfeb9067bb761db05507bc9fa991311a13fefc45fb549c5c02bb0bbbf64c6b175f932b6637b0e86b03c55f2ad970fb86bac8e0d0cf3764da1fc7be769c803ee44c84b9a77c81142111b6f0a0e3396a5ca94d6ab8bf057e510a8f84e50a86b7c23b20ca40b9529215a56edbc37710b2eb65a8d56c11525b86d550994b5ccad53a28ef92eaf2971754d40346c0c7124df57f383664dfcd866c2b1584904fdd29620a38b8b256c809a9e5e9f86484d892a10366ea9df5ab649a479f57d3c5f8acfef3b6e9e80510af197d406860eb3f7ea9a54f55d15e96fe809891e7d0c9b96371186fa5dc4fcf1facd6e04cce92d3c87d0b9f1491eb97bf67151380a693afbb622e0f7e4f3d50aeace57761d4740d6a7d075f96e82ee00c6d76bba69bcd284080c90d7e295ad4aa0d5f903a2291b9e4da4fdc1d21572606159c47b59d9753a53750568913d8c9a51fcfefdc03dc307b880f0c43bb8036b0990e4ac069248cb9686bd3bbc8c8caddcc653a22434a101650e9a6daa6cecfbf627cea8a1c2e1ad069e2b66db34668423001317bbbff4f6cd36c22fd435d2b107a73d694aa5a89894079dac3205d8551c5be94cc2849fc896547a3f253d51a3795a832135bfa3ab6afba8ccc78c599a5d97363ebdf8f7bc4b1aec69face0475ca3ae70bde857ebc6918d17ab42e115a367d7a30b4c534185f0be06262d9a8e695da737c1957183fdaf5f7cd2ef0629f2cfdd4ec582a8e63402d16e54deef57aad62a9fce7f9b01242a575ea03926cc6e665a3abd8c772f417ff666ca8e99c3b81690b25076d274d48501a110277cbb4d6de5911b38523c107310cc7821557b5c4e01828a91165e59f0cfcb81962d5c59d407622a45051e298188fbbe9580ca243d80cf677de05b4bb512b3ae1b5bfad7cd4b3bf1674d5756521a9d9da4ba5a9ef1a2f2ad6cfb600cbacce9442fb63ebb060d55f7c08939c83f2bffcae151de19821e71ae168209de200889b655bc5504d6e98c61dd96e9855e5e77c52679d637f77cfd78373ee3daa88e9bd3c4446408d2a0baa913af22bcd581c1576b0235c885de38657d0e2415e36a05115bc98ce2b98f77c86778ee44f88a143f333b6901b949ad37dad5b0eeb2f5ee8dd49d4dbf16d19232b4e7ee7502ad9fd646ddd15f8c3336111fef88b9ef639d873886ea5daf15954fce668e76d916c2281371a8de02fa24a04b6cda3338ed5556e8b6a50e08ca467081effe3d07a2e1e9e1586b9bcc013b46bfbf00a765c2f9f07684427fd3ff92cd810bb29675e8fb8292adeeef2bd77a7ef8790c5347911b313c5717c89b820e5f047253e2a46c0dc43c393b4d51f310b7892876eab8645eec6f3bb53a1b15f0eb04af681f8f9aa72a4ad05741097c4ce4b81d42b9c63a8b67eea5e4f621ff5978bfc5175bca1d82863e202ffb22454bf06c6654dd054135228caa6ed731b054c2ca7921acd19edfa3f1254377d4005d3a78146a23ea98f4e45a588c6a31157c87b13a57445d4da6684fbf2a887eaac63183aa84c54a4eb04b7d7837c60b90bf9fd121e4aa0cf47c68f9e8f735c5ae5beeda243bd92c984ae6b64c197fcd6c181d2dd8a21321212eed53118fae54570973bc72344b7576e2efade35afef0b71d6c9e205cfbb8d78a4954de20e3fdb8bb4f1d9092cb97ce8ce059de90295701f7547bd82ea9c5a0dc50d9d1311a3a50c419db0f05c1f2fd9987f60a860f7caa73be3cb6d96e5138cbea66f5092c7027c54f1d0e7469b69b5221fc6d1e8c1d445c6c7e4e0f2a550ba6b5766a84b439fd0f16cbb7a7081464655bdb7c768481ad7ecc07d120f3a4d4e31022934e535f9237e803fbaa158ed76f488adea6bfa12c6f39ec24c45cfcea55ba431f05983c48ccbfe4c51adb007e6de8fb1959ce4f15079f9e0cf81a0afc2dc15abf1c00ca1d5b175c875e446991b59acb268a683b99deecae81fe6956a84df0b15b0d82a91407660b3f8a405dec71b3ceea3823effd167f5990c43a979c5b6a5c99f5f8ff80e6944f0d9949b447b8c5f9cddace3b9b274bc378945cac38880fab1b54e848352907f95ab82e42cb62e36834b4a4a05ba33947648a83d57dadeeacf5dce9cfdaab68ab1a13b715f75acc2efbe1863bd25b18b033863a50c594ed90a2a6960921d3c3f4b8570c77a137aef39300bc0dcae9cd2d60c7d50464afec272751573ab890fcc8546703f44126ded04a1e80060e623fb4c7f422e5dcd779d12df8ed41f34a7bc85e5205d0d62d59e24405e7ea358fb855d024e95237ecb829f24cb7d076bce231ede4aecab3bd471533bc12498f3a48b9031e7155e0a34b5e066efcd0bb38d46167c5b8601697ebdb5bb96dc652a61989f551643af6b1ce944190ac181f82ae400d67fe409b02314fe6208c925e274d55180ed4b64ed97fc32056444ff30769bec8406153a3b2dd9a054011d8a95fbcb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
