<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2645a7c92027158e9ea6327d352c63c6dd37aa14c5963dd022b19db61191e1bf9f995e414b72bcc0779a64b0a621aebf56d925d12acb821c0c298affbab0207c9196ab819e17a41f36447caaa0758bb792ded576a2cde7bd1b13229dba8e4209b236addb13a79734570bd12c788570b756aad55c8919bdabd45418bf484df9d79d81e093b376575ff6ba8b951389204949a1636f21725409b11cbd0e166e5b7cc2c16a576f35e4cf6f096bfe66d79db0a3b490dac563dd16a1bee7b8cdc2c81807410fd0a9c3dc69e99bf0ae0e501dbb10b8af64bb28af73a5f49469aa515494ee3dcdd9e024e46829405643fd2731fd0489d18c580edc596bc2ce4313b5aea6779d84583b3d7e2deb10b8d2d446c830a18b47335c937d9e8b09357224e4d6c16927b3ee45176e5aca3557d6c7a126fcb9e113394d1a7ea5c2f8cfe55450b2a02225c5e02647e826ad42f5482afbdc23accd5d22216ba888ea0ba02e798dc361763983c4d30c92cfa1f1a6dd59b53050d2d26a44750cbb7fcf67ce7e26ca0218b29fee40e91f76bbf970763ff51eb33d9250b44fa7b4d465ec3c33395922e46c6af3b272d05f961721e639161e29479f65d79df36c2d878abb85c33e32b919f23fa1f42422cb0e563d4396e50c3e89137e091d64ae1978f3b963a0731ac190f18059f21f2e1ed46cc88b3c3f17fe64a6cfa43dc38c783d8c049860aa4347fcdab27aa92ba5a92979d7eb87d97464c16e288fcbbb439fa5820df8693a2a6facbb254dfc74d465a5e1be30b0f98a86a8beff9113dd55b97e9887a565738e6f21277697efd7937ce3d0966cb111f07cd55011a2b468ad789c6641bc2dbd7f9e2f4f35861a657ce47950ee3857692beb98166cf290b0ff63c387624a315970e7418c42c679f22c4c3f5aa4ab36ffd99dc6bf3734275659a46e83c9116ec12a95ffc7014adc7ae154e99a2c6455c24644eacd5b3e958b8af7f890a0bd62223020e6cdfb72da92053bb7c19a5c09275ef7b6fc4abe0aed5e5c5794ff1027e8e641ad5df6087fdd87405e79131ae0c031c1410885cb11bbd4fff76e7aecd546fffa65409131379678b988a627a19b50d5707e4a1ccb1a7e7f06c27f6c41b49204e2cd3737eaf15f26488e74b66cbc4092a474af7fcbfea0fd9476c80f810a41859f0166fab54a8b94b73fc0fe4b51a456cc468ae5a4a94d87361d90c8239c449ab092530cd2401d31f9af56a5cd2e91661db244873a98418b3d82dcbacd8df1a004607ba85ecc7d604f14723a336c53686d0ed44bee4c74a9c3bcfdce1c96f050daa7681ff844e72b60bd123b5d664a2d3212e97065b527c7d6b3463c962cb3b4befdf44be49bf5a32eefbf6ba199bde7254606a8dc4adbb0dd651ada8b02ae99513d4120b27b46fabc693b5a38d00972345dfd4b6d66fba3be533df740d616738406b58913dffc9d963a5c9cb3415e9d7ce6a6091cbce5459d49571ce4483732301cce914682250f9e80d784b974f917828c57d7a78dd280959c9eb6f363d560db44b9b1b22aee19d3006775b12984cc748aa8d8248433aa2e7cb63e4de07bc0b448cba61a6e0fd5f0417f10e510f70b3114421eacb2d340ffd8defe746b303b4e2747b12eeb5957132be067d2636525a61d2a97f96b95f25766aa5c8b01ada09bc3cbc6d4401b0187c1854f5edaf0aeab214968957f9d8006297fd573d7606f91bb49db9b6e4beb6cf594fff02bfa590d625db9efe88db77a55e94ab0ef172c3c44a033c1455a8b5848ce860619a9c795751464d13aca23ba21cb53acf58d5996f8ed579d0fac065e60b7f3d39fcfb621b6ab35246a27443d5275e72dc5e456bbc5f7c9eb3bc0f5b9926a9c2d5b07be2b123b9e3f20236030857af0d739e2e5f15af681c1807e4e1ecd46219c359f7a13ac9e2b30b79d7f494dbb456ca9155d313965dd1a411b36214c669082b194b81ae3554240c776439032f67719af496f9f5be11c005740329b1115846ac3710820b800cd2e9915371ad10bdce62d0f71cf8eda85ff886daa48b992cdf798ccc5d9ee6cbcdc956ccf3afe0579ccc69433989dd790615788a126e37d410ea8f28815a8b4c10e7dddf0b4cd3e9eae0ae2bcb61f9c23c767145dabba6dfc00b8fff9033ec0ee3b6c5817c970d702c5e47b0b2adcc8aa6d88adb3a3fe4b1ffbea1bd40f52e1a9207e6f5046f55d7d334a9214cf9de1f6a4cd8c36d2ed3b1e7aa86e2de85c6f66624e9d5afa22ecc383bc4495977a458ed0dea41f6b385729d4cf3f34ce30bc045e2cc2388045f3319992cc3447b9c304b3e8edcb5913fb145dea26bff50c718e7531b1f221779c5b68efc45b0e86970f9ca6251bfbf0966183cf8980ab54b6f17cc6139beea0476f265b9c88f06c312fe455c2c7bcf67a09b7f8093ec21171afd76af991dd19588440103c4fddde5736df44dd716ba17dd9381decbd91b2bef202af16ad2addeb02c0d622d2b6ff6927eb2b6e8001f4d0a758e63bb0d7c0a9388c3d242bf0c69e3602a67a3006da197fdbfc9cd19ee103578e4d04e519b75571f376ef4ad8a59e7277621d2992e32949d7a25caee7ea1745d86444f3a8ef869b9b34839d2217a1c8a71c556eba1dae517bba43100a38c04eea9a07d2772907ad9a9b277f95240be9f868b18bdfe2c21c776110643738d4cf66ef96f4e9162ff33cf1c258a520f87a3e966e33cc6a06af84ef3e32a4f98a97be7cf94f4e51759f46424c21a56b0223d37d59dac2c8990591f6ac7438c4e0a7d52f5d91a83883d695dd78f43f08896e749cfa9cd53dac70d4cacaf7967214778e8dfd233ef028787cfe5ac2def1400c98f210e02f28d73aa551982fd89d00eeada13296db1377bae32ad7aa6eb92da79035b212e47333d82b05acd68eb3058f74159ca9e4b73f715ebf79633be1fa27b70b99944e325fd3021ab59f0044c05ca38e76cc0ef989101fa593f49e8f1a8d68b49e14b31b1179c7a355d6d3def1269e241cbde1b5eae7500f2902dcaed0c4a0f64ec7a915e669ec7569bc58664013c7dc7e2498b546b755ef3e6a32e52e509023168684fd0e08df218386cf6ea443ad271002856bc66c8cd353442eab8e38a704a96810f5dc8073c07f58f1034f8f2bfb9a0d9dc9c5f2d5f50d89fda456137974bba8a4831d5654ecaf6dd6a42fa8f14ec47d33d0c2657fd7b9346d583797022ebfa7add4cd5a814d69e35bf65d227c2c66a80388b2cd0782c21f690d502c5d5de1a3eedfab926872cb2ddadca844e31786f5240d09f1ea81d8c84a3d8d5db0c81558b6dceafe94c101e2a723651b33490de159442d33e3334edcf18ffaf6091fffd062f0212ed5c002bf153c53e577c512283a40a748f1044cc93407e1d9b8c09d55b1394eb2741fd9dd526707f98f81a87fcacab1483ddec62e4ac0d97c84277447c1e7ada83e349308d8e645b357f97ace62d92b63011437c1450b24ac6f1462bff75098d2998cdb96681f321ea5a397fd0b019a5aa86a3dbeb5bdb0bf994365732d7ac9408a5444a017607bb48f78011de5ac39af3377f3ad036e325396aa59fcb771505a5284c6dfd5e64cc0e47ee48654ae0079f2e3a3149a79b0ba063ee8f7c14d131bfddee1172e1e00dfe7c112ec773b6205789f872b93d6770b384e7e27c363f50441e22db1f39ba664593f45ca967a3964ecb847c847c322ec23ee288eba12b600086fad8134fb0ee364bfe38e8a736f59bad4d2b3b8464c18ea572f0838be2e65dbd0b55ef94e5ded8b6b63c3a42bc401ee54d2b33f6e2685f79953c08cfa03590a6e3bf8494684411112d74421d28557e006b32701b989eab98b33ca596d6a5e3f6901d0a7e09da2b4d1e6beef8bad4ebf15a72641e04d376a98d9df4a89cc3aec695318cc337c43005b2be3fd6bbe8cdcb8cd132de8bfc88649226a0c8d39c6e4772240d5055dd487e38c0ad517da8197d86cc4045dfb61c7dc91321a487d50628172e0519fb7cd8e7b37d54e18542165529871969f797b00e1fe4af53f049a7e37f9e76c75e1ba4c6fd8dba93149876e3b19bf9c2ac3d92ba52738d3de83ce2dc9065838524322b1309a1adf5ec05cc3e64338744cbf67da67ec6820747a23b3854c2364f25309c768885a24b183f65fc560fa0b347f054e30c01a8ed9a90394030d79ec1fb550431f276bcdf848b808a379589205cb6618d63161ba133d57b23b9ad8de4481c80050100f7257d0231ed30f2dae465717996438d94fdb32767eef4873e59a7c171d8925e36c725538b0cde9e622ee5923f9c141dfbf2067a56be91a6c7b8bc145c43a4bbb8d96629a1478f58545f0ded03ec0e20d76b160772b12d24d94d2e43f840b5086238caf9526ccc1f59a2a778bf5ea72d4a4eaaa47b33bcc2d0cf6607a95f5329702fc137893d3f60f6c2f0b0da540ffca47cef4eff106a79b1c01b0d66498eaa0d2cd42bfe84c30c6489a5c7069ee0e4d402aa3d1e289cf1d8b6ccc20ce47147aaf92773aa4f94f60c8b47f86859861405f5d12e805659c68c8c3c42bc375d6a09cbc54c51d4cfce45d2da802356012f5129a437dd39b3c55840565f308aed077dbfe75af433c4c626a4f6e461943724510a8668bdedea60be11c3d6a888394b28691c8530447e07df08770d0201cc3e47ee6b0085b2f08f41e7753c791c7123c921eb2ad3042111991a88f6a7021d3deceecc59490f10c0c7e48be7946ae854e2b574b9942acc948067d86e49cc88f841c76686d7ac33ccd1acd3dff67582ec79f1ef9a937297f9c0a9e24bea135d67ddb23b76ab884fa8571d3356628ac287f916c9e0e4989914ccd60a915075d5e028312be2691887eff02b0cc9b924d0e660f0c098fdbd10f9b6266d1d138e6c523ed9b79aaae62adaeb1687cc7eddd11b45ba7e6885c1c35b750b87cc0b3137c222f2a0c1f5730d0e5c3c421e26fd2abb1cef5e23ce43533c0b9fa5258f8ed73187b7fcfb8314e778ea53302ef048fcdd4fd1e8d4edbfa3a65683d76bde95a63f8a5437091c9e7151d9930d901e5b1d53226e7aef9c31df814b3185bc4397fef0b174dd6931aced0bde2e1a042f89af68e5ae0a17a307e2b8678695c5c30b9c57be9fc77c9d3dd03c0c4a8dac22376a27b1a734bcf87c2759cbc0c7a2338456c29a1df0c5d615aef1589fb5212e0f0ec973b23b09950435169d13f19c385d339f74c4ae5355e54c4e5bc59dfacefb9a8d0b2366cf06b24fa69248280e327b2ebd90033ad05f9ee95596beb4a0f3feb1b357ec306bea7758c36f66a12b4737f0f098ad3f83a448d2f1a58403e1fe7fcbe1461662d6e6c68639b77c0ab2e309aab9b9ade212d89c45789cebccee8751a1108d97bd50b8fecf2b7daa0d80188c24fe6c9a2992ab59d823114396ed8d689bab8dd6e68d6c94c94b86ec8eb25d491f7459ef571dd42bd9fcfee3b61020dc8ea4c2a7b49cae517391785828829705087a12069b2bc97713675fc70e0ce4ebcbaa443a161fed3e26ae61440e92d37163d89fd1b9659d1a05a265dcb900ba68a8e6213fb90f14304ffe82ce698bf7d96bc1419693dd6059afd4f47eb175cac1e445a63ea84950c878829279ab6555cf5c99da586520ffc8a412f712a63a7ff54a814b8ffb5701512869398380c5de1fa909537c8b6f735214f146da913b55410600c8c71ebf8650004075a0b831a7c0c2bd1878c0fec6e430369e359e7de4385558858b4526fd24f1a17615694eb4656d5a18d7b0d5c25c9bdb32c6702439e9f91d9a73b69f0f2afe9cfc051db83b23e624d359f68d00ac93f8778f95911a8d05c2ce0508b5c9eb70171b077bd28dec26ddbc5e9c96241d0bfd0a751e647029fdc9411e7479a12e295e42a498ffc27ebbac351cacd6d7a5c30a350f5b209fd6e4da3d75e67f9dac7f74eea204457fee930cc4c4cb59e487b1db36ac8accc226866cf80bbf5dbbecb107dbac01ddd8dfecaff4da5ad1d0dcebb4912bd2a11b6ec3a3cac8adebfd88c351bf63e3b9e83ec60d82b3af7f5c30ed9f2687b338015e41644f819a7060ac75db819bb2f849c085140abcd42e84eee635dd45e0b7e0c03dc31cc11c627c22847675e4d975da2210d49dda38ce622f9af6271d1704506581c27c4c53b143061743dd7444c5c785098bb4e31746152a45f48e65a087cfbab88215900bf398d4800734536c61a659f29b2e5041abc244698f54b33394c0599cb7fc806fec7d25c869088c57b3c8ba6211583035fc97c5b1d724cf2fbed50dcf2b91dd3bf51f398c8b8036b0d3d226b96694c18e1f39c24ab0260fcfee19ef3652704309bc8bcf141f1ace02d2c449b495de1fa4856e53529a29ea47f4f55f887f990bd7384f3108b84e8ac81853aafabe8a6584306eaf4556d0c1b5e122fdb50d83cfe23bd810145d9bcf54620a4232160d43668dcf02a42c4dfd185de9d6224a3591f0ab7322fecd06e1e434b1e5dd321244915a3b9ad9dea0a284724b917141fb259975a37b8b29c49d0cdf8f7ae99ea54450406a4ffe7e9f310a3e66ba28609bf9841cf93e69e88293a9e433d787f03baf0283498fdedbbd605363c1be0edfcb21df1f47225c183138cabbcf2e120ecc6d33dab4d2857378c25fe050295396daa9e92f964b6b47c7d22483d11ea4e55ba563151760300f903ed91ff38a5c8af59d7f5bc259b01c4f2bf0a296d514a10ac93dc6590dc08344d9c925c94b9bc98c593f1a93586e0fc13dbd8e3a2c606c3c0ba4fc871d39e7e2a1d6472b54d597d9f72ce2cbe58b672d27c797803551f12db37cfb9ce61d66d033bb60c0294800907491a2dcb2c9389d8d7fe46579de97967aedc29ca3c44c9a3fcdb6b4e614f4c09ffee9836ba576bda571ec6c8949d849a99da45a97d3ef5d76d657d7091133b5681c34658cec8594d594a2f2c742c245fec450b334587ebc6948ec1b4bf2152e89e30ea243fe601ad2eb8af979bfe4b5c61c7ebc3f5b5faa0e193ba07f4bea4252462316dbafbaac5318789418421bb2fba5c1eb775b88c07e83993390e0748fb05041d8c54f35703086e9a8dcfe578eddfe8822755f9f858a1a9d4cf63c57530f8621c6b9d5e0f982db1e9ca4dd010696316757ba3c86416b6a65ce7a818cdd16a19adcf1bb82ff73577e67123195e8d30f06492b4ffb70cd8566697ac6131a5418e6c26452bcec28f9e9d1f6778df21fd27f9d47cfad2f280fc75b8638517f3cb9920d0e0d23ee319666db589def98270c8b9cf769d6723766153d334beff45546b8f34aa6b41fd84ab4997878546b940172168edc47ab970ff1425628901ea7cabe7c4be0100ffa38fc9b0b328ce79072e92db8262d1f75bb223b14ef2a78d91b4b7229c4272dabd07ea3fca086664dda36bafe0fdfdf8533fe0609c8b1780396b29b72547cf8c85072b8916a3c66bb725af9fbb66f717d5e5d30dfe11a19932a1f5be573db0402a69196f40ecdfb0bc3cde6fba4bd5c952d64fbe807c6091e76c9d63a87131b0f3988cb36cae8306d540ca775e3653191a82b9414914bd0d3cbedc409a8db702f5ff180a7169c3d8bd8ef12d913434ff750d754ea8a2b475c13aab751ab185eb9f1df532be0d235d18aa162eea78af2820ffc3f486f98c255300f633852a30778d2806fafcf09283e07ffa7fff80bd5c6cce82f9f12c047eee136e5cfaf8f739d660559be5a636560804bb90ab699cf541b4dd4d14860b4c5cd2c72b0ea2bb06a05ee1cadacfaeb35a495fbde3a7d3ed0bdeaa4abeacedcac1e18448791290edd54e8866c12b38e718f83cf0055755458fc982bdae641b2bdb8b868512c0e9d2acbf0728c7391c2172c2df88d360531109cfddad8819f9c4a58209521451c6073614faaa68794ad836375c19b4e9a5c899130de1c573a7b6c01f220a8b96e55e502fd16950b538130ff6b301e07ee07ab9bee1ace8b8e8064fed388dee39d9043a76932708d2f035ac944fc2ac24d23f4ed23068c12b57b7a8c5d2e2e0bb276f4362a3c6980a20b5af11204265cfab0297d06493632bbe9d21c86690339418965e4b6d1a40bda8233796be59cbe0f0e75038a411cb5f929b14e242a857f9923a3e49447d788d29269911a845b027b9a18da728407d40b3fe5e64689b977cb7e875ffd3738f56507e7be3a70564c0623e73d55e8e397781021e009c49c6c02d68ddcf97d4d535eacfe88bfbbc7b928cf204d1f6548b2c92877bee8ed28500e76e3ee038b481a5e060f312df79b99c1abe7074cb892ba14b8a5d9859c7ec05d801840b75b397d945e95e992b29d0449050ce515448c77235219c89de5fba8c511f5bdbfab68d40d192c3cc32c70e6b78ee87c6d8588692f6a8c72d3350d82cf5820e7772a00a66c5c46ebc7e9bdd73bba978489d70a83da689e620ffedfd6d123cfdd7fe1fe23a4be31115c34ca97537e37de268690c487d0422b3cb9997f82d0016f0027d88b346d8b79fd3fa27c87f99e971224b65c2e9f60adedaf907a3a49e80cd79d546c53e336669baa92a1c4db0be4707715c5016f7ebf69a50d5abd0fb0561481d56dc754d34d0acd2f6fb8883c7e3df2e2abf1a39e2952c5856fa543f3342fac14fdc09c6a6f3a3641a54a9a777a410f386b49b7348ca4a711c5b2a9ff30ff83189a29c6556d78dfe755dc2be25bfc4b8c7ca91a0545afeca9f67c5e4a891fe3190b5d93a23513d25f393be60a199d611a434291625da9f2ee884bdad44ee5001847cd899722b61c1981f6ac2eace8064abebbeb2dabdb16a94e8187d70ffa0f56cf77d7c8a4cdea831393506c67fa28635fcbdcc9f967548636175094f05c940736ed527130cbdf76ee132f473f593b50c9e7e1fc3f9276dfd1b561c76bcf2c03d94ecdd633a71c1c2bc1b56b4677a8025aaf7ba0622be0e0f7fa172817bf4e48be2dae6dac0a1a93a3157533bf237b04d513190ca5bccc77e9f92b518e6367125e412fa4706f7c264bdea5c0952090a5c82eb947135a56b0969e59637eeec1a21bfe6bbb0601317a2e899f9494de087447ba09020d0e9a2545b442df706536c69f63483814c612f18823b4639de53beae846baa30170d9e093c672a08a07478f1e70db7666ce3e7339eeb70a02aabfb868cbf8410e29fe92eddbfaa089cd932ecc1aa17c22f2a4c1789a723ea507935ed2b85cd479b34730e60c3abce264d3717c299fcc26819f03dedbd864474dbe723e3a041d63eaf4922676e9730dd6ae5683dec0d8255c52d03569833ca964c84fe6e979abc6b34b49abc99947f16695a10b80b05218a5ac81dbf0709bbe2b353b35da7fed442617cbeef7f7e7d917449b10c1f5751317dd231a98fa9239e767a89fcfe99a7dd6c9f26db8d295402918cc13387b4ad720a02b1c1513fb3a9dad92d375e483e50e7724524a4fbbb145d29d8fa787d2dd53cfb36e605e9ed18c9650975a7b840da72a553f3af60e5e75470c3bb2a31551ebe5b1aeba8298c32bf557302c8fdfeab6bcf20c2f07cbdea53ea6832ff7e63e28e8140ba6d896435aea9702534c289008ecb70edca21db83503bfb77d15e1c7461c83b7e7ca51203bc9f2d2b967cec4b28f68d83f9e94b27b3f5e44754feef4b0568566a571be6ed0ec7f691550644211ea2de0f8160b80d2bb46fb1a5998c491af3ad2a4e17a3f443478f2b87e3b634992476699dd5c33a643dbcd119d95bd586c74bf9f9a62bec519a069c2dcd2851628ee396cbdb03b454c5833647e63f62bbdf5e3856eaedf6eb972d773abffc1f2cea61ea583a7d956b12558cc23a09beeb030a097d6e281458d18aae9bafbe6d2bfd239ce28716710cc0c33634d36a421129c0c0a50f3d2812ad66650e9a9c64eb780e149220c5129250dcecfa61f2e014f7647be5c0bb4a19fb892a9e30e6846d899d0a56feab7959c76c688982b7821d239e5abb955484c0cca1a8d8d765e3e169f1b7360d5b4ee7d6b2588493c051a5a5f4f96682682eebf96593441c96eaedde9fe586895febe5cef21652f422a310f782d6663a375662b983b19f396cf13ab9f60735e612617dfdc70ac591a85e8be05be2ce76e62947fd355b6c3fe8f2f0254c04457cdcb714d6424430c17dee998a6b9f69ded50d1059e3c0626b16855a774bffe3e52f3a23d649d3d53f747fb45a5e9453e497bce48ac813672862a838ce92524c134217a3d7281e432f526dc5f134111ec6b6f70383c3254b86457f72f3c4f179adce643e7e25912df63455eeb37be3641d53fa83c33e62d94d0fe332f35d25a889a971790971acab6288a00e730a178e0b7798df06f7ca8e315e53cdaa04bde8c13b7bfa54072f8789c72b0b5c53d20946e13ffde51931c876edc9466d6d40f3e389adcf53d80b183209a66b5ec59d8f616600874a9db5957f94fe225cf1a1c03b124207d5b600d2222377a78ea838579bf16bf95d9d264a8f0521624215e35a7f42c9f44ab24287c1ed4c77381bea1d2bf03aec43985bda4a997ca5ab998e45ece57ef5333986235573589a7f8550b4fb91fac3671110ddc6f9e6adaad4d5120a8ab82a46dddfb280b6eb8569f40c2048532080da0dad9d9838e0352aa927d0b1ce8b1ec7ba5fdf24987e294c4a23d76cf0d3eb2c4e96faa67423c62e1c539f5444ba8747207c7fb88ddf629b6333ed6cea1f8d8e9f72ca6d3d66b345b75dbe6ac3a582ea3c3ff40e9cdb0e32e7d29a32200e3b56ecaaf1fbac1459b1a123808f35d4d318e0fc6c3728a2f3e31017842ec4161570a09c228436130e8665050ec9fa445cc376e339cb5747be8011944a5e0a7176dda800698f9f59f8a78b472e84860dd3fefc35f3160e458de285a883bfcd324e29def8b00db2ee421ad5ecf334efcf8f124227ac874f0c630d502423d1d5284d98baa45b20d4c57109299db5058b5cb341fce56b9859e0c1d755110b0515a387bdc3a3e6dfed24c9c31e5d2c75b0bc8ac3d9facdc7fe66ad1346a26ecbef4ee2ecd3d28dd0a3193d3b6907b12f9da29a6c6c109e8f2660aa048ce355c6fe2f308e444e3d7c55c24902ef2f70f559287ea5d00d93c948bacc8be863fedfbebd59a147a73dad5299092d5467d65806dc9d1e62400acff0850f4478c91cf87d7b2f65a91493877b8df57d9625abe9975a9ade5ff44fbfe0396c86c0017a0df6fdb5956da25ebfdfb6c628a77d2872ddcfddff3a93dc7985d0012505eeaa0e3623d51f3f9410deb56bc3d406eed7c84ee25916c0fe3d5dcb4dcb7a4dd92ab7e2f6d9bbb9802e8fc50944ac1a0c6112591a1b1f6f05b9d480c3d374ded0203ae922d66ca1d02540b55cbe14bc9bf1a09a5f77fcb810c34402f782ff19f4f59d3b70f1c1888b196010d535a302ad5b880205e1b2f196828112af4e6c08b4b05f684c3eee82b1694d9af06060b33147acb9b92f07cd135054a2201798045f62bc74e4d5beb9913c8382a1ec3cbdba7ffdaf38cffcba88c5b83d1a626209a41ab6a3184220c34446bbf3dfa4338e73f49735e8522c6486ca2e4410893c63a49dce48eee48644c1b47cf3889f9403610e50917421ed658ea04a673bd375620f3e62721edd1db6c89cc463dbf4c9c55551ad1edbba3e97b2ca7c0577a37558ee66db32d4c86c7cd325ed483ba0c304e3ccb846ec23923a6f62f04e64c5220c675843897c275295d880c821fe75f152477597252fbe85bc10fb9df1965063cd00b7de12a53a6a414009ab92196e71613c269bf1ceed2649bfe1a85b73a8af859f33916150d688922fb4ee0e727d18ecf09b4cbf14e37d56ecb5e26bbb7e4627de6ef0519e7f7167d7b019c362f38ba1ce402784bf6ce023fe753bdbedc04745bcacb7337e9a0a53e3891d0039c66d581e7349b971840e60706b6ffbebe73f89f973f6755f47522f808618710006eb2a5bbc59053ac1e10cc187e58a93d659d188e24c3d9f7c57d6840c6034b529c532b09bd3a21a05a9a23dee0c4a4ab53dadebe181da6b8687730d88092bcffb5f8238d3419367590769c4991dd86079187c8fafcc47eb8e81aaa1085166ef3cacaf659ccf3063e8397c80d0dbd41f34b1df8a83bc349091ae946ff2745a857bfc7a5335dfe49427c244596ce207a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
