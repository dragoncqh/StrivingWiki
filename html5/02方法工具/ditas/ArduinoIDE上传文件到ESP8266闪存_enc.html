<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"70024d536baf7ccc94b06dfeb1cb09d1dc0d322f6f17cde50c9b00f84305a93d2d70f1f60d6c1df589fa1d84fae52b32b3e88d88dde9d0a6f3d8fa017c3d751ba944ef23af7a1e9b58cf5e96fd8e204d8894be2687a56af5d954b691eae5feee407987dd52ae25f6ac816523813e37fae28d413a106043af58e97b069af981b3730d864ecdf1570afc6a0df008f40467f7a00e8b4b141d2894519bcbbe030af249bac4ade4b3a4c4ee91c3a618c7d06d3102a64c784ff159efd267373f8ff30f636a6cd380f91b2e02385c40cd1ba23208b92f0090c1e47b951228c62844dbf4407b78b2e4d478bc5012b95eaefb198d202bb53146a425fae95e92737e149bbacd75b31ea23534dad989fa033f20be4b6f443337fa9cf1cabfe8198cbcc59f2fcba7d84e2f57932ed37fa211f00eceba36fdd434ebc422872ecd2f883564425d6ef1763828d7e0662518dacfb7e25bf767722111d561c00d24e6db7689d08af34307acd05f5e4f018c77e3e860531008b106135d96a758b0d354bb35df1f869b23221af4f3e5d10f0e6e45f7727ac313915dcfe6e4d18e34d8926c4210bfa06c8b17380dd956b27e9ef090fdbdc4f74398e8af4dc03d86902894faa84959f944e73369b27f7d8c2d94ffceb27f90c55d9245c5fc0818539366510a6e6d477af26e1e5d758548a4044dc1f5a88952c62e0874eebccfd8a9c2ca5d206049412effb6f617491f33d4ac1db8a411bd9450e416aaf831857fe58c14e60cfe659e7eca2936f5a855fa673f5942a83cf629ad40fee607e47fe5c6080cca4a504e103b53c47520d83f51878c7569fe8a96c0894139234fe19284723d85b48fadb8bb47108680140f4aadf217683b62c43dc951258e78efa187f63850200ec24e026cb78f97589995883443f6335d347de1c3cba92df5a87d2e87c6ff69ef38d1ff7c9756e76d475bb529a471cfc3cc637fc3b2ccf0952def0a5a1f32546b4436b7574e16348d7e8839d44d46b7694c933cbe33bdebce38e64b939ccff9c906429d40c3970b942eb5bdde9d3d4841cd40408a749d9f830b68d1f5aeeadf4fb17b208a18b0d8a2d55347491dfbdb361cc2d1bb1ee78f87c91cbf1edceed62ce6d2f70bba343e2f662f6033621577388814addd697c8b1a27919a9f9fb1683c3f8b4c71c4a5dd5ff0d954240b42860d901f849fb8340e87879377890c60ff6d3f60e46342d6b2108e3c0d507dac1617717f33aee9d6bcf171802226553bd9bc7a157c636d07da9819e3a2ec0e67a3c30d85d536d787682b8e1d2711b02e3d7bbcd7b0afd28c75b55e2f685771c91f556a8cbbf659561edfb50bd1ea1313282d2425cac765230371d78bd50221cfcfbfb89bc8ec759f895adef92e0427996af68d1cafaadf939f8e1ae54429cee85aed1a2937411180076b9c6519b3d2730978d76ed27ddbc00868018f35168d723161b161695c96f25d04b8daf75ebc505297f57c92e94ad2dd8dca54e5c52f3d65c4e8af9619ad7e12ecb2158aee10a1c5ee5cc747b1c1f8fe51cd2aaa1ce5d8695312406845bd543f913d942818e14e9e46c04aff705da1ef355871f92cf6cfa246023fb661a2fd92aed1367b3f6e8a80d01b30c40eae5bd35d688396927ef3dfb13255af134c1196890c50b1d4160326867c06308ea107099e493a5a7211035d53b7a109a519479d759f4566ea6b8a7169ae50ffb01f7664085b3a01796167686e57970feed378281ecd97db58dd5d862d4b57060d95bad2a885315e1e49250befbba1d0e3bc2bf3715ef66be646b8b8baec3e3cbfce2625d3a30e104e30f73e4160b0c290c9d15fc5ee2734fb604edd0f7f184c2600e6a1d5d625aa0fceffd3ec93b8206b31dcec295b2dd9f967b772ff1ff292abc5fc13ff6ab9dec0b6212f16f6763e5c215f5ce690abd4a0ff8c37a7c69e1034cba91378568aed6602c447242894d52f01a74008baee59039b03903a7105ca4a1cf6b8f99610b851eee8ff45d395ae1c3008ec2fb43e7cc00b9fa551a985c7c0cf367c49ef8c898095085f9d66f21de04ad7f3a0494f8a6eb195a7cad08c7f584fcb18157d0eee1e3c08009db3f7c28560f6cf3da333e42e11069c3a91f278a552949f21dbb0ecc4af7bb5abe205401386d8f9e9a82f3690c21d395cb23803b1327c9f672dca5c6b64aea0c30f20722e225d563e008c4c7358d4ee065be0e5ac4957570934115284dd32ac9c710031f8cc94ada138fbb5efa3e4fae15fd8d22c738eeee449da145976ccecf97e461736a69fca670854d9368f9a32d91f3f117e39a11292361b513711431a0490cea02977895d62d232b605ac6ab4cc3707fb360676ff59b13d622a291945a6af6fcdc6678f6e26999e8be5324d15b3be46a22d00d00113287ff9bc381517173e2e5e7e726dfcf2b44e202aeb6c95263850abb0a778a0c6bdaa5967a8e96ba08fed1f0429ec476a6e3d7929322e7c874b53219792b97c15e6d0b488dfd7424e66c2327992721b8a081e1e5d57d52a7852a303bc4e96d4325c16429542d2d958583fb890a0dfde6701a2df135136ae8ee0ac1afe0f368c9fd347cd06ff4107e0d4575ec5110cd65ebf15555e965cdc4f1048422a58097a95feaccd8112b6937e20b388a2d4f92bcaca7b47bf14645c3cd66c29c3119cc95c1e729e1c5484aa05d0e7859b0596ed3945a3823c9c5c302fd3a89cf3736bcf2cb9d21e11a08917097d8328089ee7c29af0e987c3081bf6f08211301051bab0a0c3a907bb7d426b24ccd3985d746b6d2fee58033f0aa67c083ce9d76c33e06a48911107145af4302aa41f86df0e2dd61a5d6b121f9f8cf7c7488cef64a350f96b3192c6ad9d1bed3dd5f396865d6b9c659e5b4dad6fff7e3c7eb105c9b3da859d71f84ccdcc095dcb1cfb77ca8e337b0c71c193e5da19155e2a957c278b3a0304573d0e1e18662934a849182200e91dc0bcddeae73a71de86e1c45d53c217a1d1493b01e92438b7e5b985ace435e7c24164e73864e983cd3250cf10e7cf8d8ed7e21f346772c2f3248685c7c1afd3fe8a61ec00451f45efd8acb0a0ba44f9c61c1d95ba98fa791a3d7778fdb8c88f47e6086bcfccbc3a5a769d1d339533e2312680360be04dcbc0e3011b43770ddec2184d70555328e4ee97cd6cf4f6fb405f3aa85486fb9a2a0da7bef8e816b710a75c4ead3ec07250fe8b66363d905f35e8184a441aa43fed8192f1fabef36162d3383dccb7113dca933a60c9bab2a023e3cd112e1051cd2625e17be678f1ba1bb5e9e59e139ad4205387da382a126d062779473850f3d61d7155d005acfc18c49024b444d1dc54dac050fcfe4e82a4775f4d629110e3b737b0dfb0913c7078ef63df43d6179880e19d8c45e07cac1d8ae7c58a8fea39b9f748352603d6dec21f49395cf170fb738850e4d5835595dbded5df165338faa840d2292077870ab55e9f035aa33c81ff0e84acfc2ca45c37f035e7f2a7809064d7a0ce453f02fc69853ce992ea7a3418fc27f3eb2794662140acdb03e79bf746a337a1f6907077b50363084f882980ae48acb26d0e7132924641de0a367ed9e574a020ed94a9e79b1a4ffbca9ab900ae1ea271728fe2b955365a5a8e618423a219c23f7b4e0f170deb133c0961cec8f1d4e3dfb074019f10dc7f404192e030e48ec1ff5042dbb388b806cfe769c38edf9fc66281ea2d3e1d427125dca1d184d078f17fbb90dfd359faf160d1b66fd078fa89f43cca1efe1cf5398305c6cc25edcf3a9002cc6b42489f0d6dddcbc1326e6556ded55fb7c55ee8ced4a2e0f0247cecb119b584d4c7b804b55c13114114616c2bf83837ff8feeeb859aaa5a56d2bab5f0015936c1dd975953f109baa8c8706ae5de7829caab39e89d1661a4b6b3ce25e68af5033975ebdb587cb446a90cb0cbffc3f255cec09fa47e7795163e06b3d51663761d04c4fae85c16c01a0f065247f5bc8075a81cbd88eeb54363a78f344a3f8adf07b4f61c975079f17af4a53eda9ece254469eae470f6dca9cf01f28999e5e5cda0d5644fc2607190c9824b30ada0cc0ae57df7a73ab96f702f9995623ebad05abfb0467b1e8ce53d4f18644268a996ba1d852b7e58f19b073950ea346fe87c866e0b03937e1ef39cb4e2b8046bbb25b4e8bedd59afbc363c0a90632797e59966e67ef73f334d4cf33662f0d69f4fb217f788c195135c5a87de00db4f24d25d13afaec657a7907f30e0df49d1d2b751cff2b0882ce84ff176105110ed3c83a1e30b447cd035e3804ced12b687a4cd3235d1aa6ddce4a95d2312c6b0692a2a96131f65dfd607f38a91682f63a388e639db206d2cf45870b1e4bb691216cb654dbd11d63936b4ab3ee535f9e6039c640fc656de63ed73d894ba460fa095ffdbdee95d0e2f8cb7307b396a26cd642daab4398b5cc0eb44de786e4eee7e33751019c566939d79ec88c60a99ed03aec419851bca755b4e055fbbe443110e36fc80d1699a02f5016229ca06b95fca4ea8b74ceb98883b413e2112d9b65dfcc88349aeba5d88a360583ae3210f6f9de14ab7beda4c9ed2e243ecfee74114dcf9f75bc79f04735a9110e2c49a4c58f9576c39be719ea4758845be975ea33c4ff23477a7a0fb59dc037a46026887f046ff25d2ca194595e7f725e087ba7dfbfed63a73ca7dfd0248968ddacd726b164b8e8daf279ec6ab97f414b2b7d775e615db58620cf80de5d98c76b697876a6440c2bc6a5ab341a0616a3f0087353215906f2bae9698a56f51f5787dea39e30b49fb43990917a898ebc675a7cc0691725ed38f5474c46bb9c6642fe61be0f182c79102734a2b8b37ceb62e28f1c0f20f08fdbc3e5857cf6e34e6d821911f15e25252f7b7d0ab459b76062188c5bd608d8c20139bd3c1368ef5895843dae98fe457e2a0f418a8e605de10858e6166efc97fa2cbc8f40da2738d80e45742f0c38eb3d1edc135848a1b99c88cb66c31d25f94a20e62e08d7b0c899f4b98ce88fd68cf24deec2d8513b48e3b13a9e56a3d581df5999bf5b1b132d396fadec085360507eea9a4478c17d84f17114e449d61b08e170bdad4aa17aed25423fea2f0325b8eb1459dca9ca7234f4698274e533e81aaacbfc42b215124d9cf4c85033a35e86fd463807fdc8f4029cc1c47ec7a26ee1b391be7eed7c197690e637749745438a1de51077c8f212391332bcf88e651474f35fac8d32500d8659ef7203d94680f1b16365806069b5c7bebfb2030459491551ae87855de655453709dab4c4d4b2f7d8c500c03fb60b8b030a304fbaa8d736527e6cb087ef0a1497800b24d9c15a0626505c74d99fc5c9fd998d4fde5a1901db5791c16f6d4264d6b20d9b384acb13ec7a248d8b4bbb9eca51cfadc99d4f8a25a1d648093d234e39bba7649a2bf9d9549f7ab2237cc85e9b1eda02c6571b489b9e4befddd9f291ec1cbca7d31f0f5a169b1b2d40de2c583b659e8941bcb0d504503251de9e1a0be35646e8b65894b4f092905183685c5e803d6d0e15620824a1ff38021cd4f79a55c8fccb8d1c2cc5b3febfb1d5a64c68b2cb7b908e6eded4bc2cf4e73c10cf832b27818d69e46e04d4c4ba148eaa3e789af8c42bd4d0ff3324bbe13346f564d40e0bde2f23fd2ab368726313a62d4b16cd7b4a417cc7bedf7eb0df0b2c6a303c49d9f981afd3106e028febbb9c1933a3f767a403a9b8fcdbd6fe578a5fa103074c3bc148f6050c9463a6d384d87b0987c97ec73b89f2a95d8719bc2b0f9f5a3d0840f6f706c4e473419edf34c553411e10eb63546e2d5d891bec350588df2e474afb09ed7306d333093090033c5f2ebb0c32320e9e129f7bc5e012aaa004e7188a43d6585e5f820b17ceee11fa811fe7d2e9423962cbe80f5c20e2589651b34422df2c1eee2e01bf170c676439efd4ee438868d570129acdb2ac29a7990de381cfd10cc8ff5303f522bd228a9b07206960619eaaa75bccd2015633abac7f5fc9c3aef27f78493749c52f133220efe5a31196a47081f12d9a7ccab4b8918cfc1f31d3950bbf18c2de2778a70df67a076e3437ff432ad930f32b646321655ae934f23abae9bbd9c26a860bd3f7e59263cca1d10b9ec73a4348f7129338f82cc69a6d80d72570404a2edfd76999fb7aec4aa2ba18e8604326bb7c30f87b4ad19b3762a8559b85b0813c3cc48fb680328e02ca8be107b79015a041046b22c5986012035a73ac74292b0d3291b8a62770fe9e5734d38baf14e13dcf665ebe1f9f6085b8ce89d07c56ebe5bb14fc1fad21b9f757daf47efacc8695fd6091605347a5d0edadec54ea2382f1a677fd435fe918266c94c8d2adb025c88279c393ecaecbfc9ef81d841a1afd2a125a3b434ffd2db6761605e9dcde76205e3be8472c5246f6f6d106a03f3221ab3e3a99a56f9cb201b1fae24eb16103d6ea2c74509060c43653fba4b1958045e6eafbd36fc49cf00d0cae08652bc5875d425a05657094770c03ceb6063869841bacc22ee861fa3c1f86ef5c0a15adf2b43db3569ada9d024838800870c148c8da88c69df2c42fd1d11e9c14ff1a6e9abfd7105a71cb1fc907854522e58c523f18b9933776d3beb1ba13410550b75206a477b1364a4b0db5c478101b36149709a282403a82e602e765ab98a6473c43a1b97b7d49623287d207b20d31dfadb1643e5ebf2c241252cd5f61a790a902642efe875b6c131db24230abc8e966d751246915bd3d892276b716055674cb5dc5ee19b1338eebedb19925e4cb756287b6d02b2d5c07300f5fea66cf0a88f50e1b7d27e882325325e08b0513c2b4131ba6f3a3373dd58e87c9fc60c51a25824d09b58912374812fd681e327ad517f15a0ff7d31be9bf98013f71360dd67835a2599c918e35fab6d537add43929bd83fcb42c7b4f1dae68b6f79bb344476c424a77c4571946914049f5fa07a605bc22b3c9de8ed944ef115d81131bcadabcac4eebe180515ba89f8c1d6fd2a233df3a054e97514116c14910e91bcbde9adb6a2a6058189df157cdcdccfb649f3d99b96bc241a0c6464ddaf5f4bc794bb46203f03c8a09f5e6e4e639a110c86c7cc89d6c38f6ee1fe123e15ffecf7137624adf96ee0ce2c10f53e0bcc7bc67bca70b63a1e528c9027a18519bb1d0674979ba810fe24b7a52e7f1efe048fb8abff4e0fb1de6568844bb56cf43cecbecf999f8f5dcb655df481962e083f8c6ea04e097d464b036ab2a8281dd9cb0e1ff527e99c74bb88733d5b7047bd122b83c0a037226ce0770a525df756048a4167328f6c5bd1a76667ab5e56011617f72cb27710ea78ec00039f2542763f78a3c5b0d5c0c239688d2905e261b29d7b4f8bbd0c7bdafaed6db5a7fb9b0f5c54ce9a60cb935ef8b2e2f39ff547759649662053f04dfd15be380b9f38d1431ce2123ec725587cb31149434806ee223c3af824e0257f5fd604355822276568eda2ac3e1d1595548085826da3486c83abb8fa7363cff7c154393af6d97cf31481efc2f9ff1ca0e88429d5caf03f0fd812ff9c787701570d23b19dda5ac26846718dbea6dc08a2b1835f38e0745a4de7c1a30ac34209d28257f81afae9f589c6b8670dc4d6d4de7fc88401b340a0f156441618f473e2e45a7571e10e9a49d227b10fd81ef9414204a66c26ed066f24724efd3055dac9d06b8cd6005df31d5f385e5bda0d5be09c11757b359acd27f8f6553fab18dbc0da3574fdeca1c0e5e365a77cb6c819c298fbc802c5a963b9c66ac04fdee4fc7671d4d448b514f767fc3f79a1996ffefa6a208260bf036bebad0b43ca79ac0cf000ec441ae1cf20db9b7e5cfc76126b2242e1901f30d6e496e9509276699db42ea5e91514319b93f46379d0512cb8416d664bd387ac011a4d369bdbb541d162a09711a73d45e3f9c784acebd078e5156067dee1cd348c14989c9f761b5ffb94a26f0ca3249f89bfe0f631bb367bf4f9e4676fcc2783e634d607fdb07315d469eef6bd711acd9118fe1335fe0f0ad9d7c70eeb3cd75cf59703389d4d8e3257058da4c9bf1b6ee73741fdcf8c10090caebbe4f2a46810ad7d901f660ca373d3d51a9c5310091f4d499d17547685f588baabea209d1254d3be589bf3490bcc55afee25bc17455e50a55bd493fcfc2208214ec10c4e6b8ed29429181472e1411d76111a49dd2846350780f04eb59d1c3ef258174bb331feab26096bfa7a5211e3931a620a6b71a38a464f5ae9fca8c542b6dba766dbb3b0dafc53b97413e312df3bdcff4686dfae91aae25a23c85c8b5fdfeffb71d9dbb0e079bfa0611d540572bd742f2f73c6379ff53072c9a67d3fbabb04296ecef778651605d5e35c24f7d766367faec74c5a0d39b7cfe2a86a727665c129de3c78e3faec5bba21c9e078fb3e881f7c3a398c1fab3a7f984f88a563c11b84640d95a66a7535842ac529595f96b38c766516d9bd2f21a99da8ac149cc40a4f968e7942e9d022cd4e8ce485f3b1f2fbb5b6c7fcd3288295600ae0d003e12a426471174d190a8302270b006cc1cdeea8e037b09221225fbaa6527a82a97bd1b8a4e56fa68976e4059dfd8075e96d72da550026724656f8c95a6638453b7a8f6aeeee0f271ea0fe0bf294b514601b600ab48347ee27065e0c5de0026f52b44033caa8f431c03a5d63abda44cc638a8065a069e9c172cc83504da512ce124a35af0879448475824b29b8480eac358f11ade8913713a342528727d713907adaf9c9dcf37acbe84ee6a4a3e5a8ce86be85becad20de82e018f2c0810c8029015b2aaeafbd4e8ff5126dc82e4aa877a2bedf5c1432715c2bab23c347393a9d78cb1e3ee90bb42d165c05722814c2940269186da8380c8a220df3903017f613ed3142db184483115ad389b53523c1eabaeeb03962c7896a1b367fb8767e49b2447d800fbd478372adff46413ef3bb3b7e6337b6b394ac038fde8504498ac0b037c92cdd1294e7d11f84313f643ce481b5fe284eb93358cb91ebb2fd4544157fcabb830fb4fd6db8d3b1e66e5f6c2961b3872acf696c98ccb05838e674df50e202bf58053c91ef0ee8726d359aec714adf448e048e61b1eb7256633d58c6533182e53d09573f9dae4308411adfa2fe4738c021ccd5481873496db87681c77d40e7989cc932713fe69d8c4792d7f0ec5436ed8e68b1e45678085ab1d525b98759f43235c770f156fc345e9794bc2195accf3e738dd45636bc322c980437a1bf28d8fd3b38491edb983a9a819a9053be15eaf303cf8aef083a140e5672fd2593fc61be090e14a992b754b51889f1b3b268aa4c8a30e10fd414bb63935727d5a16f613515e301a0a2a08540f34a1e832df4b9f2c008a7de2d8014cb4763b00e9069e6b4c711bbdbba07080204fe2700fa0e62af16694b7e64e88983ee3d6ed40bbf62eb08be4a2aea46c91ad4371734e8da0a7742a52cb9625807b28c3924b78dcaee3be63d7dec1e6dc269d50f92cf11fa5365ac9be0658a0854831a2c07e6c05d76a10f47afea5a2ccdad7138b28bcd2bf68eac6b4e7d5200f487c4e8c5901c4bbb01e2b27f0aba234bea00b4fe4769c04af04f62dfdb8f89e41d5d3a300a15572065a54e2d6c4bfbccf922d01c6145bc3d711b72747eb1137f64c8ae7ccb25aa22cbf5242c7cdd2f8ae4f3eb64cb01126d0f7a077cf99206cdc100016cb19510fbbe7c56a38620f016c66989bfb6c586077e22e74d17ffcb6d9b58a4d4971d1c8f9cb14e31c3f9f102eb99f6743ed75a611567c5ac05af5c5f068e08a32003b5a5907e84f1d3539c2b6bda275ff36f991b22bb753876ca6f12b528c321b65495e8e35932c287ec19969f812d4945e6e69fefef7aba16e3b19bae841b8206a60bfa19c8fa70af3160b021f9c8573038bc4e811fd48eaa6e53916cf50bc212bc9b2ea082917f328219f9c130b092c1179936675a03c12619e56105071195782418c99cd673a257d21742b30c0c0e3e1165915e74e2562b69b8c9cbca3d7cc06ef07202fa6fbc7abf577547d05fca3dcfebfbef74482b2a19798b4cc040f132f9174ce8987ea42f7beff1d15c45d984c8fdacef1b47478cc08e224a53469409a58a274bd124f23299657f0958aa06ea6f9b0af58c1fd5b1bf59d8d89a77984c8b6476880d4567fc9be186f5d5adca37f56f39c4481d5875b32f326678be9ebfe9e8916afd0706cf258a01e31eb7917bc3b454eb6bdf134d92cb7f25ba0d618496f5a69758b7fbcadc92a664e230f240f10ffde3da5a8e9b84d31b98845abd5477d6878d6c1afde67d3938e86fe79abfb0ed0d9e90cd3429492a3a186b7c00554f85db7b5d705249f846000ec9cdd57581a20482827c6c4a1c9916e44fa9b416484b0f8b93ff6d69ec16c6c7f6f8b7f3525700ff57066268840fbb8c83bd9104831877b18ef2ae0cb1388e214bafc6ec9e600f2642ddc7846a63d1b3182f86c3efd81b9bb53531a62764f9d7c1b65bded934dd2f85bc871f353f523a456772fde32ae32f830da6b9e4743176082a7554b536a70f681bdc4e732fdc739b3aaff119fdfcbe5b49934ac91f646cb419d3e8500148d083ac54edc0487fb7b81e0d3b3d3169cad9ada08181dbdeb372c23eeb974665cb72eec05a093fd64adc72313a44083910aee0e173322444c5bd7b4052d5bfbdea5848777dec41d3cc0453fc337769ba20f675bdb0df2f486568f66b04be382215417169dbbdd9c38d5bd9af109b453dbac8bbfbadf7ab31f06af00752041b237359f84212c9d41d96206ede0ab76dadc8047b76929865ad143fe888e87fcc3eef12eab586e80250e6a23911b7e0612abbda6353b66416ad75164f0534801b2a89c983ad94a1b62ba1996f7c7a267cd46314d7fb71d108617f0dc8e046b6cf5c628e8e0ceb4df1e43c128270de09704467010faa8b467c1ce105b36c2d25017fb1fb4277ded349eaf64f3c06ac31403d1bdded5a75a7d85644335e49cc5d1e53569087cb13e4a1cde34c3f858e1e93d408c66f40166392190eb022c6a65bda1bd3115444ec87d48f4e87aef1aff6e91aaf04cf2f07558caf96e297dc48b0353b5c74074226ee6d185376e572fc4692cd3b962541251333dfe8cae50205e8291c77dfb75805780d407eaab52db4de2bd68f44a7d685b26fffda593e2bfb53182f62d9dc508cf583ef8646b9cad6594b84e1c92a865e2532b2243f4c89dae8b3bc38304b4041a969ec66aeace5c24a19b30748bc7ca3856f851609148f07232f1807728ed6bf40c846fc37cd15c3a931d667d6f51eaed4895218dfdbf63a1f161ef3b855233c85f6b9833795f7b08702aa5ba7cebe1ccf9143df59f510bea379886d0ed39bcb79cb6e2af97e9286a33508b10df62ff45863ebf07a356d3d04914dd190d3c9e4a412a918054ff104ed1f3a3a2db9f52df10193a8aec1afd386bfa771fca31480956523d1dd0117b280b7ecf8b4084fb6bcf711399c3a58f3885477582d0f86ef1624fd5a05b3e2b688d4755206ebb20853d2e43260a0644f42cbff60fd46c594476cd1605afaef6a8e0559d0d21c91eca5f9bb72fc6068b405ee8069812d3ef4a0cad19b50cb13c796858b11950ba429b234a2470865ac4e16f1e85cd56d71950e9315f52e67a5da2c3bf021e4b95b6dd0bf1ec61e165656c5acc1892810e7488f18a9315112542006844a7fd35ca3dde141c4019beb5b15ad0baba8936e30810d950edb4256c6ab5539f9f95b64ebb7272c6b9aed7bead4312c4eb427a3cfda23958c70a4022299c16a1d7481adeec2804db8e570997e3c63c00c6ff50e89dcdc50bc6e79233bae0b23adb23c9111aad7c262ba78eab3d9be15c7e7a270860fbc9e3ecc7e4f014abd31800efb086c973c4c1bb945007e05fe056c860c761b67c82557ca2fb21e40632836fbc55e136c961615ca32da1c1518b7517fe790f88dbfe5bb817dcf2dca09e1d2a225dac69d85c9eede29eb2144edd97f3e0cec220f39ef47cd0a41ee324d4328bbccba0678c7ca7adff3e02bbc06e6fbee9a54a681d84016e1cc26c9a8030147a5b045195b8ed3e52ae5bfe28c0efc70bcb5d4b21d4bc62acdb2538140604a1cf3b429b579c30d4a9df55ace0fbd8775283dcac5f239c9a82049ec550ef6bdb9d194d7035692abb0e78689cd29fc0f085db3bdede06cd0053dc9c7347760c8ed60ab3ba84890e8402c244f74db7325824680982e865227489efa4ee8e1ca3f24753fe626bcc00585f46462ceb3c5123a83debe7b6fae5b9537b84ae9b1e53822f61b33f3e6e981ce41c9445c0b90f3ed50037486001f797c85da0348b402d3b3427b503d180339c5a7ada8954a33f47e4286daffd73749239eee1bc0c518c33d9ce6691a2bba9c69391afe9e41294e83bfd71cc3b1c6df246279e888db635f64ab2e8409c634ed04f62ecd547cab6f95b09a39fe1932266b070fa22d65aa3165d8927d649c18afdfc1a2a20a92d7c1d0898e2da4076574a9f8c316fecf828d10e98dec377eee0c3139b4dee483396326e2f3c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
