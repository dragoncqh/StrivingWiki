<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"acab28ea6ddb0ada33683ed5f0bd54fbbd163e5834eace90ed454cde6b249075b8e4311ede1706928138fde54601fa7f5e82ead7bbf03d577dcc7cba43fc85911556076926a877d2de7f777cbb71e5050e676cd2c52a0bbce216cafae9984e53489b3863dd7fe8226daede71f38b459ac6339fb6bc9238d2d3cca35633591232b0adf78da26551a2c4e081ea8ef71efc7ee6f577c7a8f284a21ea8e72745832b437ca4c4acd5339ef8880bdf704002a3627d40e0af02a139720330c574bbcac9bab1aa2e4475f34842486110e78a4217e83a6750cd7a7de450bcecb9d1f0b0aec9752bb9cb2c9714021e4eb2b8a269cdc36a0c147443f4d05a37178aac2ea4b45b08f471e107f6cfef9040105221261b60fdc9fabd21f3e78fcbf368a061c395d139498ba851ba532244f289d4499d58b265eac678f631e8ee420d615fbbb580b778532190db0f1636b1e4c9a99f713439b02ee63511ef77bb7cdb66dcd342dde1807f3e9a6102219011dddb40e58ca01755f16cad75860021153937518d021c4718cc1fbdd403a3e3823af7c522b2efb4f6a9005f60ef26e2967d7e47ad36a7a3987fd62ad6707968eb9298a904e9d31e171e19c826aea6a93c3f1d9133610852658bcef15e6378c2f18c1335db5e3600df87c775eab3286b4d8e5ca539ecd1bad857dd0998ca4a3b3ee974f6e13dfc0428841fbeaf5bd1af64acf782c5da661ea7ece86ed758afa1b7b97127dd33e620751269f9c7fd5d3c043b26a345157e26c966b078dfe399832e2b6e213212974e6a6cf6d6f96784646a05ad203a84c794f075b30dcace7b7032e3754c9a69ea1414fe925eedd9961b0f1211abd223d880767fe729cb9adfb06f1d357fbc5c5b1be552ebc6fe233a2e0ba40a20c459b18aa3a5d27becb3dacae03d369db1e71f158e052d797e6b9b6cef5a48e488128cb64990960854afef7a98913646a4762dc086ce25765e795ee1ebdfd1cf0fbc28c32337d559396679beaedf71c8efd77b70d7af3f6fa020f1a2925aa7a073ec00906b4bc9a496ddf47e0130c301e6ae05e689fd0e3965aed8a1dea1925854eebc640b88ad376bd5f6588bc6d446b18c297806a7dc8a27d622b4a84a432e2cb9841a83dddbb769e1757d42f49d9b0a8a923585b79e4d2df158ac28ae7c8c98aaff2f20766f85da189b9a26cfcbb7ba39425868e3e73fc65e275524beea002c22e074783e25bfe39be36a6de47a925bbe054bdd3693a915505335a3f738e3015f03f4cab77e6d8c8572dea9ef49b850086634b6f01706a70b014665921899c6e5177aa876e798ccaac0918d57b33647edf642997d71bbbab8f670b6b77b52798bb51a99c1a5447ab72340f1564fdb78d0cf4dc494cccc508f3adbfdd44f5ff87f99b632f77f0d367d1912b94df3fc1254bd3c5f70e9c8152e59ff646eaf59a664455cffec997b091060c2ef71b1355e2a8b905bf2f7a404c5a28f1575cf761256500a40ef6c984f06cb42f2aa44a41bb41e0cca2da0c975f9aa2d3b687e320bb491a9b17a44c66103127e29544a63e92d0f6ec7fc3772c02505fa7dc06a7ef82fe8df8c6db0ef53296a5bed58bd1c6726fe9113f7d29f5fea879544948451652c1f72f933462cb2ac092641c087c8775734fc29b7cf944087532324b8f977f9df92a18656a06f2162f4c09f6e35643a202a277129378345938ceb838f6c92a680af573d65671b28061cc58c157bf729918202cbd7ec459af33a0dfc23dd6a2d68542ca67e130dd14644640f101e22f632fe5702b8c4507cf017fc2e8a3725c52039792be4408f7701a9dafa1bedea1d3f8510751412a7e0340747bdb322b50e28fe88df3ace34849235749d01abe860c678656db79a8f62e03bb3b0213c8bfc37d3e7337de27785e56e056ef263aff699aaae203eb7015a03ded46df97f29aa308b367c6c95a00436810c9d6984a1942bca00582e082a3d09795ce6769dc89cca0843917ec38810c802ee48d89aaac06ca9e6737ac8bb3fe5a7f831bd91242adc68b7d7970c28a43992dc766c6239ad649093fd94a2789b21a435701d6e067272d7985e6f935f4785b4a10515c592bc68993736a072ee816a2cd6db12b3dcd58f5777d7139e5beb34708a23f5c36d27514e574fdf7e010a11fd136fa0cc63ce38864036529b93fbd2b136d70295c1d2d2b67d5e9e79211aec9a624de5d92539ce75b49e12fe49e2a76ffaf24c68f958624d8bd063e738ae92863c8af5d521784806bb7c8092603caf7c4fc0898ebd87853a14949643a925bbf59c2b50fd2533173c8a51ba31d2ba6af87a4c6fc34edcec41547b1741c99b66ce0e373b85e8c73459be3d418cc96cc311c8c5947faad0c0bc6ed137008d1665c101d2442e926ba911861730ea65a287bfc93f79479838df550876df090a6b6c72d412cca2c8cc5e3d63bd6804934d993698c3301ee8c92f3ae8368bb85dc356d366392d8019f775316aab8ab9eee92b94bfdad53c2266e6dbe3fff3a4c0b394dcb6dc5ac448eb7f666481e126b2c74ec3c2da81d8775f6eaaf71c25e2eba9e71f57969ef972bf771d025f0c59dbd77fe2881b55a30528b1767deedd89e7b47192061078c09343deb3c1b13d3b7c5c70256a2fd4f371ce06fda10e556cf4468e6154da6b36117345977a60d4afeb05890a9e8c7e0514742adf3416b2d3b3ddca6086920b6eb3b929364586caa1c66cab969a4f38966f0deacfb01754baa5d1eb85df2fe6326475aa5b98ed53ad317113d36fca6a863c1ad8e1fd99c14b631996ff226c285a3e432d0aea8e9bd0206e286dd219982c855423e820c1373486f459d0dd44265132d8703466e216436f143bf3c69b0520bc623d4e8796939c728a3d16c25e7785c782f148537d5f258680e1bd36f7d54e1372c42b5e0342b993f6b94cd6b9d2da9a5d5d5c1aee4875f91afec4eaca5cedf089bde5cc31d374645e7fc86ee4b6d95bc370a13b9dce380a5ac106f80cd5e1cb8bc65926f5f4dafb955cb5b5a249c8b9babce06a708ffc9223625368b6b7523a5caf492e0854f0149b97ef643e8d4dad5ae13a685748f2a36fe51398c4656c97f6cc3a11e3ac4bbc6b92c54335a26beeed6dc5c8b584d4e0c2c9e6046e16d1ed1d09868f09093c36080b027fdecfe7071489054258c9e147fe427c3b599521ddbd98f6415abced471b3405810d2274ec92f86429ee0a0827b0f0dc51802f7112902bd3601499a0f90d7e4e72ab27817980686b9bbe812b5095a4565976e5ca6fb0626c3945426febe24155616287f9ba33b71ef20cb6faa066ee16a0f5ea7053470545be7dc31dbe0c80c5807fe714b9caa91229c9c3fe411467a3b10e5883855a77c31751265605a87634ae5b4b465aa80562da5f4d524b261712e4c5fd3956eec075c341959897f9e7b5838e3b7fc2e1aa3fa1a9256ba467e6fff18860f149ce76806e007cc865021569996a2a31fa938b56cf0d2a9d923f909eb4ae985be0fbcc88388af83ca8f89e3d4387dc91da76711cb721f570523b70201c22f2bcd0beadaaba8a9223cc18fbc0456d474b7eb0d79aa5b3e9cfb536b3d9967f8e69ab65d72968ef16a5312ce1da3b5a8a8149be5b2222578b389c1e2623782ca9d0b8836601fc4c1534c77fa3a9c967d2b1aeeed88c09b71d969772ecf31bd2013e796cff622d97e1c743bb54f259268ea4cb2cf0e9b7b0c466a93759ea66f6753ae070d80b249c9f59f94f8719f50cd5a99383039285a9da579d8373261af6a59f5084b3ce379f1a96b677ca597e5233af5c300f464f88358c78cb64932c974cc0077f2221be4fca246fdd9d8a752532378a35576e1dc24ca514b308e6d5b6111f586687d1945dbef5bb833f9e091947c48ef010f7f083e96342b6337c176fa36b7cb7c8e95f5290be413b1f5590d8ad7a2354ec1c675ddf78014b377cfd8439b25128776d12dcd17075c0280c0f77be61957feb6f0ae8423c47b06bd2af13125c3ae1dc91dec0fda9f57d269dd5cfa2f042ae30496655f70d0c73e62c12947f6a8e173ea8a9dee75293526470c720775f1287d3af0319397ce50b5a07f7e38f137e8fd82723c61dbae911e86e5aeac5822563036702a6698594b708410f110f519f1eca02dc49183d0bd197a5908a29daa05958209c84458f9100fe7c57a96bb902b0008761af7fd4914c5add09c742e7ba07f1bed48e6a4a9dbe4339d79635aaa0730aa55c6d327a06930392f7dc4e14a648b461bb5510868bce84896a72ac239802df2713bd3d4b8e191c5981395ef0526d22b198bcbbb248e0ef64a781a70608257af158a54310c3b31050409a503d079876073af890cc4c1f4ea98e97d0c880354b2dae055a6a13ec34af291cfe47d066188708a2ff2edbc754c4a46da7f397e2e175465b7416e9a84a1b305a99f2bf60d81034fb5a0b5333bf6cd3a3192974b40502dcd8377e7298d5695c428f8713d7c7de11e42e019cf0c7bfa99a5be583fe8f81eb977c8cc9a62f65f34f91c573d350a2c64d51fed6c7a9ffe9c52fb59e660b28bda485c5b69ab806ff58301d54c2b9073088437947d5d37ffc2d46f0cb896147a0f37ad20999bc2d395c42d19b6f7c9e0c6ae1eb1cbe840d5ffd4491fad322e9e0a858b9a0cc2c598dce9bbe9d01fbd58f075a30567a1e591a261f027d3aec3ebb0e2ef1db43f12f5bb840128eee25b5f85e18d9afad22bc78a2b5ffff52a3ed52710fd2ce87571780bb53eb822f9614443c974ba82ed4fc4649b5b4e3bfa994e83c7e91ca6198a231864f2bd2a7ad2949c4bd94d9a9714bbb492ef7ceeedfaaed736775f3da13c8cc3cca28dc898436eab2af62b8641c5196d2a2b0c3378edb483c9ab43305105e8594d1dc79c55ab3698f9dab8afed7843b725bc2f3850bc62179ee9bde183bd31df4d7fa42c26081c85433d4725137bf115866544c62447bc77322172403fb4b66efdff21911ad2f0499380b73a7e9b64fcc63537504d0eab6fb59d607f0c711c8aa221a7f37887a6e24927ed82dfbc467ae3da3b23e497bc1543a379c7db71b6efcb6a96845ebab8ba486af1d93f39ae99bba7b47145c404a580782230f57c86340bc2a14ddcd21c9e682f76ea23cc8bc57697412dea6e51816fa7e945be9e14f43e1ea0dc29d8973d01c123b044f1db2dc5bfe68c657752150ba9bfe7a4beb21339c8b43dff9e89e116b9b7c56fa48ab9dac231a987363cf8f30c9d185df6ea6bd7a8e9e392be8c8bed6c5eb0631814c0b188218f18abca22fb4b6c113c32ce82b95671534ad12287edb2222e2faf7717ebdf5eb667d0ab130ec5c111d713e07e922f25d8e0c8b3520dc3e0e8aff1078959d0f753c5e47f23e895ad72ca0101dc653762614d4c7347d08251113be60331a44d44a939f95c7e5f76c34163a9cb8a477b5286ec97a06f9bc2f2cfe4f49cf1ec05e201a76b65d0f703a6616920da9e49358570b5bce76219c16558fa9f49de7189d5eabcdf5a04e00df23a5028c26c6871950857277d3cbc362a64d75f674ca2bbad168bd7c0a19a315157785bf802b80b32edeb7cfe99cf7e4e7b83e44d40d533454ad1911ccbea0e5db25dd91aac973696136da95e5133dddf2d4ceee50ab74bca68dda87ed0af4503a2cc545dedf387a1754a2e19a11d283356758f00011c59cec322e4f978b9afa7a8d89d1ed1c96f9f9377ec0d23a836030f00142dea3b61a3a376966d2341122a2935bfb4061417ba49970051959e4c27df84a0827ecd8889669ce31a80c64864edd88b10d0596c86fdcf8335763203bb9ff7f4ef2db150496e652c9bf0c3c0ae8cb2e8a60a07239cfacda641c60bdc9e1b2102de6945741ecf660ee1836d8c55db1e38679fc4efea78587647f242763828e0c49616eea09d8131e3dc2a70ae345e68f42bd71d738e1ecf716ba56b52eec2b70f8ab0ffd7b23c4175b16efe352e1c57a6ac402f716ea977a212c80e062f0ef99ed1354730c4677f5328e0816ea844090eb01ef316c9f1ab5f44d8cfa45e1989829209ed514cc21bc499e67c5aabd4b961303a8cdbe79156a17de6f6d8357072b3f4b93198ddae42bd9b77dc31a9eb681c81e96d787c183719b28a3ab15843605012b7ced1e4abfe53159d69bb421c17159157eca545eb871567af9567a0be3f6ab8b2dd5d82f3c7c43cbd59f9b0d4e3b974b86658cab797c58678703fb2824e40d5b063000246be853ebb7d2a7c4e58a1e1b9b76e278195fca0b938c5644e4982b7137a385dbbd1f59cd62c6a705cbeb862e515200803b573c62eb326a30d3ca358447f9a690b3c748ecd45f1e0f572ac787701acfed53c3adcd06bbbd6393ab46c839b5126433850dcb5fe10d00a93acd00477f096a0efd27da0ba6675d9f0fe1468fc9a26404cafac04a10d8523a1d67e30173a400c65002462a777c113721826fe7ea4052899219b80bd0fdb5baabe0b34104aad577624c724db368a31519c9b1dcdb4e8a3c50cd287ab996d60fbed8f4b98adaf5b3fc1ae405e2161f82d6691f9ee8c4a4620268d9194f164c7eeaf522cccdb3f05af8abe17c2a9b9acb1a0cc9ff8e412be72946b030f7c5fa31a1a0a3e23e48025a85978a12fc5cf27a50d2712e5af9db24202b2aaab24048c9148977d28af3afd624fe5e179d520d29f09ffd0b82ba48f4fd936b3d9641f43d252f6dc076b70b9538463b014b0dacef12f8f9f5f94070ba193a2a9b96eb943b7e3a2a761ad8616e827199b7a5fc1208554aff63445b8c7c06081bce53fea548736e6862e69bc666f318b8ccbcad5c64becd1f876102553ab198f86da5940656a5e5fdcff29525bf0e1612b434c80d9a4a86ad6d71a8bde165486f8cbbd2c8116b38372ff7ceaeccc74872695c46b200c83c0e82f104669a4552b775ca8573f88f20815f57cca13f34392112a5862c3161964866b832a3d9145b02252f97547a85bbd1b1416d73f5919d35317fbf5bdfb6219a795c83649f26f208d3e7b286254ca161ed2e90f6c08d738e42fc676659bbc606b6dcf40fc2c02cc0a918ad225284cde1adc4e7a9e31f0ac1dce8c816cd21360dd39ff0c75bcc5bb1e2c8707f2ce957acde31d3818c19d13d86bab4c74dc0250a72ff365339a2d3b42ef8c45eea1bcc140b86cdb5873a7d6dff1bbe83867eae7a405f104c6cb24760d9a37ea71ff0e1ff9eca22ad9f02afc7a6cfd736f1bdea07f93736d378249f3c2fd690fc91d4e544d9cf96403d0b907fb377f726f3572aad9a0673383c1ad717035252e84a4ba6c5226247dc1b57015d96db1ec14f53cc162231ec5605e44344301b389fa20080c3d686e93083638aa0858241915a848c12aa72a85249dc5737758af18d8b579e48fec8bcf7d45428f228538e3c48d365112a795192833d9846d47fd936be7af338d481e6234851d8d775c7ccf07fc29ebb55887c7c88bf284fe5a3f6fa1abeb09e92df75183836e7e1a00bc2695a457836132f97fe6454fde43da0a5f92e43272592639c02bada17e0369b1501039983e710b91925d1aef9fea8ec3f11db750b9caeb9a4bc553f4dc9a6099e642722492505681dd2efdb4f9ae804e5fdf446f2dfa700201c92a1a8cac0136879daa8f4830ead51765f3eb5aa517add575dd56a33a94873a5a7ca2fe6c4efa0c43c4e63be39a597ee35100bc92b75012266f46c919f6339ccf5dde69935c97cb8a9f74d32b9c34fd6bc5f6111a41f419a26dddd446d75dc8b3bf52d883364f1729be9de123ef4887b3e97af14f8394ab9b35249e89635ce1aa5c5f10454d476839e1bcfa741a3e65898ca4518c8f60fe64c2352a6cbe382256418f6aeaf0026dc2dd0efc6fbfa6331f69f8250b8da1d581a59f566231d3dabc14a3393d92c3755fc8eaafc37147706e7b549615b0333f3b7d96a73961807ea0f17294620e73d1319bce3e9741dac6f335c1467551d4da986e17e170da79505c1d849df8bbfc4da80bc61167ac254b56bf99e923ba965c04db135a8d37057ac698bc07a914d9ade88a5009b467670f0f925bd9b49feed19fd883fcf74b8b3fccf8ebc22c89303816bb8573a26670cad2d5c85c88e864704c8d1307021cc484a2623251e8166f38c500c1ef429cb2d0e4eb1827d701029636f0ab28130d7891be15c995af83e1b3acb407daa20de4147fbce00b719951d0076fdcd5da992f9a32b75574ef61f52ad1b59e922e8702422f3a7154dcbc3ea4d6fa352b023bf7d7742f3714cc9ae8c4f76d0944bfda6fec50c392720bcf63153b1f1efe88add2b1af952b5d30156bafcd354d876e1bf8ab25c0b820387e93bc958c195f8f6ea568525f4863614b1e960512423015d2a513f2bb4b3c962dfe6177e87706b56285b0efcbe5aef0e928500bc0f29bcd7a84563e09ea262537f771fd98d772b357398b941917a932e7fd28421df31f84c2546f50cf9b2c84061697632c79d5459762d406acd0c3565969c2d897955dff385ff4600ef732a7ca6fc594b931198053d04d7c9aadcbd8eefd14569ff5b028311f44d06cb6688a72645736fe0ba0fc5dcfa1befb842b0e8b503eb0cfc185194f6dfb670ef9f6aa849e3c79ac7cb8df32b3be9cc1811ef6cce4fb9d5303dae9b4d246c33cc3a9aaed2a1520df2c7dee6b51a06a5716de330ebffc9281e859ff730a380cf91e23942f0a1b33c3226f1613c8ac2e40cf1e4a9ddce6b22010e0786d90533e81a1dcfee7d9db65f7f5dbbbe5d3257715ffda519613150bcb002d54aa586edbf17d6950347945689c08f0df5ed16ec35f44906f412d4bdeb8a6efd76eadc560b42e59c7521f8e056f7482825c40cde5bc0d5268b96993879e11864102d6a728ac1aad7f0d34f052a2f1c27f4e1b2faa5c019edb0831586899da8ce39d78df15bab011b31e3930a289ebf37ab706e379dc5ddb9cc4aa1baaf4cc99ff807c101b6c8995102fe5458a293b9f0ae9343f94138e665d2f8a6071257d845150ee8e7f8281223ffe80bd5898933452690cfb6782d6f0580065f507f501d7618ff4fbf477af0c06a9641bb836daec9d682307e34e6355b259c0377bb9433af6b0bd339c92c2f68063a896006315783b874ec20d38047e68a0609c7685664812be117eae9cd93177df44edef50445053d3cc9cdefa2612354a51fe07949be8f1d23d4e5dd7402e4d99ab2ff90a14dc902613c09fd563f3e8fd0022a1a6503cc8e54a4af3f84f4b1a62ae5390c1ad7cb0093c30dd1fdbfd568ed19f9d3537961485780cff34a2f0735c09825b536d3796cb104f3297fda130a3fe37fbeb093c62f933f8b5f71734d931d159e2a367c79cc9e9e14a1912b5c3b6c819cdc8beb874acf88282418459a208beb0bd2513bb5ca987e5521f104243af34a4e840ecc9ff126fef4302b5ee25a9f5d7474e697250b2ddec5bc4d56a0be7ac4b9af6065663de05416df146356c5128706bbf45295986e0bfccdf8a439b166a7ff4639928f0bcbe497050a36337c2fa2aae1adcdb5e1c4b943b8180048b1130d405a5d2792a4b845f77fc73067d89d48a0456cac3e9d43deb29ddd83fe5e8c2f16437d62341670e37f7a000783905ad761d5947dfada1e0efb6023131624917c3073edada04753daf1fbc6b97e3d46f0b376a42578aa17b9347097cdec36156c60f44b466480555b1b4506c9cf5edd2963d85c5872c7b99736f4ffb77331fcbaace2c4d35b6d34ef52f9edd11e7ecc3f706622d63b1df590f3ddb28b4e874ede8980fc2a5da7762eb200119e69fdff6dc9cd31836c80fba17ac3d1e6de407a72aee9586b7625a01a5e3fc45d016bb7d7de1ef387009625f3261d5901cf2d0ad98401cd5ae185047c308c8f621a46c835797f10019a78b8dd97c59c9ab78d91d6f15fe37e499d6490120521ed87a0d0cd06f576de5d9085df3e554fad45633354feadf915e349d5e9e417eb265d43b6927942b7774166fc9c6e7a12f388541321cb4b2bcab7f5e1926639aa46c2d04a3041ca7316e7344179540e5fcdcd1ac9de86b47405115bf681333aa99ebace6d7ca753ae3d5cd3dcd092dcaaca6c1b85c90555478635ea46932e7d95863f3d4a2bb6def3deac48f05c48c5cf3cee78e5a7f3d5738d4777d272ae843ee4e3f9236b585d0f4622f93d90508b2c0780568f837329f7d1f22f2b32081076a7962584bc3b45c5cd2a12d256edf19dffa699444a8fbdb3fe81365554988bf8176f541379bc5ca72ec651ab8463ba1a40d93b83500bdead89a228d32bad8ad151d861999beb9dffda0c75596e83411508e3414c4a6e5a9f8222f3b9032353191a98c51018f066dd7d08ae94d8067497c5847c42efe88da7ffed754f5ff31280f3f8957ce23d1c0e272b5b402b3e7d5a5e4e364f067b39f7c4f416a7ae996e6494a59f6075cbfb80f839152b92e3833c7468d9abe57cec84b00fc6b14d4c83725c7522843bb0f83ccec168baef217bba6d993d149ff06f60e8e0759653bbf6dda3037b557bc2e5ccff379d554d4532f82458b26663eeba689a4386a09040b22de1b56b4301d09b4e3076097ca162ba7bd326cf7094f997b0b8056baf750599eff70b6278f4570ec669978ebb0e0be74c1ef07ef011756d80e4dfd233e37d3dd94c697d51e9d8fe619148e6bb58c2da30cd33b7a7d8bc09ab041ab73d511d68bcb952287272d0a994b158714e5883f89376f7785a579b315e5566efeb9acaf5905abb9c6c410a89b71f09cb36b2a9b423641603c50c8f25a8f87b1b51d64d5750c0f121f3003a2a91cf3f5995e79aa7d89cfc53d74299c78ab9527ce5b5bf5df9c81ae27f6179e79f3114ddcde6c652a0f2e5bf1750fdfede107d5ffdb6d49face4ed15d25af6f2e1c22e9953bc212af18809eaf62b7562e633d7e5cf07e7ad75a0714967123c74fba53d9ae3f66a769831e2ffadac21eff861b48b74cf88a9a472251a39d3e150e476502154c91140fc6955af7a103f199df129f68c1309f282064114c06fa5373da918bcc2b610b7723dc1b1fbd9def601d47c61987eb3033f2f92e9e3b2738d2dee4425394aedbfcb252464ba92be17002bb1747814cf610bdb009a92c7a8477f30c227e5c7d025dc2a1f5815686cdbfe6b8d49ed25228353219c87d8bcf79f9b43b3604f3b7e5d02c41d9ff5ed59a07aac75266d23554f6ad1d6c76dd430b6618da1b0dec190b34702fa2d81a26d850292a870c469da8194fcf263387bca8b70d7baed30fec1871dd08d30b484b9ebe1415e8e9d4169cf23bb48c8498cf10a52923746ba857a1ff3af68c743ca1c71f7d58298a39343675f566cc4654049cf6e3ef5c85d5d7919db413490fedb1448b56077530f1aa598cbbbd252ea3655c4e83ec33bdca50ec5b6abb5b2c2e20ca20c2a1eeff07be99475e8befb37f1516292e7360a07b36644bb40af6b379a841b30c82d6f6644fb9ca298b0972185ed4aeaf73ca77f53d74ef28d1d2c14327b8e0471323a088777ded66405d64090aaf3315878d9f55214ba63936c4398a46e9f8031ca05069178d42010f34de1f2fa6ce5d22888832784fb5d36915d22215a9411ea2152f3ab857a6ad96daf8309510e866c24f1a611fa8d97564b9834e237ab476dda292bde5bfc879cc370df2d09437e3e71ae1a49d8fbd1103c15f1bb05d9e12717f93f6f24e223a8e10b8449cd05ee4f605c40a74ec66db2376b96e264ce2dd89d096a82370684c7feb3524fea708db3cf39e85b64322264ae2d05459ab74d24b12d83e0c3628558c5fab50fc04210d6a89663a02e31f34253e782aa80e1133d9ad22840e3764e4b8386f1b2afc3ed8030b4a0918809d9d0a66502ee29f66446b2d156432f18db96954b1038a613d848cdd1f2513f3e584b7d329be3546c1a30d58c81d67d966861166df187b9ba8c0f14e08d305628f48407e6eab88900d19020957960184355c0d956c310a7f0be6b7a06eaff17854e3b614752cb8229068c01dffec0207370e51837656a593ab8acc1c0fdfc867a41a03ea777dfb46a2453113eaf4bd780db5aaa04d1b39b2185770ac237ba734b87fe194343b4db673aba38d1aa4cfe4a2d9cfa34e7146497f87196f3a1a757a28ad4353dc7b2e95ba15bf4a13c07f7875f53602ca00382b58360806dd3c357cc36235cdc342895f48a4d30e02a7e7587edc97f8ef4d0061782bca611fa0ab6b30d7be1594c379222c251bcec0471b4eb4ecc9ff0b9ab2d86ad80952bafad1b71d3d69ba4e90c8c200033a4f5bf4d14d3e32d5dffd748e81b267f111b7f461c20eeb567d190a67e8260b220bc4146ab9b8e55323b0aeaf2fcf529f7ecc549e7d245cb28fa229218ca22a634dd06fdc078ce20b4a3e15d98dd6c1491c43a6ca0ce6334fac29d282439c6697973a8098a79a4ed658518c7f3ed4d4dbe16845d023e56c0c418f06afaf648af0c617c42e13291ea14fc100a970490d7b5f22aee1d88a10e9918c8398688c5fa3073874678a0c3660058166a0a1593d6c4cebd70c36cef64136668345f9d760341b16146558ac995f3ea73da38453fd4a3b4146601ff1e9bc670eecc3fa72fe9ad9bf4d56a945eaeb3409c36ff0147b930005e508595f3dcd8561bb013f9830e1630788bd6b35b07fcc42e9bfab1aab65ba0308b571d86024582297d39ed4d61ea1f6bf1adf4782524bf7fe14f6120c51a203bb7a1f71ce7a326c1db155804b42b86049d0de1e12272ac3b675449c15966b5caaf0a1f47b551165b3ba9af82ef91efd95eda77af6f7c3fd4b03e78973965ac43fa64209e3319dd9cd81354b9b40e3d4574cbad1193392f1297764d3b75fa46ee458856150897f20783c6059f97d0cf2438fb86f65f7bf12a4867a81346a7181ef64b5868d66dcd2ff9fe0f0675f10473667987016b5a4d48d8ec979a7899e3895f3e7d6a24f208d07fcdef476afa3b48045544cc3e974936c2213e895a1dd5f2e6afb13ed0cf6ce776e0cf978c4aca1ec70e57516e8a0ff1d0e4617d36817f66ac67c6d956c5829ec3a019a3506e5b5aa31974baa3a7fb4faa4c21741f69797fd20e631a5fe97994f1c05d19891ec886ef7f184a53947f502e8fcb4e581d9c291f86c05162bde3f79ff46e4b32d33e185412e7b4c2d539735fe558061002cf57ed1863aaec50c28758a20ed3cdf2f17e9a8b36ffc6a5c0d44f14874b6a96264f36a75dd4baaf7b72c75059cbd239194e75befde37b22f1f94bba07a256fabd96e45353959ecc773ffce81c32b1a342057c5477adc58b0bedef31230e5a8a1023294f8733ecdf7a853a79d8fa2e853334c6bfec99a503c4bdedf3a08d38a0656fd3b08a68dbd17933dc6a6cc37875a500133fa160e6d2c93bc379d9a49ce60d798b4bc618e1cc72a558f6b888c361c2250aa41f2e24b2a050996bb7188db81401c1d4be5fd46858fc35f71b0ffa6607342aba590d72c4f275b7d1cae654d9d68a3911356ceb2f647a6d2e947fd63049cb91f13ae7044942b890dd7cf9969756308db5b9044343a3936c0089a58030871fbd28e28c23b6fadb6e97589d40addfab8532d73bcd24aa2e3518ad928c0eb22248ea7f0203873eb8fd0c2feb98eebca5e558ded9d71d3eb8703dcd41aa2cc56d45d30b6b2a11226b71f34cd6a28ddf3f8e1598ff7a640f9966ec2ec4ec7659aa9dacf95be9d79a4310edfff7bab3caf2bc9ade8d8fff0e41dc46f8689f70ca951b8bee484e5908d60edff8e157bdc14570e5563ba319b06fac15820c9736a44f8ecba8b44d0795c2e818d8266b7e42d39fb23af7f52735fd81fd8b7ad59313cb868b5dc22a8dec692c5001d1c7d35d5aabae35b302405d9d98db45d17d83452e59222ab65dcbf3732ffd1ee9bf2ac2543013ca9703e8c3c0368fa76f581178f786a27c33df3aa57a585146fb899ba69b0c25667fd6f04828a1defd1c262c776a5349024a47dade1c6f3691670e171be935cba58163249bd01bef047bac92aa39ed9890e21179bfff572942bc27df69d4aedb99823f72d4a7bcecede0c6235ff984b2ca957b2b531445fbd3fbe42052f4dcde3e9ae81ce643b76e81b8d2eb81fca366b3d6533b3ed9fcdd39b37d6518b78d9875cd69a380715275edd84cdf2a031afabc6a5d328bc3f21220baebfcf1cdc6507b5b4b4ed021bc063381a9e43d50b4b08f0b488a5ae275b8d8892bf1d9aaad0e80c8600a23ef8cd6e28d3dc99ef40d7150d6410b7598bcedb4be8cd6f330e7c6bdc8aad7b5c4e7728b17f7b111f518bcd2f687660bab6ea5068460a07cfc60864753a134093316e0da45e3b76bf0e45261d8b65ebba230fc68131f31ce8bd99029b82dceccea2a1c55bea2812cbbd5d6ddaf135d6f38b3a15c6ee93b18189e9d7e2cc748d72ae4f4db317afdfb400c9aa494a9f578c9ffe1937e84162391297235c99050a3f2c4dd8da0ce365ec6979ef5e3a28c48dffc54740fa2e4842b2bcee6b20fb34277409caed7f15d11827669412e77c6c29fad480b84dfa94d62e2866c0519265fcc854fbb12136104ad1e618de9c93b1614586b98f4227e3b46e5946bca3b2e08b20e193e2566066f7ca2a2849c3f28cf2966fe49ac368a65f1d42c649b78472b8b5e5dfbad0fb3c6688363448c2a7344e226fbbe588638139987a4a53080b1f8f71e216f863c71d9dce493c1ee41b12848d4bfff47719e8c81aa7da9e76a8aa070a511eba9dca267f37224fbfd33f7a060bcd8644e318dd4579665da02d340b6c57c6a58e3509392cb600070ad8ed6222b872569e2c43b19b92b9b768272f19d500b7b42e2dd0461dad795467791dccef6b1a6dc79d20acf0616bec1a847637838177251bb6b91fc81bec34bd347601da1bc5e758b8364416895b56a25eb6ab13e11dd9f3519b2ab154097c445304cf2aa42e0319a1f0e5d2cfbb17a12d75dbd42c4505916c2dde0bf543c0e946f6e0278f84e96705edd73132029777a57c37d1d48ce719619f0d27e67e7683424f4fde03f5713c1cd316f2f4c14c5b198cb650718e27afd0aa1584dd27544399c36396cd994ab0cd536eb439d34eee13e43b72741d6cebb8e9b2c79f87237b97e269a2a4fd9aeb2700f90a3dcb49ffae8e23b12231e0c5a129566432414353d26a5466de5f5aa0db9603fabe214b26050f032fcef84c3dd7d2c4771f85740379a62d38a3c944ccd712a434ceb98c1e0000fbc410430eda2d0122ea4d45594ffaab680c489ae114fc9afaf3d86d9b7bce03ccf85e78f67ea759f8c7e841640b95950b8a964f93e49ee191a0b85fb06dddb2d921e8a78fb051d5b0db4758fa00cb5961538dfad4ee9bc9128dbc21dd8e22ba43693e3e38ea0cf47c721b4aa3a4d58261d40680d3bca19742301827070a0bbd5d9886c6e347cf71db860b4c8922823d15dae4495bc68b7d4226a27d91699e8863cfe0df04adb80fbed1a9214a34930129585117c757115dee951124873f877cd9e4ecb6b90ab6561921295c251f2ba60353289de6cc50ad385537d990dc9777d18cc20b0c178c7b9ea16f1736516ff880586f7e93e0a400789c071b2d9b7ec83502050998166e75f94cc1f9fde1d1e8294437bdb1d26e9a90bcba211ccbf6ac0b8ff0f7c13280df0c87325794521f3d15ef97ae49888a82a807235f0af26085169715ffaab292ebffe1a3dc7e5fb78d7e2a460e0181097ce087c80a2c737e2baf9b8277c051b3a2e7be25bbd2da9f69430caef07ccfd5838b91022bcaf6787e82a47dce0e0226a880e2778feb51d19165987edba230413cf4259dad61de393871304e5c6d58612d596bc81a9dce35c811fdcf7f00152cbf201cbb06fef30dcb5166aee81ae2165ef0b31fa41defffe50c541f474904a59e154abbb192db3d7c52898e26a6a25fa2688d0f09c9267dc21ac937479ed54a236641492f8a186d8151fbcb350560e2c6a69c1611aee8add5c6fbd68cf18365f125b7d6fc7f9cef0911ab3fb9732ea59273883c151fea93196a4cd5d5ca6c65ca7dacf13b47562f57c9eb3a0f2049aa3df77493f6af7a0c75fe2c25bbdff33863d3f32349f09ada9b1b8f7667cab6a9b2014877022d705e60f872144b80db67546a3e97d1f67d5861f2de70e8d888a6dde4272dbbd07a4b02f289cc2a83810b4edab4323f8589391b133282e750ce5f8e106b80ede36b7f5212212635ade2dab0dac3205e39354dce8438c95218de769d2e0b9124f5ee045f6d968d2b2c46a8ad12a407d8dab224c41d3ee73d0c37d751508145246b3bf68a0e6b6178dc4d689589efde85fb3bd3436ad988dae944cf0a7bd5c66a400c440f87e4ba90eaaaf216b77667efac42abbee6718c0be522877c734628304283f7a5d992787d544d0cd53db1dbe8de53f9e004d0d9cdeb5578d33fd707da700671e8258cbda2130b71d9f0421ee0def22997b2e0f828a2f1da79cf1a754006590b3f65070683cbdac35d593c78bb4fd5b9ffad4c393fe9e50ef21ff29d7b77ad3079fee40bcab5524bb6fa37f299c1c926e879b36eb973e44cc56f6e3afa8581e20a17037749cb9517fd5af6f0e610c32a204f7f825438551200dc435346bd7586489d1db1da8cc2d2b967a10167171d77f77450b40a02244ded59fa5ed0c7934b3c6b3609d78ac4f715f42518ef44c429944ac635b2f22d0d84185947a8384313a0bd9cfa4176c61c7bd757988eb2cc906395721a4bbb65121af954105a57489c911082b7f436452be8bdfe5219f589a70743f0a76e9e43b6b8394f1a84f69da7e7dcc88e05b970a503414ebc0db25f02df62c933abc9a65208194112037075696eb8c4cf89045c922a4957f52311be4f4f227ccc0aeb08fb747878a78658ac5a35de44c5357178dd684034abe85b1969f87eaf668d7b246a7131d418912adcbe7246782e69d6f4d50148ecd13c042514594037ffbf7c4c8f9788d296780f784588aae169dab37976a64030a5f9449082f398878982c94c2b11f96acb97e1ce8ac8d73bdaf02745a1953fd1cee823a750b7328d0dcd6a47feeeac44e7d8b12158c451403b9ce4f6aeb6e0afc300fb26fbc8f9a6fd08469568216eeeca23dedb830a586f613bd3842b020e43eec7da4eb03f7401360a5ffb3de605646677329128f61bfccef8c2cfd27349cfaad995390fd1d957d71793393dbebba5c960608ef485f9efed57257e780d1b143ddc4f5e455ea6219381fc49cccbded1d40cf7fb6690e605928e1966664a0159caa8e34a25ab00b3fd07c6799eb3a56ee167ab395effe0b129b44ba3b38ebcc74c6c0ca9df157f3cb8aabfbda5ae21c491ae2da9b08ac762bda35d41750662ef98eb9a7e460489344d13b227c2356d8a1a07001e709511b8f17946d4fd10407b8cb82401503a67070e68b167bf8b41204aa6a77031b680e678e927fb1ef8604a96cb095a1d71e3b2746138f818a034474ced62842aebd59a916217a4495c3ec90bce08718b81308a49114db8b723a7c5229969e15be23f4bd805df2d2ff6ba66feeff77d2628e22cdd29ff8b39627d41c3e932ebb27ae1c9eecfcaf34a2798be2dd8d4ebd9012e4f80908c3225f948f07517992a64020ff2ff40311d72e0091ada295de5ae4e5d0324fc56f103904c54ff4c67bb9051886440b064af1522cc941893931eee7716fb5894337e0be56fe377f9c882ae4f7b8d57049615fb499ce4b826196f5365a3afe17e845f4764a9e907e7a3a019b4f29260d71b47170a735c2cebc9e0ac0c10f5e60da704192b0e0a6b5824471ad3f099b0e52c410a143e9d341ca7e00be5edf5ccf57786b503faea20d3b1378cca3bc5ddbea6162c0f824e7f82a8c336b11826e64f166d0a6b2a2d7a5284c29fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
