<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4e4555ef0b80822f4f1334e1211369b036646bf8edc44135347676daa889e4dc99c27188669f530b2fb16235f4396767c3d76d8481704c49bf19ed14caf4f2314923b244832e7f1cff20d315045e2d53fd081cd2addc9840cf60a171314bd4ffe133269f7c578d6198e6913f69b8892c78736f97248b5ca7b484fe18e5ae1cd886a6313b3a8c1b0f28534b7e48c346341607a8fdd756cacbe76ee5f371773923f494745445bcc8ce0b0354110f85f3922594a814bafd2d3d7a3be7b31b14917fd11ed1d2cc353e372a9817a22e2f69a2ac5bf5bb0b4a46e71e154d7ea4145d4903d521bef1710c73b7cc0c7e92666508c96454db58a7859605546e48ccde72e31fa0a31d80e03ba35de1ce1aacc0aeadb7edf7c7ecd4e3ab35d0d3a13ee180f303c56bf4fe828e38aae1e1c4858eed54f2eafb60769bf028ba82d5bcdc66932906cc6509b8a70c52281d88ce865e319a56eaa895827e88b7db3b34e69c869f1720651194a65650f7120a2cd2f0555c435ae45e985430fd0cfa4c2b185d8df7b45a502dd02d8dbac2b3d034980e099a4f7ca2ad5f67f3c521dc2f885cc9015e373ad9f33ae61fc6539ffbec96c4d3a6a67a89d47e5d44cbffe11d3207afc43cc51320ea88f8797c7ddf5b19c55354eedbd969f0e4372aa4151d04dcb5725e1dd05f6ae6913e38cfbc53f5706c8b0c1b4ecb5cdc7a2ed3cc074a046140956ce6b1ab4416a335da583c61e153861412b3a1fb3eba83e37bb89d6aa7984a7141932b0d802b3341630534dd4a0fb2e63a1cb983985b0ec541485b4390a0dfd2294fe6ee4800a03873f4738d68209f42416221489515e923dc9613ab74024d2282bcd20a054f051306fc81c27e6d92bb94c29eb725518863defe8584bbd6eb43967c7d0ac9914511d2480cb09b1ac77d7b7b3df371d645a28d3613bb16d9565a9d4880ab070943b2921f28b4b4f456f5b05091d5d652db78899e02fecf9f4d98f2e373d7cb6cfb7c00cff09713d0fc60a25014c034cb195ec235ea7e8389cef19fe1fc28ed78f44f97086b6e3990a47421d6f8cbf68c9cf286305a8ec683bf6c0e7dde56ed6746dc028823966b469e609c899ebefcdf6f71a1eec353d1783cbb6de9e44fe01b361fcb45ed2413bb1904d3acc4c6d85be011c4f4e1afc754298728499d8b2e1fc2b0dac9bbde049a27e9b58ebb7c854d5d9490026cb8f10bba962ef71c5a9c5dea559cb2074ea9c737adaad391ec54e9ab84b9b6c68a5ef77039a95fac92491d3847f4456b068e2f269b68c9d6a353815b22b6f4cc99e2a8fa4b58f4e188b7642c89264f8aa757c278e02714f5d9e20693a88898d3b3007fc7ac81dd43d300341876e0201a98aab844ec5a2a097af10b7369b1d7dfdc638dab9c6f8bbc515236e3afe8315ce187c95172b92775791043f04ad8ea9f1a8dfceaa7ef24a671ffe06ef524c026970b692f29ce37ed8a612f99e7c57c9ce72c94e50900416b1e1824c8aa4906745580a933482dbfb7321e9207e752654533fbbf638ec74379e86252203c18448993508f7e2cc12d339863099977d90dc85246edec7c35a28a744dc7c10e09be65f08f952b5c1b1bb95c6f4d153c8a38473030052f10e8916b566c51231c92fedfc26b6bda5d34e72fc5e6d4cad69cf9c285324530b056d0958fd9dcbefad847ce7a7bfe8c9dc152a7016841ef4f7fcdf97a63f7ba14a80b30b7a4966de7c270cd3a0f5d149ce57b0b52625ef47fc6de29140407440d90d549d702ba62c0f38112af1153467acd0e7376c7f5a65bed7f17c3a4a00b9613e736a5c752d3d3609c388e846d35b939d9b06966083144fbc9208b7840cb565525b6937f3185e0abde04000a068fadc6e56f8d3316810da56df5fc1c261a53953499090d2dc6df6415529bd7b90a3382c8e9e95d366ec00be76de173249d7210dc270d090a9b5cf7bbb202b9c5a52e95c90db7cba6900cc537ed91ab3548cc0acba5baaa92aabe2d2d7adbf049854bf9419ed07f03b56df1e3d6bf97175f1b57d990294e2ec73140b5cd54b93595f0ba1bfd35a66b60638e9d7f8a868ccc29e9206678b03e00b6bb674a29e713a92aae0807a7ddff47c804834a187052f7ad9b0cbc395bacc593d4b96c2d6a3024f43283ebd0c20db0605793182edb7723c1ccdf7f3970ed4576f5879f8230b0e89debb8de1ae0e15f5c31d45e86a3a6255997d5d83b1fc7abe13edf090e956dc504a74e3a3f0ec80c9a607d15bc07f1c3263d70a22a92d1e1c53435f10b0e972cc38ae634c0a90e46c79b697cde45c06ef4cc5e36ff6ce52f25b7c11d83644e3e49be55aa7654307a6867dedabfb7351de5432091ee3aae1c2d879a2c0b1db4db7888a27412341ccc58a3879a2c6f3d7d4c461a3076dc683bbfb2b86850c200e82ece14f7fa52cbf592f05b37037f4622994f5a8ca58456409c4aeb2c98cfdfd2eaea71518d2db0a77e9fad82dcd66c04b5de48924661fff03fb5e17b354a27c5c16cb9db4f3a9eb7b280619796bd1cf0694f7b4cbe9dc37b9ba6d22dd9a870a7c8f9908dee161b6629de8764bf6fe7ab945d11c89969273c25db02c02dd18df07d4c1354fd6fd64a5be4107e63dd6f3f8ab9c55da454a2e4c0827ba52c7b60b1f7d9351c66c6d54ab733eb0fb2fec53e63f533df811e02374939d79683d01acbc9184fc7d65f2adc49d03e107fb798f34378f9c6a4f496a178b0eeb02701126e729b03c3c650fc38fdccb6a615ffd71d9011a2d76408954626a7dfc9d60de2f0838eebce2ca725aeac66c0acc3f6ba0c4e1284b3c2412abec2a9f748d2b474fa93e09e4b599d38f56f0d7913af259d74d7ea6b700f1fd956a1d4332fa4f2f8f2ed881f7a1bcabe5de140ccb69e6df9319c41234e86ae9331f044f14c4688ac6c2845b86f07b281a462a86f9a32240a5c6f1d1abfce527e1b3914901a87e0cdbbd9cb540a785dd7f5ee1cc8b7fcd5fc624cb23685d0ffced93e9b1184e07a503a2d2bc5bad7b48e2a339a36f9de6d0c7a1eb7268bb825b5cd91a57027b097a5b5ed3b9505bdcacce148016539ddd9e89e1a414bc44ecdcbcf8c54b3d79b879b35ee0aead978f50a5d699419491146f773f52c86b102de958a8194e5fc97123b17df86e2afc2d8faf76941ff47e727b943df66e71f2ce68fba8ff7b261d806875bb21a8559a9e7c903e39039d693a8da1416a82efa87f2527f227b94aefaa7954fbe852ae9b0f3a2b44e5917af0ff4f130a69de381e896bfe2995f620e6d12dca1216b19440f7f52982087881ed7ec1cc51e2a17a81754262e3d335bd62091f5a8e26ebf7c33e87b5aec4a199d5a20ca3b8e826064cd3dbb533dc714b6ace17b7ac8436142a81585f87c201c09fc925296eed90813dc13a7f538a2da29400b5a501b4c72a53c672fefbd6e8d01fc9e5ff3f66dbb609d249e6664a927c0ed33adb8af04841207925b0b896ee46f13587cbc45c96b1d6492a7388f0de19ec232236d33ca71d470c90207edc922b24505c47326b9b1cfdf8134b43e1744a944550eca659a6f198e625c503f7f34861316aa79b4151198aa66e3874cd720759e0a2979725f4b1952e19966fdb9cb1be93298b803dc0c1cfcea769dd850b07ca209282cb12bb804fe0eeb0333e945c462d33fe70607af721be4a50f64e918c8ebdf90f8e5d60bd6594d580c89ab59680b59f5603594cd1c3b0bad98602ba17e970b4fe606c91921d0cb9bf49e7e8a20d9d2545e7b110b2a902be10977c45d65a80f20a6880209eafef60e581e8a631b55a0db32cd66395d8e47a3c0fcb7d0e8a22047423b1ddaeaed349061b85a6f56ffa2e40f416a7150e18c5ea7220003724448ac58943d7fb72752b2488933cf3576c23f53605984edac3a88e910235585bbc829f1e043ca88c701f5915e3a8335af4f92b3e9d0ccc4a899a7ec346514637fb458474102e24ead8915baea4d81692a62150d572c51ef5c492139216b66ec70d82288fa69de512ed46920ea01dde6e49d8ae02348e111a1fa02718c3bea845772ee3fcd0ce292049481874cead4391976c5776a82c24a8810cbf909a8f71b086a7ec481f3dd8e2e570cd7b1cb78077d8599f88dcd40e9d0b9080b6e9c127196ca3d5e82ee89b32ff0b48eb0ec779fbe283a39d778af236c354361297dd741ae77a6f063f3815418fef76806c864e3380fb0f17e8299f2d2f02f4a9c1f5e81b4ee2b6b07fd7f1e87e91301d377aeb052b9475255013fb7d7e5d0ea04411023054ff07bb114dd5a949448fa891f8bd78f981ec368d85cb4caf9a9df3831fbaf8cec1ca6418f7a8fbde3b6a9372d854feb9db8789db896e90a5731e423dd24ada3184657e6f5dd5a334811cb72ba6f3b0348ebd87e8f684055d3396373324b28ecb6096f408c1fe6d9103ceab3bb9e0e9900b324e82fc14199ee00ddefc7e754745707c6c3c82e601b22b0d40505e6b6e74e260edfa25a4f0500749d9f7b2ef37b907c0931e3e2a4ea6b397c88f90b36f89ef33c6261a8311ab49640f78e5b487cc842906bbd8a55a7030df62cb5bc8d55abe2f630f8b43203e9868712f8caa0fc52fd0bebfa7274ba925ec7149039373edeeee18e76e918c11143a27ebfad4feba759bff2a2f8e1b76b04f7542fe6ae989daea37d1e7768a7bdbd1ecd78c40153f9bc59e4b0f182112237a8d4678bb258407d15d548ccfd537e13c87992591773b888cf55de0b96b13660b5584334369afd4818e816bd9211a0c42394974d3ebdacb3d7d803c48898b9b78ad1bb3c91c0f10f6e5d1bda9c140b0d693f0570d04be39693792cbe2b2890f6a9d15e6ad3fb950880abe2c775e97fa11005dc656bb368b193d280887d85e405081e54428b584823b971a22b787e33f91d96138764e1b57ed5b4f53dc84e4526b239a404341d24d73478251931c8db94880d35311144783bfda30822cd41ed41abe9ba72d9875e948cd3d5fc0be3f4bd7b822b9d0347034e7263c009abe8566ca4449ae3e9a0c611d85deeed55eecd99542f7c766c24d244a9de552faf08f73ebda0dc69c54379733150896190c7ae549eb175ee5ef4a265227409999b9338985a92f2bd2ee9db8a84b69d611b023dcbc17bd223d376f356709e50b1bfb75bf33a2cdade1cde482c55b37ddeac3b44b29039e0233dc4e7bf3ef986198e55be913e65f9a257a2ffeaf3f193757423990303018b001d89748468e5190ca5f3f50dd755003e84ad0f3333d0ba1c6b824e3e3d6ef2442b30b47e3dc0c9ed50bfc2b32e467b47b56760419165d8ab70ac2a4ed73a98a9db406245de0205d9be87422139798249c939a34078f9c9bf8487d8b144d515a6d891c478a24517a1832d2aed385e08c47d1245810491fd4573c9c2f0fbc654f5cf1efac3dcd44b39db0e710fb82291975d5fab5d32bfd0a4c0c7910ced86735316714a9d6d73299c03d2b4655e7ef40ad4b4b42b7dc470afed9cadfda8ec11cadac7bf50e2a9265b34ffa97a9a7fc2d2b45d5a1523231b44e93e0d3103c2dcce43cdefe58ed7aaf55df410907a3307e4a95204e4a08db969726cc2f99a9e170a9b18d26c5995950ad09d9541afc4a35ca72ced4fb4947f066a40c639f33fa29a0f4ba4fddd931ded67cc1eadf90226805107e9b3a56f88949a7927ec9b1d978cffcd8ff4afe1c1ca5876e953345991910462c163240b84399b78346761e3461fb758bdc38b6b00413e149ffe2e3f658b0302772828fe4d2fb7ca021eacf01c1c25cb5edfb208f170b850ede8fba95ce17ce9525b54dfc532326704149771e75cb30cc69f3ac4088cfcaaa7f9f221bbe4a72d09a9d6080f61e808ab4ed3f6820b32fa025dacedc713fe313fe6cdf3e87dcaaff8d7d05d4e13ed99fa472ab2d0666af8634a142bd70503e24b7ca2a75570c02f68ec324b907da3a886567d9d39230547542d0addbeec00d2a4b9a427cf0fbaecf7765e323a7617945781c68ac8e7e4ac49dac4891afa1378c0cf0d284c0eecccc0696175abcc81bae9e31514b296548c4a02d97def6f776eec22545c5b2aa2381a9e0d9fb27b9a06b7e2d44602d8628adbffbbc3837eaee1cfe01f4b2102dd2b0d22445e5b0897e301474742f85c0c067cbc65a59197b91b196f6049286df069b7a35c12defeca83c2508fbeec7ac53342ea6e42afec5744d3df228678c06ab79ba8b0992960766765838e90d2e13f4d304a65ea38e5f1d114031c5d06aaa5ab1b33e2b7c813a0f67a89633029dc21a9fc6c1e1b39dd17926e520c94497955ae402cc7bf9b4349bfb166bb91b4d1bc78606a87ce36c204b1bbdf82a50dd69220e943f71e83426bed15c981ba4726c523a9c74bec83a78a8d894afb1d794f732ce64fd490f7d641aa6e1531b2e99ee141640d6275fa72d8c75b1d21dd59ed851993d0d352c4baea9ed0959c5e054c03ecfc0892660df3ad03479f79597af8fd9486df59786bdc0b73045905a39e38ae205cf18076e0deeb0c9d66c91b02aa4af81eed0d11180566c6db9f3d6642becff35322512d08d116da4ea4ff758137b3d78f52d44f7c26fb14b402607be3683e94aece3d69affc6f2169233575ab29cb5831ac8aa9f7d1a2d525ce1f5d7d5a83a78aa765fa776de3364ebc669c516c186211f4c2cad1f0afbf1fc3f7e19c35accb8eebb2f708a681fa42460d267abe14741ae6564d27c5f0f536f40ff3b3f1b834fd5bf3897812a446ead76975d25b3b1a8e1de047e8434039eed91bf0fbe250223a6d7af9d88ea9c0e4f00747ad6f7f274f23ed30e34bd126e8f637e764087ebc1b2df0926992693652eeaf16f22d898319d51b7bc7a991640d8ef82fd87ec1ec2892cb8e38eb9faaec12a03e17cfa40f8994f605dfee11d71171dd2e36b7dffd4445f1b3f264ba00c300e43c6c84c6189805e52d43d5dcdd21083378c24276310fff2e9ae56cfe53d0f03e3a676d6da3b2254ab4267fa1aea5c89332858e169fb3c1147c845985ac708860294cc7b6448780b70afb11924a8e830c4853c1cea8031928f30d5063e9d8c1d27a9e87223365c3b3ac448f07f290ce843fafe9e597c712f4c9f3d1d61c24094e197139ae249ef7407c09b531ae693e4c8408b109b8a00464e11d36efd41b016fc42f3a84842a859f67f432db3851a7f787b521240bc9c9a614789b843228a0c40c5b2c4a1e0a743ba3b3fe02892391bbb44995cda227ad2688e0a375b8bacf1b913457502a8f1b63f2162a7e3da1d870129dc7af9a717851fb44f4a1561ba1869407b658722b460ac5316a09d448df6eaa0c298332d118011cd282705aa63f03d8b05e74c7a86c8379288a36001375bf00613db3eaf5eb62f66df571bcd602233c04695c9b81831e6e07e26558dbe0820786e97b9fb2599ed42978b730744d5f423caecdaceaae05bbfc1e9b041168c93a16c873d759dd95bc064014056308692dc330a2f760776bb75cb020c60c7ef3c0008ab7c382106fc28f52eb738af564a86dcc047431ca9a12f194698d81db1dbaf355c91cdabf27063f0be52a37a2f096cbba4854a7283fd5609b9f8802f76d22727363f0ef7785bd964f5bcb840bb486261811ece1fe0495810a2a4cfa51a9d217f987a9533042421198f23c1666ce944224bc741eb51faab4506a7676b43ab5caec89b0a5165d3d5c8be27ac1b921f4e174b3a51f16fac6ce650dcf68d91a7301bbf4674948957784334c75844dcb3969d9e180d89566360960d891e1da76b85a60d182e80f4db47fddcca86d4d7a7219142d3607055a46c18ba268cc810da971e016310a2d6dbf30a1bdcd8f47c662943d708cd7f064a408258c95b113b8ccfbc0d2b33a78274690706e7f8a533e4f8a929c316bc4ef949698d5ee00568fdb01e8ecb06e43206cfed19273d4f2c90c568f9d773a2ebb7e8ec98aa16551fbabda7a05c95cfdbe98c96bc4023545b3ce9ff64f1181334e6dae14bb730ef25238ec6d19b8a364ae72d2fca329fd50fe065665c6e67155680a7f31c2da1eefca1c2aa91ce44a5f98ff567bada71f3b4a0442625544f77c256a162a9d90c804b0c61dab2dd59aa0f75b4b25e2a2d6dfaacd629a94b498ebc143e0c1d60989c1ae0821511eb32ca3a0cbc695ebc1a1c049eff63c397bd21b4e5a9b6db3894d9be373b42d14f9e31ba486ff908c605f78446418f609405d4262b093db138894e5b294eb7abc5fef74f75323f35ec220ab2b45045f2819018d90787a4456830e1d7b0f3ba25d0c6890c127f3e5e8fa1bd5c064c23709a931e65287022d2f7c547396da1ab0389a7c6f89e55a2c696eb24ba8e0c3e6edcdeef94b74ac48e02bbd44606b7c1ee7a32f5e6f6de042178355a266fa57c58632da31b5776f4aa74b6471b554777cc8baf3a1b8732b077d5904e558720f87d840a3713064bd9432bb6f8bb0da8d2705436f616d71689ba04b4d0db0d9aaf258e4798d4bb9d3956b0581a39a0f1538c4cea1b1727574518c549ea7883766656e605165bc41cd97702af30fbe54a14434871d3c53f1bac14928e7c63d9980f687c83cedcf8f27a7b99df2848824c083330a49a5ab200d0c0feef56a5162dfffa4ac4d303f0715617a24981250f3c1ac767016a0ed0849fa1caa9e8cc188d2e7e6742d683232cb219f9aa166e599f44d1b0e1d1a85ea6fbbd372bf1a4322ff6bd7d26551ee5615427b3fa0a8284f526d2faca1ad95b4fc035a7ed31b22aab61feabb4c3ad27c2d65b4be843f54f14c40b6cdffd26179aca0bb5e52f7d3b6fa1afa4a2d2308b3646190230d5ab4b56f2a447e3dd06734f629e7eca251047ce67b3d0edef9fdaf715b8d2ce96f7435bca6fcaca5de73d886829847d5342ce6ed9ba5bd11b2327f72b9801290aa0cf6f15e36d5d3aab76e5e7669886981d19dd7c71a4bd4a82fbe6b87624655f31e81404fab22b0e17b971c4f7055cceb79b34f2b35b01dc06a7fbd6bbe41dabcf25bfbd827398158c093997e4124c3643610957f3e1f83a3e548f133d79378adc68930fb669bef6477c69ad9fdcf14feffdc675ae4500c139fcf7965db19adbd904396ef91907d978f0bcb079feee5adad47bcbb93be356b03d11e10dadfdd8b6034531397c2a88d465c7bb63920014f7aaf0432ec6a0d73eef22e660ccb71aff943ea0ef36fe18535e83a97d7f528ea0db2a1024adf8cec9657030a6df9d563a135f5da99fbbb68de0c5eadc634985cffbbe34f7798e01b911b78e094e29596ace7c3d2b3609a9fd30dfb27ffb9a7edb0020976c55d8ddaf5419e6c77a1ce2ac9849f777ba750aa0bff3f31ea7ea55130ea23a4f9da92c39ae07a58305e7ee3121ffeca3aefe0bda49547681514506903ee64ebf0493f9ee1a3e506fe2987e882a2a17bda61035c29705fcb48120ef585400b0dad9a32c4883758efdb31fd252078fe673127013a12bd38c1e4f22214c80afc5d9e0f8b38f86422f7ce9756116eb76fc7af3a657970cc45d1b773f445c36be9f63cadfdd80c89b1c6f70906f267b5e36bf7bb221dbf4125b7f4c8aadc633f08d04f1c560d0df357176271ed62ca854821ec25d6341bd4627f79bb8e3192aa88213a308eac03191a32d67fe464e668cfb3581770573cb17b7ac483b1d0a1c3737dfb0886edb21e619fece415b3422e80c92382b23e0d4d8494c495a1c91a847cb0906c21a3f93c4108328434093a8d0a886aefd326e39a186c5c72751d9aef39524a1adfb63b03415a8bbe95ece3747f2fb8d1f1296dee2b8a7e62f401d21ef9655fa777831ac57b149f03424d2f220d3fdbc9d04bd7f37293512c15ee390f8a07a34ed962a1ca4fc4aff42ed524c1d776ecfc1c0c774d66c03c4a6e2b41cbd616bbfc302d9326d57623a63594b5c3a88073c4674c383f9a46ecddf45fd57bbe00d164dc42b355917b3954248443183a79833cae6790f5c8525430b16facfdaa0f3688b35933b4b629218e2836ad18070e1eb673fca779dbb37377a8dbfcf0446862f5f752270295c6672188fac2617385206933d0d872dff1e29ea502328a9d704cdd289293f33a6af4f3cef242ba012abde3083039dacc5a220d7acd0c8b07924ab6209c123153b7af1c227f7adc49a891466fd3b590ff1f1f2978f8efec50244b5eb188b7d31745b22f927b1058848eeea4a772738d9e0d27a5f8797ccab948b37d4e39e2d5e33daafc8dcbd2423522ab3deb1c61b698a7d2506621531524bdb873f5512f6313bddea2ef41e5a3ba00c4bf7402cb95697913924e9bd32ac466d076431cd755b03824abb75eb23b6e26456aa79eb6c65bfa609c401902b30cb515bfc7edc8b634560663669c64820c87622f5bd36934c62dd250fbac97cdf0232ef83e09c03aa2589e7b7b74ed7b0d4edee3068e0bc3001df84f25cae3ba1a10c5a80dcccb59d4b146307b692676b3a02751d8cef01522edf1242386ce1399f853593d40ac2987f47d508dc12fa0a7afb7cf59cdcdc4b353f4ee3f87d0b72e2dbd9b3ae2c650cdcfaff02ba3970e52eac45f399de13e597ae6a607f7563e14cc630a040188b046efc2f83d6dcf94e3f3b485ccb3d8aebc9331ff33a09862785bb858b19d333ce27a7bc3b07a3135df6a742e05df72a6a59fc29ca51edd541ea9aaba1be805be4da6b68fff859499c8d75b327a8385834e9179eaf73f48596039b57760c288d78a5cf7b9ebd29d050acc6c96e1f7681f114d4afb3e55de062a13e8aab0b89a29711398354049ff48a865b41db1c4d7d4525e237f9188a6dc03c4996da0394a3d74b4284f6823f20612b7f135cddb2341c6b0a2abeb34cfede26472c5e49afb37cd8be87f74e86f44a557dc78af5865b863c939fe18e618f6bc7a547b3e85bb31313e340ef3e418d695df8d91d98785e31e4d84e9e9a7b4790824c708084e1826614da72c53dd80a96c3b930181cd24404833640df1c972680b061b2818f343ed0952a3b3a753fd37262448f754460353925ed25c65da16ebc8f35fa519bf4de6b455b44d15788eb9b02617cb17123e238a3c8106d1bf5cc7f9af0b3fa9b0dacd104e076397422e8df5eb5de90fc3bb5d258c6e84c9edb8503dee991ea31df575e7378d4bbb589b81f1deed49ece4cbf261b07a7f4ea4b0e055f4aa9effdb247400237da355c547d674011d7784a20b4162561754df13343dd882a1311e87fbe7065637214e2e7fee387b8518717f48753a3b608dbfb37c124b686c7f88f322b170ac0958fd89a66de46dbd9b3f613ba93c6dc9ef9eddb7dac652b79de973bcdef1dfe0135d66ff8911a7bd8c14791f48b57c10b7fca3837ff31427fbab74ae75c46b5e925861744a790c9fbbcfaf7a3288ae203db2e37f986a90b9300ff1bef82b411bc78b79f058c87b81fd1bfc969b44d89459dd4c58e165c8d85efbaa1a318544a2c896a0403058693043d51c0fdab6c83b30205b3766551a808ccec1d97a11349af7bc5b97aed10491507b78a9d1bc028698dc2f8c1dbd306e6f7d7317ed2370aff6cc5e91256c63370e860e1178425208a39901b3ed0de22a29a287ce5a26f96206f962db365826fb675ac9c0b1386da1de2776df8cc1ebd71386d603955c0ef5ece91282cb76d6c462b59b2423d0befcfeac958f34f5a04a64d219c5c912a3638223f326125030226e10bb32003e793a52cf19c4ffc496328215ba2558f50d2518d46796674e8681aa71842af09ea7a91b0f34783874defc2dff6de560101b7f4e0211e560436c83f47ec515d64127e20f1ded2492aaa22b35fdbb7b2ac3f19c508f01a891a6e965e4a7b5346b6377e07d48b686f099cf85507cb30d2e35576d53d983dd03f53146c8940c89f89d9502ba2c08efdce4feb6b3e8f14712ef458340b06c0a050a7a7e055e938c537b8968feb032305735ce650e910558cb3d3fc917ca6c15b46b10319a8adcdc0f46a6634cdb2cf875c136defd95da00399b9ea8c117d130aef498ecc1086bc8ab28f1e8640e6221578d87c20e403b17a5e5233b808860b4f23aa6e515ea87de8bf62da6c216fc050d4aca594e70ae1bd6a15f89aaf6585b28d3ce5cbb0007d70f4d69dbb5371f9c07ea9dfd763d5939f1d73869264f5386c5118932cbc69bdbda2cec0553d09cbd36df632408ae318aca2a865559e3f2be7893384305f80f609a8afba5e271b6002e32b6ac911e60be5e4cf16399ef5de74a8b2e15b14afe9aa0e6163b59b7c369d73816c052cfdf239ca7fa5523b78c58b1fff7e1e0dddf73ee3ee5e061ec0341fb2a7fe1bc71ea8e7b329ceaa2bfbe1c3ba0906e41615e48edd1b6b111938532648c072aa53432c2058d169838fdc72cc1d5fecd9b84007e697510c0e090bb13d92987008591321cfdf051a7b322595e7d6917a7221167071c95e76af271a80940ae03ca9d7cad494220629d0563a778eae8c53b840ff7418510e451b49fda619df50a62c4b8e6e89b39a13b219b1c760eb39b088d07eb27f448f5a3f6d6c29c60390a2799678290e1a62a917aa9d43723b81aa3fa358f9e9ed1a8dbecc7fe74e04ab7327b901cb1d03127f646b54c4dff1fd2c2df688177a0f7b06fdfca732d532e7308c4adda1d22a9eff129562e268421348ae1ef133cc22ca90ffed4c77abe8418f62374939034d23e8139bddfe128a7fd6d2b8b97b2867ea59b2473545869d8286825bf6c1454d2a0f4666c1cc19be1818985183b8295b4c7c419abd483105155abca2e4dda483c4d6a35ad4fd8c28248957950ca0ffac33fc0e56b86fbb7e2abd5eff12a65cbd6bfc3db249aedffd444dd4d97ddcba5e4ee4e1bc2550b34f09c789c040558d3c3f133b8ceeaad57fe69639f166ca55ba14b6a1416c7ff225787026a61f833893f0eaddbde5fdd2df74ed6b78856bcbb711c987540706cd98ef1c62e7e61f2384c3b970887c1a8ab01a29c15f19481f9544115ddffee473a111efe928eb5770b8c97632d2a236de99e56ed63d35e9315ce16b99182cd2e7da5908a38743e365bec8be572200a0ee07fed5f64c54004d742990ed4b663e50af0768af24a43b1142c3156fd6788567eb83f5f49f71861ee715ab0ae00c3c39147b02393f6956a384313d9ca4e06ae8d1089f381be0016cdff7238a5174db3994a96dbcacdcd6eeadbdb7610f2829dd077615dfeb3e7b11abb9f6e748c083877a9d8805578df9d596a7277ead41ee8c72fc5f156905aa3ff53baf8c4ea5d1ed1de932f2ef1787f1da67ada7095a503f5dfa8d36d0e70ee21d553410125c4a4d5a7b494f9b714c1559a76f5de2b7fe4749f07c35e50d6b54a6ce31ab0419e775d97bee4ca027835c1c977524a77c6c8ca1f2b14ed0aa631ee90c89a3eb74cd6fd80c4f38a4986663e92c185504fe1814ddcc20f0281396b596682ba4efc31746562998b3cfb4da0b15b1fcc3901b1149595a15df6380ae3b71f5cea9104f2a2e880d4611294739b67a7f0d5c969c5e98beb1828f90b0d7b97ade68e0ee394938804053a84c9e7159b5ec5de83f4d5d034705d3c1cc44755f78493bb57276ccc7a8e9f5dd6921b330f450da6be3b4e28c68f644efa65da756b5f240ebf43dd2289ead1332c3d913f18fec306bc0ee964a24ba12de1e3a513b7d64b9eb2ed3581ee465ab631089c61dc3e946ddab62d8ae0d173ce9fd78b4bbe16fba2b9a722e56d5d8783ea42188a0d814b0982736eb29c8476faf82fbb50ae6caafd99401df9acd3c3dc1be0920c6d645a7c5f5cbea81fafaafe3311b11622388fb0cbe74d9f3f4e1635747ee839d57f4c9f9f3db7ffee84a4d3879e4603297a80c637b0c04c5bf0035916267a25ed845071401c7be84ca401454491d1b418d23f618ae7e962d836f465fe5bf9c1ec45ae00eae5d68a25e4f6f20fc74efc437d8775dccc41bdf52478f62d2d35b00aca9ff0040da2aff6f47dec31e2ba2bbb78d9f6e8dcf031949ca7744e39a54744ffebe6cb3a80b0cb874ffecb335e67d077ef69dbdf70551c948a6fa8752616f50d4719dc012ba26bd5b60053a5662110a63c4e3940ab39d638964bfd53ea911fcbfe546a971e89b4893b25597f8bdc884d86be3c1ee11f2731d03e448a3fadc1dd6a41444a7cd19a693b4e141f90650802d46a0e4a72a4612da4f51bb3d8cfecd0495c9a91bf2ba38b03d90ff1487965c749f25bed9022268f63405c5a58bf048e7c8ced76b5b20d2d6db1044c10ef420cc1f0f5a89b1a18c1bf5e33fed6653cc819024bd2fd75589da947e4257566dd15a06837bfd8c424530bd7dcf381f3e9ffb5557c4917607b2b7c2a977471d9da6534ab4db914490839dc7ea72cada7ca44f1c110eeef8c69d79f49e645ec937216e3ad6c1263c6acb97866a31f2c79569d150a1f5eaf8d68e081ee9927249ff5753fa8f43fc4f129ecb19d3c09b2f182c0283172cc865cc74adffb6a60d61e46c6f1bb04c13da8648a98780c82629036d88cb40ae2df88f941fd45c49bf0fcd12b42f6fd6646b16a7b9d442dc26fa16739182fe921eda2673b7f1e5cddd74bb4dafbaad571a0a7ca85f0d2820492e030cfc7a4d3775fcf8654f79833feb6ff43a0534a177b86ae8e720f6c019dd8fe9b05be43022ffec90e7f55a9e3845bd017a509321135786dcbafb48a8afcddb6d5c34fe2012c28adf7a94c506a6bb40b927a863372dbeede078d3158f066740f1ef6405c97139aa38ddd103f352bc1f8adfedec8a87721ffe8b300b421f40335241775dec45998515bcfd0d6ecfca47fe86cf1c81001950fa99e4fc0ba7620ab979faea6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
