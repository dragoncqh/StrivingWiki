<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e29d71a63245bbaccbbd1a37adc759a6974729149a59a3273b0e43e348d57967b7ff82c7d8624f5e3e8f6780feb0267816d21e5d3074226414186e9476776487499e0c264b845e9ccd3f0b73708c0e8605621b09a3142c0b6aba2b5e247d412a8ddf8c3413e4c5e8532cc5f5e42946a77a6f1ab6fbe61829a0ab66e71e0014f9d57e5b4e2fe58c735021e6b9e442bd54295b6a0f65d6b297e09fb79b6fe9a738e1df81a99b827db9f94b14ef506c9bc41ca9a865ac7de772d98138ce1338115e33791f71000ce0240d1fe261a91e700046b0b79b7989978211dd3c18c4397ca9ab9e1e74b173e65a429de63d8936912bf447fadfd20bebd8b20b849ffa08d2dbb33810cf2a1ce7724e7e0bdd95a6456b5c3bd2821a9ec24ca669b10382d080041a70d26b7d7b1951901abd286754a107ca8f62b281c6c63fdcf55d35ce32202a559225419248f8795cdd770c5b6e6ebcb28876e9ae87e57c57a4bfb70ada08a0866db8a4a5ad7ca9cb000f57d022e69da22ee17b2940c28f264ab7e6ebba3d3c06a9f263756b57b743fb5c9c9a89e09ded0d1bd1602c38f9ff365ed45959ab9a367672f87c7c6dd9e0a84d0b8310134c366d46a257007671fe87c18722a25270290ee37f87afed77b54525fb4db9058af45ac151a58d0fa3d955b93f6120d1a1170567aa7c548cd4014a3085c2552bdf0c42e449f952c58a2f9da20a52d564db1e663f8a7b52cb828ca8340b77d2df0dc5eb957a86776d750041218180826f491f178ac1e7ac36725aae1f75c49cbf0ab8b64521394d083fc986f800f4bc09afdd48e78c70d42677e645fa5c4507d954ca06bf7ab4e1837e9fd867cee70f851558babfafb2285a44af391799c03f58cc98adae812fabe2844690e4d943f52e7f77822a212fb90548c1c4fdf14eba3d8cf549a076cb1d5eb4b0886a083e58edfa8274c17c040dbf3c9eb2e0991fe6c770a7bf865d6178944e559dbfdfe7196df88e418a6c2063300ded83d82d258f3b0d419dbab28b7e2a019729c878e979a8cdd6a59048b41df1314ccdfeafd0c4e7f771bfa8ae593c0f22080d7ccebe5b3fbb243ce6f5299a776470e3df466854f40f5afe114ed9c478622c2f9b3119ea19dfbac70f7a36f421b6c7a6539c1dc78668af2fee1efff56a044e9d8c2e3d11712788e3d371fe6472977e058ed6c7fecffce39f9e56d9013f50087ce34f56cc4f2b7ba34724b5a45816f768f76ca9edb2f187930dc7840c6d7a9e3fd793a53dd8bccc90b931c75b251aab201154a61168ce05fc911ff8405b7c2b3ea5a6af5976fba35b4fa11fbe6dfb558349470d68634af3740cef6627dcafb23f931beac9f8411e8b63d206af39dfef0dd1e8d8e0da6f5994e19b9baff4d93ba3a6332ad31d85f01bbb7b2210d9fe0f6e53143b5a9210e384dba77398decec1650905b5e56d921593e2352d3864306639baa57abcd9d3ed001fa477f93732817ca9666b924dfcd8b224288e726f346fc9bef7f6b1762128e4fe0344876ba0c6da9e5ed67d5dac8499c74b0502d48defc88fac21360b3aff2e667a22deb17ff38b3c8032796284f3bfbdf9aa2b9fc0a15437de30c988f65b0b4cbe2316e1ddc21f5a4cb3ca07bd966c5b3d30322f533c2a15e1b109590a474772d8fc32c829bc5f9f6fcd5b7916102a01982d5ad27f3f4b91607816885b1836f53d19cae403902db6b2a28dad751f317f7c2f1634712821102deec802701a73f510f69d4d91565b685cb44eb4de2a7530387da64ebbed99916da61cc4ff5d4ff750be3e674199e723f4d1afc116a9a2fa502e5d83edcbdd72c9462963070cb2d71314d62cd6785a8e481940cba436c0a6043bc0fdc32446808ff75df11a8ec0260c303cab0fa6a70c40d20edf9658fee02caa866aa52552bfbdcdd1a7f66ae733466efef9511142b43812b22f6e21832eecb57315b3199d56144c67498f185b3320c911c8715a13640dcce6061d608f35cd0039d29445e25355271917bb9fa433c54a14841f7343103de974bfce5a0a841f05a2bfc54cc433224795e740f3a6170c4ad19167ec4e0060d1a5f48b947459d817516c8d0ad0a8857754cf928c5f93b4b1b1b16fb7d2cf4151b36879ff6d9baa0f2351a17945a7982617def51b1446a7a0c14fa8b5bef6eb6dfec0a16c6e5ab9362af06fef4d54e5a0dad12e183212c1658356c093fe717dc6cbc4897d6f9d3cdca161c84fcc53ba58a5a54148aec6d1f446aabb94129ed5cc7c945757e9c3a3de383f49b4c9de12907dce25e90ef34e2e6d99f818bca695958096a0cbdd292d4343ac8109d13c4f34c9bebb4a4be1bb295fc0f397d521b9a0ad4b16999b5afcfaba4df826189db454d6f8afac78848bac3ebdb982a6ed120e4ae51bf06eca4b925bcb4e12d82cee8c090830a78e1276167ee16106ae3ecb339688fe8cb082fe79137998a5e505278d3f4c31b4abb2fcbbf2ecec61c3caa07c013a2fcf6392f82f2d59d716f705b2ec3b190725b3f0dd5d0d13c62f85810e7e4c78ba430587e85d868eb408f1a73e9e4c58e07c921af846988dd61648fbea5b5f51a8d78afbe04cd1f7baa9227638caa87ea44339c04ce5714a9c70d26cf0a4461f5825ac2e601da61a445fde8953c20e6cac3e6a89dd94772419d6ef67a8c9454662489e617564d7591c4377d746120f5468839fe8cbab99a3f4975ed1ce9e580a24a825329891c0042577d78747261e07737a8dff0cbbde7c1a6994b841625d60fb22a5bd1f6d24e5971a2d528fffa3e79fefa8322a7c8de14b33af7423cb86b87b9626329cdddd1a35433e483186ca2ff739d72513548fded0aa6db3ba1304c5ac91edcf5d70660feac8bf7c23e8b1d25f43f90a16f22e9c77a8b1b84e35dee9d11c420fb1eafd2415003b671322ca33f9c02abbad82ff02120682628522a78c21fbe5469555918d5fe0c916de5b1a3a8e6887f8ccd6db79f812c14af95956225f3b97f8e6f773ba91c6248d4034fb0b1c283a3eeb4cd51653a263b9cc9a688b7f6981a0f3158fb4edf8bccb340e681a6fdf405cab841256e6452d549328b7a4097fb62366e2fd834bc8de3d6605b935b70a58478f4b3977e0179c0f09eae52c8abf0a249e4ed2e4de73853c81ec9ed0d9f48354fd7df00a0fa677cd2ac8121f867df2ffd338243178553dc6df038683f9e769ac63590e29ebb33d54787600d513de732ebcee4e1bc99df84a32fff42787aaa9437ab41369afcf5a16d47c09f9697123238aa41439db7d5faef3f2b16cf326fd40f035ee04f54f7d1c68bd3161bb7d5e9e3b61e5fa785e1fc71120429c277cad5a72977e79e3a555a46b9224ee5078e3e22fa9be8ee2e75e3d56eb1221870d5ee29670a56f5388f210ad2e6f04bf4fe7b5509a06d4dd67383986704bfb9ab75fe4444730721094f1f7dd6578274c7181f9971ee4c478366b87c719624efad09532e729af8d556a2f7e310a26fbc02c71eb267167df239704191f0a0bf5c0da445f6641c92280e35c06d48eb98d0646222ec79ba7effdaba6f8cad7592ff985f25a8b063fc5edbe08a4d8e7b4c3617d97833273737b26284dbd814b91c8cae4f6095ce9109f60af74cf4615caae9eccaa6dd8c3709a9a10c9770e84d9d8c92557796b36ceb5a9cc05a6fb55d4541dcde29c806590f2bfa9e70c4f236b3cd4cfc36aca755ac5dff55c8fe1a5e51789530a104c38e7a10de50e1b5d36255453559ff9c00ed992b6580cc369cd6975e7ff1236a1645c73e30a21a1bb833ee445c9d871823ed17b81574fcfed81ee35cb420540fc433d1ba516c00dd16cb0e8394901f6c049c92af282ca61fd7a0604d3ea16ca596be6f99aceeead9f500bee64467380ddd3c9b6bc1481ed2a4f151f81063167b947aef0fedad8f6ec71fb9c5d20dbe5eeea3c302e05018c2626bc859729da8ed4a13a44debafc05ca25d1fcb5b5e0c91f650827782e77c90a648ea8e40ad8feb410e9578b4703d0ba2ddfdbad2b0b7c63bedbb4c315e9a35bf442a432ed0cffb8963038786de68d81232e4108ed79611ffd855d00233501d4e1b7687d6fbe3c4e96a0e7777b3466074e919af43040908b2d424fe51b597fc04b0332d495e3099bc64735cf11bdf18f6b118802190a55bdb62b7adc37386516c7615c894bebf6b56bca7679872d4dedd33be8769d914aad9658442fc60112309c0d0b667c2a7a38421167cd6d69578a2bfbf1f2485cc030600d9e32325441a421f8a9d4744612099663431def5acd285b2226d3cc5c2145043492122bef32bf15aeadd7f36aaa1a6cdb6981ea33085aded9014e2e2e28a8870e91871b7d4f0ec3838a17b83e4a3c865eef5013a2f168596109586c4842819bb209d0f5b7889bc8c9ac04eb5db30ed3d084fb07cd9a23f02460be4036970450a2fc8d9590bac108f689194f572db395f419c00b9a6b25df7ddd552a8a8649d8d83f247e5adc452f37c8ac164cfdae4ffa8b01889303dc554700a655057b197f73b249abd52fb612ad9c9128c0e83e98e3786b179d1272b99936919f2d292f112c1791f86c3c789c58ec65ce2c1ee8006fe74358d8e8ad60f93d5419e821bec8d7a56c3ec6d1bbe604045444306467d753ee079a2cb4372d87dc096ddbfd461c8063156b97931484c7bbcaf5df4ead633fd972577f26163d00b824ff7cc7c5a2fe164d5090508019fb7c485dbd15fbec61da85fdec9b18d80483fd349d83bda1ec5135009e5970b0580efb7d206738011ce169072d0da9894f7d16c9aecb41ccc7c38f6007f257b3f28e95079e00c40fc61f4ad650fe33d5de1986120b7d3c6910d5b652e92c9f4fd22ab5bc6cb58e730780b904f1e39d4cab95e40ea86ba39cde4db679952dffdea7e6cea760561abf72e965ba1f7d5e6e17429145976d7b9f40e9da8b0d9bbd8eedea91dc8f5bdc895ec49a50f91e479df304c4fd949c52ea8926e98aab816dece5567be6f0e58e67955b2c65fd6befd764d4c225e16f1327bb082d6cf67e59d1792cac8ab32fcd5db22c6d083ed3cbf7a392921a266339d1f0a67079aff4d79521ef3d6ad83fff91e84d4d31227698067a2fce5d7f914f801d2eb39cbbc640079d6890bb11257949a1d92f92f4211f772d4d64109f56340813107ce5c5fa28417e3520e16ad1cee87641b809e18414ffa24964b6bc558951faa020c7745b65dc4f6e0ee88ef12df0f91b9ef1a8c7bdab648034afac1652e7b00f0d94507c20a232c2eb7c9422d3b58e91162cc17053213eb892e078b8939bbd93c180ba5858f37989f4531d2d3087e2883e1e161dd778ce6101d19318c8ea65285f0431ac2f0e3d0d35a476a01d58df9cfd287d64d013af54bb21b7e1a64e0ffdd44e7efc5210c0716fe1410d97a934770620bdf24969cba76aa846f059916da2a1ff719175762ebba97bd34db5b5e5b440bdffa0747a76c47bdbeb21250258c8943bc7242dc96173ae5733f96df3241345c540deecd89a4d53df5df6bf8b5f57031c1097f7de315c57228a2456ce38d450314320a662b006efda27b1713513aaa7d9b8478c36245f0322d0aba3c81142b74926c7d8338134fa7046b1046e2a2444839a11f2f8313a515cafbc87979d70ace5242ff95fa6fcab19835b32e0f3ce71c9978f1d86727b1e55bc3ef582859c941de1c4eccc0be3a0b1ce272668a6f2e77078d048129f90a7ad5a56efbd6aa6f0479d3b61d59507330b81cee8b26d3f5fcef7fb0caf5a1cfdd92b4c9b519972d9dca99dd3bcdcc324e64d2355fb22533260f5b7b8ee9a10284b1eb987ea194c926c2b93a968ddfcedbf071d6c741e027b90f3013e2e8d6f243052d70bba99be6bfc6d2633d6f3fa5bc48b7d191eda9970242ab62fb71f187e5ffc27de37430216e1bd6b6956d2a2966e5e15c6c7fa729cffcec94ad69dda20bb56fb880e8b9c3b795afbcd3ed320d1452cf49c3b6ecfec17cb282e68c4a8fd06a5724cd1872b74af10dea9d85abd951e7ade813956081f9d12733095faa3a6d39694843e3af383ccffe5aed9e3b1207b3230ae122f93c9fd9bc9857f867d608fad0cead92bbe93c4d7f995d7d8e508ebc01ffcf3db9f2befcc6d1e9f5b2d3ccaa3d63d032bfaabde430dc00be810b76eec96745344a68d70c0542d529dff2d39f16a03ec46bb7441e0d1eda0841f4293d076b67e0cb3d0e39b39d10763a4fe317004115d40044b84ffdac0e1413df4c25c5b4a97480acb70719f24b25624aa67b6b440a1f343e3a9454a5daad30c20de4e1f29e52851401c4d514f1422667f0171fc24871e4ab039d7c25b9f5ae3313624f863ce3df992537aee244567370a1b68d33bd2012fc732d5fd71a26e2f579c83d3c5ed865b2416de403f1864ebd1c09739e12c6b9755680a92f88ee662e4629493c00af8eb50879ff5e64710fa87797f7edf37fb47bdcee6967c78563e34a9ee72113fa4c65876dad93d7c25100d47925586cec2a1be984c06204bcfc7e4e54432030472ca9c20e88c89b314eb98b460629787927d0606af87d7a975a10e48a1868593d801e4d8c7fb31cde7103bd0e3313187319b9fc116ead8bab3735dcfab4342aded80872ba912ac4696d1669eeca33aa9255c4377feb2347488e3e19d73a197a24d2f8a3b145a5c30cff3446bb58beb874cf75184ea27b7ab49253a01911d35876e094b17ecac6506c16fe93e7bedac68504eeac81d4b5f25f0ba30e160bbdd4f488bbad427e644b632eed74a1b72e3da6cc71bf4750b638a108c6bc66093a9b46b7c88231f55df869bd3aaf7baed98c6603371d977b32a2ffc592c9263136b24337d033665423dcdfdee4b76d782f599252efe21af6ce3dec0c917c4d30fbec4e9126d8d7a7d187717ff734c85c4b92ca0e2278ed024fa5f13e7444ce7edef5b482789e7931d88c670968803e53843b323ce00ee70ac0950a9ad3fc1c02d3d9f61ce4bdbca6ad215bc03b91e9ab568027546c5cf7d1ec8e3bc36785e631db5300daf492444dd23d458c689c255474e42e299aa07badc066af506ba468a7787aa181c07b1d6b804406f0e4f070cc57e146c790c8892b12fe9598f4e42a9fa38abe7d7c06c9af6dfde6adaf5fb07306a7eb9396defb62369178bbc15b248d38959676aaa521a21fe0af0e1259e81b5c28a17f6c1cc050f9eabb0c1dac9519e60f2a879cbfce810ffadc3da8d8e01ecb9386d384a2fa983b3dc6326ae3e959ac77a853030f9c6c186ddf0b21a78423fa258eca687fd9f3c772cd4e011ea8098de7f22d9dbb7a66c6ac11cf7c6de12a24ec652a5201e215c5086265f98fc6bc34c27dba7ee18cfdeb4a331f7a8deeddbd6c47914dea925f2f7aceeb52b7a65eff8b6395b2c7af405749a664ac5b41cccf78f9106a9084657eb1c5118e3552c95e926ec3d667942074302662fc58fa348c6b92ac4f8c7eb93c24c981c0ab77ddb8e223e6ae3a734a08df716479c1fba9b5369a75c31bdd675cb398ac60c378fd3d7d3045e38e20e15bff78f9f40eb90c77d89c07a929e2b8dae1fda4a49f3e656b0b60352ebf6d6677fd141e0cd83a2d4cd365dd25545a03306e349fbd2f283b38902838aaa3336acb05e14ce67d1afb05bceb260deaebb305331731681ca2a5bcaa287056899783455dd98bd1d94d01bf79e9c8caf8db401f91f441363f653c6db36b5b91a5aba80142e47f610dbc2f6735a04e16ad672bb1672a42828251ae013f49221a3d0f42754903806d6bcb59e061b784d057773131df0696febf142be86b530f95c52e0c6ff30aa9913331c279b2387d1b843d350d8503642001cc4253c948b63354b542a2e1a023046eca94f8a5d4dd1c26c1a0153f7e8d0a88bafce5c673360e85c4047d388dd597f3d7705aca988ab8f70e7e298d23f6fa1c6635888807900e101556c37051b1de42f639bcbe9ea80744f67fc3b20810342674236727f0d2981506dd59303d8a5ed4bab3cbab04f31880c66a8aafa2787ba36f373b16529335ba3ea90b1451ac1b371c72cd029dcf60cd06124c32014a00fa481c1b3948b7f54af1f4e981bff99866e820cc3cdef0c01d8abe9c2cbdefda7306dadbb1e0aefd21cce6013673ba44bb2ee408cc6f6b55e4747494c7f6cc8521f673cd7bc6118ed8fc3d4b0213edfdfdda7340dbf73c9177a5bd81a1f730a2974421fda9a0c4b665b2171bb3f75fa05af3977d307fa32438e71df0ffbb55cc15f121a7c7794dbe937fd828d7383b65eba3d7ee0c5e72d21d562f59c1c897a01ef2042de67c63b371b7acda27530c49e746d4fedb9f7cce7db9aa92e550f65018c9995e084daad572fd0fe1ffc5438f64004662ad4b0fa20af1ddc13a826c28b13743556abad8eca7ed1ef8fcfeb9bcf76ddd59dedb17e5c00476712b47b94fb9797052ae9d55aad6c3ed57a1e3293d000bd0db7802c5441d39feebecc2f5f3524480c9ff2018935d20493cd67cd300d7763ad97d66dfbce923066dbc72653603f7971b671462bf4bbccc783882f7c95c0037ee5fc5635475a099628651c7bdfd6a1f27315e0e6f2a90e00eb22ed36dd73608bf1a1e4cec8c52c1e2d5e5bf74e0488c527f9310914cd0d0524db85ec3abca2e024242c96e4e60e7aaf6b3cba1dec56379b7ae27ad9f38ec2ba7238810e6ac1e5dcadbb4358438cbc39a4c18d08e265fa7eb1fb62ab8aeeb87e3584aaa2d46491863d9c0a960bbaa5c884c93e5b96cce25653e21cdcff43ba0b373932f2a125398ee4a8cf44df4049cdc7e1f6716a6e2ee5e88946839c36379d35b745922f5ef9ab65cb71749a24a31452ba2c42be576b177491ea648f5a784a23c5143c02f5e7e9d68068bc082b04d645468b0c0781c24b5142022f00c5834b6f3e12ff9e120c5e9fe4eba6ed9110449ed02ad1cec74ab31616bfde5775b5e265a73a1b833411e1a887933fdce04b2e4caf311c4918149810aaecdcf0eb6746d6f16b1b91b7e49fe6c746cb649b71fc3ae9e7e51ff9a54f26218aa981ddc998aaba687aa1cfaddd4fb8814a6b5f79104a91449f81938b0508eea81f7cd5bee38fa615a501fe3f79b610294482aa078de4afbc18614af492e2136037ed5d5016013c49f2b5ce5adde79c9ba751466133400f539cacb62b7b5b2a7c15d561c69bca1e936eef4c0868da1be648299fa3f87b8bda1b695a977aba6cce89ac018b4e2ec785af902086170e2c466b9a1da77a1bfa4d2bcf69c166388033ed7f385a40648d6f75001e6ce64dc5f4b62bfa0bc81f71790249b500f5a6e65430d53ceb9145ebf769f78988e8d76400e7d1c9e384dc4387eb8522cf16853fe5d95f0c737223199fc43125c2e0e2b318b653ce8189cb802ffd3e0c4af64129beeb7e17a6e258bdb7267a2a5c4e86bbcff0d82b367862bc396afacce005f4e34378f633ffcc81a7fe7cec812421bd5d4167906cc79d4effd27507a131d5f2d3f71d86989fb29ddd68b7f491db0231e7b62fb1d3eece9c843e293160fd410c4856cd8d33833cb22f2c91ac18073fed3710daa5d3c2900b8cbccbba30d8b2ffbd7b73502d81a9d539e803f2a30cdb956aa3cd89cad6b7bd67964b3cab60e98ba43011d80c5919b6040d9534ee033ddc746aaebb80a808577aef6ce82127ba98a64ca811a747789569afa8801467afb21871a7291dbe0052ce21b77966df2dce09086bbbc36d55b7282539d793c39d46d40d2b11c083266d206c39bba5348fdd00bc39f658f024319bbcacf1af15b25e33c786bb8f6d4f93fd6f619369957a9512d32238d93699da06ac7b6e360e19e4db34fc05bb90fb389e81c5e52ce2c7fe45e75d94bead88a34bd6c22e1588bc2f520e406ee53df7d8d8bc07e4276e54657ba5f751364187e80f4b677eefb0e0f5d5c1fd6856757f4e5f453474fc876739603bfc762f23bfecb01d73593f29170733c434ce4a3275e86e81246f0321a46c2f6953b38d3115c20b118da7842900a4471aa623a820507ea4e2d70c47bba191e0589b29145794bb039b892399c746b7936eba81cdc8bc0fcbf9ad2a74afd900e7a3f67ae86ef82c2af43972910fa4688f1cf8f3d25421e6daa576ab571b9faf6dee156b9b33397303d1f9072010ac23dd484368bd410a5c45f8a61e4a6fa8ff283416ffd4dc982d23059b3172701658f755738067a88808ef7becdb64b2c6a8576ee9e390802fb37a9c03d394a5391c19cd4fbe7d69b70c644241b757d9982a3f80d0952273a455f4c56f5d3c5ba82e8cf7d24195d758fbd50d20bcbd2a926e1efe80a0c0824e6b2999e5d90948ce83a533da170779c1177444446f341a49620942eb0446440cddc62d789e3524438b892311679875739e2512b9a76d48c8ecc50d32fac7c1ee5f34e86ea4fa5d695fc3b728d3098e03d3a166d7036641338f1c217f9fcb6acb5d3f2fd36b0bd4a695ee9f05b26eb0c30e7f143c142cd1a590083d8f12daa24f3fdeb252","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
