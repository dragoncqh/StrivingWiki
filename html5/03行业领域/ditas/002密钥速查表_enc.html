<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b7bfc5f64ae0e76c0f517f6339f4926e3353192fec72a4814953f9239bbc3282bd23d6a56de90051013e0e03d8968dfa252e589f4a129b0a44e2233e77288b3cbd6b5cc0870210f8a42745731c6ca532ba162ebaa712ee8dbd474a5b7766a9f041d86b204618f0626df6e0d3150d4b3895d3d18ee93add72d5a787cc04fa9d8277d4ed5af9944ef041204639ec8a3b0b857121a0f99be0fc2d0af2ee69a63a33219b8e0f8abd197f1d5f508f80f0725b79b24ea3224bf41fa8142a925c23f9be2a457e7fd4fc346dfb5c3d952edec28b2db177e949c9c4df8f90da4a3f5c0e6ace133b1a657af1b8079d2444dda942a015ce53d94c72f768ee15342032a3eb90a7ef9ac057de7028699dfdac51a3d98dcdb1470f366675ea2dd801cb7dbb1ca9541ec6bb52a61285d018ac7b77b0e1accff5a858c5a2d39b4a9a6d0d2b3e0d844236d410ecf927df8cdfb83d368bd3f05780f405594cc3d2cd5d985d68bdb00ea1a80afd6aeee1d609e866c9d3853322ed40875e23419dc0cdcdf55a21eac00d293c97da16b0c1b2e3cd2817b93262199f39a6d654bc47bc7b0624f653948789440dcadc633522b775a797c8c41c77bf936b07403c0f57d3f613b030f923f7f6060300882a2e8f75f4496031e52da0d1adada4716236312d3ea44c586beceb719ee6938817ad0c8d385442f51024e461f1bbb872c99f3c4a9c57128fb4b9d54a48604332237ee0212b73277f6f18b20187c680ea4d48052cf561cdd219b51c4d399d7f238cd0c3ccda9c2f899f1399712c72308662f6f7bc2e94591b332bc4224c91ae09eaef189e82577e916c115eaac7e69ede9f24c7d5f609249f7ae90914c7187afefdc4e9b0f3cb5834b4826931c1f65ac624269b7128df324850158a4c2ec3e034ee32bd274a1a2d01fb7a5404995a1ed8a1e12496700b3b2c20dce40beb55f5802edef905441004de467875e518bb12d1eda8f47fe52bcbc8cc13d159d730f5304e71351f52e397559d01b1b3091258ac8cebed81be29b359d76cbf8de0c135550f551eb4b4c3c7821bf8def57142052d56e16cd625bff222202e25b93f28cfe830ec936fcf621805bdf1e3399ced61ff9af5a4628a48b67e526ebc3f4f131c0aec394958a536742eb2abeda443a80b8f0ed292a3d19cc5ee0f071ec8c70d841c7e94d44783d6372d454ac6720dd3aa425c650cc3c1d4ba951174e35c99fb4682cfbf99d0035b58fde66595b0b9bb3386fcc017d3aa2a4f58dc183f574afab3881dececaeb672ca35a28f2d1112269ad2f8ad2aaf1e1eb30c7e3ade73f65a79ce91d5f8756463b0c9f8ed8e6d23ca05a98addfb4fad3e21ce3950325848ec4855463c330f8bbf8f4759a65fecee9679a37e8f939732932155338e8624e1dac1b6136ec2b8b969835dda8f001c4db75b2fb276e68f7b4b915a9cfbb275c5f1aa6b39206700a7dba28cf68c8a280ccd5b15b521145ab361e3ee1cad75a6668238b6af8afcafaedaf75a9cc2d7b76848e3aef18292a13a1f69562211481928974c903117e9dfcaaee8f8d41fd98843658395afc6a0d8f31462fa47301e18979e17f7b2bc6d3899649bcdd54bb482249f89b057a431f8fc27d8eed536320aab14e08854ed52ca8abdb3afb33d4a59f74a2cd65078db415de14a5f905352fcde6b8d76a0df6390493d7f89293f39903c7191eca2d3038f75103b56ea7aa79cf92c7de6d4878c6584cdef9253e6d2355cf0968229507baae5b0d92eef55f999b30544e23ce9d2d3519b5b4fbfaddafe4841930ce3904114e9607afd41be6f5cbb4e85a345f39f05d616b36f61c76b33de7f7c251844cf0cc1362a722662c32fb20a05c735ae30e3e7a7f0173931df385110000e83130a27d8eab04c04671c87f3057053215c51fe36f06b198c7a015d70191954fbd3a85ac6be1269e9621c7f87af94b1d4cff28230f1cc9afb88573fb647e48d6a2cd270eb3e6c62c1c56e274e5ac5e33ece72f2a4f9b090887b16c65bd4091acac705661d43a0617b1ea1a78cdf36b9612e076a88bf063d17053df371f05edbef0cd394c58f60c85369804a5bb5c9a5f7e174e7d0142b5e09ee60ef505b09025584ad1dfcf19845b7574c255efbd4793b4d0052ff448711a1598d138494982605976baa72137daac70d64bd14a5bfd67a74cbf67bdb076b5006d5e030d0ce9fcc1362066f370df0a68ebd438151646c637d11d06a4aa039deba2525d0f725beabe9523b4a483a8be38eeeda4b4f816ca82079b85e092921d4d51e6cebd283e1fd944a7edab6d96fc6b43a1e4163fd238746d20dc6369ae062e3a5efc3a0c641b3f20a8368eae3799b60f00531fc888ecded71ae2bc6a722d59739c147bac297669c6a149d79309018af56db7f193862b793a20260fc38970ad859298fb6b7bb468d8e927ac2db08df0f6df46ef623af32b5bb181cd9d59f532d27ec0ed533b128b2458a8d561b2ac59bebcf26c700af2252f986b16760030a5ec944ffa7ccc079ab783a8801124ccbad8d2a53b2b3eb211fa7883c4cdc2c6cf829588a1f029499a8ec8288f77ac4037c33c486e140d6acfea8b7d922d6880ee01500daec0c7a8200f5925ec76c14fcc217c56c60cdc7bc175aa661d71ebaeebfbe505ccba287a744487c91812842826726de43ad1c5da3f0047c28c6e88009a03269fbcbd8a27f71e761606dc20300ba01af7c09c1147da4a6f017a0434705eae78957ec77c8c3d743eb6df6fddd9819db3660782542de39f143778febb15e2b23868fb7152c3735ad66638884058978018259593f37e4461563416b6f063e4f2b8e0b9ca8af78d1384849c53738883b0a5ef13a76e6347b84144ce76f9b7df35090404e9771d107b90526c498e501879d240e37edf5c4ae888ca1be49c05843520b369d229fa3c091caeff8c8994f48038f1698d74be4cc58a9849e5ba45096eae7f4fc5d1bba99f4036d2fcb2a6290f3bb2356d2c371793b6aac78b4dc938993b03b0b5cbee5696a4334d2f6468ef99ade4974f4fc042623a6dede8c3057bddfcbc734d1271eb48cb9461893137fa6213b894e2f9a7d4286cf6ed77ff5b14c87824167ef2a7e564aa5877f02e6f634af2132e9f8ce7191b4f335683616504d9b5abc171e05c365a05cc229490da334d4a583ee909939462fcb5084efcf325082cdacd5b85f334da83a9b3b1fed9930454b5bbf0304dce1fcf44f6c3219af0f95a0c96a261c722e3fb6c682baa4d6b5f4d118c6c987f02c5c9329087a6483a15b866b529c9f143d9ec65f816c36a1654d6d750178ec9e78e6b1f344721ee8b52fc3d30cbd8c37553d09be29338823e58ae90849371c153436d408a7ef65cf8a24575992b7e70a11931ae98fe440d5419668004e43404c81d662ecaf06fc4b616b2901a83613322e6a33e2205585d241ecac060550058cb9b5041c42028223cf8a06956dd56dc3f5b6e243a934e36534aa2217853e50bfaff8140e292c470072af7a7f4962927c0ff310f0e94395e56f9b7a39434f6821dba1924d783d548a55925747d58481cd0909fafd156a9faa2ddaab387d6bb401c461dd5d58b3260f4c3d66ae514c701529150fbee139c4fef3e0b9fb0245df69491ea77b226627264908b3a851b8a7c0605b3660e52cb84b7f22a28997c33191a8c14b6aaaeb1f32586f1bda192e11e3bfc159f7579c6fc95defd4865dacdc0a5eeda936c41712b4b2f9bb72e041988a3be82db322f0707ace951181236f7460dd92ce53653972cfe2a213bd00dde879f12de5cea155fb85efe4802b6835b75a03819c3c524b4267eb509f23e6a87c893ecc161c0a16b3ff9278ad496203771074120c87d3d6b86c7b594b8c76ad2820ec5dfbccb73cfa404ec89c02d0bcca1cdbd724503bbbe7dd09ecd190db126c869884ba2e20d28d9a71620464414ffcf3c083bc98b3c9fb1f9733963c9d448f458e32248b73c621f559591506019b9abd919dd7613e470846d47632679387f2766d4fa7b9078b6431d2687bac991b85adb944039d70765108193efc88977ce2a05ae6084a20da21968cc79f3795c3d2f1acb633b31f20e407566e2a7731a7e7025584a5e6b366aae68d046d8650e3ad110dcab6dc6b158e20577648c7d77c402513f72a33632a3c294fe975c4a8ca55551981837c39ffbe3b1d4a5c2ab70eeb08fb9eb14cf71979accd846b12ddf7443b830300d1b71eed96191fffc2f6838b9aac9aea87367f42cf17c47645d4831bcb6467c1310ce18c1e2be035b5ea60517798822c6da42e8b7c985e03b7f7f112874c66c7b208cfc6728e44ab5d4b64cdb472fc0f04ace1c7e8ca9ffefd59f07cfca7dd9465f2552a5a46b5da53c292f1186a3fa544c526fca9c502b778ba5005e0467971496766ac910a5acb868c2b1459170aa139f2e6dfc5951a75491a29010b19a70b0884d5df25c6703728887327e47369cbe63834208c8e7d52ca5523730dba31916c8e82b92f29e753efeb1c95c3acdcf0ef79f39b6c9e754b1b39f3399986c4732c25396571e805f1053f14f700132cdeff0b88da1b4f50a6f8a9cbfdb580818f2254efc150b8585754a155a82f5ad9e63dbc9e7ae3fa1290718e91c3050012bc594711cd89a76f548cf25a798a4d0a021524cfa07fa578bad1c3dab6f7d058c40b226299e3d91b6c3978ae07ca5351e79dc7e130285e6ec4dfa44de7e7d1dea95ccd8ff23f5a417e9bb642813b6e05fb3a56a58ec27123848fdd1088c2760ecf21be57ce7408ef8eb1f0d251b7ded0adb91969cdcacf1d38fc9feb53dfdc11eb53360f42d29da35e2ee18849337bb9312d45c1bdbb125a3d4ca9b04690bb650aa9f7880c7d300e4e85f48fe702bb7c0838f3b32442dec08a0d7e70425ec32b9a662192853e65e2edd46261602bc0b675d91cdb28216b00832b40df57e228c3bc2253ef2035ff5f53f448cc124b7a3d207ce551b49ae567b1928edda49af151096bfe32e9368a864de3628c10315591c12e85598e972b59df30b4801072a499cf291da5901138ab18c600a98b17222a1bdbf180df55acc3e9a4a981498a615aad1ee02b85cff6921b703da2dac2b0cc375a3bb5e9e0e584a24f3e92ca9a695a8927c1bcd20e263a0a2b516c7e5583fdffc47c83f2c358ef2fb073f973c3d67edcb50a569dfd4fa6d041a592c5821dadb1e1b4248116ebbaa4b2796d9e2c2f868b36d431e92f154f5b3899dc7667c5a3a7af452f23549dd37f6e1e6efeb22b616f8e2ae106997eb69cefad089bafeaaddff4b6fd0f9764bf4dae08dd0ca9d8fbb3424cf64b5a6fb23c5c68fcad81a316ee32d74f17b616885399c16275d20216fc474a2b410308012678b4400c3d66c919c22ed38b12c0670d3ced9b167b6855155536461de3df8dba0c548b80856ac01f33b3694b8a91a8a7f39770bc70e195910d1af0c0a446f1364a51f7bf98f307bf459abd71f2ec7a4b482834037a014056ca9b90c3a88424c7ef10f5b58ef8c20ec17e46a4e05753c80dba21e3c85f53fd4106314dad0943ecd3671fe843f8e3976db89be7839c75b88ae5208802521ce2caa2c8c99407532928bc16d558f535a3acc34151f1ace4484dd815b591f61f7ad713249b6af97ff7a86e668768caa18bbbdcaa7b485f1def5f1c7fcf58d4e84531e840107fd1d85f92b434148673eefa490942b04b6a6b42965483f02a58ae71026af7dbe1745676c54b5fe1c90aadc5ebc590137d138f25628aa360df2f3a1f004b825d99fb74af65b15381dbc56a7fe0f353fa32f3fbd488681df62ba6205ad21a819c7f30da1e76f9ff1233fdc9bec0e876bffc32372c0da61ff625864ca3d309d2ecf7980c86586c82f3d860366db20dd977d50beb30ac3721712746345301b14a484d4d76bbfc9688ba199efb8c5502b8881ffec896b894491f514cc4c021aeb7e2357ceb8169f2780276bcfb12c73b07faad038a171122fae8037ef3fb4aaeea7da8f7e553f948e7fc40caa9108e77a6591cecf740a03accf42acb2d2f2a074a1f53606268b4735993ec991120531e31d880e61bc3c6c30a91ddbb923557a1a5268b77f234f70ae5a22d5b8e21753afba0f0831b08d61d79a99e01b0818c9323c66184d09784a00471043545013b1b7ec4ea82fdf4ee7c823f6be6d7d13a8bfbf2a6c347849b720e7915dc4410e0050850b44ceb84f68f2e45fa4a6aec21be6edb42402d4d4a37ded96a29e8c579f672a85e494a3000f7a1f79e9b9e506b81715de96fbeaf58cba6edef88b777fbf6054dcdb2922c6f2ec3f9e837f6bd4de5fbb2502680afc04a6c3632191353b5e07ac11907d99255fd18a78bd55e592df3ce13580880d987dba2522f31dc2ad514a93c74684bdb8eda98c019b656f9e32c6bf110c82406c1f772f81677dfa7d92cb8552e7cbbbf8236574423946e8d987a60c369c9a0b6a9e06e5d4ddec0d06d4b80c1c8bb4aae673773d3abbeaf8f1cd7e09b0e832bffb61730537a13d900a170ba7275747ee861b4c869438439f9dcf3ea1f25f585b5e3c2edb7d778b85f8bac79a84ad7dd9c345494964b4d882f7123316dca92f076c114b86f9cf51f084d21ceaa081d8f22d627703e043b29f056ae7beae875fcde15400f7176ed368e8e74bd89ee499e9969701eeda5d29ed612edb07bb6cabdfb36143a6f403b8cf8cd871c18900a1b3d528f9eb31b4b4d886abe595af61850c0dc52dc59324192790d24fcac17582bc04980b17de6494d9c6482300c59531ce5194e3a00b40413f088e9d4e5cb6ba5f5e8f18f9b391069d852d7f3a03b3db56718c7c96f27edaa30bee6fd0c43e6325fa0fc8e671c55c0277ea60f494e8666450b1b2f13c9c290b6a46bd87a97c56f2a9e9efb522ead2590541cdf94671b1a043b73854cc15b21773dd73ca70ae804fa892335cf22aaaf23ff4919bdcd1cd598201a7f0ad1a8690db766c48d6ac9e783b7feb091e34b15dd4f5667459f8992e118908d01f56a687bc974a6c3aa4347d6d38daa96371cd4499289b77650326667b15a83589e84b179310032b0e02aa8326acdf54ceacaca9c4047f8c1371696ec5eb49c446553a7a2c3f6a5e6bf1a261ed398e0b9e0e87678e0f13c161680eb5dd7aa0fd0230cb3412485bfee757464d2d7ef708b104dc64d030183ade176aaac1f0627e2f4443ae4f1907c3f7634d8c8cb07a378008ad2e096ab4599d1210e47287d5c4c7176854518a00894510e0bbe95bb4f565cedcefdb1868c2632be5344bcbaca8d37c77d14993e361b39f1930a9bbc9e57d16ebd51774c988f00a7d19573e97f06523ed853ea21ffab24f7f9d3f489bbc43d526089c8a5061fd2357d6d5ee2fba2e7c1deca7e097473e8469af409977df532913d970fb475bd8d0957f4e9ae36bf7ec751ae4c6e5dce4a10a1a1840349a271e7e0fa9c47171e771abde4e63dcde92857acb13e0d4c253190ec1e228ec1af7b410fcd0d077945d7b66c2e7b0d53b4e26063391488e76c932648fe8e23bb26869d7457345a26c3162a2751b4b835a635a539a5dec1db227c7bde8f2618916f338b17ffe20fd07a44765b4b6e9e5ca8ddd187a09bec5621c30e10d97e74585ac198cebbd6d34fa094b0b83e3dfb5c14bf44d1470c00dd4a7b00b198e949391df719fc95f276be505237dc97636ee3529b1965eae61b559373347fe297e924637ce6a4b404cff2d994b392aef54cebc792ab79bedb9ab7d84af4d0acab40ae3c39741bbe1f5d1eb6974ffc734ae8fe08022c40d4a71f9a5091229b6a59b32f169b2540fb2a4ed422e9088b3006d09cc749c6fb521c2ade29d9301de094d00a9c4e455c7375e51f2c39e9d8de89fc43db49d281d9af098497fa1d6fb08aefc801ac2467a55f536c5e6f005e9a559ed74dde7c3b7f9d46529dd9f60502dd15dae5b02117569f4c028348ced6f8319b77d64b529b8b8bc95bb330c48e008996bfa1d1d87b4f3ee3cb5f906ae2b764f7af770810f737af5385a1eb8f67585a489c9454073aab426cf5b13b2bda158eb01a51bc2282e83fa4b48b3a761208cc40080bc4a7b40d5eab532d475641da0ae7ff27c31d64ed27ce6993bdf4a7bd33e0a095a6638cbc0838960d2b8c5f0223f61bac3e63b808c8a0cb5b3040ddc44dedb600e4f04bf6a322f46398af920eba988180bca85bf57f19ce6d024e0bf651374c08830bba5c3eb6fe40fd03372c424713931ea2d9c711df7991046f9818c113fc78ae36f86b9c86a64f19e33f1eed2ba5fa48b5f4d1d88609819dcf6dbdeae99cbc9724fa8227267b91b1ab16decceb8097079fca8e512b0ff662f85cf113d614bc6eda683e58fce7f873ebb898f0cd71ed7b013e57e8ebf95246e54a321867d4e7b1a6948a00e118a61886307a30799cf9cdf53ae08feac8f77c83bf6c42497021c3f7d78b461872eab55ff80c78c6a9545513da3ca4f162363750d4da53865fcd0985686c731d37bc3d265228bb2c803695342bdcbecdef5910b1cdec7dbeb2a9b16961529e23c5a87790597289450ce12270a2ae92ffd3a64ac366880ba2e8f5c3c12d5b769b588136eac4cdb1bf77a38a901ed77d68b083a5f87b1483f816d78b6425ead066fb8bded27fada098476c487cb4911ab6898799d65eeae4c74f85656ff914c283fc324818467d3e3000d02386b10938d07ef0e715e968d341778f863d3a8fa8c9f115cf86cf081dd5b6d4ff4e9a81741557a36d8649b7113e3cb999ebbf84fbaa1126675afc3bd6c144d8e38a04794b090fad7acbb69fa89597e55a6d49b845cbeab24231fbbd0199f1a95af72eebc4cb808239f70a704b390bb5b7ae5c4cd904fdc9d7ee9730cb464a3d647f7eea33ebcb1c61d33e46804395070713a46e7460650116ece75e29ab4743c7a5b44fcd6198c11a2a28064b57c1167d5016843d1ae97fbf601c332f4a8490c79cdeb3d911db0faaa2543050e6e38532bc1295c593333916cc29eec4d6aaeb72401eba3482dda0936f995823dae69224e41ed38348cfdf9cf0ad15e8b4f27bda3db8ba0662310707c28fe415f95c16c2883f85c4981c72d9cec924bbd85da4aca6395a9a377d7b2f7cae91561f7392823c7c00946331e23dc653f5ff39a66483b74627687697f89467c37a283751bc67b77ef36d851954636ab9c9390b6d76d43541eed975140d2022d209212617596ce24a5cf6a73e9130bd7209dc4fe2daaf8515bb5f08543258e7c041220c29ade9ba85db240a2f1dfebbb9f758fb5e21a319926e4dcf6594928164c842dca55d016165121c7f0e74508e4d2c769188c12e806ecadb317ccd49e792a846045f3c7bec49b98671d5dfbf5a9d637f8d5855f7f9f59e10483473dce42cc0ec7f92ec0a5d356d35ba45a56f13fc9fff67a83e4b5be36c891069e4b155a6741b9544310e3004fb97376812d462bde57803b5adb21b96b5e57a261732bd35271cd413b9cb1609f030bfeefcda08a9b3a116db720784a97d1f212f09a859e8c7a5c4b3bbc3dcef0babf38327d8cd7496984a6cb90b09d1ad10fe6d1dca86eb233f054e2e70a44997431b61b352e60700871021354b79c23e99a17e5116469ff1007fac8005a19559f18eee12adc519ca18b5db274a8774f938eacb56492542e807349e12ce5d7db7c1a6a48db21baa763d91bf6e44565e32fdc2770e63a4475e62d71db5bd3565e574e5e13a49f65ad50086c308beaff5221c12158a67b78b62b80c3d8cfaf4d40461ba33412ec7f68bd887e2b5b3012472f67c81cbacb64705ac047341894b2835795956a50ea30ac25cd78083fb5eac92e6b1a2e7cab422e4e1a79eedba0907c4bce269b0fdbda28d5030b5a41ea69b2bd3e302d747cb455abe0ead2cd97ed6f3e1a13bb0c10775bcbe70dcb8770ce61596b9803d161b4255a5e4f4d234d1914c94c22d6533edcbc34d244a4c58c8cc6a399710d30739c1cbc20967db69a8f3e207f9bef340bc5d105b32338e9871ad1858f03dccaa449931352a98857887dc29cca4e3a820427c11149cd7bcfbe2ad9111dc7fc954b11cbf130fd712bf3054fb91f36fb7d52071012c3df0a32365ba1184c226060b2717975be1f2c88646e81b4e28e3f4cbbf3ff77f8abda650593387aab4528c10bb755f93eacf807a4a01558cfa1af422f764ff81afb565017467937c34f02b93477c59cc75db3bcc8189f05012b6eeb53df947680fb258df4bc8347cf6d5b26d1ba7b9d66e1a25fbc1730258e577259a74ee68d0409a06e973825185f64ac5e2f352dec8c2cda564ec20713a1571039b2fa73b6f991b8dce88a1f1b972d674c8eb0ee7d0554ad72780502a6da9f3368c5bb1e355593719dfd36994a29884b25c13d2f0af62f691f0602a46c5b429aa66e5cd382aa1ca1789fefd5f2291b182893d4b3097f18510e7fc557d1443b685c984adaba0d5e977cb0138e0681d3489b3539a17f3c5735eb731b26fce5afda2350c5e5dd02844f6bdd4b8b37101e5bcd16dbb23a1289115ac00b275eb117c96e28211e82b0310df126632593e1db8d2dc57178003420ba777551e82c92adea3a88929489e52c8c110f64a1639c9c8eb2163ae8a0c2d8e88e6921e45c6a394c9dd67793ac4625d031a29f4942ce38ff6dd847ab08b9716ad183fd2ce7a92257a7abd9651d0d5780b728b6990335118677cea693f029e003f7d361be3370899cba4e89803cbc038e6d4b19c6ac5ccc632d61e76facdfc57326f0797f4b7f04aa6c97ba827e41a35a5b48d70c692a59e4cdf4a8375dacd025b05435be1af2347738b38151696912ae6358a3934f96f61e639c0e189049f4c5e37e61448c54b47a0f87f05ae2dd17a460ecfe893b253c30a05344086629e7faf7bfabd80c8ec8470691a03dd207cd5b8e6ddf26d76cc9c075d3985365002aa1f487011872389696c53bbdf7a6750e34ea0a6358aaf7ede3347e0bbc6cf59f0bf3493345fbe568e5ccb55ce68b220ef00f15319e9ff8417ba4107daa9efd06d6582491a9ddf23e5fe50f9d8c8857ecda86f532af25e7af7cb650aee7eb1f3a1f335e0636b38c1f570082eb770c266a995da1b01654355a9e559e18f3dc120ebae5316b506f87ec314de1d376b7e42a9fad3ba6e12297569c3cbada2ef46150500aa63000ae37ee607c428bc4557ef38bcea2d5e7bb273e68b9a876430d49c82014e987ca06cdffcd1e0d44ae298c365a53cfda892a69f844d76cbb957b410f0db0cc2814953176450b642261495e5a1cf27d750ed00fd2a79e0af8cc3e308e00c9c00c365340767d40f442fb92d95cd0fe038e70d5677ebefb571c473b3b1a9bf95544fe6e5e5c84f046f2b6a191cc070e869d2a8ef395b311dcbcd0ea51d2fd5db9dad6513fba62f10056d11040a07b76dc1b25cdb03e0387687a8714d3af8afb8dd7d476837432226e7dc9238c97aa6bcaef966cb17f43ce1876f1378ad076c1573a30ec2aaa8337633048baf8032636a2af8f1a77479ab5878815ce95be02fd468fb8716d1b0d02992379827d7c5eebe15c299eb3329949e004584a677ee18e7e46822b38203d30a03f2e72b494817404af8b0fd52e0661053560d055a84294fd2fa172484e4d3e427b295de91ccc624b74826fa7a45ba05d5b280d16ee2f1c631a4d6f86e023ccc31e34347c346f197c6d0db9af61629a59a4a2fde252be2af03ae19a8bcb9eb6e730df7cd130c9c4840e084ccce82d3e660096644fc4950924fed664c3fcfd4c7a9480cb566c70570d42a3be450c783b81f47e50e7888fc48586ac571ce2e0acbef993b6a1fdc68b050cce3cf51adf764185e25976c515358e19ce21063b544fe25edca8277ef015054e3c4485eed1beaff2ccc9c663a9fe3f04e5002e860d22040af5cfec010c2e54b185ae31f8bc9773d9fbe5abe63d09c7a6d212bbc0333a0f2e942e767b6cd94fc1f4273b9ab310afafdb1742795227262e25e00a1a502db059857773a784ccbc9efc4284f4bc69b1c9a00669f4f0399dde5e662435aad65a2550e1e23b6bc7cccf674f482b764c0a9c10b89bb6f9c7b49b9b5d5e47ffcacc307b278f576c780729f38e1d292ad20b5eafefdb3f28bb93d16f468de47da7fdb8b8951deba9cbe2b3d68489f278d9e8e4396404fd8fa98952ebad1fa702afe85eff9b02a55245367c6dcca67a0cd7b66ec466d788af5f0fd2bf9b066c85b38ac33d2c40340d0e1925e37d78364d640fbe7fe06fa960649e51d8889c7291695a0c527a4cb99ba775e2c8871acc1865cb537168a6b7e14fa862ffcace9c3dd2086bbef532e85669ce53c1196f5faf5b8b0458573faf752cecc6e821f319518ffd4e4d789fb27b92b0208ab74adc52373b52e756bf4d4f08df508f9a6e50e12a5a04258de0f1a1065a0f7dd1bed68c17346136fea0ff9bbd65096e649d9a91ddd9543a7756ff57dc37777534b27544f3bb9c19de56941b2665567fb6fcc36d1b34b47955cbc6a56c4212684efae7c9b76a61a3d0ec5dcf17727873794b8750685d7274ee13785ba46fc9b2ab5855668fae7c8652d30fc82c86e4f694036412b3a43f7a14e34045c1610ac2877f49828d93e0d5f415d2e853ada585cd0b474fe858a198ead2bca677c448aa7f8d024f4edbd0c9a234c958682ceb1e8c09e0d964f43ce32b2f4e2e658a4069d4298f2bd3e62d2143ab9802f7ddcda63114fef6adafbd62b56bd66856f637ffdfdd07117e0e84fc35479db536869e99e84e261fce34f4c2caf08164c210e6e0d44e0d950841240b1dbcffa9f9ef82cfc13130ad35ca2fa9a60cd19a99b8b537854dec4afc4f643669e1360d1889786a55a81a968a6a302266ed406f83eee7cd647ef848a7d44c88529c7de371e8543ec3fee31f39254ccde3f1e945e2454c52e6d9a920163e7c763848ac9079c0aad3e0bb7d6e8212588f3cf26b174e604cf671af8de10fce17fe30ce680af5410f83181c2fde43382e008ef03f66c9530f82d529e8b6684f5a4881b1b1d648de4d49fd32acc68301226cc14a19435fc0a199e260f3aa2125c14aff85c378e8701cb6530ec82d5661f1093c11a2bc32bb5dc3fb52736d49e49a671f549a930d72fee9382a16f011c6236888b9eaabae90d88d73b08e76887ab1ec5ca7c03b3e6dc65c8db95ef7c61d69aed0be2e8f2b021839a32ad29047087765a93663a4d3e057c174e7b168afa8dde876fc429644587e9c1829220b19cd46f0780505c375bb83e32a7c36fcd8a50b46213a37f2ac779a8c8982721eb94a27c0239058676d7e5c8f99c26dc9e5ea3b54df88cbf069537361dd680f0f5fcdd385b9977d265c4fa4cb143bdaf710319fb7d33bf764a9ce56c8384dc549708df4602dcb873f73d62a3c34b7b7481d020487cdafdc5d83de26504fca37494629b700761e19eaa56b7abfba92369501ebb791d70b2144f9f8bc0f11233a638f21e340ae875a30a2e40cfcf3834d4b1bad4c7a904e878f7cd8f5c829d4fcbe752314c12ee5fc933eb4df83d2c82c6c97ac3500fffd4e58313932d7f8634ae417992fbdc201976eb2e6598df2a20c78176c07c6152ccf89247c37fb74efe22df38d15b684142b6859661f34698d3053e93231a13cdb14fd58665483ecad4863b647541d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
