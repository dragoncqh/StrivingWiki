<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fc7c6a00dcdd1403cd03ad5542972e3a8222d60c6e021d368cd8ef2452c4e6f190773d80cbc751ebbf4bcd54b1d239c07198a52743ea4e74bab9084e72bba53762c82a245bd01321e95f98a9698c0917724ea07da1e141b7454d4f15af51c8f8511ba816b1952dc66b574be855969e8f21ad08463227c05ac89334e8700f2c814a3a73197baf4ab34bc43d1352543cfd511647f3c854a2e033132163473adbc68282308cba132923ce2cad36da032842f159feff213c3416616952fd97650b3f8c6a76f9700bba4706788cd25f3b6274f8ed61434725fc3320a2106cd8e0cd3a32a2fbbda9cff99cce92b88fb26d67afaf5b48667cac68d10c2849a97e3b47cc20b1ee19b04012c47ceebd78f4bd519d7ff4ecc3e98d096b917b73b2e09560b709c6c4bd3ca0c09efab14c994c03d25cbeeb86d64c8e17fa342e3bbd731a51cff08114aa4d4f629c3649da99af164e17b02c826d63ac8ccc9743a4b50f8ecef832fa81f827ce6ef6ab9e9c0ca58c0a8af300911e61d356d9d6ce837384f2043ec9f13ed00931312e4a6c98129445ac192c9afdd9320a9b622d77d03c0156793bf44d660a0b9f4769245b83fd8afe0617b3670801dfc38ed86610115b4f1e4470ab4f398377271106b7f4bdc78de9562f2fa80a12d128c6af754f007cd97d6893e606d14846dea54d2b40e3696d732d39a0fd0559b8df373bc1b11cb4650f4f375242aadc5f3247398a931a9c8a83f162ea0e996409140bf3e7c75c8ea31e3136a332edf6b8b4508609f75198c04341ddc295d67043b17dadcb85ff8c844e0e16b3aa1c91f95843244a9d1d47a1dcab83639f879574fb7892658c73dfbcaf4885bc0ac35f10add5751bf7bd77cfe20086ec17262720513295a358e467b1378be89fdbee681ae3a9cbd1a95b954e7675e46b833323fd8949c7cff5d1330cb6e954a3af963ae335b50e1196252048386ab13021ea022edf0fd4218c0137fb9a64d16551c1b8036f712147916b333c1a53a3a2e98746e2dcb14f64e3e2493787bdd36f92d80934dbda6b784dcbed93a825cb476d93bf9d5a37ee53d8008f1c97a32f198316556186506e2801515c15086846645859a79b2276a60533e97b1abfef898757f4a978c9cdc9c0930bfdcbb3e94dcf723679f047b2740280593949fa02668e3d4774427a704b55895a4ad605d871a908a3f97b5539030183a5befc12ec64dda67fdc14fd27aea9c3a65b38632fe8c93b85deb342b057069ffe190d616bbcfd31510ea054f73aafc72642c7352bf0195a8331b65866edb093c76d9da103f7cb1a6a1265b62d0e0156225ed18afd9d90bf8cde2fcfb3742912a2feb67edebc30874cb7c63142ae4655c21321e9027fdeb377844ea0ae37ebde890834dce2b454f15b3efcf464fb45c5603b172155070c1d4eecc3a0b1e2094c893b33a83785d51e424971be2b755d42efda0dce75d52b3d27db97267b28f86c15d8b26c2ca815c1f4a642f2a99ee4f3eb410165a1afd7e30585d587e5b978e3254f76c62c52ba1440c982d1e37aded53d109a2299e4df2a6e0b8ed91692fd1de96e77910a05b3e448d0b112a85ca3e91a97671d1bf4da7fb43b031042c53cbeabe6597d63c2e5c64d7cf8173eb0b2b588c805a6338d1ecda82f480e4954afd99495d43ebb075e29127c0e975ff10464156b01178367d29aaa1b6453a48b36b7bdad6308c8f372f89e70fb37e0d50fd0787571b6836c4a65b7b1829b7014c73dca0e951d8b05b3411b1436a2e45ab989748f2f802f83501cc44fe892898b4f53b82f13c1b684e7ba76e128571e0f823daa17d04b555387c5e3a7922e8da0aa7ef01648f559e80c07c3999ee21ba7863a007b05640669c5168c722a662fc8e9105f166dc93a86c2a639d402dea43d49664837bfda93ea62917b806965d272a9de459dd626b2468cdb78a9083c4c7b24f04f79275f04bf751f4dd41b27566210305b0fb8aeb1a8fd3393d7c3fa4e6823dca2092a1bebfae952b2e131931dbe1cbdde9fd09ab608b9a3b8080007502e51123cc3f1a1d38479d4255efa1f19f2db56959c35fa926c7e9614af65c29894e7df7ae1254f4bcfc50e56909d9e58aba1dc0705511a83cbc9be5966fe389920ab0cb80547d4a6f47f8d65964c32d0466f0927ce9d0157f62b42c41848b12d571423a62f26e7cc40bc57fd1867a6701b5a6563b14f1aec7d534eb32e29b93183b466dc3b5bc1b67678fee0056d74dd0609cbba63d11f26c5ae69dd5b5a2804ab2f4032f24872357c3fe824c4a691969c11847140290390b86322112d06c9f6781913e58113f28a465ace5a1e64ae458a2df2187043c9e0d1149074e23324f7cc7981ad390ac155e79f5c08488a7f6d8cc0c1698d61080fccfc170d87e10abcf906fd762319dba106f0bd814fc7695ffe1eb8cec0cb150e60998f6a2633a80efc6ab6eac89017b075e20e9d92db119c0c68d5c085c9e51accb188666cfbaff5a59ea09b3769161032da75d834ba7102b6b8fe8acc827c7832184dd0c5b1db63800eb8fcf439f41b970e428355572a2e6473ff52cbcfc5478e53370f12eeac104538f079390a2dd40b9804fe164ef6fc4ebc7b6fd585ddc59d4a2c62334d59a2956e711c3f7c9cc75f4338743010f0ad522e2893f087bac1a12577d3ee59f2d9e5b11e25e75952a8bd4d7af18739cdc5d997fd5a4895cae3c1d8e53812324ce6e80d51a43f663e67b74a9903fdc91d2fdfc4eea7fa9811cfd2b23ea44385514e652a09fbcf06e4c24d41a392a7680b677a7cf2621de68b1aa901218cd194b187278e0114d5f45ef5085c9f2c81ded6cd26aa050c653f9bd53327f49a5619465767b642e6b3d5be0eee43924f75c0d9a906e1078b08b34a78e4fdd741907cd83a072aa14daaf4622cc8b12a89400167cea296aedae84b4bb4c58b641bdf461c808f33180001e9a94aea5ca699ca5cc065a079a54c1f6ca565d5002d3efa5ac839eb77cfaf4507f457d67c65391003667785878a287a3b503b3fe2f32384ef07396b70726767aabe1ee43d14db83b5b44aba312f1ed5928a5f6e91e34c989f81eb894f0c81c402cfe3535c63f2bca2a3266588029d580f5e5406e906284b62fa765a0d502c903316dab090390a86d644692fa3fa3e76ca51771df70fce0aa06b57a5d0164e9154cda59f4f3b874a6b7b70817ae5a3ea6223ab8c140dc57d8458f3027c27e2181a39cd90a1619f329ecf048eb60989bd47985979fbb48db7bacb51e5a7c3b2e492deda5f1920f51331b7969b61b4e36f73cda999478a835ccede17008cb1ff7887164ba8303e9596dfacc6ff1de4674cb281084eb4f7ccacf099c4071d17a04d2deeaebf15449f0f9c7189089f9f973ba3ed2381364e257fa35430065a3ca884e90f454c5f6e8778499c16281386e8bdbf4817b70e7b962d533d7314c0bf53f5160472c8fb3be965571b1d8dcae4873a53e9583896caa7dd5ca6bb1735329986c440ece48aabfc9d00e447b0b614f05f5a62486de9647bb82339bf694802b57dc5d720b98059db2d01be1ff1892d0d72ef2e26209bbe3f4c5ba3e076c5811091cf87116da814501eadcb9ea9cee2c50cce0227875dc77335ce34840529e23a46c21432daf1294a77f9c970ef4d5d50847102aafe85b9e414b9847c8197bbbe7be03cb0cabd18b0c07ca0b37ec756e087d55e408cae3ff2b5e2b4b345cb1e553a19934844c6f5f5070ea656b34379bd1eaf6e7b112c27a9dd230d583b5975a2403381ccfb43b6dfe9d01cf3eac0befef762cc272ffc60e86b14559ab668f2d2c0e9598e3870aa2a0c2a90cd5f4d1d628d13979e3d4e560bb3b84d3edda74c3e54e9626e05351a125e87dffe4f34592dab378c195fd3c380a7fa284d22b1fa32b951582e32c9cae13e89621db6ca7b917dcd480592a839197fc56e44a9a2e86309050fa749e9cc312a63106e183cdccddb95302d12ffe0f62e388f0868072b6b9e93adc59c5117689f549fbd667d8797c5825a6128f918cd44204cc9065786b34668a62945413eca05dea27dd8288b7c792523e2b929fbabe39f896574336886e420713c179fa5609b667c985405f6df33d9677041a8eca03da3e71386a23be24b6fa0e5e91501a7c1e97df2040cabc0e1fb45511e37cc9143ffc6ce3e82464498a2b9ef482c4ff39b73dce024c0a7d57cf9f6dd7cd3d77a89162ec7d5050d1c441c0b9ffc0783ab1619c9d44361cb4fec4c3a1a62ab3672a3c23423a550c751d7a21309362a1e9a8be077e38f410f0dfab03f160e609c46d07d16b0ebaae4648696e12550efb6660f6c8c3b07158e482626395433d1d8a1b2304732a832cff860ca88b3d045535dba6b63ed1bf4d8f4ced093b5a5708419c6b090d32f5a315560438b9e5733a38b16a2733ea85d1c49f1e41e82f7dbc4aef2dc7419d53c4b727add80dc0c07e6c87fddb0bc60d83493081ac0bbd9beaca03a163179bc900f52cf1d897c045374408dabff5ccc73688435972d972917b19925074a11bb1660ca6e0a8acc7f0b8a88cce139175642dd4b26990de036e02c9c2415c374243e3ebcf98e3a258725728b38ad7d694e10e08c5e9c7e30b44307cb3750cf8dfb8af911aba9eb2d702de9765a13d05cc612345932efc6a1c9add89c23414773609a021c8c096fb270d6f3cd453f265f2213e0ac7251a53671687e9fd5fc3544f2cd0a19568b4892cdcdf62bb09203cfab36d57cca6594e3b1d3f90c4a2e1e035c3299f03fa3e6177dc48342f5230d6643ab8a249bc0c7bb7cab52cbe3e80cd2ef229d9a738f6e17c605c1b018b578e6dcc2619ba9ed4683648ab55e3f573b96e3e05eb885663565ad1e09cc5dc7adf78cdef4796839e030511b2b608bc32d309541358da3cb73d4cc6d9878d87285846a74fa89f48375a39e9ccc0e7ee9a2a7646ea9349c41b5a6d98fe7dac63249ff0fcbbbb469f0cff08f1f70700a33847acb021ceff15ebc4a13bfb6c0567c80677786db634e999f5c19f63bd6d2f0277ccab333763226317112dfa16297069b3d0aea980c0c44ae64b5918dc1f25b634de2e478d987888688de85c510cd3608ed32b9b6b14db58f963fe08917f000e786917200d5d38d9e939958585c58e008ad66a37fb51e37a9cb71e93b2a4ceef7fb392ae838994f79b116942c3945159f6424240b2d1bf6d199bcb736cbdcf35bbb627106fd3fc3d060243259964fb88f3c89146eb4408d9bb0bab4671727aef6382fd3e0d5e82b1101faac0be9ac7fdb867b7656d66b50ded217d8457384519ea3b71c6bf60962990651e1a04584bce4585016fa105ffcc65bb5472e0c76f88f26f5b5cd2ba1443b9675da474725009d9742bd70b607ca82e7e40b595fb385defbd6b4a1ee47f82cb04cc4f611de586239c4d7cd44b10e403ff3e252b13d7e7de16bd7780c5d5f1aaac16b535c19cf1aee47bcc9def9d4c9c995b104537d079117bea4bce55a8f2b6d3910181a410fedc2a72c62ff74752a6848656db4be09087a244a716bbd87ccb8d10457bcbb53ac03f47dacf189cbd3e9bc1234b22378e3b13df71c0f312cd369ff99c62ea58e9b1d3f78a847532e4b32af36d745d245c6a5197747289c77aca7e9ada220d89ac692f7233d123e6977429fe4f0fec16edc57024f6565ea039ca8d64325781650dac498fda28560fbb0791db2fbf0b6dcb71466930f68f1af9dc397d97b40c2fc73d193932fbfb9a3f0c339fc174ef9de2386434a9e35dacbeb2615f3e4983ea2b59d11b4a5091885d6ed12e570ad7dab72505fe8ca9f23e884e66953ef934b090a08baf5ada65ff8e54542d5089e5d478115d93720b591b0e65e734cdb7c8e74b06ca433cbba2f56cf2cd39bbad1196f918bc681a0d135177f7c8b4402af438e978d8498f97842b5439b622f5ce6da4db61bdfb871207312062de2c4dfbfa9d79e294bee06ae38b30654a9e29b42667a300858d4e249c7780adc2ffb821516a6675c2477165ca7a666adc1d64d5083c1ff64d25d1cacb5be0fb9c2346d5fa5db8799c84e77807ccea71d95961fca439afd4567111101fcff2dd5623c1583625c82df38bf35395ec6c84b67ac14801a08384a54ae93d9379a9e50c40db7650c69568aa927faec91e24eba419e5355e151d2a8882d0f88e488c9c6f2dcb0d0d9a64fc9102c242b7dea19f4f0d673cbc5bf8c50092231792927b8264c6d82ef63975bd0a6b5406d6edd555651f4d804915e7f0bc2414ab02447d36834b98fd7af86b022a10c3376fdc34868f6a68712366b31d51c07c22dc3cdaa7fe505b7d317548b1bd42c4b3f707014919f45e16edeeb4f2aed2c93eb84df4e8a805770456b76614a8c7614556cbe7e2efa7da5d448191a308a056204432e05847690ce93ace0178eac698861544a3bcf29c64b42dc1046fa108f05ef959487302aea7ddcd8b17fe80ee188323d56e93d51f7138ef3f466b9d76fa57d26b0fc18bf2c084011d4b21942aac398922110beca206a55991baf1923ae2ec86c4c083d0c164718859e211e7636d40ecfd88bc99fc05a1c9470867386ae076d2cf2520272c94e741d4207f51c7d6e585bf73230e34a7ee5a53459f9c8d07830eb39df14372d2e9cef1874dac1fc67445b3e2437ef5de679b21cdb55262d0806893f2541fad75b95c77245567c4711da5d24516cdbc1cbd4dc204ab93779849c95d34393f34fab4eb1586d725659b867d4a7abd0c00d0ba044bc87380cfbeda0cc77650d030731d60f14158002d9c5535a5a4c60893f7b436bad3bc1a349f323009f733adc5eb39dd339bbd3fd58c8cbe380fe91218b5b392f11054ecea84c7c6f4b81a5f1b2a1caf5404430793fda5840f170df3e44ca63ea0f28fb7fde94b3e86f29c9e25e9cc31fd1cbb4bfa83b89e8a6cf4ec8e94fa01385dc416891fed5d4c537c080be92707261fa970bc2a0d9dfe352b2b5daabd71ad2e83b1900c4a66f50b2c7d8942963ea3d50280d00eb17c957737c312d5e3e3d669386699212c26d7f70e629639b2ce355d4b83bd2cf126d48978b7cfb96f332f8598c0386a0a743c81317c6b1794e5f34ec4d547328ede71af5a7990a504685944b77080c435b49ecef679871b00cac175d35490451f815a9fd9e441e13cb8a8ab9a057c3a53fa2542eba1cda7ff4a85c37bc802fd8c39fd14324135af0ffdd53c6b03add29d509bcfb635d82a2ce3f4d48c7e4ca693569c763e760027a84e7ce71dd49f3cd441a332a6f479ecbd6080287f415e3b21dcc76528fb7421edd93f4460915679c8dd5ca63160017c33f616ee811a58625397ab654c8f3e441f3d7b99825a09cc4b6ecc0a56582de561ccbbf46fc30f8328607d5052a37f3476461137c5bd90f2a8ab3edfecfbab448f90fbb4825340fcaa65e56e0201fdba1efc452a257fe7314022740ffaaeac2fe0e7512e5014763d194f63ac9b9af141e554ea6f77bbbd059ab1c17ca62c557479ba1b18713d422dacc5dca8a30413831e0fff9871b6990caf31a33d315de6ac058a8a4e485147710705e59198ea150ed964b214cb8c6afc07e993e1c6f83c34459b71481048a69dfc852b9823d22e9e8dd599008f858355177d508756fe66094bd789e48f841872e0e4f9a4cc066af3d80f70c2eee3605209272b280844cb2e55a29318b05769a893078c24683314395855fee4bf805a9f3657c7f230fc9ce9aa8b91bca6e8a37dc417bce73f8515dd13a0af2dee7be3917f71a114cfa8b4ddcb3fd09231d02aebb121deb70a193eef6df322c5f69e4f68ea75eaa08e1136f7f55940b578af39f606f238f1fb3834febd0191697c8e9ff808ab80f01505a1ec9b89ce3ce3e6c30fcc930f42249d31b6daf1fa8a6f5e0df73e430051a020e84201e16f2eb02001ef8b79cc18a2502268953c4f7fdc39610ffaf63e794b8b064278280d55f81d1018d3fede2adc83c4ce93de73b06e48e59760656c716309a21344d11a28f48bd896574ddec00179ebdc39fcc8f2a242ff10933a31f6db908324b3d33baa153047e0dd12a7273480782ae0d8024ea37b28218dfbc919f48707783e75c6074890449334e3cd6010b71a747a47254b7e0498e46034d6c0fd358276ba47e75b51659de27d398171935edc30a080265ba10aa3594e39e0641f40bf63cb5b71a867966cb7f038eca40462a3e8f6b4972357612e102824d15c3fed16e5635d5bf89874ec53f6fd4206c19bf3abe829fe47f688e6c6eab507853d17dc1d25732c052f2c92359ff4d3a85590e223f9f46baa351d7b634e53d10c9186f310d02a60dd0f3cdf01362500c3d2e0e08c1ff846935270f2242bf7b281bc6f47c591d5456ca5a69dce90710742aac94f40f9bbd7c92e2f40f3b87c50b7349bc8dfbd82127fc15bb307a41c1d88d44c6390293dc3b62c01661144455c27424263046606564c61ba25007a5f0ae1c8529774a2ed20e142cc2521c4efe2645011e15a10db1c70e19aa96c9ad6c9628ced95bff703285e1cb9a1ba2eac5d41c1e3834b0049bacde806296ab2a788fdc86940bb5d94c11ce3965625066e2c95ff4a85cf995edb30814339cf022e789c43cf97878a7cd04c91534ad168d31565e36f46b8259186bcfac556e4f38d48faed0be","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
