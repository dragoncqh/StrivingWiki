<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"08147e5e871e7412a9b802651582dba8cb32e07e17f163df7f941175074f5148b1171255b36283ed9fef871a27229be136f98e5473a9078a3227bb53c1d4e7a753081e7cb596ca642e87bc09462fcfa4260d4c3c9df084426d90916659e5beb415fd0016013345e6023f6156c75e8c00fe52e56d894f17650ba92e4e49255baaaec1d590e6f4b9ce74e8235ae83219f97047e25ffd5f66ee6bd49d356b11a4d5af49329a80f92c90314956e51bd507e65ed1cf2702762abae2eb48a344986ad19f5207e01e8265a24b9d84dd97359f47740f710f4baceaebd48d437d3624ead99ea561b6451c1d4625e82997ec8dd4b4f2eae911e34f79c55184be12f0b671ad1fd3312900fdc0de87a6a3fd2e8b6ee4225beceff7264e58219d3be16b0bfc5bbf44ad3500b70ed68b18043bfac2489f1d5a62880f892c5d71c70397b34f7751df39162ce0ce1eb196f895c09887402020517ef346125fa6e51c614990bc06e624eb21bd37e1601a87a2a4f09fc91ed8b8adc1128e34c98d5511cf069fc612c06184d397ec262110dcd3246766d350a1bf202696d9cb50525433652c2fe691a6b3b09b1f549b15e52e5c1b09da763fd2d77b101ad68b1c1b1da2385ae27b0e1e535036c8d80d6cef37d612e0e43fad3a5b7ed180dd47782a8080006afd15f6ac085273b4758337ad7cc20ae34b49766d84ce77f44c970bd7d7be9f0a35a3ceb1bbbd31d50dda13c50a057d2fb7d2475cb4cfc83ad4766a44854a1229547c2d2df465c3b365c65a5660d6ab59839705a78da2b654eeac38434c5593497ebbe5a29ba292a0f78bbd1168583bdc28cbcb6cb4d93f45a58bcb5198a06fcd50475b4f23e47bdb16add905175a5772bfd525b3f2d5800d8b99e93bf04cf25adf752b033bc43e0ce73edc8ff4a07a5a846c1d4334f4a5e74a54425d91a8c546d0a32db6056074e97423faf4f3e53aeb49efd2679e364aaef80b3a7256ffe3bbdbdaf9abf9b3532c5d977aff6a82559941e0a0acc7892114a12dedb61b05257baa373edbafa0deaccb96beea3ea5c105287fcf592cb73c77d3af6f74cf3b0a43cb00457cca685c1d018631adaed3e60e74674fac54695c0d8e2ec34dffb6ac62ec274fdc4aca832a09399191f7e0378da3e9dc753b60a1be0c753dc5378909aa9ca41e79f7b5b8514e753f31d5cc8dbad409106483544858f9fa906e40583d0a2e4bfc3f59bd15f0079634cb79a920e85b8cb9d47a8fd696a68d80c1c2674549703d680618f6fe2ee405d770654310fda2231bf6a26f43910020e6dd87c229a08649ac5d6601276e60b92ad28a969a7ecfa6ba768ebfd39cf71b2f0c891bfabd8b2d2826fe1b8c203c022171eeee9f17ad7cebdbb1631b901b5a709ae4d5ac2f48718f83b06a6775ee52c5b8bf19033f8e39253020e0862a77955cb0c13ffe50cc57bf0201982ca706fcf1221d537e7a2df080643e339b4ca18837c080f2c60cb19ec16b5a25fd4414db500ca698300ac4a30db370104f8a843fffe97403ac7130ed9f257571bad0f5018735de1ddb99e9413ef18c31d0e038a60f199064a5cf3de77f97f81f5982921699f792814430e979e44865a8eff42dd3442b2828d76568ea7d306e4242de411888ee08d72de602f8305d66efa10249e89f54e9b0b802a48d9d6f5a6ae22627b297c4aee565afa902c279ec2003cb6364ba55b4beb867cba3e0587444cfa89795130bc864841f2e29c949bddd8f5762246a6a9e175363380e4ad43c977b864809614371d6b869e9611a91cfaefb31cde9029eb87d988a637a76a0d6b6d66b6f5de2ccba8ebb7202c6563aab7cd483dbb5f125d1b491ea25133820fc408195bed57a449f03ed4853fdb1b52a3d56bf0b3b900ca7a0fea376da9d390b79dd4e2afc4cbe23ca0544e65c11bcec908e5f366ad2034642b3e3bf1e2268e2eeb35c6b210a853336c3d4c3c0ca14b059f4d4bbc4acb986b934c0a366ed077b6412f6d3497f8c7f6fec6e56b2483129a7a731dde6b3318712399b7fcfa46594e24ee1fbc694f9413334cf612062a348f411b539d77f00354a3d9e24aabc4c4bb1acf9ae003578ecde8b38fd936108be27bbbbd104a644ff60d9d1ca54589a4f6d48d5fc6b91df65846a0c58647bf4a90c62f06749e12ecb563204dee6bd1b4f2fd2a1d80eb12ef882130c0231c02998ae034fb1edf5e257cbbfd0fadbf3b9b54ca0504ad9865d455c3a2e416f4234871d8ed41bb9e34acc1a2e5c39fe561d2436294b7d33dab986ecf21f285dd83b678929ea2726c04a796455725f78f8576435857cf6fead12b84abe79551873890969e95c8a4af2df9a445eaa92d12af18108280ea4aeafce8e7fe5f779ee59c111c15d6fc6107a927f010ef028ecb8b36de5e86703ecb303b90ca1b4ab5341656cc78fd19f08a657af8689827a7134fb6ba4751bb2ca20f718d22abe269aca2941b4be9c3dd4660bdbccbb771f223e8b24b7fd31895380136b0d481152dcdf7a1b7b1b6e342b4ae2b6e28f33c3286d7cfac46181430038a8ab3c08c15ae318600714ffb692c493326aad0df7cf493a392cdd57fabff042a890bcc610be01457b8aee2ca7b83c4a38f51fddc1a6f8c7b88e5a7499a04a411f760ef74115415fe56941933a6aabcef2bcf4f701d9d8bf8b96b98c2afb155647708005e737988e6971df36733f9972cc8eff6edefae3d5acfd939df1ba37467fb818d8e88cff93f3ef6257b645b6abf4bb1e2bdf041ec50bd4c6e9dc21936a5ae56f5fae0c4acbaac5c8c144b457f471885a6d00fa191e99e88e70dbee50feb988a546d1e839910e582f4b0d96c1acc2fc66260c9e8c9d356acf20116acf2c88847f19818ce11887a0d5f4039820d5142ff35ceb89737706129f1447a32b4ebbb9d3cbab42dc7fda51c4a6af757e08c4d1d5bc9077d6cf815edad0480235d66ca2663d424fa452f7881d7f8bc4e4634d8b118aa049f6cedffc6f99966ab2e8afc4da34be40fcab607b1095ab72e2b2ef9a8fca8bc670fd31ed5d6ade592d1ccf7757583619cce1147a2f907acec2fdc15adcaed88e3cbf4b3148ef7d4a4f7d612bef603a9163025d828ba6f9a61dea3cc65779c542f9abf75f20084f8afee2e459cd6139aacead028c8762c0205d8c668f282a7a26db369c5ab5d5b411c91e7448081f46ff20356a0758b158e97191ef976bc56740889d4db4b6d878544df25e06f71c494d42a615a236e6582ab323ede2ec630dcabe104cdda503d60c7ddfca83e73215295a880fbd08c9ad31df09da245b9e519a8c40e28d9d67782d91330bdfca2681e92ae4db32c9d7373dd4957fb672b13504e4c429d798b7e0a25ab1e773177b567138df552c8c886708bb918cb1027fb3ae7d03690d1a0aaa795ea153d710a8e99b79de334bd731e48d3224f5d7334114eff5cd5870499a3ee7ca03cb5c9a4b1f0bef530978431498ce4b34b0e4ef25394e35897c104734d1b63becaf42921b98900ebef4e3b2b5b3126ed66ac62fd823511018fcb3911b9e9e7de066e61d756a4ec247df99d79bc17c070be6cddb4e43fc7b637d9b743ee2fe37b5aacca532d20b5008536ce3a23b2bb352f10440786febb7447afb83c87c79652497dda631c519976c13cb6b538f5a6c94e72495205eb3ef3b48917f154234b0eb65cc45f177588e91d0b5e0e94c2cb23fd24c7192f675092d522a0d852a23b18edd8fa360325c200148a2a830a96260598c9581d1e484b8b08349a05696f73df6d5338028af9d861172945b771d910cb50b967bc042afef7971df9f583ea95a7f22cbdf7ce02563ba4a3259d2a99c4383665e270be338f7eb18fbebbcda2ca90c87fd26e9c5c37e0d6e3b9964a12f3e16086a3ec2b24ea317055012cefb11e0ae492212fe9162f077b252eff1f8a8a7ecff41b8b4a18c0d41f23bd20f6ea17078d300e6a2c7746593bede98de3de5d93a69e61630e2d5cae510cc5a113214e308ee46c2ddb7e2a17be573538d1bcd8e8760ea8c92a2cbc059e9a1d59acc3f310c3e43344090e1e399ab46e66d6991632906b4f92276e9efd7d1c1ecbb4ecc7aabae48f5b50c65a9a8b15f356147466ffa80b3b53f8ae1de121573bc1b407e6e53d620d92c5ff300efa700290512c4e6a6467ce09be347b9c3f99fd8338ff3d663ebfe9f0bfbd5bcdf2da86c4707d3372ec403dfbce76ebf9980f1e9b2080730686643efefac71ea2ac25912b69328c99b24f3629e968d463acfe64d13d4450fdc37280e659f6548107843c9ec2ea0359809e049a961a2c0e3c3839fb892b54fd3527d96d4fa122c5313aa0d902ba15a2496d26bd52ca3b4f4d98aece086037cac5d343b5eec8ac3f66e61ee6010468bed180352aa47747a3eed8bf67432c5185790b7804f79baf84f186f0f250697573e33016f78d3f87e6611f1d231d4aae2a051ce436ff558a812af8582be51af7bff4c81bf48c9aed13ed17377139d92578cc31094b5ffd9597fe0deaf6780dc7b3eeefad26c53d4801e3f5675400272fe2dc9786f640775b6ec316a851f10497fc0485fff0acd56fc002e679ac3ac1e6e506139190dbe8c847e3a0047585c498ea4d253ea7a54c689a93ccae54c0064adab700702ad9ebecbf20f0c289021f41362b8450265e7760525379be4a83f7a360df167502e5407f8c0cae4d141d323c115882dd837109e55ec2faebf769184c58b18fcb1896ba48722e16ef496411bc33fd887bcec49bd8adc24d18e5e14bae4248dabcaf74990030b0b447c5cc9979eb0e75bfe15d93d48dad25d5f9584f4da337fd491b7f3038c9cdbc69e4972e9d6750f7139df7efa6b1deb260a65db69562b1bcfba45d673a54722c3376be108c1ecb0d67d9d36195976588e64d6244b533a151eb713c0e7ccaba5f2f6dd34c9f32ff221f8ec53e7e9dfa0966509d6981c716966fb1aeb43dbc5b3aaa6167904c0b740929c71e1b8827795726ebd4b57506f385f230bfa7dcfb7d6956719bd1547f5cfd2d3aac4e9bab05bd32a98dcd1035ba631777cfe0276b332e4e645b8b0ac74a4d3a199b28ba81d4c2c5543566e8bfc4cb982cf87e48c0718d25aaf672298e8f5ee30ce96eed7225be0ff5af4b3dc8e4c1eac19ad96488dbcb2dbffdd04d159a942e0d1df9d973566b4394a62f2a0aba6989d5c8f118171218cfbdda5ad0549171098180a6ac27e81b85909f5ae53d528c7520a0ae03550b2bb153306ee05d194fe32043d896de63fa3ed08ed796e4cfce10100e486a316f6e29f8dfa0b7b5d5d5d3b46e1fd8cecd347c85c58785a92c31ed6ae33009d013cc655f3106d400c212b9f2ac6815dd4a5dcc6ca88f812f83e127148c2d10aa5868d93b7a3356bb8e3450c4ea937e7e8e9005bbe3b0bdd837cc21b0fc183f2eef2e9d8de2d18dc904806749b5370226ee4a81ba19dc954192d9c1c52e41867209e7748ce059c9f3572d480363e4c71e57fe4ae042c87914b2833ef3c2e0dbe7b294fcfe46548417a4ec9ebb1b17a1b47c8096e776666d877d46ecd2a5088a17946712dc708d84b9899e49d52b90959fad890995142390c29edc30e2237fcda5d48b4c832f522a9bab7cd4c82743430aa60023f9f7ac8940a00857980030e39a97f0525b813fa1de2cde202a3056f5871a36529eb8a74ff92df470ee876e1e114ed94d2b2fbe1f52bdee16f91e360c6510d678c68ad4d96bc0e6f2c1533e20c285e864fa64d5e5840b6e518022aee5cfe6ba64d1695ac46899082c3668113e27f61a74d445f306193af09d034d2e11e90aa2aef60b0e3b29c7638e8483e210864e63819b6b653f34cf2b25d1136f1936b64fb68007b6a0c0c7cf7cf0c57008dfc0241c0a50e4c470e430a9fd7ccee98281de23e199c925f052bfa9789d50a206c1651c7ab234d852ada70742a4300161afd987ed2bb03fe3f2fa043317adf020cbd14a109f7ce168a0fb8218b7d1c2c4f5e9d1eb0c86e0c684e7188b8442d699713fabb842a2710ba5cf9aa85627ff5c4aa4ac81af06f8fbc3d158455d4540ec6bec172011cef6c617ab8fd7d382b079659b635b34929c0cf45ccd7d8fb1fe39ff0f8a07308270916723eb901148d11028e5bbffc6000e49dd842d6c755c85dd70566ee089bf424d3ef9ddc9a3522da61cceabcac48765ba7848c4fbdef286105f4ca05ed04e4bd3e72a530acdd694b07b29a78925a5d9f36e1c9584ef24ded7bc2ea319254753cf4b8b92d0565926f7463d5e18381af885d620699cfad5b24a650162bcb764ffb86bf6518c265946d633b047e25b982470805636186440de3751db3db24bff12292dd118d9a62564381cad5f28d8d3f5b795fa32a738298873b19f82a248c51fec8ff29272311e2188b4ad415825b6da99d788aa29635096b13c73757cfd74485e4b1bb4208afc2cbffe675c64dd2ad1fc1f568f00c4d6f7388371481b328ed73f780b7a8406ff0576166c32ea6511b084827f280ae6b7ab1b1d48b1de0327f946a535e1f2fdd4b6c22e60943ba5f049598a38d548745ab5c8797afc7da9415f18da74576fa29a77e13766a37018ba33747462522e534463eb55d60f68e5111a3aff155c26e56806d12f1c133eaca82040d04f822b0b4a8d32f8a559cdbb870be4685ac000f7c2fb7c8b6d1c36c93545d6f6a1db08a30e8b831dd54b9df1c9c3f0dc8140c1ffeb662f6c848b05e687faeee18e826479a252d3e64dbbd158dd14f9bae36205a3628fb1286cb990d243a1cc1a5329d54a69d1cbfdaa171a285f581d660a53f259878a3c05b35f2be357a94bb6cb6a453991d6a010e360d4d210d09f8938536b806e379ea8eb8422cd7b80bfae36820e097da5b98a6257810b327fb9366ba62ba12619ac2af1f9c00069cae20aa2ac238bab2335e3b4d2e3d1b0db41aebd922530065d57ef290b0a832ce1d234e8b90c52490c641c296089aa77a1b0eeb8510067c5d77dc1d507c618fa51fc8ab8a1cc975b299159732c04e2ad60ec55d43b529c3bada7d82373ada090e70622ca9d6f4f046d84cb3053e587b813725aca126999f2033ab172c0d79080509db344a3897edcd4170d67f556ff95a1a86c0572ab04f1f5b80cca3db7e20e02fdecd46c3b8beeb49dec474ab875d885906bc3ddc459cbd6fd25c6ac914f7d422058f35c9e7826697adbd30e2ff630c13905bf0f375daac6de69260e55e92f6d568a03176371d687b211b1ae84cd58fe7cc6f20f3fd8e209671e103400b4fa63a48b120bf8494e4e59300826ee28232bef7ac17b0e11503ea2601941e2b7553ba2bb2eeab2e560150d499ae9c725754055e499f05f4b35de0e425408f1c0d259a0fb8917664a7567f204a062f2b57e2cb1ddd2b9609e9a2b61b6f51892ecd3b3301216403b84b2066ac2b28da910c9ebdc6460dbc29b9f45de898cb104a2c539d73f2473ef25f7df4f0b95c91005e9dd7005580e163cc3aaaa388be33c4f212f5be5cf5c60a2b28398ad997f67a8b3876a32695002c1fdbeff55ede8f5c5a969eaf4cc09e74240118958e25139e3ced93525981a2882137adc11c6d51b735d729f1c830dcd19937fd2375b3a94b71441c93e6e188e77a081c777229788c948550a82f20fd56df246938583c6c401c4e9b6db05891d06e031cd05bb8406a35b621fc7ac90ade69da6b0ef68752d026c4547827825766195d6d93e6dfc4c7b70a5b5e0115352460f024c4f48d15341b7923e77c223f12a02f0959aa6b2809998e51db8000c29305d33bf0a55a3816307312389eb235ef87e09593d36d99ca298cf9550ea10fd3554cb3a1a94c4d4ba518e4e9712b37463d2af2e7e912b931b3a91303aa4fd0a83dd643ed0564b6a7b5dce21494a55e0fc9400c3d923c492ddf2e941cca0f09378cbc6dcb957da4bb06fd077a25a06549a9863357e86389d55ee78586633364340418e31ea72fbd2d5862cefc492863a6d90575b473524ac573665b7f81326f077579b257c1637dd0e0d19af12b2a9f4331c830f9495d042cc8e171c7957fd9dac6e54cab74eb5cdee3a070a25f6899df0f4333d94cd38d33192de47f5724bb36bc775193a190bb7edcde5f0463c04f197e67da70a4a88e2c21c2f30567c5715617756ecc609044a069d59375fdda2b380893d9b3162b2259e4584774ca2c60708f271060ac3d10d997308ce6d618e8a5d6b66e5798b861d71f2b4af47242d665be884f053fa069e595f984b108a854b668ba1f274334af58b58eb1d73e783fe5239e2b75e7be15e1731c4f7bf547243bf77bba0eb29a995df290b3a7623e4bd0db029de37d4523d3022567dbae7a4ee6504474ecf82c49a04aeee9c10f24578da97519b7227a33f5f0f2e73fa55a9842fddcf3c0353a9f06f761844f9449b6dd2677dc52f8aba3ffea4f3e2ac104102352418a7852e8446e51cbdb59a4ff196d57384748f01faad046a9fd19694e74772297d52076b4c03831b5c0217ce83e6fa42a395433f68243a06b8c05cac81e509c95bd5c7052dce118e90ca73b8a63060bd5ddde85640a1a36c948e2c8eccfdb9064dcd3f412f08f9d417d8eef515d36a87d17c114c21f43f90e3f88d5305de29b1973c53ad55429ab5b75504a32a3260a1bfb1082455052d9c122a643cff9c67e23fb3b00b1409c175db34a9429086d75695ec4cf4cf1cb2c9cf3ad53ff7f9d3c5fb75d6858c802b65ef07dedc8f46b06d2e0c9f48bbc0652fbe730cdf9fa63e42d75654f4ba48792dc7599171b2e04d0860b5ed84ada4927279063b9afc3592b8aeec0ff4d95532d440ce75e81624505ea2258e6deddb912ea70068e3bb4b57367d67efbdf88b609519952293f2dd660c91690cc43dbd6a79c7de524e5b83d77d4b0ca77e7020a49f683ad9c1d428427ce4f27512be6f8c2e4aabb5c2abbd9df0901b8efe06cd9933841500a3354e3005052f9634da7d80be54252b1927eb2dc55f3da2039cbe00487a576c30fd5312293ccf49e973818166dcede634ed23c87925842a4d8885d81c64fa7481f9a0be404c97b07566bb91d3e4a9c8353eb925d3e6eb22f609bee908c9a7eefaebeb754f67b8b5d77b622621b5b12f889b2f1622f9f01efe7c8ed9cc5527103d07fb8eee16dca87ad000595218c8877098fdef39f51a22dfde8fa79c849810dbb73ca2237a785418f814ed473162587ba2e4d6fc3908475d35b1f1b40c38caadae149b572298b6ac6d3607939d94a9a45d41b4c27faabe8aee24d5c510756fdb14f733af1ffa165422830cd62fab38a98e5ed9a107251531778220d8e4dc8d4d35da1e4b25a4cb5e930074a251d3cba7fa30113af974378a5ab72ffbd769420705919afd7094d1ad4dceff8060f4c8ac4f1211a490abf656f3074f9090d02daa40452c2a3608054b2ebc186b2f9b3f84581536a156a61edee2da02764bfef298ec13cbe0667642a19807884cbc08537a3347874c3591cce8bf0690c218f12bc2987ec42788bb19c12c5f7b6bf55bc9cfb61ac88442075eb658bc7d9c92c2a14b1b1275458a943dbdb9594e574cfe96afc7d0c51f0d61eed4098186a66c5a06ca43ef8e87c32f3213872e61dfa1dd3b95a66f3904520973bdc2e58bd66e836c24077a6d0936e920736a6b520dcef0b5596352a0d086c4cd33b5335597f5a865bc06ca43472c714d6bdeb09e3f63903e361c1095c66bc1678b5d2c15ee64e3017b9d87ce296559ef7094012d97f1b4f9990ae74a2aed33691d9f1418856ffac0fd3e099418450b9b83b095d7e54025a6048f3b81b2e1dea526524a8a86cc80720bb86576c2ec3b4f9dae6223819b52c19e0a9e92b958d4a06e9118b7bf6b5d5762c04c6f42942596893cbfa91e6d089a2ecd870e294c85542c3372ad3c6b426bfb9338535b56c690a2cb76a3c3b795611f9d647ce5e60754618fe69734a9d2e23a29dc3bc3f663140c2d60799f55441b4be65169046b5cc05df0ce897ea048bc807b9a09503d8085c5c293bff56d3f219c965b40c4e9146ef99e97e66fbba8127cb76f0c1e1f70b9a3593d3880b53ea964752d93ffd13fe22143543243c96896736af6a3ee811a9e4fd21a053fe29229a644995595354cd5785646bbea53b717e83a571b3dfbe88ba9b0303ce6b2603f971994ddf08fc778506ce09466b4c0a394bb70aba1d7fb8a1586998ea98d5dc8802348a50f8eaf43ba52f1ed8970151b8d6891d931670bf4d7b00a5f6999310ad2dae3ff5cf8a5180b4939e1926f194535defb5da470ef97816d0a3a2684acd1092710e5d0724b9c60e6101e817e4d0d8cedc4234ddb2a6cae3c4d9483d01536e1e6633344123252c3e5111cb6e66611cbd9ca5be9d349fd0a4f8da213cc0c77a8c518858cc4f3122f29f89da97f8cf76eeede0e560e26995021c6ed7c0365e783cb0d9096c9df200f589cdefe04f0c68a01638f227e1bcaa935e0b76d980fac4ac373c8991a095f2bb153077e0ce7ae3bc4fb7286f3cd232db235ff9f648c23bdb4f3e91b9b9050a203839e95b4adfca029ca498382d4db98715d181e539f441959c6474abe728406a30451c73abb21598fd4b10024b9920ebb46942d21deb4d3b3968b3a934862e95f0352dc4443263b641929730e65da59ee6c73d80ab6b5dad2d51d42058594f218bc371564c825b3c39fca68457448902ebbde7f3ec4ffba09827a00a84e02f15f32124c52fa591a48dc158cc3ba5237e31e4e50b56dc4b21ad4818d91a832c98d5a7921821de9bae802ff28e2d0457d28ac9e6b562fbd32a3db1aa441f68372a49dfcf3fc630d6cdf7a3c96eeb9e90df90efbbf3d6257840e8f111508e5b7560c6a6c100b130a41b5ed713c0c5b41b8bd7884cb8326747ca68d15000f0afdaccebfefa0b4b27ae8b7dad1e5fabb604b0cb73bf991d112b867f52791a1b1f7f918d028a47f65ddd80ca20c35198eeef1fa0737db47cf4af889922a7fe5793d7d2d7838f4ef7641dde6b176521bc0a9e893bdfcbf3f49c9c209e900f57d1d0e1a2c92481502809dfcc152e05ffc5a91470fe03d4a74790873e3b89070c075ef4758b628396e741dfca9f0784d735400a25a4b5489842547c343b582a2d7f71b80ca8942f4bdd4fe8937d4760ca2ca057ac15fcd97d714b7169c5488b41be0f38609d398a2ce658c09b62c9cd29f77d2b9679db58640133af6f10c4e6aabfa22f196807d2dc7546fbeab7be649e8d76fd2721ad6bc995920fa67b1f581deb010b84c8e6de0230ab65fa790e86864911ebf5fc7a77b04eef4a8edc7c90fb1d451585ef4f0b9622ff6aaa3f4315cdbf92497f1f461f338b7960646af2a04466d87cf64f3df0a3e6d38fb8a73e562456c19fa65bc989f336e6943c4728f3b2bef2b75f5c1e9e9613dd38f7341fc923061fd84766599a8f58e728866823948d8587da1b5c6743d236113b7cbc512672c3bfce26140646896646902659289700d9f3bb951c65b93543d1d8e314a8df16d02bfc571130f28ff20d586f2ac855834a6a936c99dc2272a60dd2715fd3ad0fbf9d018238234d233d803909a13de5116d9d9a6d87abd3288eab930e0c79ac27088a0138bb38413fade1ca815550c5b6d098b4e6b5e88dd70cf60f1d2bdb5175c16c105c873307c8d09d797516c8b632e2c4f0e0eb7c6dd752cda68306c1b212ef2c1197c2e58cc72b382b4c81ebec37d4da10bca7d5f5c4c9df66b2c76c64e99457b6f59ae765d25d084fadab82153c9ab54a53d8bb28df80ab8033749eaa031760ccc48b12f529ce97d6ce622f6586140c4fdb6e7043912baed698cb9f2bc20884eb1f8ac98a24a29988eb981b6e23cdd2195dd767c0234da9a06e2792370f52d74f33918ac74cf05a004300c3007827a29364704cf54792bbf2e4eeab73ec2ea11032880e85e9f94653a673d9e5a8e4b2a24e8b671c5881864f9b743d9113cd43974585c7d0069f5cc4f85d15098566eb3720f737f2044ea9022026357fd8bb7cd05fb1527f36f696da18804832449264319dd7be9c8500f005a7f1661a1b391ca505b6b3d3f609ea8879edac5cccc2089fa38774ace5813fce66dbb3638b5d1989c5c3983d41a36ece4aa6f07b5980bd87e32fb9ff0cb20717e6b4f7d62f314f0591a2eb4f8c4caab77e78238b02b1e46366f8fef534bf22d373f93f51d9f7f86b21c78ba3a8db580898b760da811bc77cb6bc799711668974c86c0e5d4f82b62095073e3c19afce2d0d7ad76de7c6c43211d54373dad757d20c3c2efa42061d182f1c73ca00d646f10b4cd7b8df63f13f6abe3239c74e1b6c1dca6094dfd781c81a157027a8009e5af03e2b9857fce19f4c6484897958abb181419a600eed4318181b6c23c821922fc11c59c50f7b5ad9ba3a978b674599f1f86b2cb3d66ede90843670540b606342b38da40b436ff507ce2e0bb9dda161aabaedb9a71e33b03224b072f37b4a42f1b176a08992c23a3b9cd72c17c57ff05a0ce1de6a1440fdf99e519372a362d57dbf57486219b0f5a4cd0d1fb70de4054627b7e71cf044ed93918883a26c767a8f433077c8bdc93be6d2b861d603ad507ff956e7fbfcbd2535844b06bf9d64ee0c2d6c531ebfe9a22804944efc68a4c86e41b7024642171beb2f367d58c782c3cbabe633582361eaa9d44971317114e8ac962b4334e191058ae50209eef883c9f9f217ab883e5c0ea60dcd4e566ece2d896fca741c526faf8ac62111096b98dc9a269c544e5b1617af3248ac69fa541907b74bf9358c6446e07a8c6d40bd45098670617b7d3cd16db2fac2297a09427fd5343dd03a5cbb1ad3f4fff83b6c9ad56ca3ad173579a23d38e3228fb8622a25acf9f792644d780609c51ecd00425e78192e45f6528aa8d2b43179ec60c3e1b743a363ed1386582bcd654a8d3783e62d5a3e31326b97048e04d0ebd4278ab5cdb13b7fa48b88a467b2b1c8a48968830a884f91606d0be1eeb02fa4c190cfa2ff32022a12f1286d122b042298ad75dca57a78324fefc719431800fe07aa1145c97ae6fa31f4b566bbee202bdcf960f4af30850638d27653144d445ac6bee31df78b48feb5179b864e5c4699abe94eec82a5d077d7887b4623cc0ed6b516e1a9a9a6ba761c4f9d981e58453f2fc3e565aa342f40b2782d9e35ae12c5609cf3d8775c071e40af1f90f30da7a03902e699d4f8dc53cce5f4d573fa67a2bb21d14c8defa2ce4e68b8663b93d891a53f3fae2e9807f8c72dbf7fc8aa60c6765d7fa29ba7c077189845d9aa340859cd45d902beb5c69b24863a694c2d28f737232cd66dd7844a3cbe1fa640db49ac125bfe43d056473d5af00829e33555cf0a3fabde4ae38762a86d840c71149263470dfc493c224533fd5bb931d71d5d129501f4da665ea9f891fdb2027d860ee36dff3eb4d2446b2508847923a8744580f8e133be8801e98223303b2b8c0c002ff0495fd9da8c4f5a06709b5057fa1651cd17144ef115d0f467fee3fdac0571f93ce1fdb3fb43276be23433681caa36f945260d7925ed238979b0c74aed354630c1e05648f7994cb91132ae0b4d952356cce62c778669f6d20a2fcc7a237d9e2e67f26280b9e5afb43e5ac0c8deed7c52118a36164962cf220d01b312aa34f22397c9862400c5d617209c3a85757f780705615f1c4ac61ba3e7635e51dc953a04364e1a07557bf6b97a93f144d9eee179c6987f41e5122f020b1738ad66ae7ed6434f3808c7010b3fcf644c7ad75c29a63ac83fe3fd10bc2664ac7014f98b23101909fa76444e5b9d4e7c6ae9c6b3cd778ad6605a726d0c4123cb91c96895af96de28a2ce86c1dedcfe8cc461a7b19c9975b2d17ae1e9d15d73f354297528ecee00bd485526560ea0ae899f31f8515144f080f9489e59d6074aa916411e911e0b722bc4dea3df07e593394ab563965019d1748b0a42fecba40dff5a47db9b6cc57416d93640d0b54b4fe68e29f3a7d7403a3148d286c09bd0770e49916ed50b64adbc264479a607253f23aca4bfc134f734a9e3ffbf0e0b6136d11f4d22d2cc02feb08f5e0be1122a8299e71987846a82510aba3d6c864490a830b4aa0f3fd0fbdc49c9da02f3b164a7a2b8141a13d24db9fe3e8f3718aba31d2ffabd9a3067a0ebca7427a5b9d47612e1411a80fa2fb721122571e43b2ce8648ca9840fec48c10e264403ace63e1dd463d1c7056088673840fd817b87f8280a21dcfb3aead6b072ab1fc34153995e56def002d7e737b05564d4b8ef255cdc1374f31532324ad2cef177790ac7ad4b4cc0eb805493a8eefd1e527d9eb7720220e5a923cf3b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
