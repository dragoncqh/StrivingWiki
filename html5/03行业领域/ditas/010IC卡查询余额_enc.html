<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"faaef6781620204fe127535a0473effe00f3f1026c772c03180cc9767a25435adfea37a11be9860c8793ffebd9e0ff6ab606c86efee1fb5c33dc99b8239da9d2c36543a50a3144e8b89d561d8c4ce32b8993ca240e6b59cc8bd59b9dc57df7a30412d23efb9eb3a43bcd700bff9024cef97810ce067f8c38e4ac1780df6d8c02674dfa3ea00a8f2da120268b3a17fd0dcda12142a3dac8bf209d7dcea6060442410de12453e15a52fac5b409ac6a60c8183dc6d68f8d4e7d3a6e33af6c79165d97d780ce0086ac8c0a8fc3c851cc2b011ff0177255ab70472660b1c38efa0a22eba54510527de72d02d7ac15cfd0f25707c5f3f7a73e3b0aa51541cade3d3d343a4ed94fa1a1a1b1c031559e581dccabbb366ecfccd175aca8f44b237bb9312b7c11f0746792afa4272760ca38169d6254f0c2bf99a065b175b041e60c8a84453fa73baf8d6187de394ae836cab5ea78d790d6dc7a98d7b1b5b65d59fcd1df0c7b39e732dc9d34ab86632a979eb613e1d2309943defc391be92c6431713eacd8f25790c06166522bc4fc9aae2ed79f6ca73e225230bd556c571b664fa3d67dc5586fd498a273d4df9e2aa21c2c9eee9a2d643aa20083769a0b29711889fa8fda95412c789ce59ba0ee3c25b92cfe35f5b85a6cf4e6f0bf6c7962e466675026636a53417c8591f7d494b609f29a2929a547456ec3083f6006a43bb786176c6681ad3570d99d3d1fa1590a5b2e87e765f60c0b7a7cbf2ad3209c0851df308c7351da3351cd53646952418a5c876147471fd69ab5fc79e3685beea556e0a544cc1d9885666b86456d077f8f6478c0aa682198f92c4f0b4535a9ec6ffadb0a387f867fe7d948decf55d36a80ef1d53aae0ebe7f2a88d4fcc29fa92bbae33b7470e787d3139dbdd1f49ef17bd824cf8202304c2a87e63e044d60711dee737be73956782e4ff954c53225c443add247afac0c6f7164b5ab9d452edb55341a3c7982d01408c3ee3ea59506f7584087870c8a8d22ed230f3af5cc121a307eda7895adb9ac20883a1d4ff1b564ca31154a2a852dad4bfdb5782f11aeffff15edda761693fcf134e4e633e0dc381b8c1aa9e137195a679d7511a30d68fa41f86649e73b897b8344c7bcc159b3a3e84b63b8ce73ebd3a9b38b0001c15c93ef2eff0807180dd65160357633e136193329657631b9334fc5ccf12dfa0bd44d45013f0c6370ff71f89436102b886b41c6c435673046538c9e4e199cf131c041d362f39595bb040a3d0fa0d091afd85a179514c11d032ce5adc409eb0b1ece1ad99ded1c660af39a3d8e4fa20e09d84ad46288f3558ba2f3fb88bd972d42ee30b54b97e5c3293b00255415179c891222f89b08bf80332cddea9cf5d636993858b701494bc3812146c1cba2604f19ea7789db60a9dde80e9b13891da8aa0536db4a6096163cea69c4ec6a21f2e81b188e456ab8c689cfe2dc7ef6a81ae4c9099b4c7a8ee2ba9a16d89250091a73350dde378dc924902aaefe377fb789f0e321f6030d9b1579b19d140951f059395559ac15d8c25f491fe8e14206420629e30b6e777962e8c51b9b4d5769ebe43e04e168bf57699d29244e4029aff089dfaf4594164dc7c534b7309c2c01726290e0129ee5b3e5144231d674b3daaea8606344c0967d791a4b1a70830408351502592e54c808dd66fd57ba48afbfe28c15c2d429ec2dd2865b7718885c6f8bd3999b300836261a96994971b62fc8b91631bf89efc08140d7b0b022efcdba73542b8dfa33a77e3616eedbd1c1b9d391156789e3a57f39fa800a599b9f675f159e168aa816573a75ef0d036144d650a7cf8b5e355048597f36d92fbd6f4ea2d85f9dc0ffca3cef7a5ad0c2f9b6e2e0e08d396fea31fff88b059606395cd19c8df80ec9a2e8abb28fc4cba62e4e90ec185c2def9eea79907491a7cb3d0fe12b07e30aa7e4cca0cfc8c4d4a5a7de9fdd560d3535c7b252ac8dcf35687d8583c5c0d0a9c29c6f8538c0086729e28f68218312324a721bbcc70ab5f89a26f1b7eb833bf3d73619b4314a7db898cf09240c97aebe7c563081d4d4aa62ab61dae5e819cae57d74e5e8958e53e67cdeafc63592d49cb1faa22aa908bbbbabd85943c486cecbc9dff433e951efe8b01a8df71e47bccfab89a2d7232b4209fb82ae70402fdc6627db98d1f88188de0f469662c0160b01b2c78a1c5ee9ef210604c030782af66c89748953038aab5a0e9d738c1f069cd726cd970d6ae872b35a85942d93f06b4b1a0890e1f4a178af0198b528f7c3bd3c903971a91c6053c245acd9c3355d5e21ec0580a589aaf6c627175c75b62a75f81fdf57cfdc1264fe60696d24231bf069a718ca78977e467a5d50d203404cc1cbdd0e0395c3e4375cad46b656a9b103f6641ea3bab8c149ea46b00adda9241f198ba8c45b64e9151b1a66c76195e3e0eec9f76bec14866564efbec542e9e3f46abb80e990d33d8a572709c35959c6ba2c9e03dd770b4eacb7d796b3da4ff44de0d79f54b5b902d221fdd703e4b7e12031e36a09b59a606f2e95f1df9f7fb2a427b8e82dfb4805ca2432c2d66379671fe94dea421c53891368b097a5864ae464d1bf143ebefd0b755e019023441d6b6b87d80245de2959e33487009743b4c329acd35dfe1f9025c31260d8791b4ef63544ea666f241b1471edb24e27e9dccef6edbd52f677a5af7596a99f59b8caa779926bc6c8b130d4e16be1fe01f660e18478f88d5b01a5156957c382a58109f0961719fe587f7f7f64e2e7f27db2c3b26393fd987d1ea94b0fc7a01de2f98fa8714803b0c17bf46ff0a8265114980673ed2015bc90c4c4bd087478ef355d5358cebe8984b761074b6085796149f9968729f45e0ab748b89d9471dc63ef76f88269818f4ec790417aa8225e4ca3a890491ba476f8951f13bf804996aa8e0449cf236a018ae358c0bf95e1da455490fd9427d2335fdbe8b8de4d644762345eaa9d8cba4911da9ea7c97247ebe8df40cdaf270704c8f803abe43490568e016e5298d7e5052ce386e85bfff47016bf9fc93dee250d9e611ed2370f1809bb5385bdaf376936d26b768dc9fe517c0ff8019ac6efe01dbe44fa21de18d8013bbaa43919d516bc5106f5c88ffea8f9dd6bc867debb69ec09cca220d0f222c03fa97d84fc6a026b5d5712c31df50cf0562e27c4ef382c3ecbe109a75f12eb63e72628d63a9ff1a38fbea77bbd87466828760cd9f40b6a9633797daa1088f4737825eb23d76aac8943d042fe3549a0d062b64a127b15ddbb4bdbe0cd5843233a0f3f7699e3afb9d3a13c6f504574fdf57c04247cb3dcf9ee3fa7380467c1662a2096bd6cf9a558b6a1381fed16cc6e939fae5b27a6a6e176aa2ff0d4910073b183c69ec4625423f567159d3c1d84d22fb1e01228b87bde35f7a3c4215ec1b45c205c58ef1086ba7e38e32cde51c76fa1b2f62294ff3e9af34d829d0364b52fa16cd166c5ba09bf7b7608436f9d15536401eae81640196403495eeaa2f6faa232dee21c9c7f605a82a34f58c6cf9f355a93d073b6aaeaca155e5f4ba6740b7cec6462c4e8518e840a36f0b366f0fb65788637ea34fce0ff33115183889719d1457cec6a234ace3ff654947e7a4188eab76b9bca155fd24524a95c46ffa6323c2ebd724b7ca176fc10b5f36fc349e129a7c68d873adf2ad9478a6d588d37a05af06b55b7eb074bcb98aa4a01b751f6dc0d376969d5f6eade94a958de28d4f4313717108408fd087c6da22ccfdb401c8b2b33ab85417854756b8481e6261e1184b19a709f733bb81c67e56cb83accad377dfd72d994afbbc750429e04c076260176a0581ecbe4a5b1d2e9b98a89ccc385bc76695cc6abcf549f58e050bde7c3885661d4bbf9411c81aff096d98348b4e967ad12e7599bb5a17739c756ba5544634665b28727bee2d0818bed7a28d2490c4c6a866168a9f42a7246945d2f18856a4bcf9dad9e25bd8c2b7420308349a7a2e608312c6ec71524a1d1680f7445e38df38ce0b985866dd012cc0f090194cd646a24de4a75131460521635ef96a4d409438b1a8511839e7be96872290c26ec5bec79a92bc23e69268e1a45427e859d935759e461cd0fea438e2d84460a9d30cdfae8ed67ce4c1d887ebd19b37368955fad5aea28ecb2795b035813762362baa8054d0a7b68339e2d7da23e4f80bfa10794c828c26f4c16fba124acbe80cd8d5f545b5ae1a0d7e5ed29b35ff17bf7fe7a0b76a2d6d2a3027f2dbafd5af19101dbc8213fea23c627348fb6f5da3019eb165415eb401ffa65545282dc6d8139a4013ffd52b77fd52c3680a082a7397629a8d9cb1df29ae8d251f6b147f26e0e9961b98234e2da91971448f204839bbcab9dcfaa8b7517970110c388af3de61d9a8866fa9cd77a2d2130bf92e145d85329fea62aba0b94110d63c3e8aa5a7eda5dfd84cc181c516621d44399b33c2e8a0b4f768f0766f6f5728f21816032c1a2214cf1816684b7e6b4eb6f59e74cb405cdcfc1c29bedc39ef653669c7972f4d2c6900d6a7bd0dcf00c6a94565a5654a60b5db35d346fcac71b682f67bc36d6d846fd0157ac7d10b88292b322d24cb33b870d28ff692673c113281acfea2756c011ab1e5e5e46e535ed9213b8f10b5fa12c6b8436cffdf4988c47d68be357dcce8bf9e399c5076a33a387a0a5af331c9a9da9425a8c325efe0600cb96ede4cb7f1415280cf1931a929618ad80d7e0371b0bad04e4b02e671aedc450926e86c3687b6bbf4c56414fe2db9625f032472a647ad6cae26c70d74f9630a420762a72d6fdb2ceca564dea6c4a12daa271750c0c4928ff5cd4736fa9a556104f0cb5ec2c187ceeac2bb62ad39e3267d2ceebdc15311cd2476fef019bfd4646da8e47e29e6b5778011acfc937f758d248c5687582f5c2d85fd390483fb8aad036979419dd43504acd527abe35765e06fa76e7b6d9714aa68c892402d6a5f1c51f2139e663c71d8c2bf20ecedcac68dcf25e090737b0c8016a7cb9c8faa5472c9267993bd7d86e69501f69f18c7cc7df60fff2738578f6b0f104d18c30ce0b7c090ed6145f44e40c14fcb59b36c5995c2f064e1213e2238baea5f2433b7581f63cffc36777947ff38e2ab970ddeaca4304048083402466cbf626626a920c2ddea35fca10e2dfdc32fb464536a4ca437c0e105a79c55632cb07032c4df2697a574b98964f66c9d42ce9f5b8a7fb03bd9b5a3d90bceda401ad5fa761d7a4d56e4f2c8e921fbef9448b326b80aad939b26f754741f93eae31b8d4dd581dca53a5115daf6a0877f9254f59efd01d29a3bc94abfe9afd2a20430498b06f12fe6e018dd28b997efd3cdc137d74e0bebf2fdd30f63addd2f9d565de4fc82bb74981cc78b95033661cb3b458ad5589ed7d938de53e212dece07178a29d716ae919bbc1c0ae802a773351e4e6b3b048de81d097510eb177581796c14a898bd5441686cc2e8f2768bb2c82926d3e2510e2e8fe67bf0f524558e8bc08d96f8b5188b42d5dbd18f9c561e3711c86b7a144673c6927b6380e4e0e0055fba4b3561cf64bdc3009aceed1377eb6c37aff9f692d65b49d39aa86b304017e17e637a7b77e22f849492d30b32995f4b64510e9a69732f1954375aeb07e051402a898fad3706923741de3131e9e81e509b0aaf7cc31253b23b40f8ff0c7e2db44000ed883bfb0311ca71c1571e270d4551cdaee5716bd9aedf1e8b94a0f3ad0d70c93c916b56b17621f3e0fb9da32888e2e9cdda4e341e800e4ab335583db49e4eb03f8cdf7964b0365ad84133433daad93dfa619a801b316028ebbf96d4aeb7cd030ceaef8be68d2c85bbeaae72395469a17daadff6b96b16723477164037a495543e98b72b63a51c4ff2a3a2d519af50d2f197e50e7458e6ec1f7f0a4f84325e3b1cf5be023d9d0946f5efd4ecbc0bbf3df8f4f595628ffa64c729007e427e4962851a20ec6fbf1d15a54a8132a3d6402dc24966b40066728bf05f007d5e95fbe60930622699f692d3f0a5b36ab2742441ceeb972e28f38f204bb713344e4b72a18aca2f23818a5ccf5dca2d7b9199af96e0e305d026eadab3f3ad8345f85e7b2f4c19a6b1514bb05f2f319979cf5da17e56dc5ae818ef8b97a5ad25c5b1880c0d7cb8b982381b833fe6867f52e201b6af4305745e276c28685ab2de02a230346e772909567024ffc95f26509c489a53595366dc408aaa626e39cd54909689d2f613546886cfeeea56151f43e169cdbd19aebc2a1a8f4631e1ac56777ff9b4c1b58f9d42bcf7a43c6c515532dfd2a03e7897b58a2d6d491fabe8989fff96f89f5079d5e9520b261f56d1e8331ffbcc966535aba4b60ea048bb863649486629a07d56cfff324ccf6a905291d9b02ca8937679eaea37f144e8f1c9312dd8958cad3e1c19fbf144e239414a25849894568ab074ce7eeec71975e75dab2adf31c1fe5d6f51f0d887b2a96a056b4b2265f4bdaca84a655ca64a0586a6e058fb7dc08baab1a22bae928e176622becd778926d806bad4662ff524dfd39b0525c20f8e142a7a98f7f0c88553dc5c843cdf11dec35bfe63e6c136b6a9c7611c3080859d4680b1ad40bbb0716b9bae8dc927b9f0b51aebfe02523c5cf5e7228b8848bcf0d8428f81c13335b8fd567bc2bc2ff1213c9b93f147618dd0a11f5145073a41e3dc3316b0fdc67b10e0ed12451a1610282c48ade08385859c7a328bdf6a80d3b6430c348187ef7372f7ee3fb89e7292ffac954d170cdd703acf29809bb0a3e0bc35d8e73b19200d0b7a1156e900fd456e2c9bc4fa512435fdb1bc0b766c433028a9497de6314e468be75887cdd42f623ea1f40a72af5ebc5425b1390079fde9655608039794e52ebfd59267d843217542ffdbdabab502135678f7e4222850b55154e17d7d5e5a9dd4b967d9fee2a32fad1c01eddbb8e4aa04134748c63bc6647181a8867a0a7e897b0b978492d64f958267f0b25a97068926c411b916743ed5cdce058384bf27b14cb7f29d63c5796bd5339c7560ab4f6dbb00198f3be2f9daa4f77ebf706134e7685b0569d2b1c3e0e821d25cca334b2651d073c5192cea7fc22868b4ace0e6f13d3c88062896a51b0d8b2c86802d9d21f66a752fdacf776a650b5dc2c27eaad049f5ec82cb9e59411141de2236d27ee41f33543868971975551cfb60807b1f3acd5fb6a55f5d9a3f6c5d475d191cfd37666cbc67cdcb040b2b15269df4fa540546a290e7bf33d81bd0787a73639fd95473c6a18a248867d394a4b5600fa440f82733cb95c08686bef3a99436e8eb4843d78bef62a170a41a96aaaebce0650f82a0a377872b810382a5493f4ead675af92e00c1e20ea0146eb1aabde2d3f97546dd69da991b3873b5602a88c207d7b3a59aec8b0366455e85e15c809779b5ad270cf33cb0107d4d7de23ef501a8c1ccc3fbff91e71447d853ad1224c96faf6bfb32868f24ace792c057b1cc6c5aa2a2f54f4ac29b7b75cd145af810c405dd143b1fcb5755a2fed096d30067472ecfc048795bb680b307731aaf97b3cde6708b02612b98def4cfb8ada816d6395b317d264c02973f1dc95e11fdce7ea1ae72a84d6ac7dd2e3cc504f62a1670a5194ba84a1bbd2de0b41671c7e30b10e77cf02cc52bbc68817d111827909e065e47259cfebbe1bb92c8d1701ef9045cc35ddd9a412aeb45cd9dd8b0f662956fd515b5152161cbd9b933ace3cf23749688438bfde229fefd77a54fa4380502f894d0d83362c2627884656a528a8b36e7727c90048c9dccce31e64942348b033d364cb8977c9e12219c5db949d028ce0baeb77227469a7350f5858b27bd3d5adee9e8ecf83d461e3022cc0b1e58c3ecd17d1fab03dff8132a6fd05f98426e3c1ea172f4c47d6d6fde77e73fd3c277a919b29e8b6a72eaede7f571afca8e2f5e3ef50cffc2ca39426595df59c70a3526c4b5437bff0d16ee4365ac562426303ecba4ab0012094c3e0bddb1c1b6ccd66fb76e62c472d9f98a276f1d272fcdad1d076190e47de1e0f3ecd0afd95211395c79c288458da72391370387be2e15eda2a05064258480a75e78941e95f046e8f5797f1e967e63d40b9237e9e280ac91d53e75d25a2c998dc2083711f516f1f55bf656aada25a2c011292d3be9137b56ab9f8ff6261aa27fc9944dbb0050784de8e8d5a294db2a72cfa2c48f4f4d1f26c95c6fc2589bd95938c2641aa5dc8b32cb03e9819db0d4047fbdbc6a7af15f35892b128e2a249a8ccfe4e63a9ba0ccfacc6d12e4c901abb3842cc972bdea9a5bb1b65fbb9c0b7dd3987d2edccedd044da5cf59b4b778f4a12e1de1aad55ea4efbe5ce23d3eb8ffa2d6ea9b089ae166bf05c4ee50595ba5189b58376838d59f7d60bfbf82533e1b07aa5e0a7c23901c9fc8d3ceb1575e8ea8b27ff9e45ab30f349c7a410c614a25731cc59bdd148c76b91299bb8bdaf872f367e4af177a1311709b8fdbb35354bb72912640cdc52371c8aa94e06c0e351dfa0f93582dc1f359b6d2b7369306b5e12ec2f1f1d39bb773b0194d5ad9544bada69c54a57daae6e0b784267716d8456706eb5568e93b57771bee76e43b370e5a3c72f7a930195da5182915e48505ead5b62b9845ae93d43510877dc0fc52bf2cdb61496d31e76bf96e88ac55e7347efe3b9bb811baf3c4c27901231ef3ac44c127c4f2805d1f4e63e3a3286454111e8597426306536eb1254d95dbc6b6811eecfe7bc6fa2d13e65f78104faba4f15812b6b6d5f8501786a6618257011a9a6e6c76be8b5d327060a3f7c36c49e464f83dd2a5428b25cf60628deeb53162038a0b3e75ec3680ff35c183b258e5f7f6ecfb4091bef5fd7bbc83c84ede8a83e639e9da4c2f63f3dfadeef6f7bd0813868c69b6ef1c5507c7206d6fbf3f75799da3f2d5693436f9740beab0601842e28f55dd1b0efd969f6073719729ba3264d81d0464e309a8bfa73c8162949d86102a1cd869ea81d705d633b4ddb90f67fc64ac3bc9eff0c7ef793a52f23d7afaa81ee1d511fce271439c8bd6d5f060308e57ceeea6b2708af2f6bb17eaac81a859c322c9491acb10889f65fad66cfac983d4f33a95ce3473dd73ad5f5fd6cdb4b0d682d098de0803680eda473bc3998cd80bee1e33380b7f91b1b5baac008cf92b978a9c18f9db5299f36bae9b42019094b483c274e39811611d4b016170090ec6d4b77d4a245d56f55fbea0e9a88a9147a3b8b2baad03b015b54e11107e4a8db4fdb3a2593c38993482ec6a8718629c13e32d5c46215f0414189562650cbecf9ab55efa8dbc2b44305eafa7965f533e2386087b7fe22e9f3385964e03d69de24773742decda2f45e92e5bd41d8bc9579e9f9ecc9ef1df2dd3d17c77eab5232aef274921bd415b2c2fa9e9f2d617a8d065acfd7ddc389e77524cb325eaeb6c1dca6b9e9764b0a6909d01bead3ba2662b5ba695f75a0ad44b436d55f2ad0c13cd78e98b7dda49bcda72f3720eb397135c1809d2a50d4d287320e19791e16745f16f6bc13ffec34336dd817cf50fd00be7412b22c715c09b28ac5d19e53796c9106a34596415b4c0179ea955d179fc2987140475e3c1e40546653d37687eb4cce3331131b91840004a789db81b63350224febe3914a18a3441409b6b8447ecefecd4265d55ecad9ee026d694ef820a4f384411b07e60f0c30afa040ed424bd7cd7e45b6a2128f53b76013793395292cb64a7bcd26a927183b249d5786f5bb7f4c62d02a7687e7d2fe7011c8402cf03a7608fcc89f75153fe5543c9653a52f293518911b929c361a72e6cf92bba99ae406da720288eaa03ca44b3bbfe4db2f45d19b95de76d4849b686a2ceeb0d8d5dd2663580973a7506780b908954f36b975f8e152c2906c6d52683af692499ff8a8f5d17575d9ce990aa8348604274eaf8bc7d9199b7bf06ac30c102745950a5f23ddea9247e3d9fa66062560adb6eab192ebb3afdf4b473e5baaab28707eec339250ec7b7e5e9eee3cf10a2e952fde3e0cfe127f66d8c4ecb2fa454d5dec745768f745428a1a96e900f978a0860348dde83a1223cbc3ce5caf5084e393c73d00969c99f74c5c3accd74068e714c02739f809c2207c28048aff9e4653a8ee2f231a26fddd79810645456133e2422fe65a67d5ec3ca52c9fcaf9c032fb3ad4ae5e0fd9ddc7ca6b1dcda8db7360334deeea04af46b1bddc45af2e841ceaab062ffff2547d7c2df0d6b0a70f85e61e3d3cf31b56d104b4cd3eff58298bf757551a78e741eadcc08d3d58b8fe618115cdedaba91ab86d44c4c9a304b47f5511534afe384905762d867093ad6371eb0c197caa0cac4ecebd9eec65131b0e9520cbaa63a01a3fdbed7a98f89dabfa77b1fcfbd9f9a221c9c9e03d7ca8459ec9c82f9185d35f15b5be09482f1d18baf486fa93b6fe3b9470399cb46e80f23066fb137abb9d0224b3f21e93cd12879edec5e291420ec9d750ef91cfebf79be45d8025c8bd3f1665550874fc0e7ed9125973cce7d5ee2315bd113228e400da2faf576b5fa5c281296bf89b9ee06dc3f32a2ebb6d3d7118ab7387ec6c577ba20a0842f1a6d1ad2941973334b6c043b8ecc67ca6b81cd590ba0ce7410688978c088c9d14c2dc018c72943fd9db2c6ae2876d29e1d3b10fbd7b004ffc811aecb11598f2033d93e6a1d0d4b810e34da05225f78625b873e902fa0a11d3cea2ab1a765f52e592ce3c4e09b632dfde6485892eeb48958372afab7a3cd0a0aeead4448ad9dd73493a31184c0f4e37a6c5c69a38d93b048f4ed887a7f4d6b3d0f77b460338d68692a18a0e730d29c9190a020519a127cbbbc8b9b91daaf5d6e97887f108c10103771e00ccbd9b3d1ef054b49ddfe071f8ca4686ae6c69225c46ef10c5077da2edfda1e4aafcb103d6f451e4ef13b7d29b1ce9ca994606723cd060a1cae5562fa4d87bc69fc7f07f5eed931cda184d962b9c4cdf33595aac02f8fcca5d6a1986ab5e5c67eaf0d92372a529e44ecbb2296a3c563c3085d7d4fa7e48fd18f79bf680b5703fd5eab3c957094e1d8d6118edd6655c8743f9723d7115ebe41d63cee3e743a4d663c5ac9deec74c9577fb5c8563dbcdbe85581fad80407e5a11e32afe0492a566aeefff0b1d7ef68cf999c92bfe47d6fa108dc866015237557d18e59e945fc9ed78bc65843119c019aba6fbf1a8b0eed1e6e563b7a2ea1eee90dbee310d83ddc7d2dcba2f32386951ccc4e35fc54801fbd8aa858f18dcb333f340415be17f87498644356a01f7c5511f9ccbd4a4209492d008ea788a6c11be4d5dd4ba566117158f5e901efb940b5c4119ab6ec383fd88037d41c776a4dd37a1bee3d981bf574ac973e9e3a543443c206e6a1dbbd2cd50764f52e70df9f4d4bb9e7ddad8ee7e8b0cc4d886fe145ef7bb9117d1d20a602703a3cc2fca19fc7bd12e170201d95d1c63146b020c6c5e8a2763259d1355b258a582d317f6a0370a5a594969396cc49c52e647539f8405715158878d422be545c9902ec296610fc24bd68966a6b528654154067109979f407891d5f30ae9b3b1b32279defa310099f89ac7b325b1ac04ec510f147d1e2bb8b7f50b19eb2e6277dc754da06f0434f95416a4490101cfa46b32b9030eaaf18136c82f3070bdb7a190b32c5400afb7fcba9da331eb14a609bd97e73e43a028cf7a2ff523640a2afa4e65cfa2861f6814a317daf0066a4233735cc6becf94dc9163039cbe9a0a45fa5dddd982d284eb630b23a9edca2d42a6f0fa359e20d569ec5132a84f0d9c8ee960bb0962459de2d5644691a69c07a3309ea2f39151006a5bef837aa48c5ac0c37e681393e7c672377b3774519acdd801db9001a783f795683b7eb1f91c7c3587c57dbb7560d8a9cb62836a60d5175b3c2ce1163443940402a588410237c3294559633905266de6760b8a8b27b7537f65b20bc3a95a774051749c778a1bafd4aeaf730caca96c59a13548cd01b6f60cdbb6c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
