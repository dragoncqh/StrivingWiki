<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a33dd3ec4d531ea18376b46b966d46a3f23c6a8370b21b2c326c924f866bc3ba0c1b23d85787b4ba095ac1e0217227563b554fdb668243868f1acfb1d01cda6738e94422a31d9289c4fbaf91b5cda7f6d76c861f5e8abd04c8f85ff782fd35783fe0a537fd914d2618dcedf9a35879c2b493b0e5c95da4cbedaec1429fd42bbea3094c72db3a8d5909b7c3d39b9e3cb200bb38299878dd078b868caf34ff4d094beb3527deedac3010fdec28bbadbf7af2bdf892f81a38df0384205b538e61f72852e3d344a4136b2f5a2f5c13b4b85dfba840033758261040ddedf03acff9ece8d34362df70942e92dbcc6faf2d4a28799f6f52854c5361148007e7dfdbd02f858d8eb108138b5098ae84239e09268e174a9cadc1895967012e7a92fcdd94f095e6a96e1866a47248a9d384709365070f1c3454075ff6c97b30b4782d322ec0a57804c3ad972532a4ba116d7f3cda0a1c71727ce9a13e2c169cddff20b4af123bf760eb3ff2045ba46cd6d1431b346416b95e5783386686b0668d6ca851d89faaa7205c388511d206d5f5153521812edcbbe05ea044c88518f8f31200cfee85265388eab1f1c60cfb77ff2e1486f939c4df0c72560b39fa0dacc2a8c746242707734792ca12bbf0226080f2c26bf2b9d282e2f365ae37e323e11c380bc69a309d6a79d4de06cffe31fc0e19f1bf4469af5741ea91c0e8493bbdc5eb294325dcdd83d6ed6dc8012eb4de438d64f9085461dfe191cc2e022566c20650d5ae08d6039c93b355669d4df5dec73077345b517b1f7a4f539cc767a42632390b4b5786f1598f578e1d6583d13d89c2bbffdcfb857b0503b586dbb2f060a8a76d2a8938b6eb3a87ac746fbecb2b80090ea05e055697fbf95ab7708fa0a115f195a1ae7e6e66722704254190206c8973df99d9b08265c62275db7c10b068b88f28a65d587218bf7dffe1ae09d4065dc1b2bc23e98071434741f385ae4071326345fbb6edad977ba385ce1f90ecc7822786b861f3f6c10ee5b919c004e17d9334b37a1628c90d46ce6aa0b5d158f275925e9de72f4689b313b5ec965a1e20cd529564f3b0a2915617361d656cb7645fdc5003796fbb5a2fa17344823d604c4f2e481e8da4bf435b3074387ce9d1272e9d00be8b4e75b55504871d9ffb3e211b6c310e82335ee0a1f0d765d5486e2f604ed6ba94f196a1f2a23a3e463d37664e1f95f1722a6b1e5564f1925912742908c202b8052391cd8218a6dccf76a1a4e14de87a737eabe9e03bf4c0b320954ee78baba9515c8cb4b298a96a700fbc6764991a74ac01738bdfd0bca2b109ec254a7f0a5ec88e101c4c0180db608f17e4c839dabb22f640043f66c6197c350ded219e9de340ad1331313bc2fd205aaff34846ef454a984c7d0decf15e8eaa31f351828859bcfe1738bb0f0bb42cbcbc88f507878ddc1a81294be1e5e829cc78553cb02e2d651d9b448f7f2ce63706156d2a1c71fe4f8fb422ce42f036a456dd60be9936d46f9136e8a332cbeb685da83397109b13831d651f352a80c79e5ca5decbcb11d2dd9c55669ff6814fe9ceebeadccf60985a940cba14875b2d5866c4b2e757f27aef4914a2f3f14257863d2d5974208d6a20756c7cb29df0c8c280c23031e0c44f21bf8dfaefd2c35a9f77a68d3b88a00ec056707e11c52338c1e4616b4275058d356abbc07bea93904fe7ba1be7e441c9bc9aa19ba4cc8466dcb2d1f94f5bbdc165d54c789f6b12bc1d9a710bcf90fbd11f5d91ecd152c7c24ca7b4e92cdf0cbc3d451112eddc198d9362f109ee665c880793959b60851b60cdeddf576a9f9314711dd4e7e5d100f6dc6f7b5a4fdb7d6245c6c7535966c6b407fd197072f63a7677913917655723e3b2dcef7cc9f6c72715334a7b032e3844243f2faeb144a71840b64468b0d36ffc904b568e2d4b8ce013af6c0d8588927c550d89385a9673e01d59ebf984fb3eb42795af138b78cca50bfe65df088653ad2bf83aeb54cff4d5628044d2cb1c0fcc560f85144482bda5dbdaec441d9bf17bdd0ccfd3321dd9a01335022c4c0095d9d83a55f49689a9eb6947a758a0464a1c387b805d9dee080e148f27819032953e4640cde630a38e08f27c157600e835ba6db8d921563843996c3bd4226ee68d8d2469a578756dabb118bb32c3b1a3ba789756acb81d736ca551ba2c06403e3f1afdb9eb10b69d4b582510bff0285a57d8fba791055702e890cd655c152c0f5e6c50e3a97e8a5b5dc4ae0e113fdcfec9458071767d81e8d424a1d1316a17aadeb87018d0f3b631c1636f66dab5515f4d09eb18f5d440efd326a5fbff9d39429fcbbc7d56c526d47432119d696b8d25443a75d9a410034eb44ff97113e6f286d8fb9a075f2c2ab683b2d34b4316e0a011e7eb7cd6235c09157ed7dba1cc4afbcf874e4c1eb3af650529ce2f366cc2c30650046c841ba8c4bae6658922c549f7763d01a69d32195a57d07be7a2fc1787464f800ca96ee0d60a9505e0e5e84cc076770d98ff5caea98976dd5fd199aab22ad5fe863325e8dc3bb9f00d66e67118790edcde50ad968a63fb9dfbbcf1db7b893f591c5022a578076c0c972d78690fb8eb57bf39ed07718cec1d263904f830d09bb471625da1397674b6af041d74a47a17154536f5164a33d1266ee4c8eecd05aab978f89bb519bd14a22ad0588152a15a56a88afa0cd12daed6e4a8e305e0a8ba6ca44ab8e7ca641e6a2f80eba31ad4d77324bf700f4d65b120f791e0c85b5809cffcfadf9cb333e1147361de7275e1789c7bc901e81ccbd6a4381412f23c7462f62bd014342da240ae377704750d5a442211ba4ac38741bd3ac840a42275ac77df2cecfc7f98621bdfb3fb9c24e9509396c4007228139b38091bbf9e8c1a255e72651f5e8715deb34743cf728265e47f04a4ff1f430d2e92bdc0210178c85d2f3f50fe871edfc54105a9cb985ea79a39f0832591e8625a9ee1db9dfaada3a707c49f129d2d9652260de2de13a649f6efb5702cd5865d4263809ac19ef398a0811ac8d80dfeff1cfc56c132f8f5a3905bb71e982d47b8142bb0fb80799f9d066bed1532e3c38d60ef81c0f2f60788b03ca28c4bbe97004c43c5710a5fda6db9fa0d455b95ede0237e10f5351923ba3f65a8d510eb88b0f241aa646974fbc2ce11c7ffde0206ba3afc0641745482f1edb92b793c43a22d8e36539e084a910f14b77c5e93c1d255da9949ec56b22ffb71baca72ee5eae5982102459b826369af396ea49a8f5404c202760281b72c9a51ed62d1dab123abcf0a3d6c47de35a9a032984198edfdec2f03989a80c3c6a1aa01100a4723c97f5305f24a44306cc7a54e150ad39ff8905f5b51aac0714eb56d3c7d1230081ad7e4bac3e7c46fe181d2527c79809caaa1c1e5840f0dc9575cf93bab7ba13fc56ef955e83b7daa291fab2299ce25fbf83bdd842d301d5165e88010f8a2fbd8118da232334ff634e8ccd981a82903f20832a561dde551909a49578da2f2729f076fbe894238dc6607566bbbd94fd0717543a77f2c455cf98c5bb4716e43e7b22045125b4c8abfc9645a7ab449675f51073300b5f1adbdf21afad2517666419d7146a8fcb2d38cea2fcd3685d74f8e4670f58ab931626dcfdcd3fad54c300e40a59f09774c9401fb8a638f15eae31b6e45d45b656f66c32d267599c679cd21bbf84e17e86cd731a35327138d4f2a219a2d46b04bfae8b7a29de8054a4fa10186edd4c0ce6db22bfd0979a4b03e4ea1a214e5389776dee3e90e6e6abc7375cf462a52398d1bd6108f1d4dd5e9cecfd2de8f8910963746f31b085d366541e3d2bb0954b7af3bdaa311e8cc1260e92b963ff9d8e642beb906742d78bf7036fa29cf35fa4d727191daac04c9df84ddacfa700f45f57089140205fc0171438a7fa34725c95cffdeca81e1ace8e790ab32bc75aa9abbed044372bbd2c01c8ef9e61aefa3f31c86964a7568ffb2846e1e698e937bca65dff5e639cfd84cb609b348adfb512f1047c574476b941c64135747bfba68c3149753fb1a0f53dba520f71bc42ba1d819d232a8eb89672f37b99bd4f66eeed4b59d85bb399c821927799f731fedacd013729a59c17e4c5cb5636e42103aea476488eb24dd0dd13e0960bbe5b247b82eb09e064d313d5f2b1363387d007867ada17dfcd689adc8a856f73fff60cb00cc8758b70614bc6f4c9ade1cecb61d4ca7fd646877055206956cfb107e1102534e3ae6aeb4de986ec32c778442ab1073d1a65bb5bad881cec5e8b7b2e756bc0746046610b6e95f7ed6d75ee6538a3a0ff4ca0e0d578ac2420bea4c4121c1c3731e6d718c932e0fcf4c62704ba2767e1eaebf0709fcc126b8f99dfbe2cc7281df31a7ea6ada0ddb1e34ff3085a634271ace953551370fe7b3e4f8eb793d644715f8f789aaa7b1ff0164eb1489a83d47d1aaf9b1fa62b8fe95bed4dbf455eeaae059b29bfe3c5a8c41677b980544f42c7ebc4cb3c8d1a40fe0dc8bf8458450391d49470be98e2221d979949fe0d9b4affb089cd6cefbf5c6898a2c5aaec8f46b95d09065b865b11993b0c2b10e5c943476fd00d3ec832dcfca9bc68fa7f06223b7713996cb3024359503cb9fcb7141d48cb4dc48983a5bd7e26bd75cb45a792fc36627c26dc2fd7d321c89c2732df033b8fbc9e4165eb12b57b295f21a1c5f567cb3ae1c706e8f48db632a30dc46a4b4705fa62bb321b4ab00a6db2072093dfe4b738b207691bff62d7c57912a5ce0e33b0e2f666a8a027cba5bfec1930a0c2d5f5196a82d0c8e0bb42f7940f4fd9684d22c1d615413c7d3c385b937662cc3c4ebae3c535503107876d59cad005fe970d6d6d0598ff52ccf5aca89e17988add3f0a8848d4d9ecf3104c7fa6d8560831c52f27d498d4dc8a6775dfd149dd2318dfc8036fc1a217b95db50a0fb851f153e68d84c52064e51366eb1eb45564316f1dd6abc682ebf0e8fd424ad3c6782b3b10da086580a1ff80962de9f2f8011735505a5542776aea2c21e2b76784edda11eed2e8bc5a69cf95f21d09e45989b7f377912de25d3eb1156e3de9aabef7e94ced8d7fb6b56358839ca59171bd8d935116511f223f5162cbf867dc3b5e61185e68b0b7d4b5e954cfd3aa4443ddeafaae112f6d52d3e7b58b93b0ecb1cf2c85bcb294c1e597672bada9777b0a552f06907b5e522d0af1dd8a3066ea18a407241ff81704e55033138e59a943b418f50b8a84cfeb264aeafa0dd1ccdc2e318449869debaf7a2c23247298616b0a80223c4667f2468d371eb6ce7295737e1d155302204528503922d048a96c910707b43473deeddd5583d97c73ba54f49559f80c0e3182b44e64c49b46b349c7e81f7437bceaa96f0314a72313e4b77b2ce8f6262f7a0d95e3a56facd2e1243e9bd75b62683266565163b4401c85967799be9a29af5ee85a8a093189182e90700d76938fb6c339cf0726e2bcc3ffd4f643f2b6b69254a2143e526180715fb5c9cd4332dd498d4303dd6a8d775276d943a337349e27ce1afbb378484dfb0a114b1d3064f1cb6d8f7a8dcec64f30f632b6152dc182936cd3033bf489a816893bd34cb7ae4dd17464350971130579db068408d949987775973d07eee12143074b3c682edd0a69edeffdd3cc3bf9541db289c48dea997b89ec35caad07405060c9685153cb72422053803488ec52156c0c2ccc7d8a34e144968058f645d0d4beae7edc201c7c6e6680b2b10a7e3deb78709362fdfee6bbd3ef312a1d7a00788ecba048812051975628b6d377709bdb8b78c2ba69493fb3def61ae4bd7ddbce5b5ad522e618a98b1dce8410fb50aba4c2763e9aa195782d8a5223588ff568122d6e5ff70b6e0e14bc3ee4f8212de1e44c3118931a2a8b3b5a62a94800921f877d4958e16620955a7fe2111325e062896528aa16a79b4c861f4ce41e9e9b72eda470d156e7e075aa1f3496d2ca61f162ee3457f5b1e53c156350eedb5673180141310172e9d30c97c2c07a7fa4a73229d07b6538a2e7818e5370ea91b60b10e66ea73aeda33f54ab0eaf552ef9689891f0db72ace3dc9c01d2701e06ff0e1b999e3339a6c88ff7d36bab50e97fb41191a7f6a813c7299cce797e448ad5e468b32ad2a4d6d2ea5921f1e813a10067ba790b2098e00042835ec221d4a28c97e12c5895517397fed54fa2cdb6ac9b5d4524ac9aa7da14b90de45032f992a9a744462d345cd2cd64bec6be9fae1c62cfae798d8337de32c4be7205e832525439bde89f3d08391f97af97f197fc2ff280c73cc6db7f02fa707784bed7ddbd90d01ccd909651cd3e1305507167df70739c3f9169f874b44121167781b8b1ad65a8d20af3d07d748c7136916db115d9d81aad969b53cb87f57cba87a941ca6a290731ba3cafba6f2a7d459ef6cd4a242e241290c5a074e0c4682c656d5f25758590c274a85c4441b185d6fa4d8f4978550cd2f9adee04c237aaf8878efebac3c660e7e466867d199c8e4d47b197dc1b75e0f89124fd0362c9c9690cd5f2c417174f73a26b7a78f83a949363466a5b01366182281be48fe92802c9f2ee55ef236c726eed4a6e2e71729498cd5bfbd7453a25aa2b133aff2f212912ba4bc25878f81df794530722aeb5140af66a75aba3d80550d9e38b70634aee875053bd0e4e4eef1392b71f6c0a5d786bc8f2764ba602063c9541f0660f2a6bc603b714e4df44899f69c5298fcfc6fbdb542a8e8c77254229202a315ac068ce099d92ee1698af27df767b2cbb8287cf9d671cc4aad6b3968c3055f18a51a4073a0ec33a0e6cbbe38db1b4700518989f2cde21995869a2a78bbb9f475fd237be193ef5f8b899bf967ee67058be513fb2436ed82abec6aa299262b5b26f077b45b83795a77a4bca4a877ed60aae31bc5e92be42201c333abb3515af61497f2fe66a17937c0c5695337d64a8dba82387035395e5363511003d7e079e38347a1faa6da035a109e194642bce23a33be683a1fa74062f7a47e51d1ace3e995dc3146f479c2acaa6159b3247339d7d5465d20fb35ed4a8ceb4ecb46f3d240ad63180e3e8a614e11c0385fa598ed84b009b68dab4d37a217acf9eeab78c0d664013e7595f8ab4e9ed11b97bacaf002403dfa4088e40684cb816ef4f03dd6eedb5957f9a20aebe1131f7b208ed93c11b4bef5bb81c70e64c992e4cddfdcbd3a87b02aa66ca675f1a405600d2ceef54a0d552e3f0276da73e4bda0fac7f3665cff33fddf40ccbb633dfba18180b2a684ea4ab2e82172ace69f329167ced0ca5c85f838cc17c9460b061acff9721109f7f11270063c3f3e9686f07ed0a7b9d0e6c5ee882ad248b1ac8fc8cee024d4dfb3361a72b1a20413aceff732c1ca11b45003012ac2ed4ff13946f14950476cab34cb7327cab2b3dd2ca4fc4ddd9e4c17cd26cd5005c2931b6b5962a21630ec7445947f7ebd0869e888de06e2658a763c05914e40d8bef6fea19e2e4c80123b9e58562eb5aaffaaedda0ebf2da678ce20ecc29ae338997281f502e0936bcc7f189cd0956d66dc7e980ab4c143d98dd2766b94efedf192548c9f8e3c2d49a96512f53ce73f968ec8dacc9114fd8d8978654094a8bd953400a4afcec9f8b2f4f49fffa62823107ec975fd230a4b40b23e063573f6088e62cf221503d9e42c3c210d2b7db4a79224537dd34e1b025ae7a5242fd21710341f9fab57fd0260a5461e60b0c8cd2c39e9687908d68eeba42ecf1c5e3a21063e8b7fd8b29a6e1946a29ac7f24f4e0e468a2f36fb5ec43d6453edc48cb60caf239a22eca607bdbf15d8fb36b34489e66699430921a1a5f490c86691716cddfe9855b4b235f60ceb129a8b94bedca2f4e4d0532b7183b01e3a4566c0fb2812ba93e1648cbfce8212add901e9934e2e9423e197549fb401446d795da6a9bc0692a1d9d82305b98cec55d934fdef5e79d7cc736cff6ad3ad165800a691c0f70cf725450b92eb65d926f55850577f741b30fdb133dd5c7ab911d18b6dd8ec6a4a54da2460a1bcff1ae083058ee67e36ae7275a153a2afd2139d6feec43013f84815c3a462bb083cafdaa5f8d907436cca04afc71d251fea28bfcb789ff9b47c59f7993f99e8196ee124c716cd089588fe72175096ec68556e627d0a40808682878f3a7eaaf0824780620326539a98aef81693dc801bb0f46b553c45c209181c7890c0ba54b1fc1362d62434b20b9743ed3864094465011d942b0972bef83f2cc174975c8750461276cd4540931bcbfafd2c54d602950a366b642171e2990649c4ad153edb4c32922fda2edfab3ab115341f0ef263a13a02b32b417c3652eab9e5b955e92dc38ce21a26ba0bf9d113343df0b85de5ed03bf2030e5502698a43bbbeb670f39910c7086585bb6571baf6823b0e72457f59ba7089edc97439b7bb80e229719353ca4d1c231709b1fcafd29cd63f8cbb1df1861baae09d9e83776135ccff77ed1fc1314be1a46236690fba62cc602d417dbc0b4f2a56440226cc69f26d8b44dbeceaee96d6b0ecc90981d9040b7b1c8b3aa43497a2d90978504af57496a7ba66198112b11842761d9d9fc0f3ad7ca2f9e5ab49f6e519c03854080475dbe66020ec8d0d2550b7f14f01d3ea042721c7d2146a597227a67ac1d722edbe0b46734ba983c91095ddc0360898dd53e490e8a92d2fda8feae65a0eec21dbf7f2120a466131b2f5e6857e130a6309428510fade9335a6e9466e0411ae3853cc467c81e22211f972b69f4964352328f601f6190d2b494b2127e2f4753cacac6331e852ab8915c83477fa618dd265f54df8b0daf013d922003aa128b94356b0481af55b4449543506dda3486ba5f0cfbb44843492df9f0b807bd22d1b52f67ed51b85a47b70e895fde067da937b8eace7c6430768aa93fde573dbd1141b429fe865037258107b0b58459a0398c2b049b5ec665b1319ea440e07a4c079f1a7dae7aff30b09a72796c741203e8ceb495e9f389ad8b83909502e3b2ca425246a93ea9eda821b43e6b3c0929d9a53e7be4e394b649ee8e8668ecf536e1acef259b23beff8eb786f5d66db143ce5b7e6671ea0cc40eec77962d27d4372fcbab8e16745da2b0176cd145b12ade6ba189cfb04e58429d3c544642c386b8be389e7a5ca15edb0d88db681e515bc50a8ce98d13c18037ebb4721c41dceee7449fe7eb36b4dd50c6f93c1b8b6a866d3b257eb011b2b395092028f4c00b55eed8363c81fdfb178f6584df26b861034674ddf628ef914c50a97e45a7dbcfd95397e33aea69133763d2f69c1cb379e13be0bc43ac8bacb58ab1bc2b88adf7e282370d387c96761f7c6671f2889f93dd0637b754de80ae740830d1d675378831fe9f0a48fb57fe4ea4ffbebaae7f9cc0f9d1f0f32fa184dce5ce1dd550e2ed2c788cb968a9056ac28adc1cb023db198ff24218dbb3e55f60c9bef56e533fb74e1c3a8c9867026afa927b33968ff9eac76e11afd427258d5a3756cbdcda4b4dfb6b36dd797e32c022abaea1b1952c95b83a9414d0275739f8e972f954747f1359b8d5216578c2f993dacdb19ebfefca274ebbf5dc3c64f9108ac56b55c893ca870080809b6281e3070c50bc571ce051a4dce8b2a382335fb3f3d859e50d298771668269c044f0645c5cfff1aa49f5c063879b5ba7df876310013f57de52d60c2e89660b07fc53acd63f1413729850b93b23ce34ff0ca8cbc6acdfa2b19879b0c870aabbe6e9b794e736f56a47f63e8b9023cd464a7082c436805d7777d22155eff50564bf6b3c9673676db7fd8c852cdd3da75fbc4eb9ff8a95093acae2afc8e65f0f0b9ca9fb86fbd2dc7becb1c91ebcd747d6f06d56ac61211a3f1a5defaed6e2358823154e96c44fed8fc49d289f326be59c0b68e62ba9d76c43fdacad786f8e20afaa48321124f2ee90a898a0e9208b51c2924eec0ff84e7643b4058d02a275aa3c8a22430b18d0489b7c587d900679cda052cdd7a22f5c06fb28c174b0ad207944e1fb0027236d9274d4d41525f8db40b99aa5ca5a309b478c8975c9009360217473ddc023f01c130e0f1907912a26e1eba45349b15e6d87715855773a1d44311745129a1ed4a8ee1f90b9e1fb09647f96a81b19d089c58940b4d6f4c5a9bac1daefde5c3143295f5cacbf83827021f3d87b4d3414cf6ba40270b9a3853b2f65647ecd53c6ccbc0fc9254f44f40b79b386ce7b1db8cb0d88b155d17ad1e7279cab69d878b80a04053d02e7c60efda5d65b10c904b2ad1e77a132b8496ebf2a2256ae638c44adf6abe234a52aa9e3730d8c3d25646e95e7ee558215ea12e212bdad228f9cf1449878f6e3738ae7f765a26c003165ad3e0be161d54b8b1c2115372e96f48d6ad5b522f60f0adf78038587f579ae5ce2ba5051c08e34e177f5a6b90fccb2c5b1dcd8d76f548f1f11dcbb407a93c2cbe811228a7bca8956c49c8c3d8f7855b93579ca8d9231f2dd59bac25857931594c04bbe16113dbec2eba2cfb5170d40d1c4bbc7817a66bc103e920850efdb930fb6d3082c2ab96e4a8dabaa24ed0d4b0cf254d8d7be944b2f9820da6e392d07d38dba4ac2edb8b56ee3df079fbc8be4ba911b75d335b3d6368b118c3e1d85990b2c90ad30e900b0e2da0f29090fa866b8aa8a256266d0dd1bb163b7829d74afcb9c3b00e5b11d6be07249979c681a71996f6deaf84eb13ba76556100146da0063847668eabb9cd31581505b28ba94efe0ad02cdc7c448e037bb13b66629773cfffc4a04d3ef61949943316534b9f7e5af3b7c54f1548a460b830ed90d2a731a8e9d361e61766ac8a0e17f07deed32d58e95b2f09f0ba1d543f7799e6b6d5f02531362c73691a7049ffd903ae7bd9a6f2a7fddfadf686ee3e16b5a44fa3b78f69cc8ddacab93bfd501be92826b4dfc0a0482c52ba18c7fead47d576c6dbb7f5d34b752f5e0a1ab0410b26e32c40b0694fff1677092ba2ababc2c2995f19988d498b2317016caf11f27cc6bac7d5450f02935584e14f9cbe7de43c0b2df76789a35b5c76cd5bdd8fccbbdcbda9622a91a6a455f32cd8a67e539e165ddaa37809649effdfcd677f3cb90f7607f1c5db515d98aeee59367c027b0e72b1128d272871d0e199dbe28cd26b863d8540c41f660cacf1aede27dc4801ec11636506172ef028761ad8ec2c2a095ba5d21bcf166ff4593fd66e96ef395e2db0e7de3a9fc35a7c7dbc2722e67c51b28bbfc6a51326152c29c7c40a7a77daa8607e9425ac37290b0cf715a3a5ce95e0ef60ae4cfb17d42fc7e69845e180431fbc4d83c99da8ad2023de9d74cd0a7914577878622895f9f12cd443e72c2b1e6dc5a90703b651735b379530d6e62b81ef7b3602bc86bba8f51e7f142aa077c4a6e94b892fc5dfe2ff9a73e837e53aedc7fd7127d8c7020bf732c9c28af0422f75d16fd0f16eaacbd49792ed453402d03c3cd54ec46111fed3a2536b1ff3dbddf280be5ccf2faec1d73f18b4efe93d4beddb420443362d64228ef0d87cc2623fda1b7864860df1f22b298fa7b8e9fdf9388cd38139ed24a41da31e2a66f5797eeacfbaeffecb7c33b02e986bd12aa9fca513371ce199568b2c3c1d7b4abb1dcba6826ed72188648f8fdcfc7e63c206f48f785c8140277e4c6378e8df5bd7b97890c75aaa49757adbd8da481edd197282004c6b66d251fde6a622b859c90a1c295b678e613a74e6b6f9eee043713e87e041a3955694a2b4fef082c80a058088eb8fd5e904b07403c72557f11f9d6f45b1a81ce8c9b57e8b2347857b9ab3f636926cfcbc28bfb20db8055793980857a05fa7057cfe07325b9960e207f76da3540815ca3c7ce6dc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
