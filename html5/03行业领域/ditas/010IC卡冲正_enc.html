<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5768a46d570d1a2f616dea752edcb9a4bd011474a7d3fa41c0cffa854cf39910e8b1d1b30e8d2eec00066074d9be492361a2d94a7ec32d035d4820eab4231b14c74b812618f8ea322c3d6e45a78cb190c939da0ef7af7ab565421c72c497e9fa693d743590209a5b31af7f1b0af251f1f3a9d185734f66b46bdc239d17585039a56bb913ced11745b113f77a961001e9bbb98e00ab77d370e1af8ffee851976b0aae730b8255dcef091d58a4c98e1fec321f8c71deb3df0aa98b60129cc311777e42e7422e707830b5a3ea8bf2138da0ec336cf1e9505a702f3c6bd508c787fe0f33b5b1acf87ae6c4aaa770a485a72516a9ce544ae4840dd2273fadbb19d6df40565083996cfc43151c3abe5065f065a18d581cd9bedab5ea0636eca4c259c399340065f04d4bcb38d916fab6a4769fde31d15625dbebbcefa9e6716361036dd141f1984a8edb7ccffc608e1f03fb4757005c936aa0fec1075fa4ae25641f75f6ad55f853c2cba2e75d80ad7079f2c62e4ed88b9290211876c9b22f39603c23ca896d8e618d382fb32585f08a04a49968c2a744bb39362781ee4fd44e9cf2ad13a251672d5075523a94e4d0f72e3c3336d11908c2e3a7a7700b928f216edcc3bf630a2d8f9eec478648d45d2f370506f980676ecd36d8b984a75b4ee3a53d2dd7548a50dfeabd7745a0ddcb93180980c0119fcf03e3c7a0522c0a2deb59fc7c1e080ad54c5863acb14c0af3ab2713331f9b811258575321fec30cc65be4730400581b7b58a951e1d2306a41570955dabc192521f42c34324dd2b637c3ad201b6c664e0de76a9c951488da2451fed539249680cb58beb3c780c66bde9e0b6ad36e708c4785441591c0caa5fe9badaeabc77ba454a2ea95c88519c07d1bc704fd8b5097600f119a19c1681b5e3e2ceabc2dfe614934bbc4b6de68390d9ed864c9fe9b652ba3666ba70c06708e5d951c29aadb4a9f945e489cbc1755ad8e6e09c370946fb4944cf02cfd15178defbdafcdb583f8525c937ae2007072cef4f0fa1316e099069aded7544e548b1669d139e537b29f590eb31971bad42cbd0448bbf84c3b9e86cfa2caf7ec9569db7e8901ff218bb09f7e3b7cf967e1341f43de25afe936b4d8b520de9c26ceed67ca5a9a28751a44974e3477edeb0e6900fd0a701a9536e4a3f9af2b4924016620e5a1024ee21a7f36f955be3ba96ed9eedaaa3ac3e3899d6ab46a595fb23c228a6decc97cafd96df0dbe90c77acc9044d450714b073eacdddae13bd1309bad9bc60e3dd867b0b27c1da6307111281dd9ec6ff311466c9bcd6ab1f1c6b8aa98a2b1b4979ac7fc07a29badc910ad3caa41667a554fe4bc85b2999d930cabd04f8b04cb8f91bbf205bb5eaa97a19b54805aa113581e316be12a389e23e2a7d9dd9b510af7695d9815b5db60c49d973fbbab972b5da2138dc713559495c1c99ab3d352b7369022c81e7062f472ae0053acae8e2062040f67696283cb52d56d7e44a94aa586303c156926022311c255bfbdc644d419aac8990dacc01c8208ff3f5807a62caf6f3f01eb384faaec3fcbb202f1ab49538b643abe7a4453c3a6a2f7ced7d7a7fa12e19a2151f74e2b63ab2555fc428b3b25d2ebb4ee6888beab86c092379ba3acb9f2a346a87e105aca89dcc3658297c9e83aeac72bd4fd65a1ecf9a9a4a49f493c8fc202c0975036a60a1d024471825e33deb5af430b4b3e5652aeb61e495bc373ffc4afb449d7cd7b83f7baebafdd2118a99adfcb3201407287d1a9cf723b4f919996df74ccbf7d9921d7d51541e337021fca6318535439dd1bd7b023e454355f5832ee6b92305855838abe30666d66c0ac27bd9e57ca91129fc1d32d30b49ea7c851216a6ae5646051a69fec558dc6b11ef5fb16c757a48b33f0bac34b12915785b218f83e07cc3d77e674ca91e132af933c4649e68a0e254c3848243624c186be15896d5cd792b3ddb4a7f9dadbd0ffb0071c9b8fe5b54616b7f9965f56188bb325e7441004f8a1775130a8ee639545e4099a83cbcdaf9013f26ce6145fdab74cba713bb873cbfca05a4a1e9a34f4958361f0aeb702e31cec89e5f4e5dcd11feba732b2ecc46ae63588e767d63fcff214ef413bbbbd813253ecb4bb9b7311376869a5f1f435cdd8c601c9b30dc5ed48b9eb91311918afc8f41791e3e68795fbbebfd93549e33aab8420febe9d61055b917c86610fe77ea270f53d0c5e7ae773ab021fc84571a3bbb8c94ad0c2ce069b4e88e1a4558514b83e870a5354ae3a586891c0750fe7d062accaf6c38ee245e7f7acf95c77128586ad3420141ca807c2e41e143b286e6b6e090b56fa57e2ce38ead3fc76c547e30fbb9bfb76abdcd58cca7310ae5214a9970313c973f6f6908c87e1bf5ebdc13186dd99ba0951c116d6807da2a3ad7f48646c849fe9a2adff34439dbe1796e33f0451412bcc3db00507bb3232616ec1bcdb7d35e44f5ceec1eeaea6705b071e321c79d97268436d83848dae19f30a6a76721d864c8f449fa7012b1d0ce06ad326a5ede751cd24d8d441f39956f8379149f6efe691ed7fa0c20f5e90a3ad4aed770b4979962ffce2fd03abefb8cd5c7df1394a36be0ab59c5ec337de3c02c6ee8fffd15e88b1c5838cf0d633d5ecedd4378312c1455093d5d1e3eb63f2b2cbe2dde1c5c3f388c864bd3e0c9a79d9838b918b365d5ed55ed5b6f54a7798920d750ea867f568b474518e7d91dd53874b37f994972f5706fd9202c3734730fb1807ce8f9b52b717e10e4e072e6cd0c1201c106463672ed5ce3776c625fa6e7ac04cf319b60a2b6411770f3de5ceb6ae4ecf951e2c69fcd23e97762982907df1bbf4db9b9e8a35cf71ad4e2dd80c15a50cf39d9c3500327799fd341464e5a313681b758a3908bbf0eba1096405c02f868364116c36c5cd22d1f8ac4776ec5a481edd1f585528ce41ec8ceedf15c12520395b87c62b0ed91080def7530d9281aab365196eede282ea431d4c4bb1125bddb7c6a4e5d86bd68fa2e5fa6581019c17c93d181d57debc51f858e9f3bf335f0ca6aacfd543d1fb77441665e5e622954ec6db7570564f58f3a6fad7200efc5174cc187b93e93bb5d9eea7aad43afb516fbf4f1cca9ff7b5c1d57c5268d7154c1a6452fd4721e092bcf319f7d52cdcaf59ec0817335625db3703568911b4121180d1fb10abc822211fc3e0dfa05e78af8c1794e794e8e90df2d4dee65a0cbf34229381a40742b0c847b1d23c4ad583c4b7e225ff115839b33989144cf6b7dbed324338275f97e38eb214c7a48be052e423bf373e870904dcbaf9a7f101f1c05eebeae03bc77c654eae38de0b022198ab8af127f825d680e86dd0164581ee8b179f22705068ca19ee4b82bdc4eaa69568c474975ac17f627c5dc39e33b4a34372dd6997e95cda673d851d76a687d733391aca58d801a972f08e7572e6067bf2768fed61b92beabc2ca9e1fce02b758ce25686def2984f5e961d17d4b8e19289a5530e636bf2ff370109f30216913e558a1be130a7711efc37d3a4e3b22b97f5e0b2d574e26e8beaf98cd8e015e47d30177f881b7a34a8e43dfa94d45e6b54309428011478f37fb5ef130dda2a77d4128d8390fd3c40fad5381fc120fcbe421f164cf0311a7db3e990918d5f93e5deca59afae28b661ba01eb7edbf46208fdf89280d9050f2b8bde94f0e5305e5b514df47f7a6c34b1ec15ad2452f93bee49c1d73a10e09910f44fd12a0aa2a598f68c328bab2cfd7a7218cd73113f7c794204cb34ee835da58e28b464e1a7cb1a57097c5a62df64a31fb6d87412ec7c4b753afecb400cf84878125b0ea4026fbc1c7f906fafa2882eb4f6d0ca6f66ab458011c2a7c603f13e87745717f92d89a375e6ad2baac26d79e00794061d8daf7cf4ad704fc3c5328071e9aa14117c5603769028246cb0cb0cf5d4ba3e2daed8fe170731e5968ccb241f9132d56ffeca46b838bd50ccb27f555fb0c85a866c2d41e95913130c570be9554b0faaa4f985c01c89362d56d8faf7a2349e984b349314a6c0eedac8bf09e038856788c3e9bbb7a100596f9c9bd5affaff4ff28764e0f44bd49ca92b13b14d5bf76800671cb1be737471e4323cd223c0ef5612bb1162cd3534975707d13d41c6323bc686b21b85e571a89520888ff2909f16f0adb835557ffe27f1b5a99d02e790899be11a87dece032aa1eb53bfefb0244125ef9a6d9b5e16b21deaaeaf8b9491cea7048f3e00b338dc2b79baca20dc692176474d849229ec725da10354d39ce433edb5e8dce5aafe658256252063666703a74bb919c361402fe859f197c24f362fdaedbee0627e3426fd67ef8dafade884b6a95617192c568b8364a678ce9bdeed26b16c885b319a55c311b50f1397afdc69db41112aad031f3edfb7b913862245d5b94e5f0ad23baae3569f3d3be1cdde8afd0425525d57272891dc367f019fa7033736955f4b20e41b895b5b087e524ef379cd671d3322dae3faa97690bc293090c88f8704bef897dd56c703fcaa12a547144f92263e0f350e0e4e0839e587ae0dec3a3aa02ae0b17016e2d33751cd49396f6228bff59b56c80db6651676e4511aae6fdb76b72a75954a582193cdfe551159b3cc5dc3288881aac20f3912387d26a2284989a9b20164bd1c15164d7106be66ea47b567c404f9d47711dd91647888a89d687312fc4c17ff79ff97433858a37ca6d08f6933c7a595694a1cf38cd59424bc6fbb4fd1cac3090b98aabaf101a38daa35d0b16cc94424dbaefb5ce330191247a51d3853697ace948279cce9b97db370b35b492882da4c4686aa394896f92a9c2865224bfbe2fa24d3f1eaf20a2ad0985a846ffa64558496b9b8ca462ecb4326d624b29b373302a2575424bb0b6de7d77029208ce21fa6b6994b93faa9572910fb3b9449b5daf09cf8cd1a5777c05d0846eb3a274a261a33e85fed9d8918f23746c4de3d87e2501e5f33aef4050fb3808feb53e8e59df5c92eb635dd297aaf065f60c766caa89c7e2c6038af6da9e8becde9b02c3fd18da0d13340c0bdde2d6d9340a420314867d04cb42ab68cdb8ddd410214abbe82a8416c9f503a9c59b4e16222f4437512b503677f898d1a3c389fd822118e65842376d97cd9cbaea8e7f5e1115f23cabcd9b5f2724502f0eb81c3a2d8311bc94036cb7bd1c69768089d9985ab27624cdbe3689ea92883f1014ef7e804e56021eeaad19e9eca015052f737f0862fa1f9cc28cf1c8ca7e7d4ea32f11c082360081b817fbd2e7aede380f2e1861e2f6fd187171cc9637a21a532d566c62d87b0ebaccece7f220b54035b50c8101be652a27b63a43790a85966baa0df88386fa0d8d7e4ee64ab1a3e253ed5dffcec2d581fee4845bac3c1401c2b3d28d525c4e653cd52855f0d9c29ba6b3e6da023b2c64bb4943389fe6bcbee28637405ed6b99091e95d7ed1f9487e3a5c3b81c0506b0c3c0b44675aefc0bbf5332ce9c1f438620925f2f3da699052a60f83818e6f6d23310d8cbbf9aab99d0ea86cc7b64a71b3cd5e2e22b5071391e39b7425ac039292d7a21cb20f9d3461fa81c1fbd8638a1a3a7463d0bd5e645c5cec76f938f2e0e8f5196e1726aed2b857ef79d050e63a49cc963375b04cf7106517bf1a7f1068312d25ac78ca33f705a7efa21d39c59c61c1633f996864b59df0e1d3e451d36055b56c69976470881d62e6d70070471fc4daccdb47998eeb8c6ff2625480450e8b39884900c52448c705ef15bae768f7686a257c2b050fb53b45d705de34efd8478daf6d51774c3dad7fdf1c6e9e2a1db8b106bbf2dd01957f698f7d1c4815039b993ce12221db5eb9ca13e8bdcaf1452cb3e2c6c6a96701d279f9a8cc0bed555811ce1c6ddd9e0fee5855d696232c397aed026e7286320ac91bc214c8958acf20ca2b12413624f376b0b2591dd9e9e9b97f724627e207900da53a794f85a954bedfe9e62c5f08de53ecd16bbad019c88cf63930381b4c3a8cf22f35f36131216e8ea21f1d140998b0ee2f7e939f50e79c7b7dc3ee5cbdf8989907dc034b6830f594bfae5920736fa5efa93ee6236ab9e98c7003314c68fb30ebeb9ea60c02d75bb8ec8e03d485bdb549dc880ef1c9ecae7e9424ec05ee7d0d9e67e1d095378aaaab01ce3a7cf1baf8d16ad8c7811f2a96d7a29a49cc263aa5b2adc4688d70379720e43e61ec61a38c95945ec4ed05463d0cb0028a65b19a08aa346990017ae8a356b750186750a715d5a72335dc62e5c057c63e5b21027f00ea19c16e32d4738eefddf72208ba80e9e195f07ac088c0dd31faf85a81e8b61b66a68e447af0b3279085a7ddee3d480f4da6bd0963ee3e17ac252d9e64714f5fb8db339b3471e78bd57e4536a05303618b52efe1cc12e17c3109ac47c2fa73a0b94591e38a84a257cc94830e4f7e97f6eff03afc5857e75d2a744c7de2316df8d121e3abf97a5c707c89ceb56e603dc8e7a1408aba2850435b38cce927806a9d4cab18042c32189114224d8a2f91a796e6de0ef7389a38044f41396260dbb6bf3da56ca9b98fc867a30fef21421bbf1abc03151a924b049be0af40f5d8b49687d598fc510fd5fddab2a418a6e06946b602dac74a9ade23dd327bc844c6a687cf25572e97a81e602ac897436f6f2bac9bd17b03e09ba8cdf15ea19610aabd9e52c558e2fcae2ba52da4063841646d82d3c639ec16b0257fc2e7b15c38cfeb352c9564433817054e64796b4af242dfc3c100a60502e4e9f46f74b70b11f7cfc73cc2da6f89e03ff2b2231ea5dfe6248d7fdc28b3bd5f156350d3d9e3a96297c04a1ea6a1153ef4eb6297a14ca0a5953bd31189b40e9506c1a30c0c6bfe52749eec7a10a2d3ff24930ce93aa69070e29843181feaaf54ee2ce63da0f50ba3cb02f74711a21c439435179abad54e4d3ff4e60bfdac3df1597686096b9f4b5d84304a4b8d4ac9950f5e29d8d2a327c9aaf369baf7b6940aa94cf4a1a463038a00df8b951c9ea9cb47247d4b5c1d11267e85b305e6e3dd3f99bf9cf346e7c97e4396889903347726ec98999690260eecf62afeb7b4b053e9c3186a92d91866c8b6fbe74b0429d0385825a262bb3768e2a259310cd6afc82901932803d10cabb5c6672c1d10bffa07c447a6114c87733dc00b8ea33003cbe443c2a116999a54b1804adbc36e5c2b1d2429bbb984f484a511c7be18a69144949095f7e97bf983f012e1e6ff525070ea34ea0f1d2c1417013c916b9bf1d0294c2c731f30ed7bb43c2dbbe9e360df90449f03b527e06d6836d6c110a540a73e0a5625cbe2f36832aa2ac2bf9cc4e42a83ff39d6ab2235acf9b037504ff8e37e52762fd0447edf64097fddf4162f9d06cfd836ad2b7be85d9fc1160066a4c96a063899f27b41ec2dec410cb844d31449272ce2849df9a1c4790faba6dd7380da21cc6fad5392f690c9fb49a9da5a477f7287638a5d408e40a46afddc6282d62ba30330d9dd41149386daf2d63aec9ee86a287e846d0054765ef6e46268064da7e1a9ce942d966e6189605f8b2f75d667d417c0ff4e6f79dd1e22fd8934d7d263b7f1bec5b29b7bcfc758be80e72f43ba57a6425cf98c16cef5401c5b5b422282bfd459437381032a536b3ce838a273f37a8366bc5a0611f47887a3d6469e2218e3d035db456b7aff98c10412e2eb526110775e381125880b3ae57830ad309aa78bb4e09b5ecf5a77e3c431e57e8506d7e9a61d02409beb5f06b318f6abadf0f1c12555ae8d059a86f2f922c8d3c0e3b6b2c35f39eac241a03bd5d41a683c1310b0eecd6175a983f192580506694835f79bd0f94686951950a9214a1f3180d54398b3709cfff5f9778cbb998f0410e3f75b4f531ea379942bf5bc3892c5c7a10e40433f491cb37a38310feffd3dec45fe922f6c270091988df131638f36cc16b1322af9d19eab56da24e0b5a228c4ea4b8d3e9f6c5d1d2892ae90dbad61c0ac9b0daca8bd5ad32a48603c5dc6435a5c4da4cb7897e66b3b69b97d1ee243fb32c624c327a70bee7010dc5f988173bfe43d6c2333717b59b0fb5a70f79889ba1bece51a1ccf0723782bf671f7a6aac6c1914c4af4ad87358691e84c2f8b1cdbc733620e9706397d2bea43045706401bc752f17b1d7c9dcd4d2b63e4cb48499f5839707060e75fb37797cb5b99bcb9e5a6621644fe93a16954bf95b010306e414b33c7c195f003556f9ed7a4d98bb1e682a11aefd2a55a1ed0e3821b93bd19c4e7fbbb7cabc16711185d3a3c06d259bd542d455590d05c224d9de01b633d6440a23d967fa0830693ea501c46a7478ac399fdf5684cf0ddb03f4194ada1aea54f70910ceb8d1e1746e29cfb50776f7b0000b2e21f965783ea7f93ba912cee0cefe4be6ed6f1b429007e465367a9ba0e5f9896c684007690dcecbb4074bd87627ab65cb49b56da6417326e5eee76e48e5553c9619cba837766cd4267746efcc442a847b95dae15299dff088246432b7c9e02668c002353c045ae0f124647308f3c828c1df04e5641be00977e2fd1c1383151a19ef28e72bd2c0cb9435ee383274bd947f6f65d3a988d5870fdb3df288ba85f36691b1fc1d2058e42c28e3e4e3ae4964cf23d1d0476b4e68fcd76fdda3a70970743e91378c1cad37c7521c1b51798dccae3c684cdbf4a890497d257fa41f2df229a163cc3cf61d801690f49c8b294c08f63c65c46f7a97ef73c37105202746e63f69077d5cefaa0cbf57de8fe23921746ce5cc3cde25636543c717f8bff78ae849c5d49f0a01569bdd0954f07d8be9a7babc2df358f8be93b1856ceb2a71fcff43e8a94c54b41b6b5c2ae75a2bf083e29ec3a6d36717f3e103b8b61113088b8af16198e32e2fb5fe8713cb3d75c0deb6c7f64418526d79a767c6ed473366ec58d715ce1cde570b1d7aa1bee29dc0269e889c1089c229abbe8ed9e65f69e610bd18c57a3d301931c22ef295f3c566124c5335e85005c75c63e63a466f345c229109de2d1753bcd058e4b5f5b291bc669815e2f9672514dc8d283d278d9e38a7e606a97bb8d5b52dcbff82db4f7d24e2a546f1832ac591dee7d394be5505a23f82524dbb5a7c21ca1b94cc84e10732d3d601de25719d45998d67f126debd5c00991f84ee2ec5519bd07de20b4423f4038f09313ae782786e0ddabc21babd950beb70bd08843095db8c0919508f589a8bfb6f6721b71ac4221bb689ce2ae4a64d6125139d6c99432035f4da080743dd91a18f8c2c53f1fa32e6746753d9ff409923678dc44c7bf2ac298d08e3f156128979a797242d3a0aaf1f38abd0557029e6042e6fceb6bd3af247dd26882140631b1dc53cac87a19d41365f552207030bd176a3aedcd855272e910207280f45ee72b9854a65287f73bb1b6a7ea4ca299094edaf45ebbe915746aee62fa48c7c63affc0c4034e6b707a98a60764a5938acee3a58d3938914115200499ba3aecef502990daf98510ac931d8f6fc630ac7f350cbc4ef8df36917c970b14b56efaf0169249dbc763fb807fdddc5abc16485076644ed3996cacb173ce778d3f0385dff024f115f03d551ac22437cb59154aa79a4ce9c2ce0ee5e7f2c9f84496e4c43c98c6d5b6086691038dbbff24c52e3e3184ed4e60a5706f032a8513840fffdd1c97ee91ecd5aee7f4c08a9411b21fbed1b091d4eb4dc838a3f241987b96fc74ad1873abbebb8af8d58999bc09486f4de08aa30333ac1fc5baf0d945b98d85c63edd84a1bbc0b083aaf78739bfe6f80b3dea58ea0bbdf2a315edc7fff6c81944d874814578f022450c4b44fca9d575dbdfed75b846f22a987c1d2fe0d782ff59bfd2ab231dfa1fafcac5af2c30576460636614af2e0bc1ef03e3220f425dcfae07f3ef481b09e540153b7c3fa54443b240c98838a95e3796373f3524a738e731879546e2681935cbdbaec4c86697cf8ce4259c712e2ac11ccb8c50b3eb8812abaf952d5d90b1964f471f5d5a88db7cc9cf19c87377a37df97406906afb548f4d76f1884908172b20f95ca5c2148db74d9dd1861524f18ee2eec7187cf3c9454c99aef79666e2b2ff5bf2bffe030872c3665f403f332fea56e60852c0234779b0b2e458cd05f68c137e635de82e623d1d0b21f8c8ecd75259c60db59ea93697c9d828e47e6633885c1ba84f950e6dbcf03268c0b2e7e20498ee4f146670949a5033c3f28e4c34c85bec00a0671878a2df3d52e1e958fa547b2a4fb721aa12658ed725d3a7868d43dc93134ce3ba51ac77614969eec619","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
