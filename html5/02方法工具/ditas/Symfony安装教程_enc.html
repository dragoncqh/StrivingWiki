<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c85ad55c6534ce4bf7742b1184c5697ce567ab13b8f2a224c13747ce9ab802a18d49145e7d1fb7fa060680c600c35cd03f6f4ef279bc283018f04221c6d81af7da944359af4aa092fbad3fa96c5ea4fab73f823787588074a5626d805c9b05d3e1b908f4a8beba84ca4023b45745cd1768da23c32ac7cd8e688592650d5b70e3a270e42bcd098ec367a26eeb789e145a27c05f8a518ecf14711f61858d2bc4eab55de0e45fb6c419ab36ccd1f3e0bf17dd45a497f9a9b2641ebe94e64cb1631a12bb41ec0005cd6d3c2b7308aa96eaabe93a380aa2056b17310288c59afff4de7a5c198ec28dd13da71aed6c6d05b025739cf71e75e561ae25f3e45e23a4dc4e7626547da7d2a2ab9b641aeda1ede1208d246c55984a80eb6843e9e3181d238f7bce14b4f88a872f04f59cdaa1be0d361cb8af5637d5ecdca2d3daca233b7169d811a2fa98b5f1b35c636f08695352a51a35e72f345bf753a688f22378413b3e3c562c6e0ad5bfcfcb629b0a7f91db7fa2caba11db3df3cdfef86308d20107dea006b0e859d8df6b418c8571c89feab7f4f5ec22cf89a3edaf321c5ee3a88f62ca615c8bfffe915d52dc4f35ab838f4480cc36b308a44b06f545f4193529b2affa49c468bfe95d9e8580501a801150a5d3effc36597219fa84b7e3cc864a8cff46d0fb7228e83bf9c28a8d85972947cfe2a1844d64cc4c02975154ec05a7357ecdd47696ac3702e039f9fa065b463e7a5af9777c50da02f2b253729dbaa0e0d95bf782b02c0c895767df9c7eb242772ce0c2c97be0073ca2799921987320e944c2e944fcd71b9b7036e73c8f6681cd975138d6389f82d802212107cad686bf3d1f7992c17fdea69381536fe035dde759ea7f12c12a7c67063aae08af98d8e69e7d4062a280e10ece41b4ec7ad64c86a154ba57c274c6b331fbfe7627579a67e3d7adbf70a6c5bd607c48365d4727504ec72e2662038a572032e5eaead13c8c3bad6c858e1befc09ff0ade525228e80d6fc189c437f010e5ecd4fb51354f626068bc4f6472f011f13feee5ac3c2fc03d0650795a38f13b7b8b0df6b65fc3e04ad0084e3fc5b932e3267e8b27fb067a4ff1625903afe8714e6a8a44af9d5459390e32a9a7c3fabfd5fe258a8ee5504cfadca9e0f9a81784db95e6a8ad9674827c2604eb36eccbbdead008850e6666fe419fa2f250d5878e12a94e63fadf4e9481517cfb56b427c611f564749c9a1d639c7cadfad6875bdd7235b9aa4d919c0644100e83028d0afd93f1eb9625c4703ffdea799519263ae31efba10711750fcb1fcbe6530fefe5ae4e64ce380af5ddb0b12426981352e09e89e85d9fc177d5256c5eda62fe8222332492c8e04efe4f9850535540a382a2ce49348d1450f9fab367d43eba61c203de6b36755d2a6e244d0e0bdd0dce3c1ef5dde54c42975fc23d6e360f6ddfefbe253ce226222d1b3a22b29443ae4a7c8fdc0d8b247da6ba7139543aecc33277c08b66743a1622076ab745a4faa13197773245e2fd14700fb37d0446fc605a5d87f2484de6541877063d3e58bd6f03221f8ac9353225a2b7afeb2df7fc452c625aa70a397fce8f9b8f0e032b088612915148f9e9d84a089889fdd48ab2192d3ec46ea669b84e6a82ced731145aa654f9deab6a9fd0f18f4d07470a682b5e8ecf0caf50cf52df6f093bb5fdb76b6162c53fe1c1a7827a8b743edaabe80a34c9713620e718e0832d956c026ebe09e29522616d02493f814c8dcb3123d47d3bab1639d20121ec259869168000e844d290e819572ef9ddedd38cd67c344204911fb5a7c6bd81f4ebf937c704eb082698914225e06997aa7acfca80ec323dce3fa39c8ea74224f20ad918e05b3799030ca67e3cb4bacdf6c2b5fa54703144d9e268d30e0868e780766d44fb0ebeac25d6730bb67c1005a314e25196dc42c29cc14c71bbe413f4b09af62e3105ddf999c29e6c92a8f61222ca689e9464cf975b6d5c11bc0c338ac9f4ba8e815740dfd6305f305524c261ad005e105057731e6df43075d40bcdf9d70d4245a7a9c1694c14830c40eefaebf68033aa2242bdddea57f5e3cd743dcc6dbac8b6344e441c4db0bb05bf5e655eed57574ae7fb5b282bb60161d960fe024e1970d18dc2379d90ab136321e117e96b41178d5e120fd174f2b8053d8b9a6de5a442158c1ad59637759e142e00ff8cad02fbc6b9ca23f4ecf77b52ac60028066a703a889d6b25ee19dd0fbf9d407b1208e382d5e5c1ceaffdc739fe52187c9b5b2e163610c1f088338a3e5c3ac32fdbbf53564b183426a9b61b6eef09d5c5b5682e79d760ea8bbe90d058aec24c160d9f59c85194adcfde1ba0d72f62e18a955938315b95802cdd1f0a65f14cd20e763316e75bae7af3a845b38280e9c03bf5f822f30361ae2e7bdaeef299a54b6770b89bd7b163ff9e6a292e0f0be8c426acf469d06e5b6c92276da6a23f9ad0544b03d1234202456598ad00a8bfb6040d94b7153d43b3acd0913ff2ef39ccab72d51fd4d3d5b4bdf6679a637fb377376a86e013f074d0a8fdd5a7914bc2e2fe900c63774ff7a0624e16bfce7f41f496ee5a447086b309b3fc56ed6295271dcda66d0308b780d4bbc839cf0cc9cbf311ce8a01c965539afc5aff27f64ebb5b683d254e7f8bb36fb078e359b44e14fad5ef42c706ef122b16c1665c72d35e79e1009bea0fe6295bd1f23e532dab7b681abff4ddb4949c70117f1733ab67564593862750aad66e29a732a9764b242ca94fd6d33e061611654c6032f21d4a82a730e6fa0f8ec6538d5f16077198da640b986168fb80c864fbb015efdfe3d3ec515e213296cd6acba48fd1cbdd120ff779aee78a3a1b3ccade1343e2bed45d60062e9fc359aa7d7c901aa904c729c3cf04c555d7f22287a4a9c01ac49ee21015fa225ec58125317292565986f84bc441146f74e84f25d82bdf295aa10b30b4e748ed45b9eab657117d2954800b34eeafc6a69411df2da558b32b0b3381a3bc8d4c46e58ce21f74a7440937b59fd048d4cd4053a074e108336d04e8c54af24df24c3b16da73a2b00b25308c0711a56c1af3add969318a0af0d77fc772649d7d0254e3185d6ec19436d95f910fc550d98fd2f3937c80905607433fa58100920466caf3da5dd7e10b78e0406ef3751eca6f59fcf8388a5d72d54d45c9a7510f629f600a99c6be30fd824439d82090a2845bed32494f282745f8ae26abb72faeedc4d690da6fdfefc1f31a0a59dafdbb335857d2e8a21b48e7f389f65a1d84420fd2e7a621a3a1adbda10ade7b19b96d906e68f97f20e5ebabbc14c52af66b7b8dffc8d09040448aa4d7d5df257c0d67764c49c60274327c28cb98177dd981c583411d9a148bddd5f2961bbdb643fde873a6d22ffc88557b6a0999321325d6ea64d72ddee898fac794f9552aadb8a1948be15582b377946bc285040e776b6ac7ce38e70e4c08810aea84441329d1894298f6766038db917faafc86e19c05c2706c0e6c5563cdc06ba5e44d19cecbbef65eeb0ddf0892a4bc3e052c424b27f1976b35f7ba19596eced87057d5a104e8844a8f4c13aa4ac9190f59d6114421d1217b71a0c972d75f681edba2a56dd3af706dcb705082cc9135545d4023fc186790f4ff30368020fd22d67a78c417b32c40c911a29401e1eec9874e4c0de650c06856056f566dee587119253b0565cfdc0d8bba8d416ab352e29e97449c32afe2da12a7dd7dcd1596b23784d0922d6391fda0e5a854c92003e6ec18eff92066573e53288be76b8d5ec56212f8c46401599d624688e5ccca0672f8de197fdc2285b18fc997777fdb9ddd79ef41d178fb81d81654bf96211a90ee44b429056587d50c26e0bb934c29d7d29b4d7fef16a6d66163f4f07144699799ef8d9b3578065c588eb6e22f53cb69a6d95368ce985ceaad076ee69202fe89fe6161e49fa747ca6cc30d9d0d49f38292cf54f8269d40b83c2b794a1f5f7aebe90e54bf05f4468d3fc5068b9bba4684d247f9985b71c2f2a40e5c2aa2bde9962b38a923c8b2df87d353bdabc9a7548611860549554ebe6efb4f2b0a97302fff6f76cd6f7f912ef9448c279d93722079fe35b1c3fe2afdd7a81af7e12c2ee06abf0abdb0925317a5788cae4f2fb9be944416085e0573e228581ba02ff9e456a29ff7c86e65e88a37c6cff4f8b49d83e5e3998b0a3a7ef086495d9c7c8d7ae9c99129fdd7f2a6c7eb43d4dcb9d73670a1ce4fe0252291718e560d3a6f2e8f7b59799d28361ece5cb54a7b41577784456014383c836f0b2a1ebc341debd618156f19f1158954049f5aaa500ce6a065eed1722f593ce610de4011b5197281227a6fa1b00d3679f983112aa6f6fb1610d2bd4ac23d7ee3aa8cd9d8975969f9a597d31e043d4e626503afa6d9b65f334847b92b0f9344646c32ba8426df7c7cd4386e9ab69124b5d4a2ad0c8e070c92fc44f02eb261b2142e8d604bf0e9397231bd9c7f348656bf174d504660fcb1e0f179d2ad36b436ae378eb453d6d88879a72cf1fe8daaba9e97aeff4fb9e2e75bd16dd125c2ca251eff81495dfb90b90bbd2fce2f843a2311500810f01be167eb3c42cda4cb4f1c603df1b9aae34622a35071f97ab0085c68972664b5ae71ea5835511c8feb2a960160c50566bedb5030e4a6df672079f6fad7ecbe208198dfee38819ae426f6d7965d24e05cc7c1caa015a96dfaad4daffe25e705ba9624a6f50e508993ef0b704fe9971d453924146e24a3ed1f681eccc6839a2112366015ce5652a4833e69a655d1df7cefcd4baaa9340427e75f507f21632b7ca45027cab76d63b2f7ce47e6fb355689dd4d8e00ac20c42a7b3d9e233aba878654fc2c34fd658a41d797462a7d0e814c1c5030fa670f13032c43f4888c80a3883337e5b0d31a7e1d78dc9ed49983699b500accdd53c06696f955d1b3cdf3fc7d9c7affee2714e7547412f0215155a38e2c24023ed6d499266b1a4c8161f95eaf87edf43719aac2e5e3b86da9e8fee27a7fa3821555e65e0a4d83c39afdc63fda23f5ff37f229abe378febb5547fddebda57abc165f8bf6686bac5064d0d992dc6c60dd11a349a8c7ccab5bb8f904d660658104643329604b12d7742386f6a209baf9196ba30ca922718a5d230e219a67097bb2af67079c9b1a2f409c4ddb646cec6b135ad0b04b5ea5e4e9edb260d73d949f438d8b4a6b2ef377c087b9916bedaf6f50c36ef7f3a8927db0785f5ed47723abb763871ec7555c5ac5dacabb8c158cf82f9f682c69b06037ae66ef7b54ff4cf7e5e2b5433aa13d0a3ac83507c68b3912d8dbe969b0186a8f6a3bf6d36fec79a8e95d052cc7ef2f9dbd40df84f97a752e2d622b7937f662882d8705fcfa8288d4cf9d147a860729dcc532f2f57a7408d644666510bbf483b3cc228e207d2a2661fb131a0fb2e2ca4b07f795716072275cd96334c187bb23711942918af47550b41fc0dd284a0eeaacaa7c88329effd0e96cc29211dbbe38ee50ea4e6404cbd271c0afddbb3f327a839e0d59f825a53a3a0f5e81b1940310f1a5556db6258212964cd88811115f9d80d01cad515218fda53f98fbbaeda5f1cc868cb43a0837b149f7e4134e11ab112196b099c4a9696c3b440df98a2bac77ef184e8c03b7348f395e02b76bc3939e4ee8974a31c5c474f6e11369e2e57dfbb2ce5ff6c2d709e08f4857d7e640e126398e934b26edeb8b605db7fc0cf653cd29b86ab832316225aea26772bcb080e16c9e5dc2a36dbebd46c01b287c730dc1a433da4f485b3a82c644347ab484cfa73ce2c93336af6096d369f3f2047055eee4ba728e6748d9cc08be2fc7b46818fd6ebadfc2abf722802d658e7293b1d32b6f8d1742bf88d770fbbf8a91c79669e9f02771cc2da84398675834ee2541563f0d6c561b3ae7d799e1b520daa3f4629b5ad08f350f1680af1e9e719c296e0ec392ad34023f10706b5491ab8ba7eaba2296623bea718ebcc146cc097245096d06432fdd6bfce53d53b825ea37037c2e6d5bd0e4de24411de7b44d311a73a5ee930a8494e0b15c9ca12d4501956b7eed3be1228ac244f5085ac3623ee2677cce057c744dbb412df9f693362645b405340dee6e22394b3310d9e8c6b408c60f8b2c12c26333a28adc754dc0f00304cd6697c6bc9267af7db311232e26e76a6f980f10874b6fcad2c85aa7c1cb5af33137fe1b1d6ac9d7fcf40a5dc808824f8ca66d22014a4c6d66cd09facaf4be50dd2259b07c94b5ccaccc897c2eac81a4980c71c9a6b1c804b48caa4191def45075015a6dc27cf92884c72fbe58d882a3bc3131317535c8c91456d8b8bbc282ce038783954958ec640ab465804e4c760021bdeada19fdd28c0b5dca5a7dd123bdd5cf1c139132edfc763be64357885807b1ae8c56d68e8a508141246a9103e669f13657b11b65d03b248d4a37452b297d9dcc9733e018cbde56f6eee9a6bb824152f20bcf9950d84d630887663fd589426214962469e944f0e8c05d5c1d5524455842747a46adb584aabdcc8c12752833108fb5594ecce4cd290a21d348d853d1298c99ec9608c6e5d7f4d29a41c780fa22b34640847d8fef1c190c291c7c38c274466ccba6452e4bfcc2890a04dbe2178b04d7c1f35201b2cbc87790127ea55cfec03df8c3a2d8444cc0ac0b1c1094f761a196f3bded41cd6ec493255bc36734cab9416f47114b0ec73035a2373a80426dd873d7a923ceb1955c0c7c31ce4e91bc547022cbb176396c6f78c9a4dbe34559e7294db94e9f258e6d5c5a88b4ed359b9165d0170e3bf3e7a87cff284950a4f6dfa4e66cac9d2415d9b737d7fb5bcf651fdd6775028f420b9a58d7275654174bb9293a32e21b92d28a158f4f6c6cc0e11859207dd6896f96605d1d368fb6f1e8662a4a5ec48a127767d79bf8bf6910afd050a4867fde8d8ed501153f52de060fbcdf26d90eebdf4ea1e3a6055d1f8079cee005ca7e11d235c2cc420a08d6ed4639ed5a5ca08efe342c3db71c29c47720062abce75bd7a3fad8782644511bf6a8a832b3bc6e383473cd98fdd56461edd9663ea5974e6a5d9aae8d021f7141224faee31d3356c9c9e5e32ec3bda764c4f37294f106912d6199a41fc955ec2dd397b0d3988d218aa42f2ff4c5ed5a8e448b903bb3b212da9466b13df64f0d3d784d3fd7c02ee43b77a4f3e18edb258e77357677b4d16d957d130a6cf5005ca485d6ea4bf08af11781cff7c41a11f1f93f6c466d2c002b8a7a4f5711dc1ab30c8da9e0a6ab52bf85dd6a7bfdbe7b4436fc56a5ffa7d56b6f5e6a8fea0a1fa95653e2d72244e653c8fcbc3903b1587d2d89cd2b8c64b71f3bc0348a315716502b75ebb34a6f168721edac6f64af091fcf44d609ee4a9ca6eb725e8437b240537eaf2a1d41df7f564f4171f91034e8dc95b31f950f317d85c6bc7dce68b5ca164b8f58010a0935bfd7379ca6c674149c17a1f1239c57f94a688278374348cbfe07e5e4f0dfbf202db1515beee571b34ee4f7a475a7635481ec9cf4d56c20cc6d73c9af35ec3ed201df0977c47a84bdcb89e31484c1ed256168c1153319cf816fee6ebbbf70f30c671b79b2cded2524ff0c1e68a7e3fec51bc195324d43dc926c0951390fd458d65ea82c76fc19904f87cd16a8bf71483cdcd16dd3fa05aed3bd19506079c637a453e5276b846d25a3a6010b0c978f03847d6458490979ead5b82a475d3b1ebee775f75a89f024324302792d853f3c58a9130d1995302cb28db07508f41ff9795e4e75378a87343960281fda0c4875ef4543e8ca98c9bcb6e82debdd9f290bc29beb0e7844fc40efff1ae2ca1e4ffc45285c0e8fc7209ea6d3cbacadab72406b49785269b82c1982924750bc9574b675abf66c6fde6c4919acc57a4e169e7923c1b425c88093a37eeb8c8b4d976fd30cce35c68beec52cf169e7aab40d7095c6021e21db79fb69d891a4d99a2c0fd81e57ae31c9940ba4072b1ac891c5f2fa072c6e41b9f3511041d83c35b7a37df81896d512acf1b75280aaa73f69014a8de4ecf3fd2e9f5b5a72979b8d3042a931c604047740291360001c9489a6edb8bec8904d0d7381edfe193e9ae2896863978ba368dc2b470de5fc721a1f6403952523ad7b3218cdaa82504d03d88b941a5b79f36f0d94edbe57f22e095889e25ed42c085726cf59261e34f9025e2cce8853b643a3b8f7455ebb221cc8b03d86035e390a24ab99cfda1a0dc812eeee28817f268f6d470c9646c40e5c1604572da5df2e16bf388b77160d46e01d005547bef56902765caab126d372ce260056f9706d0b9bd99c690ac1a911de9f20701572e63af037be510416549367486975f6ae3508df2730fd0d1023b0000f381c535cbaffc822904241bc2f2ae0b4931ba4fd46c6251c148b781217b9cea958cede3cb1d60815c54369d5c165f5b27a31360a04c35d3b845634f787512357371811e5e5976702c94e312cc80d1a16a313fa7869e2abed5fdbefba28889fd0047b23442fe5365e69922daafa1a48ca8e481e446a1712778ad16cc0554a8ff3cc2db9ad7394861c4abe983d77e89d4b0c65c0177ac665e1e3c61dc0e2a11a3d77e7f90e360c627303802b5574a829dd1c35e7d4d3e3fda23240eaa513d366d7a75c2ff32dc91637efc5d31d5fc3ca7a2fb1a642f8f69e0e0e353112c5b28cec6035e6a3939da920d83cd33b0f7a493cd5b648521d779b1b1ac01ba639075d8be9d65007f494d52a0efd63bd6f64dc5a68876319e9dcbcaa2d18660261334e04ae607d3a3e04087b388074a3c354f111de246c1f957fced1047e698aadd99df2de447c419d3c582d8771cdcbcb18b2a6653694cc6bed3a50245279f94e052a8f2ec4ed8e904337235d4f2dd80672eaa5168fe465fd61deb066f2fe676917778926d9d9ca3d243064a41bd6d809d49c5d560a3ea0c71160eb50b0ca42399af11d18c947a4366e1bbd6f4fc91a3edec3a3f7965573d568b308f988d547579bfb1aa64a13a56cf3fdddb6eb60a3430c7b3bacae9f71a60a820ec5b655df478d77b276807e763ba933dfead4bacfb17ba6af669e238cc4a6a2b3aba97ac5961dcf8344d767db9421555ca82ad39557980670866c20d815a6ed1f7326144ceb0e8cbff0b6ea2385fc0c617886767b2e7b1fed205f6b583dcfffb6f11e1bdbd65b5014055f6b25e3eeba8fe487887a747f61ca645fa41dd876c7581d8ddf83f239d10c7ac33ce0804e7c4a2ac3809aedd18d72f3214594d8fa7bbd9dd9a5d30c8c8f6f0bf8e55a603788115f3eb97843e527e4e71f8a03ea2a87fc33f543ab4428d60078df0b8f1590e6adedfe74c3c9f79de34335b52fb9fc93c71812df5b98234df6e9654d7b117c440d5b1010a637a322955c516b9306da5accde13fa45fb010bce8661d6ffe5b541af8e7fa117b0432787848b13e4c0b5693e5552c35fc3b3117ab36c55b596b05d31d8740178d5f49f4dd52fa078a60c0cb54c2d44a97a2f80a10d5972140990186a757d5a847f8669b4b3eb3d4a282112797824a5e96a2b48d8d01011fbc65a6b9d1df2fe4e51ab0fe171bd2c0cbd0bb99cea03883caedfb1ed4c546310582b1ddb1dfaf6c77429e7cac0ce5c60867ce0bddee3ee6c072a1af75b9c6b35f450ce812dc9eb1072bfb5d9f19b186b3779d0bc6b4cec93449c0d47556f1c199411aae9712c64db5ed240b6ed8170d6e363f486b23ad673a1d110e14b3ef321bb41af9235d2ba5afee213fd81c6cc488fc91a8d19d6d38c671742c6786146de0a56ee170d0b9fc13f1e99cb6420ad4242a71452e802183444df9fb9d35bc76185169580c98836e71b05065985397c90c2a8c5e246f50737bf9eb760006fd774a62a63561d94f76853b56dc64e6ba2ebc0a42aedfe96d039bd5ca27e9ad9d873142b1ea4e74673f42cb7ced14410c57c72db560eb9a88fa1337a330b52185c054a97233c95336b3a0bbe781bec98e3608587016515bbfe9d0b4d7827dcbaa2a66ccf18ecbdd0360400899ad8906b0ab7c4eb1914049f6c951f586b5bffbaa5540fdaedc1ba316c33bf3938d5514020306e9caee9cab84e2fd4ec01683fd01d940ac63bfcfb1dc6f5ff3f1abb85582fcf79ed376093863976634ef4c27cd42d1db1263bdfcfa17b7fa63d49e1f4bb810ec87d50929a2e2b818d05c6744f7c6533c810831811fc7b3c0f788d86503f4b7487c4a6c1d87f9dce2275386070248ea77485cf67ab5e456b2f0a7da011dd0da8d92c3ee3fda9c78cc27ee5341c393ca2b6f4d4644c5a028a8065d1a911f7989405635342e6a21f84406a3597cc28bded89edc7e0adf31bbd220e8852d144f53ed0ba68b1a836e6794a9fcc115d4723d03acb8dda2fdee656bacc17c17b3eb83d258514eac493959328c2ce5cbfceff24cb0c9239962d7c7f640a6e1b958ab8eaf49103b94438ca640c03408e83605e79ea0649e7148b7b0376bcb613ebeb3bbd0eeaaec1c85d111000ba010e422dce228a91a45d9c0b84149100d07ee04e89fb08f87898ab114524b2e82755bf2d9d9c2b089e05d8e59086cc92171b6190294b4001e8cefd02bb8a5d03657bf8f3379f3f76e15bf5d84ee2cbe3e24149b56266ab90f9aeb9b3ed3c83853de355d84d5f0d6acf70e66528240631e0308f5e923659a3e35d647d514b73bcbd94124ffe35ced01d19d2c7996b9e9951903b95d1229e80e250105fec64d1db08bd09c67a79eced72ce87277e3ac41831ec7130beaaedcdf6c4923fc92f7f66c9078d5f3b9b6fb84ba197d047b1387bf486cdfb2e22d87d77aedd147a32e73410cee8c6befa82983bb5d75a2257efe4632c09816268fad1bfca87ccc325672d4b2e74560e264a6a1893fc63058c1cc749e4cbf5d4675725cb63d38490021eb828653373a782add339130c574445c278b40b37594cd61049d0f6e7184f500285d25a91c3a655048c183c175e09a70cc95f468ca91100590b71834ec01496aa9d3f68bbd705e09ee404cb466ac6fd3873016b03cf51134d63585be0ed392b9b546b4239af10d2e7438d086d7aaeeeeca036aece3cb58e11fb37b2f7c5ad842113714b8d375295ab5f55cf3dc9a5a9dea040f2940fbe27ac8b67851e3d97f61287f0ab8fd7705667fd05a5d566d502ef13b3cd3a0a60facf5a83783103d4510350fab4822963d203fa63ca0b53ef9740369a0ebb028f6ddc254c2cd19def06bbf1942bcf897aaf69d993ac191fcac2769489f57fe7ecf931d1d7502ef4751ec77d7b9c426f69e6851f46993f9df1d11046ad3dbc1be67c43bfa74f72dee6ff0bb7d158296ab2ff914c793ae9e9f9f66268610e8768ed14f0ad497fce65eb57a7a9ce454068178616939679740170c65e37818cd16a52d9bb3cce39c9dc65711ed026fbc87001d4cc71a01452fc186f5292ae9ec755a7f3fee43ae904e2c68c0f2bdc8c536f81a9e8d7c4701383155efb961dca4a833598f1142090d320cc2b73f78aa7b599ac2a6df9745a541178be22a03b4138254eb49cb5b2680a8922e827da706f08022fe417427dec9165a182ed118571ab4d392fce911ea7202c6596ae9bff656f49c2a8ead27a9cf0a1ec5316c70c93b711d3ca0cff1f9ceeb19bbce9519383b791d08b853f633e91dc1bf825f57be4b2c99fd6a1b6466df0cfd5afd45595bd4c3acddd8fb5ea5fd6153e50e7463a88a516d7fb18c1b80c08ef57d58a042f780c957b5ece03bc6f41191e028122fb5e15d6522e399f213165568fb4653f68c2b0f2da03f2b23056f4b2349ddb626d7352b9f5e2337375bad7c025682eaabb6878c2028992344091d0ed952842f60de5c2179aa1e2469de41bd56563dcda546ff4bb9dd912c89986096ba483d9bcd9e8a06c72bea2d7feec60fcba5fad0624ca0f5f7eaefc5b9274b73ef006abb62fe98d65d165da542982af3b0a00355cfe32c0a18c362413de4aa2615e6f513b0a67ff5c6f316cf41676a441ed98fbf3453ee8386782016cc5e3218c2598f7e1e3cc0f5a73bcf016139220c7740d31e2ef847d8f2ae7d050e23fa8f4051d6f785ace8773b357ef890e08f17152b4c07169c7210e54912e77ab2cc9ddf7bacd03ae00f7839fe38c72a8ec3040c680c0d26157e8214b78b309473d82fd247ee5bb3f5a1086bf353538b1580b9e34c649a8c2ff77d2e6a2d33a16383357f88fff63b39e2b250db8bb85069ecd8794a414d362fd82c0ccc2f10c87c7a6ad42333a054b63fc648d727649bdd73151c1cb875dfef4285cc2772d4de2e2da9c0513218f35f7812636f6085e9ba2916c1db8823136673559166f076acf77668e9c5cd2e1e63cab28fec4907a3f6797aecc846653453e9149763e5fe221ec3478cb8ade5f56800f5f0d9b1c0e569900d7aff9264471e9c9f8ea9c04c9518539be33c97e9e9c75767afe7c6af7c01d129bcd09c5e3a612a7e40de4d27ef8f3880b1d4cbc6e1320025e8ca4f14f65eae6fad90653d0942269b08aa5eaeb55f516a537ca1c94e59e2323a5b47300c2f8ee9bfe6d88f95d9f88877d0a8854bd2cc8af3c1e27c8b82bfb00b8f7669c8ba552534227620601a5d3a084597cf266484479501ef0cdf8ca38b08ff69e2e7dcc725b7f8ea2b1c18078081aefcdc499179dc03029452e5dad2fd5f598d307976eefa5aa2fa6a7c2f518a7d372cb8aa2f7dca8a5e6a334eea3f93f0bac496a481dea2d1e02b40336bd56b6a48ee47ff0f6e3ea56ea4c53fc624dc01f3d3ea3529c42ad8942fe11c2838393e523acbd89b0795ef86ca6bd7e63eb3bcdb5beff8a0cade37ed15c410aee58bc2a0aa7c52bee112e5be2398212f61be9e185e8c2c69f79f53ccdddefda60478610fd9906f9e88486419034990d50e792134f78a23f9950779573b8c85c0ea54f9748467f1ad8eb18e2dd23d719d5ea4b85d2762c5237fdbb705d34c0a26565bc80cf31ef557d1bfa9b1a0a9a64b5a1059119a8038818872033c6632e7f136a2204a7495bd13e0449691a7cd777206652d04c1a790f4108a0333edd68a9a2c35362b5ae8a67db559c0118b18df5b0b67a81f32b0343a73520f3866b0bb7b247d2b107632cfff2ebbf2b8caa1832e7db639a369e05706fe6e4922b98746fbbc7df93bd523705e32970894be50a767af808c3856ee43b79421c19ecf90ed4d2a188970051a957707d53d248800dce0e3d16a3187cdcb673aec31a6b7276da607b0689c570502af9ab8836bfb3583ec7c78921e769014f0ccbde87241696051d14389fb0871e0ff2618536c6c423c91534c2ecdd0120f6a2ee3eed74314b5addbd51745fec49bcbb93e5318e766349aa723a6abbdfb2a172294c107bed263f7a5edd1b1f56604646ad58a4445c09d7def2cfe2ff9d91a213adfe8f11eac84c35277d52d93e7c3036581f51b03a1fc5eb6d43eb94eb73f3beaa26ada16001d8c0f92b8db8320ba0c70efb1792102430269ba60118df5ad04a41a0940223ad4a728dc8444fb58870e3b92d3f3fa2dd782a029a7c4eb60c3424732873d9dd8faa958eb0e759577d7aa6d2b6bd9b5445397e378f2644953e383780527a3f23afbe5483fd660a3c7aa656435c854f31939808c6a80dd3162873e78167d02b613a8e58aec9182e595c82dd8232dc38e3134261e03d3c33d8d0e03e00d3961a319640e2525e43dcb3e4be96bc0938c319660f6eba96a2ec3fccbdb90546f8fdb82d59f0dd3f531da668b6dab2229c17dff7215b8a7b77043af406a471e4fab39c358503094fa71fa2df79103cbe9d3db478a69fa46b81f4f6a21d742aa03a92a0296987bf24aebcfa03c33769f1e78952dc60619d3ea20ca137bd5815ff83b13abcce6f0fb6203f9232c06cde789f9a8a36799ffca1c85d1211d0cfa71578ded97fd484d8a9ee138ac9a780fb8c87e2d74f226cedd78e41bcd081a7f7056161f9a34b7cae53051e0467f2d556f761962445f25a4ea9c8fc3662b0a4ddb253de5d26c6abca169f86d9e8cdbb394c6a5ddb67d6ee313ec063cb8b95e745069b6e1a32a1de30535d55ff8e9cfe3cfa67ebf1e265db25bc6fe3ab70f2fcfebc4531392b4f325909dae436d007139eb58e0a514fc03d4e203430830aa160b596e3033011b4cd7d6e89b2bcec83f95f8c19d1054146ac697bcf4c9b60023f83007ad5d6b9d2b353e6cb17c29f433fc75e17e191efc6774b49436f06b5e8168f01d733b0f1bd7716f8310e02fa6260e18ad66fd167bf4728dc4892695233dc36185445dbce794ab49e0c734a8bcaf1b25e4b6dee94acb273ffdc80f4a2287c68ecda5cf97951999db4f90a71f545b39a57ecbe6ae9f2da57a4b84f166169c42b5bac04181dd8feaf2ec7b188caf75a7dcaea3a9e9f62075b09db05524448164735ad222571cec0f0199f31cd9af54d9f1de6f45e9a78140a79d1f565b08c0199950862aaa524d8866f615a78f99459cce842edc390e4642989a1172160af245691d93df3a1b7437ab3afe0b929daf6d088765a7242d2e9c3c1f7d826320c5a09cd9f183572d11405343603cf3e3745078da94d029931ea3c37bec2e9edd8d8477fd0adefd15f82392197394fa561b4df550e663cde9de14e54ef062c2b99523248941de5282d69285b4b26ee41b2577145d24341772379fbdfcebf3a8b2c2e4d2d415d69906a19700ca30d4d0ea7146585a3d0c15095e227e7ee6361ec0c89d224c6fa0ad9a4e935c9086c946f45dd2214a53d62f67293abad0335f11f5676dc6e32d579460e28ff03cd55088485827870a44c9cc6fff2ce2f9886d2050e8f463bc8137bad2dc5eadd031dbe8e2e1a7b1d3c5bc8e4a23472a6e7d2ab2f7593dc009f9f9718516715f6c14a4e1ca170efd35b67aeec10bb078501c1dfe3a313bf695747f76e59a27e50ba56104d99dbe95434a9e3b6a67da97a77b5171610cff26a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
