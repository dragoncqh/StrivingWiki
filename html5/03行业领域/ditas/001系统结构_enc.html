<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25b60aead14898461a91547b3e8b81d5c38878f4a225ec6720c254daa48ef3ab3c63d4a6297eaa72e83bc637278a285d8bc1c1143c09ba4276d40ec3f95590ff0e0350e91719eaf756c4718abe7317e1eed578a94b5405c4b7b632388480ae053a1e8d4f7c2d51f4de5c3c5697ee307e26430dcf02b54b86ae259017d2d83fc09ced07129f68ab70b4d98059f6d904a24c59329809a25c0f6f8840912d5bcc68e371044883030e7413158e334d9d8ad2962fadc7cbed0181d29bebc33b21fa6135d5d06f0318a35842e9747eb9633bc83e17ab4582a8492c0169e9e486d8753de7b39d260d758c0b1ef926b9a7c940316ba4ef29f99707876f84fc1f672e98575074526e6bae828781383da861c5949ab166af683e91ab364dbefbab174b57f0a96319134b99b571cbba144b33e19387860183f59dbb44d9012de4fd0576c60b70e83f741f7db2534aabe2c105fded040f6ad707fd667b5b4314be208e9ec41244b3bc505ae9445caa6ac361fccd61a09bb5d03fa97cf7f7698d863faec347710d17d1c200f478dfde7a443c6f5b1d27fdf8d830e92dc4db82a3cc28833d2a7e0d6234f86c026ccd0abf33354675f24463c9e7faac38c097d8ed47442e93caa055c4b8ba9186fb16811bf852931f3570c4565ba2e5e62eab27723cb24c44e753d337c783897d712381298474994ccaa954f2138fe1a2ec6f73c1c064a7e9bc02491b8c50336e5d1a3f7df91ccf3da3adfeb9215877b267de2a83e32bc1c8c970fba8032f3a38bdc9b517add0315ee365d27e9790494510b25e882d17a478380b071404b18bc5984e2318a74d1454577e04b77bd286efff732beb2b594d222a454dacd3c6051151849e611b1c35a5b413e877d3461053fea380362824147e1f6f61f4324a09ad4d15e28a637632ac02e02b699b51be725e48e405fcf53069b1604dd1086dc1d377d6ecb2406727b090941d5c9c3df1596368f9dd7d7263470eba6d0edd11e55b8960fe8f3021886c032b41b36fce079e2564dbabb088402c9c308ccdbc5b11eb09c60b6294e75b5bdeb99d5e35887222931e66cccd242997cb09106e8a6d14489c78a5fb485eac03b280f37efe7901116757484494ffbb2ba7173bcf9d4feb9ac8b7e32dcb178125e014b967ba2732c967697a442fef816f22bee019695e6f145d8d8f7adc26d261212aea74055a4e02dedf8f80d12744a5c05c79dacccf8e1724105808c165ad691bbe7b1c520971c2b223ef6cad7611e575c2f7d004be17e010d4376d3481e8bd6ccbfc5be636f30aeff43197802848f01e2b41945c6f9d21ec42c45a14e23d8a6f7a7e200439fbdd3ebaf9fd3e00f89e1e9417c92fbd0b0a3b98b2cdc2b558e849734c6a66c7b6e3e4c234d23acf4ef98438436d07051ffd8689048a353dd3008fc428f736a282f1cd81435ab7201113e4c26ff83eff16bdd717f319491a6d35ca9fb20cc444d5626f922403a300df5676350fdbed952887110e1a4e9d01eda1cba5aca2ba4f624dd4cdd39b54ac9e7ec180d654309f8520aeeeb3f37fd59d79671a464b64d35146554977cf76a19f87a1f32849f0b8b8ef3ad10a77e51d61a445a880c3a46fda5e980eafc800f4bad85cfc73c272ba5c9d7b0146b4d4e07cbc62091d45ebb54e2696f0e40f3bc3b9197e31deacd7df6b08135e8427a401ed635dbf75497198eb311a0f20e89e9f70a6503223d605db803a0e6bc38e88314052b0f1b908123b4f0dadd01cc46f0fe931634462908b3a1b4b478460994ead570d630584fa3ca229548bea5ee3a17906f451e112d3227f2dbb0f6b1f02a91fdf60ae513dfe30d9c2cf7cf351ffe9b7d715bd633f0c9d43ebba4894ed24d074da6447dcdb853c93513511ee97983efe1e8b54fa9c339ca26350623cd1ae1479b7fd5f15ddb29654492ddf0be05a5331128e5836746c213ebbf3560e8697dc408be515c276bf98a572bc0c3c555ce06ba6dc47093d38f23a5ddf0a802bcf1a56d0432e51a6e85b4ee77ec7ec97576eae8516b9c3600cc1f9301a8eb4ba1c60b7e97e35f70252388026cf4b6be5fb26694b263da7b08fa2fa966d7a983b6d5a491589fd09f712977c666884b4b7bd9d1e2888c42789c8800ea96981011a54ad39a4d28cd65603f633ae36a01686dd714b89ce173b5896eabc1341cf10d37de03104ed6f57914701c5310f9e8dbb49c0538e8de596a05c3a593be3f334d555f3d942f0eeeea90ad74035b1a7c0e3d41fe1d4b5b8304b9d4eabe20fd5a4523125f6b29c8475b1fa79315d2fbc9e8beed51ec491ad9f933ba4b073fa9fc9e19673ed88fb2ea4d5afdd31821b4fca6e9fe5f3275f58ba570ce35d688671591eec114bcf46a98f81d2489ec8fbc05fcc94b2d9ee39d07e50dcca9f57a6339142935b8ee230cbf31cd9c170236b8ec0c249abfbed1eaef91b5558b12b8e26145568ac5855a284bd933572811aef2b269400611b8aed2a47c8cfcc2cbd7d635015566885ea710ea7d36815ed83d45b653517ba6e57db24d19ec5f46aff01075346c9161655705c08663dd14e4556df6e1dba0bb12484544cf929b6a7041347f371a6b4b868353900c418ecc55249a2b41572c2fe87c72a4e315a3924e3c2d0f64a9622389a8f6eb3bbe43a5863cca613cb1e0a7b0c5c8d4ea81ac721c2074072e45da4f7f5b2089c51ded486279d65c187953be898f485f2a106da8d204c713f66b9ec69332716cebee4d2c56b1cfc921db36ad8b66c2b57cc78febca5c0315399a3d93fb1e0621caf0d75482d4ae56423e867edd0b4e5ec26c1c0220d859ec6e68db5487633fed8dc3baed5c11c011c14010d8c6ec72c4d791ec8c32d33486a8e442e6f6c8f2a0c9661b9bef1e4cffb583fde8073d627b3e6eff119b980d1d20c9fc80a706012031a2028cacb7ce1731400b8be662f58658c9196bcc1eb46e315c4c4252693d832f248ee8d5f8ad2cddca19adbfca3920e62ab6ac42a27a1e03843efac410c2dd27e6babd3685023aa8ca707b36581b81cf7f8f70f01ec2d883300bb16fed7af05da4414d52b71f36e2befe3aaa2cd45e9729298e299c7c8acbbb60f755e3bc8d07f2a340603215f4961e05841831515f901ee87cc6cd09d9f203808f75c5611a33c7faef23bf48b61ca95ecc6a614dea7abedd2f5d6fa915fc7c38ba948abb72d5c7fb17db7b978591ec37b591b1240ce4715e1d4a333a43260176190451152099acb64cd0429750f77971f228d1106e7b447f3a3fb4b5c24dcc5505c98c28b9996664a20a6789e35c62ca30fbfbac73dcbbadf23e4e52908fec52ec8b4de69d4767a74145dcf1231859fb5807a2083bd03159bad239927eb74fa5ccfd035f11baf16f595c947a0b8407c042d1d835bdc79a6aa7bf4d4fbcf267872b855b9b93408e5cafd71e52f1c8c1dfdacbc2970190ee3e4e1006f8ab14d60dfe27f0ebf449d83ba2c6110571cd3b3eec834a14a3a742368a665f70a5394ab2d605096c712912a2a9a7e327c10e3e80cfee3b80fed66248ebd93da4e19f3968d4acd749e70250cfabf4cac822321324187ef86a57fe0e8e241a3b711cede2f9137b0e7594b2650b44d9966609b9fd5a8a893f93e45d4b7512608b0d24b3c728e3db8522fd315406c39f2d2a1b8cf80830a6216c53448f8a54691f03b63c91dfc593505a0de3f20df9efdddb5a39f9534867fd1c334965470b3217970dd48d53cbd31566e2b6c674da626e6010919269a2339447a714034372c1ef153e043050b2faefa71f5129f7db53f58bfd7d52f520d7690e36245ec8099dc8c313cd13c33166a8c0a8871076b994f07519e15de7d2b1d36cdd107a9990815576942af0e4ce6cfc96079382176a8518d44a131d95ed6f4f5254d95387f44b0b55226d625d71413ec35a2f58b54bea465288f5cc5bda3486926bae13d1f6f91c812c2eb79a4c06e20430016d6511b82307f07bcc4f80f8fdd0b161b8706b36aa47f16c547a859753f5a486be78e4809a0f5e9f4c4f011d8b52ccb40e433da2dd9c9408ebc40af9c1453b4363f350d22a7f599136f7d2fa68db01ddaebfed160c8f5813cc0017132bab1eb86c94b0dc2bd458a3926d7a36a830b346cd1cda9213084dfb84c1a44f0ee138b9d5eba88225479b9da90b593f1d81bc63f9970bdf6f6ceeb905c42104119078e4b8184a59ed3032424f958dcf15bc8b86f956a0046f41bdd8e39a2b4f9e994e74c08d69da84cf40dfe6142a5b29a4ceae3fc6835eb5a71b869d8bfb51264fbbee40034c3e3cf340cc3bf628450dff1a505b2dbc86ee14a6894d933fee9023354174d5f0d2295af05c972595597f8f376d27910370d5cc9251b9b67d2b5a19ced7728de8c42ae3eab44d4d84f338370cd03f143e176284e26a7f673058a8b5b1f3f00072fe24487bb4229a575425c80cd0c374eaa511b56fa95316c48ce000770238a179ba91ac3ad7a13686323a9eb841e5d5b980fb364ff8cd3608b17e90707e985a547fa127e564cafbbba7a03d2c2f329c58d673c90e84627a664b46d1eca16faf430f70c036daeea624a1e7625a623116a3ec3eaaa7a6c6c89b8201f1031a44b8b7f8c29b10f3a408b74a282230fa8aab1e82ba6967677379cab0b795170957620b0ad03363427433abd376db7570214e13454d01f7d9ddad0af5fc08c3b77103e81358069e6d874288ec47257631bd8b1cdcbd471448b91ff990331f7c294f7c09f7d4cc10dc83ee32e838ad526a5fdf195638f4bdb5068ed2b17d0e473712584f98cb3a3ed6e916be443c24c380085a57b52599f1506db11bc8aae283e66910d21a6e1106376c40e9248b944e936cbd7176abb6dee64814d97e3f32a1ecad2314688f8707395f62fdcc143328f6506f711652f3eb390fea75c465a90dccb9ee0eae1d9d63ca4164e9e29cfa00b0483326e7b9abf5820b7520dd30aae8784d7df8fc3808a1d2978e1e702e154a3fa47bdc9d01d4fa53656c32178287ab440a1acdbd727e41c8f26f2cac7372bb2be5d0fb97d02540cc4e898c5a56b2bd16d397d9593e83deedaa2988a856925a8f2604ecdf46b06ff0ea9b6f44a228152e6e320e4c1065ba758a34abcdd763c44b6f2d14d6069cc0ab19123231ee19992b900c934c1770f9a9c27ba8fd52f7011e3e25df0a856f73538bb399ec8cfe3b5c64e8824dcf2e8ba4043e7e6561eb7e11670543e622e47ea56692ad5eac514870099393e9e2240e375fa944150cd6d1a4a6163cebaa1f0e1ecc87a39c315ea40a915d0c845de2beb7447097258ee3520e91f2836db4705829bf51ab48dfcfe9e5036a1120e553f22af68c3ab42ff92df8e5a4963a5a9bc932557349abdc5d4006a90c450027cb074c6dcdd93a7575aed4ca9e8a14155320eea8c4f4510486a8f61738dc63d3e369b9e8d800512cea9e25498c5a74baf969bc560d2d7e2b1237dae252e477eefbe5344c5c7302022d9a415535a872fbb97a23c3ca6c0d72709e803dd5acc6d26b78b3d998eab8e3cc98591335511aec02697efe7408eebedbfa7311303dcea96bd1e40c89822f48263151cd9a389ac23fef3e74b08d9bdfe2fc184b7a7a94e1374a4cec0157f94aaaf5f14d867a006f019353d77cd00ff96b7ed9787d37c0436237fa60ecabc387b6a7f10d0331ee41088aa7c6ee869168ff03f8fcd408458c0833637ddc44b6eca01bc709abe895beb7f51f6cf39e3096bbae1abbc685c0e3f026f1bd67c1d6b80bc4ae2d5b240175538511c776a29e4228aebef2b653d123abc94346057bd098815f203b5ae4630a450cc719abb4b8fbe8a4e18228f6dfd1bac09ba00d5ec0dc945c15e1991b4b2abb976f5b2de3145480bf24ffa02e7ab0c4fe6334a7cefd3412d4bf2cf9f725da81e970e20a0281558b5ee998b5a3b35bdb21f53d8576e2e8287e6d6518305229d9c995f299708d96f6d82a176fb41b585c6bccdce6c87cf4bab2829c7b77edacd3e29f01ecec0d738e13da5422b1eccbf6d4232e250810cdac1bf4ff09b03929cfd2dfd2dfe33aeadd23409ba19dbffc191a7a9a8f3e378d7d4971b438cdecd000b4571be75c11a4ba841306df42ac6c46d312ecaae45dba4dbf104f894dca1c1a4548ce402e150d68b7dad5c7729d2736c88d06ada7fda4a90f433cdeb496fa9e8623d6b4c813c6ce6b453aa2414eefe8fdaadf4fcc749f7d292826d5a7f8a89fed048d431eb4fc3968884422733775d7c2da1e6afe4f07a32400548a0d22fd78043bd85994186da14a46924770e41cce9053f7430ea1d829a24b7fa9831ccf356ecd7ede095b67bcd8809f1a1b7c454dc0faa2c55ede769b89f7a280022ed6ac4e03f2ad5bc82b8204d0659edead75e98954de1c1f803b93006c51c0281d506f0f49df3660670e1c1027ef5685f21e9541add28d1eae39366831647e26064e5f9ff38ea36d0ead39ebf5adc9da2103ba562e399fc3758452519b84eea7f21df8ff1d5d49912379e1a85188b73ec319a5e0a6879cbe6367f82e9a6d1077f508cf33e83f535ffe6b0c3150f02d1a75efa83354387fbfac728e4b5de5b1449049bcfb12b003b5d688e0ef4b38a8c3d942ef6d901f156f1020e128a306e4544bcc16d02924e477b340c34b3e3ad188e8fc7bb865cfc0fd41404065db7efcc4c2267c9571e410a252bdfcc616f8e9ef7b7a723f0440a6b813fd0c17175b3866e29cb69291fdc1ba0fe8b65181458ec38269e3540a28124aad99035a676b5788dcc2ef453fc66b51cb322281ed79d8a41adc6f3844e91cbf587baf89f6810498124b1dfefdbe9c2ba71ddaa5d1d2f1425b63f2b24965c231bb5e15d55228738ba6ec558b768986033aea97e469e76efe3ec725a61bc3b46d2d3c46e1ec5413d048be86a82def70b74d18206f2d80c50fb88d63628672d1600ebe9b1513043a1758c00e607ba723f13be6c06f830df6164f0f172454076b401700ea32b8c1b3dda17110afbcf08dfc7c1c3f2fcdebba8069ba10bb3d84b441868e901209156d648c525c0fde051c3d00501bb166259e0e7958ccf39e831c5f961a4c9791821b3ca763f943d8e0f8b043376c530e5a39f55ff621073a74639246f8d6c3897f0c1da0ab5f71954991daf705aa9ad501190cc4fa5dfa5007ae9eec6c782badd4a2b671c88a46ac8a329980ca399ca0d2e80c24fe8508134bb81d1b0cc0ea42218098bf874ba2640a6ff5f988458de1f6b69b5232e7afb0e97727a27e713b833ecb58324a1ef7f8c7def9b64e42cc4a57482ed66c01052d67d2923127eae1d1fc2e37b607c932b459514a35448093c3bf522b474e9c99af12d6f34b66c0050324e379b14499af5b314287ddc5118559a12b90e2b7a0a9b85615432dbe1b97f01e9eb28f94591cc84465a35d8fb5014a552fed54ee2b3b6a22f09f28ef1fdf03b190f6156035861eab9f7e10294a40f68497add3480f6854af23d77e0812be9617de0e93bb9c922a3820ee41433e2904e637c00373720e6edc24f8489b35ed01d4ab4f55c58cd113a3eaa5a800309d9cf258c69de83942fc757112ea5dcc1e7f64d3771d6f0703541f1979de8685c7bd29d02976c2bbd06bf8a796fb969a702ae98ee01d03fe9bc13036acf6cf29495af4e75ccaf1e7d352a1dc095d4ad9c64f0ed812a05c589218dbcdfd3fc7e76eeaa7086b227548f7ed75c60c764097e66aa3d6034cce00c4eef1efb88b46dbd7e1dcd10bdba0f4b93fed371b907b2e87a7d38c11169dd737532420c9a4c912c081594b3dad40c867211f4f03f033cb3a7871baf761523bcc54fd37b5bb671f8a2d498adb58c03963120e1ff71b165d398070920bac4d551ffe8c0b94707d64f4fe43ae21e53d8861d6751a5ed83d2537c656a6adc925091662dcb3aa3402a0815e750f356462b4a0e1b5df13f774e8a943e67979759122c731b892583121ef004807f968cfea782460f11cb6992331e2aa9a5a7c64b736c8256cc1432d3c2c6c9575ada080e7b50e02feb1cbf3ebc6eeb229fb96af2e44dd4883c180380fc63843458bd19be6270a9f18ef1d41f53557953080d34c1f5e4020484f301ddad435b53767a8016cb020201a0db0e41ba24c205c7919bb71b158e4d6e70aa4b954387e546ee96cefaa99c828030216667336d016359cc475bf6e7163cbfcdc0b3d444381052a6a8816d4f25e2ec0407453eaf9d5c0dea6ae21b0b501516e22106f40ea80259adc6f27b4544c72b696cef5aa977d49ad87eb71478e66e5902f5ada5d913c33e4fdf062cf8ba759701ad8fac32de840399a511275174e8c631bfc0ba791365249d599ad216631976aa8444181544f82fcb30e1817d3d48e380a53a59b73ac1eb5238648c6261dc2c3287c8b5e467804bf1886574d8c6ef1cea223e0204e480b105c5e488d52ba62fdc371a11533d062a05f85f6a27655fecc3e6108bbad67d186f48a4ee51a4405a1b6c0215cf5a65c5f5e442d01a093bb5e66c8d9f1d323092c36d7aad081cfc2eaf95ae312f9b070b4ca31924cb790f0fbd27f50c7724afc5f78d4ca46589d00cea833e09fb2c92d20191961e35e76bd0a7f181248a1c45ce23c25a640701f611cb42e6498295b9ed45b4faaeca8c8a1a736e134ee77e9412147a424f202c71226f2dd3d041f0da49a530de8602a9f16f7896fc86f24fcdbbce5371a2441aff06ac646efa8bb3525aaa609b69fc75d33124d91d91a78b8a61a75cc8a5439318aad64b8aab61590d60445a318a97bd871a3695bb0744f715c234f4d19f0b33e9a5a3dad870ff877130a8bffe0a8b702614782186c5da6397486e73a5c80814b584318239ccbc9e7d35a06e7bbf31dfcc729777a408b6a22b7da7718aeb8874dfade1c4c034738b6fc437ede5e3085b9cbca5e208e051c09ff4ad1d57c1c51b79ecc5e3663755dca84076e73dfd9321f24d3e0fbfc0597024a4a5d24594fde396e9cf7db3634d0acfd363710c93ec2aa5efc0a6422272725e3e0053c0b00dc5844e89ec3998485e373a6e68ef2d593224fa402eab02be63006344e488d6e67e73303885b543a21e26e756c8ff802a4df352e0c85d43a9fafe79535066edeb3b35c5dfa6161232d0c3d361535f004df0a2d799d06a8181e033a874ecbd5583fabdb276f2a813dfda187861a246eec39715e486573dec849cd6c747f7257adf49070c9e22217c27c8adb3683b0f85ac8a0f3e03ebeecce0bf24aa2afe4a37a8492b5125a69cd16be056144c9b277d9f19cad9ad77fa73c9fb9bac16e12046c266045135048e865a08ffb7ed19b89dbb3378b9b9afc159c1da008c129c6633bce34a1a125635bf5e2cd2f2983cf63a11c262c895f2d7fea9de81dcb9885f1bb818bae8cd7190b2e8bef3f62c001d9ba4eb19dc536865709bf2e7251127457ff7a951a79b7e28229b365dce2af4a199c82f50defa0788216549c8b27d2387f12adcd6076042a0a24fc5f9a737c5be1952dab44a52c30496a1ede677ca43dea9ed631ab133be84cc14409b9f6d12954a75ae5d76932cec92a6da72089656956c82f896b6445b62443960129659ef5ee0afc05058d4ec87dc2877727b81e787c33489f8a1a642475f5d182c442cfa1033c2dede071ad36a6f34ace30b6222b6909a77a48a992e6609daa9927bd71d593b690953a2cc4d007921c333acd6e3ecbd17a5707dc8f62e9f295bed2d84428c135b425954a1fd8967e49c9c098f518b6d12773b7c9e7a4d10fdef26db43e218923b15fbe87fbc7f76913425539651670792558a087165a21a025529198e7793e7f44293f025333538164ecd7b829af80aaa35abafa44233f769a4ec6ff18dfca3b6e73bc1586038853daeca7880bbf8bdf2a8d00ae638039c0232c6623616a1e5837bfcb2ccbdd85eb1f8f57b706643db1c08d00a372a4dcf62289d3861caca0360dc8f50fc79b6b210bacfb61f974c168d91536feb77a04a055e5ad1927716ca71c135994be15962a34e07fc999cd5809b2483d18dc4a78fd94ff897742b39fade407b9dd8946319f5ecb5626ce0964b908be045464b76e94eba3a38e65c297bca81e0a019402dbeb1bea9f506efc2327e2451a758d9e5bd450406a878c82a8cb123e2a4f616d2f45ecfb51736f07e70f5b165f156f5266ff67485e358e37ae2d36444bb674a86641ca2955fb4adcc9095dc60e03574c951591df84976b965b8d90647319c75788e8859be1ee41a138d9d40de2a1854e84ea783015365b5d1ead5469285d410e9c79db1394a715d9a5dcdd5d379c7218ee93a32d216fa888e587d51ea02ff3796afdf73565c3102bdc14127831e927378dd47713bc9aa30b0fcf4d83bdc1fcbcd14bb44aa1ea0079bf28c80b9b991595a58881add71450024ab476e25d7b071b98f6edcc2af948bc963dc2b0338c1725ea22288527fa3fd0e075d5a3152f261180038f12c3ddabf095d0ca29e21f1839028de21f653c6cac415e2a29b69ad1182412d10d0b0d08478a955d61fd90211fdb1203aa30611f335f788d7979793e09d403f9df7218597dd82b908884f69a546f1ceb21165eaf8e3812e1d73f386338a76087961e0c5758a80e0532b7a2deaf9ea14a3be172a3b21225698f14b3b27fbade2977220708220b06db291bcb7345f2a3721537c530aff01baa80208b037cf5da60ce80fd56385bd41642001d79ff2f52c7f5635c55a045023de46f3eb45a11027859c70c62c577034d19db527d5e10d78b1663198c7bf564abafdfd8e9e4f55cf36cf86085a426f0ee2857e1ef1f1ffb299638a9ccbe55844b4d0cd73650d96950b830b8f9e74a6b079004e938d7b19440de120cbf0578149dc94ccb4e318f67aba5fb964af863d284d7478ded22b5176931b2e694d7c029b49cffb03efc58549c49fa55f9ff43214a7dac7558608ec17f5d3f7e8e4daa522105062276c45fd0fa06ad2407bd3b7b91b9e930a03441b267af166e0bf2bc6fb4af7f557080e94ac8cf68cdd5c34de3849f582263bea0c36388c36d3340e20815807820605c8f4da25cf9b19ccd6e1e648360984808ae22adbc7c6327a34cf17e5b1e18e3445eaefe1da202840dfebc97bc8ee70f653b27693d7a1576489198cbafaa58ee7c70d0c3334159f0cb027d818612a535320196e5809c16b014729f9b9f05d3633cf024b167078cb1e53b5e7a52d4e77ecbba0f6db4697ccd94eaab791d93e37cd8d67843e2cbea74985c62c62ff38115b77eb108f0ce336ba36ff4f3651f10383016a41c135d4c1c60997c0fee9f700ccae9901f3785ac57364be14d917f97c038c241e8dad11732b3d374ba434661d56e86edf684999550bcc2d2afc670053cd64a1096a9f4f00023e2b65a0a92a36337a90559e43ba5b0a8a40a79f6334d963eb0809a65999cf23ab68c6a8cadc462beeef32a43d170867701905489491f0a8dbab446c3bcc1fa4d7045c4919d076d712ceea28eeb63c125075342b5bb0f0f98e182600d1eea846b7f1316389d16055288dbad6d74abc6e11bb5d96a8a9671ac8ded7588f2e2fb30dab59d060de25e2388a8b691efa934322ae1ad355aea5b3ba2d3441e1a12b28bec4addf0059e6769d50ed7b1bb364551289399db20dc1db55195d9619ed1cf94316e077745f8fe9bfcc0c0374f0ba5ed9f54c2131eb240ee094e7a26aa9c89f482748b1f10622009355916e990e7392b449a3443cd510aa3aa8e82ad256f42fa1113e86ca454add47c4bbc6ec910e2d20dee4e443e4ff8f82a4e3d52d585b8acd43c5b6435a3918372a6fb2e5f870ad19e9ebfd3c26fce004f0e20b6fbfca276ab78de79009755502aa2bb29a7aedebc1d31651a0ca78b64dca7d0dd639a0dd0c9ecdb1cd7662e4578a99b0c509b9954c97f765ea59f1c6d6ad97189c19fbf3dbc10f4c914cd9e533ae0107d45743741012097197d29171958cb9cd96c27f493fa59c05e17235e59f9c48eddbad0bcfdb944cb5e4e48ad35976876cdebb052ca179831ad87d757f29f438ec37d562476e834acb9905b5ebdc4381073e78bb750ee0958746beb04cae26c89c764419584ccb658b203aec302831ae5c5cac55d1a9b415982f262a4857a5c39b713a724a6db2c7584b4c734fa0596a8566574a62a17b3eabfb58b53b00d3587444f3bb973dad7cf62b1e7e9590a0167b34c97cfe0f434601cfd8fff57a7ad3bea3a09bd87c1717e3a3aef3dcc4d1970fde5ce5e7b49ebb0f0485678c53042ed888ba617a6af0a2982481743d1c133bff7c740eccd2b39720930274a88ef18daa5a090d3b88c783b0d65aa83d08cc496ea98f296b57e96df0ddb63321d72e7e2e45bf0d72fb65ce0192603aed184d5437c225c28c4fd05ba4de3800dff19bda07583e6e4623b647be30918937fd979e215fbeec61e7a11b14294229d9a362817167f84f0ea28808de397d6eefe14b0ef2a30c1c9e38a310eb899d5eb22c6733b6eac42be31c9e992536db1f76e7680fecc08859be6eb19fb70bf8697c17517054373502111cbfbc35e3b06115a57790609855283be691e05e41e010d2dbe5e2b0ff32ca0234d01e05ec47744481cadbfa7add0d1feeae02a6cb03b567b3342d04aefae6d81d6e4fa4116309b02763727ed0527581b687dac19eb929e4d093d90d4df9f16c05ec1bd6528b7e97ce6e2443559f3deb0721a79146d74ae5092fd8bc5a02f1d1a34cb5b1ff92fa664dc10523f913d4daa3f51c13c2a014d2bf281ec9079a57817323070b72ebf4dcf228774e90d5cec94a6cdc156bbe2044afb2661f3de5aff96b60893a2006bcc87af5606b9bd8d24b22507fd991c61641dd395580a4c5bdf19f255cc04c5ddcacf39b92f3c7553c649ffa01824ee6c2e9ca39b9a99c8ec504f2d825ffc463ac720ffa3cc7118ee3be138c2b18a3d3af3effd544d74cf2a0dd85ca07b3b41a647ed349e8fd7e6bee933649b0a9e0a40dbfebf615bca5b5c5175034ee53226e397f33cce9d417d6866beeaed9e132f92795da51581a1bd8bcdfa8f435897089d15ed1e6f5fd0ebc4d9018a94964f94f085e10c73afe959eef0600dbe1fb8b41d12db7e6401ac4535f7ce1d6adba9ec9b346588de18c39a577338b45cee18f70a60be214852f8d24eb4319583962d6396fa405826b08a9495b2a2963743117bc3d1864f1dff168575dadce864ae1b951f5c5e9388d0597e2cd5c8b3bb01eea920ef7baab914dc14e2e5302fd2159515501623571d15984eb403ec3f1390533a8685b454144632fd61d1617db1ccdf5bfa1b3e5b1ce99efce3c12b9d81d946f64ea7a5d609ed7db94a2c4a81826da8b49859e03540f96caf3e4ca03793e2e83f02c309d24cb0fbdd8c36574293c8817c5fa3b8a7b6c1b3f81eb288a75f50be84c58e7014a97b0dcde83f74712ef253457f59594f22ba1fff9411984f971d2b2b57f2ef8ab35d40d0711b8242c688757e84fd44ddc8efe4788a429ca36b1fb79e5e66c8e7885115a626a7caef6b15645750f3fc05e26848532315610cc39a129292fb26dea009e58d81bfd279009e1b6cf07f40da3b3348f774b8cdbdd89a6e2012f4e886dfdcb4f78c6be3a55cb1be2d0550d2d324abb86d96801fc8e536890a5107c72f64723efa3f93050a492231cd14c40dc9dd305c371cb5cd52ed5d9364faa691777afc2c08ff42b615b4e027f135221d6729b301ffb207fe8a98363d89e2c0f7ada09a3e6728e9bd6c0c20549ede245c4deacb0837bc0b190ed03c306d6cbfb8f275e097ddc5ff1c1c66d6a103624de31f5475851c48f66ba1c7fc4a68de2f31d867d46371d14f09a37abb13fee35dfd35faf0a8d04787feb19a5542c84c81d94a4c73b9484c762f36853c840dd001c973d33caa0b76464c80919654969a93050266b0469ddd4295ea50729b4e5a264bf1611c0ac76321375f4767723a6ba02aef1b8ed0ec140e9ff74c63e55a45cf488cc7546c3470c36344311691352075212cf1ec2372b0b7c99daae69a76863a777a4979c248c60429e3f16e1bb29226dc843060a6e073d4b3e79fbf40ad2ff69efebe32ebf37b92673d4b0aa757264983db502622083c3ff66956b960c521e40bde6334b5f45af6997306ed8ab261eaab528ba1a0b8ae5c93754539959ab99e6c814e2b52d3424cbfb79ba0593ae74805052ae42038034d20590dc847621969e4d6702e86fd30237f94856055c91f5e3a4f988f4db9be9fa8dfcc55c7bea8acf574b34147f55bdc251e173ff5e2ec00324fc8961dfbdb96fd16b9e88d58c3b4dec44ae42841e29f3b11597d4fdb6b64ddb4f8a723d4b428f95f96bd55a264adeee18be891e4600c3328189ede669790363d776a1d469b1b27bf39d7131b9b0ce8a404f7fef3dee05348b8b3a27db6f3f41f511f77e9e1a29acb02380259236aaa289d9fc3cddbe27b591699fa12171b024f57f2c7da73f09a69f309a7f9418ef213ad8f3849ccb34f02008144095144b836af224cf9c0b77c1a8492d9e0d3951d4c897d45d12ff506f34348adecb35352c8c346a572ba710bbfd68e8d02679fd88b6a998e4e9f6ab38c901da79ecbd878ea6dc255ba5de5f3f5945db770553cb0699a1cc087edf169f50678f60abb0f7fc92ed8e8839c0fe158f58ced4bf6a0a427583a62897cf56d5a3b6a6acc06e0d746165263836f0cfa0ddb7f7f2e300b999f293d7501b7da3414961080ebedcbaf8073cd3ac8dd4efd8d2b536387f8220cd338afc9ce37593b901e60f2ad55690cb604dc21c23bb256607831ace7f31aa41aed256b0bfaae5a170ce8cde07659c8a42679d265d3a3269edb8d882fe160d3dbe61a97c786be8fa94b7aa6749304cf62529a7e4d2791f8e6ea4e2bde4fc6b9f4cdcceb1d275c5c123cd9455afcc673b9ea8519584896d551ac57fc10466bdbba786ec7d0d1aa5c4c314916f3d93767e9c1226608cb664c8aa769e6c75186b681274467acb8d6d7652529054d28ad3dd4324ad9b8cd6bfe57eed01ddb6b3386d8fdd8e14831e07aa558b82862ee7abf81094b4729b28ae931a4708c374de1e4a87fb72568cc32351a8314640d80725ee8542883861a65bd3b3d5baa0dff9ce1d9f7c084fdef372fbe43cf3187417db7ac906b6a263370d6b8d12a3af540cb9253bf323562db3fa1460d692dce976e7bda2e0677fe6fdcd5eab77883a5711b84dce70a1338aa4eaafa03d1e1e3608574b7aee90b4992332efd04e8eaaebc1e8c64e36f20b0abba4b67e3dfbfbf821a52a6335bbaf66a8561eb3ddcf6337fdb6f5f43bbad91f2bf3f3f40b12aa097fc79225cd185d5e8d48db2d450cab9da834c068785c37996fe161e808f06d0bb20c4ba55a9d3ad65c590765daa7f298fa09ffd212e53e0fccd9185f107e94c180b25475a11cc320e43c038b8e954b90a8911be2b844f414425657635492bbb7de97522b4dbb679f77d3b80c597fcfc610460b27436e1e85aab649366d923cae56345e8f5caec399f69926407614a5fe997a31d90456a96fb67402f598b14c5add650dca2899b268c59d565faf1b33c2f8cd84c45456fba9a00cdea4ffea456b866104a81409c8ed009ec2b8277347bf77856135cdb9d7c50b00dd92a258b36c52c1feaa7e29dbd76e46a7d2eec854df13b55db97c782a667e65819191c74b70701dfa4bfefee514e0d86056e884623ab4e385ce0a803bc228da5038a71c47078dca722cd8728d110ec16bd80ac06c5e76300276ca9e4ec6cce5bbf02b74f56639821e0c9f88e7207adcc6239509dcf71a001b0c5df849880ed481b25c02dfd4044981b0b3ef2969d53f42285375001a2eef708b1047f233f3aaabcc9b0c9f29f0049da954014e3991c55879f7142247ef123d9e4d6a1088bbd53ff2d31f5829ecb504cfc859c102e49267d74dd0e79ed457fbe2a00e1ca78fb7fe74c3e7554f9278cccf56b961b4e5dc515158566de2ce221524a9b841ae9623c9aaf5e97e130ec387963be459cc54934fdac2fd94ce12c0259f4c77e52bb150899f5d2d0dfebfc254547973e9472f2cc660d2ed5a413dbcd22ac6ab296ea30349b82998ee0eee3b9b73baaa360b15eaeea55dd279c2f8299b9aa55a9517fcad723cdb08bd3ef2ad26e70d82b9cf660f27b139b0a2d65c3041f001ae17abeda13fb706b9a30dcb84f9b64dee4215c360cc7fb1930798b34693ee6a6db0f94ade9d3890827e2232b536b5ed997c60dc2128fcc94e9fc6a4e9039f798ddc4308f99f1d9d946da5ee96ff927108795168c253ecc221e6aad1224de2bb9339f00afd08eb3190a817ea68f40850428822fb4ce20755c62198b60178c9da166929429532d31ff2b0d62e250bf386568f954007d1e00bd42c786542a2303226d9fd93347af0f17d21aa815a6c76f1e549c40daa6e39eafc32a80ef3a9b652cf9b98d76c2f60b08659bc448743f42c32c72d2e80fe08ed0c6a8d98763a704d6396626964e3ccfa4766647312cdc5469ec830d22151565f992d71ab1ff61943db60310081d4eec41218c9c280ac735809d83024063d34048f0b9e474c01360395e1ba688810914078576a0cfc84727e48d69ca374abf57ba12580cd2be905209ea053f78c3821910f7dc5aa1ee964023240c8f8d4bd426df18e8cc8297e0afe4704bf1c5851efe8fa6e660632380d0cfb8b9f5067c133cda630a7489cef5ef46c211b260d03139d4e681aeff088aaacbeaa0c5a911e3b3b805d91cee871bc642153fec10b19c3608afe913ee521f65d251a2831ecd4fd52076187dc2581e06ab6aa8a00e28cb18b7e3a8f43754326a92eacfcc3e8ed8c673e8cf1849935dd1dfd698bf9546447827ffab93f83877b4b158ff475d916459254145ed7fc5b721ae968216eaa5d160cf082ab557a04c788dc656d37122ddea973be58973565b5f2c30195709dc7d0424c31fbc0b4d29b54665935d851d900c7e414bc37e07d682f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
