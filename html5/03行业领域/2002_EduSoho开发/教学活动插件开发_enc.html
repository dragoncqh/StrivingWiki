<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2a82fca0e1847c4f325fea1e8cb29780d2ed6264f6accf22f37347b0266a8f8189e43a61a1dc1bda34a46d6e655a6b77c6ea5322ef0e57a48459230a7b4a0400c34caaab1e19344848fd2e726eee3e9fea9548f053d6e1dcb4bff66e3cf89c82846aa99dbe1913815e14efbcdd3172824ecf24ba0e2719434a8119c946ca40000a507d0d297034cd81a4106f3371b16a9bfc1fd22d6b354754abc809012330f6287f92ef7f87aa3871cd8d26f6fcf476e7a3fd3b63d1b42964a3484f532e7f9fd5c897a7dd25a68cd4829d906b55c78d676dcdceb0a07e7181b0fe9b57211332deeb6635a8e1e341d71d10eff404c9e8a3fbdf5663911e4886db40b2056e35cb42cfa290ff71235a667f1dd2cb914b65e6b5ebee33330b46250ff958e45dea3bfaeec0019659f357b2aeea425784877a649731490f874226baa79e36309bc47868a0187a9716699020d158f94c5563f439b2ad784d255db124ead57e5ad13a51e90d7494cf14bc0f40638ac835848e4308a8da8993a42cc8ac14a44ad311e8a5b647c51a2532358aa0cc93957f7a9e6f5dbec812c9fa72fb06a2a6332384412ef61638c98dd05e68109584df56216d1105f677dfd4352037d7fc515d004e148965423c9e101f9696ec66aa17b19fca764767057bb312cdfbe1502bb00ebe2052a8085a5d55a3cadae9b3341a110f3c7dc0bb7763bb4465ca7dcb7fc4d5f849476e283f138245c7e3be35a0a810b1665296dda156b68831b947f7ab4fb9c72cf6c15fe9af4e65778fdc53581e03253ec1c9ec62df6fc56d3b69cbcc2cbc258102caddf90e915785a6cbc78598a64abbc67aa71376bc4c4945eb02bf4ce2e9cb43428e8a12fdcd871d73494154c92e4597bf9d324580bdcc2be5ce0e8dd21e7b5bd193e023cc92e9a4899042c84588a36d6dcc77b117c45d174f3db9cd800a55098348953cbb90336beeb0b5e2bd121fc5848f6197c3e4d9e3f132a4f35b0c49496629bb8d2fe1742a73411aa39d63422efd86e3328a845fcaf698fa0cdc084d10ad90f811f85e8d50d7c1ac036bec5dbe19190ed05412b7c011493ac008453829dc48d9e1470695bed2b0a2c87c0f2f32fb12980444fd5ecc255dbc020a5d82649616d34d4ba08afa38e9ae02aa6a2acb1add59d694ac3dd93439b305aeaef83e9861b280a06a03ecc95059181fe061d64f24716312a02b3c138c568df7f596fe1583e9b7531a750e7eefd4208768c50bc7cfd667b7aa4ee62e8aa492f6006dfddbe4d454295f496be558abf719e17764c0779757a2dd3fc0bb5b4c14f48d39ac88cd8a595f8f1eca376e19818c1d4dab304e8bc7fcad9dd4048956bcb8c54f7925f0f832aac36110b55e53d25bf02e9cdbdf39a53717c029f9ecda2cb382f9311b4b23f10ea97a46bc630fe824a58a4f5a39f9767c8d2484faf2463bcd195832539d685181d6948fa9e52f36679194132a743de94a6eca9028f6002d41cda9fd879d0ebd13b306d728ed23513a2a78fe303b2c1bd1c464954b89616481f5ea87e60fce77ee366286054e43458fa19a4be6e1436c3252e799e6080d802ec7fffacc6fea577b850d6234da0d65c1cbc6ecc223e8d9f5580c649135965f1310ba55fb1bd6edcea0f0f7d4782edfee4767598d81f98c1e3a083d54c158848f7c8c23e7fbb34a2fc84c1474ec62233f3279d4c983ae229f4ac2cad6e004eecd7ffad2df8e1d73e25c9191eb505113e61eb2821bd730a81d09757bd8e94a68aa62c51a33227373518d71c2299e07eb42ed9dbf3d919f5dd0024ca014960e19bad5bafa40d71c2e400d1f222fb7cf1f095f936c189b40b80241466e1a015e1849c45a4aef53853cd872261703cd73d874999d6be5422e2dff972148de2330339b159f0a3993c3a2b22d4662b3bdae2a9e7758393becede6814f87eea5cbf923edec4eacb5dd717e6ab2f0a47f56fb6f53416dce6578f706f60d4ca66d3eb02eb9c9786cab802cd2a84d2156f9cbb657c825afc063bed59c32e11a9c2327eab0a41b286137edcfa5d75bae81ed02d265085e7a2e462112262f4c0b7f9592bf0913e27cc2b94c54c9ab88340673a96ec76321976a76db35652d2c8ba8b61a294d8e4c3fa2a3dcbfb33e1138c07a56e64155adb28268e328a743c82c92b9cddcda6eae92a6fefabc112e1ccdb7998bcbecc234fa786801158df41420965ecbddfbfb15e926b3c479b6425b4193cfbd7853b279ef07b92a68e0ead95b0258fc8c011c4c83006ce6a8e1ed39f558fec1435d2d862142f13bebab27f1769a530317ccb71c6247e0cf051eb154b83e70ade8df104a27386459b75eedf57c2204b29d6774f9f7d2b28e8cfbbc12c5a66abe0d107103c92a94dbf4b55aca6a5455d79be66f22435cf474389ef263cbf129d0a7771b4d584ec7118836ddcc5eac4f1d3c58b42e5d1f22d143f2f0971d1f37e65ff1a22a654976ab1899c6af6b5d806311e5f49c6fe4f824d442528061653f232b6dcdc6ed2ed8323d522bf59d21d64911c801a4b2ad20bc71ab466c21973e4aeb44a14af70448cfd6fedad6ded857c1e9b55bd3357a0dd8a0216bdaa63a7bd10022d6e333612931b084a0c4806f99e87edb782661a5ae9c2b3f464833c3a1d451180ed302a6287c4fdd3d5e05bc5989aec64e39afa66664c862bb6175c59659668662cd07464548f93bd890282a63603a461f23d626b79e891bb9b14e674f4cc79eb59831425188dc9fb2026ca32431512f82819817a3dc6b01b423b0080088424bbfd828d19fd42f7c07be4f45bec5983e7ea09dee56f3d8672385fa5e52999cfae88ec82a62772a1775ee751584f083cbff16a83e4ffe408883b1be3067aed607b207c81e0cf36a9c4f85bb2b4878a0731e8be6ee99cc0251b9e7a389ea8a99c7a2faade8cb4c70a7ad8fa48952e63c0a78ee377fe7c999001a8f27e133ab83157b0154132e15ff0322b93bbe8f41a3c141ec4d39664d2bc5a27ffc2813269d2dd71fdb56fe369b4d7e51e488c631e8725ed8889c2b9425120e346c195c33df92b36cd6442793bdddf221579566a0354109ce37991a1597c7c0d032631f4ecb6a59aae1169ec4e475a38036a104b0abe4171b84fcc65cb5ba0c58d77c0314e5da8080f21e7e1fcfe6c0d3b73ed5eebd87bd121f1d6d41b14a2aab64bcdc9c04868ba6ff71e71cfb10169cd309c26131d90a851353ed549ac8c614bac96f3414e45acdd6b66f6bf70036152a19621831f2ccbb09825be35db9c4eca20fd341118723378fc085da08b4ee486b39500b5ba461897feb2afae1bcfddcb631f19fab7fc99863d2adf563b27f4830ae94c66ab263072a0772086aa9d75d5a947fb75c1186a08b141c942f64e5d5c48bda6f697753c28bca6d2329dade6cc4bb07386e0103bdab0ae5656549139c04fb2d7f94a255b9d6edb66f65c4171fe9a5f80f57b82efd19cb20a006c0999c73731bafb520ea3f4848f05f4757e6a0b6fb4396f83c442f51aba7fe5524cf70908fc1ee9eb45f3289748c11d38e7e48ef66ee9130032530757f837a137e83b9264b8a9294a3afe4b1bb1052c2815959bc4ffd1208ab67ba4198f3218d776b20e8fa394856d9888037a4cd6644056b25076a8cf1818aaf691cc4c22ff35bd45b0701ef80885a5ca88a658779bfa8ba98ea3ce9a45ece9bc63ff948d5ec36e0509a8e96e7236efe9e15b0a4309830b6afc6471d2bb585cec0949bed995e5d7f9d668f2602dd98466e6086b0bfd6c25958b49894ee929338efe3ee00e5ce5cd22a97303fca3e395a53b93524485539b72ff9da5f3948bd3690fa18968f5aa4c824ba273035bdaa2ea6fac1f42e2e31af118d13dd23118fe5d5d6acd80a24bf46f8a5bc87b55f79dc1c8686d6d56f135606d2e2dfef5595442de122921a6876f8bca2b9ed4dbfea39112d71ff04491a7018e48e8805a4a3a6212fe544e8af94c37977ce014ef137e7fb5593ecfb7c1491fe35f66144eff007b499658f77b3b7fce32e529d6eab39bab88db859a32bfa108a41b4a6e937293386ec2fad67353fabf96a89c9ed9efcdddc6e615db260122f198deb28cd4cfb7340906386f64b6adb83f70f8a0335ca94ac17ff5f49d312a31c85810deaff93e34ed35006b146eef9543bcf144716dfd0648711cda3d5b91fa12eef244fd450303eb2d53a36621cf1bfb8036afb3fc04dba2e042b0d9dd1c275bfeb969c58ec8f9486a0e641dab4dd9fea4bf3f924066d3641a7dc469e875fb261e6ad0996df18e5de9af7634c8be4ed2f84ff9155784ffafc523234782e4a48471672aaa51e18b569acae77d41c1775ae4587e747c346580ae41b5e6732e63340c840380ed64c08df26ef79f4b2cccb6dbf6d4feb06f69315bba4dfc96fff74c72e23cc13f3b204d1085c2a1b820e314756b566c01ccacfda281ce90018f1ac5b72dce7471ca9c1dcdfeb634c1c932557b96baf7a122895ab279de5a311ce1fa8020d7f200a5129c8e2c545287ffeed11bf7d99c05d6d97c7485867fa91f1fe3073cd0bfcfb26f8d37d4c9d7d566d20477f0a9a568ff809f7cd24804ed89534c21517a561db20a5aa622558f7a49c3910d2ee0be42204f1df8c087dce6ee97aef58fb07849a6f9485a32e117a1baa45c80665ce26b9354690d89facd9f2a0dd65b986151f73fa7669f794d4551ab0a1538f05805e42514225df0906e9d1887776bcc786d0e92a2b7039460318bef8e5e6192453ca3a9ef1bbdc080b2d14c21e3e2391ae0656fcdddd3579eb5c02832f3194acf05b7550c4db7af83dfad0e991859766eb572786829ec2d1f91ebb1159f041db9ad6248d50781280bcecdb7a1bf9c1f6f68049086fa176f5a5a1056115d9bbf274c2389f1043fc724cf68f6d4ba013a81873cbfe10ea4b09845b3540bbfd769dbe899071b79809032d883844d5f374722e20108e0db283087eccc009bc0799f4ae8173e8bb1ac1c0890d8f11ebe5f7de191fc00482c17da17fcfdd6e461b0d1e1f269cc3ef1a31487f4384d0199c03a3fa0a01977da84c67a9710e4dcccd537264b9f0cfbbcac1133603d798291c5741c14a31714b22bdac6173f8c339b3491bd4ae24401d1eca35de385e7fbbd59e248082c1ec08d8741492e62be7baad73f4cf5c1f1f117cad71ea134ab1765c8ccc1260736dcc6df3001aa9bd1876576c2c8383b00c55e15b8e9282c5c27aa58fb8ff56ce47b56a79fb246fb97ad25e68f77542a4c66139e25c76814c7c53a3f22cfb18f70d2f76d39dc35a11574cb4411decf8cabba07de8d9385624123d4a1e2afd4947bbd8157365c9854a11ae2a031a5647e730f566f82f41fccca409e9e5ce28b8de05b4209ac277bf61260a6723c252b8f396e02f8458618425eef717b70232c6dabaa56f5c1285bc839ee01558b8c51252683936f673c300b50608126de87b719bf0776105ad06f74fe3b61c57108a151a7b5c0a688b4f05779a40fc47064d8b856905c389926bf70762975e4c8e85a6c7fb20affbcea0c0eb4c489cb37922146ccc9ea44500899026f24a95c15d0219c84f45f28e420d0d43a79ed46fb66cfa7274a8907590b293f2b09e168cc8a26804deecf7c110b177c4a1f6480f209a8182f9750a232e08b99eda4ee0168c70a568c533387ff4c028f76f9227d78b397c11e63c16307f02888e9969204788bd25962954f1ef3c8a9aae141ec28349ce3ffd2df6d808e0344574aa8197a1187cc8455a26186e65357da86fa52a5e1eb0ce81fe12a1ab53b911328d5f791c5075711ca7c8f9cd7c8346df3af6d5dacf0f2878d27a5d05afa577f93b026bdffab81983b38a4ebed1f1060369a94ac0033a807d21f639e06e45241eedd99ad0ec1d0d207b6f9546767a7d35a218a86043f0e646679027d24597687e47cb20b3223c33794eddacf35c06e1f90acc8a30bd0b895a73365fd423dd4c350b32bf2670c319858bc17916d6636a1df1d54734fa6650100f568d22ef988856a5e85bbe5da3061ffe5a493db4618846b2df344d35a28486f3766a4c488fee9db4de9511088280589f7cfabbf1c3c64bad1edbc557b33ae167b68bd9505d0da9839de621a44170fcbebd1c0cd6ab747f4006f24bfc6454f55d35df737ba5f24330a6abc857b72fdef0bf3abffbaa46aee157590116d8b0c2895efae4b9bf18cb985223c474b1d22fac45c64d3965d3b7a9a69e048b4dc9b64705332961addd927c529fbf7dd0eb352ec4efe11b6313d20eae34889488a7c33e1e0d8819a34be977cf82b057e544ea37ae7c545349e31b3d277dc0fea5455745c4b5ee5fd9a5e5b1cf93add6042ae1d0f9eee910f5ec93a1ef1b609339f6458112b7f43b997f354a9b0184b875113aaee6f694cf077b5337cbeabbead144aaf534387e6d99a0cb75f8eed67092f526e4cb1e722548fede8aa3c5b3bce3bffd0f97ae84b14cd167ff98e5d595a8ad8fad4a34243e7a21c4cece18a10ed260c33649fe443c13124311a1eb1ab0874d704dd18367354ce043289ab1f3a9f315d5cd0157164ad381b06b88c586ea2e38b68c5ccfac260d681ddd723c6d33e2741d171356c167f49cf67f964ba9c585335cc043592ced75581c47de219e399a358fc0f2fef7a2593f9143990857825ebfcbadf54c3ac60e647141dcd979635d8153e778360c80b6eab4195824a2b1038ee4899f051a3f4d51a8506cca1e3bd282ef061bbc539400f5db233a865ef91007ac08cfc419d054bb1c5762aac5308cb66ed122cbb1cc8dcc49f8feaa2fe8ab6bbe4dd0ef9005b7499efcba324381e69df64ade44c42bb1fb0b80c4576f81a3c311e71e717f9d87c206047ca7c3b9b34ffd672922aa63bc984bb71988b2329b711808b5241e7d65602b0e70a732aafa50b13387c83db3ba29e21010e43c3869f0e73602d607d5fba054eb84c1f6206e7c6b683563d73bbd4dbcf22f5586e37abe8928a089104aa9f6dac887214cf353a0e7e956edd1a56ce0279672a153742a98d96d974313e44406eaaf16a139afa53e07c4e736ffd9f3566a6cc1161cc61fc361700bc0d5f28ed7c5ac018919f661a7912d7bd00bf0fe63c01c4c8def811a26b1a2a7543512e42d381237636cb76d9b1c897bf0f0d9b6edbf1b6a5e0b89cd4a35837df48e04c370e68de5d33f7c7c4d2aee1c1aee0a03fc0e6ff4faa4c179154bd49f2662c56919761e4e63fce518d937b125b033644db92c93478d15e7d1c51dc54fc9f17d866fd3945563f63217980319f2a02d118a24335e7ecc059d566f1e7b9833284eb0e4fe870fc7cc9453ec469e302dfa2598492a916ce9f95db7ab249d6b3eee71f9d692ca3b4d91605078ff0c3e276274ec2564c4443556b9ea452dc8ea093a4f541c1ca8efe6f4754526dee3316da2390ae8ff490c4836e4a5fe3017344f7e8d2e55fca67f37ffd3cf619848487eeaca44808b465088ff8eefeb01628f3c1890b7acc913f809edc92916c1704fde454e2064df28facbefeef05bc4dd9b63ac5743fea36a194bd96323f7d05c2fc27d54a5ef89f5dbe2daccfc17e3620a4444a97411963069cdc7940a13a5ad689975c758010302d16238293d761c0e1500f394bbc1f22b667599a35d29577bd74efb6c232ef1dfaa592bed2752219b2bc3a97c8635eb2a0a5878719e0900dc354afe49f4cb13752298f36c24e6d12d462f4c5fe69fd2fc5a57952529a34b15cb20d0eea49bf287faa8babc28b5317328f793ad275800754855f8adf1e7065f1061d94073a3f38bf6799f7a54a823d29120c689bdc3ab3947d0b33dcc06bd7b85c8219b0c6e2e738b59fad91cbb695d18c6066419f101efd2b732100f605b56982336106d6c9b6bb8058da43d8f935c5e23907de02f3972103fce95367e15f7d68fd748a386b85ecd9be72f621edf0c123c6b65a1041de927914bee30056acb92f8960b8d3acc31d9cfd861790020a2c7ef22cc1ec61dd4586d9614e4f39f551ebd114d578ff03a03e8843e336605961d54b66ec30d1fbed2fbb59f3a2a4296e5ef062dd86be544e8afa04ebbc6a9a61241f69837d28155b0e78d7b33122f9a63d2d6c315de17b70692e7950b5d312cc68164524325f3c72c46c0c01f167ef3b5fb6d40f6f8b7e8f2e42a9eeb114cbffe9cb05a96a958746dc40ec063346e37f7273ec135ed3b5968c6e0fb82d800e45edec7b1a7c9d00ab05023de7d3c6ca4bfd58bb3ca12fb438f5e50c67891ada309c0dd4640449a295dab4e6513e4fd6f67dcbd3bb146fb38a400fd0b6d523929346ed4c790452042d8f270088c06a3c8404e24494d82a1bf6681c7346ca355d82acf7509bfc330c7de28f091d68c09fe6c079a7f691f26ed0582127d7d5a9de3a478881c80e9c1b45bc133622c7b5d6cfe35f7475855c110ae547e195ab15fbea30882ef49f728770594228e39c6886e025bdb05127960683695c2dcb1d73d61258ec09afd6886f117f08290234a5f086a95feb667b53b09c2c1f00f4ee74ca4066abce46eda03ceb0b891334d91272e82977b0eb6686fbf9a4ccdae8759f3b1da4c0a2e257fbc884da1087b0fd37915e1426a0b13db6d1151e9d44b0bea009afe02dcd09e52605336dd2823e165154fecc5f19781aa061860aed8105ea1cbfadefcbd129361bc71245aef51b2127739eec3ade33b45e3dab9c3e3ea82ab90895041af9ed4e1746b119d8f1dbc08ec18f8612e94ebf9302e1cc4e608611c32c501f69a4e03f626566e8cefa222fd9cbc2f962472be673250bd57f4f8b3122bdf658d94b9315252f5ce38bdbd9074ada01695a6d67d91bd5479df83ad01380d0326582073412317e256b35b7374764cc4d68f118952af20a9e35fff4a6dbbdf83593c06127df5c261e146621dee12201a869fc359809a9b54dec084a328988ecc938aa6f4ebb07d8c02a7406fa9b5e92512d77c632b8cad3a42f552688fc80600413bf1a84d8c5f2d194d3eb5df27b3f67100cb8ab3166b74bc6ad24d591cf8986e1b56d0f4c445f989997587be0a5a3395693633fc6ad58b3299fc1a28d2cf0eb634322c0183a5ccc23edbef8c0e30645a46a3c2b88c1539fb912f042eb552e29c8ccf212a885d118389c2659a211847a9ba9dbedff9b2ee360daba82f6332177246bc2e9ae7f317151d74c90eea931c227789ea79473bd38aeb970f887933e76b38d68223606fccbfff278a1193c5c6df07b96477981cb3c7f55f53777cc5c3b019cf18ab8cc7efc1b33cb86ba7be8f70051788496c6b1a5bb94d94b634013ce34f24065b5525fce96c1cae8fd3b026138f77375053e357aecd8420e9a14ecb9a06cb7401ad65f8997e25369ef58394650cfc0f5d672f401dcc559a69a61cc40da76d18245a4358204cc8d8421d909296dbc1b2bc933b24932789b283f20a0760abe352e10671cef5ead25e5d51a0ce00b235e751d005dd9500026ceed728e339c75a0a9f8052ca8419ba78271e0e605416323ae788bce7caa321a4e51d7e8a2ea793cf66a5ec98d99da3ceb7f8668b73ef22d07c80e3ed395f29b2fc8543d320b883dcd0feb640936b28c9a3cba69ec04a98a108727a0b66694d98bc599318da5219429ce4b5e148b3aa96e52c36b3e52abad4bec049a4b196a76e4d2706d00ba9cb12d43075e1d345e16e3908ecae4ba48a265b4c43776447df19bf76b6357c6fdf958c27d2e8d9066d394287651b9a0fac2f35a4842c2760e266b622448c6e96b4a3b32858c1e41f0ef1eef837bf94c9efeff0f2d24b2005a7727274ce8a0a42a7c30e1f330c67034dd24160c3af7c1f4ad3d5e3c02c63ff999199ee7962a5a81229807b3cb9a793070e5eb89b802c3fcea349bc9bc215b588155b21244808c70ed7d1ee9b2838bb919a3f24701d1b749d20d3d5e080d71e93828e233e2b29f3daac460d4464130be16aead9f5a72372417a38a175a8be2060a3bb84ccdd8d37757475d8b9b7c29e5d6913986a5cc4a69cbd2fa9aaf7af91a0ddb7ee31c7c5203ea1f4f1affab0f6ec0e8c8029c33d2329cecefb46c3f14b64465d5ea7f71356096cf1fd1e48d61f488c591d3543ea2b5f4658ed422c8786669525206050183eaf797528eb2cf28ee686c8de0dd7a5dd7d77e5f16ff293a025343df2cf7900e502af8e3d2690bbcbb9c8ad5c6c2210f3627e66da57cd36af80a2dea0643904a719c7cbf8a8470a10efad4f8658acda678fad7d605f4209aac6c70dbf8be81bca1ac4306e338f46682cf2d457997be5a1c0c17e18fb9a4d568661d7fb22c73db56f9e840de3935f55c80141b345601e6b1fe581517b4afa1d7622be84b992a623bc81c53976c19f1a732ee7e9ad62e24290f58c7e11dd19c8ab96d0dfac6a0b554d2e3f72e1c1dd140c4789b101a5a059e70ec076c6b08077f0a683f7e703940a9c5948edbaf3b107ac186a0b25cededb8b47c2700b7313498abc16afa41b3b6c5758f48d2079d32051316c1e696ccb978986040e8faac7ca988f288f3b07388c28aec387e0d75cc4f22bd23b585da76d27c1337971683d7ade010ea8a032b856fd81a214e12ca066e6ec2e1154088ec426412bee054aeea67ef01e002e2b3e180b8b87b61b522041df52bc05c98ddd802b5bf60bbb52ed1af0d0845deabd6ca981da03c86fe694de662b4ed8e04bd233b3c21f3767162f8b51d6f97998249fbf84095fd89879032f3d84d24f0b68bcf58f7064e4f9f69025d509fdcb1b194339f937e6dc5ea91702fd7e63e7767baeded784e9c317f2876f5386cd0c5673fb731f875ec11df68c47f40221bbff6ef6d7415ada38bf5fc1e004adf65d2c50c58ad7df2a7bfb5fd3985a55ab6500b288e12ba9e5163e008604627a9cdeac46f104835901cead6a1f352bf2a4f8b8ede4b41717f06bf5be40f3fbd12ce32b69c4f09904c6e0743311a5b12e2e6375e336a16be0fdbabfa2c0da9a2fe0a3da59e4c807a9e033e4de10d70141cc404e148d96ecb011180967bc7330690afcb4bac05ff82f5903c8096ca4d6d678590fb870f061832fd9cee6448c745a417643580309fa0b3efea50d360ae0c7273db6b7fd6b49292f4a7af31651c31be7faaa96b5c9d2a8eb4451a603539ad1b40d7fafe634aa1a577e4d2367bdcb95423807013953038402c0b80d9affd86e00972314942c90b561e0691d40a73a4e278b7edf4e71a163e8d9c71863efb48a20bfa56d06bb1e191558bdadd50a01db9116ae625914b7eee9638736e976af6ca78a5db0b9966a1e8c8cedea256132b21854766da51c35ace57502afbed4294f85fdc9e4081f52673bfeea58d4fe62be764e26bb40c4a9429ffc105f1cd05ab22cebd426bb0e0703bd9faf8d7f9102ddb56f23774adfc80c08b24cc8cfc3e71bd51038154da7d1cc6eeaa2a4092d5e4977d02678e22c913e8ab6298a70bf3c92c89ad631b0d8a1294dd4e705a7284cfe212747f389ce86e2c6b9e37142bc750bf06c46f4c1671cf714ff96d220e1d39f736706d9d6c3041d965fcad6ce7b97db4ab7b51aa5e88e09e7db5bf78b407b2479f773d0904517a59da184b3311945f1b158f6adbca0088f9b028ff7171b86e9e8bcac54885931bde2ae4806ec3decc8cc117235b0c70a818e7c973f7186a3b5c85a8d3263236741314e975c373150a7fc2270d4595c90afbb2aa2b647ac5ce47fdeea21624aa2f570b758ba5835aae0579a3d0c780b893252e2b9b7ac827a3b95a9e84375b0d6e013ba72d18063415d2022e938be79f511ca21cd580c88c1273fd011a54fcb3b2bccf7cbb7ac420b93632621405915a918ceabbd19861cdc312e431c1823e669921b312bb145eb6d7a43a8e37618f271","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
