<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"05f98066522581f91f554f943dd2b4a02a8417ee3aaa4b62a940d885f6052d75c8158f162d7de9a88dcd3a9f7efa986864bf50f42b68a2b77bd2b79047ce12fd4aae347dd84aaddf7d6a0d25f2002407392242bf8a030e7bb85ed94a7443b3b6def7e8581e9a478cf753e83dc2dc3a751c756cfb1287c431856a803a181a9f6b4c8bfcd309f9e44175b992bb3974293d69335c9fe27255649e3e47e0efec68c770a3417da2837f6de173278f6e30dfba44ace51784747e1aba829c710b0cb8280c25068013dd5e85fc5b2380f6c58ff494539c807b80cb79f11d1320c6c18e61bf8854cba289bfc48202046459b163f5e459147cf6aa824adbfaf7fdbf398dc1722766b29995244498a5535b5afebe4bf8e3bae9c44dedc3c6cc0318b14203d1f2bd96b6052d0da86abefc96ec4d225eb7043dbec78350fb0d65e130ee27c98e6941fbc4a0a4ce521d0b4ea796f59fb2dc7569e0dfeaac13de406b1ab56396f6f69d714630cc466d6bd415e12c518383ec0b272511739eb4cc65c14f39a9b32d00ddc2c34592d24e68ccfe1d83948819ba4cdbd14ca530d663aed6de6ad38cb9540194163008d191488dea8e9d4d848550211ff79df33d8136ee3229c2b09fab5e52e573cea634563e9cf4174ef6845a96af3d33631c17739ce51f5b43bac874c0ec711c669c3c0e5c4425a25a7aecd54fb7da5b350b1f0b4b685add44e4e14782fc7b62e32b44956b4878b2b9c64e59c9b0b96a040465923ebccf1cc832ebeb03acd7ab5c1492d86859cae166e4b888e564951c0ff1e23183c88dba811d53a7374cb06e84266ca837b8e911a2d58de92cd422123a9105c3408df4f93220b3dfbb3e14d92e7762d698437a8cef63cee29b658fc647b7b632f3459f28e6d6da3e0717c83d212421647ecc6483cbb5b5081f93bac0110eae0642742d5c854bc5bc9436cc2cdf9d93e721ae0c5055caebb002eeed9ef0b0779f7f76641c7e2f599dec8408ff2e0664983dfde4bcc781224f817ff0d1bd945654fce16e292f33d629a40040afdeb93261bcef416b8fc22398d9c102486e0dc0d7a3e2d4eb4c95890129031c08c5729d59891d2038386f708b6fd167b8114da5429bbd62fa056ffe1eefb63fd5c993e5346877c1328fcd3e3a0b42cc286134996d1d70369df72f6dcb903252905f4e530f9cd89cdd610eef0c6d864d29e522ca8d2a65a636b7dc83567eee5f4e17b3380b50c871e33c002c35dc4f64dbb592b22af45d2b6221b24dfe789f8350e051b0eb99ab4ab72c78d0d054c363a58ba61785a66b56089d2c94037a7c515af26b22fcba4c06ddb502fe0933e8d76473091f781fb8ae7e5c90c886854df4d02cf5973e122cd9df4f43a552e69d32823112861e882698c50d6c539e8fd13d0fec91499a0b23382fdc7f901a5d396970892267c70d256158ebfd2cdd3617ad57050bcff15b1663d196baec82ddcf5a1722bd41890351bbbe34429e6671d1d32744570e75801905d5c9200442dc23fe32bdbf7af5f5ac94675a479ab7d0ed40d5f466fde3c79796516a64f5b46cdc32cce387fbe3ed44926c88ba988db43fe24aa52cca2e024a8e84ef9bbf8710b582e616af8b744217e6cca4ae129c782ec2ccdf1a83ee982ba87e50a38785e38ab968561ad849887b20b638b1a9e69eb854e729fe19cea689e06a625413d057ec5f34c83bfded4624ece1e04d88a0d5197d79beb8c9acccabe58f9ead8d3db4c35e8aecd01480ddddd9c3d42cc437650a5b2e0a152f71768038e681487437ff75e19a198ac369dd91126eed87026dd50b5400170b11d5b7405cc49a1bb476a725e641170a0861888c9b8bbb082ef84538feb9bf06789544849733caabdf428a4d80c4bc3b773ecb4fb96f399ba4611bf2579323ef63e5c6df6ee6556df4dc709fefa4b20b5b8a7760a91795559d5b185bddc4de5da00392847ac410539cbcf6a44f55f004d76909b8bedce100fa34add7f85506902d1c6f9934c3898180aa942b7f32edddce9888bcd382bdd7da36ac2152318d10d3e02c08b3a006447f025189916c8eea157f08fdae99144a317b87cb15553c2061594e32607ed5efcaaee7345a452f9461ceaa3fd1139391909de95cc74000370a3dee66be26e4d074f6272cce698be5c553784b0518381c84d453c0fb412d2cd4799ddc72cb72b885bc03e37955e1c9a1eac5e6822c2bd86295849f8e3b5957eece12cb0f01d9e0a40e6f6ea287aa48a8b988584fa5584acb8f36c476d610498d02c56912185f0e00312ba8c0b56ee494e706e9d9930aa185149d4c0a4b9950850b03c7ee645bb1d922de4d61311c511871a840d810f7d7693d480a8a444671463491fa578687d85aa23589f9d31b7290c93d1923320911009a3fe6a26e7cd165c5bc3673b228891cacedda843e05a2451b0e5a822d3e58ce5eebea63eeace5cdb0a9b3eddf05b7a684c334089d87fec4fa86e04a487e91c866a1c22e297f4c054b31c4c736f877e226d2ba43ba8730e9e182959bd607243b693dd35dab67d59428bbe8d861a192f3c7742702c95e1a52735ee1142bfcb2c1b37b02e75cb10207481463b498ad81b4d57b965fbea68b285ddb2e2af48c17044e311b8943a1aea050242f1434e6a81ef0d565882e4a190612360ab3d24f907973560e956ad09aedf730430e926bbf720bdfbebe6fcc0cb562856f212746b262e1e162dc1fa6640dd5f3e6ffe375e9718c25c2f2f23ce0a99a6582aefdfd9d3db78c8af2248c90333f59c719768e25b048e250d94f484da4efa92f9c80642c551e6481a19da676800ab82d7f506c2edece3305db673d6c3d70c0c094f88718b8ed5b0898547815375d141c98a1bfef054075867f01cc09b21838bf78af9d99180e0e2db5d32dbe1b3bda49720686424c22ea0f521e5177247ea102206cc25c85053b2b62da0d99b1208a9f375717c302c32b6238284f11ad9cda3f98e757aa664c3139753b63369db52694337339f130ce1a45fc434e1efb30d68cd875960002fccc243ca04e19df391b5a0464a31d163cfa46f30c102472fa1f46e5f8a214cc74f0d5c482264b53b2a4a4608c3750451a1913f4967c30a4606b74a35f8eadcff9b5e3209055a04fe0420a3d9dcc5ec3971ac5002c496ed3dc78661d470131bfe6a5fdaf555374086bcb67b15755b52102db0928fcdb79f0bc18ac284ee11d4478243ac28c45d5eed3e5a33ebd22fa53c3a224f463d878dbfbadbc2f6d5fe87530c8e93d863007f03dd2ffdf3885a8c5e0828f917c854bbd794dbd8528b8ffaeb13a5d6271b95c875f1369047dc9667c98e8c387b573247325de7eb370e034bc39fca7450f5a31878c78f0ad53f5434d15b8057f71c569f464a50e981b31b36c43cdf9fabfd248a6509a716926089d697589f2d090cc4fda0a5e801472a36f41a1d97c06b22cd09def89a540254208cb97bc2c02d72285259a1ae38897c39bf2ff81acc042d73dd15a70a41a9da234d439fecf3480856648aa07c7e3ad3348b48347c028761eacb38a13360ad74d73eb54484a5588ffaad4ad167fae6d4d30ac5cc107fb4065fbc7ec0eaaf8b2c8e9d7651bfa24336821ac7f748a020bcb3b0c81d99bae6054778e01a25d164d7302f409a3b5724a37a022f56ca599a7ad4070708f40d3b0b01f7a17226f58d4a45e6c288af05da3b2e9308d3685ed3701411f386e4187d8d7f1eaab1cef27c0389902aa833dab8ad6978c9e500e031352f1ee3544eb4b3ef740edf59f8cb2db1d79365f4e8dc834f279c8d1b001c8abae7c52f9758bbab23c7f042cfb57ff5f811b826a022205912b600c308734722eea42805c951bae717b65e77092f678df0b10aefb18569cd425e2dd4c35751b91d4994ca2e2844796242703620b008d085d6f24b223b4f27f5054ab07f4cf3a0eb8521e9b8835463c31dc8936b417521be081006c285d3c105c48eb7bc59114919e8bb218f9bc96171d1884772b41c81440f754dc2d596548c2cb9557c1b3490a75b8a4fe7167f6c080244720b3887f1c51ff8e14606a71c5ebc16f753aba60b26bb48ee59d1c20487c85ac01723a87b1574e8b535b3a1bb713a84e12267dc5946d246ecbc29cb92b6fc6ba251a929270a124a520aa69fbff66c9aaf8176222af264c7f1200ab057f4951bba4693fcf21e8425818a8269e102d238474c67d65022c3f1c74df60c6abe48d7e6cfae4bfcd203e9f0dc35dfa6397266fdde5737c7b2ac865b3fae3d36032925d643f9690cf1f6aaeb906c100c62c59cd7bb7219c826761275cf14c99411dbc54660ca5fa8c04008e5bf751e2ecc8b159955a12d158df44d91a8fcf9185ec181c91154b5754672988619ac39cc0aff8bc384383720818c1445154ec7f78c39a8305f930c6880f2b6f7e7f794252712377d01d66e2fa0d03e2aa5eea6341aeddba61bce089466e3786aa206e2fc9133d87ab6a32e15f81ff8de234cd885e7bd6e051ec95617a0af7462e901730be4d9de6f994c5cf5ba749b3535a9ee58951df3736054f12733e5f6c24dc412e67a43c5f4b22b784649d16549093a6737320bec83fc3bffc7a0be42b7474704b5b5e59f782aef623a2e1813b95d33987711da3cdf20b9f9446c6eb6f3f7d25fa0710711aea06278b0b922050921314a60f28f41c1bfac07ef29cfa9e3045c5ee09f4c22c62de25dc3c0f3d22874b2a1e2f1a987b4aaf2cf9a26782150dc98a530c825ecf45a7d31f1e4cdba3f9feb80260dacfa126cefe8eff7d3dfd5a6abc3b2d0535742c94f1d1f3a21edc8106e193bbd3aa6c89f460b262407de6b331b77c0b0aa377a3cf2b318fffbbe20e6ab2c970eeedd2790078673bb6900b886832cf5f8a3155339473a247c49b561c0b1f4696e668ddb2b60a4dd85cffa761e94add1fe96b8c485995d60537a95422d053e2438e3610dc02e1849fd74527daef6247def3dad70e1bb78074772ae77f89527943bf4bd353cfb0533b6c4e56c6de9a9ac986e4ae9a35ba0f812856156a086aa82b828045e0d7e7bcb746cbbfa1b717fe4a27ff36d4033d111784c6196a76abb79f527956b77551f39cd16f587de52400c0094398d96b93cfbe9fd4e81b8965205138bc5d5a756be2510fadec325fa13046ee5164a20c8726cd50cf62b8217e30aac09a1e68009f161c367f75e691d1b16b66ff64bb30d81505aae0707fa4af7f19a17479f0f0e2607a32fbc34bd49c5e16395ca35a656a456d560258d73f752dc0d5b7f69c7dfc0af2ee729232a6632aef5543a074296aedba7214d356f1a95df1f271b7728fa3c79da944c5f3a12ff56d3db1bdabc603cd672012941c0c98579a95f20f2435c03c1993e7aaa94027fe1416a137a235799d0ce131826503b6ede18f7fbdcd7fbc7412b914a499ad2d6df3af471efb1ca61cdd85d2fd35af1d5d5ad004c1317b6cf9c19b1cbb713d93ac747cff20ce4a07be3a664a782e213d343131b9bbde1a2e80d96b7335d4c8f589a8745e2263dadc0adfebbd2f47f680c92aea7f8cf48bdf23a7e7a351f2de501d245aff6973338c48c1bc5b1e907340382eb28588961ee58c56f51ab3618de6f2d851be707cf93a7474d063a4819a9dab938041d9842122ee31d87bda7b500af914e514f22117c6a11f2583848813ebdb7469c9d6d86e8a9922316043abd906105d2709a19049199d1913925fa4ea74b288b588077470c5c52f66db6e6e18d1fef2c38517c7e311b7adea132e668542fc1e2e72bab4a1cbf2372ac3462c04b9bd31807829f4f7601622fb6539126995596f4e0ca0eb31d0689f5ffa57a8c38f34dca1a3597ba9eee4b69c73b816d0922aa1b9fb917eefe8f3a091833e1909aa6bdca93d2d954f9895aaea4190614a1812705547dc6292c61db408c32f8affba303a27d320a738724989524e8ac137bde8040bf7ac35d1bbcc1c60a198d2a2dad2389982bb8702f26155d55aa3c5a3b6cf0161d3be13dba2d1d20d30784a53cb07c49dfe514c094e143315ba413eb38e628a2681b13310a0a359db09ca8dc1b65929d6ec6b99199620667344d6f5710d62b1d19710fbd2becf5da9b3147e65093710f303643ac2fbdc0269e9e7a62c8eabe227eee15830f756341ef9af44a4209e70db9a215216b1c9df839474fc08fbd7ab1b82ffaabe23520fa1192aaef54431916351f3c30a982097d2412e7b1bf53a384445a5382db4abb54bd3bbed5d78653a7200b419521abee741323f80002df18100daf05f177541272fdd22ca02f7d70f2864e1921e795f9f3875b2e79e62ae6747b1c9a1fc2ffb8dd122f63e61fd85ef4c63d3bab2cd9a9e70b1f6c430264fad4e2e4dbcaa98042746da4fafdd0b6fcc761a82ecbb885c9dcf19a3462944ec3ec474d9e33d0178a93e31d1a4defcafe6bd1954354170dcc443d2e5267d5229b2cf3706ac36063b73fd955d5c172c454807d6f3386a123d4df5dec8b3523bcf2175a19543b810661a4c74d852ad015ef19665d3ec2496eaf4e850986f9bc1975c3e7b2444c941accdbfe5f4a6fcfa56b429cac7cc4dbd57777c1ba2d0881e049604f8219930d13a684222a4e163779eeebac7e14da45b1fadd10731b003c5c1ff3386fea4bea24eb2daefc96651377a0eee4fcc8729dd580e84f0481729cf8fea5b5df3224e9f2e881b5abd4a62158ebaf939eac2d9cfeae68776a4b19d756be88049c67b75b443ead5d566517bb8fca052e4ddced3921ecf783c0e9a96e7d82014d635d6c38c3f29142170b291680c9cbdd34e3c7b07972e456328df70ae43a52872d824892d41aa222ad98543f32e076483e8db2949f6aed0c3efd8d06c1a175aa0f104d5d93edcf4fd885874cc057b324ddd70051eb80083e138cc26a28e760423f5b4c5f7a82b60ff1fc79b869f6d53bc0711d3892ff554d56fe3dc29d976a4cfa3af3109ce83206a00b8a9852a31b0f49c0becc20467838f6e0541590658fa8209c4e5a8926b6b9aed3084b5a73b2da28868f717b54d1625a359b5f6a1c307eb82aa08eb47505517e0387b6b0914e55df519574808d83368f8df4e49cc0d389ded4d28860ce48d415ca7d2e5893abcc2d95055bfd7044d6ac0534fe03ca2b169b2a5148e6175a1d64ef7bec4d71a5231386f996d9456a48102976e5792f49b4e5ff013065668d3e2ba9fec12e25a3be82c70007e1e4211db9c5a2ac57d47e3de2d74ff72402174e647e2dc404515d720b1d47810d6345ae4dc236eeb1413f125f99330bf046969eab3d99fa10d399cf4ef1b6f3064d6a317d0bc5c5bbeadfea7f519a6148d79306f950353eaa5f2c43b8edb9e2eb2e73468b47690612c2ff2d3082ae5246c46d5fd2940724de2978ffb4178c13dc62120487fae978e67de0f518d18d40a3980e002890438457ba7603badb60e2cf4ce5bc53bc5c6baadd55c4f54bb807a064e4b177944fb4c4d0127d37e7e207a61002688cbf5b1b269b2032ba45b0ecefacda431f4d034b8e13391a70ff2b5ed71dc38d295ffa0d23588761a4da2c3d088ce72de43351e2829573831de4c42346935f5a168783d2963c3ed7eee056595568b02cb09f6069a983f516008c0e0b30a720f8fbe2916a94665aff5be07af7d870f2e1e051a9add67f51e6f3ae2d24bf22413af5c488ab44bea906e633104d3feb9e883649d2e087816799fc1a590fff97c550d29622e4e53cf576a6cdd75e705bbc0c3b0672c1e8481c3cfe45961b9abda6cfbeaac148883efe543035fbc69d29b0eed898669c19b06fed6773b425cf1a071b8ab9ac9bf29c7d8255c1dbe8a9b10e22ddc735e0672f7280366c338a1f4d9e481809da41905c95bae88f00a896f17c9ee60b8d3c264dd24a077c90e4015eca04948d6ae82b052d5c12bab82042e4e9e8e8725b0e4ed5dffd4bea051319f9eb60368faf7700b406364e27435fbc03694a51379a1964d641af48ac86ded0769984e045801f112b17be7642953a2cc1dcc3bf70e0ca0fbf4ccc9e2ca138dbbd717521a7e8836171282c985faacea03965734db99605403b0c3f02ff45c5d956ebecf00dfb3ba7d73723b61cff583f7581e0fe1ba5ea1909e57c12633b77ecb79eea355708f0a2a357250465aac3c7b643cae0c616eee1e9272cf95348cb8f1bb5911c33fa3eb9e68ef318dab5dfff6aa214efa448e539983d0865ad0610d35ed6ec75cdc43b8af81afde85c6efff31805a132a7185d5654ed0a1f9b0987c11b84d1bc2ee20f16fa52fcb45b6c54eb1b936dfd9ebe2ad45b1670e2e4027b520f1026f935b8e9c2cef13ca162849c850b995347785c576a9027c1dd819f91f845990eb04a3813eb75cd7d5dcf581c4c6df269a11ffb36d7c8a54ccf28ebc09cc5e68fe906befdc808f9dc05ba10b192f7901254e445b70665864d7f1d66ee430f92e2248e20881e8dafad15f7f5163b06853282716c603d24f165a7fe537f97766ac98f68c2cbb4e58278fc8b59ec3387cba1fbc0ce83fa039d9174cc46bd36873278426518f49351d20320a43f4a973555abf2c983bb2509fe964f62ea642cfdd9e1f5cd8e48fa411f3b0b70db055af4c0d4f6cffc642ce4f3998a71ede725ec5d2ae4ccbd3ad9c9bc331e6c1cd84230dd89bed8b06e23fb370160e5fc0bcbff4ed9fe0f6bbb2743bfa00e10416cf1e4cf228cd78f4212102cf037e13086c9ca15099a71982c00ea739d5312da3f1d7d2fdf4646d920b002e81eeadfccd9ca9005cbbf4263da06a37a87eb84b10d53a938df36a0734dc6c365cab68f0860ccf956f113b9c978dc2d27647071bba3d0c38aed2447a69373e16222e9625990f312f6252a8d2713481e09b77f70e0e6c91bc464c4736f27e7d45ff0a278c34c0e288d3a5305cc50638003d988f8b62c88fffaeaff8e05d3d16b5e80e6a1da6b6608cc45f55c74fe421dd5bfeb00f82586a4237404e358c98048692c88b49884dc988f8045a405a0dc7e82c75041f869d816ea4b840bebd52ed57f8de682fa853bc5714a5a52ecd3840c19acc42b538a261e4bb11e62b48db8d3773e7c3e35a3a44b8d33059743af3b5b11785e8464d2cb54e3a14894f20ecddc61d86091c87ec4d1e17120a4450963568146bfbbabea6e9800dfb50a402bc980eae734bdd74568c35e1a508d7dba595d391d15c95898bf94ce7f97da2b0a104c3ba555875c56421f180d899789bfe277c6ad4d57ee14a253dde573861dc52dec218da0350bc51f406c4d76944d3c5a8d9745d550b35a50b11e16da955724723e689788c55f4956089c0480d3a17c6c8bc2dce06d5b7ea806f94350d9e9b588b3cbce9d1abf4688ab1752129d7c08b6a0c8d06b1db2fa8c76485ba7f9095249657e792de52f2526827515d6b1ebe74e8310f9daebf8133b44a9a2fd6ba9936ca5cedd4da7f3dcfa7fdc36de2fa00df1fb7f0abb8bef270cc6876a3b43c70eb8cc3808c461d4d2e5cbb47a810180436385833413522e07b83979c5c3c0328c93e2735fa48c0b9040bfd94bd877f429cd7c560c7e742a7e35cd7e679b936b3800b5e85e84d5a17d0087a594f53e0e9ada0cc6d67f1758f6e0354643cd72ff80dd53439af789ed949eea64e846d39d8d676c56e9670b46c20c1ca408c250554ae7960503b4d353ef59f3985d318166b26011a64cf151be360b596369a3ec17e3b58cc734a843febfd034f541bfb7d0ac25debfb95cbf2445410712c75f97c56a7e9bbac9d6531a8af3bfbe1d23423cf4b0c836609105e55c74e8a875792bd2f3ffc78fe84dfc501e8b46e5d878c711d8477ec983c7bf8418eb3b405d41d3cc97e9bbc884e8a429478f69a66faf5561f35ff4fd8ddf85489e59f680585bcf89c57df6e26e52d8028c7b538461d65045557d27d7a9c705386884bd8ab0cedebcf68d5e7ce6dfa74941035903d9e8fcbd01341ec70ce794edd390fb6bd6fc600fe9d2793f1c6371755d05c8daade0c5cf2adc5e465880b998a939de7237b52d7a2c1f2c05bd385e9e7cc9be421150e69c5f9eee3756a7e509c0633ce2f2d85e46de79b53006765927510c76f6413d54c0de77d37212d47437e063e7cf08e5373b6156fa3a9483310f5fc378c641781d8d253958e32e634c7dde2aa06eb5f84cac9bea93ee5307d88d871955bdcc990427e1e6a474aedf7abbcc63f7b5cb491fb56b2bfb643a65a5d40c01f965b103db788a22317a7906b32ca85bf7f3134c6f7df91ae1e70868bd39e7954948434d2b14aee9f43843a90ff691e53833fa807982a2d64cbf7049eae1f367a94f2720bf7267fc845214ffef73c4cd4373ffafcd27d40424617453e8f1fa234fe63fde915002b8abf22328714e917728c10c88f59e22b44a2aae0dafc8d7a3beac2eb5ba77714f5e4f3ccb0c17c20faa4db52b2dbb34d1accd992ce777a1aaccf61d5e08d57155e9d67170eb365ba38ba4f594f0d0943729604b031900c8ca137ac0fa3526638108e33d2a30efdc58ef4fccf414bf7f1d912f5a3caa42604bced2383e3061d435fd2c6a049d46f3095d37186766685d3fab7685adfdc0264f1e4e6e20b1290be7e4b6d454183d611eee32874605f37cf9cb56670597c695406b9abd0ae4ef22571ecb62c09a0d1e4cf26405033afaa819f3b97e015bd4acd999339f88feb6c1cc64a7a1e74df0ce5d50cc661954928524055d115b3cc1f2ab074424f71c0ac3e909a4ffc50569c7e7439fdf75370c8eb7ad860465758b41f5deea6a64869c1d8790a65ec073256e754e3a100063c0d65140c9f04418315e38ce36b74271ff1341b6d3d8f70ed7cbe4315aa6508fe2197575e878dc2ec57b9b7015f6ae1b4005f3868ff22ce723c7fc9b4411489037cdfd78f5448beef6aef69746f46a8a339be603bd3619715c3e29b55c86f9f0a2347e497a975cee7cde3dc66e44a3a6e2a7a0dba85b07d1540d8ac41014aa560b8da0bb962af11f9cc20332d1ebbe8bc944eb077fcddb3b40a291503c255a24cb5a82fc1ff8ae3592526a0bea616a00b9c6d31d9875dddd204a5346ec47f93cfe026eaf5d463e7e87f4f30b710b2a02d8928fd22328a037e72ce31987e0fd7a968a03c979db994ac1c38190e277914de22ee651c0936bdbc5862ba39884aa1b4e953da11cdbd788f8ef2772208e67b62790ba1f993c334dbfb6c7cfd0ed4ce1365d15d5dca624b8f7d9d2576451fea884bf64f05e0c5b35f147db9ec635aac077fc984df98ce1fa11363749fbbe0d2e0763e962cd0cdf37f6de562164ec022a3bb807c9b8b5c415a212099bf784ce02e211a9754e47b7c02f493b8cba1d183a0e635457769844fecf80713a841a34d79f9aa6df2cc417508c16410a4a531ba68ad26eadc38e7898767b63d8af9aa2180abf1e958cfb01b6dc6f9c41a7e8bc3fcf0784e40645cdd665b0356eae90540bad49e80dde1be26f0709d16c6520118eef8fe367be38c7d3ef8d46438fd0624e692bb2fc72a9c0b68c5d9783dd5bbfaefe7932303ada62ef2e922e2e2d75cd3b32ddddff4022ad97fa9996923a0e367f583e4c0b50f6b2ca890d76f1e8f20ad66a4631d57324da9fe21d75c58fac6efc94af1bd97fde47053406d7b3c0b8d36d6950ebfffb2071c360c9ae839d895223df9f1bf92107ca31b9d7d116d0799211b57a27725a927271ff3db2701d26f32d8518a403a2bf161ed0518cc31a84b7a3cd9e78d73a8e17d0de5f035beb7f63b30f4d816d528972a51b9dc0e8e9fde4b29fb6f05db4c5810ea2d790b025e260b806daae805093b0a52d007a413e198b16fb95a483ae1d0a2276c59cbcf92274f7377ad0d5567657423c95c75b6b75cfa9b8f4001fd26cbb6192dee2a96d66f61e54622d8b733cc962b663556863573906cd43ecb2f5fd66eb2c07713129ac794c9161002c271f134c6d09570599e6e730bd81b00c609221879e33b59871cb480a306c6ac35dec39c5474b4565141ce1c21902f880fdda7e810ee46e83749b82ee988e3fc078dcf38df0f52b4b7a1f8366abf581a9469729b8849a60d626e3c54915a425da89c5884f1e332e520dbe56f70a743743515c280b8e96202de6511fac7ca383e4b3d38cf08e4d6ee83850d654327931bfe31dedfa85d08489101481864ece419b35ece3ed2ab446e3fee3791e49f05505c8631d665a0e5a4a9ac0f996f022f3ea69312ec46c84588c0730c10f2c18240ca2b92f569af331c72b29940faac5c1712b51d2e0778414dd618db716cebcd8525c1c75a3703ad40a940937df6f52ddd704717d4cb56a69f0abea0ebcb09a79ad1310df2e896dfae4d0ef6b2d3986112ed4d9051cd01c9b1f0da00ebbac0956bcf37b7b45f0df445c90ba93c20a7797b23f1f301c79ec2010376b13dc9dd631b6fac050a749514ed9e114a03d0063da1616248b6450504175cfc26389240d98d2f9011e990a1f629afb7d16f953b2dcb888cc6b612b64176401567a1e8a0f7ff6852b73d8f59c4779bf8a4197d0f4131c293045c3c0dcccd8aa5b4caa8055fde5cea45d55364b88ba7f0d03ec72f1396f30a6be13ae2939b9039a9f432101448cd0cf0d51cf22cf866b2cdd00b0a4f808ef1f5de6e73995a52e8d5793d0ca9367c23c9d8ffb18f86291676aa0abddbfebceaf448c2775936a2cc3bd557753416bc16f0b0b85be395b4ece3472afd719fd2cdb1643ec788334945d3f4b21c26065e6adab2a2927e2fb1cc24d0005a60fb5b03827ccdeb3edc97c5c713f588de9da308b88bfef9074b509b0ac0c8eec70dbbef07444a8740f34a11b47efe3eaaf90db01ee5219d64b95c2d5f3b9a0919b3688f50e047adef78828bec4fcc29dd715734c8dc0f28110c34957ec7b8799fe18200a3251ff695e4b9d9a9c10566976100d6725f4fcfd3d91ea8c9a8a50fe0920826b831813dd089de00598194465ecb73cbd51196a8a9a4bb5f23835cc4c33a2aae174060747a3e9b3639e02cdd4fd4965668a77979f147b9ca0895280454b4d09162b1e90c611b055e37f9a841d66af58391e51d51123f2d1744c3ed0bcd867c428c33d14819d330217d5cf828113f5ff913caea6ca27d9e66666f80539701f4a0e241d04d869328703f33c8272ba11d57924c2459b3185aedca9093d889792b92c44b7b50e3ff5a08974afa0140199f0bc0fa9c3dfc8bc274b6286e51726b06858b166de6677250f8ef6c02b7ea574003c2417f1a52a75f8bb9839de92184d179fb438784c1dc3db97503c264a8a2f3f3d6086ec0d212f043d60577a3af22d5719d3f7dc46e742273b5edbde8567150836a8bd7c7c9a545ed42033a7ca8159cde07ba8eec7c9c1e4f2bf9ac90e1d6fd5389cd7a09f0af44978e16155ecbe92e8e4c6c32b0afda566a2eaa84e6022e86cfab720ca1745a355df43ac6f54800c7deec9ff484bc6ec2c9092e1705fadd0eab29b40d2c823afe9a8b35c2a260327d52d204354cf2b82e81e54eefc63974f30b4d2ca7bca28ec6ae97c7ec1307273d252c8527f26fd3edb88e5882b531d827f91fa87d20be549271e260c56a23ac8db91aad2c458ba86346b226854f034b9319f31e71a85704cb403fa821d258c7b3bdcf14c466ecb3b7a9ba46c829b2bbf05cee610ed78e45e2e7bd89789c799121025ab89ee48962eb40f297b308691a81cc50bc58ceb95f76569ca7fe53ffcb406015cbd1fe2f3d847ee155bc4e766f65792301b28288ec3ddbde387ba711802b9037ea06acf42aeffb8474c2fc8894acb9d941a8d031d2ef9cbc3bf58da4b7ff744359215754928e720dc6b8f7678ab7156fc99296d8d15b9b53fc9568a8cc850fe953a919dde5bf68fb45bd7d361e129321e97564fe04546dbac480a6988797af18dfce912660df59b1c8d26c825fbbb5d541d2b5e1f79e48200caccad2310292e920d82ed8eaf3c5d51f2bfd394f6c9d784a79232891005f420ce32efdee75d5b9d93e1e709af95be57b04075639c36d844d8be3b5b8ed1259498886b96042d864580f73a9efa0a78c1590d86127e7d2e85c1ad1b6613986835d73e267d50b891e9b12e02ba2733304660870635c6d6536665aabe2b3158b0194752cca27bfb364e9f972630b9b41e8ad32bd23ba6077250598b9903d726f94ee7b08025b28b16f9bd96076651886662083312b918dec81a5c54ea3363dfb511c7de0878d3174525e29703a45203b9c40429364cca871881405a3abfe2caaeb7715b6cdb29b6b59393fc90247456a2873026fb964a713a88446bfb9dde574d09a53cf9bffcca37b5cedde5a12c9d4e22772f7c17bc1cf84fce411673cd9d1ab41952699cd5fd698c691f1ec978db6dff9bd72bdcb3840ca332139410154236591d84bf12f43bde7cce024afee3d14bc954483380e2aeb42860cdb0a12d1c4e583792e30ce17e59302469541581019c22cd6dd6440b6f1157ecef681375cff30fb5699c6ba30937fb1800c78d8ebb297a190f573ea9597bd2f43842616f1880915fb90b5a8229891091bbd833807704d95d8bb34d372952c239e4db3ec7106455f6c8e7c75937985e9cb4ca9502a5eddb0173667f496e7fe8cd096d306b65d486251a983fbed1bc018ec03c1a8ab2f350421b2c1bed46905b3dcd8e878be82a3c474e131f173e610d1afb7ee0d309e3abc02505387698f0dc3661b785e0d1d2589d56bdf5ebcdbae53aeb63d644efb4522efe7ba81a7e34680bf6e7e1a9aa26e000f12716f97a60315c93c45f3839c98ea03e260e46d6f5612870ef567489bf7cab81147b69bc87867ee91a91a4523e90270e1747299dc25a83470676e5bd7428e1c69cbe5910a895adddac23a24614b65c21b25969b3591ab02629358bdb3a866015277273d36c8a92cff4b89358219bb15e94503799d1d53eba117dc68fe62fb0e12ed644ecca49617a1ea2d4e7c29819f5c762a26311820cbb7520e8a72c98d48cbe3f60e3827681fe89fdc291b8b18a193c6d65a38c31134ba2321263104031bba18f23416d8d1a32222f077b6b846dde86a101de58bd1f3a72cff33e0a12f1012dba1d253a66dcdcad3b0cd6f38efb07cb761585a2d5a1405338b4f2a5075583a4d1e50c9fb5413f9b09fe395585b5334b698a44b0359cfa5eb6df1193153a755b1f500a1be0ca7329ea2fb313267b9e9c61d20a8610f45632e46300958d131a36e1fd07742da1562a21c151a4134dd653b36f3b5f45a80dc2544be6b23071dc855b078301bbdba62822b6a3c393ef98f9ae62d954b68e8309421e06432683823a70e72b472fa1f310a7b65a8ae0ef2afa81132230c40fda4a5c3604cc5c262822f4c79a60cd2472bb16fa84ade4bf58ce43fa93f92f1b4b98d63d4fe805dea25d679e86dce5ce23ccb124a8e48f8388d901826dfea9d91d8824b73f0925e90e0042bdfd1f8ff9d2aca4b31b9e912581a4b1c9a2e96872077585e074164bf2928ba24b7c1be5b55efd6ce43b4728b595dd18e83a7fab43907f9143bfb38cc9261e8bc0678f5a650e537f8dae800931e605d0e4c95f9068965e083ad70222f2d758299ec06611bca5c2471c91693137f140ee3ee38326c7f439ce104b4ec1b5b662c91b53d29cf63d482aae5ab76c0f0a6267ff5322074729c90bebb24196912ccdfeda7099c9c5bee63acca1273ccbbe9519290ec96c5e4253d0ad5af01894779b53cefeb8a9a092282fcf0667d8771f2858360a3b6c6172c40ddbfe48d3e57bba8f9dcd30d3a9e6f9e3c2f01c6463ffd115800bd399e14df3c925b6fe1b3675d5dee5fbb5f302fbdf9b54dcbb1f1d20361f4fef5a7ebd6b7e60b7f8a77ed8706c4db081b738cf78afcd9ec5d2b97a0a3db4c2ca83d19796f5194afac76c69752610e00edb32d29683ad8f127e74c3fe3544924939c98243720c8bf7ac895ab0af2571367fe2c86f9ab2b0d07f2846717e38ab8a4c22010d2c80c041a4fabce9ca237ed968db42f381996e300658550c2cf672c2cefb12c797e6844ddc4087dfcd8938ce007879ff4d7ade06af860d51d1e921317207f738ced883aa08b85824c9bc084fd36eccefbe9df16f2346ab9a60ee7d62550d08476ad877d6a1d5569030aa0fad8a2a7b9d5031616472efb8c753b23e8b297845a02b6b42c30ac5c72b8bbd7eb8ded6b8c64a368aa257620df1a3c4fd8361154b066392283f44e0606adbc45da68f11c015c24e39db5878074356fb859438c82b03d7d3c135e26466b387ee2e91ad288e384493a4d2f42eaef047b86105a4dc51ff0ffa9b10b9e54bd993faf42528b5b3abc4bea6ecbb234b4419067b122062e92d4ce242dfdaea12e8427b5e5386765bc8eec93ee3a164d0aa047a6ea8c0d63b0c2e3be3e8c0fadfc8bd74241550c51b5da62f1534aaf86a51d565c97fac94eaf0383108057a8cdf77a15d59322a1b2a9a350daffa2f93ab45fcdd53a005eb2b4825044bbe6ac243fa56173cf21b44961a35fb11e03ed4c78ebc917a85b60ee3c84ed2e68f6913c5b1c9b104e4e2f5922cd454d962cdfc43b927f3cdc7845a072b7697ac88ae358ed96fa55be341a5aaab2b85067f2cb246e81f7cece9d5d9fe19e1b0a14f48ea71ab12ffa04db0c72a86ae610c93e3155ad8a52343270483165b2e3b775c89110dbf5c4eadd8a1fb96b16401f1a47abcd91cfdcf3c46ff2a50015ee44a4a852bac1393c06b17a7aaf342d21f7168e37fd48d337f5d99c8d743c1464882c473297fe18241cb98a057a200dcd3f3b602953eb9746f10948e07080b0cc1f454cd58456e4e294cc7ed08528761e8a2b9291a24b44b104a2e0f20b2619211d1a449ec7b069552203239a8c82dc7eefaa6f09d263a03deb723972e43929c31dbab01d190f3770e74b34931025e1b7bad76610149a2e050be202da4799162fdcf5e54a52f0f0eb83c8894de874bbb2072a62a3c5d96b4bad1f4c3f7fa53498a938466b8b971b0223ea28236bb37982fafc29a0a2960947d21894794f6cf57f0f629bfed5853a04e936bd0a7a095b0c413a72c8098dc6d8c4877d032338bd71c6841910fec380a2f42bb3325698410375741aaf59b5f4193b54e0467753ed5e7793897f6bec4cc7e92597476c86a63577f12738ed0d64d82b856043b28f00a9f447ced9beb0bade993d5c7d627ccd192509cba09eb266af630bc301f03d23c471a24145abffd26e3a3589957c324fa3986914f53a0940fb363c84491f63b31da78f66c3f36d118b53ba79a928582f923ba67a51621b8562a1d8164d2bb032868c902f35b254f077c1e46cb14efd68edfc12c4d9216093099a713e353f5fa0a660ad097559ccdb425c9fe335023baba1290d8c080795125ada43cdf77464eac9b3918be2f52862d58f3a6738c2e989a450244e142ca913a1456dd800c77cd9ca6447cf42b4b6b124295af70f4d3fe652d8a03dc7b4506a8eda95a6dc756084d82006fa5b3887005f6f821408aba37ffead95ce7f97676b22ad95d5ac1b8835c182a515ea6988ac168ba6b3b60422c61bdbe082814a17762ac67e0a469d829bb9dcb4814cbb0742d347bc94ad96b22e657bd53fa52528e4bc4ccaafcdde8618bd7246390d6476c2e69737725460152a164b55143876a3952fafa11630beabce8414c22387194e24661d65aa02efad72e52632fcc33a0ed5526f65a4194826a3a8ccf30377fe4107e103bb9c288eb0882553ef1fa32b433114280668f2ed3a1dca91c277d38260fda7bb853162f358d9876a26758c32209968e95576aa8016a48ca3d38dccd71c5f778ce81f84741dd46641b4f61a34be538d1965f31b3f90efcea48bc347ee871b36c305e32efa0375031661a184c2fb981ffaa02c6193c17f53004860547b611267cc0ee6467706b8c7982b3dff3aff59510e7a82e7fe3006defff83a01e3671d0147a874181a8606ec160db979ba39e5c818b82e03198b44ab6897bdcaa10ee865b3d3bc5f5372b4baa70e602f24bc225724a549af187193cceafd0fa31fb4898dd771cec363155626ac46ae5d94006d1f08b08f5b53b5a8fa5e8fbdacb007fd72ef64c3a6e2e5ca1286730a9620ed4d12f8a4dd0e0b794e87b5dab6e066d140470a6386c7ad170b40125585722f7491d2e6bd87689e3c55ad715370d2c322c5ceb9fc0fb9a36f299071c9b6663519e46395de30bf3dc0282770ce892d23bc90006557f04ef030b8075c3a695cfbe00f295784b36de1080cb17f0c648bf19c7399097702474e0ab72a97c2d021c4a1e1fb38fff807156c481c57c24e49f3b533bf387bddb8733a1989860071c40419f5b1983ae521f6aa13244c6e1c612b52c5a853414d987430ddc7b3231fe83d9126a74e1f0df26c70d1e6af1464387c104295d41e4af63c0694c0e364399bf2c9b89b5b4c64b034e8dbbc654bd736d82b98a7c6df4ac411ffe6b4df3dab24d7807d14d5b7ffd1f3bdcfd4f15f987d34625f8bb2e13b20fc6ed8cf295fe998569fb2935b9453a987e3593e9848198acc06801a11c001ddd6652037ae4dbd43d341536da588da125aa84eddfa9a375949163722eb99e5b71c6caafa2de21734e4e57d10e4fbe6186cf42197a6893c1e7ddf5644e8307d42d0aee6e34dd91cf1eb8e78ed966e6a4887aacadf17c38fd3634fac511c4a763ba292e25b6dc1db16d29c2574383eeedcfc79fee93f0aaf9aaea317ea6be7f2ddc13e16ce6f9de3a141bf7f5fa7b10eaaaf8946746388ad3c0639fb76677306cf0155087efbc18d0b5fb0da675c1b034b50cc450ba677b9c4f6a5f3b6478f251061cfec898f4a436bf696c59844e3c9867ab5e7428ca419fa419f512cd8fdd99a79739d1e006f412bfb72084f6c29af695d671a050dbff2642bdd64a8118036b26a758d44ead4e113056ec8345fa3d8c19a33c8f23d2862ee28b5414e49afc5367aff166da58241c6d79f77f13ee1c123eeedac24a876e9a9ee815d35963c920a35dcfe75492531e9de8f28b05fecd6129842305c5f32dd68cf78239143a092a7cdd6f7bf9cb3b2636ac3d4600576d5c6c3566812cbe286b8c748acb5ab018a3837c2fdb51d29511331c924fbe52cd3dffb1d264f6bd0d5aaf3263c188eda39216c64650f3395ade193a4cecb4c56ab1d04e84440ad7ce447e55ccedf5654ea034534785fedc3cd5e99beb6257e29def0e89f6f4ebdbf9fad9409474d64894bcfc46457d300ee8f99a91847034f8b00fc42c454ea9faa2add5aa1f3f4dde66376b5d50dc2e0f5020ebbb94ec637a4ca5cfa85e27f543881a4e74ad098ee30ab28b1de2cfa25f2be2185e29c38254e5c649a99599c901e2a0d2955b06587f233a5b1ba860475151605543069026f1ad391c51569d0c4ee3a37e0549148bd6ecf388053d954548687259bd6bce88f8c8960e387510fd8864bc7d1e5124e0d804f0007f6335f3edff939f7a7d3ee77347e256745ba7dd5a127b7d1ac10192f5df43e70d89d9b181c3f02397cd86d46e374ea0472acc72863c0a7d065197265774983ac61456d779d99b5bb23b919b7271b4ab4ea338dad17eb102b020a4cc40f6666171c85512daea3e60743bf0042122ed52147f60c8d5a7732a62c5c5147ecb6c2efb1ae0239adec8f0e76f9b65d910db0220f4f0a14e68da97f84cfd5e2587cb51dd25a0d1e05be2a76649db84ee5e1e7f91542e8e71aea953482f629c7c6459e09bd2f0df9c4aa244e1c4d1d5a12b249d30d07c989ec19df30543642ae8886504ba0a3f9000f448aae80aba2ac29a56a96b9ffb1e370e471ffd14b64f409e1b5e75aea7d8eac3c219f1cfdb9582ced84716daff867057d416ed78ab433940a559b490f4f3c8e89c9e25d0a4769dfd6c501c5ef58862a58cb4d3224a7f4fecd0b09173fc070a8b5bada53d3744551be897652de705d061123542f289432d440cce3e9ec23111ac60633e962315da76ecbcf705da0f63e1d3b167d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
