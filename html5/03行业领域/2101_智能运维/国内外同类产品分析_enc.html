<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"845b23790028bda9577928fb484490bea8ba5e324ec8b8f018cd9581708feb2c9d1a1f5cad8730030f056ad974b831672fdef81ccbb1ea663d3a02a62a645dd3e843e8c3aedd3cb6bb1b977cc1a7a95fdbd852c3a115178ef2cd4a40f3185dcafe418c29de2583a05ae6191a76d1c96fb30427e4b43ac5d02e9c920b7ac329c409df9ced6a64469f5eb2919dc13371176a08a606f86c21c3e0b5f75eb0657f16442ba5a5467ee2f7a7e6435276d752b9349f22d049b6a040b71e4f07f48ccf691d4ef92a0c140e996bcd34be7f25f0520f762226e753233a8361495c2fbe5d0e4686116d59de290e7840d41890d02e1d3a5bc06b7476a4df18cfd45e6cbe4484a70ccd16ff7675d7f874ce04a809855229b9955a0b0113d096d593d4ee41d34b115dd4c975452c146a943def1c5902e0959d0d8545846fc6a525de4804384804f8688155484417a645345ce6208c7226a000e720b4301eb832b942dd5e4736dd5f16e2198e645fe88cfe8a9f482801e1a20ee20d7f4dc08a3806e2afc34665c3c882458473e7589410b592a312e10162d896dfde7b0d2247aa7a6b02090538657878dd33a9a67a70ef4ffc78988078c7a96120615f7bfc8bff278dc0b0e21b61c8311af111dec25d2055071185f1702daf1b94c52c8b7b1c8bfed357a28d6ea27ca92dc6d0ccd7a7e69ff56fcdfb086b6f3520e3729ed049cc2bc48480caedda13ad20be0ea778cc04a0bd5346f6debf97bb56bc08c8e556d65025d961a2019f1132ce9521e81edbb42037c27d8fcf52e84066e5f20f94a24acc5e4fcf05699b4680c32aeaded2649f059a4a1e0fc8ce092aea46168731332ad6ea154998b3d45ab6b9920036e07016e6f14a586b5181e3919981e20215b73fdb1bfa82245e85db08c5cbc25340bae137bd7720c0c5d3b590ac8433c8d71f32cd71f9c3483dd19a533e387741d1990ebb294146fb4b17acb1e9ae5ece2ffe35080c520c7330a850e68be969a242d81a6b96dbb7e5371e11a44a0dd616f8730189fa56a68bcaefcd6ba21ac62301eef0833b629db239b9141b7ab0ceef632d6321d7c174b0808f4f8ff9a7a3dd95eddb458217c86aa78d89efb44278e5f086e4c114631974442016d1b5c5bba693e9072461675aabe7b55111f09bf2f4d645196c30627f3291d5f1a324f7cfa3a0dc3aa23b2d1088ee7141e8ba8dc14b4136e7f8e67c3e4c75b4e2bfabfd9b0efe38e2fb43782a31c9fcd972418e28bc7fa0587d7f8bed13a0d6aa58c884488380892556773eee33a151e65399bb0d7a9faa048d912d14db35b6df5864c4a08e538ffe4ca89b5ea0c41455d50624be4fdc43eadff50a1668aee7670801f5b9573b69c7fd235864d02c7b1937e03a98260beca66ce1c40193e803715dba1a70ecc48bd84d4e46b035f3fc479e4d36c4e389fb9b8214775bee2e726738fcb062e977e7591df5f3b4efc4e21e34cee2bc209797be271803ea03cf409930781106809f2291edcf37cfada9bb74b50f0fb0cc8cd8079b88ae455e5dcac7f02308bc5ba67ab4f04a2722bec2654c0575c6e9cf6aad412a9acaca72983b773f4bf49f5be4bfaebbb78092bcab536d357d43a4db332b12ef1cd423087c64f7b7e27e87c9e4795340b2ed90325874a0a13e16720097ec37abe7834fac49d8f354f20bae77ec23f04315adfb7a5dc110905c758f5f446e393e02c1f8541b7466571989c939721ce4e1c20485fe5ea9ccbd6ea3d2e895cf5c1ffc49356ddaff23c8c6685e8632c243f1c6cf04cf69338e7011eb77237e71738451d678c660166b7b592959a1bec001cfca7c9cfdec55097c1d89729ba5bf7cfdb8843e4570628ce647bbc3a2639c12c2085220b939b26917a85ca8cfb8fb7132b47f9dd6e2f3dd6a522f0f3b62e5d4fa17a2649c05c8610fdc4bc63e037adb695550049aab81650f3039c58f16a6dc0af03e77b9ebdb247b483741543ef2526e29d15c3cef259ae0fdfbad7fa8a8d50d291499f59b6f7e38fda76e6815a47bf9f3c090bc476ac5c7fd5bc7d347ae7958d74187010e678a98cd81342bc3ad9f9a8422a80c5524a83562a203edb767ca7f3b1bc8cc6d4a76d640a59778648be4d7a4b26ccd228d1a5a83ecd2ee39c90298b30c04283a136302794cf3b4b34c91e3fe54691e6c5825e0fabff47149170909c272d2e16330f7ec7124b3ca430dcea8f9c39d71243952e446d8c58c797fa9b61f49cba97ce4ece77704142fe59075a3aea96ebce9d4417390d151b486967dd300dcc670da30098b9328a673e1a7a44fc5cc17f07d2e02e26ad0cec2cf5439a8bd9b6494fcd7d5c5532064e6597822f7ec0fd0f01dbfa2530d9f3518e847d36f205c68cfef1f7b29e16327a7b9522cafcf243c3e682091b476797013a0761489be936dd6577107a759b9bbcc8428de788d4e4321c960d4fa3341bc023d617f253a4f44250937c83ce7a9def271b840c66000a8c3d4a2327ac305c88925046f243eeab75b99a27e1e9db3df44e28784514da1a49a0b44aa32ed80df67c73f24c6722bf2b9acd61d22d28986710847ca3f6f96fb25f5d6cec3e3178a19d7c2d3180fa71790a30dd8636b79698090310e827bb0b984a4193f03f74d5891858812ed3fa7faac3edee63328917edd3679b82c8035c166b38a615cce6ea1055aa314e39157436d9dd5c1f74bf79d38a9c9444cd29960d4982db5ca5b8b015a999a714c12408bbb5818f051debfb657c681348de669fc70afe016121e0c31953a8e5455b5c4524036d2de07e846071e56370c119451933a8d998ff9f945d200216ac6ddb16b6248b1347f922e779507a3952db46401986c12837399226c8f2733dabe5325a473b75322a698ebdc776baa567dc69389306d17740865e8995092cc89f986b6e76c3df76bc811acf70eedb96e33f492263f9da49ae4c4e5fe92491556f48e067357c6457a3720c59d4c83342c15be649e99eae5c78d1f850ca9b17eb1c82139f774a58c6c082018952f709daf8217f89536b4e719e18f73b1f0f04b5e05e79fab1d8cf022112eefd37a54abfb069b1360f6ba6ae11fd4431f624f7dec04058ea132fbdbd57b6e6411e07ebac058a1ba50c21d2bfa1f01be064dedb9a74fca30b7708002b8571813804702dfbb9463cd1a1e0869f84e25bfa20921213103194ca19eebd5c3f876d0fcc68bda03a4ebb8b5ca2ed8e8855f9e0dff07d75865d2782e7457323c0a2c60b44ac44332c465967437a1af6cb275a52430798c09dfc7a16a2443d4e96d8f74217ce656712a977247fd8e35ec5c1483b3566943818293be4b5eded3691f7bbe17dd91f2a4e4e8adbb26c2fe7673c89b1d80fb01381daf3dcf389217770a28134461fed7b77e120e8e1dbcea29b725692a67fd6603177f4b758fb4c4fad1e16e0cb02bd3b408972878df3302b0ca9c9dc50117f4699fba6f664a3390e20331b9dfc67641a81d7de0ec644d74942018d2a0983b9dc08b9ec979ceeb8b8aa2ef7d1217cc0a4457b0dc9bce4e682e6c74bd0caef85219faa6e4eaaffd19a272c592af6157d71b03c6251df7d1d2e7215a9b9c48363b0ff6efdbaa35c65851c6c136b2f11024236d49eaf9102c5da80be83f7179f5bbd3bc3b0788151f1529b46594c0ad01d353d4141f45079c6ef9d75f7e053b26afd8d2b4b0b96b87a52ed58ffb8089c70ad6f583624f090ffe3178fda45460193c288f9dad80e3678e50b5aac7cf81803f1810dcaab2e836fed3926af9e4fa6bfcb822adcb5f391ca2f8f45dca0818adc28452dfadb7aa71ddcbc867a53dad2c9b049e14e7fde07548ee54e736a888e4152164d523c5b77940a11595e3ff1769403948a5f913e164aa4b65a8dad26278c4edccfcb130d232f538e81f41027483a0f233a6db90eeed729e173f187779f31a778c6d8d47563baacbd8d5de1f372aa5591221ecd62803368b957aed83600e9dc42059a51e4c652d75e8ecf659fa44437faac5c58b8972a36b95802d424f3eddbe5c16ce5cf343f04c435a979dc3cf0919a2c4228a6bb3e968e7e2d4aa8bbca66758b02d1605e258a12cee9cb9c75604904854a6c311cd183a3a66d761b05efcaa6bec782be8e308ff18af563b6f179d4a251b1d2b0d9082f089f141a3b990104bd333e5bfe3b6e9296809772615e32718014e3b0421a352759d40e581ed53895b033890345141053d6c4fd0419ff00620925a9d0e95411e2c6ef26101e43c61d7fb061b926a48cb2d6774d05ebd4c3d74eca2b51dfd2c753a975ebb588d6a0b26a787ea5db8bb3e88c6479ca31d56747b52f8869bf21aef1917daa20bcb4585edaa74bbd728ff85801ccb61d0039361b4cfcb173ca480b542c80c11a2c91027222b264a94dd48720277a87b69ad12ccd19cfd0197d2e0bb9082f35c4214850b82b910e4ae7c17190b14373880ba2aaa00ae92d64f1c4dda52f4b1e587bd7b88c9796ab32bb1076ac48f46b7b83f1d206e9990ff6fe11fbb6bedac8eccf94bbcde6013f42345fb1b8ace3f7d158010cdaf0e460d16b77f8e01365fb5641b61c964dbf736d822ce9b82f839f43312f6b0b34ff9d078ea48a5d4b8b8217a629d811b7e6fd20f1af459b7c9c38928f0bc7ccb03717ad4995bf50220bd5a1a2868f5eed7d62b679d136f844b187464156a98b503dff81387d9eda0b83867cc58fb51562330ef47db7aaeff8c7bb4bad81d97e105b83027874cedebcabab9fa9b3f7d827536a78111537e61d7fe7aa5553d4c835312bfe12c576a589726fa0944aaf088c9ae49347c75104c7cd3a77b1b8feba6163b119f4e0435420f01a147ec4a71a4f56522f9433beab0bccded48b9d481bcf6a2153b90e8263a357dfe0367440193f9a5229e2a3fe640de80ee73ae3270d2b5d00ca58bb7fcab27487f94e517e64dff88f72a270689a6997e57a0c3e57f57b0eb3fe1f2beefd2eb2438ec1cdc67b3a8f5414ee0bfa1454c3956bf387ce802b45a419e0fa48d6c3e75e376979ecac33d53bbb6a4059c7b298403e0d1e4c018671bb1471b91e77cb450bcae91e7879ef1e1185df3b7636fc9dfda2b1a72f1ef7607f1efe5d9a6c52cf398a61ab8ce22023b814b423e7507ee35989e0170b2bd666e1bc17a187d4607cab474c7b7d8363442d7d31600661e1f0a530bf7b6ebfd1a01efb5f363a32e8902dce4b46a8b15096cb3c68e641ff25bca5a733a5e9a92f2ea0500b7108bff7b7b4868f99f9e9aa26d6128b39a12d0eefe5163b3491c0ef165d3d25d9612fa042449451c858ef828415ea35f96c097d944cb9633bcc47a5904ae8e08b82b76c47dce1c9b42e3c0b09996f3883fac02887a99f73e34c3be079109865321435e3ce6da418c6dc84d02575d580f6f7dca1ef21abb82e6bfc5715a39b1e71d01c85b531401eadf43662327cdf4db219ece26330083265d99d946798e091efa411ff88e4ae3f45a497775f3db25c843f06443e719a8f94548e61f9e41d618f09b4544bcee75f2797df8fb2e8a9c74ddc5880e0bc38c1a90953dfe75190b393d7554dc52c532eecece76abfc2548f26ddfa6b4f9d40f0f1cf2019acbba1a26485e6e143e0358313c1e65d53da87bc6ba29c93018ee8c5ec5b965495479b02f318087013ff8ac25bad05d6fafcf7abfd6c85d607baa73cce8b49da7ffe1d8bd1023e4fa4a2f0ebc25256fbcc9aca9e6a0febce8b26963d1cbb0ac246b5b899147cc7b174cb320d2f3e2169df0fc84d45c001a3ddceb01c8d205420e7803cff50fccd5e1ce49e0e96b0c697aca9105dab601edc2d8ed071d9f0b3addc31a43c0b115518f05bae227d177fbb186a9b6b85d29febe2312deb6822419ac5a9487deac4b4ca36f85c80c96744d85764b84321cf3e1aff44790c4411a2f12a9e8a0d97872ec6916785bd71f79cce63f8c5e9bf356047aa1833ad0b5535d08e16b54c0c15c7e25bdc212f38e12787a9c49a14162d3cd68de8edca71b264625cc0ecd25fb2c3700ccd4388854ac24a578b5ab5d8d80c412d89169dc80a1490384cc0590968c86ea778a570207205e67b8e40c260e79cccccd12d0c8d184b5a14a474508c1fb442ef966b277f534e1d69399fa19fb669580c508e08ac359441d720d39c50d5ba30247e8d421dfecb862f245776ca37fafd684da2338a0a148b8e1fd989b885f5bb47b2bd1de36c009318819aa013b3869219694be6b81e3a031f8a35d657831543d716596e17d1ff8eb94da1d86fddf539c2339742a5f344e282cbd8765c4411bff03ec8e11359746031568dbb181bf502792675d92de7ec9a3512041addb488531ebeec222643290f4442d494eaca9604c88de45980bc21dd342c7b8750c225276774f2afbaf9f97a8f0a7a8331aed00869ca48dbe9e70b016d74d6ec1a683110bc1a69ef403727b6aac138905430f232ffa83c4b7e6f69bc5dedd521644a5299a49e7ad0fc7c7b4beb24c3def1710defa89b5cad681811c57cc55c1a76744734ebed612c3e9dd138f7e511a8ade492756504bdef9a8be0b829087a944f16bb977dc6fca2a182c95c72e6cd73d2fe18ed683caa426a8b4b95e036ad59be3fd420b42995ddd34b6e63d5e8b11c2e2909f31aa0947c18e8774988de70b1687bde804ee9ddd66d1bd59ea0f7413527f5b782323b09c8f863f0d355f6535edf40d0fe3df863946eb7021c2e9a4572f7ebc4102e38133c4c031ae8c5c384f910f0640a28486a7acb5eaae6d59e1b0396cd92eb95da11d269e3007625195edeecf537d65de65cb1131d1efcb53564ae273f85fb5c446a2c2d0732035757acd475408d45f1bf4c13296188a94d8b0e870ede00d1a5d5f15db88ea42ff8b30d2a03ed3312dd83f5959a55115b88ca8ab1c29e7de45226e317c01b988c707730ba4d6192db471d133ada3cd2dd65891607c669fa8152566cb92cfa7c4fb346ce96eedb9a066662dbc61f0acfd61e30e33771f72caf957ae5fa9133fe1869db656db406b44f7c67621d7ad14ae768f92b11bd6a7576f231dc2d811a20ebe5d53dbd490470eff0aed37b74181cd6234e5c5f6a7d237116d6c8da23e3d02399120e636f776a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
