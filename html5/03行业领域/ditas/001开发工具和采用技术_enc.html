<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"083ee30cbb1b413f85a95cd72138d2ca8f8f5cecd19fd08f5814ba534da1336d523677aafe5791101186258f9cc8e264ec231ef1b3f470985280b1666a42cef5539c8c064f3c3ad79d93f3c69c596e14f4ba33b0e03b41c35a06e9d213ff403a7423ff2f6ba6b603f0aafbe84b524d8d00aa2c14bbc50bad7f152fad271e85a2c90c28b809bf1cb18948898cdc0475d4768680790fdab64815ef97e02d79172f10f7e59c69e4c3b19c9caffd12e1f360503efb73ad81a0d8f5d7efb22a071edd5d488ea45e72a0628d2a26dd6fbf94d75814d16910bdd80bcbc897a57173f54f617efe7b59d01a1b390103a45d69240abdb15f1cf312f0fc480010e15852ce0d3f4ad7dfc430d1b9aed68e7d5f43a93f101f5f41e87437b2c2b5d1af31039224a05c39f04b7baee5d1b9763a98876d5066a4d6c2eeb021cad6136407079cfbfc5bd3a0a2e7df326e9ab16acdf79f18d6ee2a0daeb5b57d86ce248a37a8129f21c502f66306e9c2acc48e2d5cd7b9a98bb061efc3543ea340b0dcb1ef7b72c2dbbc947cb47f31e14fc8f4e56ee2fffa6adee05ea426efcbb5429200bfe4b4c6093abe0e7a35741b1edb2906a0f954fe81dc55455d0943aed8e5881f502b270cb8235d896d34b688d6567b388c2951dcfcd3d1e396c78b997fffab8dac8103ecb59b79672b4a199b7924efffffb33806b2b0d2c0899021e42fe9b66ed9378212edf2d5fc836e6493eca7722289548d81646cda2ae19a28b35220c48a6b75ee8c36c45edceb7d58ca0e4414e2bbf8c8cd7e14d6e2f3ac23b22672eeb5e359d4385fc69fdd210168c10452731c280da24ea15a00f3e1570b97e88c63b1ae3d16a4e21fe94de92fa1a166d194c1497c1208374dc7222ec11af0a0234098068c83d64dd3b6bd6dc77319730351829988bc2b0a7642f1ed87ea6bd97a3db7a01625a137fd0cfcaf4daa126a04f2a4e9edadcb680e410418af261cf0784205477522b40110a9522400d4cb68290e89abff45821c9b358b326f64bf81d149fbab9b51e47dd0b99eb019c347b4ca4f33d570a0d6a27d9d0ba16d91e2df72afd40395109716e67ebb4b8bb57120a399fbc6fbc1fbc1d18e3aec0e761ace8ab90fd744ea58d3e33c52735a189c04606b7866487ef188729abee9b65b3cd816452ad44709ca8effbc856da51995c64028fd11dcbf481377f08006fc0df86a13f260fe2eda0df37c207fc1009c9b2d6919a6e74cea5f80af93daede6cf4343e54a7d8cc764394b9686dddf6ec54ebafaff48b33ef0674829f17286e0abb5df883bde57729c0ad2816b7d2746e412f7e166074b0b52a773e51d6ff13a28972d0ea07c5fbd8b2468ae183053d3577132f0d7c54751372c317fe9ef3b85638765c4d08d2b27f0aec5c24f4b85c0dcc6d2a4c9c389d446bfc05c5c94e4bff5e8c41a8aa615496aabd84b95f915290d93dc0b9d396bd7a520587f562de0cd355e2bbd7b42985b088c15e2f551eec1520bbe6f3025cb740a2e83ced456d410a59a4efcb1c9a7063cf7a007c732f4b5c8047fc11f9f771d66de52e9cb3b1c9bc193c438430f8f76586d32f67d134b6be6f444f45a4b79b6ebb827b91487c271d04f4347413755ad43163e2734f61cfd31aa2a320050cf6055d5f7b6d17397a98c4d06b56931bd1f2e35570549e6d42a8f7120650cbcb9ac7d6a795c716c27909b19b19bb24c5e70f2450a3a19976e0246ec86634725935665ec634ec4e030eb3c6d45eadc2c327ef08238eac28124a27ea7e074127c6217b6ae51ae21d4d57f84bb2af56adb6d40dff61f0a5595129ca80d761044b7382fc0ea494ee87ed69da1ae21520fca3db3cba7efeaa85a924e33a5a26ec30cac24b80abffe19e3c65accdeca2edfc14aacbf36d042a103517421ad337f7f6442d1e499102177292089022c13f045aa61e9f91f36b29bb69fbb8c5974f03da728ea1e4d709e1e9e1c8319d6864583ddc602d59bf54d7b27e61ffca9af34d6fcb6749734f28615c32757e8e2b6bd7bce5a6aba8a56a0a599c99261b53199a0cdfc25bacd3444c607b18c748a284ca15768cc33bdc04342c8ca097374a2f23cde652ca030f0ec34688fa098fdc4e3702bda60187e5315721a71eccbc85d5c04a9648027f129ff5ec1191529d2a260d9162127ae1d436e68ebefd076029821871ef7b9e98704e6abe4f35b564fdb32e5bedc5478fbc825975eea1ab3a3809e70b7432442f935f7c0ef6478759422a7884c0c49e84b4c081d4621e0d9401037b393319fbe7a6d3fec599d876795108d82a6c281f95847f0e0615ef940ac519e632f496cf6e45312c173a42e68575cafe6039ee939b07cc86a01a2ebf216ca63bfa63a2e1ac0b0c465746d3cd3e58f77108c2bade2aa4e00abf1cb16445f08c366a807b997fd4efb50a380126367416e65bcc03ba4d6c8f57c0ea6a3fef16b7cee5ca0510fffc11e3f14e632c1b7700697ba26aa290e17bca2300f94007b661ccfb366687b316c6478dc77e7da92dcaf16ffaf8f734ca9a182697a2b8b511d324a851c21ce438dabba9c1325e4ffdd6b9bf264473d4f4dd53c0575e54297d445b860cc40d3f5e0d4d16b5a7d7ec139ea35e1d4de6b9daba17bbf8a7e0f0fc44be092dc9d9a7bcfe7bf37d47597000e9ed16bf4b37464b683e688e37fabe0426a78d7f0ec504645af4c1421470eef15d425bd655a80312478942b9d265319967e4692ba060610157c78eb4a4fc366c505914aec1bb4ff974a258ce03d69d759604398526d949c26ae3c8191d4bb7f3c5f37bd8162a74db264d84c632aff70270b59c0b50e1df099cad9e1492838a4e028fc84fe003486040b63f4cca9897bf61b1860d5f868b759c0f25cdc065e1387664c62633220b5ee6eb88cfd430f2aca9338abe157f254159b9c1e53a605a766e34242688d1d2682b541a42c8fb4f305829ffc0f13d4bfe16f15ea04bebce6a3f2b706c2a2b1aa9ce5eb442c50cd4834b1c7434bbaa10531b05d66c3f5c02dc17a91d1ca34f20c03420db066699ece664e665a9b9a78743d1dce7b9a4317cd78faf4eda126031b6f80362f204a50f31b711ecf53066f89a40fb95fee93abd6ad4c9eb35795b735d00ee82f2167f87afda2978fb49662293a4f22344091c70fb55fe80e1cff2ff2d73e0dc5af564da853217f454f5bfcbb22efd09289a9e83fc79c135261a065e949dd6c774a6fbe9b3a8b1fffe276cd10b14c61f20c636b82b7cbf3176243d30918963d2041e69377bbe923f5077e7823010726a06e606723598e0a87393396fe4dfd56936d4910dedd5553f29c639229f3cd6984d21cd9a8796acce6e0803f8d4cb766f07dddf7f6626b7ebcee5069826d4bd7b8b80e00a56e436fcd1b8ac575bca0355947a68b1b90abd393213694c7b735e76f5c4022bde2fde991b2cdbd648078228b5df049fadbd999ec12bf71bd21a88acdbb623597de2e2c289efc08bb38f3a5ef174464242fea2500eaebdd5880267431fa3ec2dc38093356ab5b904fc58d4434d257634125b0a539739ca28cf86fb20d93e8f01cc68a8d29f18c91c55aab0d27b8b8e1a79812efee7d7799db764c181185200c7a2ff714854f64f54040372c5c7507d80ca9c885b8cc562f6137e36315029855a8228885189a92ea5b95134cfff37b22069dce94a47a7f0d4aa0a8f3ecf15d844ecb9d2fdd5a59526c4344bc25e1dedf14183786a881272571f9be305dba4821efee00062fac1470816621e0bab8b466e5bb020ecd7b556bcaa50e3a54f78a3948bbbd3541e93ba3b4df1b39b5ac4cafeb33b59f3601f750b3771c2828c4924cb055b07e38fc326a72b8cf169a4de4b5b976c5e3bd18c04c425df13fc85122ed748ece0bfd0bdae02f6ce9923dd5ad5dfaf87eaa0e25756d87bc2099c1d94af3761eb36098ba96796f8f1b27d20d5fbfe60398e0d80d2facd88af0dd31e67e1f65925421fae13fbe95ed60c5418651ce660d5f3c31577b724a1adfc8298e9cda15c13349882087af863f9cafb9719752d280e31f629ed8c40bf9691708917626fa8b5478964b15c8bb99e2519819bd3690b486e7069d1eaf3b65c293de34d98acbbe7e053d5b10bd5b814bb8bb6d2810dc16a5b346909d5abcac248b28fe714e1c44ce999076b531987175488a5715cbb47d67f80a99b26777bf2083b61ebe4d46a6939a95568e4ac570453ee8840f186f5f5d4bf7559253b062baf621fa8b962c737dd9109da45a53a44739d0b984b06cd5082beaf25d64586eafb540039a46ffc8ef947076943c29761f708914b94a6bbd4a719eae5caa4a70f018c5712fa4c7469a057102d2ff550078768f736c2c7bdea2c44b88dbb618b533ea90ce8047950774f5d4656aa8e49fe38b4a332cb4daf551938ec77dd7c7ccc74713a97a5e48083d9c2f4612f65a84af75f0cc7fbb75313e9acfce55fd2723f715db3716aa0a0b55995cace9a4f4e34a46e12cb95ceb73ce2b41a733c91f65f29ad5979f4f8a1a394025e75420faa0f86f313fcf9270b6e4fcc0b5f40a362b992852f5e28885f4afe2b825c19f0acbad368050e1229783eb36c41f39d1f6618d64535acd2c90cdf67ca7fad1134a2992ccb71257911cd2a8c6f370c52024de3470273d536835b1e16df7dce89f36f4428da14cd808a3512814be59b337b68fb11284186df5bc689695f0178885129e52b83200de1ded3574de9f4522abb974f9fa5bbe0f7442a3ba830b6b53a79822d0547c148b2c757e4b379b1a7b40f033920968a66c4c33c0876de4e308ef319ebe261add0bc6b5b301fc637020a601e505f80c12f62a2560da4f676a2758439ee184bdd332172be3730b85b99a7d1aad7e7bde611582f962fe0fc88959e13edceaa926f07a3d7c1509f37984552add42d14139923afdb054ed862fe9998f96ef70428b44b68bb656e61f2f9e26bf918fe45c162bda0dc9b09f5f352105049683b1281a2f97e5a503c153ae0cb40fe068f28b159c53ca19bbf9f1e676c81becf8210d6cd3f5e3f5930e80e6ac6b9552566b480aa7fd9ae7805b9dad2dbe2dd98093bd1f39af493704c41da5128f672c1a9802b075ff4bc5ad5efab9df7363aef338ed4eab390131684d047bb23207ad83c7119de873b4661d2ba69c4d01d7e91a06233d7a0b83f1b58d2bd40f00cb8f176179ce50894eec0ea39ab5d97bc3fe0dbaabd37e41e598afdb84a62dd5c6ec9968bbcbbebab41d7c64e2226f50c1ae23e8f5a08e6e30a7c4665b2b80fefa5ede5af955ae7ae1ce5177160097dbb7e184c8263bf715b2df11f00bba6f06dbb70689064d2c408e85c0489cf60ce186d48e117215172b12f706b24bedcd069d9c08fc6d4f6919a3924c992479ada430165171a72713cffa680cb3d654a3d6df79b7472b6b2101050dedf49c6839bbcb79ee8e73dfffdee6b40f48007c6abf65e32b1cac741181c459a3ba472b54df3501bd7ee38f8484bcd29dcdede951ecf97c247b887914876db095a4c50149310329c1d2b3be49fcee8d9437215b8d8889e8f0fc90e5a6c3371a375f1437fa0b901e8dd092f8d2ef7553593a358251c1f97823e6fd65657e2d43ab1e5f71a315b8a21c2e1c0d1de0ed5747a01adf7f3577f012c256ea3661fa2e3b78f276a34be900a2678e7b712b2794dcef6e0e82cc00af433d817b6c957eb70646d346d45887312a3e8dde8bec16963c527a763ddb072936e316b3e8480b0a09d1012d132dd5bc1d7246951b20765baf92d5f778ded9ecb378d55e8d7b73f0b1a226de9d12a5b1b9b170e94f75e7bd1d2865d93b6482a6cc6f7e4a5598e2f31bfbb71c070b5f92396ea625618edb2df03097791c0c02e8c5589fcb0319ab26f02e3b7d79ecccea1affe33fd80b6aceff20052fa3002cf1bf8ce65b2354b8bfb26aa6e9d488ffb21b91e42fe43ef321b58fdbdc2319c6f0db251c96d32328338418fea1464c9f883f1456291397fc3462649a633c9de136e8df30831dc1442136b33c4dcf3407578349a4bad6394eb01427f76838289ee39a1d432b43c53202b77a5feb1c8ac19bf6b2f5b1b2e9f753c4ffe0bd134b9ece70940255a4ac7b9411a2a95f3ff42b766875c8a965ea6a7a0c6ae3f74579407ee83a2583403761c213c899ed50c3433b1cb0fd64d2b173173481146da3d0f30bbd193aaa8f1787bb45503ae7dde1384193971f4a831d1e25f9208e9baabb7b8a9463e73fa53086e337c6376adc9cb264b21a767251715bfcf9b00402660706be98dd89710d954965e06b785fecdd599f8a89429b77bf5b419385c84794ddef08b4e0210ce0b2b7724ad29941984e6e9bee76abe7961af61decd56f230fcef355266eab2911e71ccc021bf5002b4df13337abd5e94e57cf361044ccad746156ca5413df706791913e8d613f9d10670759222683d4e15671b327898face6fec19eb17211cd5fcd900f89118bb910fad94f89f4c380dc2e06b9d5e947874c54b465ef4940828bcfa51ad093b52b1fbd9b72130d38746dfc838c4254974d154c042175ac11669040c7e2bb183e8d1630b1c9c268d9ee6a94b01e8ec02bc0277512ba8c6f2efdde5b724f6da015a69306fc799a6543f8d8e933a8617c0f0ed801be24552dbb95974e2b608c613404f4618ff5b8c95ed13b85f2a4b897403a181fce1e6936b91506a230bf4cd147f6f97604ae598be75ce1573df3b5c19e2d929b9db8dc3c326d6d05b88c89b2ee7ec3388206ec0dbb4cb2b5f3e73049979b0bf4c300036ac477b22d727d9b5d2540db1a3358dfcb5feb7916f59bcf5e6a8b543456381991170041e2f7188c7d6584c0c58ba5c728166dd8c37546b45d2dcd0c8181c866ddfa2888dec0b1f19999f867f6536cbab3608eec534c1c4513aa98502dcd7c3696f782f1cd92307a94e1a6737cf342446584e1c2fe5159c44f8837d8a910a7df7cf91bb0ad5cd00a084859fa4e295f7608270a2e2f3067fd2ed904f00933931da4b1583508ae9d8d6924cdfab5edf8ac7c8ba5ca00d0dc339a0f3daed968f9bc0d6abdcb034d6b8390a738aa3c3e0bc422852f98c0f46bb22b49a331a2dd5eb3052a40851bfe520277d40537213f973a8d1dfc62ccf8b8d77f65c495c87bc6108438a871e47e7dd57f37275e01ec283625e587c2f66573b49094707e4b4c635436398b757bb6bf8ba38e61d84322e775ccb3f175e681a8ad6ef3f14e8957ed6193834f246dbfea26114de47afe221181ce0eb07be606001d4380055707273e39590ee4dd9df73ed8cfc16edecd9c6e2998a4b68be9da21ebeb5ea56d57d010e165ea0fc12f19a2fd593fc1cd84eca675af2ff425a3cd21083e1dd185c60dbb109016987debe5f6a197a4dfa61a3ae434a3bc4f73e3ef2a65fa473d58c62e28882d9884134958d62bee13cb6d92257240d5abbad0cea634460cc647f2f6e2c92c7b68b7333ef791c0cd0ec31072d702cbf1f1232dbcb3bf38e8c32060cf52de7c5be6e3f7bfd106dcaca7fa1bb30a6512c3768b5a1c6f9e9f89a8753e745787cad6665964c207f4ddc59afb3d918960daf77b88bd4edcb1fb9991814cc5d2b2a4a306befdcea0ff5c2cc6bf4bd9c182fc2dcd39bd557660cc75b8c64b899af2dd69962bf44b3001f83361012f528cc70aaacbbc441225a8892d709336f9ad6bf48cca4d34c82fb61c83c4cb752254390ebf784b363085337c83f300d2bab191aaa18496a626460ad6e37011e2f0041818a5d723e328bb40a23bb5a66bc3127d2af9c1924149a38cdcfab6ee1f45ef734dbb54c939c60e100202eb4c43db9bbdbd7afdfc6dd4be6316707edb266de6db86df551d952ce6cc15195cbf702eccd119c20eccc088976589f1b55d529322e75a9f137ece6f131baf458d9ae9e2bd82766509956cefae43dd9e726d455b19de7ad4a6ada6ef30b1772059cf6a99924ffa0ef3ccc8e8dedb066b83cb86ce3b70075525853a6b88b5fed0f5da4286d6a7f78ab6854e7ec1813191e55720b18b7c4e50ded9949265ddceb921410b586fe616dcc0903c3df32369c5843dd1fb75d36cbcc78e642bc9a9a7cc976cfcdb2a9602637b6b2f3f956d090c18e710a89a54b165a0d18cb8ef813706043651aa1e27bfa1f256a6b1ec7870ae2d2925031ec8ea9f8a767a90c986ef43f61ecec9892e4edb5b146ffb415d6d4a8b586ff11fa6d641794255760ce90e031a3da2bf70ccfe85252157b255f5687e69fb0b8dcc8db9241c3db0e5708c6a36b7149e3b543b731a79d71e112e35f84e6369047f30f28a0f644a41b1f09b245f44a8948621c4f0a805d897e3c2c0773b560e3d1d15e0bd36b4683f16c368010d573b7bc1a4329bd03e43243b9337c204ac8d9675d5020e2f1b92c49a6f77ea4c08cadbdc4d04bfc98779c39f22bc0e5a4ff44ffc5c5df46b35f6422192cf9d691483e9a7000adc9b99d95da5e4d7c11e116be494aec4b9f96c94e108dc96bc5231ef1357f258015e2a4b67c360bfb9e0402d2251cf8cd56b99abfc0042b9a0ec831a7c511979a24e556590509e75ef4e20c4853c4aa27b2da03b99fa74da0a2cca0b8e87c1be1e5f899bfc80fee595f1c7663a4df3454884144e6ac8b7289e2c668990a5303014eca7e1fb4a3813119a3e20dee0cc29391f3de548b1a7a9b2e4694958deaaa8d336ccccd585be61cc7b36b585f5780eb9eb163ac94c534c53ef3054d3f6fad457703ccb7f49917f38d09b97bea7870fc925dcd6654812cf97d31a5c1520073900e3fe809b3d62660024d404972a0ff3e2601585a1524f65b10baee7673f49375cfcd669b9de6385087f2d5aadaa8edfaa82613abf2a6e7f00500478f91b37d11d955e4af69ccbd4bd961ba32d6b085259092d2a35de03fb6cb4b932bb7bc883f93737a1e552a6c95884ea7c8f549fc58e51bd9aacd675e9ca9e6d3e29fba56fa8060a8c468f1a1211b92f4bb9971ef6423f2dc2f63b6f5fc2483cdf26f4a79b0b04fc1c2a65ad85970cf09962fd8f13dcd55ea87248906ff3b98d76523869f5450ac32a1ff4b435c0360c07905ae2e0c9889e1e128873e66aeb4c99918c21be5d7234d89229b4fc2d36021052d5d1f78fd50820ec2f0a148dc69ff5db9876c0cd449998940d0b0a26769e6e5f890b698e9e0cba62e0970468c69cba0224f81e5a18c2ca9c20e10164d5579b3314a82d0b8ad7a37422b5db2a84b5ad6602f35cf9bcf170c4cd7158a31b6a6f603760a6ded510e344a7c2385c12e013975dcf52dec53eda92b3c51a6bf2191fd140be9d9c2ecf608f7d8dd1237f4ae2e39176241b6d3094cffc0ec65826fc39dd134edad7d07b6e2e6814035645deb352836aee30fc7006ee88f6c73d2e3cd8e0bee4375c1797736eff8366d1d21f209325e2a7d4f26fb1fa57d1b58e5706d396fdda87e4203310c6b601a1c63f9921468b30d4905ebbb0098b2668c51e8bc69b005fa8b16abb665a290447fbbaff7f2993d65b1947047c7ef92de92352bc1cf2cb847f73e58e109a298bdc3452bde2d78b82e371ada1bd7eccec0a1668a384cb3e3551e86b169c849d2be67a605831f97fd8b00c32d5c4066edbd5d6166511ee3fad750f8cc7310a65346c2cb75da163aa8a24145b37ae9bcacd4d9de8752502dc26cfc8d532d2f11975b5bcb61422d1309442881a4d824f2d35c1bb8db743af96699be22b3bccf8946c361e55936e1f432504159e42f4be16d704c556b198d4abc2e60b8afffd7d21499da25a3ab661bb18b767e75212766b8777ac93574fed53a1fc4a4f595d765e8e696301be4f5b396750ae6361816e670384c794a09dc7591819586750d442de178c3f56f1a7ad4560abda78b3226061930368a718c25804835a0b007e56475618794871b6961938df786dfdbaede11b75d85c1abf2e0267f640966d7418c9bf220982f14ad3d597c61d1b83aae1665cce39319320e9ed0d4dc34c6f0edd43937b3611c36cf419284800d0abcc845eb5cd6aefa4cd3080c6211f8d0cce9f7c3fbdef8496c0447963e860b04253b001b46edac57e0b4c3468a9033d4ebfb89c11850111e9045cc1cd148d2959be1a550ea6d0b43df3be324b72d0e5c359c9dff7bff5709d8d261961509bd888780dc4f87a7a67784733a31f6217f161fef9300f304b8dc2aeac0226420351b1ffaca41c43c1f06c83df9693abf1dc8ab028dc8f7925005918a809ef145992b2415a7601d4ee2139a0598f01806becbe96d529cafe6ee0d9031438cead11835dee87be7f71d9e4ecbdec48fae90bbc56c839500c50906c5c023cb302509dc0c8ce627ae8d2f433514485aef9dc0be1a332504707ad966b033fb64d8819af61c213f4d31a451d2589286d882e988342113924f3b6892e026825a2f00614da438c3783148f6da391fc3bb583878ecbf9f199fa577bdf400b1ab20ee298c71f2c6fb44f655fa00cd2d0a91c7335ff3060246ccb119e6c605cdf290c43b3b95238fcb0409a193e710e645c9f64660a0bb5f464c94cc701d8a4ab9cddc49131bebfc635cac96b388ddccd75158cf41bf34e829f7883e2a1b6cbf9aa47bae8df3df9921fc69426817e93234c8ce88fab5f4a271da7a5946cc7dd0a37fb7426779652018bbd87afe3eaf51c6890ca4a891f50748c2fbdd66eb3d1425657a540afe55188ca0df3c907abbc3078b2dd8fc08bde4534d3f0de53d32d38a39174ce15428fdc41434b6ffad4e6008b8e216816764ad29150793c3424f72955e947f810e5cbf8e74eb2f27f3e9961e43aa6f4f82f30ff83b4b50ccd7ecd4fadc97b9d7e2e6b517d8d0d63858f2c538f7b21b57a936aa90458777e5e6a36749f116d6d6ffb9b71faac2ee36de08b635ed9f3ba7cc5992a2c6a5e3c8d824c4b8274eb30603cc09332fdbe3f7395c2f7caaa6b80140ec4c15739f695d6a68cfd7b748c4333c88f24eb27b951514663c7d96a74892b0721cf645cb75151750678f4971ae23ae7ecce58382169329754e5f71c560779f42cdd531f8b8d9e0997b3ffa76fc6a0f4a1df297d46c193a0928ebaeb1ec4d81ffd09d296f22faf89760c02d04a077b0d1627cdf8be285620a5ceece801a33267b287a5d2d5715671363181f09af117a6508916aa17d8f22583eb9b31f19a9209860d8c0bbcdb13a82dac4b0093998a4da2d1707f9110d08bf1ebb506863336a17665fc278753b38100ab3bbc66e303109c5efc420277b463ad8257f0599d6bca748e95fe9c80f624cb0cff031c3e0edddfedc0d674e409518c09ddd14349679d503beefbf69d77a4b4eb291ba8388d993eb2983c6a79c5398e5a79d2840fcfbeb380b28e5891db288e512d0fc6055a8fc31596da7ef59db0bd2cae9f6745145e1d516dd763fb9a552bb3997ad9c5ce140383001176863d9ec4bd4a8c715200ae00cdba5294cfa7ac20d96f978353061072fb1ae71231681d38e5f5c3738efd4f5fcd053ff71bda0c6932ef020949ca61eee6abbd29c1663e0afdbfc8aec80ab986327ca7b47ff1fae037694145ff1fcae0a54e0db911ad7477894f004e15429f7dad04d2dc26069d90a5ca5285e112199fb708c760ffa80c6343890ac539ccfb2f03085a24234951641937392906a5598d3b312e7a5629bc8649a31050ce346c66d91397b8ab7ff5e84693030a44389c1141253a5b343dc80392aa028edd9a3d5450576bdcb7e456cc94c8157091c5d4777a9a6e335abb9faf1e75f71d90cc2675edd447b4d6910f8d8760411f3bb714af1ffa0cd360c271e8da5eaf3aaa2d489800fa228292a5c3a71c8c2fafb7c84c4e5bb127f9818969eb9d2e5969d04802c3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
