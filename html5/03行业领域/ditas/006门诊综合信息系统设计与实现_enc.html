<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5847210944af99d5e91da05fb9aa1fb436a991f04026dceb823e3f3fdd98995edb817592891e576f1a846606f21bded2621120a8f50abb144568044d3db4981efee1c631160fc09b5675152e6339e509de1dae605027d3a495c607bf22f315202956dc92d3e1224fcd1d4822ecf5f267739cefa65493833419c13245781163895844ec6da89496bb4b399157c7710f13b5c697746a7d05dfb7bb489d97f2ec1504b8e084ececcb43858335837f42146276513201886fe6d2da20d9f6be05cece2c79dd280d69ae4f01da62790a2dd281e942c80f7cea6cc5c3cffd1bce7b36ed0e2e49aeb6ecf01f34cb2cffc0a789ea9f31fab9046358ff788a6e997252501245d3f6c1b801d077e578e41d23e42751ab060922e78f39432d2912184319d91c86a33afc56535730a48a51f6cf67fbe41f804e146d993e224ca7abfa141a4b31f976b45ae9bcdedb8f96c534df433d4afe2ed2dd286729cf4e17f47d3457954a44750bf1572366da3d9b95d8fb2a8bb55990378225678d7fc42d72fb5d11b86ffe93206574a9df2c1f1d226a834a909738d034141405eeff0ab91a39985a454f1292b4ea9d7e8582e33d7bd8ddd483bce09706675ac72707eb1db47a7b494e004b56feb4350eb8929a0247b97158f84bc52edf0921045fc2abb04a9e1b42cdf8bde9e67f476688162760ff019abdfe5f077d6149e858bf42089ffbe6758d77f81d93c28749299b5f92cb23782b7b037b8607156cfcff17e57395bf359d17e0984adf6011372cca53c95f96adcd637d28dbac32a1bae6d61f07a5512e21bc8fb48d5d14a57821261cf088ddfb9e3ce6c9b895968c1e09744e8315f4b3f9af76af21132ae204b21802421db05c5bf5e95e517159121cfd8ccee82ba41df200f3ff566442a2d55ad52b96ebb621cc7e5fb80c8ac1133f363c16286b8f3f5c7968a1e254c4f2cec837b74f4c3e7f643bf520b3aae733568b7074051f3fefdc7f9c2a6dfde376bd9740b6cd9c2cd19a5513123c2980092b7258d815220d878d52e48565473f1f04de11f101ad118386c6cd85e1c32ca4ba9588dfa535073fb9295bf0caca76f6ded0b218870852f3062a43f052039da8a88f7b131ba5260d6ddb4fd043b9d6a1cf2ff2940206f8609db40819c6fa16760550f1534d9f1ffa5c30e9965463721995f98665819090836451c49498e995b589852d08b0a021c727c3b16c38ba6e0d8753d1484a78026577b2a7f37cbdef1bc2ed057118e4ce2b78b6489ad2eedb95c06a11060aeac10a81c74aabb5bade0bd28a4abb76cd74115b6420eb2f0175d98ab71df9ebaaec5aaf9d8456b3b5222afa5bad828338032a95a107cc4b7e0869d85d22e8414576b4eea50a11784601722b63ea26b4d5d6e1cfcdd7dff7bb3c79bedf2b57b1233ff812b5bc28070131113d75c452472eac335fd2e4998cb313d533e1d50b8f74efe4a59067d5561cfeaefd7b180124766ec202b33e1f316f783db9abd76fa645532639b4f3880167243da8ec280ba318d42834be3af2c4aace5316095ffc1bb33c89cd93d4585e24f53e0584c70336f8c4fbd9f583eeaf4b2cdecd45a9a6b462589da970dbe98cbbdc4c9ca8fb127874682ca0715041055abc36932db56cf74b876e7be34b5a5b5431619ca674127b4a99db18ef145558c381445f0d0e4f9ab803787e2b3de5795cc74db753078c7ad456b0b866037e7358faf301da4867a493e16e84943db3f99b60721e686be8cb88ad508cce1feeb189c10dd991a24c1e344368fba1f7eeabbad9d7cfbf4c6a5bb26e441370b49f664ed8afae04e7f91db702fd4abac775af3f2f83e70a7b70e7dd04b92e6db8f7a4f31d4bc7daebdc29e732825e96802495324d51d89ad439e684b78d4fe79e716b8805ba7b3968e70ffe2753c7fc930aa45e0a0ccfbe530bd0a74ac10eaf625fed7395174bca47437a19b378f8c12808b1cc8a3ff8a39087959466e351cf571e8674ce89757eefee2b6ca7f22e38b1686ca97dc7b406ee6e5b0eb35e6346934463ee18dc095f8460ce8211dd267991ce3eb28096364b055a28c10ebf3db98e65b410798f0855704e85a45eba0e1e0bbc6d67be4c6452894a982eb84e7ec4e1e2699a02888e2c30331fabfe22324bff25c29f46108140cdadaf883cff7602c5c499a471b158462642ab869fb8a9f1fcd247fe91f7060a55f8aed032a07825e3fa7ca216684bb6043ce082b825f8ef4ef36f9ed47c4367cdcf6257c90c47c4309ee4a4b0a71bb8beb5029ae9f2aa71319d2fb4cbde4a774e8103a4f9ac5256f7e2a3fc2016bdb68f6553b59f08ddb49d7b63cd22f16f282894f9a9d1aafd257d60d5629687c7aad85953f872bf04d1c35311cdd77efe94aafde4478b097662cb59ef674677e897c8624334fd56ab0fbb4c0957a9d32760ae3469fdab20377b2102fe37f1fa3631476c1f22831d6e944e799578455090bd7bb585e4acee2c04aff00b4ec27bee8e6b9608228085272b8d04044db81122da9cf691b3b2a5d172f1741b4c5e8f6dba23f0c40183405eeeeef2f8bf071e5a1d859b4ea8049510d1abfa87ee29b3decaaa50698da91b3965fe7c9b8c286c9fb120458098991a7d7db34a6d82783d2dfb85d4cb8d5f6c9760d42c794bbb7c4e79eb1af198f0cd0f25008966508dd7018c1ebafca86a90e3585bf7e7cd8b670214819447d4aec28b949b230e6e8d96337750bc56bed392f838b948236ceb2545e8430db9cd78bd49547798832d4572b5ec033241cc69ca71a934c52e8c6a54b7879d5f9c299c9e7d808565a7da38ff1e42211c58e3f08c5af87876339928d1e43c3691d88b9a8a7efd8fb0b139d9e68f741f7cbc75e3d5678f31427ce82fe89cc94a23a0aee4ebc0758e0ccac708288688e97b2d78ba85e1dd0903ae7f8b27f164de25a87b0fe575f1a7e9e1f413cd1060920b757eb531faf28dbc7cdfad90c7a2fb3644d19f21457ff5178e81bf4fec67d98529fa72ef887730086b6c8f44cb396cadbd0f08235e561b5d571597611635924fad1022daecd1d08c88653c46d9e7d9185903422a72a3f814fbabcc49954089b187580d70e874f64e2ecd90938350b974a5cc4a2eb7ceb8785b4b40996c5c73cc6f0e188ecd6e6ad0721dfe0e9d3dcb847fa2962c7ae77e0b84191688f5ccb031ae29a52fe1f7ff9b68a1cb9c1e327abf70442c3d9a5a7ca2cc77eaf64ea8cf97275a70c425f0bcbb98f6e2f5e4d20e0daad1af4f0a6b7513b54e54bb7e3e699123b8ef703e9c01e327754c93a51428ec05b474ea4bc557f0c6b4c217659295f0346ccf39e1f4fa5ab0d7160b08601b64b5f34a599f160001b3cd8e949915507147cb2f2f0675d9c116df7ba333a600851cf5f4dc26931a7ea2c8f8311171b14f3da08fbfb4f177d12601522833d47eddc606f83e2510375be8fe677205ec4ede231298257793193fa75c0614bf04ae797d18a7ebfafe17665c01c50de31cb9cfcef99a4f52a7889436e97c76e1dce5306f86d353be1fa50f742633225cd30e303098cae64da5ee7fc56e3f8c42f25c6eddc0b939a645ef6ed5c9dcc776c3d6bdaefa39ef0a6ddddf230052dc10a70be5e3d7e85d2d0e489acbcb479dd17022162257a7132d3e3146e41fcae22270eeaf8aff6cdd534ce765bd974a1951c42324d383e165b2f8ef067159328d3c895ab50723cab8e4f3563c9c7691cef40bcbb6771e9d9bc9d727c1e83fbedd3c69e5f7a65aaef03c380cf0732a640348ee7e47b4aa89581072c32591fc50ca48298e8bb2c3127f049f44abfd92718ff0f552843ade5f150d00844feec2868f5eee7fa2f1892ce82c8f510b0b2bd0b82ad3b330e34d414cfae4f54b2b7c26936e4b61ed248c7cb179de56565c2672372acc7fae1455818959435ce78f1cb351a2251d960d125d4bd14e0705fb9de98abe50fcd88d5b14599325643189ea9041eba31d69e80b7627d60d272b43312c59006b774fb989be75d1502154fde8459f5a6706acec3ae9aabeef37a39d593c3cc8c06f6c990bc91ce8c35c7f379937be556bda2038ded521dbbbc1808acb1a6204fb287e8684d1e371b6b65f581c13c5facaaec6de725bf348bd0f11c49aae393bafc40c0cc674c7625456aa0d11211effc5fdfea8b22b270dbc8fc723bf644763724112b606bbb652e9498778549207d128344b87ad18b9654c113704672dc39796beb5c86e78f22bfca6797003f03990c617b31258cade425c4699ee57be1c98b889f38f9b32334e1d46f71d9d1898c97845845ce1f90ac7be6d5fb3a4c4afce6ecdecc7b26e37c07f7cd0e00dcc9e6b21957eaf06dd543211b509a6ae19b605f8841e0bb03616702e942a9c309a24abbd3de469bcb1b5dbeebfbc6356ec87d3a4d3e7dc3a6ff36fd326fad2451d8e6d4db4ec90d62c5b21b95740fea8f9504daed865d536a9cf71b855ddf41b90dd44dc0ec4d21ea2daeed1802a9bb43b0d83d0bc54bc9a931b27bae6d296aad4ff33d7b99a4a42a8050f0958e5e4358e9106561c3af1ea41a50002e94c41e4c1e6f1dd826392d6f349455be495ef605cc2d06da1f2270b309e7f1e1f24f4d347a4d14db8f6c3c0654b8b2b0ad5ac69428a67571928c053ee32a95923c6c3e92abc7b775eb634dc3226e82c9990788af5932f8b7073fd1964669e0202badda8884401ac42070e5430358dd657f5745107b792493c42a0e90fd4bd346d543855991ae4aa1e3612f98ba30054985996cbdeecc7eefb70059de1a52a6e25a8b2ddfd6c915ac017b55c144f9997fc6d47a395d48eeed5881c4d862d2066d46f2cb172c9b769a0e21e78ff9a998d4ad440eefe09dc6066b0532bcfddb734fad2051cd6c1f8ae1ab40ae18342236d6c8ed4a0ec93e9128828cbe1ea0593082368bf0c7b2ec5b18eef5a82a1530a30d68bc31816fe14075c1cb1702de76858bdffd28574fec04127e20cf09aafe669224993ca8e9281a44d884b26281e2addacec762c6ac213acee336690ec7811c81595355edefd02c81bd1a978bb786ac23bf58fd873e74bc45986ca517c3ac64af724f546efe4e5604f7c0863cd8e224a7489204c81229c585a8b52c38cb71bcf88b836c00375cab8f2140bf752f63e7a98c933ac2f3f61bbd807f8d296d480a0dc82661143dd904672d9b1cdc6be0c1c6bb4a75e8c413ccc2db6e9b3f6a6d6dfadf6c2ddd3b887a5366b0603dd60931f0966106de4890bcf8d669d178616b2c6e3f4c9ebf4413228c2678659da1bfe0e6ff07223473faa84881fd9184e7eb9c4393fd7fb2c0e27f708f46817ebdf1d6e67c91c263970100348bb6715d6e9c978b9660bce85a071a3cdbfc89bc96a310da77a6764607f5265b78835c0dc38af38f62a610402afe0b4817fd36c18894e89d515f03e03a7e7bfd3c49748cabc7381ddcd7f1ff47d63cd8fe235c2d1ec5eea5969cbe2f6ec418236919a36e8d0d3e28738f710bb54fd062f359e5d349357ec649bab479bf6e12962b84ea8454164fb75d04dbe07eeec74c727867aafe72d038fd003af9419f1085734e1ff82881c9c9f0d1641a25bafb2655069acb217bf9ba610d2f23202dbf7dc7f8e869674d818c4e5e6c5d713538564981ba0bb1a0ea41df8582a355fddfc42c9b8bf86f35582462b3d895199e4dde4fa89aa5402fcca4a2c0b1b5341e2eee59c6f1e036fb360185c23c099920f72af825ee92e0bafa0de562e8ba226e5ebb129794ae5103db4314548fd29530f0d5d3b68c028667c6468d212f7662a879f4aa4a20bfbf2027437a42bd71fdfbbf36708633afee38a87497df39621b64148230e60ba645791321a85a27bf6c9b0e805d7d7441b4baf6656b2d9d02a643bb25ba7f0dd2db54e21b707c1daff54198af20363b09bdbe42b625470541f17065b87ef544e83ad06992c9a2d9fd49af9d11c8428c00c177796ec65292522e24308f889732fa8deecff83b8ad53c22b60c0590b837d581745e046ccc8fd41e39f646280f9d56ed6aa1f65f90439c15f1bfff45625b4a2f3f3d2df4cf1d5570a58149f7f21a35c83ef470ce2f59b108fa02dfd4ca9d471218b2bc409aada41ff225ce60511eb268979d00ac599f2f5ce1cdbebba7df112e4f8b909c96f15e36626026349436a2fdffeb231873943182d95a99d67b1f8e3d12ac560543178658bef20277d93665139d09db32018e5c4cd1cdda3e59056b34bccda566dfa9285d3b4f3c3bbe26c03e3f02670796f44ad3f6163270455bb297e8b5d1da479372efaf9ce748e2d35a56ad392833ddc6cf9d6fac4a4734e7506358a4aad3d4a131f0431c2a44d200030753697b096e20f7f353ce0c316191564c546594b83f469f226ac29732d0ec8633a64d040aa1f2b57685556e07ec5e53cfa67ae8b174ead2424c2dc71d1d8bc020f30752da770d3f5fa62ebbeb401df1045fc06638a61e92cb7b603659a94c67601eef34468d8cf5d1ac3ed8785fd3bc9631a0413ecf6106626d0a77d02f2180a5810c9e60d50d5af5384db78fb0fa674b355c2cbefb0fa81b18efed4098d2c8cac6c5c4c8fa6c286a2608564c8e2f2c119a10578322a500f464844846106fee63285e08b4d7abb189dffbfccf3b21e90a51c1d27464942c0de818f69b579e40c592c3da5463d51c5afa151699ae86d77e29462de95c775a052784ed486d5f536855e430ba7ca2abbfca5a64a0c583e86a54f079d0cd8d8a4fb3772396817d076449ea6e9c7c93acc9f59042db6abe942e54409b619d6c5e165467c5cf85cbac524248b9dc7a8e4c557d740a4985dac38a4d64d1ed159299bf20e46afe873f23dc38b0fad9431896589eaf4db9ec8a6b3942df6e53d6f7d19da45cb3458f8eda310473e533b4757dffa6f4099ce2cb3815f9af67b6f016253dbb3019f0876539ae1127f83492081997211ac3e3caabb451b62cf14d0e1fc7c56e6f3fbfe5d47f91125756700232010e96bda55a97c3cc542a6891693663e370ff59c1096a24eaaee1327b0e11b806903dc1ef47d5cfb346ac93774258e0836b9294e4264149db12c7e00eaa47d48ed763c847ff4e7b52122a3be2b3ba873d0bee6f18ffc550c4c784d113e33ab346836f8ea0d53cc173a37885a9e90b0a5ad19d827279317e0c1d6437e9c317b429074c534193a3b5eb7d8eb9918dee0d7f10efb30127aba2c46be06278ebbc9efb3dd030539373f2de478d83a88d6f3045d3d1c1c209f6a8d36348ab1cfbb8c82531cca736cedee43ee0f6b49263d527325635ece6c8596caf0cb157cd8835c10f4fa50d997e1d65d11b8ed217541b4bea3afeb8a91801263f1123b7c83ed047b2e9b3ec02f0aca2c7a29a98c241d73a0b3e3980634d512679f98d59b7babca97751954a82c52f1a52951faa33bac4faff6e44994ae07eec8b21ab5677660d37251e71280b5370f60ce23e1c1e4ff9f80cf522b1653a6649cb33ba7c9beb26494659d2e3154d2749f93bea9bd272200d4d46525d52ff20a4a847893dce196f782e51c03100064db47ce5825291aad1d876f0c8137029889f6e17dd481268d7b0cb22d90c275b30465d548706d8c519f82b6c8b018dd60eda280f9c1554d08a9aa029aaf566609e385313d321fd6b269d89939f52447216cdca6e78f29e82083a07a5b10a805178adf3904c171920204ec32b116b6633849b13b8048804a932a33dc5796fc0d659c8b6e2158144b36c8a2bd270d227b0de004ea7cb58965786edeb80d5426ab0a594b9c8a632644b403cd51c6e299fd5c4fa85f46f2499f91dd65c40cd66f7fb31df2698881615cecf809305d604fd0df45f83a68e34c0a76c2705c5742c45b01553cace6a0f1939ec33621a455059fc799423beeb3f33a4be81f35ef0dd7b149d780f4a1b21aba808325ab6a91d26b06f47f6b448bf77d39a424ecb9a33168be8c228bb3f1f7245ef327a44a47965dafbb9b1e172e0df72f6e2604881043cebd688bb4cbf691aa7a31b27246aadb14f588d34a5288af004941a44166fc82814a2bf5f28351544d3d91c373ab93c0f5068ac3409eb1e31104981965ec26a046d1bd1e37976f6f1f7db8ab91cc6be4eee2714f97a06099b2587fe01a0a9f1567b169e5af81bcdb3f5fe2ab8f1dab3f802277a03a81aef108496e3cb3ed82ef234a4510a5bcfdd26576c4b4943964d488025aff6de513194380f9745b5511e03dc9a36c6a491f63c3430c214a54271c7bede21ca7c50927112a2e4a6471cffe06ec4e38df9bf1ad1d68443d740b66fbe0774a8545d55e5d780b98a130d39bd631792d77b65925dff3308329a3c317775aa35f152d5b7bfb7468b0f49a456b31cd2e1bf63a3b6b90d3fc023c944e68001989ffc1a6cb8fb57fbe701ef8bc97f93811a81117a2b0e67d77db6789bd7a5f2248af78d19315fda7900d0c4769dba86e3251dc427dd00d8479d4f839c20f0780224e1e4a3484c5a93cbfee9921a681737ca10b5442603e179f590d0de013fedca83a15ba78bbe597f551979a7406e0d3dc4a11597011749d29064c75e0625db8e493d4efe201f3620d0b7809515f947c5cc4c0b2dc47a227766d6f63790fc86ca963ff3c93e112ef289795cd31d7375b708ca587fa8deaeab9f4cfc2722c1173ad9f3c58fe5afe7f65","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
