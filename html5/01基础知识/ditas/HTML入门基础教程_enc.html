<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"efd387de56e30550a50b78069af7b46135a24fac8560c77847b73762681fa9eb1e3f8fce9f4cd09d6e052d0bb256f2260a05465468e9e4c4f8d644bc76c3c53cdf1c2fa5aae755d687627c88197506dfbf0f5b5b9483ead966603af6de22ed18f501f7b4d6e4352f58316057dfa3e7ad4affbf63d5c0f098aff1b9ca8253dfa7debc1459a9cb3c3d0b089bed05fbcfeb093e5181e31c0a3c424dcc6d9a374df814a1899a2032d043758ddd0a96f5626761092ef9a9624f6874481bf4af5bb12a22d384d6ef385138985b63af734d31655a06a55fd410a57cc793397105f0ee907041b751e0a5e5cd5dd61a5ec19acefde8594456bb072c18eecfac195bf578a53af1d2208a526276080349b19495c670b647832c6a23707acdff911e519307c128c5c9693ed624457185e36d83cc1cefa448d3c856c93d6b95efdab32fc3beb3353705e2b0ff7e9a39e299456ec3a225f9cc38150c4f90afbd4d5e17ecf271003d8151f50dab44a71e270c660dbea9e40b3b12b87c46a8b3fd653e17e7ee69d7bf7697d336a6bf6193de90b168a06ddb9f85127be2494c5dfdafac29e52bcade844bcd14df4d2090bbf7f002d7f17270625d3c29c535ffde859fb8c199b29f25ffd59eb6550db25c7aaedece70b74e9aa6f19e18f2c4a4c5479f13785ba6417b89d3b916ac565b1d3e4b3e92922c1384b9c989c514320d1a36cde48df3b43f98627e9a46c5bda303669a2f69fd19c27acfb078815909898fe52e96d30a632aaa3b19304473d20700493d9090f4adf672925e98fe566f71b9ecc322416a03be221cfb03eaf9076058427effce084c91c0d48d71385059ae1d785c3cefb2b155890f9da8af86aeed604c65d6bda771309da1eed5800cdc74cfae3612580ce5dba0876ace1cd6720f8a25976990af2197e329a8b3b9e54ef182887a3ddcde989d3f97880fcc8ed935c1ab57d4444929564721d2bc72e854123bf682eb1c1e4b6a7a32d955e67c987824e01bf0badee4dc0d8fc5b779c144c2f7042b14bc9b56dd078839df6545ead4271f3fee44c4e29f2aa3bf00d85ab376330ccbd822edf1b12fc83d98784d86afb1915adf9ccfe417f0f1f2a02788ded2413f6f197abec66965c15f44c4997f28e11a3c020268a1e13ddcde446521bedca63aa1afdfa2d9047a18275670fec9a6d3e073499032a2235f06b8cdad24736c23d8f610ed87ee662c800c8de536fd627706625c993606e9a512c6518140a73cda02ffe6f42c6143e6bdbb003d5a7dd2e608ba2dec3ea432d0f0a96a80816f573c0769d1910a36fa20ab508531175609336cd8e6486c96dde404f8a040105bba6d5eea89507f69cd609646c7d6af0f712d09c083cb4184897d21597b653e62b32d8b19ff057577084f17a064cddadc1b683b6b45b0891e4ec80791c434456de016975497126478911f86ab37723cb0ef90880ab403e22c1d03ac79843c01c90f4fdc8de7a49024631d8a23d61d13b6837b77f7cfdc9d6c1ed2281b51c1e95e01789451f8d7a4984d48bbde2b4415ef089a1f0ad4cf053e9af7b3bf87998a9776c50d23fc10871aceae2dfa61fb7e7ddcdb13a88eefb22c689ac969d70635b3c4e77b50219d2c28fdee4b23f6ef1a05f6bda657550500d8e3428f044d8c73d4b8e989fdac0a14ebe3803e3b3aa94081d2de2ae7e8f4d6781486217cc136cbb044ffda6834bf567b3db52b7d3e6ee6ba366357bb496f753aa1d61ca86131b7fc26271039d3c4b2695a7ae339b2db22d9fdb59a0c5e641ab18129ac708785003ce99a43499227ce64d8d63de244c470b039cf5ac00b8dbe5e5d760f678403a83c484381280566dab0db3917904b8771db6f8cadc6200f080922ca459462d864178578c8454b51f189d6f67f3b187e9ad4a49de4ce1f6cca21f70d47ad089f6cdf577af79729f35e58eaed0b881408ce38dffd616ef79c0f93a01107709da388250583bb1aa9c0fa0e02d2418e93449938bfbfe684eb21a250fcb6df1854e0ecaa31e1012315187f9c73e6edbe31b22ee029a915c15c0a9cea077cea389b9fbbfc18f924981dcd187a204580991af0764e9a7f74f7ffefaf43ad15b81883665289b0931bed925e7df3e5362adb3c96cf1c141c86aa94555d4f13ef02b8ea691dfc49cdf85adb9ac7353bfce7a07ad33a505a70602d459f557770edb960179a94be7df5ca5f065c18682f671a7c949dff4cca62ccae69fbce9fd28bcdeae3c80c46cb445c6071de6a7d9eab22ec2ae67b63a903ea1e1f74610e747aaa318a4065fb273115b8d746e4fc9c050568f914af36b12ceacb510cd325242647ffe5d50821ca3140fe6721af8d1d8a2d1bcb2a7c543683af0d1854c1b52aa5ad0527888d6f34eb4aeaba5722ebbe7d70c35652f7b35f620f13f62ead7f7f33b7aba30a50d0b7cf5d377442ea32a140f86ea198ea094fbf8bd36827e648e16cf8cad8d0a1f57a9f3c2c4b6972d0c170a5772a4eff2a9f49bf4b62735ef1691de037fe779da3448551eeb2a44a56c0a9f30462e57e17867e1ecf789cabb5c8874563e8003381b5a0cc543b7aa55be94c61c36c45d89b3cd9b8b199ece9355390e4bb0249e4b77a0e04bc181c42bdb0a93f67569b79516ebe16beb344805774f3621ac817acc8dc8a1df1031dcc859d2e489ce152ab0a25db8f1c67b7aa845a38ae1976d2879f82162b46988bdeb48de1e37976c1f73135db42a040a4912203cec01cb7bdcc861239f2ea00dab8883895a8fba3c3b532d95b43b422aa71186d0dcfa65b02873b6f80ab9f43f0a1e612da3c722937a2fc5ee05ca24c9d5a04bd0be7c629fa0ab5dcde3a01f26470a5f05672b5b740786ed021f7c820c20d4f2cfcb3c365a321c92e48ad9bec131dc4637e91b1f147277730539777bc0c9e7863e90f97c67362750872f876d4005adcc5b30e35845661c6778ee7878b31c773882e029e13b1f954d33eab97987fa3ebaa801e475174fc877c16a58a1668a5d51ec75eefbdc5a390e1537729d853f5909b7ff9876060cfa5f5315b8ea73d79a6eb6907dd552fa0bbba4fba3c999fd3c4350d1d0149000055c520bd909d51e138a3b97314568eb3fc4c814aeb56aaaacbc705a93cdfc9b63c6f084bffa4ecc2236287772e5fcbe8fee9c7900f5bf5597ea249e66f20bb7b2990e091d641496d185ceb34df49f016a5d0cb15700cf3eee044c062291476539341ea102bf547eaf91b9a8757134eb777f6c23d10407e4e377c20d44347daaf6a79147fc8f2bb574b20c06020f9151e6a4719609390f4bc1480fcb3201a823aad0fd27944485ffe0ed23c0e6c283dd67c2149f25cd4615582638a0e6e7d21c0a8957ec70a389ddb45e879e43ad275d2dd8ddee6281ac725d772f273a491ac7941f67097bfe88a302212d7904c5c16a9422fb63374d7d7fc754626ff2e867ad0e691e5c3d87cc3d8d3b2f1aca39b7f0bccbb216f317f5f71a65b1128dd0e75a4a4d73609c2c37c5b3c302901d1a1499c8594dfb6c03e6a832dd7d4f5364bb92367aae50a0ff256a4a81c21c6905a3137f55dc662d638627dc78b3ad2eb5d49841c379037b02386ff6618eddf6ba57ef4631adae940c1dff1d4667e8fdc243c10b063883e660eadaa693edaaf247bb453f24ef7d52e6590fdf43216529047689e86cdaf894b336736aa4e046be93520034a1a5d19d97dd43ca011c89b478d83990d059a0932da8f71b196c557c0dcd7cb49bd2f6c6dc86f57e2d87c9f058154f7a8476d252870fb9051356e7b6c92d95390e79371a188a18232508386cb2c31eaa84ea545d763ffc1bdddef5602205efae01a5505d9e01539fa9dca3728fbedc20fa49ba323f1a2c0fd0479c2306ed62505407be276a5a8c0e00dbe920e44e082a6c7f6fdde8b949a9d6e382f138cb20b3b7cb04fc54a6878c0a6033292051eeaf66f5a6c2532c0a64b5dde8242643e527ae31afab35429f479ac8b18b37423e4f1294c808bcd969f42403bb8a79187c681598e8429a947614c6781b04353d6f800a4723395099abe3e0b68e4621cebf4ddfadc4ff9932ba0ce9f310497a9fe3ce47a58753c40d8a5876ba106fd4224d2d9eb27e53d4633589b763fdf15c1be7e74f4dcf9e24135c5f7768e0467d1ae479a277f3e551f4f9ae77cbb5be1097433b98f1efc9405dcf6bc459ed34f73db257487dad251fd3e74b2edf7c074cc0673c3983f94662e722048b41b5f9871ff30fcccb518d30555540985b51bb06cc8e902a227c86b8f0d1002b3e60b367eb7d26ce077bc9728d7759222fad7404203207d6910b481fbb33f2b4e3e694119ae200d2968912d5257268cba6572f0a9ef2c2dad17d8fd3b267d5a8bc782c5ac139c1378b6ce1844f4acb8202e2a232a48f2d49c37add2fccec9e61a37c3031bfe1b640627acb3a34217f410a4f55b5b2b0a7325e5b28f2fb2f2cd5513538d7069bf7dfa80182c167e7509d95fbe04ac080ae31ca6b5ce57642c32f23e3b52796d4b1076410104c7b8e456351ead454e247f6ad7e306c4c69167b08777c379c85ce9585ffc20f3f913141aa2ee2dbabe0d0cc69791af065f5ff1a27934f4d9780f1b143c006b611f5581897e9594d7bd9d6b1de620c27fd17f5f3319d371c16807292b5ef58be846940d2cff6ce5fe6dd30010da1007a1734f523ed10b653064ae701141d2202e99d072229a476ffb1ca1e8c52f40c72a831a915596842d002957cf7e82ee62cc931c3098113f090f3a8aa46a1e68627854c004cbc96c1fe8f178a53c239729950aad6548b49089d3575cd254ba7b64ecc289ff48412beeb15ea30d3f56b9513af653cd5ef74b411da2e9dcf98bc9ba5ec85a2b06b67dd73810802d53ab44d2babbe170cab6090c1a23a17f6407925584c9ed9d2201720a539140824eccf031a2aba47b517aff24b82dd5f999980747149ad09284a88c7d2807f7cb34ad7069f45e33b471416c26a7b1d5274cc96de7da6389bbfa4b03784e989e9f2a12aac4c3ae5632036a136df3ca76a0b3be2fc2c257ecb08584c909aa98172b909651a667d3b16d35a5d845e528c7cc5693f86164e78cf578b47553238ead74b4076d1f70ec45b3b51e0659ab2b247bf7263452f14331a5a102cbea351b0daa1e8f3f3ffe7d9d2299d682b81416f143791b2c24200b41ea2e38f134311a6a71b60dfd32fdfd8e90162e23cf08a761773b1fd7e8e4fb544a2dfad58b6d389238c984c7a029dc6f776081553e8cdcd7713ae98f04f94bbf71f7bfbca855ac35a4687e7219b989a762d3daf73834ad0c23609d36a2a361ae9f1e56643025f97c6de7d46668e380dd4dbc74967ae045ecb205a6eedcb291dd7005fe4fd503136eb31ac8adc85e0dd45c4f3667d3bda0940292a769c77fb1a8c1db7a908b81ba437b2f923877ef536bd87929da53f18f5d6dd1ca107523f835d7c6ba5be5455c857555fcc02a58c5ecb74cfbdd0b3b910e04c76538a63a08659fcbda64984dff607065bd5c2725d3eddd02b142a094970604a0627f0fff53a4b1b21f0b2e7b09aead077ad415f2a1e98cb3c1d80a6145c7475a666d7403385d8e2fa02edce62c47866c1e5c20539ebef5ad2c873c85708b7b2d1994497464edbe3c6ff10974f14b8532ffbced1085d7ed7d2d5e932072f0c09ad3d588a5def4fb79ca66ce64bfd934c175f517ae56bbf313955517265adff211e0d581e878f7e7bf012c14aaa4612e48317a65f3b88f9951e6871ea18671718225cddefad26e27e4719095a556440af3ca4bb6ef013cfbf639de9b22a6395f3c8de81185a425fa2189d844f541e6d295cbd3311a66066b514bc23325a39ce47ffe35a4941ae20fd39b50b837306effa760c4e192b2240d307f38fa3f9106d89af063fc284ef17827a7693f97d340e0a2e758216a93d3cc03c6c6945e5763d1e29e3a64c0bdf6d9a575bf7016bcaeb7ee3f64a609e4cae58b7ec0575ac898a45f00967aaadde7d5c7d4461a6eaead9c13ab97230464bd8677f8f9ffe41dec741ec2b624afd975955fdd3a89352ed253ec5fdb7367074c013b727b59ceb82bfdb384191539f2a69dbc5719cdb107710b418954a389557224d338e347729e2b43400a70b77130885f57ffa472308ebef180cd2e350cc4806d3628e16d6bbd687eeb815592dc38a8cada45ebf1b181e0ab0ee174cbcb35dc765228741b3c3d94121ec3691b34581db6f8694bec707b72dc6045d93699290ecaab8f5fc8ede85fe33383cb66a50f64b381e1530af8c386c4300742f517d51bc135346b1c406eecd1162ba4cbea9763fb4cbd71eca1e4ebc04f403f6fe12d47c6a446b1b3fa1d108d8559cb81eb25532038ed940e91d37f6e224255887205ec35acc3973360642220b263cd2871a2ce336456b07057dbc8b1b7c04130dc2cc7264259ac1ced99200224c953cadbff5d2ba54801d202755f1ab50e5f27a88e03f25f8173d8c719aba8f63f5e063b6ea65a26b18931b89b496aebd8fdf3ac41d9b5f440403338495fa44427abaaebdad90679e289e27e6e2d6c82aaa04063bb4880d7eb4c738f0280d9e024cf703cb50128f436f07166b39bcf9f7d53bd7729493b4eaf6c69414fdc66c50ef6afd8bc2f41e8db06c01d420f866f1a1e84e2caa57b5b9c9a8ba690508808e6bd590b683f0d8823dfe00bd840a237ed160776f36ffc5ed19379a82ad1de888efd9435c088e96e04f5b15a7ce63fc8476dd1ee517655c604ee3e38f75541eb6d309640c4829a3129827063e680c38cf1392581d4daa18652b21412b6658fd1e2904c4fa8599776471d6000ffe0aa4984444effabe73ea69dabc6bd5e7cc3e6bdb10fda1f80fe3e035522f35fecd9e0fd4047b4359a360a626d1cd61caf95a1bf510fec169da8b872938abe2b49e1b5f057e0e909b4feadef8338479c59177efa6883d2c7fd668a96637f125e4c04a0b15744506533ba044abc1b7bbcee7b2b486ab284fc047b42390f1ac1b8ea57c7737eb8d384246f8701890d4b629c2debe7ba913ee9b86e224c4cfa3a2bdb00494d9c5594f495f33ede9d037bfacb27334a0691c72ccd378d9170c49364b3e1506770c20fe762194c8d24cc67f84049d498ce2939f4be621390110d18505a69c6f6da50cf04eba3c044501d84721843eaa093a44c35669e233f78fee47fc2cd01aa24165d3e3f7362087301674f446530f9f5b1864adf26613bfafd1e2da9a19360a0cdf8482b2813faf0a0275374c6d3e86de7449a3644ec78418f17578ce6763e32093ac8da2f80bf255496d681a3ff3f0ddfbb992181a7570a94b26b307075b8778b6c915ca2ec7e6beb37e3b9b0166e17554147870db345f52bc619e7706bfb5687d05531e8c9e2005b826d4110f22b85b1b5fb51b68753b18892c8acce1db8eb64bf7ea266f9a210c5c13c2f7a3766bf60ef49f27230a6f9cb7ce035c27e999b9b59cb6c0df2c5d9022b92ce17ed9d64a41891f225257a13a6e712cd8ded5871d4fe51ca3f301df70f2e23d6c3dcb83752dcabf9276eda9b95d7c33c590375ac371db0ef7c98c37d437840c1e7084335fbb99fe0ef8edd9dd26b3446b9be21a756606fa17b0c579a99d878b6571c73a4985b4ad3962e241de6d8e21c0c6e183b2be5f01d4ee4da3bd9770db0b7ae9e0d8fda17c82d9ed8d271f0509f8edecf77190e875e659da50322dd9c5618ae856c722817ca8fef20b9fb90cc79f25c630b76805fcfa044999b1f7b0490e998c86d225fab5c9dc3e888e166374ca649c7778a033a254b62e3892a0165fe433c267de7bbec89c6028969779e20e517a827ab620309a88b1c90459dc5deb49ba4b59570e7c185e187be7faf16f2ca62c2b6fc264fd57ec1b5b360ddda045780e2a72f2c311bf092b372e022a93d36a790abe5af796b4ba16e76c72cdad98cd2ed802a8b5020c8a76cc89bd665aebdf8403f889117c2548f75396aaad3805d83b55ef1a49c3f23546bbc37bbfc84be6518a28dfb675d7d9cd4b9fe7bb4c2b134fa05467073ee304ad04195c2cb438b2091155e83beeeae61102b81f48803c482e1c33f9886c5f66d6f9a3a4bd18cbf8cd132e6ba4778967f62d0113666940aded2d694464c58107af4f06491e5cc1addc91fbc688d25995282c935ef379c570f6b353991642b1ea92182ea64e3b75021f0494a5e5aa2909370a5e09a5662eb7bfe1a404d491db3dd6bec5a79ba02f36253add46523f44d907ee96f6a2d9c379d4684118e4359548889484a23c5b86a1d3851757a144ae25f0424d958f41455e804ac4f476daa8b66e358a3e72a5dfbabfa2f3c775eade4c123c082cf524d1bd99cc0d6ec58c714090ac3f8e8cd659083f86b2f22ba2687c7893d4926a6e26cce7041bb0a2e89719c7ce8aef584ef3f490d0244421dd98c95959d74eb9a4366127dffb8dc99e83dcd674e0a0467cacec883e66c646007e8d474507246a7241b69fb2f8a03373b5400fd3d8afdba4f72a6ec25e66433c982e463b29f6f19791b2fb75589b473688893b5fbc61d4182dcd80ecb046087cb30fc08bf1faa15c889f9a58263d636bf78d09863f955386e8f33c4cd2565b9f256bb3dafadfc03f7d9096c023b6af72ed225cc8736aae4ba17078adf91158112b09bd4b322ffb9215cbfde4f1d8c83b0feb99a0980509962bdb840202466c208f6c1cb271535c283c4cf65a1617e374fdd544b7a7604dd779e24361b1f9165f510c8a37abfc6b9a12710e3095fec1fa2ab2acf21c1c93a44688a85a829994ec84eb33b1da902cd3ce3b4451779e9b81b2f04530a42620070c3c756ac98b1f64063acec080cc35a57e89356859fbf5ae893d15ab2551d4cf1279baabcb3d083fe738870f6a3e11d5b81c8e6465355cfc9f8e54fabf0aa6629d98b7a1c62d511e00066fd1d3f2adeca31353cf089d6aee82b5ebf6c5fd31165edd58994c4c12204f00514f226b77e913a12ec95280ac72a6524185bcb891ac66a1576bf2bd73298714d34b001ef463910d48c222af0d4b816a6b7da0149a5004b924ef4d30c4cccb25040caf0fa260b0a0b3bdc0ac346d3bdf94f7d2e5feaaaa0bf6d8edc6c167dbae98b0e2fc6ecb00c607f7afe933b49f4a6b535b0e21781f3e415880f76fc5a61d8dd44189b5c7a8aec5eaba30c9d2b1503882b3841066ed8381bc1591ff21e9c4ebf6485f5956cafaf7bda437348711898d7bd08ea86f5cd4aad4181807522a6b46055640b8e5f54db2d13d1cffd2dfb7d14d2265f743de78aceaaa9bddeefcac1d2f9c3e4a1c5d86591090bd8aa5d10f93616440a2182bbc77e9737539b6e2f464187bcf8dac028ec48ae014a03f8a06185376334e8085d511cc7b8b224f824a9b4d40c81467b13d50e3e609e1276d27a84674ba86011a599f07af5e492cd5364f0621f155a7d7a7f97635b84095c6a236b636a1947364fa83bc2e13391c1fdb21a915719e9e12609351fe821f2acc495487afc7c45605b0a86271438f7487274c6fd945fcdb4cecdf66328f6a168ca9b68437d2b64a1013e2a108cbef32a41fdcb7a83aa221591acab014e707e6763bd8108ac91c33c779308218b069671a7ad2763d2f75042b7d2a58bea27eb7a241df532d6180b81ed424ee4bd67bb1d46aa1bef460abd093783a316a624ae09af5fd40b8104171986d8c40a9c5c60784c76f55027fd9d5230c5b44758ff80c849802cd64dd67be05b536530544e613dde42bcc991c19ff6ce6a7b1e7bd63d68bc236c6ffd4afe23ef1e22050e7c376713bb76e7bad62988e655235caccb36a5eb1bdb5dbffdb48d91cbef31c0ed12cbe3982f8e74cf4ca6bbfc354ff901cadc7a56953360760d8027bd94e05e94d9effdc1a1d611d84b7c185efc6e857921a5b56202aeae6a7b9749d8adb2aa67eb031c65e61bc7b111471d3be3cf2f9614384d28a7049ff9ee56b1aa39972294b313346b2dd920bf74ad11fd12837b867ced18b79316b1774a34a38d1c6b0220285d4e5c10f8ff9466da7292ca1eaac6cb6d39d5201aeabccbe9e8c3bb787cd51ac3248c0e73a241eb78d0a6bde6b5e8cad971e7d454e187f00f04b42575560260b842e38ea7a4cdd71880de1a4d192483e83995df7ffd8ea6c79ec7dc1bd2661c6d6c5437d1fb0c5592bce9d30ee76cadea80b015f06a427176a6cacb233249355aef4efe5c6cfc8d7859ee975698c47bf815eafb8e7122e739874d1ebac854884273ff683175b5cfaca38b14af3c49be676ea78c9a0eb3d84a85501696ca9bd03d3346c1f0ab3c2fe04cd0ce6522f4f45dbd1dd9dcd2e05bfd9873cf2190045cfb803b830e048f8e3247ab24c4dc6b40a0f7098ea2ceb9ad87a783486e04a3e65f0d2c4a1477a7b3890c38b4ddcc5e11faa8de9aabf9345da2cb050bf0bdbf7118f325ec34b1df77d4b89911415240548391c6eabefe512a346380ec22994514201dc506324dfc7f2e8cbbba9bf72ed863e1e4cef37f1c693f3b2a9bca98674dae6cb2d0db7211494d9f526cf256d10d6b67858d81c87ddc62bcc876fceb3a026d43dc1df91966b7d1f6e7c0a664692e0c5fff250a8e74706d81e7ebe34d721fbeca8997b09f669ca7c113d5ac7b7d4e1e36939e4a8081ddd1e4bcb7393737ebde9e1e4c6868f40842004815a16184fb6c4bca19283d547fbb77152dc09fe255ca993091bc64f0f59df7daf92c3eb6ed0a4dde7df80596f0a8d6a9cd5f77b846a596233f3f68031201646479ec74c5d796d40b2d7980f4be483b9ba0bc5582e623f85d89fc9d34c5662884058be0d28e039176661029260c655213068df0a065af8cc5cc8e8fdef29f866fb6631f2bf6e6e8ddc33eee4b276364bbbcb549089667dd6befe1ae78efed79c1cc80d291504bd3b78debd582094d82b9da650309bf7753d12edbd2b7c73f5186d5c9268ee943fcf35c42dfaaedf31c221dad75c550bd622092a6cb18867d906858b8acaf4982e4912b520324e10ac87cd2a290efcbb0c74fb862352990cd3fafb486a12591777454742538ae9bac2d5ad488b84e12776f70e62529d4665182e0a651e64fdb655c84a1a02572431628b0011966b2062fb38ff9a3af513161fca0a989cf3a45f0fa3b17b329ea385c1882fb729be3a5fb0d6be7d30524d6f55b9d92d32a5a42f93714c9be898a83f9763f73ac39c8ed130e94c59f95dc39e45cfac25f66a54c81e702a546e54605534be2b5c0118022dfa5b773fdc147381782643504bbc577962f0f9b29a9d6a82f89ba05154416fcd43bfeac8d4dbcb4e5a0cc40b80dc7812ad7e2a1e7e54c582ed54aefcf0538581914138134ebeed1b113be215bf3694782a2f201f505ec7e9229cec67060cd1d89385a296c3f2e511e05325ae48e588216ddbcccb790a395561d25bb24ae46d70c90596fbda74804579847f7c7a5c900bf606f120613d3c4bedd2c9e775e5573991baf52d0f0110ef5b61c341c15a0ce685072e6b8531b23b700fa2464067fa4c7d18c4a2deae9902840b2b73721b9aa1aee58bf7b77db5202548606925de81aaccecaccc5d303123e8a4dbe7a25d8bb1fa6783b5f450dcd9b0d706f33ba52076e56a1d51f90818a8e09b2a2e88486d5fc32ea3224766872d4b425fe7b3437721adc59be49420a59f4404ee25b22ab34dbebeaaa39abed6494b896cc7c7cfd59ee7bc775f5f74ba91612460e29e26a7acb3be0509d80aeaaa3159e8240a48ef8179e2e3b420118181a664d972b4a4809e2ef1683d23271286280cb65fd774a054795205acc33ed0c5a84997e4e6e68eb4c32fab604bc9329eed16b431a744d263f5b7532d0979fcd0ddc3ec2e5227d9acb22d6ae4b5d50fff37e9bfc32e794244e278a23ab56fc6740f5f1bc8650dea62bf24ab4126538b343e0e322f2927af55a7de2404cdb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
