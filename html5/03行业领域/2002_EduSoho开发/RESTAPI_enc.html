<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb1d14919ebdbdc2b1c7571f6952b887c7e8218f8423cb68121bf10017b8b79824a1a65c88379efa7f620fa5e6282a837e32610b91d7c096d8844aa75b296ae7682dbed527064dd63bb06ed6eb2959efe9952aa4c2b81987504c9549f7b4fb3d1a994dd533f37a26e9c55782b011c10a92f73d216f3b5267c8d4271db65e4e8ad4ff3dcc8f6981f671cb83cf6cf685c9c4fe7cd9d44731c449f8044bbd7299efb1f5a08dadd4b588b9c6f386e95b60ac32861c95bf80cc6beb48dc6097878eacdd9407b45e1c5bb4d695ae10f6c9dec7d0382e28803bd64d4b531c81e7b10512195684c4a90557ec8e51d5ef6d95b5d34407b01b6a714897957f30e66d07b9b8b0eaf52fe252ab47980fbb2c09d1c96e1b9d6c4ddc5eec923cb266c25be370c01db307054b09a2073aceca76a7b32da3a6d9ab59898b991d499615357d620da317a52199de81eb48ba8028ec6bf75e59495847260db3f337e2e40f8567f48cc309ff2e63b2ede31911871696ae7ebeb47d33a2b58894c0055d88bf7b43d133818417cc73c6dcdb7b31a5daeab494ccbb6fbf180acbc7676a5bca847c4557095e7a9aded9779574870d98c070068cdfc3597b12071a16d60a3d8e8fcf3c831d7200da363c968c22b88a801ed669dc8597e747468c5e4af1545e215423a97b416e0eb83b0e2e4ed470878d0b9a7cb478dcf43d1bdec68b074da572fdd674c5d41baa4010a59b77510a53ea3e9f4274c2bc0d3b81dabed67e8011bd35edd6143cb56fc7987aec163eb9c6c4d22d4a2021f96ddbd48f12dabd3c8c2aad5dd3a4fe121141eb1df00d486b10d4d7e650d6f3b2702a2994a1a780f629682a1050defbc7ee8569a2353a64689a4188486baee29cdb6249e9e1cccb43b782313072d3341dee77b0957f876b553946c5e0a0605ae82a6fb7c0f146e7f201bc542c81168ef75a50e443e68b578012800b45129e0a73fd8c472a832a3182f1d4483f55b3f61672ab1ac9a0be06f808d42ee8279d4ea332a74d2c708ff0f65fed8e17c49844bf9890536469c857b8654ddb9595f55c50d74b398b3bd0b13eef3a629d48a14175cc6c6e1de224725ba3d08ae5c99b338b9a146296d870f6e9e49246494876b852920cee87ae452f5fcb3f715dbc89968872292abb508787048875efb6d01738ace864bad40dd08e53dda002c591f4578037558414d85708934d2d42a88a7688c91ce7be13dfd3ee53d0c7d9bc00e13fc7c9b40cc87703c89cd77e4de65173c293e9ed23b6d1e4d497d7dc49e81be4e726c1f729f87b10a671f075fe06ed7e425f08bcba764228415996349d1dc8cdd86d8c3feecd03e4159a9138454fd5c8853be64f527529e11f8289b5b15f18de3fa70ccf74376cb426088aaa57aeb197c61f7253e9f66209d8eb95f1ca652646d3f8886daa1a913e40b30e464f748847814415b2cbe7fea673d7818e7faa1432dc3b1aae8be24cc31b8ac4bf5f82160a0dda0c2cd419bffeac5e35facc38df88db21512ed4c42d862078fb03c6f7db5828964608d56e943038011a1cbbd8c10778fab135155d14cc208cc01277dc57c157b3413ce8964975ab09a240170189b7fbec8e3eaf7242c18d4a11a93a89716039e30f05895ff25734bd4e2c189dd3e54f44157e81f6594b0fca3519f911247436c67c7adf0f74df8fd6ab24bf8419b0d2390b25666c2f1862c6eae2db78965bcde1e7d32e4b12f9ee6a9f133d64b712b07d38fb94bbf3d52c3eb810e07e963ff6dc9d118036b1940c7adbd710072401623a01024e7294c6aecb8951278614bd9295a3ecfe36c8f665c9a3c72fd22cf353ad2e0f43c02ff1c8f36cc71d322d156a3f3f4b802d995df6681a7dd149672a50fcb8b0ce56a7f5f1b2a120a606fbc89ecb15a9d351a1e118c9126d6c334ed3045a19a2bd253162a6a913e2b55c5d01fd15e0ccf9efe2646a3c7a46989559a10be77a00b1cde70f04fda17478f78ba41f441ea5bcf885ee7d082e18ae3aa364ac54444ecfd92c179f10990c766d03fbd16a1ecd865203cbb2612158e28320aa6061fd8bfb6f17035f8c562b8ffb328ed6ae91708d25eea3db27af5a6cc6c8fe48381e245955cdfe920b0b7183e8d61d5d6fd0e22e1881068137e767b307c43b90b6d7f611ef4a66a84d682563ae68c992b2a276b650f33ec1bd5954504b30e8a74e5c73ec99ad9ae1d58643e5f17c87c0bab66b318f31eedd159a748bd9b1a8edb013e2c387e15c5f25b6e226f9f08231e7192bfa4e201c2ca4db909b136ff037a2b9eeaec7843e6fa27ab0d35ccc79b65ec1b987f6b0893e4eef5d0cece686db5a200e5ce32d1e5db159f4832783b80609ee007fd68abe5cd31a25fa3a47b00d5ce9fd071266383872c4a889c15feb92131c8d6e259614bcca4000f2a3582d63762b44ece0b479fcaafaccbacfe69cc8dd73ecf93a3fea8ff7375ed2b4b39854280f1361958e8e944bb6ffc86aad549709348417f0c95dccd37364bfd87a7bc3f2ad9024c6ab8b331017de50869ad417a4b9fd3505edba744cf70638373c9dccb6ee003a7964540504fe34831ac0b99eed60401b3578bc925633c574c27a7b7de2f9abfc215a86d4d63c941698598c95fa9375dc3129c929e8af32270aa92817401b3a7dfc6956fccd3bcf21824a97817bd73a3cd7129816aa4ab3e81cc7afeba293642fde32c3d4039800a37ae0c5ddb252eda508750f89dce91bc3f9ec25351d4f50cbce786e3c3f9c821e06415153e7a33fb598fa45cfdfeb051dd48384190bc6bb50801060a027eff21f3bf79ab8527d54a8117cd54f7b955ef58d516d099b204037723193a5308c6c12b7602ce8efcb1baed8aa168f9c2c4b898eeb8b98d5699e666bbaf700b8a0b8e04d9bd586106d5b2560721ae750644216c26a1de9fe25e8623dbd80d0e6e5bddf3383a9e8e3f7c0f5050419443fad20795f5164478c8887f8cacee77289add11180baa453c1307ade5b9c7f0aa2175fdfacf1b6c1c31dfd2d20ac912058d26de89708e490f3a62d99baf38b3d5126c1a9250b373e550550079d99663a5caa5eecbe9989097784def7c81ba1366ffcfd6c158876825abf36e8d922084d75dd2fa57d2f3c3713e35f24d4299c38bb76e4c809a7cc2f403729bbefdae149406782496cf1d0b4a9f75b2f676557b84e1378fb85d8097f8ff39b23960d9ab3305290254a0bc89ff6afde04c9f9813874da2b135ce3360b5751c1b0ec7574185ca24318afc235662086e76604704d382618f45649c0391848373ab50df3b219a0a1628c0e55ed10a4107880e0ebe33bab025d5cc4b7b92adffe8f7a2a245fdf95be3df27f82b8055dd605798d69393d13c5eb2b88d5c78e6b6879ebb2051ae5cdcfc95f586b58f87c2aa8f8804001acfc6ad36e27f3c0a149996a157b38c2c0851106b98b3ddb3e9aaf2db31fb11aa7fa39def7a4f994bc1f7d5b06f9f61cac86c8828b2ae4fa0431c64ed90e45b2e27b2b39233a23ee9fc7b2ccdb4736379e37500e27c688c4ce269abd05e55f54533499a40361b30db3d4e5b7eb2ce4fef1d3246ac950f403f8efc23b6bcc1be62565b6c78fcfe638419c37555070f7d0a2087c9167282db4db97cbd80f270f9b0da909aafb557bb823c7aafdd58969ede6c351eeee1485f7ff46326abdf306cf296d90e53b4254058a0345bbe14f8da60ade9c5dc6a2c6d37196c96bd2dc7a67abaa138226248f33b986cba62e20e35045fa84864773616b02e811c7b2b886e2c4bdc875419f368f298ce29f328d8e3301716d11c1c81714218aaaa2d04472cdaed0831acc328fae9b58478a384cacba809319299c492d97acac79b9eea11a47b512eebd2e05180ab4de2ef782851a951c82aca66ae0b23fab5d51f6c77d02a58ad99633cba769fcace1bf5a5e3a8547305fe6d5ec3ac647ce549265b412336ca8d0a11e93bbdd5e0ad34a859c798e81b5b776bc42fec21f1ad95666f93cd1d19f733eb46ca3ece558de80deb36c2ddd2225054cb6f5584ebc75d2e930f24e1dbe9cc03c844bdcab02c6e18682e48a5605c83a6eb30b905e646d3c55b422791983bc6a29b761fdbe5c441be4d3f7f2da91c2c7e581e1d24b06216f1d9fa5d15d25d08887d6e73f6f9c15a4e1efed4e682079e7b9826d1bd4c8ac46acc440a93fcc7e16f8b4265a8824bcd5c1c9a02a10c09ba6992e436113e845fb91145f3dc53f1605061e26b3c110a580f8bc850035636826b2fbe2ba8a2ff714a1cf09dae45f47f72b8b6a3dcdd489fddf0d73ef6aa4ebdcc62cb76c62dbed7173e12f18d2eedaf18c92718127c0da56a12811795efc0dffa0230c798bec7bb8c6327a6fbc2ab79d952ac479549499ba24057de1349e98cf093672cf8094491f6971c93798b13c5c5f74fa8d0970f00bf8fe43c31f3c1f4b1dc90628e067567a56b76371c7a5936626678906c47986e9094ce511b6c335f71acd1993a988cd011abc0716aeeceaf4c48cf617b95e094d724f1bae62670a2f945adc65c7721050ec588d268f316987b5b0be79dfc2ba3e50279000cd2a7734a57a8b4951923270a36bd8432a49331532653b8ed41766bf45e97451d64374a73453cf5ce567b9307477a1854168e026a0df9ca6adcfd1eb359d1869bd03be0efca157d85e4f281e576104ea402184fb6798ab983ec693e7092eb1ec4b92833a2c805a0e7069994f76179f8ae199bf1d7ef78dbc3e491c7acde16cbfbda0415ef3c2370f7e2569a2bc93622735a023b9caf1b8ea8d7ae2860847473a1eee9b0133da3ac8131ba1cf6a988cc96e052876d92b9eba1293ae6a49e96f52251d226dffdc643a64ff89243bc52b6ba7c7b652bfa2b62e3b42da243f64af89cd684ec04ae9f622541031e97de265ebf315f8a5b51877896a0548beb9990c91dcd2a3f683918dcec9b293b94ac07e51719b4b49f8ccfef9212c70447fafce02674c23e2036283bf59b9177d54eb5e13d6253949bc6b4c5bf2d92bdbb98e5a3e2364adf076f8fd0ee8850dc94863c455800d278917124c3a88e09f5f4f06380398eb3df3d859ed87b85000663244a53b29a7bd718ddd9771a65e7d6b20365c3d6e95f44934d7d72428a27f3a8ddd4d91af19937dcf81e96e26c265e36c06110d934cf8af3529e1647dbe1f6e10350420db9b21bdf7978c7fc9146d91da50566651a12b1c91eec81556562d7d7fa79d26798839794925dcb9b622fbb4e6ab33a7c4177195035f90a8eeedf64c558465158b1d421fc0d32bcdd0227716b8c0c18656f5fe4bca1399ebbcccb9154e0ffc47001f24b328a983a4f056e81c5856ed6f4ea2f1f7dcc499d84677eb82734949474fac7dd805f047cae75384cd12d063cf30a9cdc7845f537f29e48d1507eaa194e2b72c80e27f9700c8c49548bbd32da942d90fb5c990164b366cea0547bc4fa43ad6a2c177c86b093f5b4f923bd24c9b953c1ef0089040e20e06876666041227d664b7c80b39497a952b16a3076f4a2fcdcde920f646f6f7c39550a36cfcf44e4e6675b4dfeae7dbad1446805f9cd7221ac0516dd791b49067e13c70f506d39f183d29d23a93b48ab63663eec814373a28220f5e5a90cbf70295addd851ffaca838115b1b3a9d3cb4c530094012922ec480a55112a70f9cb6df6a2ddd6c26b8267edd5fb99679c1e162d6031b5a3bb6ca0f9e7e6ab7adddab5c0259ae2f23ea471d4630d6f175797ceb4c0531fd13a8c790ef9fd03f370444ee202e553769315229faa816af0c8f964fff74a9e02ca344896cae2d6c02ba88f6b84632e4d6ed55452fc6d2935bc7ba908c74fa2e7f2f445817354c37d8033a2d4c6f726fcc1818fe4f3aa2ab21f8075eee91fdffe6cd92cde5deb1cdf19a9001dc3c4297501c46392407641722b8287b380fde232be3b6d4c7b3352c389caf2c92eace1aceb001d8a6dcde459b16e8270ef9e82e1357ddd665d1224ebe87219c43e1f8af5b921c399d83766b3d74ac5953c117a3b06c3e99e3ae38a37b3faa1a4a488fa7f62585828fb82dedfceebf7d0de84e04e33306a3325907da8748fe4d770edcae1635f79f96fc9992e45af786e453a70c896c5cfa878eeeb2aaaf22eb517b40940ce4d299eda7b48474504153a0d0fb491a2bb4f821c911d08b24d02cc5f5fa20640f9b1b9b4ff2c2288763c2002668f048545d1ea6284b2c1259619594269ef55b09fa6a7ce3e6b6be8d68d0072552b4d2613a5f8ba3cd05d9992106bb68797f93b33a6bbbe2b27eca4f6d965f241e00f7fa5c39db8fbc48df5af726b4ed9d89f564c095073b42b482b0e74f2f2cdfd0660cad2b2e140a06272fe0093f3f355383b04dd5f615323835f0230b9795cf515cd9f8f59002e50586b5aecd26c091f30f172288e2664fbafda361c989f59237235480da6c80a084ac7cbde3931382e7dd2e726601cc4b3221892258bc91204ddc99e5971d876f6ad1e25c3130a403596d434d1292d3066804f285cc0f6eada823636be89fed640e6e4d23b6461d649d43e67ecd6544d8b946f88390e28269f2ded25de20a2e50bb3477784df57a42353a858d2047066885aecafd60af77b7ba5d5196ecbc7c7c211ef0d5b0340642a3800fd44b1f4f2ff1c73a360d75f0514d81b8a4a4c8974edeebacc41857f081ff902ea7e2acb0a9bc63f405a2fdbc9010c0cfbee4042432c8807a856f5e8d17a69a8c656cb6a1c828decdf1fbcf56261b84c019026681415896e808a6735e60aab003eedffbccb8c78bf404b2cf00c5adc7b75b227fb02e15d05442ef8d1b5ae779388e1da99642999abc6277afcefd9f296d70626d2a45aab02e61e6e51affcf78dcdaab0dec7c2aec1b6e7901ae99780cdbfd39766e5cf06c4a8b61808a7112bccf0858c5dfc69aa2432a9408ce388a914b2d7188d3ad2961ff178ce4f8aca7bf003c72b9049b1375c76c6c0dbd3832a1d72e250c1c4ef05fb8688effd3f6649b0ea5d9f97380fb3aa3fbd39da2b10c94dc36ed7d4fc5e9260a6259a5a4b38ec387049cb977c73604ac1770e65e2cf60fb853d9a63e9641d36e3602020684ea9fa5b7a7d526e4377c4594537a52c0d87ff361fe56ae2216f48982b6aabc446b500d3a8a1b808df5c489737c20ff11c27f9bde9b446ea16ac6bbd1822caa379293f7bb98817d3f70c6ff68a6a2950cc69ed6582dd61d8749ad5d201a770043641ef57635f83a9d0aafe9df1cf599971ac2e3b1c5d9dd7e6462f0f1bc95b25f3ea7e9e737c625637673e766c524ca18a9a42f5ccafef2fd61c1c30eff39bc7bb0ee9d70d5f4f07501e29e4763e9d5584af7b28bf688e9c1ac29ce36e54b138dc39e83e1674934b8a46c30447626c5388a8f9049acdf170c6f303d3c0cfe8b64fe74d758f3e4ab630f8ce2ec501a6b62a88db70e0e78a668b618c5ed3c49c938fa9ada07460de6a335ba85c7a7885d93affb836aa3b22f48297f25bffdce81bf6d926e4d37d8ee9bd9dd2b8e5f68c0065e3a5711110f4ee8abbdddec98e2a3637975b6a56e9b9a779f45a89766b6fde531c391c921bcc36d00f23c45a9d7b3958e20012c9f9f3f0afd77431ebe50441cbb331d57998cccb828eb11895fb38bdac197ee3c4ef104252bb6288e292697cf97a3dc6bce27b03f700b2217e9513e8a0ce24efe7c5a7040755736facbe5d07c4b1b84c0216af63302f0a7d3e5aa88026d2fd5495e8115a29b995d0be42d6aa237ae06bfed047a22020934ed664b75085754dfeba79306718b9e0dacde47d1a24a8a4fb206e954b45c3b8b96be7e7775f03decb2181bcea9d4adb2f637041f3e59509f7657068987ee41b537ead8bc778f842921a887a64b4a1fe0494acbad2f271629f890efea3b8087a3777144e0359ca952d04118af4fd09318313a94f13db637f17536468d5994b355f04844cfe848f8e2ff8c17de01ff41be2cf28dfa9f5ac15d155fdd8b0e0e9c413205a3874ca4de3bbf4a55929cc7e46a52819c26b06eb7d604deb3ed12072fce4bcacb4f8af68296802d34d74a3b97f76634675ad2645cfbf0c5e788fe9be4be38aa208ecd897026ea12a965e2ce131d5454cad398d6c63845b83bbf8d20ed0281402626ff933fa59394a7113ab88e7b480ae57cc1ea59c75b20cce99a3acc7d9b2ac4826d57c3feecf4a427ad8dfb8bfdf23cfc36ecfe28752ab109a1a0f8f5b55a6297eac864e2897b0cf8d6a7533251ef3c768ff6ff27c1ce0d74521d48cc41edb90e058046d93b3f962320c9152137b0121c39893a7c333864b8e8b9b480457d1e06fc34a8933c79c19825c494c623d8cc25b211643a6512cc9b0b7f89b01d7c24fc4faa2c4e2b480656a30fdffbc0e5b31a67a70fd9005484160172b7c6a4afea05d3c4586289e71ae8904df09a4ba4eb7accb8bc4064717d857fb0a7d975b40e7235712bc6a227d55b4768ce29bfabf2a81ef9ce87a60b72d23567046fdb8a527186dce643a0670e22677648fee26dfe0a74ce36f568325caa2768db0925f328c9fe07703a095cc06ca56969e3da1928c7b49205eba4bbec1273e4673e4a8b9d488fd92067ca554a228b51c0b6423a80b2752f31307e734842ec7573c1a447501f76d3ff3b8cbf0c1bdf51d183d9955361d55e38bf1cd210fc6e75420867c535e5036460a3ea9512015bfea31c8660e55e82411c311b7d423eb83477cbe4e78d20cdf946b920d3e4f3815664eac28d85b4a898adb0cab20c5bb48026526d4d3fa0ac0afec630f890ea1ee7447ca45bd7bf666f5699e3c3aff5fbb2df7284809a1a911ad0b5636629df6a827e5c93189b58f25f9ce25f5c30213d07d48be7a0b1a42efbf562f8b88a7389a359f0d5c64ddfb9d7e751467191a52b8b7f2fa09d21f8dc371b33461f95eb639ebfd0ae9c466acac844b61d2e8ad0825537e5cbecab49a77dcf761df8da151b79152ec87f0b806aa1ba71c3618062daffbef6d6dec6ab9d94192e64bb36e0bc39a20c93dafcfaaaad9688e9b7d1c49acc0bc9c7c8940727a5fe2e3455915cf27cf2217cebc3f9e8ab9ecc8113162bc0bc1b55a84052277faa4c38066808cb9d5815ab80f397490c34718ca3377cac6100e0b2db682dd37f99e4ceeedf5e3922d885508f1c9e316a16973483bc39a8100d0a09b658a2654d3c6e9077bb513fecdf797d6f40213bfc1888bfb6fc6a1fdd85574b210a6d42d0ca349255b22d0f0b1baadae00dd40bd9bf072a999c9374c4df4b816be851bdd39c32475ec2927855295918dee642e33e6891408356076b6161a1b721970d7ec963c0e1dfe12fe96e6897e28e132deaab849033aca7c5857db175591ea342a13d6edbbd13a704450202f80ca27724aaaeaacf0c9bef5dd4fcd98b41c173a514eac432ab5c1519bf27b01f18639503c82b5589818ba478b14a4e740758b4cac7c0361c5274eede0854cb8b8c12a5013efd63e4b4bf7854c75754d1229cfdeccc941a1ed4f147cb33d958450bd40836b1d5a723f454687fcc9dfe9e3ee76edc76b0b2ffc4312549ee3d8381cd4ccd025be5a25cbc105f77117ae2825ef4f2f5088d4ee2997a33bb77715607a0ca538c78df17c1edb2d325bfb380354ca55e2ef011f4e6fd4d16a0cd9703ef772bd242243060547de4174201b3195f8ac94bfe46e334394c15fcfa912859dddcff452cb7b46b8c7af4d4e72b77f33909dbcc388bd16849366cf7335a173ba6f63dde38dc2aeb9adda14d461da12e77b573c8e739668090ee596efb8ff19d93e28a98302335044c86222f6fc602759d0d1533f7f28c1f7cad6774b07d8408737af271df5c3a5ab64015d6b6353627330d66a8f9b9a82fa749b1c8809896cb79d6862f76204830faefce4f35115de2d3aa01951948add52d43ac5342c3a689c6a82c93aa16fc533722a65eebf838d5f809dfce8354820dfaf31c03cafb1ee40c6dd37cbbfb515878b188b2a9aad2b1d428d4405c69f6cda70fdb0e57d016d20472d8dc65f45276775934c6071e33cb156d500bc70e25d1750c5f9cbcb26a4e8bc967b67668cd9763bad92f4248f32850ce83eaf7493ebe67beffb2e92faea923bc35c743f303416d61c1dcbf7a68de4ac935bcb505d6ebb4f4b88b547decc9540f5a528b0a900dbd86f378f54e8d9b00b595491c1aa9274043f36745582db8702bc5aee415790c71a1c885eedd815d8920d8cb2a493c8412d3993c64ba021af029c11a7f4aa64ab1053c37ade4ee53fc0385774914f974e446b382b6a127b3a59c9b061ea6ff9ee155650863ef7e781377375823b32ec2cb7de42e28f9348fa5cef31d2b0210b9470a67861bc13509fd350b8cfb525e0b7555cc140d0911e7720b1d13945c4c1c6a0201712a97fcb4b968928860291fb6bfd00494c3eca441e0ed81d2b1c4ce3dd9c1e8b545de22badd862ba3bc6f06900d33ed83c2663d3b1082b66d672c3b6a4913e64fd0eabc0a527028aaf169fbfcc4d74225166eff3e7897a3a6f0a10034c9dc3565770c145980238e93b4b362a5bcfb731a1add0c1061b685ac0beb5b9c4e4a1f58aa15ef75bce8e97d48d34bbacf7130112179b2e94e3d48810e9a198d8a0474d6c07fcf3a2d4183ffd93b857e4e61905a80fbfe9da13a2b5ddc3baf83ce2db490349c19164a0822e7e519f69f8a500597a6a2245041c7c0cd483aa007b19f81854f777a7decb6e74b43acff5cc11dda428d7660753b2f0e6c473b27afdbf312d30f4af41c95e3c4005098c7b93586fbc11bb23b0d0e21f73c92d40e556d6f278a87f25583c4c51d9e4acc32243061544f5ac7baf1ce0166711cc996574523b36a7bd35229e8ee9992b913a208955aa009a60c1da85291a97fff8475b4849689736d41df9192b44abdb175d8bfa876d6b1a71ee1943f3d13e9f835071dae3058c7e1c4ad83e881c4080ed6661ed350b22612f319f943372a866fc999f246420aa3150ae88d5e1bb5e47ab3f962b416c400a66decce1a67ce2e0debc2b8b51ec4e5602e7d09327dc6cae88994e104b470923ee755c95441f857a6db850723a36eada7e8ff3f5c35e22dc2bb3b29486dfb3d552c6f8044e6e7a4d8eaa169fc8eb6bce28f77306722068476562677ad6ecc384b67ba0e2e6e3e421f76905b3d879843f9c00a27e4bc26019c27596ec60493303fbe915d21efc6f91d66bef9de7c303a0101e3ec132c35ce1ea5f4daa7cbc96db28a478879b49f08bbb2b0596728710b6d072d8aa52755ea2dddee72dff8ea1d13905939cf1bd3d2acbdedf6324bac109c6f513b637f473a839dea99a4330041115047062d61f9ea4a8a8cc95c33cbd29200e76bc40a8970a2c2738d11e80c41801dc8ed592709d577fa7af4eb87fb176943549a529f9a908df054c89cacb6a67d5dff7fce9252a2974c62e314fb252b7666d8d52201dae80fe5ef82f7969168b32329f5919fb10618f17bea6b01d8b8383af7a743b0e07454e272294659439584a0489f77670904447f6464b21c077947710f726c70d1b1dfc346f227ea5c14e828fdba8480ab2bf72c46638932291414c6e688caf7bd21812fb4cbbe373d09aadcbb7c0a3af6eada78668a85c3e3001d79d594658f3fe328bab7df847ae9c1a499406430f9b948d3318ddf1967261ee9474a8d0ff7fe7ab17cb62d9e56727e0b2874e7d3305507859b4c1e4321f0f7371ff00a365113d9c8eec50bed5d3ddf8a1b1c17861495a2c9e461469298a022b6220f74045bc1231176e6b907f4e6c5c9cbd157a3fd20587be62cd3e129d66e957a96139100a221fd4f55fcae9e8f2a26ac0f117c545c67a34129d58635d4333f5e6dae71e62b71ea9d9613ddf34347d88217e95a52ab8034dbd9b0a56cf651949d13e5ad92eec3d1337f453a629de20d3297deeb81ec452a1a0a00e0870456ab9d889581258b5f7f91b7082f2a6d86aa3b93de2b60a5bdfe8e25fb8735d71c74890ccde57c0c01ac62f111abebb37671c27b4570ba9db06185334d35db6200cc06580efed4e148c25176d56ac36892923af27956c9ff6fb5f66e9c45e55c62225b2c566e9af1e4675ff9f74ab075c40ee1f1f2ed2f1769e5ff54706ae281533bb5251de51655c6910","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
