<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8c51b47ed14693eb9ff2f2ab0e55b5c1c082b34b609819122efc8b942305a07568c7331a4c2269b039734a8e109d3f0c73da6587efca43313e5f29787b21b5240894f0054ca5fc8059c42e44422e9e6e40e348451599dd099b8e03e916cfd70737dcba6c53f1e2e196e5bb863dee9129353fbedc1f06d4c95d05988285bf9354ad64247764e8dc2bfd0ee32a65dc0d4c7e654f8630c0807038b5e931ce9327eb692e7019dbc9ae5565069924db0f34911550dc2b013fe36571d92f0883559ae79dc5e52cdee1627a3649da972ceae69297927a8ecd59c9fab839488497ddb0c6d96af29ce3944130ee553a0d0eda3f6681828baa44187bc1371fcc74685e3dfc2fa32e06ed7d63dde1642fde10a60c62ffc1a0bfc57cee5879e32cbf2871f71286ece7c0d6123a78bcf85750d0773aad68a0d1be5304aeab268dd405e4d4d90601d124c5171f99dc29496ff50e0d31e418361f77704e14ba6dac0d57aa75e8b54a2d10245f40a4befc1b0f7920156a333ae8c97dc84e2547c9a821767ad98db310d4ca676f56aea89eda8c5cc3c680447297175026a8e25d38534f44a2c2d0e4c2332b1c7d3f6cf983a28da1131d6636902b2e2f2c986fcaf4b03767c37be6f585eda1097960ff095ca10b43314674d3983d1260e598b88d0493811fe2ea39c4026cd396a7cb4f78d0f1429d367a4352526b356d1da7b4c283799adbcb44647b032a1642c5b5a27034458c5d77625c1617e06d4a49725d41b163cdbf764f69dd560aa8d967d5c2f9aa97a5df541548bbb28e4c7a4880be31fc95cc3500dac5b84920ecd61bebc9747c864d688cb541d14f136ba7469eab3241a7c7734f3d14345e63150a4a7f9bb17ead78d92783b93fd7114a483cf7ddfc6464c81b66b98db856fffc808de306f4b3578d132cb710d6e172e5de96eaa784406c8ef3502ade607855d536e803e7e778da25e4f752637a48da98493c709432054af801119e12bac0aef3b3a14c5b3807958d7048f4d5abad1179ab129fe547ad1bd882ff317dad96a273175398a065789e8d84a4ac4da7ad8ee79d23c03244190e2d9ffb82097d561c64d8a2e476040b571dada501863bdfc73d347fb3f11ff4561d0f9dcee93297a31a8ca63a2d4c8b9415092597b81647c22cdf160b2552d282cd27dec6bc92a3628f4c7216dfbbe6f2835698bf41c7016e03bfcceffbd9bbcb00355f97b3307ebc85c3cbb42db08118dc1562bec82959e44b8c643ae9e992c9458535cfec706675ab7b0c77719c7bd14f2dfa387c610fb57693b1ef5cea3331da4c050bcae48833550fd4820c7e1aeae7d8c1a5f2c0f13e1ba4b5e9890bc241b4a476d825fedf2cff990ae8e36e2feed5d1c9d3d486770e058d3c396cd2b877369a893e57747e80cd20f973cbc0023b04647b69d458f41222bdc9ee8d8ad818f98e45b96edeecb7fe2f9ae154ea9e37c0a1fcd5a2696a5cccb4776cc8d3e3b3a08946f6dfa0dd9af7df0ad6aeabfed87b737d0feaefe04b22d6577028061f8ffe93161a102cbfb413be9553b8bdfedf7954977000c76be6f2c99597cef2ef0038f357ab2aa13b95a48a31c616a83bab7c34864a4d461e4b9a6b906e37f638403ac4a2f3e846d42915d5f9a9f328f0903d01f555c5b8ff1f4895cf6b7d095d5ac37fdf0420ac25ed00bea12162025305a71a90429dfda9213fbaba6b61475344911d6ce6ed2ffcef754e1e6b42ce44550c45c8717859c7026069f2a18f34211a9076d91a1991fcc8c09eda32e3d6ca6917cfd485b7f5d59c3551c6b795eb1c742574708bc23d3463bdc0b92cc599f02d0799c8e975cd547fd0a945995a886fc8056898a70e46fc38ebc1addaaee4dcd523010539111c10a90a52107070f3f0cd44369c1dc0ce5738b6535350992b614a27a08e5c9de40fff6f54b390a12371b51faf8a960f51434fb071243eaec1bb8899afd42c277d66d7beeb5160732d415130ee8588251a256a71e47cd7c0dafbb19b6d79bfb70b462555166e75f9948c06e3472f80b91cdc4321bda7e8d679a8a448b9b856696d475d50e737d37cd76a7d9528f8c7ba887707fdd3ab76d5a3af19ce7cf350f7448d8511c94f8c4051b3a5929e2ddaea2afa15014444a1181224279ebb50f67401d0c838d5c00e62622de8d5e65c23e70b0682a4617f1d156020c26ba3cf25f4c88bb5106abb8eb822fa7f8b874733d72f398dc94c18cd293b75d02b783fb8dcf22a0de13b82f252f786ba6ae03bbd9eb0ea86034915060d761daddaa802f7d52c33e7f40b62b1d97bfe986cda3a9cef990e24cc5cd4864728b17b25b392de31be6d24b154c77012cb0d58bc0cc7d9ec04722bd32d705dca7fcd14f19b038e1b651314ef5832a6dc25577b2cbc0aaca5279566f84e5d88c9e86ba8e91d636b019808440996e8d3a9719f0f34ff64fc12ad45f8f30b865de12b63d35c79c87fcacf1b08ba23b31b833f9d0e69609f383e50169171f1ef2097af2adc08c0b56f49238ca129f6808f09e96b99b93e7ad67751a865ddbc5a8c1767e186183e0c8f10d7c13aaca9e6e630a8cc2e50ecfbd23544b54a5720623c65d4f8850f888acb86b4770345dbe1f03afe30323e60babe6b196efe5ae7b27da13d2d7b0926ad3798cc939eed4a2b847fc9f26baf09837292118298ca0366f49bd4175123a7cf2028b665e1cfc37bd2033d14927d997db34b4fb889a5060069ec1f6c4444db0746fe956a46c83980fa274447a31db6d7995fdc073a30dca7997b71cfa92c19d3000b68b138ec42b4439379d79386d69c9a761bbf6cae95fd6d5d644a7e8c20721f735f26daf9d958fc62fdd118adfabdbcb10e502cdf98d79713ff303c0a76451adf3a53e3bbd8a0efa2917a0f2cd58a49c6ea5b2598cd7acd8b742d75ef9970a5b70b2f345c0235d414bdd3ff91704a0f81d1a2af9bc61180884ab4e89ff01d01e8ee359e2eda4d458bcb4346cc3b8ad295c78534adc5abcd198ce23d849a45c9bdbf7fbbb9907144f3203d510f932da0553113abf078f3ac28a04741d9d2f362013adc123cd9973be26a50bfe59df6e2c1c0a46dc2e7ad3864734dc18616a52e64c32c20a31db60c5e79fd3bdb13bbdbfbd75b660f2e521a852f019539124456a0b7dc2bdbb3257807989b2ad4323546e17db03e346beb7208f784c8c00ea7d56046573d8e234ea984f099abd24d228a363110632c9ba4bdbf8e6b0554a9491daa4309741042df61e878e3158a47a0ebd8d8b43937531effe2afff399f4ddc1c2ece3c4b37bb3e0a13af9dadc57d01b6109f6165024b30da992da41b19d94b4df0f3155388f163bcc21ac247969cb59af2fbe641ad695626a494b8ee4003bffa4729610063be91cdad45850db9be8d5161a1b263a2ea9436982938c86b083342fa93ee631b453ed4f629f294d7402aa81536219ea1b51a6e572eee0962bb0039413e68d8b7949c74eaaafea34fe7da4b5504939f461dc08b179565030db899b05ade4f84d859403350491d6ffcd708abf9acb7d7b2b976be17981766e998376cee194a2875a8f36c0f690e3f9f6eb6cde991ce8a975e48c165caf4dbd6f3c5036edb730129ee5259f65bf4ef0f5adc73b1b5905056b98358fe23cf7a6cb04b9b0e63649206a85cca4f7a2994bb0f3586398c785454abb70308669f01ea41e7a3fb4a6b871ed3a8f4a3b325ead6c19745b9d3bf4adc8690d7bd2120c8493ad776197dc27da7e908ec64af9aea169acc028d6961f1952f0041a5e73c639a6f3a418f8a248be68dc5594bd61c1f47c4226b829fa811357bbb59ffdb6c1fe9b705cad96748174d511617a14f166e28841142e96603f475910e5e7397f4d9805530840ea4cad3ca2a2ae494c5113aa8545c7d01559388d8005230f8b477592aed4692647f62e1ef211b9c26116f96b00d9daea5198a86672f7909f57fb1f66840e880880ff327e82538e4f94c1062490a1d1c91e609c5dcfe107329f00ba6cba7efc038329f13d1e928eb2e95718b04513d816e185cfbcc8513331efd809128003ab4ee05f047eb8c699eff3a141e2b5623ef4a1d9a0770fd7fe9ce977b581613d1c4f8935385fcbdde95070cf4560f00483f576cace2664d1aaf8cd97cdc9078e4a1002154330ed8fc8b49e9a732a1969eaf39bba8adc613dd1e9ce55568cf3f268854d7ad57c5bfc4e78c0a0dbfebff6d5cfcc5650396acb78d4799c3a7517bcdbc24d6a3e8f6a28dda13a7d252fe2366802d9b559481c25560af57e1d9871d1ef97bb24ebcfef2f40b8c12b94e275d3a56b21113dd9642a09d55e7ee3c3ee06bd93aa5f68d655ad6d738ecbaa2468201cb5c75c6e125ec03a54ed940e67aff81f54eb345b964651ab5e11a77654e7ece2ea34ecc85fd7ec7f249da33a5dfa5d6121550e6b5d3ad2ef7478157dff8c514cb9ed02edc5d3bf80bba57465d0cff029ecfe147841429c1b379f1aa302df2509d0b9d7ba7f5902f06e85e40d579c49b6486c6be46212017ad1e1c5c33444e880b23e28d50384cfe803eacf7edbc1d7f0064ce46151cbb2e3593b955077f444949c232501760b96266f49e841e76c069047866d32aa03cc581287eb904dc7807c7ba239b689e727d3457e106dde9d7edfde413c674a6957bfb99add1fe98c1f2f0039a6a216e1dfdabf4c09fac70da6d5bd47dcd90f3b5ced131b6bc51bdf9b43c54f290610fdafa0785944d4ba28299d985d18f03324042c9674107b0667cc486638ff3b7d466bf25095895dd489830b18a6ee9ecc4f84fb9b06aef31014868c0153231ec3d2d388b6dfbcc50c8d2f6b4a60c4d0ab156a28a8fa57cffee657c6bb40ba78d344f20812357168c6280a87a68738ea3eb8584a959767fcfed01dcf5cc1bb87a39dd05fcae6e1eaaa94c6ce1249c65295b96cff9f6852fd06bd56711c275ba2039a25c0b2c4b38e318a160d6799cf1b230ef95adfba5d9ccb25fc8ad3d78d16b839b79b9602f263383bde79725553f082335c6e2f160232febde38ca158ae9e64504ebee4d1bcfce5b9248a9bef6f887c2a06eb9d92c2d0fbabe78c165b27d924c9848212accc100bd93afe52812348dd9c4050330d46cbec3c570833c60c50c5c8520cf0aefc2a2dcef6bb8c9f22678258274da3f450816d91d9f9e6035de400788a6a44171b189b4eae79913f085d4a5e38a6ddcff8fc128abd58e423f96f8658593f7459f25c8babfded580a2ad2c7b60d7e88c0fcf324910ab83d8f3087afd7d416095518e6d206b5ab430613142778b79b79cb4805fcb09eabb720e316d3fc1566d6083f058ef488a3c83726dce5eb3b80f0ab51d17a664e1a361893942caeaf51371c219d0381a99e49426d0b77f79e11269014b120bd47bf8bf94a4f40e60e85b67af88e75ab024cf9c3d367572919ceec7604b0aecde31173e2bb07a0ace298af290a97576d0065c828eecb752bb670e9349200787787412432c1441f20817645f3483eef33c686f4b483bfbce43b16eaff8fbf46533d5e3bf87c665802299f1772b9d9c91eb662bb74f02a2c022c7f38199c714c520c8415114b8c3b35bc7ffc964d5ecc57ef87c4659dd63b478e478c607034db70b4cf3c6f0b8a42603acab19798da8e6a7d6ccf78743bfcd66fc74ef8024322a8360f48203d63ddbfce9672cb5e3b980e31bd07a9915527de466301f9c8920dfc24af9276f50358e1005d83a457b67a4f56465cda9f88de744243f7fc911c9406c6ebd41eeb308cb49cf61d56b5e99bd1ead4d805932cc7de7254931bb5d9dcd6ae55ff7d74b733ef5fd537b82cd2ad65c226c9f8ab4957377d85bc4248678a12f727e538e942ab3e3dad9e64b358c0fa25a15f3fc0287af19849e0d2b9abd33aa520ddd1b01fc1c5d41b90c81825f8e4f9f64690be58cf47dc12de19e264cfac69a4fd8a0ebcce55184828717b479a00695b0d7bece606570cbabd25d060760dee4c5d089a5548b05ece3e5b63529067089af255ae393bb27f2617aeea396421c1c736968520bd2dd0a057d42f7ae322de4adecfc42b99460d7bfebe6b7198bd8729589b3f668259c6080bc6be8beab59eae3d35993fd0144e5939dec7f1085fc984dad12f0a1479358b7b1001fcd19cd8b6a90a02b8b5603a77cecca6095b20bd1779a77be18ae7bbe0001751973ad9b08b9445fca1b4192a148355e4106a92cb986ed3310ffda2dc4e5b66892b3c705d68fe4fbba64ef1b866a03135df65576da526db15d09e3bb78ed179c133b2652e2fc6c4f85d6bc86c39e17bf37c2c415dcc61f23d0c1b54c36b13b7d59038b4279861f7f7c86b2512a80c3256de6e3de893005494502a3fe6cb27f90a2291f98e283d84d7b42c4300f20f0b21f4fc8401b058074e6c5945913a5e933b365ac5af1bacb96cd75e4982f0b1b8a401082fec7a577ffe3d7f394d118d254435e96abe1046a84caeeabfbff3b611987c48b8fce4da5aef6558e68387ba8f82e1dde7169690107cb94a3bbd61b0a17ad7e8b1e7dd89b56032597dc0862a9770dab1f95607c9e0b5450f57ff1829e87aaf1cbaef196ed177c169550bd588c5979cffa0bfae72ff5fda5c88e45d5745ba3be59ff42c5def77cac2fd724ac2d5e7e43704c21463ae3aa8ef7460d138818093e45a2f22d87d4d8ea37013fca34a9dda52dde6b824ca81a8dd455bc372287fd7becfc0360e6fce5a9369b090632a75c4f137e4ec192847a5ae58c63f994d85319d8c21d7410fd1dfcfac32aa8e0d2d83993ff361647cd4c458f04d9b9ab3ccda8a678ae50bb8a31bbab00d1bac60839002b795175f1b2bfc2f9890dec83001cfbeb56002c79ad38fa93dde9d5be58766531bf42d088c6a4e9ff5273e4c427ecd9aebe5321f7d033893fce8129d54074dfa40dcd4a125d7700c6ed65b72107ba35807f5a732b42faae55dd90f95369b07a2d877c114706b4eccdad1352ad3719155ed46318422dd204b266f682a722b03cf303656ecc6b3fb55c2b951ce1062b1e687abf33098727be749b78299acd18b15223f76978f1fc242baf6f23fe3e0c0a211dd722b77829095b83faebf67c98f012b4baf2668a030d0016eec18f8a89cf87af6974c7cbcbb1154bf3e30563d22f52e8a8a46617da9dab779304458d7eb264cea01d430d4ea1c11135a46448f217cf354410756f1ea8c3f5b4e80840084a58d87a73e492213dba57e67cb84f3bae7441ca0d1be4846384aa13dc735f70f1caa13a8e22044b184db3909362017d846a95ccafa4f5046449861bc63ba5b54c6fa96c670cef63eb38803c5f1f6680f2b51ca594d82a291978ffd766a7673780bf9468f6d1722047108567d1413c0eb98cefa89f65d648b65f51f04edf17641726aa74011af11f81b4c5a4ab32d62db76987d4edab0a76d9658de1b36716bab198298a715c4f2efde31aa51aa677da622b0d5ee961bfc300a5a09a5b9a66b9daa2c3cdd3c9a66565eb4bf814593bb82e14b2a9d5138dc7bb63524390793d0937740d65c668645fc7fe451edb105caeb250d4d5f58da61d6ff08f99de9c461119cf1d6a863168ada1b0902984fe4a290c347def982e55fbb7957499b5d0f6f7f7a64dbd6995a14f3ef3e4241f3981eba092175fba130794719d1fedfcba0297f38ce7ddcb866e74b3c643720f502ab05ddd19f4370fe7e8f0a21543ae141cabad7ae5b0f63163e120250fef909fa66522fe4feddfab1ca0c6c10763100dc72430976e48d8df7e8776b38ed0fa732eb0b0aa259176bfe431ea579e4314874a44fdc407b496b71cebbc96f739288d0da87b47c4379004853e441903eb50f9da3cbf6c226e3788247b03435f65ffd0483f3ebe9bead3705a652838aa4e469efd58b09486c0ec6052eee51f197992d9a007ed445746debf2120b568810cd9e4e48a67a271e5efca1187001c5fadb40ee403eff2b5091cf955e8e25fef60a32ab1172fd9adccb4d591edbd2cb4961e7441464890ba0f57cce1c900b88748c93498f84f4f5b1a8b69e2bc03f08e49bc19805a7118626e117cf826bc8efab3aa101c70c4fda6f2fd53d3d067c829cdf23da8daac5c8ec33fbcb10b5650cd5394ed76de056bf45b39ffda80e690c4676886307a419c4c3d02e88b840016a97dedefb87fd5496804781f08bdae123f7d463de99ded075ce865b020f971ca8ee02d5c95a792d6e5f0824375e786177d851eae7471fc54b3d4240b6f5310a1513afcb055583f0c8a20947f0dc07d91ade7cd4d76e04644c2fae146eaa178b97a66ed7c814e55375458b0c1d12756282f6e507c69afa2d8018a357be38899d75e43507783bad6509be79ab005226e0caef0f991b7b6c83d29222b9bf95f2d408851daa6275e92e6f608e68abad326b175a98a732f0aa69f8816a3e1155d004d2522ab6206bc80a160c3df5630d1a3c32b159e5a81bf560205e62562d7449dccaf4bcd5da77c5c5c04eece68e2a6fe485fca09de43db162d16fb92a510dbba8817d4b7cc05a58e984b2effd27c96aa951a558d47c38584cf979738f148eb67a30e780af474a03544b2bfaff3e5c63a685a5658fb98a994d2cc28fcd77a3938b4e634546dd7eff58512df6d6427f5c19c77e344ecff945930e388f88426bbb1a12ba258f8822682d991595310c3f320f381fe6bd7ee82076c0ca065a3cf3abf62631346f9e6bd1f549e777d1cc13baf32cfe8f98a95e432c7f34ef567ff51a567a8b3f8e5eb6217634afc06ebfb99e5cdc231f02557a9813a2635197c162476ccf358036b97e7d1e6205329d339649370ab0a83bf6fd398cd1deffd929e59ff30f8a09678fcb7a0a8055b6d85c887de88b9db7db9522d8be1ece3ff0bff83f27674ed92ba07407efaa738629e4d65460dad50fa597a1bd5c9b855e56b5bea917e1588872c01d1cb421a9ede554ec962789a80c15e0825057a2beb05325ff0dd5457e0486b7a61412f46f2c1601d5a735c4895fa60b5e43b338a7cf5ee2b53c9feb4e1ecb9c7d33e2f8d90685763a4fe4bf585d0ab9945febe1ff1bf8cf585131106427fcfccbb5e81e114a0d098397851f1e86c3387eb6c9785b2cd1c9a80d5fd8a7afceb1cfd21a2ae68f245d6ef6e8e5d8e366332f66550f877b9f5c7bea80b8bf24e7742b8af3791512245f592de108a62b736fda76bc5cb6f2fca8ebd0c87b0f97e8b4fa7127cfe56d14e679aab5d847e3aa7a76e328523b9b2109f2297701bca9ee37cea927ddd30f637ed94c57c968933e37992aa5314ab2696876d7bf1f85fde45920eae025dda48220259d1df7e17922690923fc7391566c98de00829bf5cb7966775bdb404fed84e658e014b4fae8a9d4240312f353f207650741a0f31468a1840800fa3a405ae5114481edf58b2661bcd2c24912f994c2e1e051fa999f784c0d11718b3dedae0aace67a16048bbcef2163421a5e6999b8e3f9a3e500d756e712bb01e37d50d1253a33bfc93417923063370b1096e20bbe0c274ed7ae3a01f05a7862200e980eead746b7cc36a357d02cfc553c6ad9787b8eac631beff6d4a5f8c51ece2fa756ef7791acde74897dbb6b653c00dffbb8ce71e0f57643e1545dba9b9426233d2c9dd2b9f47be15775fa6c1bdf2e0d53a4ac114d9690cb025c5b007f751ad76236662eb94798e5135c9d36ab2270b672bc54a3c9c5d3c31a438320486527d26e448789be19633d5e2dccfed976f7cade8d82075ad60bd3b9bda4c3f4b23228b54c810abf90f584679628affcb92a9afff4988a10e3d70f55842d191702581327f38dcd4652e0577380e220792bb45cb9f1f618076e48a258095e0a1d5e7c59fb1b94bd8012bafe4675d3c0249de2b49b41631a989645febc5cbc7039a77f488280a155d764aa2813cb7f31914f05d1533af254ed9ee05aaa08e6e667e2fcfc20028a8dde8b4effa9b9bf4f6cc63f4bdb74b8a26346da57528e24aff530cf4c1a7ebf3a0a9d4f51ac6c8a67862144c4d5d8a096972a68881dcd0809ac141217e29ca52f5c449e2e9be2bfc104221a9573a75e0ab5ba3946389e26555288e7dc1e077069cc14ae727bcbfb15e58a4218a2a9faf5bec4f749905d0d2e8512c2aae6ea831d5991a32ba78254236eca1c26377c17c2900526d08b75abb307ff959abdc4ed173a64560cb88ebbdbe17ad21baf595217a1608c32e034f3a0adfdc1d43ee01ea637f6c20c781457d7603d97ba6f58d35b8a449d7cd3e81728695b208622bd44816dbc809801a0b4829b406fb3e0304695b32b08d7ac3506858424c6d8f5d00b700a63e036ff14decc9f2b93b84862fdcb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
