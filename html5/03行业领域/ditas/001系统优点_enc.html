<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"84db453386224a94726a18c928ab6d08bf59e5fba05e420e460b8a73d255a6e1e7e866ba1be6b40874d7def609d6b5283f8e09bbcdbbef6c75fb92ff15b6bd54bb81dc96553f983bda673e663f92cbe221bc9ecae4293618de4d8704bd8d259a0f85f78d6754454fa97ba959b9c9253eecfc30888302978b11d8b1dcc5a29177c205cecb603f848c79c30382c004f40ae74dbfbb1ec4904a472f877199a590dbd61916db2e0c6352aa62240a84cdef1d92fe3c322c10a23dfcab13ee204850c55d7c332259df076b82110641c7bbad99eb87686cb11600ff059d474efa19a33dd541dcde6ccb179fd91b04e11dbf3397c085c65e76e1530a69584b15401a900d216c58f93c3fa66d712b591f524b422351f625d99beba1ac4815c05a773e86424a9754a20bee2b7a58d67efc63aaeeb6125e768f1c2af956f7bfb6224c93980d21aca8efe9aeec0af1148ad1bcc04057192ea696213e1e8964fbc1d6b3aa2a01023f04831195ce0f984199859cb04d0b68212a80a1e1ae8aad62c78ad0eff09afd8dd35a00d2104253a11adc2076a00dc589872d4395520488401c279959f88d871aa4d9cf9f1c81174cfd2524f9ef857a3696c3cb037cb85468c4c12441dc64bfa7ad68c7ce996c7d77d2e7ee45e119794b4f64c79780a6052bd248b8460c63cc43b97a1be045bb227be9bb4ba01af45c0f464e3d34eb4bd790ff6fc8f4c68137391dee037ade685d4047ebf481df74752ecc18f9b5354de45562c82cbbe9cd64ea49eb585c5aab59277845006c5e551aa26f5f2530abb386c695d20b5e3dc76aee55ad01c62081be12336cb96bf6ee375c6cb74653f33e609ef7172137f8fb41610c95108d8bea9bb9ba1667197ba58b71f4211b66997196d89af27e3bbc233b854f60c79ee0b8e0f8eeee75770343f442e7b6955c74fc6e3db63d1b2a5ea176ef7c6109ac0e7378d6dda2b9c7a2db50ab10a629a57aff0e9ce5916aab0d5138cd864f584dd5f81405562f9bae79834ecb8f6744e97afa698a92a4c411e0a8252f8aa0a1a2cc6e66a541ae02f73c98a2568f1ecc627ca9d772f21f8189a9f952264ab5b761889aa44804757a5534ff93e0aadc7b8ca9f9060c30d3d48f6159bb570f5342032dc8ac5d83c88d9bf5d7fd108079e38b7f4f5a53dc0c70ee45138c7852aa872c209e49ec51975326aa103c5ac07291f964fa28e08b1fc030ae646da001b4cd8167827adbf44d466db931845b3464b71fd48a2d019b533fb84bcf334e6388b2143a3af6480ab3d712d4ba444e54585c046e72b0a3f9da412cf68d3bbede753cae547406770d7413cddcbaaaeb804d2a24fd3fe0221691f57b1343d5d5498057e555e9fda0522e88366413c128cf30de6b3bebd36e6d72a4d13f43ae94e5617b04e9ed5e7ea2df200318feb3b2f29e86cedc380447c88ad8d7384847777b76c0c6950514da06d485e0d8633c26a17602055723900539a0fbd1b7d2eb5f16f76142e59661b5be416add1ae7bef0349cfa29be3e34d9fd5ce82bf51de100afa13c706588a3594fde4a6cf95044c169e834088abd6b6d47cee29aee6d639e9b3f5e8ca85fb2a9a07e7d75edacca9560dd8ef5695c8cf32b4189d3a75a12da48e67ccc9e195564ecc73765ceac050bedd3927cc060dfd28a5b7514e6f6f86481381a35be1bdeb10eda0a5f6e8242a9e39b4e0036145f2a26370ec09eb30dcc1170ca3edc30a507fe8e2e0fbc18ecfc3d6c5ef49f06bc28becfdb21d053d4d931bede779a35826fc24db4e3b521c5033ea52b347dddc4a1d2df69b04099ccf0d7657aed075ff8bd5d29bdc83dca5f0e3a0f70523d56ad1b9e64e0281a793f669d8ee5d731be4a8e0b47febff2bcc1767ec8921d50d5e6cf6637af2837767a4cc93630a5800de159ffdb5f7cbbdddeab3f543e2b241684e587dd0545461d37c39c38445c017c298ec045e865213b347655ca2c048b051df6b2729b9468a4ced535530e80195a3e179c229b1a4b94d534d238f0b962998696b7db51eba907857ed1a6a73f79a788edb303fb62b15b1cd16aef8df44c456a97af93db04666634a6a3dfdfcca0c7dde7d2db4cda3352cf6170a129a19b3802c313e026f6930080146534bde64fc1c6252f0e5ceaeedf810baae490a4de4a85e3c0c886eea53658f8afe6685968f922af5ad08eae0fda6fd8ddeda8fda3e94a03591b911aeafa5264f3bace55754dfe6978324acf4d955d0eab19f0b595a91cd5edc1a2d91438e03a39d26949908ff6e71c51f70c4701ebe2d6116870bd9c886a348b14dccc87e35e3e6c0c36542cb2ac071a994a6f20e4e30062844b2c972e09696e120489aa352fbacc6c3506442daf96073b675d4cdbd36d1f413d5e3179a389bb75738cb1b84aaab110adac42afcfd5fd5cbd9f4612700a97b43b6e655473cae3f4724ca9e9df86af47a7f3c381f933490b9c5078c6ee506b11ae7fc860417962cf684d80f64838f76e41eaaa52feab2c18adf24803772272fad227d173561a709de56c090f9470d4b41b8eb90a7753bd57a3482f2b754eb61c788c02be4dbbf2186b56e1286b6683d4fe7f4a0b3c235b7dc4f917353232ea977fb918e0970af04a631cec9986ade8c780a6361da4eecc6cb79bd543c9c2ba4c7af31e7db7f650afbf176592028f7763a0301ee957816a06b5e7df2365ae57b7740ff9e551b7c415e2e0d0393be4fe2e5167dd17282c8b598985d12114aec5f0710f8ceb16418ee27607f4363ede37ab0d473ea12adc43d2ed37c5acd1109a15728f971225820d7d6302773c93674d00701873481a007e72d98b16d58ae62503e1c210de42a3e8071c6ca0765a06d1bc8e57e6f8d3f29aa4ad0ec9948684b9e0d2107333ae2a6ca6f59afb9c50ffd409a87774a48eb47759d418e78641821a9fbc533c51cc9e7c852fe1d05b581719c13039b0e9e9f896c423bb3753b6366bb600939d10f4e49198450f58d739dd98329f11ac78b92bd8c4da54dbd38e955f9d167e2ae22d80d1348d55ab52be772e26c151ef538094e4f96886e14c9d69683a822eb6dcd297a82f619014b2c26195d2cede3db839947827c0ee8f357df00af22ddbdee3f7a45916d57a45141223a7d0ecdbae03a89fa5f03269a69b04e3c358ad7a2beb2e92e133e75dc25438e8f3a61e4f8038ed2e49b9455a4454a571807228a4a993cd958e43b2577dd410e42ed519f4fb417896e349b467a3cdcd2e9e3173167c39a45dd298a87fdb3e54242aaa3d60889091c8932e41026e4609e52ccd6448913bc5d1674039a95cd2e2fe28a2087040975d0df75e6a8e147d93013204bc90192bab1c9583eaeef23fcc5eaaeae507bdd08c1773e53c1e067283605a7d59ba3f9d37901ca7ce611def726771e42cb0e4ee05bf1fa923833a5b6ee5db8576ebddb7a88255a7fab27ba5f81d40cba593eb4474ffb42e216e740d7564a8aee08670ba3a8460b654f687df9fd2fcd1f4f141bdd1eb08b99eb4cd1cfdcf67b7cb4d2edb3a73e7f1349404497b9906c003949410ed39f3544c64c8f51f489e65c928179c838278f5c4203c0f8e5762fa621e75f25aa6b7b21504d21f6e75c832e5a196de1ba9b95550b10561b5cf2ee27dc41607c88303d8d4d87bce589feef3cb98cf2d2e9a2c44fbe39ba81dac049cb5901ff095ae373ed8f7624b899320a87ee9d0f7134e3ec8e461397ad05045d091800aa8f9ea8f390774c3e3d1160292b34888113503cac8ce800c7ba757da6f75e762d7060f3aafbf02075c990f849c90bd28684575a893334b7df3581c07431299ac1da2a8211dfd9fdc6529086e146d43e0494447cb20dd250b4cd5df4a160e6dd4624bff16db37fafb9bdd3216138939ea5c528318b8cb27ecc88956486ad2f89468e9f247e8bb14215b40f08f12b8a7464afc99aeb0381d4e568829fe077dbdc99a7892b1611365f9b506b2c483e0f4ad6392fac0679e24fe448f6a5e6908c544378685d10f2783c9bcec85b353698274176374700a560723d009b1c2aa5afe102593f2baa52dfd84c5ed902200eca2f3884edb1f45d1036974c4820ec3ad8f0031b76ee545c6c5359fc17227e0c34cfff9f62f2336bd8e4dd60c080d9c057c7a092ac0822b1a003870e82640e41525e690f2a1d934ab23c98fe5d37e29daf858f66db73dde3719aad95ac1edc4ccbc6df225b232e5f9c1900dd588a8cc77d63844e578898d34ac3a66315f882748d141dc01ea2da65c98e7c8662e5dffa3e2a5fd587abb5cea51014ea9ca4b63b15add16483ff46189c2f1acc44d37685dc2ab49c110541e10207f12e579d599bbac4e5606459c832e919d3e9c0d71daaf6bc014249c8e8be896c29b8a0cb64157b60e450bef8cc9690843018301df73feccca57f0c70d2c22d8324812e55f0e1761febddea40992813bc7db7d9c02d0081e21e6587f10ccfa8b1f19eee2881cf251206acc60b89f82cdbac6a90cd5f09942c7473c82179be560d49422729cb7249a188f11a95ec2daa9ab45f3f9e06474033be9213d1a4de167f56313d2efb239e04239842eacfb5cbee2c566398b333bed1fcfda542a575064bab6582329655bd49c675716f0e3dfaaef50377e94323a7970b157ce8b51f7173ca31ea7ee1c9db6172ab8e432f86b64790fc2c366ebdaa193cb5a25e96637f219a923d93d54cb30f11dfd6beddb9a2fda3e5921749291f0e38c45bdcceffc213e64d7ef8822cd6ce2a529142b7dffcbe4aed30aa4cb3e434a06fc8c63e3335400bac756c6b54b99ec2adcfa4ea6e323f6188d8cc4e012fa64dba0d79312bc05be0a2c6b3d8c1c081de40ce55c306dfcba18114eda3e1fbdf759f74ab0669695b47b418d51439ab77928ba889e2373ffefe830308864ae864025af11cca14681d08cec991654a82e1b0fc6f36ffe245160d6c1f11830c9e8fc741ae3a0a6f6dcefd7c83635588a10914548bb836e4de45395c26f87048b4028b9074683140eaf0be03fd4b1fdd5e191ef6348365c89cacef5df69b10e46e392ce796a0544e73bde404ad5747f6af610569068c585a98205d6d99f24ce700de6c86b94f68639c670a5029f178eb055b59596372e6853ee91528f064b8ee1624df84c9074b501e0d2d6bf3f3d319634e457cfb2809efb10684213a2a7c0f1792393415b6343bad76050671da55f9dd0c31364c55a928fde7d6832d9c4a5d6acdb855c4292137ca74a5821bcda2088103bf325292856c932718207b770f4c450a82b95f326d29abbe4000059a336b6c41b7c118281e22d469bf98b52955753bd9db16dfd545f069355f18e40a2431c5982e71ba5706960539f4d6722d2eeae58050190493582c23595cdfdf2f5e59abb5f2592d40d10e1e9978a86933641a909774d90f4c3a9ac1f5d866c7eb6be4f51a33c202df80c6d436ab6a3d7508ab9479cd28fe4f384160a4d721c2cc8b67160bc2863c64d40b57996c37355df960911b7446e17fb70c37aeab02864d37e91ddf2db7d99a35733b6126271b1ca07a3ac98ac77ef141de6ada2fb648cf3e8653b001ee25cf935dc52eab056cd2e652e17a968d4ad01dc626f422914d352a30b5a952114abfde040f8d300259b9ab201f88dd3d3ae275c0d1d86ca9c7a4ca918e1ae45dd9abe96888f31d70e8e031fff7eb004c640b2cb8dab489816eb3b1f2dbe00f38e87e52e5caa456d6cf436e75b3fba5415bfd73481e7ca6ad7c0ef4bf35b1df9a9d79829f3d22198977220a0f853d7458f75c4da626d58f45362682299f547bd75a15ae7903b249d9cee6aa3743520519a461e0713ee6a2bbed1ef6728be42c0a655ab6a91ee6ca732d7b4e7e29c7808968c3dee9fcf7393b535f71df84a55f9e5f31494ada3aea7ab7bcf05aab33cd14a9344449fb887b9c57a2e89dba1d6e41a93631d6d2865b30b8d678d354d6a4620638fd22f03a01c092d9a35dea4a54e47fbaeb00b07a780f965d030178e80271b7496d63c247547fa90f199e0c69667b6754aef64e6f0a0ba830c8762830c4a780cc8a45dda919a4ede659a765b17e0839ad898ad098f393ab4c6d733ca03c603005f47ebe2c866e4b918d9feadd09dfc2d11aca452d5b6ebd74009f584f91c7492553a06a08c835e270e3f1b4fdad9a832b325026ba81f4a3cddd7d603a7261f01980877609ebe9ae3226d01181c7144321f35d4ede89d354478636cfa6e3bc599aa707b697b1bc15d2120dcdc93a9c93d46de331345be4a034715276a1a249d8747772ca783721578571852f4579412734b3379b03ba12ec93a9af5d90d78605e3ad114446eaae8d5251f8b8265eb13005c8a68adfbd6dbab063ede6b1e9e42aed9b25f739eafaeefe8e7a9434caf5cce8ca28ecc988609a141386a325af1595dd88b134ee8a447499727550d8bf49878cf9af951caf15205a9eb4f98e3f028be0718c40c5ad88b0b4f780b32ea289e5c03e6b89f244d854e20e3147bb67223999f5993daf053dfa82c63fa88bc48820bebfa4822bd84584f287e1943fda60205f5342f93bb85f34e53fa8887dec40b24cd3645596adbbabe2d486d31f2c4fa3b663288fb5e3b65b47f0185841d6a243dd4ee1dbd0198f645664e668630a7d1fae1f9a3a11bdca0f849c63c441a2f42e551ac2d59ded752d7b56071623d44dabc7bc626a937e38d7245a1d7b73d156c49e4eec18fbaf50aa1711829d867ff9773112e1ca052a474ac9592563ace94a26b4ae5a75d1693c41cb850623517889bfe4e00d79246c2570d8f5ac3dd10c896be3023f3be37bf3f5ff3f61bc28bee11a7954427dd3e484426e61f3e2b38042188e06dc65159a2affdbf6a52a80f07e48401af0bc651f13b6b071630e91dc82fd4e147938270e8f297295dcc556e7359212015b72a22a80fd9a0146dcc5043aa9a7fc5ff78973627d50e741314cfa609465fc4616c137c7e4c06ce5fd30ab822cb847e7b59d1838d5d2e80cedee86e4b3c71bb7b5ce07e8a758263a9b90a05acb5d2f6792d2c8a8cde64d7c8a4391143d51785ef2ff744e0f61be8cc4a7393dd2e316d67d24af1d2687c0ba2ed56c61a8322c4f60a15792edfea44a190bb940b2c901f5ef8c74ceaa0194d91a540d9ccd458598171259beda335127be9d0cc38f159644ae7e0ac78c07ab88bf09e041970d22bec3eee8d7652765ce472b05cafdef54020a1803b6cae095e00ef765dc1ff54b4fb43ab845e7fae778c09e047bade4e0fcecc7e10a67a528c46382459853325e95ba5ba0621d972203fa9aa5b58c2c2da8142c02b5d04622f690ce9ce21a24bb8519b3d77c7448739018fece03900717eb8523f8a613d845501fe4defc4889e5a5ce90bf3e7c41110193d711bba6dc07d3c3c9737a2951178a83b2bbe5100f56ff390a7287f1eb9dfe304274065f1769ba7f7a064af9e4870271343e1c65deea90e9ba0dad40f82a4a18ab79a3aefa6a467ea1563358d794769a83ed18b09660de56aea2c13439d26dea3e8889e1d1698444d360ea26b613f091a21fe1470a061c345daa19b19e8a06d10e588eb05b329385da537af8d8e169a9067ce64b51c9b75059b775cb3382c50d06b372222534698088ef79e5d3a860db60a759a37b005b64560f2d254acd1c2a7b76b9728c5d10d2d552c3acb2988b22a17b576a22a23f60d4dd4ba6f14cd518dcc588e907e079fca1d225e9930360998de3a837c04033ec3d07f8567c43118a6011e76e76cb30c17ec84cd969d49a14215b029dfc3c4a95f63e711566a1e7e59585f8116027736c9c287116b40f48b37710a223a46605baac4236862da75ff186c0de4052d4cbf591ecf33bf626fa2f6241fdc55a2869f1182f4c5179fc2710052e705e06ddc1dba41f222cacb441e8449df1e26fc6958512668e8f6e9afda424f85387cc2b7410198a7a1c322aca52155dfe72eea200acee03145bd0da16da2a9617f51838ffaebfd22de88835e04ce19d74c5b266dabb131496ceebafeba08f0ea2ba81acc287d3a9a558b2cc8c58b78303152abcc46d3202999e251ffdf275451645ca80034992a90558e06e86d0ba07059a35690886ed9f3eabe1142cc0e1f7df1c2703c0a8a89401865bc4c1b549cb96ff5d2226577884f197747a9457b06c333256f651268fdb1ccfe5fd77107db03e3711909642e3a87bb1f0b60eee644118b1a65d76a53129a3d43f715543863550e2ffa6cbc8c019a92f62c6920258f3561f3a2811239b6f91fb1b7859e9814337160a6c7d54fd19734a12bd9e2f6b56bbf12149d3af40c0f79bb690d4c60d74e763d283341e3131598fde521e737837fb84693d49c1e88269f4c42325c6244d2ac516289dd6543db0d0adef4f0c6e2af148a95dfafdaadbd7d50a130bd6241ea6c29dfe3e3fe63e229b9a5bafae34b19429bd6a4f08eb4dab643e01d0f4d9141d9447927e13fec098efc186dfc03383a195cab4563f874c8a58f7c47c7301d59c931bd6bd5f459189e125e0af18bcd1e3bbfe7c62d3ae41faf7068c18ac33f216f4e4243ecc71406c8dc1298bb04b5820175fc2348e147c0dea8925eb20d2d15b3f5041e1cc7023eeb5b0a4d6f7aec6e09b3a30e0d28a9a31f9c3f404138cb7cef2fa1395694f9955591be910cfbaddcbcd3579181c1f9417e4f8c6c39e54cbb1d402141fc1aa0eed689339c9f679cb67b946960ee9cbacf5aa626f6300979ac0f2bf0617abe541fc996784eb7ef9d2c3a8092e55ec983d3d16c691240832e703b5ccd7c51d4367a0da2f72a355103bf82e304d506235e3bb20d6fafd9c70f407f19f0764b4f6473ed132ff7fcf2e4b8fcbd9b3205cc8ad34845556acb3a3d30ec8105d2766ddebf891c95552531717150db827130b581cf70c332923d7a5785ae3c8ad1030783abf657b9f6e4cca9b2e80e89ddf27e25a3919087b43d3aaed58025b2d76e1e8a05e5b80090c4e6754e85004b9a8a0eb555cda9c516f23be34aec47b6edf93800eb3152bb7c971106211e485dfb01c91c55d6fc7c4c74a973007a4d437aa909b06c98eb9987217382023e8e8546bde43dd9fd4e34696ae08bb63b765fb71738a7bbd319bca6b1551b883c3689cee85c352e4be2e47b9d5a6745d6c07807c6d4f6af15d4686691c88ac4db300eb22edb08b4284eba3c1c4f227cf78f2386ce3247965f9809a770d3dffd66a0d42b2cba1cae0df34c38fa8b13b242a1733a05da52b906767d3714667f54ba017cf5f99a923fa971a8bf165b04bee0f99cc888433d99726921b559ec5fcfb9e46335088c344febe325c8e547dfb152531c3919eec723dcf7e7a29c8b6edcc4df70a220bbd82f4f97b7df9a52433f22e971d35cfd5ab3ae638341b3d4ac32b7e86851ccbd933f746e80f6d69ad66023ebbc4c7cfff2ad4c5a08d726c150d1a16d625368e557d1c4bccd5f4b4b3076a1ac3265c214217e4e1d0bc7513cee96a1ed031e6976935fab06bfbcec5022ed346a37e3853cdaef542b6f03c86922c6ced12bb7588178e7a19ce8d837e36c2f6978a1256c08943a2b299699e409787cba2c207444b92d31eb569e3780da36c7fb7f6ee44ac275ee738077973c9043906e7c9f62c38eb3712b7bc8769438329511a3a2ecb990a3c6e56fb47e5dddc23d66d23cfb46734f751a514f819d860260ae420b21beae335cdc58708db43b588a11e6dd216abf5af52546de3c4f15a677278e2b5b38fadb3b60b2771ca9d484ae0419ed70fc0b1fc423669210c0499b15809b98073c7476541cd3bf4f1438d96594123f4e195af69be037402f7e9a57b84786e388e0a591c9c2675c57e68ecae98a8ad8ba297bb39ff12aa5bcea90ac6b8f015941ad9658165ccccbcf04a2c170ba419ef0318bbcf9158dc6b2655c08e49dfef53182c4226e079fe82738a96e5f8d4a80198a8b94d5350d8af388aa35a8a1ca349809e66b60f699796e13f337bc74373c3093de1a3ea069b4386481a2959d3fa12bd2e0b82f9ebf7229739133934c96b3175943bcd38d7430495e0f122a2db2e53597ee27cd6a3970c7dad68d1f6c27c716e4ddaf10b9d8648bb9c6ca78c67cca623549add8956f03b8501925bf5defbd0dce77422c8738a6f9474f54729adfc6763f3c2b69c005327b1260cb8d1d0b56b104b8c06513237dcb9880b21f820a39f83dd7dcdd486763497610f96e26e6f491af0691674cd18f1de013a70380ab7fbe1e0e5fe4a5a423e64bef0ac7265c5de9197413241b3c47705891dea6d1ea1776454335e2ad50fcd9ed4ace9f0ba487f60698d2b6c3d1d933a69176326f026b1e16d57d77fa306046c3aec38c7d61cdf1d404b1cf1c4f78cafca5ec801944459730003e2f9aa49399b3a10bed57c0135066729dd09c41b7fdd58be20ecc922203fc387d84d6a8545d542228404a7aedffb0332a4e4e23f143ba7e4f098fb801d5ad59ea726c4724e0c9faf6e07bd422d12b1a6312f6e100bddaf7d49dca5921434f19ffce06aef68ae87914ac7f95f8b1fbafdb56484fe7cd130295d9844dfe68c9cc4f6eb015e5c6a931b70c8525dfe11334e93c2887f05bbb4e6728458a439ee354a687f717e088c848d7cf8c1cd63458b646af256d916896e6d9307a17846275d5b8483924daa2a4ac53c309e266bc0e157b7458bf91e6ff3a38810d6fd2b0d506d3ba4c552467172cdc2d002a324c5fd8a0c0f8e7b35793d7b3293089015bacb536c956a00098457371dde548b3a0e24ffdbabb137bf579f2a5f23dfd51446c49800300f51a26c5ac79d084b5017ab835ead307cde6153928bc0f71eace2e4a5fff30f58f91c16ff99c697c8433f3fb77be0d5737c1218c2fd2d4f53ac8be51890d4257c2e610321c241150e3a905029712cd08d61815cbb6700eb7e25b76b80f7581652451cc6f1f6e36b1e9563dce782eba22507b282a286b0fa915628cffb8fde8eef1dabebe32732b4e9106297a0b9b9bdc42256f3faf3346e3f701d78fa2b4601ea99ede543ec7caab491f6812492d2a938af7f8ef71c3cfd6b87efcb4c694c41bc041acb7ac8f514435ad6536e5c1aefec7fa98d38fcc2c0b09b188935a5a030deee5ef0039ad088df265e8b8f12b87ac9ef98baf34c9db4c8fc26cea8506d726e4ae4460d3e961c7eb48586cd2592f36bf9ee9b4af9dd897b927f971ced6ce4850894277e26c41bcdda7a7773ced0b8eec99aa6c20ea2092b2afd7b886264a252ec9dc91914482c7736d8ea7f19d266de979175b49986df60336ce134e2e81f82f86af5a5ae4f2b48389fb51436c6dd2935c9c17455db39fe32735a81e278757ac565085896b9a7a89be09331515f3f70f533991e306cac5dafb167e3e63153c6f4b3201d760a12fffacfb0d6dcc86c1c2b9cfffba8287c4ac4cdd813a15b32490cc84307c1144927c73976ea67ae42a128ed627211b92c6749af87afb5fd17f07a4f307720ad8a3037c01dd484e2daa30a9a5ce06fa6449852ac4dc64f24c81a6be7eadca76c93db70c23bb8269997e07e391ca9600c884ddd656e30f1e9238b7d443c4d61538ec00dccf8795022846abc62e95d2a95f86db77ef91c3c490dbad2acf252af328f34c04058938c52d0acc54e5a4a62af5486a8532d5427319e472b2fe3a6a042660840cb70cc9b5e6774ab1965e90642e48bd697fd4554c54179af0ded95755bb5a20b3618e3f3878f18c32e34946f6d8f2d06204d2a9d960349262caa463f9cda1621bc03abe0fb2da64312a09e4f93fbf5d068d13cf9629f8f8fdc5e64ca848ae224a156b8d5db69dc327504450d1fa94000a3654d27e23de9dcd2c5e7811ac39d5ce106d9d1c2e077779879322449b1e67f437c100afd6f550c4d30611163ff6fc1b00c8ccbda131c088c176adadd2358778efd3b8a6750daf72963760f8131b1e8ba6e484f5b598beafd352f8770c179072af673aa01da80ebbcb843546099647a6a30f27dd18c24d4da305bff9e7995e632677bd93028182b3147f80b26a4a69e1fa96081dc79947998bc6b1d64dd1cd81d107e57f5d01bd195ac01fcbc63e5fe30baada48495628397043f46d32d283a276e3346371c7d55947a6aa8ac35a11a1fa8fb2b5a7b7cc13f0458612ff4e818c25f31803a7281eb3757eb393af72d2aaabe0d2ce093f550c73c2c9ec8a137791cb560c726dd533385d8c881e7d1f68667641a8013d9b23a396bf92562ee3b6f6ca2cf0edb781400177949c750006732e54649808d253bd2f08b556a932aac938b79a365399093d444c20da923805de5a2c0ff7bec1b21437a0ace38ce8898420b04614eba03c12d5d9129255ced8827b86104c552633993ed6333d931f892e03ef5515f038877ad774933baf5d75ccacd7f8f2f78cad0d6adf9727995bace916d250fe764e760a8c1a12e77c2aa20947522043a76a876a2b142c5296e604405f6ce3e0ed4bf8fb437d6aaa3631e7d4c1c779c68866a609cbb949763b57100fd4323ce20043775c1457d168b5b77960e883b3a3b4c2dd66c2c0bfa4dbc841b4f9d749937e6567ab01cfc2d897aab1e1e77bf26426b3f8962d4e680a733335a5a21c22e2aacbaf083db26496558ba224efa721c39d459799a15ade520ad462dfa4dda6895a18b9bbf11748c0996acb607e1b523c6c52b0b7dfa8d69313ee6a555be7a4689ec28bcae2e4899892b691475f53ff20dbf1d85334d82b8c4d733bc05bc331ccd3a65affbc5902834d1de416ce63b4853ef86b023b1c770e886f61e1c497688f2180d9c27920827d62bb745d02457f9615ea0b1e071d68edc30e2e6dd040311437fbe9edf5d1b8ac41764555372e1a02a7d0e99cf2029a98020590c887fb4bdcdec86fa939076dd44c4720531efbe584bb746894290b56974312a0a56d1e8ae7b74d496e42bdbe11ab9db41f107ae2bd426b8abbfba7e27319857de29cf988899b5f8fab1f6fd56972e463f6418e00de31667cd39d4b047d7f48e3add92b9f3bc0e5e40da25c9f1bc33fd7ef3e1e285ff935f35865512785a64a1c025b9836f406fa01ba7b7922502a8bb4161f75fb1e9024bb8c8a5a1382237298fd03f4da9d47df72263d77cf8ebf668e42267075d0b139badabe33519aad9783cb2746490ed8b7d3facb5a430dcd6cca18dae993dd79956c9d1452edb31f13e96664aa97595d076c6facf6adb5cb8edd603e251f86b2c6059f6ab1e86f2d570db9f42ddd006f3d4f10910fbc0141cbebf70bdf0a9765a7b2d23538631b4eba29d5933343133b46fddcb5985542a02596321754739cde7c056525131cf06ec1a0ff8abc10f6566c0c54b6e6557a39eb7e90c1db98c39a84caafc4d06ebbb926fed74d9601ba72c0ee74b9eb662ede870d479f4dd83a2729163f063542e0f2f8d932bc8063bc74bffb9fb8c39ff8ca3791fe2d3c067c24ba3350e7df30631fe51d2090b119875363afc7010aa16068fe2071759b066341013d72f9452dd95491ce348535f219ee48f785ed342497e360d9adaec3b6e892503ab99c5eca27e962e0833b66dd6fb2783af7db0946586b8c3566801376daf305f7634f8a8ebd2137064e238bb38520f0a4aaa0f32176fe553dcfd0674ad37bcf77c00b3822a0befd19dbe99316d2c6e510de4fb1292cd6ccb973a0f7f5214d9acc11e75a13ae0d2aa777d0e774bd2c8d3efec071ca51c343bd75a1da23f5f6912e856f9e21c0b71410512c4f06ac7a8c4725d4bb83fd918f5324707d89f152a9476ce36f71923fcd0c348aaa0c826efcdd7040f6708ef9d01b19f543f7bd576529850a2fbfa6ef2812ec975db1efdfe0883052f7d1db9d48daa3aa4ae2a2e99e1e7a5e43a35fa1581faa79b2de4b211f2926f4cd6062bb5f98adfa20871845714fbe33c971af4f66d15eb30e5bfab48aebd9e7ef1f55ccd259b7597c66fae6e393d3453e556ec520a9aba2c4fe3940","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
