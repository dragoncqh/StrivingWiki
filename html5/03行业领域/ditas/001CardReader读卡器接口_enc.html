<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a495d3a1270cb768c1929e185e701b77a976809956c410fb30ee773606299daa796ddf2179d8be9a7830afa7596fa365ce13b36efee18a682b245d7b0fbee9218d6677299d15197bae0163b6663aa83d5212f9c91bb6dea1cd2e071f0f3a99034354f2ab1b6dab8bde90583dcead6cd937fe36e56136c8dacb08e3fba9342a1f4012864abda070e65351475a5c78daae0a562358e41e4ee2b879dace8604879ec13d2f60506f7c434c45ab4515035150760eeceb3d3ab00798b72669b4aa8e1de2596369d09db3b4a1a1b8d48b9678b57705ec88b0e1c1a709e1f75b4b27e277ee041254cde4256547aa20f56a7ba6ffb4e94fb6dad0a81253d359930dadbd1e7ccabe665bf993aa74d7ac4f05b48c044bd6d40421fa8de531f24468633c890a7d7160dcd73dd381a798e7166096cd015caa6fc7e94ce5fef267af5d1c8fa6b6c24c8b331aabedf8ac6560e8e1e88054512a92d5908f164ca8b6928523c31379550ccd65d54d0469de3f4ec515a4967d7def613f3c7da0afdef03bd6feed3322a5b3483cefef2ec539e59532b18fead08260bc79df4ad37ea83653c6fa155906a7397b1c7e64e6cbf1963a102368b95ee78ee360767f0c965f70af2ffc909f7c083c07a2c42f87fdfc0896a8e941ec0befed13c70f8627eca60265f65b9bf7d437411a6a5437554591d60877d07a7135f4031874820b19a5aef2b06a73371eee50f18cd002506b40c3cabde8cda867c0ff89c78348f36363631ab2e563a273e862495f1faed71af705507687da8f1a9aaebf503bcb31e8830a0e6b588b20d68bb45a963aa0cb7d485987bd4de71e7ba6d531bcb728481b8c6901b6153450df55d0acfc9be9bf08bbf84e3e4a9f2282dfcd142525c175b6511d7e1ae98fd959f7b4fba6f678e504e82347d4db019dd46723b51d86c4eae899438ec795f1311c2c2b42a8e4ebdb2c6314244367c0ef581f8582508cb8b4665cc6e7a97a09e6884700c1d7ca8bd4fdede635b4f44d3d6adc7a24310472d167244aea95e61e317a335e81f1b633d4dfd6791feb9cc01a23a01cd47a18d9ede78863df2fec51dd22d5f036e795a46729591dfda38df31285e05badcc2f227d943f1154c7bb810707a0cffef00340ba4cc58ee8deb528ea93fe453a6bd8fbd0ca724b9b1bdd0c2ac98c5316b66f5d22b3dcc01370795baf6dc6faa781ab5bba572f9ae784d833c8752e98f0bd504cc96736b857b3c04d5f8a5f602a807970a660f4b8110a97dc14477a520b9ac5e952382523481ecb5805fa46399ca36da5cf412b2ea1255f50ad920b4b97ec1f459f04d095cbfc52ef7a146737f550a2247a31f5e3f6adb91a089411435c70ae3d86ff2ce236f721aee9ce408d4465f8cc2b0b2a1728d24240f4fd955e873f21c020b98dd2119123704a31bbdd52ca4c4ddb9a5910d70907c79a573f7c70164a49c92a5447d765df6e002e5d602465034367b4855a7dd639aa241cd4ac3de1135821bf4badfbc2977c5a4f9a60abbe03c798c433459aa733bcd6e4cebf0b7471a0d1e0f44376c78785cf34ebea0bed483d736d4193e09ea4783a996471d0103c920db5c708ac077cb92ce9e25c3302c5b04b35a247a3c40ffd14c68c83f44bb33bf7c483cb76c788fa7f6583e6013722fa6274775381e9c9518144ce7c5b8e87c67e8fb7994ca1e2b0af5dd62fcf8c6017c3452f77f0202fcf3173c86f2ebc24d0233b4c5294698cd9dbd942f1a00a879a745b60bbe081149d86298014d459c8302d1b895d802239c851457a10c23c2a029c633b8083c3f5df3e43dde73da3f966f2faff1fc3735f259c432956a7fb4ac81d95ac065bdf744caa71fd4b35c543c2ec913a0b7e341b6662cc22c9b62ab6726aa3a0c1bc97fef778942393fb9435598583b5abf0fd1a363f14376bc587690bbeb4e1e4d839a2bbfbd6b6045883ee918c8f74b08ceae886e0d4356f9df1629ae9839d8943f4a901231ea4929b78b386539edf694b97f5d194369dfb236d140c091b3d1470e702c459afaf80993b4674304fb8dbd6a126825988e8694a51770ecf964ab99e5a949d0098423155d1e1ff77098839fccdfafd46757e9a0cafa8521c89909f43052a29c81eb64be9796abdaae1eccb24aba2e113b7341de85e3aa59f77994069368026e441d0070aa8ace32877eb94858f47147e9b39d6cb87af7c39ee8156fb2ef587dca8afb7c9eb3dec3d274ef0d3ddaea959a9f1961946744d4f3e60c0a5422d453df602c850f84747c83f1739c20dbb56527a19c27d6aab0ae38fac900ed260626f2d488648a0dc0523b56bced29dc29d218a07bb3065429cbe180ddb4b300eb61aebf5b9129bb81deff6a902885b724858e42bd073ef9d254f83354b4e42b2c293e5bf6da1e2d302727fec8aba24c8028fb4bbed087e89741d6aef4ef6d0a1b6db87ee224c02bbe1c13168b9cc5a5009b2bb5c816dcea01ab7f6d4c55d32d4b85366441b365438d910e5ca985567e7b55b16f533ea65ee9cc8231a386c9d2b5a956f62ec9436551531c7aa3157e31fe7303f499e085b60845dd51f9eb3e1a93f3c383a6c0d6fcd05dd7e512798a60c72f50cd10057f1f90196d2b46b20bb2193c763a910ce4ab97d911382e8a2e75981631d26483667c3e4794dbd51a31a95f5a63a6af2f7b5077373ed2aa29975a78faf58715e978d4c49f13c3f4d72cd98b4ef42951a20ba7306997d93b1012c49e9c44164a7d042a31d5282430e3681aa8445800b0f31b023014282d2a5510eb39f560a9f6b026ae617fe8e1f0f930eb9209604fe822a970d5c78a5b3825a5c504a8c13bfcaa963267d88225dc157b046459ed3b51e894ef183fc73b2b7d2c1ee17603761f985e9f7fe8b785c8223084e25760f0b68bde5c3d51a9d4de4796360e5acad81746fb3c510ff6cf3de1e741b76e5d570de87652edc85ed8fd03d5ad5e33e55da17d386d0801fe2d12ee5d0808b72d08f436265cfb6e4ffb6eeee46207072f2efea835a37c1c7874df5646c5c5c33e344d55c8ea12c31d65b9cd01d16c889d43083b69bd221a1e5e5a329ebfc08e503bad9c3720bc81eb598d7d4cfc9f31756b84eda366996fd9dc5a64e2075bcc7892f82e2fb3350a5d1ffa8a14d136f1c22aa2e677420d06c0e2fec662a058861a3c0171cfe7ab68400045c4082707769bc058768f600a7c8f33abdcac01f5d7008f077320b10b9eb0a490b504a2f970026b25884a6cee5722d1742a626065d11dcc71cc08eb8d66f795e2823f285a576d864b32b5467fc0115dfaa522fb69b378185d6f81cd9d872d5626fa618d3466532b9a1e439f3709edd1eb88e289ac749ddcd29243a37a01f1ab1083a4722ec8473b1fa83e8a2656b3306bf71d1f60a31b1ee02f06b4f67926e87b76267e46c767fabd0df1b527cb821d4dd8140de43dc1a204b32982275c2feecc75405f929f1955654162224624f98fe3dd3f4dca04cc32f1c7b59c09e04563f755bfacf80f7e3e61f3f3586f1ffc56f63238cfdc44412e6239f527a654957d421886f12f83f370906f02cbcc0d82217eee7f95e189daf6953250f50a69a065a9119ec8255082a95d150d0af704cd533937de2eebea6c40606a5efc7ed4601d36fd8dfd2b5caf7f69be3ec6b69323e0b56b0fd83cca9255807d354996d92858a679c909eba040e1df00c916bd795a3f3357276d0a48e2b62fbab5d3759e1ecab3f137fe6f5570d6497ddf82818215564ba873e43f65c473b7c4087d0a60781604823175ca9b9c7a5b7a26568c45b2c1150262b438e644607fad44a206a22dd340d8ef873027731aecfad72f57302966e4bc743dd3d543dd4d235b1bf5329f8025a708f0aaa3382090354531469528f1160996be5b869f5bcf722ef4968193cb0437eea5e57271dd51d3bba85d19cf017e922bdc6b13cf3138b377ca881b375ce0e9c338a00aa3cba9a41e3fa0007313fbf1ad8c8e8b905a662051a8b6de6a987e72313a37bc7ac4876a135bb0195dd0e4bb96a411b8b8acff657c4bd6ff4ac11314a3fb9b980063e78f1ed51af0b6c50b40a5e6556c8731231f1b7566d6bd402b590c5375328cf958c5d0fba0b11cc43498f6d002f1a7366f0a5376ecbee8f979b3444a0935cdcfbaa0aecee13fa2fbcc8f89a7c8894daae8ced373fd1c0af1eb2592bad8aea4f0b77022ea00f3f388039f73db721ea7e72e908a557c6506fef3760289863cabdcacb998d2fbdefb53220fde452da17e408d2156df81c40b294fa26a8b1af7a9fe11806dd07a0bf3c3e7a9eb23f11a3928711c703fd7dd5d4f9c318b868356dfe80488086fe9727ec00cff6f8314a79f4703aa830f88cae7b38c58f0ec98c69a01d5c78c7664ef1e32306e153bec34600341df43b869f7eff973e349c6dd0107d76e2bfa2531ebcfcb8badc89cc5f4cae4308b339bda60a5a71250b5c0861dee5550b5493bc8ed23dfd84db01c907dfdff54b2662be33ab10dc3d0224b3ae937f7a49449f96b7bdaad078228fe0aacc209695aaf6f7a2ee47cab5f2a021cfecf0f94cdf42517397a209ca3fd1dd1d08097f06951472db7043578efc20ee7d018b2c57391687befac24d8b79015da844d6a454eb4367b701158f0ecbce36144d56e536306120d281211e581ccd79ed1279b27f89504a451094d060ed93042f8f8c3a76208dc0b6096e62a99889c50aa4185a048550668b985988bc0d37d0a66ab94299df1c2cbc9ec9fe5a1402bf0cc9e67cd59037d7a3951b9d024cd2c94fc4209b61d047ab61f5a9ec3199c65f53fed13066d2fa887c711e0e7dcdad7f1ef94d3e02447d62bae214c1f703f8845622f4395f37468e37b30ab53e588cfe2ca29ba91f33851cc85f45eb024ba2000445af15426f52208ac16be78b7422725a6dc8ca161f82e445c50880621e70184342d55b2f579b675cb494323e7faf892c48638f6b6bdf92c81b8ccf46064709e0cc5eec87ea71e5a8456110293ec73e5d3acbde62f75c9eca80685c48bda31fa2bb3d27f5563f45774a8b4617dfcbf6ed0bd401875ca40cf9a89ff1feb01bcb0754ee885d885cc83d223878d89d8f97d0547d839108a7d6c9f653ed647b58a27c85d6eedb696b4639d8b51ef696b7046397efae3e6cb4f0cab9a0a174cd0e1130cdb366ca4107bb0a82fa6c77e00b3c7981989777753c46feae7aaf95415a3ac702bf1c729d08a2f4865e9ea84994d1ef7f490242455b22b579211559294c6204d7edd06ffc47a411ae37e6675a28f825112a06cb018c463edbc213a6042474e6692b0cc3db38514550b12ae11031c7dd5fc5fe9cea532f9c364b7fbc5916962c06ef83353b59611ae178781607698c06930b3e401decfafb71bc32c4f42fc465a3ea7a2a305c9078fda7aa44905a2e0c90d436a92583841873b8ce219e62cc3bb53150d827a1d80e66c1611e374dcf75d143a5b3a57f3ec76b7d2c6937781fd16dce62904d6990093463a0f17fb0ae131b69b416aea38398b4407bc714be9362927bd82f82799aeb1858aaf55e44f4f4e6ea651983ed0288963e3477202390bddca9008c8fc343f63c198613661a0522e32be6452205dbe78cdbf979afb172615edcab47fdb0846761c0ba9fdec78a6c7a79df3c9198a991c55985c05fbfd21fc84c561a497103d6cff8d46b74d14bb4aa81b770c5786e73ede0b06ffb30cf0c2267dec22f1aaee924d33fd40ddcd9528a60421b0ba9f8dbf72f3fe7e35f9c862ac58a5074ca365553c5e4e3ac57e7a53a1065d27fa21bb8301f2811e2b36bbde2ad79cc56cad6f2b98b8a31e2ff94067896bec08a13dc001af79960fc822a82dedd4955e667218d35f549dc61f294ad056a9847e30691bd2cbd66d2dc67880ce353232dc00ccafbb283da372bf8d4eb7ad5b275b7221975990f75b8e6e4a2babef64efc6a533252078216592d7d95b0af19fea376fa3a8fefded285984ce9734f04dc6faf1d135083ab573844e6e9b7af6c1dbeb70dcdce92e04a65cce2d7a6b13658965769442aa100aff88361f5e97a5725d555263acea4e0618750fe67f159cf7bc0a64a983cab748b9169969b5cf69b265cae43cd4c903eaa4d94fda4ae6b4b44227763c35de5240e21fe1c85cae7051a610ba100cabe1f3e571ee1152368918eaba59bd6a10468eb2015ed3bb7dd49c0bd0d98a3e846a776447dc99892f88f7d7020b2c3c53fa44baf0fdf4704e354bb5226c5a529bf1155d14075db167a9ca1e5cfd5fb486ef34be34556e876dbe50139ad4ee95e1d239a65ec49f86f5ce8e9c72cb13dbf860fd8edb8dfbf881b819b4cc2287a4506f38f81c684582ec8f0b05164ce71b454d99c0ad1e4be7f052c5b033a07eda2b93b06f5f21ebb1f0046f66abad0e0e72c3c4f0a9aa5514e336b997fb4913a2b88dbe021bec88e4475255ef2f97182135ecd81450385e9c4a1927ced8a2d4c85c5cf922b3a0bacd54b2d678b12a3f76c2af80db73d495a8f103f78d8de24d788cd5a47bd645c8bf4cd0351be9fa7a48616056916b9910349ecda8a4ae175cbdba0a3b6b4d118e3d1012e12ad8c220fd97d79ba9c5fe5d4e438ec6dff44a6a03b08b957ea393ab54cf7fa6fe6b3224b172a635638e212f3f42bd259a4b4cf5da9fe6415f803a3626de742b749702c2c3e7e01a20800c55759c0f996dffcc963166f1295edae46519d6e6db4ad2364e65e98f64d37ba3eb8b6989150e360faea7fd2c17a5f0ca4baa3a9aa9500fc1fd84b2fd259790daa44b2a300b5d29ef5eb355d1b4792bdb7e78eb4cadf5932c3abb24693f38ec35601f828e0cd49d991ceb3a70f066c4a49acd55bf751eea8e9013eafe1c13b2a62151826cc6badef44a445f82e69931560a02e23e500fe08dba8f3e4173c5e9292f876f2851da9576e1469bfad7004dabc48933cc754742f7c36fa42cad764a3b9bcf71db1f84ea94b085671f488aa0b6a95f4871a2a6eedd646851d81cf9d2daa174caa2fa42dacec6d2df184967cd9cedd7844316cd8224e65b822a530bf2969de87edf16d03118d7b2c2c2c8f6d0761c8bb39d2ee692c9759a4024cb93116fb136c871c0054e9ee3e0b4bc0c1a2ad651c0c683790749ba570aa3d5f494546aa3d4887c6b8fe87abf263579b4abb03affeb0d9b6bbabfa55fd5628aa935b002bf4546330254f0782327f29220f64dc95dd10d1ce12ed02fb29313504e6607ce73fdc46b65c24ca2ec5e224b96cc6f28285c7063654864b7d35d76ab10c7e1da6b9cf16aac5c7b55d3e124ff8b52c44a1dce47a959bd93b4d7455f88e84cb420cf421cf765cec78dfc5c14a25e2e26ebe53171045fd0158349f7bb87531f66c1a8266214037dff69f730e15489b89e8dd7fd22a61fafece4a30fe55661c560794ad8805f0b9652339a0f6783cad327e02abfa05f88f8fda5e12a2d1404c2119d4aaee84acd68b9406ab2daff4eceb6928815902b5fc1df2fa5568cf7c311842cacd02e071bdcc51b34327899fa4ed29bbfc9347dc45e99365ac7d8024b3df8d045d58dd0c4fcf0a03fe77748229ecc3b1de4b661b5410fc77dab26d0ca8ed5ba440764ddfa0ee2e7021ac5fbcf7b374f9234f73a3581cdd3e4a4bd77284c9d795acc813a010b011814f31f700910050964c3420bc8ef6922338d615fc5d177353d649353dc235b1721fe29631a29391505c1ae6f0df3afab007eb116b801b03e636817ed251d9caeb0a1799839131821ba36a77f6d9a1e9e80b47ac165cdd08bf899392f6ef09a38a85bdc278cba333e0cb2d571c21480c369b5b4962241d7d8befca9d966ef669f89afad668e4359e5a9077db0ede4e13da98504a81a122effe5abfc7fd8e658b3b98eb0ce8b2e2381f8d08be726e412946d633d577c3996a9e31587203c8a70d2c49adbf74b1f775d80a298c1fa3e2b8f11524b292346bc45c67960fa9d12312774351cc8cf42960cd5d13a7b1d38261ff12b320b69bf049d99a5ff81418f185be16630d4140a821aa9f700358cf9a03236d6495052e52524d1ec2c1ea574dee197594b2ec144f2b6a97768de6ceaaf14d2e23cf1e6c9fb2dfa7f232959f5abe3baf8eb2216f30dfa178d53936e8c08a946f0c8131b8fa808e3be57797497363be64007cd6aa8f638e4cee8f09465be16265c89b0a1b00f123c3a9d7faf6f9670f225fb543b28c373788b8a8252e0b08d45d785565ed2adf618131b0a15f7b8a52f38b97e61cdedb812004f20f274bb8a023dc9ce96f1701daa7b1a56b43260bc6d624627c541e64ea8720412c09cc226cbfd23d4c37f30b3f7bc551226406a4c86660e4d2abaf486ab190f570f2ef29fb42d34fb4aabe22fa14060652134f0f7155e14c5af4dabcea57c4f06cf625432039410e7f3ab3d16f9e7b94040cddc44d1dfe4b684cba64f350b51e92272b46bed5a089b406ee94ab83cefd61e4c97afacc64b60936b6f6f17d56cf855b7b73b95c79a0efa0d118a02d651094a8afc781557130673cb3cce9fc4310f02f5d97327cbb7772709db0eb1da381ece6f2b109966a14b6a1dc528a5116470fed604a06aae5a6c40ec732aedba50a18aba9ac6e71866ca7012a958c5317b429b602fc23abc3eeb805177178140444f25bc9cb0f8a282e95e092cb98a674956b076088306e3d7d7ad5e09c2301521f21451404828d142deb198f5f5f6800e23058963cf0431636f08eab553029f52291210a55fdd666d9f57378f08ec486d38ababec5d07e797e8faa7bc6b2e191147076a6b33681807b598673168836f5d631790de2f996c667de9917fc995c4e0db2098c79870c0eb6e49602e7c6559be1fd364b47f0150e820172d4aec36de19c4b6896930a972f4ef4778a079fbd3166bea60e30c7230ea46be07aa2b307da1e1c661c9e58d7449a9a05ad04e9d5f29df614ae66faa8c515b93b90550388b83dad370a17568edfd7ad07c2ac848041eb6207d7b2793017f01c974515bbe876cc8bf5ddfc273d7db443940cf20750e1f3aeb4ccf784a94c00e2ea9704e7aa2ee5c79aa2a56655e2a51ce06a96f0d46e1558140aad594e6b9590e27817f238965bf8b777498907bdfbefb139efb1915dca06eaaf836fba36c47978a95b482491fdf911b5ef9f119e871063f156d1c6f45b1096d00d53d42e73d86e2875e188648a13d3f638b83a9bdbe555c64839f77522912058094e371d697c05356b0b02093916b03e21bddf5c27d54844cf80cfaa125e92d99eb4a66759098e73c320e8745520488ce385390449aca84035f7ceabe7939b75b1d2f9d851042fb0539c4aee02ef746ff017871ae3ca32a04d35fbf74c539fd1636fd9deba91e5367f9e140d1b83371472b7718825d3a37864c9e60b737d498942aac143de564d0322a0470cccce13beb85f8553ce676ef36850f9a9e3e94042cab5dfd8c475a740c7cab962474ca1ad3c06e043d360a387e2047f8d1da88711226dba34554699cebe4a1ae6b21a7ed6532e42bd5901176df5a41c2fa5989516d63bc9b96d5c22fba6664c658ab032c4fd6b453740fb9b391de99ff754fd582a422765a762d218ed6c18d56a1b5a4df979d8d9970d57c7d657f4a71b13751b38e76ee0f3dc3877a50389e54de66f01af5bd5eb802589c6fb0cc33a2ed1806144258594fef5c97890c4da9065b90990af286deb32c3d8e292a9c378d38c84c5e163b65fbfc49c3b53a03e35ab869adf190d7c3fbd73183bc3fd842f27390b6201cae23358a17dcf72e46d17cdc2b5aa9bd0ae298d59fb1e9d21904a979a8de58509990ed1a5f1cdd3a0c3af2de8ddbaf2518bb07f0cd7c1de5b04f71dec9ed6d67493ab5204a53a69eb859121094f517855e3e1ff209fcefba765657aa995f7ff5c0b783f83ace6d6d4ffccc9b5a277b90dc189a04754d8e57c93aaf5aea1c8112ad464d4ff32b7cbba23d9e06b6ed58de1b4bee44c05dd1fbec81f54e8d2c1b4f2bd454670e2c49061e3209c56c915b5271decdb125d5b1dc4c98d0240fb7f8cdd2755238571a80af92a24a478596aa03eb6d8b32f9258008310e1bb6702e6838f263e0aea9440e237da10729a7889bb89992c3cee1425a2ce10a69bdc5b9adc49af16c240af7b114931c591ad17c027597cb695b924b292d707db28b07113c3dbdd42475153c34b81624081489519b1c541e21f24f07f5bc083209bdba975fb0c292501a6f0aaf2edb52429c2422613b828eb54a961f6c6841109b3207a7a7202fabb235367f14dff0e7af548dc7492c70879109d3ae49741f016fb9e4ae106b17542f5e63e6418e1d4fa999c8202fab5dd5d068153975dd60ab84025d4c17ca51c6b71c5063567b6bc75265c5eb5c9833f82c2aebc992a508356fe40fc758ce9dcf62210e81297180823a75134dd72da2daa7c1198c19fd09ac81ee7a7e83fdc3c63f757794d584c0c0ae854f37102fd041eb79ffbbc8a312cadf98feac337fd5c1907303776cae4d1f747a4a5b5d046180ec69c76bb1691e2dd206c5d65ad2c8323600e3c58b8623491f0f3aff3f1f1af5f93593a90ae4b869f7014942f1679ac3466ba0eb6bf1d76c816ef526fbb2479fca8b9de0809207049a238f25e99d6c400d0ac3ca43d9ee5f9d3ad2051b5a43b1f35bd73a2ed6b382cc99bc085d682cafa0155ba985142ab203e1fe5002173fcb9b861794036c3b48aaf87adc953f3c498f35a7b607aefeba62947e0b9990c3744ba5c1e18b2f2a6985a74b9845ba17c624b5573f469a04996dd9b387cff4fd3fed4ee760d6338be6d29781504fe7ba865e2c4c706c8d03a6c3c864c1a04203c62126a532fa4ed324cfeb28bfab9996640fbec35b0d91a160b43c23880f6dbee7f8564d823fc287dd6e9c17f19d3deb85b35056bcce430700b7dd8f26ba17d37c2a5eb9f3b261ee1cf6ebb04d7ff7f27a0478f5e7fbd9990446fd12d1d12340e1905e8996a2fe1635153c325049ca1ecdf59a4d92cc06a2cd6e0a3ff1a3eb1b995f06a851a84747a393ed0cb23747f925bc2e11b30183a39a6ec428d4d6e0b89e79e80f6e8d95dd839742db47b28d0da8d17cd85e68c6e25fb8b03fdc7167bd8dba40a56a961ef524d6de8d6cfa87ea9425c4318574b3bb552daa85cafc8af50a67e3c1816b29e7b270e17b767d28c535c59357c54c77934d1f5d6d2e4aef6d9867af5c07a82a6d86d4bc46747e4ac22d11faa996fa418992db84557be2244f13cc8b0cfb4753f9d025f406e106ca470fbdcb38fea320d1e82482ccf074ea703f586825b3fd1bd48924d0289d1fb96a30b43d9634a56171c4583012200d9cb7029494a7234ab9f8034fe003353fa9a6d9b5305e02e361bf5baab41e274e337ebb2162adec94667b0cf95e23cd5e53cd83b58fa7621229acbbe2cd65378cac60b22a1f99e4dd5745a362268c7fd0cc7110c50be43b0cd5c4952e9f5e95546354bd88d01b115c3196499cd7f88c263383ff369dfc5f84b2d2684b7fbb07cd5b4dff5e8861777ac039e79da7247744acd12a5b9561c5bd8b63af70a132532e830baa6eaa572016f844a1ecd40d0ad201e30e2fb02517bd8361dc2b8cd676119f2f13910a9d66311952f3c66538dba530c89d199c3373c9a0b3847bb8fbe9243f2f08f8783dd77afc853117c63c79b4a0d4afcf2bfd01f7b2f9ef5fb367a441fad3d87e3d81b0f1c20180f694c67959937cd6acd5a52710fe269b71db2cec6b544d5651237b650ce897c984e6fce022d980e6c66f093aea3207b822a463fa26da8162d5932ad64c67009c23378610e813b3d725baf1e1bfd1ad93e111679672da76af3189f55c6d80901465ae4028ffa16b423b94d2ec7ef624423a0200bdaefa22670db0276a660b5ff1eaebf9d1630c5709ec0d38581532777b95b8aa017aafd7a3c73ffabd7e230b116b339637801fb19162e7b0181274d894a1fa0551d3f9ce094436d42a45d08e0e95f13112fb8bc9004652d5fab15c417351d1d90737d494942ae490347a3f3b1ff9f79b361961e7c486446614a5af733278f47a6774dce0215e731322e2e91d41f2c3e7fd5e59d5957e688799582bd21e8031ce65c5556159f51c5a058ee742f455289bfd08662125197d6c7c215a48487294c30d37fbb2eac81848dc4ef54d63bced97250997e6c1105eaf0d02f698f36a1cf9de177c828f7f09c1629fff36e8971d054999a223a9ebc1c796b0e4c8d8fd03f4538728bf73292d9b9b0e0b342b764137d839b8a85e4cc6efbb6ce4608e1a87fa693f782bac999623ce81b095e542833752e2bb7f1ff8713cd1ebb5a946c1b2673c0a969829c0ce3a1550c9e1bed2129bb52b418045eb787ba3468259af175134011c11c3ec3fe5e8cc2e8a92a9ba3c4e24ca67aaaff357b4827e98cc79c3bc85af00c400bfce7e6a40674bcd5e15e8c4d91cb575a583b929cd083e128267e132b6e18dbc363091e4b9f823e6186a6a533473858cbc71a5a7c2c3f9ba9581bead23a92c72af11701e69faa2a6df2a477a78027c098e3dc04fd5703a70f56f9715a2f1144a42c4c968ae164f8155011238f1aff0e2b296ca22171fc6289ab7e0db4836bf58ec24d9a1dc2ef0cb1edc2ebc114cc7a025fe171f1f5a74edf8d50b4a8ffc6635f4e32448b70e769f7fd241f143dc3b2948c119a6ce4467e78d59ae58050e00e5db0fcd0927e6ddc1cb0556ebd0a48289d4e94023241472174bf4e2bc312389441543483d05cfcca2a99c5bfb24c5d2e4e7f491d4c70a3b8112fc5cf6105f64027a669d9628cb78f6eb640ebdf82144be2de04e8ef0c8f2099adc092099bc6e198228b21baf4a82a0345565b482451a04e7955fe8306d4cb028a913e3347822b929fb618dd1b1785b5d4553de3f3c1736a3d2b21c825f99a6fd09f5d5e92c0693dd448321da153a2dbbfd8ced1fdf7f39e71bcd040aa6149c5aa76b13368b89fd5c5057cd7bc373b77691f8cb5081b0f576ee63d0df28531f5fdf359aaab2831c00362b41af4878ccbecdef31a53d13288bb523152337f78ae3ebdeda4b48c58d4b97a1dfacc4295e70a78afb9bc3808c4e08ef9dd78ccc846f60378b1ef4ba047119f337716510d6c3252c724291bab7b6b04b9d2dc8b69c85945e4d8f877e29009d65c22896d72744da01e6bc13f03777b0ffeac77bce133a013ca367b7124265f5a9b36aa2f20382ee07369e048724d1ff5b5c55bb3f33e4b59a8ea403aa36e039f2530fb2b536ae74dab726dc127fb7bd3bd329564141a5738be5d59ef218ca85b938e49a12faad51036db3ccfaa399bbbb258f3961fd715440d04bbbf92d07677150d02105b11501cb6acf3f4a9c28113b38d522fc7f57df20f3e0456f5eb395937ef7bda5fd09f995dadbd587c7ed164e59333deab6a4792f25253c0c7b016aabd6de29651a14352baec9d742744616732399b670a47cbed0527a0d7e276ad95ef36ba94d91b1d3842d5b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
