<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"73760133079c1bd0f89c74f64e177e78c429adb471eb2fff967f973e354137ec4eae8a5e5fe3b0380281488b4bcbd8d44341b65283988aa598d382ce760c35c5e4c12cf87b918c345abc2aaaa25b2533515fcd805c5de8b71a496ce56c6b15a2966790945dab52c8882ad6b44a9007c4fd3b2adf45b4f777e1a0b9f0af997b6cbe6233eeb1a09c56974700f109c3792c931540cd4312a4ff340fb81086266eec1defdc636dd43c04b48420a821250fc0a749cce553e8c5a5e388a4caf12b0f97f1226e93d827dc46e12c90510962abd613c7331357030c7bb6f1865a6d3a5da5247509f0c8d03ca5507e33ac9ab638623ad050fe94f80ad407eeec92164a610abe0b372d60967038643c28917f6a82b97fc3d5f742794cce5a3b12f884cb6859285efc81c9a60c0bf89e672359db0de7f28d4d3399436fc7742e2fef99423619abde8bcf34ddcae0a94d331ad53475d39e1319ba36b39deea24981005cb90806e838e3f098d623f15e315384ada0fb4d81942498dd9f9896f95601ab9c98330f51193a483326e3e7e082ea41c61554520a0a5d59714b65846215354bab749d7b96f654b5a7f2a010c0cb096e11b34e85cc7266ed8d0f52783587133f1d5dee4827309d3d57a976a7ef149a6d9538c178b089563bed9ade200ab6f6dc7fb84ba7a1ba59187c5df3bdb5ec521ea715b8520bad527323d9e51e2107e4f9f991444a818d4e4dcc40262eb4370dae3a1850f21c9e9bfd34fd726e9c0666de94378529af0b507e33afbcb2a686f7e7f5b5bf7f1f10201a2c1b0e4925fa09522bd39d6be07c219f74be420b4d0c6a2e917d531431ecd1cc49fea95440df7d5ef2d5c3f132b4f74bd7a53311ec8e3c8ad6d9f6023aa54b4d82690c3cf14d90420532aae11fef87eb07dd0fdbc52788b82a85be890efd457ece113cdf34d35a898f6d7dc655dc5ffdfa13ab365db738dc5cef9f554f344537993a2fbd5903a05849d66b4902e4852014ea2ff9a2c3e13adee835971536269a0617b4e4ad0b74f845886104f073da3bb5d148d220ed768fab71e8e63fa532b6d3536111cdea65f8a702405e57492f1b9dd7cc8fb54c467cd7ccd4bb14719a9b9a6270d0d3197d224287e096fd8e6eb6adf602b9293cd64fcb962ac3eddf394b2ed8046dd050ca0fb07d8a2d3387e447a9aebbbe98a3fdbe47bf13a26939f5268a9a6db895dd805c3b115b978fe7f8ea9aa0fb2e7b9b05dd75311c622f20d10959a84ce2099ae584da8397d9b83bc0d62fa493e5a4dc1deb342912757301218f27a2f60a28249672d580615a236545fbcf7f31fc2d1004620c789e05e70ff3e74c526b25e249ec81fa2f50fd73a728d2c6bcfdf06269988ee6fad390d622b2a164b2afaec613a75f0c30a25de7d1323882b663f52b662ea0d9995b3353bbea2966282c640dba8ccb148a27d4b13da9008c5044c733ba10a12e3b1f00443e0ee4ddc3948370276a20b4c0afa0f83c9abefab86f94aba325968f18e98d4b925a50bcb608b0e8f9ac6104faf59fe62f82120837cb9d7014e6498e531fffdabb1ac971744a743b9fd89c9a91454ba596d98c8ee3fcb5c9f06ac03340bcac77b1eba1313626609a3096c96d6ff8c0bada66105330b90af950e1acce158dd08bb69ffeec1f7ae96f8c8514850ebd5cd839f8cbea500c3bba7a2ec651f32a6a2b2621dd7caf1eb560650744dae383562313c128f6eaec69c1c38a55e4d6377a1da8839e5934a4e41311feb140a1109ba917d8028cb79b995d97d7a6c24058ec5f6335ba92fee2f1f55c2ebcc32025810d0364f58aecaf8a08131bb04b811d6002e6074c0fd6fc1b97b61c0f5fccaf60a11f1b110bf6cb998cef8527e26f993c85a8334d5e6eca4c1f4b0e1e9db5e05bf682657348c7d21d00969a90d2057b9ff43df55b2ac8cfc4083b57aabc1e90176afc9c637ccd2ecaf90ce76e8e68a13bf055d78bc1cad06075cebaf03c2f0e4f940653d757c3e84fc8345519f8d4052173c09dfe15abf8374f67ad7237485967c9c7df66e5ac09b8e96bce3fe61ce46efbc3a0b8e58d014c25683fc6f324336252fd26ff39ee090e9ef486ac64d16f119623bb4138b4a0ca3267b390e6ce8c2468bc1ce75e28923299ca8c465faa9c9bfb313764512402cdd3e45a1e53e6e2c30946bf7badf3261c523ac07c84b288fd787e0a2318d7383250391e397ac4e1d131491986fe5db23298b67aa5a54ab53ced8409082c71b70a56ce94f8ad757f78735cc1d40c93b16a7ce7649322d101b17bc89a95e9ac0c2b2df9a8236d10170e3b0adf3fcdbf32090859c3b067fc51957c4cc772f2bbabe90230fcfdc561686ee1d04c132b686643185b89e89a52e0dfb501af0aa522bf2f0250a248ce08dacd180575e6cd8ba334be503e945a5d2a640db182489fd335c66d3af4096bcb3595a505a45f52d2f05338bfd18bbac820e5ae5830336be3b83619bf84d3f4e0930c8b0001a5a26f4d6d2661b92fa0aff73d83aaadb1adc3843b8972355e154a9b3f5f1daeaa99fd4b4742d75c3915c6c94af7cd79906a8c067e3ee1db4ccd731e6af389b07764f6c47c82e9050ea2bd4176c5f1bf344a4e0169cfacc6fa176a968a66a32e6a7f428b792a23bd2d663bcd40c198c3ee94dc91f7f00156add930a5d2e1bc7b79e86cd916a41b97565305b13f1fbef9fd28ef13ba9fb4c746a935d564106c2929692f30411c94bd092ae2c5b3127bd71bb5063e0d793b7a937b9f4d747903476f8f9e3f1bc5afc24c23e60e41e7185cb41254e37a6bfc44a0b356d26f614f729a7b3ffb68c69d72996df4dded3041db58692d14474b228fa2b67cf280f2eee1008e90c944066acd4afd6620ecea74892ad49719a2655ce38626b4536a072e70fd74e0278d75bac16b601b0f714777658bc44bb2da84330c9a1c6a24abb212d261c4dcb08a1327981eb288bf0c4b449b7c5da7de8e84bf82325bd93384c39141acde228ae06ddcdbe3662fa6df4a0681026b81735d54eb47db8d2fc14aeb7518367055b14646b94fdce21d535c0fb22dfe4fd2190acc698dc2cd3178f8d07ed395b53e0b9420c0df0204ae132f820821c3dbe36927d786442ec518a41ab4b4501ec46149a436277a01dd5c666a5c8217ea7e8764ccbca646f2b1ece54204ea1819e2e86f50935acf981ce56113d29ea7d213d47b64934f68156bc0f4dde223ef152bff28527851eb12fc4c738c9847e805c6da6ad84d37bd33697f5297ff15d76fb5142d542e0e1be67bba10281aea870772711c41fd90b87b9af54387b9842a0faaa38bfa38e3c7bdd4ce89e2fcab7c7e04ee007f14ab7e406bdd328c4650f3e010e33bb71f97f6748cefd318f945690b67526dea47430b3b776c4957901a118211f76673b43f65ce5b7a37b28624cc988ebb19ec1e24d2b605853242826cc9d21c54006d813331d0213c150a72fb60e71646ed01eaf861e395814a19711812bf2054d98ff37423fb0e0101398b210a49678847ebb8b27646d4e76df777fd9b85c14057dcceff4351089fc6163826baa97b6460cc4e6a8273b006ca408b1eb2f3209a43cbd55d3d7299c0265dbcf666aeb7fca360414149baab0581063aca3d88713ae0fee1b7066105b2460e786291931aff5ac0c231b94d72867d9404efe9546444a0994e10bd8d28e345684bfc2df9f38d8f0a15a20eb875f004a59f4f6ee412aebd4fac7016f36d520dae70eabd3e6b0e00e18b4023ae56e1ff72972346f8f402faac31a2db3304e87c703fe41c08bf8fb08bfa9dc82eeb612fd1fef73584d9e25cea427dcb05db04646d022473968a9ca2a0ad63f8e6ef4e6ddd3e4c733e54ad6603e481f6f88e284703d61546758ef6885d47e2b63f2200dd720c3c09f79b2b1e0d72ac3f3cb9b9d716768d71e9566a4fe02b74e9f255979c843ce1276474719c8d3d69f1034b821a800399d0fe448cf68e58e4bc2b9c4332bf819b1e2f8b70086cfc209e8fe16e3fb31f3796bd9706e50bb3905eeebd09eac31ed3db2713f39d7cdc7ed8331c2ad9a60e285424da651acd3d1ec1938076ed0b155f97bfc9a661ca5a4d01812c7a34e1ca105a102ef2ad4276bb8fca47a6b231beace4250d49d4994fa7e9c8a29dc3c8805603a3f1ca8d74105a0022acb7df46620a121dfe6c670ed6c55005e4c773c71086b2b6c2d4b6f3e19b061c2447ea7d5eb6a7363f95fdc8a228535e2fbc1d92129d1c861993dc184e1d62d09290470941b8eae121e58c0bc72cc9bd3091f358b4ab43922b63b431730933c6a18f504d5c43529cd80b8e830b48f647ec6108cab0483076e417aaa6fd81c22f167b600c8a4fcc8e8088f874ea9a0de8a9a90c3b57561b759d1fb710ea48275bc73ee2271e3972106e1c50d0f2ea2daa5572506455aa76d7dfd6d17ba4299f4db698da237cd491610a5514a95b789849683f8bad15e6a34ad5ccee9dcf8b15473a8941fd2929397258ff0cc54c6f78ac03894361a3062ee874fca78b5361e245a5fa144df35912ae25e7ad81f527ce53fb97bfeb2d97e770f95e033e471005e2f8be44123286231be5ea3c587cc56296f94288950259452b83888bdb33d704425ff327e93f24a9420b13a1c6c8ab0109dc8bdd537b8c2ba378ace9382e5cccd38704775f130033382c8dbfc4d6c58c3a105566e07796b7edf20a93616ee996e66bde8ec3cb8547b7d6c818cf683587ce6854535a4150fbe5dc7d081ebf4d3f3ff2998e004b4d6b74d96bfe97eb97b23c2912e962c4661048b905403883e55d66e6fca3f5c87823023f7763e77e0547c576c582f211860eca47f88ae093773596ab49795a485057b3072fa1e3607008a3db54f403ccc7dfd432b1fffc89b1a65a0cbb83d257d13158c2891676519b45676cc99adad42841f64980beec08326acd8be8498ba5d13a86e3b55e2a5068a2c10cd242f453fc4168bdc06ec880e1b74d8dedb1c064e2e977321865645386c7541e004bd9ab54ed17396740bd8696540586f592cd01213b4affa695659fa5f1f32b15fe2ac6cebddbcecec1848f3127843bc28e3ee7bb2e9a6a42bf60dfc86ac7504220ee1b9e73063aba2da3c56c4a2dd0da550ab633490f3a3198124b8a1a7b3028f14ecf33471e34d34811b357eaa842750768a9c379ab828104f5f3b186a3098359f9c12f358b036f2fa88c0a80fdcf6f8a2d8e7b74adc9b8ab734cf5ac7ea7cce15ecb933dff31118ba75054f5d010466539b091434973db7b0d6d020c41ac785f8e533face8e5e04cf2bc20e46a17c203ef1f20656fe883eb34481297c236c5dec9a49baef98d49f8fc61d28925e05f3a896b0f251635b5a13312ae0f5b16efd7de980116d10a82011711dcd94c32ce7eed51f4b1b92b14884cf278e17942ff09093ce1e633251f26f6ccee66772c19b8d30be1d89296b6c030e97ef410f5abc0d196741251ef6a9ec11a3fc905001c239d16ac4b24cc31c14fdc0bad6643faaa1bc6cce2239980eeaeaabce142c6f6a3fbda73934018137eccabd5a6e85c0dc8bc47238d73fa289d139ee9f910aa34c70794dee97b3c26bd81fd4409bb19ca9eb60ebc206c2b5ae80b56bde6279fa607e31a4e249599e150737fc01b3d59ae11d8463ed0125566a4903614dcb6c8a2b1a166cd7f6c4f2e93be58391c8bef415bcde0d13f18a28b2ab4830014c8fde98d0f62a5347d3c76ee71633032afb182c1a2095ca69aa7cd09f06f7c20c8d5bbe9417ff6324ad763c41b4361eb402c2754626214e8c260989887aa70cff32b8da96271586a39f95b7e5b2b100e0f0ecba8a0c80fa1a72c2db800bcfb45bacbe6f59f3fd81881ccb96cc939584e7e66582c3e67dc96db7f6a43a14a4c48b50b8671f8d107e58d6518f9a8226756d60f28ec3d7fb94fe7d779251c610455a19728388813f0e72646e7f4ba0a108c1fafbb861bea0caa3817cf4b427b09a2247427d9392a8b5a312820a82b03920b3e0b33f75253a05068f41a9b25d2525f46a938f03f929232c17b479742388c2f67a7059ac0078d37c75ce82467f303b56d180d75a21493e7b2ff97045fc6be19c77c4b44c078f684b9d542e2ce36d0e4fba7badefb8756671bde3453c8fd941239a66080ef2e7f1e3be5cf7872631f96692fafbfe95e30b9d8bad87b7a367d3181b1fb5d4165b1094a0e5c168b739089a2c5f932e1f7eff5d5bed63fc9e727af151b5d1ed7b3f3ad03ac63dcddcc366fcdb8b2e4abf5a92d4e072851e20d4d3f822a876c56aa5f69f943dcf9eda7f7d1b5130ded2b8f5926d9352a31c6119fd2d8bc4c1e424d10380cd6f65fd794a0e6de6e72d40bc59c1cf52fb97aa5d513f6d71050288666e1d32e742db183512c10ec1379e1bb33170413a9906f0ed1e59b9248bd2b5d7c27613e9c3fc9ef2da549fd01ee3d704e74da48e98c080fbe1e13dbd5130b36c1aca0cdb5e8767bdf43c943d2234f8c613f452405de2ac841f3ffc7e26c54e2e94d1ad22541731d5c8b39df6d0c176d4429e13a444cccaefba7633d788cd039a125d10909c9f615fc912b44285a77c86bbd6566b472200a76cfc56fadc5e98db4fcfbcb00f04bc11ddf3afe74453ab141810be5ab0ed81ee344c1f89a40af57bff8b9ba0e61958a9d79182fd15721156491c6abf423e44a58712c187ba3cab86fb769256b4b49d5be0071c73c385473d6bc8924896f070bb3ce923e8c71b2846a609e671304a37b5933480a50baa00c3922b6e64c04df8b1f146ce9074a4e128a6ebf31efc8e028c04c06fb142d5cebd1dbbb22d959ff338381ccfe0ea3a8e76c8f4244cc1dcc1501dcdf7c0a08ab5ab29ff2958ec3b0a469e44bd001c848569e66779f2e46ef0cf57c7869376b11ef065be5d62043a55273b69504131ba1a9bd993288505d90f55de5b03369d373d0bbafc4dea750af3af867b10cef8d9826cc86cf3b2bc69df4f187c729a288c4810510383a55f4627e42e3754fc3f4321cfef8c0ffdbe9c51d310d87fb93476c1820ee3d6c18c6388d3e54dbd5b6460c92c1f30d7381c3d7384cf2bef49eda30dcba5da54f17e0aedb60db8eca689c7a734c3d8b961ba4273562ac2cda05ccb11bcc8ffdafe18092111532f7b26b1eb4e3a93281cccfd90453f067a4911878028a34f15b8352e35b758e0a23567fbb8c1837c8e0b3d1f849136bf37c04d8c6ff5df95d6776bf7e7590288e9bdfe69174ef363bd31788db7eb8c2e4a214d67cb8d8388837c8ff33fd05543365fda3aae5b2a05dfdc590679d5ff4dbaab0aede37330ef4cd34146b80485322352a97c48cfe9c8fc913840daa14e800342a45851ddf71455ec9854b3a3cb083a645abd11837a1067ae2a1bf0607128a620338e89e0606b99156b72ed9ae12984ec13664edc5239d2ced121cafbeeb20a77e1bd57562025f6c503901c3f2b2c366a8ad8872cbc1ee7402cfde50f7b3444265b85e334c549aa3aedb36eb5b2285550d4f490698a2eee81c0ea81ad6f88ec75b35b399122948a24ce3eb34ece3a1fbdfe7050ff5ea5dbe4a5d595431a9736663f97d67328ba10c475cd8f486b38f75c78abbf6a64f35fd8fe9c3dffd75b835e8080ee97f2c69553079559a08057be8d24475cbb6667c7f6c9d64b8299574a285a8691f171ee0b69d2fe0dd8f64dc069b979fa75a83796b15e8bf624937285307c2f5945b11b36ab692a02d28ff0e68fe0f509ec81575afb4f8250754384a9d9482cd18b758fbd5e10cb40db48267f5c676d1471f6fb1f5bd0e26a6fe293bc3fe9346967e8d0dda5bff7a27766e538b26695fa552076c055856f069cfe3125e3029a3c3afd321ca3a4c3179e04ef45ba10d8099c61694e2c573ddbf278eda81f7d40fb8db5deabc358b930dec3a5989ff01461074afae8eec2b33c6a4a0001360270a331824f2cf52c70f08a203c5d114fc7a00ad586bd756febe0dcd654f6a1d174c0b695ed50996e9d893bb41c16235d87f29fc500f17f6afea4660d41acd8c0519c6f1916565d8bab1b85bc5ccbb3c33583d851605013335fc6acff810711d298ebb8df204eaedb57bba688a30936008fccafe6384d393649967e21d95a601535ab532db61a543811518e9c22cc10b7cd27e1a5155d25a267c935d879ec92eae11169f9c3c9313942e6903a94d79b2d9830bae306da4de3705556d5adb42e4a22daf08e2408d8e72a7c74a86509f574a6e8ce34eb1e164ca21ac3bd0af0eda42af393219fe64e45b5f68b10ede93bf5c723856b26dca525b22fd007d9fe2459eeebf9dfc49a59d8dc4958bafe1fe38d64f24071ef3069bd96665980820ee8e1d2b8a7097ef5260f8c2ed2ebea2d6be84d984097b0d716218be5040b41f612a98e07907b83881b499cea213dda9d946c77c0423c5512bc88baf34161705a128b7fddf80bd45a51376fe1f28b1d113f4363da7e94ef7d50eaed0d02c7df8ca9c0c552c40458d02eb8f2e5849b3b43f52c86aac2d8355b4f08e52741cdbc32390754c7425a68503817a62b2c37d60677acac699ad3ac95ee3df0c6ff5313477de813e6b2b84c7cb3139a6eb5dc2eb961f6dbaa1ad43627e1e00dd59ce7014303e2392baaf26c1c0e0f0e2a72999763caf75a96f517fd32480951592231b02441f13880f55b9e12d5073e7552a658f807ef70ed8e2fdf8d8c85189f7f5c33a7bd4984e235d2ff545fa7a76c898f3a4e2d27b72143b28421ee3dd2185aaeb89b4bb08e7a7d3d3bcd7f1832b388e050f454c0237e1d8f0aba85f02e389daed2bb95b8c841abee6105716489581e48d7208af531c74cf138d24b4dd294d33a0b2ce25032e709951722d68210ffd770a3f719c5c8308e8967fc4b5288e5d5281f85acd7b528061ad052fbeba03006150e3324b53cf7d51451f979a998a909bcdf649e44b56446c8ddd2735583a7b481617f5f1d16a54ba3bf1811f7e2027962deaad1bd3a3dc9811ee746cf75dc65c489a715c4ca436679c7caa8ce4a0b2a3b463a414c895194d1c12d1969a93fc7213f28d180c2cfb3b13f1881030659173d18999fe58b802153894c0c7563a20921bd437171dae3fe767b52c6167b65a5340973c68c7c38b9a15b120391a1208b406dfdd826f69d20c4a5550011515056a783d8e389d7b95d8689617f63cda832d030a886739fe98010794e0e4f793cac05ad3bccfa5dbd983c92b27485827fb05ad5936e62d70869c6f2e7ab9707ad5a106a07a1508159581bc19cd3a7c87d24b93b1fdc86e46244e61f80941de67c22d123328b489f84442bc2a66dcfd7a8ecb6e6e74bf886145a63b0b359c97b66a8704bba3cd75d708b395d6dd48529f118ba7e4c8a30d36e5fae6c47eb6da302ff6eac1a5790f0acc9d867bd7ae4b44bc176acceeb3b08b43abb5dd4379dd88f0cdf17ca0b53049e424ba3e40e574e9bd2b7713d0d289fcc8a35d6086036c65de37a4a40a2cb68f03fcb7e1673786f6674d5b63036557dae2ab2621f551238760d1c046c8ce81b39fb9c3026adcdaba36a4bc133bf6832a37d26612193faafd68fa76dc46c4f9a6f85429eee9337ab17198db6b447c649d03499582938e0ef234be6ac49d434ce6be3cfbb7d1bec941aff600a7010775a8824c117b76585c919edadb26048a50a4c4145473b9bf3cf443f3da5483ad3b97d85f6280cb6ee6c05f8876b19d9828169b2677a16c48ddb658204fc9d2ab5b270da2b272da6a107f7bf6c3425eac316228805afac43e68ba07785f6c02acc4c888e402c206f6740d1adc36b8aa798a3914b934b437a24e94ab1525ee4f992e2db1e481d7085bc431c8694166dad582216f018aa5ced317d9c266805b6882dec36765e2cf8a5e105116dd549ecc0eebf2999434eb393c234910ae030b166ac4a0dead1b3967fd8bdc8669e03e4f49afa665cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
