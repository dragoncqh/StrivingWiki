<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a09707d5612d90feaf942dfea12ecaf7a7dc141c726415239e43175014c35a02c7df632dd9fdceee1901a5f768e08ae8e3806fdec84525c66263d6faa3e0b383286a078c15997131df011c42e13f27fc437b48a05d0dcacbaf79f9a8e8e95ec5efaeb04a217f9272206b1c6adc0bb5535b75b045920080c8e7c150c15d6f029fd1824488df40f1159717299948f0de630709b2c2c730d9d1a82a01a0d45d9ef5b8f7d3ed99099853b115d425174d00ed5ab6a7f10f10d6f97e89e515bdce9ce36516fd27507d9928b559da1a1b0081fdeddb5dd73b8e56dd9aa18d8d1e11b4312a25f44983b4aeb22a3189c9e350c84c5bd4410e26408ea96f52a4bffb651cc2087de9088b373df2f2bedd77e7269e00f10b7d8a78c2db62b403e6d34b26077bf9f9f5618d6a0ceaa84e2f87722ba874cb4f6ee703231169462ef992c8411fd08fdb39ac8578d620c5788b952b9e886190cfed6c025f1bdc6b17ea4980d8443d0656184d870dd2454bf6cb7a441613af5db4482bb0bb4cb2ed129413f68d0fcf424a56f4b46b4bf3fc5116bfdbb396627266c93a76dc71e22b939751df1f3dc9cd385fd8821c6210654c2d08a3625d1980ad579a349449709f5a46d0507f5ab3f9219d497075ce1b2325ff5b834db3ddd44ecbfbd99e3bc82d6343e1a0b99aa0fbeb5e1827f8b7c20e994e8a7ee122a66d123b0fc717834a833c6aea44ef66d27665a2a9fdf71c38ba75d908ff62db123a8b17d32043510969035a709d6828a6fd2991375ed295c8d7a76f5dbc8be827951b55ac1184bf56a65b49eeb1b999fb28276eea93161056fbc89343d73ec4db3b2b605d29b0e19f1db6ae4c30d65553f361bbaa9d382a01d7f79bd1be0851b57a11798657cd06de56c27a04e4f9cdb6a122b1ff0af86af1fb88990b433b0b1bf4cba0b66e4fec77507755b33b5d460e3c8848607fe1f9d1977670f6bb4b28f1090d8d7bdbf9bd9a9d276fbd12ea4aa2a2c0f3f5a35b129cb9a4892bed612aa4f2fe17f830d88907ce323fbdcc124d66670f924071bffcfdf605e9bcb257cf27c601957d832ee657da9968cd217c3396f5a9a70f5e07046054872a655aedfe984e7e1f1d80d854b8fac6fdb229a8ef197642d84d9e4968473082c4390b48ed82d5e5043f7dd4771ae6c7f363eef8232218d199450ae88e9860261fa2eebe3a2e377a4982d92dd661b2989402c3dd930f8a004c3d0c88c10f48d86e4c8b3779fad915103b53ff17eb6e0e666313ea81213c35720af2c89a3c5ce48a306c13ee39849d2e4f34a51e2fc91467ef2810e29996235fe8f88565dbe992660961a35e17140800e47354493986ebf2c9938e9829b04d33b5ba9dbfacec1882d87cda1d3e4853732a74341095047bcc2c19efd583b3a3d8aeffd5967fd1ef6cb0262ccea25d857f3c0eab5d2935006560ce96b79194c00dfe6ee52fcd27e04e70d62eff69b2ada18ebe94041d5366f5cb214c417c9dfe71f078a00fa4531fd981f14c862a515e6c5b5e8d2d7ef7f3cc77c874ea707e8954a101fd954eabaca7d6e6f971b900738e82ac87af20b9c935395c5e7d3a25ce77cce84fd08f9a2c4d6b2369eabbf56ee01f1e81b2fea058e6d71ed75461b4b1bd948404c1eac9b81f9998fce38947ce9c91f443324c71de9227a11d50c2216f4daac64670ea5296cb275e298c762df7aad639d2542aecd6714035bcb2f98d03d9415d13f3d13b624751e52bb7ac9f64a76eb3e561097b316d49393434b6a201035502e043aa6e9599fd38677484cb9bc246199cfc7ca87e0c531a48e4c5c585c1515fc0a673bca2d33ad8abbac3a67557d49b2c255387eca32ff2fb40418c051f54da83c6e09166ee0f929967bc21e7d0bc43ee6206bc9c954b91500b0c68695a9c9b8a2961ef02c1688dc569e9d0f04ae95e5206182f73157bb688a87e4356043d4db9dd50ac820ca285b5b8c910ef5472f4f33d234bb138ba1b47a7acaecc80fe96664d8a51c909e9655e947553a26c3f7bcf5525b6034b2bfa78df319b7af7fc8d4adfd2f1ae2d3fe5a2ecc7c880dacf7fe62cb62f0dc6303c5a856836196ffacf0bc982dd85813a193cd8e48bc51f09aece20ee258a4686ef26865b8e7e72ab633d221bf5af6d75af2329a930f6f0301d06518e1deab89928bebaf0f72d5bf995b8641f3f12a7ddc07421c79e108ef3349fa966097bd133e7dd32e4a7b11946d526373813c4b8a7c7f48e4ff941f602eba1121a9f64295f05b61fc0143ed83fd6ef90f3568988e5d053b683adedec6296a516e035e15c2ab2734aec809ee430386ae3017321b841907d4e27a152096ecdf782208d705d67ebea18919962581c56678c18c840b54dda1133f8f6d4827a7b5bf81b398a84845f173b716e8d21f00c4b51de0795f87f36a517d45d3aa8b26e4a9793a73b5b15b76e69167051753b1b049ed77211d5b7e58d767c16408a4cd0f5a778a95703eb987bba125a61bd4d98adf233dfd94e5f1b23e8cecb1d32e5b51d53122aa8d840246c7dbcf4c8f871b701cb6be3f188e59a67e391ee46b2af685caffea3e5b0ff3d97c0d0f38336c24ed434a22e8d4ad3814086d9e6abbd440e9a4db96284da09cc731264aac937eb65f74be59e1331d0a8b3214f211005ae764dfa864363f6f04bb8c9770359cc62412818d01a3d3c11bd043092a1d86d7dd3526dd3e31216ba9e3f54095d6bcd6bb0f7831cf145b3368766333b86b73968b234f9cb01eb1d3881fa1f0f61ab457ae65a4d475b2a4bfcd9a84c4ff094c36cdf6e17f88792ae78187ee64347a2527526c6f5372feeedef927ecf143f005ce3a7a4d85f79a0d702244b3702293369c8181dcb25b9b13a24c18233f0bc73d9a0698f6bd2cb01fca910a7326e3fb8d685bcae8e08ccea07f2a2cbaf75431ad9daeba49f21a8976d55b941a2dbd723615b04401fcdefd765830ac2c8b5fb6241ce2d992556783fa6842fb48d716e6be6035315e1e8b2993647ab3967617021fe54c0dd6ee175648c41d7e0cc5381997d5c14c5b08195290825df5cb891b6b8a79e2565957780ed05667c2ab3ed0e7613362146c69e23d1b2be2a693f2a667f2d2a1a58c0a090f5ab561b5ba8e7781a95202b2d7b7acff774f9516e088aa5316b39e7039d8e90081a2fa9be1e4ed3f587f9f7b63399caa8f2cec95511c6fd566b81069f62bfb607f326d1f1e48cc3cf0e71d4371fc499dcce8a758edd04c91c52d449a8078e3c9d4f39865ccebf9d64d254614c0a4d00b099ab7f74ef943922a500a4e596ca37854411401fb9770a82b58b7f32b1f0360bc3be82a38aed6caf0339acb64a9e53a8e1e6053a322dbd3ae67c8e34801b72afdbb80b7f7532d47940b2ceb7f29fd8498ecd5ecaec2a323308e7e39d00eb8f47ba528cbca48310869655cc659f6ecf1c185259ccbcb90c8a13091d11655974813d9b87dcf1ccc1ee4bdf422a3c1020bd906c7710a220eb384c456b72da26f02deaa27826cdf7d06d024bb0ee2a840e5e5fa1f366fdacaaba7980f98e8b8dd17c4c50a5a805e3e60cd2368185b2cfb641595f7a3e2f47997d082046e39ff0096e153c49fc8366c0a4b9a649ceffa9727614aa8f024498f6f18069802c8741930822bdd3682f039f40db1e254ca74c2a1de0d547a9f710d00b7146044fae029c9096958a5808d81a7a8af18f8e90e4160ee883c73c7b58a79826d867e57d7afed5cb0ecd483d492d8a759887be5ef5f07d3b5700e120ab8a9072fa7d0f915e72aaa4e68290359ae07d98ebec0cb13e58206f056bcef7d2ef4503073aeba3683cc21c03c7d74bd642d290648738fbc26928c9a7628db14543a060fd61f10a6da9807c0dc5ad415f5a2afbe9879d0193dddbdb9762db75ac2a26ae7fa9d8cf0882a1dfac3981d17df9f5edf5cea9dc30c524b05392ff9904c8b68e611328f914f78478de7e0be54ca23a7e3fa31d2e4ca2884b7f6e41d95f16793211ac19ccef494131b82c5429585cd33cadacdf26414ffb4bf79c45e7ed20f13307aece84e120541b8664c3d6d9f408bbcd3339d77f174c3fb41f9341314569ee735eeca60a00cfebd2ec37b0299361f30f02d41963c29aac7066bdbc358d0afe06cca720a1095f32c2b4547bdc63669424530aa50a64c6b55aa881c4e8fd654750614135a5d3815b50133b7a94e60067d27223f0225319fb05d8dd77f883b9f9514152fa7e1b585cf81a2e0c7f87be89a9184371705de0e2d19488fe0ba91cdc371323e31ca90e95aeff6e0a786a75c6147e9a6e534b335dce8fe8c423b7412dd46d4dd99d8ed08f8e1c89ca486c61d161da33f973dd5ebc1b90c36c0c89932d6c0c0b35619a8c57f36a4568867ae203efebe85090d862b09f6bb88b4479bcf60dd14c34889ff56842e680569ff18cddc30fea461c421ea384f8f0b37890e4eba71020e791063dda929083fe2533adc7ef9660069a177e014f0bdb56af1e7f53376085ea0b6dc5790043419cb3ed69fdf0276c921048dc54c5a268fed9c4b44b3a4005c4f899b423c37cdcb373882274478bbb06bd2ce97cd8d98d956a0caf5e308feebb71f3b04b1b5eaf8261d49bf4725d86d23ed89f8281dd694024b52aab50678078862ac43d4d711516e827ccad31f547a99789e9c3e7087255eab4c2311dcb49e1ac842069c9b932fed01e5a1f2ec90cbec1dd244329b230cdbd507e9a0cb46723160d29577daffa1152148067fd6ddf777d3b35ac882f0007307d42f795e4d8344fc953e1218e58504c69617c8c96ec528a9d5d1f365b95812cc35f7cffd97c90732308c98d8ad23598e7886193b625651de8b40a812ffcde7dee66fd535d74f0b8ba605805d4442dc4abade0077b892456632d131bfc212f66a7754c7e72ab99666fd835faf33a1539d4babe77c43e4baaaa46df2bf6c868cbc606f467b1beafcc3dd3755d5e15bdd9a99a7f440857d69f3ee713b60e64bea63f7486a67c4fc9c61da674c2d713018e0b5a2f6e04730131159cc4a95f1accc716a25f03c6879f957598756e6f39ec806a5c02a0ad9cc8ace0c842fdd23e6b8a5fb228f4d566535b3f2d3a1cfbc91bca0bc075004312dcf2936d3ae43bd1f4b1d87cb285bca4ec13501049f9849b887c4645683648d66f5f67be8169c8a83e263b9e2b3acc0794ab8a174fbf93fcb73e1da6775f7b34acd11538cf8e9b730414e0cdd9ae6a5c2de4dc994da61ad1f1a324267b72d702ad150c21f84f3c36072cd68306177ca1808490294d891faf44c2b0ad3e613c011d104e3540953ce573040ecd34617110994d72433d415f8827a6b5183854070ccc3f233cd70763518a9ab7103ee4933ccace0bf42facb8d58ef321fdf21d93239774004e4defd1c1f57b5c218bfb253dbce974293ce327daa6c7b7ebdf13e9fb29819bbb9b4e5df3e65cd9f99f5e2f94e0b0efa444c62f2e5248629f1c4fc4f5b3db5c4e5a0285f88f03381b52fd51ad1d5fd1469aa79d8a05697070fae8789aa50b495b0f26c57d4441755a92996314230813dea37ae883701fedd4fb4651cc019f3430556cb2356d3d7b8dac62b78bf98a97f62174fb348cfcf70e0a70622c7fa2dc41d05b2cec12dabfb381453375f05626a7bba9b4612b76e34afac1893d9536ab60c8ffd478cbfa014975f06cbf0a501dc6ed1e508dd411dca9853231bfb9ba58568a993973f228bb71a3027ce49244db9a0a1ed5385e389e58bed5349cbe96ae89ae64530798104994f45853025911ec42afd7bb6de34ac5d1300d592dc115167704bf21c5f1853af0f85f2eafc60b0c2f0e323544b99ebcdbe8047f2c92422dc7a9e15931fb9ae8dd6b941e8a03750215a3292769b654e6429eaa855516b61ac7840495546e89ea41f1ea56de413d5babdf0723c7f0831adf584fddfbbafac9cc7ec6da0e32a3b62f943ca0c20c744a1f8c4d36d2030de7b8f044f0b823d53bd5413119034bfa43595e0b3f39376953b99e09a8dffa30b6b7bb386766d41705bc89a4dfd779e984409ad1c7dbdcd557c09cfe2fc6ab6ccb9d8df9cfeb2d6972fe4655b38042edd57dc78c88d51d7f62e9134f8f66782f270fa0855f4cbcc1f2772057c395fe5f6af073343651ba3b6d018fc55163528e9daa76636734faaf52c3a1e31f54ea8620b054157c7b60027c367f855ba2056f21a40d6f1cecf639c18132091ed410aa36a2d457400e2c4a4c09190d4de2f1412f4f96bba6fb12d8b373786c0fa1da1884476a6eeb621b18a723cf55ffaaa46c5c7942bcd6e3994d86b220c36602fe7a440ce277e4206176932033bfc5f3c85aea562194442ec2dbede46e49bf0912b2604cc6492d0668c8e7f5c9d0548a19f79c540f77f875d646cdfed94fd7956a4747f590e12074918cf6e9ad33a6f3ea19402e288b245bfb73058ef8c8a448787002c5fcbfe9a3a49c95ae23571aa77857ec72bcdb9d36648bcaec5a18fa13a0815ac75ad8969aa63fcbfe215269976a6da5f9d74f23cfa2ee6a02f8cdb60d6442d98348985b617d5eb8006c1e1b0ea826760c263668e7dd53ea04ef8fa37c8ac5ccb2cb22fcabf2979066d945324f7449b527858d31076d1f504df969fc45a7ff05b73abfc5ce021ad9f504fd855f32bf1927c1836ed5b011b1023b16ee9268f491136317de7b7f33b79a50aa88d63bccb4ca5f122f9d00c3b77db6de98755dc724feae8324daf70968d6a4dd8f59dc2c8f788c65f69399795a40d5f785f8710ac1ed463aab3ab0b81bd67222186b4feee4393e4b31f83877ef916d042be53f65b391657530f075d9258e0796016921dd47b579c9e9c135efeeb25a9f30d5b9ae0906c757c9e7e01cb0406cb2ad6e86cb462c586925b85e9cc8da6042154c4906d841e643b37f1d4fb1a49ba8ce337c0346ce3ed30b55465130a85289a22743a844ce1c9073b20a0e299cc33fa3239c415d0d4038ad164680666b9b8f0cd6d8aae3ef8a8b4a3fa16d8faa68cc2867579f10632ee775faf33153c544d0352c586bf9260391c8f7b641b42aced7df5a10ae23324f75450ab89216f47b226012c2f80241d875b8128a283db3172de466a864fab57ed1449575af42d749bb19ce52107facc324eab256b8f8bac856c410071bd8d9f559b188a730250c420f056ee9a18c02f84bf2b1b15d6298fcc2a733a48022158b573103ba78e61b54eda0dd8d7230cf123af94d79fca408d19cd69b04047b8c3cb2e915ca242845ddd0b3e1b9874011b6235c6d8a8a2399329e04ac70557e0fbe79a2383e7043829e054362b082195232dc8578249852790b91ba29243de019ad276b5a618c8ce93dfe48fe27ef93bbb337f8be3fc63ef0254ecbda1fa14f91143cd181c9bd19adacbefc4d9d4ad87851e0dc4ba31605b34730891e779db1c238a48a7939a624b87e12fa453f0b99082007fefdb6ed3b99e292e833bd69c330b032b495a537cdf72b99792ac29baf7352bdbc7c6fe6e000cebae9b0c4a9ffd37c6f19dfb2725c43665525d5d23d661b61bc01d8ae2804b31df8d8f2fa15ab450ff8c492dc7674eeb75c1ef96a5d38faa2f28b90b1a877caded1d13041d37f3720c6cd9cd555aa9da112f18534daff38da3220f0c8e66b2db4c57f0ac806434add0c1307a1fb9e1552dc3747b454323dfaff7fb317cb7414a165e8c8ce0f58f52dc52419b8101e410faf03f867d41773b1ef84e1d3e7576d509c5d888d3ce3ed937ebbce49f1818b8eb7a08854ba0c88844c153f3d4eb7dcd9d21395a3b33ac02b20a0c0499bda29086925df07f30e06641f49bd0db14dbd1edc94b1b3b56ad5d27913e29a97b3071f053a067f8ef3c1e4b8042f0e1c9461d1809415823e655e017ff2552e3b2acf6835fd91a667068db666318098f7c2b7c8c737ce5a2f6af517d4a2ccfa625645919a925bfba2f4818f27d51ae6278fe4d7fc8cc8cdde62016ce423e01c50effda85c6d8a1402013f9b4e9ce15ac44bb1cfe466a9ae78b869941ede15ccdb8054db64af283c3305242ada3f24b33da8010df394f9eedab790eff288ced229f2f515fc6217b8d6ac1b6556fb826db49cdf9894be90e5e7c06dab94a2fd3d0533ce85f5823b134e22f3d22b46550f9497f2fa7bbe0eb0b3c340e395246aff16803f63c0ffce619962e08b93f1922e65e2e3972d2d0a168d64ce016f9af7b7b29600b08dc30f9be1b928606f10746794445f2231329983abb10864d0fb9c769bd9481d5c1d1c940b642680218e189103b930fbc96cb8163710591c9fd1a5519bd9fde2fa01a14a483c5727f6d4102da139c9ea15d2fd11159a64bfe5a301412f97ba102e011efdd728ff6a3b9a08c988d35c37e41ad15b5fc2b9854768b2cece81f64f598b59644d9fe173da44a9c4ce90f69421b622bbbab146b449ef35b1a0cd05ad4ef1b32523ca0d40c8f3f4f982125dc653687c4c25030618f47164b2ed7d5d93eeaae9c4ab6e0fafd4892b96ead08a4deeaf7b74edc8807677dbd420189828fd0196c3ae6a732ff830bffef1cbcaa175074834865d358a8399767d0cf691961808e7580127ab323a5ba32695082422df49f464a40a5d66cfbf2ab8473f5b924ba6892b52cc6d0a90474beef445d385782b6931a06cd6d574c72a2c8cf9c0234fa5d5a358bab80681c00fc25a3983210a03fee07fbdb7141ddae92e9a7d3a78af5b49bfaf7f069c495e47c0efd77c059db3a3858d6692983ef8442fa15381e3ab64586516d6f51073b0e9a64b31b43ed17ce33171fe3825fbb3b08d3e08b2add8c4923089db98a11bc3004e8ab7844008dff460b66e60fd4329cb5d90f243d60d38aef8fa69cacc609bb827cbf130c5ead94170a6b133877178e17b7ae07a448c954ddf8a76f27ce7bc37115cbe174f6dc81ef1056860b0b0322e2ee2ba7f4577ee6eefe55efa1cb5f6e03444b73c06645311e93863f6b5739b6c5f23168da41ce88ac6d9ac63d61e9f9d4ea0d7988a10e52912c0e9f5f60bfad44c1f5dc53a42e39752970e375a9de8206b2d641f98952a69d2983a5826b1e7278b684f60d10c9c57f1e2e66ab5f686d62f48b8ebb661744446c870f237dee1bb0e1cebe75831976371cffa7d3bb1687201d10c7a9612e2d4f8760b9d396331abc142cab298c348ba2949f5fbe2c02b712bd94359027b710e742b94d7db91ae2b1cb6393391595f690c281b6f2d67722266e88157ce86011578251566b945c3173472fc5e82f9a02f8f90062750654c40fadef2235c23d6f80befbe278555c6072e7e01190b6e2950274a5a9590a6853a1ffd85035535bf0c1108ea61cc1536ce49be072c4613b2e8b3027f1b30625376af4ac0a1f95e36e4698a5b5eaae59ef2fd643f202ae1e5748ff1f0a40d2ab290c354751ff2e4ef967a91626954818ce2e8770e7fc4e53aecf66991e395c106276ae8f4bef0190ac5d4d88bc4a125edc7b2d9ba36bb1cdcf5a25c53240635cd765238720dec5bbd72ca97dbabfbbc2aa2f116f9a412408e96fda797164e56606053b23a02e60e9ca756e672b2d1753944d9694684449593569d5429322380f0b5b7e519a400a39fbf4cd0c1929af8f867606fb0fbdc1a19996c95cf2498cd6822ec2773e29b25a9907f97cc22c85721420ac4c6ef629ee92d580d1596cb38bd6b3136576fe4c7d05e512d67afa5cae60acb957fdb40241c014b392207f01f3ca74d782f5dfbbacab9c8c6bbae7ccbbabbd2cfbf74819a4a8806fcb40ce3309a199950e9bfa0de41c31f7089d2a5f16b33bbcb28475f553b13a875c32662320dfba2e549495f718aa6a1ac8e4724082155a55a9d723512241823f05267e9546614012794ec0fb218202889fa3327427095c3474f186ae2d1b3675c78175468a3ff85ca5d731b23a4467a1a240a85259d7b111321c7b7b707690efcbbb69a13d2533521239a0e2bf7ec089ee0bc5d5deb6f4414819456192251117b02165e25afafa39086fbc402998067117b8904470b658c1081674e22b6fc344bebabc75510a4be1c4ab9b3458974880d646c4b444d3868dec986271e3a739289bc290dcab06e6a2b1b365b5a124d17789de2e5bbd39b35de07de9f99f94c1c111e4c0b348c823e21da72da972a49644c743be62ee77c5c0be96bfae16da0f4a01ce9e6052edaf3a8dfa3bf1dae2b3d5e4b653fd4a713ed383abfbc2778987142d66029666ce129e6f6fa524f278aa39990cc6d5ead170738401f86cc7a997380d340d521e9f0d222fff2f3abc4c339045c9321addf837cb7716a5ed7b222dffdcf1ea35bb69f93bd36b03829b0b1adfc034166ec51901671f43af8f58717ed5377fbe0c379f8bc542464a89a13d7a42c6aebf4d94c1d505f9501528d0360b2c5f281bfd5184ee8b85dce97a0a5a4d1e424814e979f058e61d4aaffaadd8cdc73541e58238cd227ae0f9ace848985469491d76aa57ea19912a8a877840f3a27ca7c2536383c033292eb3ecfac84e29dfdb97db15eba24316d69d89ec0375e5a7879b792c82d30e9a5b5508815b575425ad9bb9f8b9517639329197463d99a826b88fc30d78a1b771abe3aaa5662915470bc075edbb270e8c0032b34f2e4a685b67261518738f0ab04f5bf00bda101c82087661b774276dcaa33a9dc43a1c9a261b8bc572bc2c26825fe67ce6e1d111451f4d95eae9b5b4d9ac04c7f6482439c7efe3ce08882c105123a3f7c0c5df850e8130d01dc1afde09af1c0d91f7e849364d471b39018a803099d002f8829b15fd6b034ff1886028f1f189b73b1cc45ca1132c5174ded97ecc6096c80f95206fc7bd7c72bb6cc61425963c89ebef8d1c7c235eb5fbcc87d40c279f809d45573172cd0e51a1b110ee59d42c54277d22a7deeeaff30ebffb924f4484adcaa80d67bfbaaed595c3166c56d6d95ac745de781e2ca2589ff331b3fbdcddaac2f2f9d2c9428748e032cc34c2f61bf8c3df9a8b50c7a02f788fe9ca36161eb75e4a28985162d925e628509636af0f7751cd6670ff1a0beab807ebb443c1353601bf0fcfadf20aa056ce4f32a9de69d8a31db0a738c336c687b9e0f5b379353b30a4dd33ca293fb7fa9005c709210175f5e8041d7695f32d20f49ac70859305eb82e91eefe459e16b277046218bbdf30b75ccb25d3e419915582f665d8358b4689b18c5979162a478be89d098e28456f7c4cb66b99673e0b3f319e3df1fddfe16f71dfd458eafcc569bb6848e499e9f1c0fdbae1f56e64599f2d5383f5f493bafccb4a8b8e44ac01b957b9b87a9c3b41e8a64469404ed2d205a83c9ce797e75c7766278b1d1315d523a719a0306aebdbc002b4e27d726fdcff670975754efe90bba8285cb3247006b535c61fd7213f4dd06ae0d80028dbb9becf9f15c5437ec8b1f556dfaacb8d455feef8b98cb76def3c6b78048a14550877916dad236f6dd17476b507ae2b9717f6f7645e64ba4294cd6e15bfd2bc6b4b8821ec3f905c035517b624c1bbfb82b8e778ee1e13db7edaee1b56b63db54639b4437a7d3afbb45b4aaa04d75071226b8e199ffa26c39064780991d1d53d43349173b45e38a3ee774b16e030e22bcbb49033bf52a8616a0e821e18830fa7efce99ead5207293cd79f7b14fbe19e7779fd112d2020ffa6fb8f2ec5e069bb0f3d0e471399b73cc0b7017bcd920d108b2bb29bec568ac8a9c59fa72217af56b439990b4319ac904159252ec12f9105be2e76081d824c72b8e8cf854c81f5979195f6f9ab24701a63f77087c1480162d31cd74a3ba42a50326f41bca8da09537fe74f2a3428f54e666a1d82311c115a3494061034c49559a803e45a1533826142dba858f890644b569a277ef2a99103b32cea84b53dd023a0af54591dba46b44235c62c5f1a579e5c4e8787440c163a7f2e2dd615c9c3116512d10e1b608e9acf6240b8393846cfad69b0319518868572e97a9d25d7c4e9a2c74289eb0561c23512aec09fbcf7e4bbeb51a5c9bf3fab7bf6f1e1850d09919a80fa4acbaf7d17b21467f3de4c75aa37920dc15e705fa8b33971ec9cb181c641c63f8beb3bef16d3de467c138743808826563d8efe3185048dfbdc7e08a002634628644b6ad21d319f06ab029398bfd0a48115e8381713ad68030b81c5d1668c194352ab54102cc05c0d701cf3e0b452c3e9256a40689348a1c23c8b51b8e251e663075d208ad03947c927fbe264801b4dcbddaef7ba40548f01ac0d0c201a6ec9554e5fefc1da956b2d4047ff0bb4e90c3ae45663b42fac12f09c78aab9a46745ec2c162a23ac1ef4d5a5b098d29022258c87fbb058af05799050fd8ca7d09efa07e432a02802739944b714c104dc1f085b01ca4ef7fdde34279f71997e7038818cf0779c5caa1d1bb18b443482f30b08dad085fb9cd2741734b9bed26279d02e0c77c5c126157adf1a14e40dc3f60bc3b7df6270fd80001ae3aa30b523d033a6f73067912758af210228a21bf7cf330812e99cec5140ce358cf93d387803c0016177fc8452f88477ecdf001121a6f8a4a7782db917a35e99ea4f84407bad20e859bd0763020b157f86abeacecaf23b9bf263daca4215363e1edc0461d034961fef62f0cc55020c1b3a6390914df5eb770fd5967cabc707947e4daa0e80d40e70ebe49d5b9c949ad360235855704e1b970cd00e63927544244db39c46e364436ecdbcb478dd93c42946a3d7eab89b83b9aa48c60780c160fa04a5ecbb2f69d6e982b7dc8368dc6f972c3578000c002431d51d6e0493a4fc925fd2890046f259915ff307ef69b8684abf9143810f24ee83d1921554266771e6dce71e3b69b871cd960ede558ccd1eeaee007e7b3e52ca3a13e3f60e6be72c8dc29283fda33d1d3ae444c631d95ac3523b75d1609a08c349b1a2f84cb4354cd7802f27f7d7485ac3f4bf997d72d90f65cbdef1833ff62752db659a99e1b33ffc65bc5511d051ab14070e45e883c91a3ffd190d37d690c51df222c0dc69e3cd4a028ca1fb4d6c6862ecf0da3d8c8447dbfb4efaf4ecfc82a6f8c37088dbcf365b3de3fd47536ddfdf5014f312a9e6e30f1fc979a79355315ed8984dda73e70a1e3a37dec53429fa495667960d874da3177ebed4593c1ac3ab9d68d38c4485b357f22162f91b00b82fe4be099f44dfe8348e075b838ffea33289e79a7b0a962c4ef9f8d41f5fc3d075f8ebf90ca0efe0b9b72b50004afa393ffc2ac7b80f74412dcb805da8196d0337d06abbe2f1c85538b05fc97d0bfdc07daa37766e7ad9f5fd39bf1130cd9566e8abead274d7a96278e7e36485541e0b835cecc7b43008d83e635b161a2aac40ec9b892e05c92e218998571edb07f6591fef6c61768280cae5a334cb69f6c3679037d3f93ecff87ce7a108a8edfb1a5fbdace84b559c52e97a77f53fc354f09fca32c68d19aa71b3674fa4cea64635b8c2d883115732aedeaca0a2576db12dc476ada5cbbc2d2e22b61dcf3fe7caf763be2a0a81f54aa3e109bdea2fc07126e71c599511cf3103a4890e86c2b793ffebbf892c9677029d82495c43ed7b9c5716a0c49b511395f8ee8e405aee543653e882de98abe55112697432aeb9aefb659261d81ad1a3193e7f5f357a876de4e3fedd72d54d01512859dca121dcf9fd02a94bfba8b50a69d2d4834d10f81b94992737d955acb58734a0da2969d9d5857679b57e6369ed0e0a09c2c7be2d1408068b22eb96afaf1681a5cd7ea070bf32c56663a1898e8649ad2f97af1487c4e91700fcefb2fb87866ca888530c1f339df60630b82f84797db7d7cc72795c384c3b3b18592d5fdeb3e6410a7fda1f00715d238737b28398a76bc52b4eed513a99344ddb01458ba217b95f4207e8ace445688caa3c5b399be8a1b3f969a46890921afba6b8609232947c64fe14cb977870876f05c36b463222e787ab7458a4470b056bafe92420b3374be09ee5df89b9e02aaf089402186239bc55ba0b817362354bccb6cf84ca4fadeb0c87eac023d7e0f35abd5447bf26cc87e44ac3bd7f5f6958a4626bcdcabd068bb52a5b8c98c06059184dcb258333f884cd298f1815dccf08402e2bb203056f76f23fa82608b28357145f013215de7b2b37c6eced3ba578f0761a96d22e7139f942a4ff6a452ae16cfd5da726906aa0c8a4606ecb6f3b7ae7b7c465d0e04ee22c7382828c30e6b4467a7bee5c84c5628b28fea77d213555416d5e91f34232019b47bd02ee10cc7876465c1dbeb87ef8b058e9250f71eb9dfbccde7d75c68ca6cfb0147890b76cc272bb56c0a2b7b5529d24f6e64615220659dffa505513d0188930ac5a33fca59c55d9e35623321c4dd6d7298f268d1f4e1810e925bdcf27c62f34ed298ef6c048d4fa40e6de9391c3f6fd78a0820c26ce70a52ac3fb98e3271f92edc8c6f4dbeba40dca3cc26cf857fcd8587f6bfddeb4097c469cab66dcf458f00b648231b5a5a05ade2f626d36d9a35d67dd110d823d87b16b6c43c3c49359af90109fceb8129d1741904fd2052d209a980e109434cab38540814bd79f25a02a4218dcd70ce93033f26d7c75dec7e8c4fea1d0efbbef472ef760cf1508a145f58f6e405e26f99bfdd50b1953f75f98dccc571f0c4f29afbca46b34625976f6d692a1cac4368971a3b0d9180b9dbd9d6b6e7251fbd5a2048b0ed3f11ba18049f8b7cb193a258f88de45f48825d3489ad6c0e84738fb74440a92b644a1846b3c7659131811e14af453cb803f7fd1e32f92a93b638483117868b7e86ca43d4d4889a84e7b16d4d710e75843de23705fefcf5b8fe8bc210421a0a00227dbe1446591208bdff0205ffaea15f74cf337b7fcd8763a212fe6ec0e124ece9c10e333f957f399ef483a7e3a342ecc6e73e7a79438f9fd0d1967c9fe28b75ff6defc23687e78d84ce23d210ddc9669f04dc1a418b8ad81ab2a88f55c67910b832b1c80adbcecee259a97def0dfec9e6d93ad7d1a68de21a8ad2b000f4721750f29726e15721350dcdca0547ce8156c126b5ba7a1b6fea05d3385999aadc39072cf334e409f01df7205215b31f489c164ec467f67943c67b36abedfc799bf3b032f0dc9a5a91b22a38fd4c22df7ff7c21936f218a10a71fab649f5d4243309d0393f423a2deee3248654efe940cbad1fe7f086f752ee824e9e6f226283053b5e33387d5b892875455cda0984e9dbd2368f5580022274477612c92138fbe6e81b37998750f49e52736d8e03b2ec1186badd973db16110639fedb2bff88d15866cc34be3f1108","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
