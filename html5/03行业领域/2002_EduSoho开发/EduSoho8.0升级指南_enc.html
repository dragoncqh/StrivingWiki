<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26e31de33fe5370ccdd67758d653ecc39439dc3a004d7ffe9a4ee7125c7cdaf4cfbecc065e120cb4f36e7739831ca3416065b502bf25cc979c1519d850b59bb8b41d8f952b1efe2588505626f8e5ccb247049edad6b8f7fed3c0df453e62366f9e30cff0052d83abdc9cf823cc6f63d07b414286cbf200d6fad098ce79726e80c6d517ccd158fdc75e91eb8e7c4dd5254138c83cac5ada520de3994e85e2f7c96df1432950e06d62ea7524ed33a73304c663f55098ac34c3d386e97a435bf88d5a79b7257d867257c493385a81d118c33c18d3b01606d00c0d07dff69eb65c99049463546466e9d98be6118c86dfa9098d2bf5e914d48442c49f81af118e74db8d9f2e8fba093e3474fda8c403ed217e9a6f9d6dde310d462be7f31f579389f11d0dbf2984981405348e55dde9715f5c416009c6a877d7191633ff5212c9bb73b83b88d9e096616cfb3b8dc46b3fc2b91f23d3085283576a894255a9bf50ac87f55645d8f86dcf72c480625dbbd6adb41a139ca71326bb3c2913e60a213e4b66874b46014149c6b6e254217f2fa8e1b0e06dfe6347fe3fd3f770bb6b3e0906b10506eb34345709d4848b8a4a286e0ddcb3d8b389f65c9c9c7fd53381f882ee74aa930f05436be98f9bcdf797b0dd846ce6cf89f335c6744631ea1b7d67605acc3cc6c9946cce84393ec183b6a40329b4a0f92d341d53ec6cdbdfbdc5424f09af622e88fdac78f9f6723cddaa9ac51f6fc5006fba625c12428bc086f0a58950ce72a3a90b29e7fb5da6760af80bb43979fe7578214ed9575771661cded99f8f6e17ff297e18aacbf3bbf62f38c5b0f3f0094eaf687509f86356efbb0e0531f2bdd1de6cd82f10be33afa8de5a765ef8d2003f0a0b8ea6ad181eae06eba654a576b471505944927a11fbe3a62e621383bc9065d2452bec3d77776fa6f13a61fcbbddabf2fa89f8d7dc562cacaff732fcd48c0eaace1a23ae1d7731a482771865b842d66ea3fc90919a51502f64310fed44a1ec66c80db5f749117b1078f500d4bc47a0b367b2d36a1ba1165561e4602a12d73b8cce565c3b8ee30094a124d3f9bf6858cd147b9f9ec26858124f7b2fc84cb19d539eef26a5cb6cd39958e4dda830394584ab87d22150654169205d597705eaa0a46bf89c3c28aec03b5f63fd09d28afecd80bfd8231aa556708718afa5cc5dea0febd2cdc46bdd51fc985ee6400714bf53ee321d4d0a06544a3e289b0086992b5aa6953ebc1720ff6d0f05082f22d294fcb29e61156c2463d1f2c05dbcd8d1920d1b1d5a78fde9ef635423c12e555eaaee6b60506570910acf3cd307122bdb799e001b74b3b63117353c4a0952e3d7dde56d64b63342f41a99b236c7e1c1742e068460ae94c0b387d8c5cdb9682857905fd99aa63525e2efe21441eec04884f88d3ad7c782d518a1e0744f7a95b2df37786fa14911d12405dc82034566b72c7fc199e983d0277b18d93017526aa83505db8cb33deb6f4379efc23638fab36222fada83e198bade116047a6f1713d19388e80cdc02dbec3be760aac26a067ef935976e721f230fe62612404cf8e131fd7adff144501647d4b3325d3b360001eaeb53e059a1675a86a9bd79cfa2a9870081ca160c3a7981a88baf540d5ff718cc055a54ddd9a61aa96b5311ebd522f5712e4d448502e6100922d6ba71652517217907346161ee56ccc0dafd2a68a808972f883a23b69b68d05d9ab751f406833050aa737517c91d41c0518c0eacc1a389538c523b787dda75c14513731f07f6f110d9dcc38bbf2fca5a12fb7397f0a47d4a61896161c2c165abf17648086d15ae78931b98935d875ac8150b89452e35f44d0591283527838933bd86faa69b57e0652f4ca375a5b6524f2e8c03b7a5f6e396fc5fbe97625a6980f32cee86b18a8b23a8ea9aad2fce388b9b44161ec33fdef79cee96be6cfb090771b20ff95aea2f15e44f03335f6a8a2c19e48f9fb5d7271b0be9f23fa1f2a2a0456a7b7dc45b4d0e17d8df1f4cc3cabbec350a66fcd8e603990e98634cedd94a73b76fee5000958021ba7ab1e7487604f3df45af48cc13707c2976ea2a570453ef13341021547af19740c4e9f33375782c8d2c8953c38ae71d89ceb990e5bfe72f632829dfb936a499f14ef73f9853658172373876686183358e0adb2203d62c78e8f2e9efd79f47266ed23a1b6e6328662f9ed6f51f2842d31d857b1b44c02312ba818377b02df3cb37fe490e318e0993c3cb8a7b647fcc05acb8539bd8ce216a0c5e0ce156f660044bcdd38e1b4ae75ded6925b07962a9a113b3e07c06cdc08a8d0d885e5245d3e6eb7043f3d88fa0b23dde09b684c294e9102f9f58f04c7f706b78190968e3d7d70406ef0e76ae39bcbfb4903612d16e06ea60c5afdc5e89a73703cfa17153c43d57c5d36244666863682076d3ccfaa83b6bddc6e01c7b35bbd9c2e5278c15812992d53514cb7e4c6b87e4073e588a59c0d1bcbcc19d1aebf1651ffa3120eb795f1600d6e03b2b422ce9a0e541a76f00f444c56d6ec3ddc00b2cc618c089bc48b7cf05d6accebd6a992b47d9fae1be5394732b724b574425f1abcba44176d12a94184639679e54e2fd7331098f77e2e46eb3d25e1d2be6ede882fd31253dce5d53feddf71cac3654defb68771b91c09c3d76e63d8505af10a9f3ef2758be5df3e8801b2f4f41a3f9b3045fd566730c5ce343f9ece55c452f07804b01d79a2d696ba20d18ec094fa1a9df2e2e5b14b529c0c1b0ce866ade45d5d400ebda0b2acad4482fbc710e4136b306e92d6ee5a688138af33a6d8b6c3d2e7152c8b1a6da39a4e2cf29e1b38187743d9037b9971ee909a49f183b01422c6eed64c2408f98087e1524150cbf33834b94eadf5fcda201a3693b9778610beca15ea6bb97ffda14b87bcc0800665dfa983b8c6188cc0931480d52f39b6a5ee84b52afcfa7690556c33e3bd2843540d95df5be69fb5d078eaa8661f35e95bd68480112dcd1e23718a2eba9b026acdc09777d06d1c4b24451e19454ad2fe3276042c399e71393e43f9c747fa4bf6796380abeb17f4c4013ec4453f38c3f5289c83cf2359c6619ed2d62a9aa2935a78696bab3544a8a112aa9491ba460a10da9d6235b904caea8307b312fde3b74f19520ee80942504139c547573eedf3f3da718b594a612cffdda7c554baa6cde044acf321e536453143a09b49127951abb243582eb73eef93231481a4a12451576b5dec78afaa687b1d8bb260b468cceb31ae2eecf849fb2f1859cd57ab58fa552291f9c695776456b5b5e534eb1fbe8e3dffc56a24428777cbeed5373d230c67ad35d4db8fa606ff7d5200163a3bb42b75dbab30bb141d32520c4576ffd9ca7cda92cd8883f882497e030ae6c4b43416208be470e03b4619b285377c9acd658c6f73a6067c899d45b568154167f83e3fd133952c18d17d8885815d59225d654e099eef3e141934ad3ed6e14c3e84f4403dd82c9ba258747eff249f86c66e8db7feac0c2a319db4223c690f00820f43598c73b617d641fed7598e32f39b443271d1db8cf115fe9ba607ee87c4ca7c9c96f5bcbeb46acd74c43df853cc485dfeef3654e7c260d2ed5dee919e3212f9a4ea213dfac080061787ca356012dbb188cb6bccd2d035e65b679631b44b5872e01e5b06517de1efe2dd7a88f578923ac4a4b0f23952291241e93d816b4b74d6086ef7135ba42629280f12e9dd44da35d489bfd47c1aae4dbf6f3aed080ce4a24a9d50a47f215ad07c5ff88fdc3078f50196829bb8ed56246bbeab6319d5b9b1e4906f0962237e72b54face4585c22976684f2055266fafa0cc083eb7fca090ec9739bab6c5488ade746ff2246d426d5bc8219b16dd3693c611ca711dbfe3ad3b970677b28c7df9bf61897428cfd8e70fd01eebb661e4306f15d44747a9c79bd6834b8914069e71f1f6fd2aec7716f6d6134591cca9cf562c9e9bcd32894218823566ad7748fb4c2cf26a134bb0fa4d06e0643fe408aeac4a41fed75c067a248d83d035e1c0e9e4d8784f422577cefb8ffafc5e37d558af0045428012a4b462a2b44507615efe0f5fefdeb3da3b18f5ca8fe1cb8ba64f36b899e45a4b79d09016b2429b3e94ee02daf2d06ab29da43d21f78f60c0b28d08dd6b3d7bc95dcebfa06317c575e4e3407839df44ed94feac17eea05f24a52a4cbe02038a110b55f2404f2a72829f406c5f5f135b0ca2c63e7d2c8dc6028f16d24acd3b40be317eac064f859671d37b928eef99cffffdede1c97de48b3bb24175706994b541d23013600a5c27cfa4845435c40b14c6e2abb3a6066d3102a28689268a5a5e73a2ada4eb541d4da88b0ca95749ba9ffe83ce7ce912ab0eef0df2e2a7dc94668146016e8f1367fb1c20831313612c0b408c492e02371aa1ef4cda6ee82ddedf42d4d548a2938bb38f4d28bc2d61c100a2a16251b8f0a0c7dd2997238cbcd0a5810f027ea8d1cefa7374bcf2d56ed75908a489cf5e61b6e0b5a74e9ab2304cbcd32201a98f87a43a7166668059e86b83b914aa39c9caba75affd05b022434795eccc6e4c1935075c233235c61d0d0e353354350a380ad7804340a5b6c8a456a0bf1f57bda461433ca21f76ddacec09e67887093c704134aaeb6f469c9cf676ee250bed51e9056056e9236f3e85d33a56dfe9aa21a5344927ba2adf79d55df3c97a7de7bc0a25e24b33a517d4c29e310bec7762d48bcd56af28bb939b7502bbb18e0a31589f468a4de6f23d60622e4352d791b40d7554332041f25d57b12b357d186f11fa3e7d6c6699a5422f13befc67ece72056f58f0b8beb5920bde540277ec303f6768ce85d0b2de42cf6b520c0f76f1324a1d26507a3352bad2450a1548f93e1b775460d1b1ef4c741682b470eb902021d90571c2cf72df9f667de8cc575e210ff22508ff871953faca2d36ff01f240a158393f094f5408661cd8e38d5770663813979bd62956b6361cd5609ef9bbd5df751fae7ff764d25648bfddfce459472d88c7ab848f16350031ba19422275e404aa6c15958899705f4d71d4af17ea3b52aa243eaf9708e53051d67ea2da4d8df5139a1b446f58c1145e60f972d613a60fbb4bb2617e5ebe5ed9ab2fd73b44be69d82a37cd4297b907a3ce5f2c3ea77c342b4cfec2c6b438fcf1af50082f26c56b082e7d70b1185738e861f32fd83a2f90cf231d7800d99cb3d3388d9bf006017dba296371a8144c44570a9efc7100baf11edddb6f47804e0bbc6d047c7c8cc1aef34b7f9a57a4bd57dbb95eafbb75d59eadc0f1cfe7df2c6a96d2f16b56bb80edf025604b3bef14109c1cd7c887c519ed0aa3a5f406ea937c5243d00cfdbb219244f8319be721cc0971a9efa877d768755e7d532ba02f998644748a226400b67987f6598f018ffce86947abc24c817be9b0c0eb6c2a1418daf7c3d0dbe14f13e9f0a4ee14ff7efb4c778d29d536d16ae488d3b146c62aded886453b8a4038f8963a20cb1fda9e87f6c6b7c88494fc688c771052f9ca59e88127a54a34853b1328fdfa5ae9a04a8799c2d454473f4ccc0079bdabdaa2230420c71e947c921980088aaf8e9a5375c9ce496f3587eba21952ca57c8a2fdffa8bf7628d7a5af4340ba4cb0da24835cda7d85cf2365f9bf1a8cf5efcb347c63808c358c87b4c97493e72832d94899268ef557b8ddc4375cc28db1af3b88e9f7ed1f4dc553498e4b97709ff559acd4b378b79059548b23a784aa1e580417e0c6d7d81b2a3e3596dc0f142aeb1a3c374d5136ab9f0e43c8517f387e005187f3edf875df027e92b29f207eacb3db8ffe09827b787e5ef13a21257f33a413f9b9eaaa295d562060c2582eb17cb951625490b5af963e6f3c9752074915e35447e953ebea3752f33f08cba4694ca7109ef4184457b59a38a7f8e40db2673afc61a64a61086643a36493ae745341268883be4f7fc6c1c5ad3f71a4cc99d11e6604b336c1aa29165f7b4824032a8b83a7c11694dda9e5dcc0f698693bd4e45f5f6012eb64532935374f0c1252bd4875b10d499d4f80f6b17125baa2481759d1b86b2fbe60a05f0bf6d86d1d4a1c41963a9b2e1e4a0795ecd1434b37cd461fa7ab74ea3f261725af1c58508bad878ffedeb00280b6d114cbe2a54883a3962d2bd812a2c0c1224b5db1480051ac978f6b7b0ead5371872a3fd8d43ab65a27811b2bd447c442b59307b0a42710e27ab01f3be5700cbc598bcb63225dac659fa01451b8cb0ee13e52b0477269ee734046a743284da0cf2678c3b103de7c1f4cedba211d7e7a26d3b5dffdf778259e1274aabd4a63b1f35f30f9b9da25fe79d617d31b86aea4c4c4e4a6eaf23ce3531446019bce88e64966e3a6af7393d326124cc635c4cd9092e399c14f408f99a9905eccdd29632473814c3259c92acb93d62baef0d5579dd326b5590dd1f35754cce8bdfc0caa124b5fb4cd08bdcc8a8a58a004428ecdd10ab1a65beb17a0c81af5b3e35a79b5cfa41935f1946242616754b5e2649fa8bfe8e1284c1d1d04d58bf6558fe9dea2b9ba06d08ec52954c41eb2c972269300201336aefef9427e3415157e007b5c324d24ff9170e1c427c21b5da567cf1d8222a402fc6607421673771250dbdd51af96cd00a9bde46add6c4be4c9a89a5283ae203e57b0a9eea572abaffe8653def7674e00752647a968a0d3c0a7231deb7597fb6ad8d80340651664f6c367d1b7d2991386fa9312f260e0c5cbfaee6a05fe7be9c9b16c3d7338b42a2181bf47876a072c7f897b392e421b3416ba9a063cf02b9233f7ad99917450e8a85a58f5da5fa2d6117202a85de1b91d40d3249af28865c822e5fe9a2da4101628b19f1a73ce6d2952b992be3f9d4c4746d6e46a104f48fe4e86945bb3bd4301781d04a519362820dfee8b05bf3b79b154ebae7ee67c41f2d88d65f8fe984e360e68e8805d7832de4446016d6413ea7324626348a5e8b67e870353f1c9dc3d717cb532afc5441c510fe85c1ddf160a19a7d0557cacbd76a5866b37a7b6ed405cd41f6f855826405b872b6e024c79be81f91b0760a242e2f408506ab539717d8714c0b11593c3bbf4ae5440f7147086e47b115b23a0f2c1a880a7f737c2282677bb52474ad9a01c339c634f829ca013f3b54dcb032ab3a4baa8e0964abf8306b40ea7a7060e582074daa52d1fa640ba97578c9e28ce0ccf3ce5fb47c64dd2d3740260e86b1786b9de9e35fd3a4ef81bf3de57e5d600d008f4b67fe29afca6bd9bc97b919a291fcd30ca8ecf757395c9dcfa5abb9c3b43a11b5c20d68f974e0902b71ac872107ec1822470933a7568dc5851765fa3fd642ab916cea4349a0dafbde970b80816e6dc28344a6152f02e42156c02ccd8e8437a9cb12c825b20a62ab8672147f01830109acc5dd1cde0e0fa348b79f74f853506953a40151fa35531152cbde205642138b38f74948da5572ee5e363d2d9c81c44242504f50afa6302d00dae12d1ae3760f5b25c6ff43efdba71695b6106f996cfa406c136c9627bafdd3203592685c597e8871ed127fc26838fe6836833bc69acfaea519a2b3446c633a098ffdeda3e6a981ade28ef1c1f0e3ecad873c73aea6dd9a2228b20bd67398d42406f4706187a0543e3dd5e3036ecf605e753502d1c7bc364131c47c2a051e9a3f37a5b3c7447d7646bc3734aa88721a1560eae4ff70138bc6809d0c2bdb8439bed5752b1adcc7de510ce73f1381af84e42b5f42bb113b3788ecca054086ef31076f03c345db84212f9d2f661b0c274ada91f9e7b1055ec20f442eb059ada6cb516da1d0baf55c1ae1053564f29009c1bcad9495c7934e8f8c97332e4cfa2fa4820eba90b31b63924525b4517ad0331cfed2a7b75e5079a9b9295a8cb24a6672dd0f61e37294704e8b91c23ab7e0725ebbf759eddca228cf49fea9feed1530c093139955363e2376662785da44ef1c934a99e5c3a5124bb44f51cb9e166b74d9b3df425a68559dbf78fd77f00613bfa01ad2913dcc4f3b0b80d987601277b8bbe05903366f1ca001edafc19038967faf269a72a4954c9403fe9a6657334a1d9a429f748e0d24727bb801dc3cf048426563eef4de5c98e488f8c3e379eed63cd701c366ffe98b74e057cb16f0f84e9adfd2eb038330d0a14a8a3d17951791818238d636cabb1b3de7c26021cbae40b2b2ef40ad2d5cf97dce4a6a123b1e494cc9f49254b30f291904b3e5bd211801990f579ab7874faca34602116cdb1a12cc597f4d452f322d634f72bbb525e34a1e36eb83c6200aa7c31d0361270d2296abf24b2c83e03a3da9927dc495702eac801e094675482b9b11e01b0e914a5d3ffd590324f6fb930a92efe2612bc9aea46b3a5321cc01c43d7da0c37bc2799f46016b8d0a675e4f68b4e00bb19e38ba0e610c2a0b9b2b672f5e7d96f7e55ae668030b00f25118a8d835ea88d1d80b5eb3f9709bfc9ecf8cf836793a0690d1f10ccbd312b683888bf48f2662423bb7a98ca721aefed0dfd3b2ddd148c045edd9040b882c83454f434dd961dfada863172d1ce703a5ff79c0c734018164f10b4992a4d6be66e5c2061a60158a6582811b6f5529b4362811951122fdf68fb95e2ee337a7fc166c6f2de3b1644f42284bee7f18d3b7f7d1364b222c97f7ec41423d7eea88cecaf5f2bcf464abb3552bd7caae42d1be8b2fbe9a1b49e7dd9b02954d262a92238add5cebe52a2ba10d04d314113f7b5a4b21ed0e8f61c0378ba84dd1bc1c1d42e1d172f6eeb39cef7761c779faf4e5705036f6b1873d8454a99b28b03b6d47e41f950607b4fd242f41c34ad7e3822190a1e5fa53da213ad620d0cc4e2e0d255088ce52f826dacbb25ffa6766884bad220b135587939e5d419db21487744f07f73ea45d93427b6274fb62891d3f628793b35b91b3f79b7597b954fe52edac5732794ee223bd42fb0c1ee5af50674b445c05e5334cc8ec44415b0f33bb9e2e1a800815c555159ac28e2c2541dc65b617d68af7008e83493e894d6fdf599db2fec16ac8cc61eb191af113da4ee26a6607bca92c34035c26f61533b6bc49c321758047e7e2e11bee0d68187915327711e8c91fb66f05887523bd2f53fa4d95439bac6736a8c6d5990070fa8b05685b68fd3af15c603a33bacc69854c2b6b9cd81b2bac80f2d773c92beee7bee914e20b46cc3d7e5386c59bf8b73eddc1f3c64f074eecf0aa7775369011a138eb72c72e706e083a3cd70e29e86ecf12300671a410d83b399a63dff416b05dca6030482783aaa52ce701862090176d1037be2df1c926efe6fb52824f77fb7dfb17ee4eea628252ed51bf7ebd04b0a753024c7255cf072e738477b088229c6219f1aeaf431f5b3c732e4d4e8b35e77e8dfc8893ef07c2a5075eee4da535780cad3faacd2665e2852aed48bd1b91a20aa9aedc6a7e287a669f5a8e5bc8ffa248e26e30f20c5f1a5fd81b588d2c22e2d5541573c1164ea2db65ca53fedd239f8df56ecd589a70d021953173090630a9ce9d383e682c9530a5eadaafcd5fe374b2911dcecaacfa5ee73abbde079474914ae5b92ecfd79c08418f3fc4d4ebb5adbec8929035ff60b8e33085e8130c6239472b4b290ae33a9f24d7a83efb42af826aa570c57eea5410acaa20172027c95807bc618fe6de88e406d5b54663315038e716247d31ff4cae8c96bc5319ee0a080320f9c0345938e84ede74d278c99b993c6ce9fc63133c30030a571c14f518c2eb557fe38c5e4884890725de0ea4e55074ed2c1eb10cba385e72b3b650dd708530ea83d621b1a14a7c6b669f5add2544f8b7b901df173404d3a42327806c8714982f09da874eccbd470905f1ecbf587a2c7955d5c73d81df563826ff0cbf5e7131647bb32eaa20e28555819219db3e0762e42b717c33f79eb6ef401a8cbe92f66c71f6f646d1ce8138c4faaa92dc94c9498478773bc706ecc9c0be742ccdc096bb2fb7af9d224235b727e901bcd459fd334d0ab187b74383270c6111c2ccb97c27ca92f3542463b2e12787a6d0a3ae1c85c9e59f2fd360ba40487bef9352de5dd57744f4ec948da8113b6a4d1db468f9f0e024510071ea60afe3df3cf9b56503c2a70e8b73774ac2c497a6c05d44abf1ac080da6ac1c5020625ce468dc045b8d9e8ae2128c6d5bb340cb897c8dcbeac6614d7955f3c9902286f6d66d1613635b1eaa6addca4427bea66fffdabadd622e1457b48468ab0d1994d16b6816ba507964cd076a19db2f86bb6891be1ebf8de94437ae61099cd9397ddc3ff5425392429b0b9eaf9f0cd922dc62e6d01cc268264cdcb9274d414277e25e898576b35fddec75a4c95d4a6d4fcff9e585e029a5d461c85d2fc6fb424fa008be467197cdaf0f7b2dd35a55dfcf30f0198da57a07de584920a6e752e0b99fad1d523af20f91b8b5d1f8e5bdb9d89aa9125c8e5bebbee3f884146ae662d74aafe3d2060659745b384760ad6ba9789e7e7e19d75044c767ba7f484b60ad9b3f48491cc34f811bc38c8d6945485ddcfa21302d7f9644ccbecd5c074eea8bff7e1cbc482807a756983ddad351bf764f5aea674aa372c753498fc638db329a8dd191da97b5d6265955f1dc6ee10625161aa8788da950541ae3244fb013acd2897a5958ad2e7bad78a7a7dd34ef311fde2f6a71921e06dffd4a73bc908eeb837587a59a9e7ee0b14c264faa7dd81fc6406b5d3088c515338c90bd64f8c182c08bc73125d32df150cca1b8a831b2b6891585a7f8425991f5f0365559c6c273a80a78321c21c0052a2696be9e700fa04ed5594f28ea53b0faa6afd313ff4eb0c5cf263d80b9316d1488186d66ae1b6448e9cc8ed97ff2fad173fe7e12f8b6094ed45e163c81d113e2eb8c07a519da2be78bf16f529bbb8549772520a2b46a877ece677000c96fc0cbeeebc35d0a95bbfb86e8d8bb816b1c6f1c04f4d586eabb7a7cffe389a539b78775036ead100d95c0afef96bef93c3bbe90dc2a0f0b0c7588c3eb9c35eb5cae9d81082c775896c882351be957df5cd5d53baf1d5cd5ea7a8b27b8c3c732aa8de847d522b17ce6eef5bc30feca43ee48550302ab434ad23019a4100aecb8270c173feccb1327e223d47808230d2c4686475386170f8b9d744816beed5386b9274191a16f8f7b1ec467622547976afd1b5593d3c141af99edcff624a1568ef65e386a9b5c87eef06b4b3c34ecc94bf2f2728e38fd98acb0c8525f61d6a13043661a57a390c10cce493a1ba9018daf024182a297029d9b96a5a3b37159840cd50e50a5218cebe7a26d6914c14de9fe6f3f4ff01ca9800c29fc3f2ef41d1498ef50be7c3e936cd36685b4c5ddba0e5e596b44e68266a84a3fea4fc0240ccd4dbb8726401ddf4846641c8e70e3c1f2555e5a6d16635d4120824e10f21f9eeacfb17b86292aef0396cc09707ca4254aa570275ed2e9fe5fc7589c5182e3a0b709ceb4ccc3b9f86595fdb157c70c28b1dfdb00ef80ebbc14090fa00089349f63a57eaa301a153dd37ad8d2574cbf2dfbeb48ac596d556caaa134a54c020b51404d24d1a6d8a28055a5f9f322291a7aef567a511adaf7ab23ae6335026077d70a358ca9eca87efea331b50c05d7ae28a4a568df026641a1c986c4a282cf01e0dbab06b7cf557ee1a9422a93d2f038215d6f5c44a65c3779dcb9aa98320defd2f9925023951487e11e757a75dcf361abdb4e2aa8c0935d88af9ec4f32c618d51da6afaf56830b96b7fffffbdd801d4eaa2021f3c0574931d0203db519009201d40704a79541091470215e61388c48cf20b110123b687d9aa3b93b27733339a1f9ccb1b5307906841096a7d859aaed9873538c6628a80bb17077baab6b0eccacfcff77a5ad11e41feeb73ec6c6a945e3611e2aadf360909da873dbd32ca525aa1a8d75d9e2e0c8a3fe3dd3527b2af39e6a744cd562c09d09c795ef6df1e12c754112cac1ca892ce29fbe21e518f26f9eca4025749b7ac16dc5043f65f1b4075a124ec7134ec6fed4023b10ccf4ec6a52a2bf536faf0a0ede3cf0753774fc27e9f2f0bf7c5fdb3d5ac9e205c527e12ed3a756dbc038371f160eeec747e57ae560b539a03a45c8b4a48baa930e0345c2d4a51cf25fd8d1e910a214a41ae638ce6b2ae2102b20b1d39b4d7b17399cbdd6b1ec3e320c17815b1a574dc42136cccc8672d62b00abdbdebcb6ed87173a0ef7fb7bcbf8943e296b1a119167cf6e9376791527ea4d5cea937e99436bbd428109e2fe301cb259a48e33f4ab211aeaef4b2ed720b975fcca7ecf32549643f96c34c9596c57ec43f57c0ee38505ec3e5114df6c570bcce910bd54e324de9bbf4fa83f757c4006c3a342e60a84f9886dd428f9a473dfc525c349b8cbb61f8e551a9aea1f4613073538ad49c9d0c4f16edfac991d7cd45e14d3e21290bf275f59de7a080a5d2b29976ce8f65a0d49ea9d73a61cb76a9e7cded4dcc73f64299c9752f91375492fe0d9884babca35d483e934c10738205b99400683bcddab7572a4c50986fd5c40ae4062ad693e987f1987d5a69f0312d1785601a656300958930ea4cf1f46b0876a4209708228c554e5b30933b9696dac6b887525b65a4498835a6402370458966cda01b161bed5a8128610c60517fa04272ef84ddbe8816a802b7919be8704417444972a776f0c2116dfc7475f93e74e0bc4812dce3ba94829ec7cf42aea25653a125377e4b140b692fd72199de3559da41c8ed1e57d069fd11b03ad54be99ec88920f1c4a22ddcc59c3e359b5366bf152cc84574d43bbf3aaf3517b41dd8388242305b1d2ce73ae8776dbebbbbb00e66a7bf59dd3ed08b434808cc663c0fd67dcc243b8c45d3212c8cfcb429114d5c796f8457f7821ed9a3ee23cac3120f946611e420ae79908f1fe96987ef4c4c8846e34505732519f20fcfde5d840ab5f4986a3524cd13869bc5c3d5576719a9851e8cd90ea9cb9049d302c12f8fbf33f16747a13d05b889be23c9458ea615ea64dc405792f970385d5c85b04e55045bd53234434978c8bb588fffd7a4b96a826f4bf7760a8846a2f922a74936571e7ba099ac6414e11d17bcde30794c6a4f1da18410d45afdb27e7d9465532d1e37959c59e6fba2403fbe298fe9adb468ec08d3436253016cf5069ab391260440d8714d9507a6fcf004d4fde42584a91eafc00e7668c1534e541254de26dbb2f782d4009445c8488f2a01c3c41bea7cbd52beda49872f7bb4719375f614c446b7b9c4c776149fd799ec166d1823b0120ebec6f4ec22c710d19bb0b2bf072d9e863a1620b9d826bfa2c169272508cc52853e010341a927b565e723f5bca2e24f68263a2931767734db7b93e2453b2107c5617458efec85b6e8abeea8578ac2e5d88f32032aea1452d2fc6069dca84e3679d979547365cc986070b2504d0019fed5c79485711b3fe30f4541c2c97ab0b879d5e3ab24346afacfea404582a693003d69b94a3dc0ddc1a28f8b8b99133a92ce0341b6bffe3db46face33be133c0d64c1776257b86201d198f6fef63f5f58a9af9a2ceb8fd90310928ab03801d955a0ca5a6891b9def8988bf799532cad6c5cf950309bafdba4dd6f217c94db6e8af5d9d227cb6cfa04908b089246e8e0a93aa2a35fb55cd6b574ea010d0db4f94ee32b42bac6c27b6f82ff950fa5200f4ee9423f89279e36b361d4877bf57317d8962bcef8cec9ce254714d0b710c8526c0e0fbff3a522cab1f3beae18225fff1b8374c8f0955e57e20a7ffd20ae512e4e9cc0c536f3dd818d340ded52a9f487225d64d3328e428e8d8d5e0a96e09d466b5c0d09d424d90ecbebd00f544e6096e9192c69e603a67588d30c99be8a2f1d5a2c443b6688939e7e2f1f63150c0d2a85af32e6896981d3268b301065b7280d0ca9c63d85a5bd94ddc44ef501958e77ad1d1822f9ac2b9732fc5d553790e4f34ddc4f4934035c3baa24d1317b93d4a890193131f6f58839aad7706e2f873c108d3c9b03b1140e6aab89b89332d216c26f2894aca534788f10a43deebafcdc308e68b2e58013aad4d75b03bdeef61c9d980778cac8fe5f02ef9e33983f888f204ba466043907c39b74ecffac754402d9482ca7e2c87198238e53c6c6cca34dba7a38750dc2e765e155997acb87c9e8c86f660053cd3bf9fdeb01c8d3666949736c3bfde24a7e15d6c4d6dc6c3cf03d8e1bd590d87359dc128465729595893fc9c8c96fc9b3be84ff21f23c9980ef514593597e4069971593e98ea40e1f7faa21147ee71d9cd74167694a70015fea1ab17db61c2fdd3c6fb1b59d2a1a02","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
