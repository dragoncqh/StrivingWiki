<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f2fa63fc8245711048a5c3cea8367df696b1e36e7d574763058214774e998028d9d3441bd0e463287ebe514a5d50c68701850684d9d1b3c1501cf1fa40a92f7fcafb99ddd3b28fae3a94f610b28a9269fb185562accce1b0df198b7c6c7517a6cc67b4fc3213e5148a0dd69e74a9f6865fbac187dd69a8bc2d999f3ea8591190f8b3fafbe9dc5405ca08117030201b8ed5c71fdb39941214d5081f034b0443813c93aca0218e904c14872525d1d6638a204b9232fcbf7daf854c54922efb5375f5852b98f4a4437512860570fb5254294b1598e1196ed445658081c902c43d2fe4e662b4faf62331d60aba12602398b2a626f93e3dfc11914be7e5fbccacb729a2ad5f2ab52cd11c4101b3fa78e4e4886c32c9238313529dbe01b5dc8307648700f600da7cac2dfe79f7df4247cdcfb0d711ffa58a816073e4669ec24062e546e868814c721716656d3851212a4cbf9e0dfaed31b9aa2459a209f132479db7afcc78b85e83de9797d11d3af31fff266b65c6c64da13cf137a18aecfe08e16c687e10fab7fe4bea66dbc767eeac4cc6ff723f8d69a641e80bab9ff3e2a33e1507031bd170e76e794d7b8502fcc7eccf56c17c7c9a0c03348902990089b9e64a54787a867d9def803f6285f5196890490ce71691fcc454901a2d72f0914c8c4f7c8efae0fede6f056c160ae6c5911bbff40f2e0d0d840064ebcc601e2ab4295caf175872d5b7cb6cbb88ea26e1f1f4694ea2beda81930f8e510f73fabbb8360a8c28c7bbd7c017219d7a2c6728afdf35e66f1a2f589ecb7f3d9dac2f45359cb773fd8b2ebc25eeff2646e8102fe652f5757494f4addd0c3ffb32a793d5344b1673b66ef813bf7024f55b7cf18a4218e382c992c96aaababd6e747c9ca9ab5a81ba5ad9bcf2b4870beca1aa8c511e2d0a9b459c34d1a582add522b6d3dce97dd01d8573f9593e1b1d6e012108f4f5a79fc5513dc710362f668ff9a0ef4c26478eb29d6e07bec8f77c567fb68405229a906351cbd6990eb9ccfdc715de952349f5990c0390210058648eb4c244839295519558f655c32ad08535f0f1ba5b02dd5cf599a0f6e59896c81fab2fdc9890a6b0a9fc629c0b01ecbf433de8da498c7517ebdac15fa048a54a89ef4e215ea1a2aa3a6f27a3516db995c293b779fe887a3e5f2b6ffdf3c36895b192410ec973ae3a0f370e1cb51040fcaeeb4fd76c9d9d821b9431151e609d723c1ae1309cb5e95dedf69154b4da8432384e4f62984356571bfe26d67b59230174bcb036f2677cf161f9527e28d442cb570613fdf32732fbd1fb887e289ba38fafa616a9c869bf835227cff0a812dd7884a3774c8bd6f43e883d6d00b44a564f16f272c88bcf1fd5a5e485254c931cbd36961f87b68e48f6f30504ff4eaf574aad799e7ed0aea3f8a8c9baee3e1b1a52fcb4dab4160d3f3699bcad532a57e05df6091884c98a0241a5c5faefc189183ff360048c810c8fdf8b9cf873de32c2b4c067ddd916e61e1ebc4e4593728950b4beeecdb41cc99fefde774eaa74dda5fd6e7f4f631e5fb80084a8c229e0a24a209cd8d63d38b9c70e4c651d16d3475fab3e14678d8b6a543f54a25d88b71574048eca1137c3ac1806c8084fe82054d8d575fc904e82a4582dfc6e6bfc491d66e9d8fae870faa264a451bc1b001a4e27c3fb0f9833b8963c28860210ca915fae1a3d119ee7046e87417f78a7b3a9d22bbe00fddc9432e0c6dfb2f8e9d08f77af8237ec5739ba6594b34fa307df38548f5a6a6bcfaaee45aca8ed59bff158175002870e38333a5bec0841c1144297926f095013aa84d44dab0d2c51aa87f3e14d715eb35c6db7761ff3d94585d3a9f015dc60e8475a33aa6905e9f671efe5c2b2867033307e97bea8556f2511a4bf3f2980087e7bdaa6fad51ad94463c0d012e6e3a4121104f1bb808fc56da5f7c88394bb3706725b0136ba69765b3f8b35e8c18c88c047610cfff150ad7dbcbc7c0fa149c1e9d52b78aa081d86d67f47f3cd8232c7562ad305c088d1d02fe93434fea4da4a30d987010ef8a07e52d61741df3a6a113366b3e6d22e8e52bc6ab712388aeff67f7175e1a0dd1603d21356ef05119c1e452b34259424310be187c0e116e30d4ef0a4eaa13d351faa5fd0f62227fcd165507acb576c0b0eed04bae69ea88070c03da604dd58f799998cb517d64a4ed91617960269aa71d87f98c88e707a341932d0b6bcacabdd04686d306357e7df19235a9e7b575815b2cd4ca4cb96826a5c2e16cc8a21858264833d992a9652d8ec7ea712146d5a908e645be443e309f652e7bd12f903565c2060cc8adb3ce711377a32ebafe54ff78222d0d6493e1fe80ad4201ecb0088e8e56c2b9fdf25ff8c70cb418d1daf48e0710f3bf4706be75b176c48eb1d80750af1bc9c52fec16d1ef17ce43ef19edb73f9f14352ce9e48a8870d497f96e9e90d12f91084d2e756f04ca395c0163f711802cde0e93f9d8ba7c1c88743c142aaf6a9b1ea73aab7a65edd7a50e9a4f10e3d71f040679e3de5fff03c27286165c74572e987ea8689269308d2d52e500159e55e7158f49c5ae73b57aa5ca2b2c16746276205310744ffdcf8f33244992daa669f03444dc9f4e7d90d2921598922268e89a3507bb3af43b7ee932ddb6977193b01e9ef646bd100a76203745dc79569d540c89793255b3ac6a2031ac9842ec0a1dfdcfbe620225ae7033b591834075a3a980f937eaf83e981ad6059c30b23e8d399ccdac1672006d9717bebe45a7e0fe5a21bfd151882e7b770317b3ceabc22c0cc49514d3920adb9a1032a943efdec4b54175282fe25d054e2e68fd8d7b436e5c2213d037890bf1729e7b8708e10a8614fae93342dbc59b4ae10e055694c030d00c3427d34376aee54e4a187943319c1b70101eff0a041b4ffc66206908003d73fa9bf6e4d38de71754bf0ff0e6bbdc26593023ef375072689b7326edfaf4f7897dbad2968e90dd9a56771ac2ef2b24c5a568e9eb95a63efdb42f44886f7bddb5c4ab2d0487a8990059320e46e5b8c0b48502fce76ab0734e3c79260a9a125797e99b020e39bc276bb1784ed4974e4cb70f381d32366ae1dd95561ba923629ee2bedeb85ff5f10df200564c65f6551c1c0c5e889a2a9591cc76ce6e412a181e635cb0d6db9f4237dc7ecac8aa88975cce25cdfdad1caa82c8abdb54d63f8570c870502fec90161730ebc85117cba9d1c78f5c6c27a518d324cc43d3104d5d7862afd1c5faa751d0e77a2eb327d74345a4bc3a80c9d8530d2bdd3e1bb17a79aed9c265ccd0e579c7a080c77a5d515bd10560d2d670b03767efb7f9b23e17707bf7567ec9668d5b212116f238d6f5a080a91c5b54af92e7c95404e0daeafe5d594c7d4fc657c1be2c067f147eb86ff8d895c98ebac7b624f633671bdd3a0fbde7c41cca8cd5652a9d66ea8e7332e4c169363459feb3fc3652118a4d20d9e85e14b1cfe47cd70790f488b6205eb3e577f3cea87e289f3de6c3abe0233fd14608ea87e6d8bd5f67a4599553fccec9c1755e8205ca48f88c4ce6e048eaa0f5e44541526e3b3b97bccbf85b250d2fabc742a9a0bb9ce69740ee54cc441f79f859d6f18275e81fd67a1d7d01e905363953311af6585ca6001d9d7c8c0c17f7904493fd0de2a85f0d1128908f5f0aa9a299aeb7db5a7a88657d45bdc165b78886b1cbe70f175e79922319e16298bef002f0d9a3236bc6a0790f0e968bf7ac7b1be573f0bbb05c612a7e8e1371fcf674ae1c64f9e6f847934774eff375b58f6dfe64d829545130ff33d400fbd5a0ab27a79aeea8c2c3262ee3c6dc37e9f0f3e277291a971b1407fd10d2281de03d6910a06f3e37a7fc256f5f045d0d10fed23019a783cc50d53a5ba5cebe65614cc28a90939b63b3d32ca0f179221f1c06bfae65e8925b36379f5bc0d0b36eac681ba99063be23b0ff863db1be403fdea0bca052d448ab150c2e764be17594699ebf5fb4d0eb58afb41c97d671e455de993024b1d48b3317cc8ed7be4d4d2c1b94f2632690cfd5834fccf252ce56d2f4b5071321ba90f4c32168ebf43ee8b50bc3cf110d5b5429a8af238dd9db936b1e90f2354f5b412e253b0259701cc698a5a2adab3dafe6e5773b889a79ed2f84b375b0c751af73d897c048f694cab490fc138cd8095ca65198e20f15d1b4a864b15df005bb64b71125af0618bf34299051b912076c3d00f8f9b8fea25b6e3578551dc8b00aa6a46fc6e1ee2c1f0f6f7d5be356477e9ec90a6d8c92bb95717b0ef2fac024c12f8575b98b2b27e261a433ea2ca5ca217c2d33175f2d2bd26283a77a53119d34effc4c8a9e344277d6215f1f912beeacc4c6c1913975db82fcfb10690170c1f47373ba8dac4ec135a8016d6d4e6b9583bd1077dc3a416fdcbc402af505434d42c76010594bd6ee483e34632358ee611ee29ccb908b8c5fe3a6dc9ce4364fbebbedccd716b18b0c8327cd6c5578854efcf6643384910135da941f930fd75cbbafecf4431f6adb25c379e54fc7dd220f12c80a86aa1cd7d838c6b7cb4c10479c45eb815feadda54980e4fd300540de8eed4b6ef62556fa0aa4e69a3285dae58cf36a22d96642561b9232e7b5ebe7a6722c3c3cc455662504312f2662e5c0481596e7c22da151988282f99ad37c0e86530ee6c38c723e7885aab24fec93efe2e87535a418621726e7a84cebe73a9aa177f330de1e5393c7d6cab79cc920388ce245f88f66976ef2828adea9c69ae149b4a9ad08b66ee8df988c434644798f3405609613c34ec0cb822656c8df21d71d5eedd27b064fbce4ccd64c7267e949419bc56f0f2aa58a94c54e25f137ee2eb579ece6da62fb64dd25ce80ac3ecdc7c345d32e7e2aad2dcef4166eb665a1019e802ad80ff0c3997eb3414e3aee8d1e405a2e7d0f3531dc968f399d5df31eee95ec2670c502ce20789b2a7e3bb7ee19f7e98fa3ee9cb05e64d06a1bf80798b3767568237c6f4dbe3eb60d6fc80bde05a5df2df685f492b0d88c8babf3f59ac1fa4e6e3da8eb976aad13381d549f9b67fe3296e14e715bc84d4afb0fb6e1daea8739f7c36ee4b92d193369f0984d1d4802ff8e118147ba1bed220b517dc117330345a6d56e7337bc85c12de03aa099c2cf6fae1cce04061a46f88d5e6c189179fbaf0d3c2492518eccda08f1fd8105057b020aee5fea8bf1ceff3404dd4e726299965bdfaa3d9ccfd36a0ae9160b05837bab105e31dfe642b4cb6c0ef7a054941c987efeadf2ac207ed520880caea28f0ceacdf84cca992f28a561c8d8237f2bd61c251fdb1ccf60ad814f21d1b825b7978c160f74971cc79e38dc55abba9fbc239082cb9396e38a2b8603a7ac1d6f55efe66e54fe39587e71d9f678d61a514c9cba4007c7b2ef6b92f12da7f7c5900b9ea5f141bb34adeac52508cbac702f4e9e2b6d31ac1d86947d495af168ae7e1dac8c8643b61a350490b01db01381d69aec20810115ad3c324a6f15b1f4ccbb3ec8a8bbe515a1e3c410db1a9bd6f6639b445f971590b2672bb450965aad029bd2dc64847a3df6418e0f5b5a20253fe6549cf7bbbd5a1b7553bd612babcf91b7442723758b14e4ee5f3a67d710a3b8f4edf7923d8ea167744acf09a2b8a73fa11638576e92c31c8f0348f3ffe145c2a875b103ce289d5574ad9e1cdb1774be424280cc0c0d71797935277a1270750a466dd3dae7b3d14a4187f78be618e32c4fed262c0e16f8b848ffd600f5fd0300030f48737fdd377bbc5daeb8690697e374316bf5d80d09820f09c86d057b63ab2212247a2ec80fc59d08a726e089ae0c8e56a420565f97367ce3525cd811d7eb4c5f0a88e63ee56d09ebf82a9ccd00512581b2407c6a23d7824463debeddae73e878a04303929298d4d6e5d0b2a335f3433ab48e9630420e61677ad656a4ad56fc7d44172f851283eab38395a99526b1716d62094227dfc226269f41b734cd33aa6c774f6e6555ae5acd9b7f2de88398fbb1b248f59f431e57da345d9bae036c277caee252953de92a6e689519c45733c9706d603ce05bbf1efbcbebe1ae4e447386e86ed4a21f2ebeab8f49e25c22c4297198c93c59e3b511083866e4b142ba674be6b72c4be6812406e121443d6dcdeaa647b306c43292d29ba33b5745828937ab9690ad8b4fe96c239c9b5829f4ff3b79d670c3bc3a7a1c8c1098284435523822217392bb01dbe3185e34798bc78cac4331e0bfd792778b744a0c66e80bbe9f3dbaa3f59fcabf7b9459c1efc31117f424c72a7197f40b5fdf99b21ffeb71044c113897148ab4f4866a4959f6aeb50bfebe9a833fb2bc6082dd11afea3cb6d213e5a37763e0866ec2239a5bf36d27051a4e070bc3434a2f94aa900fa2d6690875e2842edfebdf796db3c8d2b655f80885615361723ab2e4c3063b43bfabd7f4d6a27af9104d0b9938c1ab19c773145d03e7b32cdc3a4f6e515daf56c7a8c4fae2c0756dbc8da37f116dfbe8868701917f92ef8e06e958c049aba4f7a2bf4ccf0fe7b311867d4362473bbcdaf91ebe9c269f53db9004929c8bc4a505fb14574432f4d411cc8fa8c2fef07455fc9d64b7534f9d0a7eb62e7d3f6ccbeb1f105213e46093b9c414d97958fda40b1e8125a962bb531fdbcf712f06bafe14bcc05e5e30ffc330717ec92b35f400d510ffb75abb3f35ac54d0c15ea5284d3a4a4167c198305f6161aa1f8338b4c65d09892854fbb3d696551928948314a783e5a0de812361d62e39e052f095556ed3553a7ea7638eb7e36cbf2f176a1d3a5372ee7f87d4ce72d44c7454e462041a23991cbfa94b448869d57e460c0f9d44dfbc9dadb507e3b14f299bf8fe7032da80560a427e4a0813df774014d688203eb7dc406d135e093aba8563d7a7c720d02f2b9572722968a5bf999711ccf97c01e37f57f010e422c3894c6f58f15357ecc1ced84dc298cc7910f54678e867a6286cce6c647302ff7f6e95b26155a9aaa6221ce254e40d709326cf8b1e14c14aa39446e8b02ae8ceb4a5ccaa65b5b41d161bfe5b1d4824f58d7e590218b79db17bab2119f9846f782fd7a3c42f9769880b674468909f20bd6bdf8239dd104b8c23797fcfa37fd38bb5a2d23e49c6040abd9a7ad268ada359ab7617f26b6f9c45e3e75213b9a396fce4b1c5763276b63e1115e84403db76fa5ef611834f4a2891fd04083f383891a43a21dad7a63aea89d5b19fae9faca09aaac937206367f004546145d1b23c6e42e3b254b2ad9b3431601415e7eeffe398b6096aee4d24b32438f7d3628180c3bbe2689879bebbdbbb022cb75cc6447641a795e65711dc5e8492f426d54d6da32dc46182549ad7304db7deb298fe03605375692a977c5ddc16a6bd30537e32160592f68f6c708ccf80627310f71f1a1f974dcab0989a31e541e25a9f07dafeb04b2171f7e4455083648c0f3bb8a000217c60f39b30fe658efee5ee634a113e037b56326761e4c48ae00d408d2404f17feb257b04ded594b3644d78ac7b211133de533ba588ee6d746859f89ecfb6d4293899d33a1f397bad0b120e69b9e1ec271d26ee29c5d2af57a7f5f3f4a807ed8c1c78fa584557b36a763b89d16a84921298c0763cd6d199d3c783e1808c718fc1881c83e1184e511e8763f5fb0f3381a9ee5e49dc277b6b83a01d5e8e01489667e8014a2e29cd6a5a6f759d0e1fefda95fd9fc7bf3039cbe776522aeb6842cdf30ad81c5d19da4bfeb595c7fa7c764e59cb7be5a74b9fa3a8983ad8ba0109ea8b96a1929e202c76ebf30d0bf88efd22be647bce67137ab24f8bb9440f1d3fefa694b7fbd6af54e8e595a93bf466f54836d15428758b31bd357d651ced15fd9b2bec941f5efa30a1750058e9289ea5c05f0474621d1c7a3e0a9080664ae17fa1467d7ab8aa8a05694bf390db647e1b3a732ee01d0165682c13462a2df59d56e6da01391396a711bdf954f406965afc0c28849fe8583a5e5a5f33fb44fa55d2479ff2e64f1246503396af2cc575b6bd6f993975798cddcd4f81df586676448d22029e54e95f2da1a11bd785e2b70b4c90348d831aa676e1fa02a14f8135c937da78e377894d985735604c103809fb83db1f28cb56d7a969375d6cc116aaeae2cbf7539eafe32344eb1dfd28d82a869eb21f60779d2cbbee83b1b58bcaae7aadd5e2b57af16e78b35668777ebe95ba97f7341d4d214115a7d329e9edb6f483b02a99686693e6f5c559210950bbed09e1cd3b41eb2dc81f92a45c6080de84bef6d49f788a4da040b965de0a902f2199a5052cdc5a46b372dfb11807b95c3e7f75dd3e52570a4238be74877a4062062066311e3d30ae7c71061e060cb51376e22c455f715d697a12eedf2613f4810a0469392454d9ade84948b23bdbf829b4a0a2aa693d2b29b5fc8aa7fcd7fbde3c06168ce6e7acc56baa59c2016a72f7e06f781bb64c9aafd91a9b95667714ffc99965d433fe6e6fd1044400199162d945c64a995d161274a4a7ff0da345cb199189ac59733f7456931e7327fc5dfd9e80b33dbad072403535b94f356387a1fd72a4796b41e5c5a97c07e28177c10f3e5c8a12e621273cb321412e6ea7d4bb7c79aaf48b04383b77aee9954794419ddccfd4ffa06c52866b9adf5defb59478979879aed9442cdc741ad286edbf6a536a8dd7d5899355eaffbbde8eeb2dbb4b97c4566195385ff71b36bacc2e87ac03549fa5c163ba948e3ba04c9703ab8de8217215f8467ccbfd471cb32f5374146302a968dd2d44f0e04cae46c5d65b82c56a748e87edf500660662d5b313dede9890b2a23ddd787e759a91471fcfffb29667be765074be07fe36cbdeb9ad019549932a3a2567dab5a06c8c867d1761424dbf1cbd66ea4ef002a4cbb93e4522fc2bd315bf0727cf5af4b8179f00d2f0579ad016faecb1b5160364540bbd30adb5b15bead59a1ad5e70ad29d35d4e959e566776d52664d3c01b2af114b0ef47555ad4234de24fa6b19d65abc2ddd5e006c0a830441d9c347ee63dc8693bf5217aa6300d5aed4719422375c4a07bbd4a5c97c46a70cd596b0d6c936d447753e0de32c6c1a0959f56e6fd855b536edb7ddc76bb8d6073798860d0b3f207fd04eb80038fae3d20d1b5ef3da8291454a686078219bccef22448d81eadc04cabea36c3ba9b335631165cbbfded11cb7f21cbb3696341410163a547d0832d78a08d6b9c4812f4a358338f17b616c4587db5e2f86a4b35f032e6fd1a0c262f93b6b4b904127aff51591773ad7e9577be461665f6e203f0fd55700bbb7ec1e3a621e56f4002a7197a3c6b46eaa3ffa671b162be7385d232da6eab5070a11c93ba2b17b33641a45298bc679c0045e5c4e13b2c0ac91e62c67645184dde72d8803a4c30917cc6823d4d995db6b196d49bc285ba6db3d84a8ff3843ec493095df28ae515e26ba14c34a657447149f06fec1ef4198e93820885a5c5839aab52718943851828a0e22805735a4941c847f470a8a32fe9a72f0bba1150ca6241ea95281484e8aaa361f3ab2296dd2ce886ee1b9354bc4e6415e9351804065cd7de1a70e732380bd7e23900dc6ab1304620241ee64e4fcefa7b92c76c3cef1248f8e0c968adf18a1507ca197a67a6efdffeb7a87be63dbc990659b6f95f960ca998962fc0f256b13baf67d0d0703d71abefa094703896deb265ed75a89c0ac2619675dbba5d4c7a1d0640e168f2a0c36d4b7a4937817069d998dce3ead7da8570fd28d70e564c3ffba2ee20a156695b81862f3e792f6d64e30c4c1713c2bd0c8d28c7950225f3662e4785ac9c1ccaf36a8087bdae803740886eb3aefc78ed825fc4c45510a54faa72759fb8658f1919135ec7d990cc54976034674acc3283b105f00679eb08183c5e2bd0f668e824edb35abf6ea9bdfbbbe68864d8bdd02d485807460b55f42cc6b9b4408584298a9385ee107bac58c404d7010fd4c8e43760d79dfee26710635b16c5239c8814aad2fc673a307d566733062ce1b4c60b45b5e7b389fb2e8ec66f75cbfd000e49c3f901868c741205f4726338d2d696851e9484c6a2f6e2b6c8e35823f18540674d916f73fcfcf431407a9f94df7e95dc87f4d7ac0605543176fb871631a379c4938f470e0efc2d06cc1da34fb072961714c40d12fa4412f2d20169bb7e4723201db6ac64d9aeb9b28fc3e8385c3baaccc4ef02ebe263dc0e498348a8c1ee200afc8cff4eb86ef2f0133e36496e47eeab6bf95912d714ff7575b61f63bf4335cadab975c5b084bd067f87ca3d5b28eed1e1a12c5928e33595fadd3394cb612e20355352c26e390c23df0afce6787a15d11ce7dc81eb600ffab2c924199e07adb537d60e63344dd7594215a9f82687f6bd6883bc4a3cfba92aa147944b91870ed6ca31ddf29277ca3eceec7ea85fab1ad3363cd785f57d45b6514523aa9d6e43eadaff40b06035ca8b7f5fc42","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
