<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"97bb07f353a91cc646adc5cde97572fc22fc3ad4335c438751aa0d723d352c08e6e5729f211cd4ac583f571efa9bbf8c9e3faabdf2e725d47f295cce4a991ca7bd3173804811bf2118336c94b760429b7eae01c1f4c66d75cb72d02a352b2b4a28128d52497cf1feaa6ae6b85370a9e21620ffc07cb934e948de4f9bc61974dd2c4ae581a1ddd6faa8742f42465fab21c3d22a328d4069b6b87761178c5eee95d55077924fd225b735152215091612abee81865092fb270fc10d0df68e32f9117de05f739b6b1b55fcf232dcbb4b16e5401fd375748d3ab207aa485aa550b87087e7c8e80337b2809135fbb9b91c78a9b03d54c2e3d2dfeb50a9684922839c8e7bdb0a0d6a950b2627de0b76d43fc0da0a12bf0c03b143450a9ad64dfb96dc975bc3360fabcf04a1c839908e21a62708c2e0520cbcec31206a6bbad13f3ae05fe3e5ed51fe966466482f99149dabc2ac145803f2cb886a37111b3b129ab2ed435f74a3134b4dd000edd2eed426f401372dc23bef84531d18be55e46d781e82db2ef7d1df200d10bc1958b7305227b3b1b029b154edbbe5dff97eb1f4ee6be255ced1e8b8e213f234d1c33037c253790f0410ad19ca91d8d4afe86f1fa75bff7dd1dbdbdf313ecf1b1d769603ade75a0dfd88e52b169a1478989a0cdaa3c27b712a48f6673d905828111a683bb50a40edfcf8c3a377074e83e9e428210c4f88b7779ea9bcabebbea4dd2dc0a4bf94261414dc3bf634a0b068b05aeb99ccedc8f26bcd2cacbffb633fd3aff205815ef31153b543efa948e6a1a599cf2c7aee779955d40df7a541c5dc8b5f0d6b5609cf99203e7811cc973be2b675c5f2e472f03a5a655c29b452bd6e9cdbbfd4c30e9bfb97a154bfc8b3b8b72908d54fa9be24028833e1e266511ce47d2e56ad4544fb58c346f4651868f78b4a00d02186d4392028dbf668105423564daa90fc6aa73544037acc508e549102aa1cc160437e2c93f3931490897d04feceda79df515f296796e6934bcaa642d19a059e30d6adc8008f5bb544b102aecdc69d87641f9919658e894f5b8639dbaf99f739645fd7b26a330c7c95fef4849b71668c084b1ddd12b1e1808da93c49dafa86f3829cefb8511b58b56750b5470090ae827879917faf88d2ae06084460ab55c750c9a47d5b93ac3b0ecc3c6919a56d79d9225e9de3d5f7747b04fc6a3c93b1d7068dea76ecbc1fcd97a1574daeabf5e32401a89dc8eca433302a60e69857b1b72192f71a6ef76d6f165bc091e9dce026ac3b0e00373098f62d3ce24213ae5dc1d1e7cece3b7814901e7b9e0d1fe7fcad86ea79826bf95432c8d232667799c166df86c6a5e710fcbe760241af0ca53803d644b6f53ffa24e8ea73c79dd521b575c14efa029a3d26929a6c22d2b64dcb19e396d2287f44819c7433e2cd5928ce62577844bd78765492fc130c832849037d32e34b83a3c369494ead2b36688ab4992e603f861de2824adbcc454a73bd9d02c98969dc1bc14172fc34795ad0645aac7eccc85b78e5617d56303f4ce5d3e32dc01410fdf18dfc3c05311bf30526fb1e3ad42dab2b20a59e86d21db66c518752dd09f1dec6788b6a689ad8b8d00d76cebd77f89becbd9b7d54e014d5661dc696434f2be77d4a58c20ddce9961ecc001191ed0c63c77d2a08e3809bd2dbae6fef9070f258d54b068dd11f8d4194a10b403b8aa7d573a967248ba5a044e2843a8af505d8b6d36fb954b250e1115a21f08cb01fe082598af89a5f003d4d22781ba9e0bf7a85922490eb8c3c8eafc8b5964cff32308f495072c7f744dc0ec5b6b69b303384b10baf6281c3aadac4952d6b9032cfb3415949e8cbfdbd0d1d62247341c9253cbc1051bc6dd3c2d9cd8a721daf7c8e94315b36a22e81e973acee7159e94f9f12927815a69492ecf10fd8caa4979f866ea9d799615834aeed6df81d88219bc5fd5d24d67ca2d9f34dbfa9cb85e964fbca0c62a11b6f370f260f9da287b7c9efa2f49e8d8ac51c38320862d199a7f3dbfbd69b2f8289d2ff05637dea52370afaded33e2c00bbe9842b9fe170b45b18e0c410e20e5d671607ec406c078cf5dac74cf09d004a623a61b349d11f266f3ced12aff1f5aafa9f762a99d03bca1a070765d206d0435f086ba94328bd45623860661c4a19b6ecaef4c084b9025132089e0490501b5307c32bff1460c3229412efebddb9f4c327a0d9d7e71e99ac3f9669fad8e6fdf9f134fb62d019cacb916635693637f4b6793078ee88be15ddd5a05d5f3ec85bbc8dbc629e0960fce4e79f995c9003e7a4076002c33f8a2bfdca118b26de0b15540ccfe9d7645a2cabff11ac7b0cb694363fbfb8a3e30a4623bc510d23ac619b4020ddd579108d1faf800e5b7a6cc1183e9c59ffb711064c90d83663c36341747998b9d5615a3bf64445a3db1ed5aee44e3b33f03e77b9feb5aba724c200629bb794e3eedbd6771b77feef9fbeff6722657b642f30d6a422c95b5be4b8eaeef3218ce6f85f59114147be0bb8ecb63395aa7f0f5f8bc527ed4684d8bbd73c516a2167240caa76dd9c53f42fc8d6143689d47e389148eb38ea40e461778e34b630ca9a3eca1f8bd9f2f08dd0b123f7e56640c4221be788c1781cea5d941dd4968ec9f07723c224b1634c629969f9d9e199ded5b40043b75a143d1fbc05243fc364fd0659898f3167c90fe952509fbb25843efe1387a6eefd64d2aab3a4ff78f5591dfd3a9415c3e62e43ddfb6f48ddc0b5074fd40661913ed9f9c3f2e0aeb1d6955d32e2c097f356efa4ad7156adcb7e973af49b927336fe20ffa39dcada5e3f047390eb1de526b4b52241729123cb282cc3ac8f0cb3dac97d5352bd5bba26766836d91656bb51ad7839db67c6370a76eb5f3f09ef3fa808b9580aec0e2f6bcc5c0b2705ee866c0de6309dde9028579571e2dd73333f7474f09dac5196d00df3d84124720cc4c451666c0068094d3a0cbe6cfe0a3d7c23dd9a91ca62e874641536cd1ef7706d353ac4371b246ae582464fa36eb734dee134b85e339c1dd87894e4d42f48638ba68f884d3af109c7f757bba3dd8dc9de1ebe0220e1444c1565b288c92c921ed6562c336eb5e155211e20f773578d202b8476c7443ee7b6a3ef9c4c8cad7960e7ce28906daff5af68779dac4db83781a42cab85d53baf932f7e443eaa6318f304c7d9a0936ce5efe537c82935f7cdd7af0305fab97d11e6dd98e13ad335ab04c82c0206eddec0fc21bde7fdd388be7642737e62fcf07ce57df7ae59fec7f58ac30f2c73e667e3d81173b830344ca383caed9013bcf09e28c9e4eca66ff4401a7d0c9f7e18342d04ee93149f9fc32aa90f6a33e5b2215d892590a8758ede930b425ca3684d752ec0d332f07cfe426aa3900d2d3d35edaf12bb183bc51ac913578dd5163f43a1fea044d27161152197c44981c107cf0fe1367582064df30c7a0aa5767a279d98b0037cc644c365e1918095bfd667c2fd4bb7af25b9c1b35b0839b00ded8c5877ecfc17d40ee3acb8a68d3c86c301e8d1710dcbec0f2e3b7491d8670222350cd161d21e9297d870c5215d25d138f8526c558df016f2f2718418e6ca102a791607f0a9fbcd05ccdfd735edd2821ac02fcea5b968d1ebf13a601bd186c2c0c70626edac175bd1cd4082093a23e8d822eb6b8efe4647fbc6cb982a3e6f77c9d5be27a85a5a764a98d786049e4e355bfaac8592cb790243a6432bd786d5a3b166e821e7ed639a7cb086b2afd3f5ce019940b959cd8e81986126263fd66bbafe0801a6ec0cf1c175cba4eb1f1e2c7d5a7a7cb85f3b5bab3c9d6b02c70d7ae6d8451282535a5730b03aea68b8402a7cfcd1b4eff97b85d818bccf4ab21a2fffbaace558be1b7629e17ec9bd9850f26ff25d7055d171649408897562a701111a3db67027a9a85e41271eeb4d3a764f3f9e64e0bf5ccfaed68f3d44a161ee7f4f0ea5ca278fb3648d99ca3ee01e29596dfbb5affed3081c07afd27997cab3cb597dede7e4cb4e6eb1fe2a5f992aafe300059122adc591eb37463c85c0bedc68941ee38397d138e9c0fe76e7948926108072deb7fbdd47e3278619070e780b1b4255f4d0296779b8733c754767c2f27a2cd39f47e97f7563ed8cf1f7945c058d8ce939a4143aad501cf1c5e86546452ce69504b169dca1b4cefb9cf5d9f1cad2f987243b635219d9a37958c32b688b0f8e75a62ee5fc3612805244d9913601c1764761a12bb4ab21a4a5583f2b7b87ecf594baa5852c86f0bf45ac8822b8e8758927ad8ad2b7823546107815fa2b52c63f45baab925760d0f8c6a4ca6ebb893ba7a2ac27c780bb93844ce0e72dac32676d7564350699102478a58eb0ce8aa5dbe13d7b7e5f110a344b856cb002333ec13f786ee81741b557a763c611977b5d12a9665bd9e4a83f0879751c04553e3106d73790a47f19445cf238330f4a55edad756aa4c5d45e313a13342ae658c5ec7ffbe6fac35945b6a7e83e4778574ba3000c5ee65166a478614557baa022f74bc3a13894fc16c1d589a886208e33776fd8957f648457f9b7a1478647b4768c38780b51a174b5c17aa074931c669446560c371c83c4e485636b3319a60e74556e8933860eac9cea43cc6da12057a45c9a6175adec4e46453aa35df380db945cc9d711741e6476ca83b9f7e36bcd90b76b9d769f6d4e0c0dc196b0b258b4923147757bd0daa5fbd3c10623fd28178d1daef645f2bb31711b37d179bda52b31fcf57353f013b4bb64dd8c243e21d348b4f1dea10cf14b21373ad8ac7db78197c6c4c26e74608c5c17b8f2d02262159c25ef4cb4b7468d642ffadc54d87e29b0bbc79d9440f23a4b7fdc0103e3d7df04e28a9781de20bf8363f44a6d03e65e109e6de75c46761664ecabe28b7060c427ba21a88a211ea83c8ae14037cdceba5d0eace10535abc68a00f19205c4436be5c55d96e033f81bfb99cc3e9d20116a91dd56a7db9fd98937ece5f865c134721724f988317fd8508a53cea51a4161afd536503bc8e79e54a9887b2af1f7bd2895b8104b735fa4bbeaaffc0170b325eeaf71cdf705064967b2cd49ae287cc265914653087acd813665bd3ac15374af90e757917d53c2448eb60ae83b57a5fa3a8adacac6361f5697a8144cce41a296769db089e5d1cac66d47d12f53a863eab5d93ab8b0a2f38ee5eb2dfe0fa035124087d31cee1aebebdf824b096626b572b19fb4ee40bf76a568e9efb53b6574a18e54fa90e897a77f615d6275600d66a00af8c5154bf8a635e982e886676e3c021ced493b66208e0c90d8c14761af57c74b50e4524c02a88539b3d9598c59d24640a92f88b82c2d3dac9ef7c18d31eef96b793cead2ce7e028537ebe4272f09eba6970229af5552cb7b062edbd4440b8ab8731df1a60d1eca85d80f88c310a8535a1f8fc8d140e5167138ab524e49b9ea8a43f6fc4a5fe942e670869da517007ca28d8f38f930313f965b6e3d122c98558b0d4b5af7be676f8af2d04350d5adbeb9344992ec2b7ea5c11bf86412fa9666edc8c0ccf8d1e81670ac9b5db8c77e7d27ca2e575c0aa3acd014cde2cfc9fb1497cc9d400f9b1263257afd2d2ff01fe770643326eabd9d3ee10d90938233dff3a15a01387412bb2e5e5b54c274a48f8a46591334e18fdfe05604fdcb7ba6469c3aa65b37d57536c329c6fe4e2954120c8c558df61d9b9ba6944184dd69a70fed494550a4fdc846fc6fe3d3814bbf8068db34ab34dde1aa0f4edfca71a5368fa64b11423e92924daf2ed7ffdaade80a3941cc0307a9d83dd7de57fc363b45c6d72f1101d0a1bba9a35b7968bce574c38a9766101eb852675251fde7e43fcdb664b01c2a5ca2d27ec1e0a0f1ad1d662c2b6174ffcd1fc8fa363a4a57e8b36ea5659bdb1fca38a17a1724c32f5e4272a9176eae83aaa1250d62c55db4b885a9190feb18a7854f439b08de9befbab3b7c3f6c710c9e425ed46a73d867eb5b2bba23b707d06d6b657bf9f5cbde3cc87ac302890ec373470fabcda8ab65f94f303375c35b698b89f5e3b8490c32dc4be22581886c50e39a1ae667beeacc229d3ff25ad19fda93688f3c8f64247a4d458a79a54739509ccee96e1274c1f62236fe1bcc1b47d3ade3dc9cb7f28da536e523fbe55b0ba93b23db634e2bb515dac84cd43bf559f3ccb9c5282efd098856b222f3f0d0ec1a17b2397763343502b0660f73c12f442a62df9a9f80b91d194cf8e97ffe8d8186256e99e38c6939e0642c4f3fa074aa38b885fd2563ee2f5c0aaac1e66b16ce72726cdf4dcdd70cc6f448aa377ca0c77aebe00b68b41518b92aca4eb7cbb9c698728b713c9f0a746dfeeedcb812f89d8ee145e46345907899fd64298a37f2d77e5f58b5661677d9234831a53fc42affc1a86d9e39fceb760709fe0f9244f0ae6f9c371648ebdeeb8b7fd33a65e34be906beaa638641e2bf02e5d66b28fee0a6f9ac7bc519038303cdc5ed2ad9db241df2a938b0f7f03a83407a5644bfdd78bdc479c78f8e1badafa551ec80a06892104d3930dd9958e2c11f906aa71cea70d6a96370f50746f537f5aa472e009af33d5d47304825d5f04f711368db3ca4094721ba90b76a117b81dad12e1417c2c49732612d46d02b9bf3d6e67a28a709359bbb743bd1a0811b6e0ff1b2a4ad48e717f37e13d6f6923d27d7a461989bee82820960c79d02062a1006e61cc7fc577b483d40eae768d54ce59e7a310747b27574d78dab6243e85f2a47bd7f61fe00a17337726ac3c8c7d069906cefcbb21ff5a838d614e5ffde94385f1dea07bc0fd33dd23f8325338189ed1a156f476c76c9053c721ad43261a78d5bd6d3698d7eed2f33de67d07713656261c859b97c4de0e6521f9418e5c82b8fdd19a06ea50089f77c5c646fed33f6c3ca97ad006e13555ccdf59f0429141a1eccc2e6e0c0990c076e8280221f2d45e21497ce526374e79b34caab86f7f423f3096e258722c376517d5d643f6555dcba0d9a6e4f507fe24510dabdaaac5014374a7437688ac4d41fce221dc5a6a6cd1a1ef7375299aa54e1f4564e8e2064fa36b1e596ab1cab4809cce33af384eac30f64d77624a981b90769eeb69631bad12fea074708564a30824f6368fc4262fec8c8c44b21ca1a60b8e9c066df50560d17bc975bab4708d10583459896b78788c3c77726c422ea9494dfd0e5e5eca7bba9482e0a39930e136c8af2027850e4660b3891c0253599592d81777a480bb66b113b923d5a91dadcc6a914a763f01140d1392cb7458c82c74e81f0bd084a7525e51772f8744abbf83306558ceb27e78b51fd8c594ee5f20327316e7a6356f122d709cd8b7ff4d1f64d8088726b0fa7395ff618b201c2e2e47bd7afcdaa24b2d7f07e766696f17bb4cc4c96c86b0fa135377443cc10825a14e86468f15449a07d399b3c0952d8eafde31f59edb8e1f68186298a59de4e23af0fd6445a1f0321e4008c97719422d125cc130f50a2e7822afdaa860b73849f0b5661c194df5f79447c99a00d86119b6883b5ade6051465d87e9264e57851d4bd5fb5e974c4d4af0b289ca6a324369438a7a88e973b0b8563eafad887688a871f7cf00f2305f52d4764f02016295377ceb266a4f756be7be95f5e5cd57744c1d177044b3c70abaf16da7fe87ad200c030bc438a10bc097fc2d1a2d3279f477c955e28a719f23d326a9b352ce0100a73595c79ce1c12fbb333f22eac670332ff4b70d355415b1b9bbfe29c1bb2d51cc3c06f1dd0d4dbecd808dbfb7bcec8fb359048a1b50aa5790d2761e770660904d08d9b0550e61839ca347f20b0bc4e28f1083a4ac8779f23a48dfb4df80b6fbb866d8033187d63d41880e37bd8a62eced38cb5693ed1b3de2f1220a87117c99fc37ccfcd630e4f4ce78a920483807ce1e8f41bb66c57491a659c6c6bf7a36fc0c974528840d7b4b179cc376b313a75ed000a57965179ded0e7c9f4433269708e094d16bee86490cbe9c5be2aa72715a5e62e5738391d1e70cd6624a6ff19b8139cb103d5956ed5083ca506e3eaff3abec3d890d020d0ef438dfdd180acbabe9a0b82c0b84ddf2ec269c8d818678d585b091e9bcc495d1750fa6dfe6751c43a3f259707d01383b06123796bead8028649e202731d5c67c22930735d289e44f40abe75daabfedc07819f13ad336809a8b6734d68d6b3bf73ef73e90836ed3b022c0f6aa5116a70a3affa6b150ba1981e495284d30603ff40a9442b80966ee42f364ffa3b88e00ca07628c899efdc2212ba335f354cc8325e3e100ce41ace7ea8a9e00be2f98a9311f6edeefcfb293578f3b09e79eb538caa9bbfc8b152641b4c8d2152118c7eb9430b6f1518e2243ac1271c59c9aa4ff7c9bab937a30747c0b8988a840d0b83c75fa3956c0bdcf4bc889411e21750442408ccb9606b0c76a75e325dd3038eafb5f5a8a4b6e52a22a5188a2d8337102ced9ad12cff7e38e003d3287066963aa4f7162ff6ca9f2e3095c3b0508d3a619afa0e31c1b3bc9525b3dd955584edd8f6a0f3cecc2552ad1944d8c17cbc725278c73d90b1bf2be2058dc9f0f7dda97ea82a2a4c74d117b48212356c06f174671d18c737894ad56a919a61b40eb34d190656faadbf9c9803ee0be2fd3d5c414836526c6ed37f7151b4cb972b733a9745d308869ee2cbf5cf6528e98dc993aab5a55ced9ad88f8548ef8c0bf446d71a2290fd687572cd1b03f60c2884c7eb5799a96c30770a2cd3cef6be60c776722e84a764e1ee14da4c9f71b9a7fd8c62ce4cca49e3287a9c43a0172bda57c1673771e59c91fcfe3a667b84a4ab4c96bd1c8090965dce14fa1a7b86158473184ff5905b5043c119344b8896573a47366b2384f4e04b1ae124660709450c69c89de5b24eddc1ecd37c6e74a0e35aaf0aa2c799033b79b4b74dc793633900dd88eed6ac3f43c290b5f862cb7c9340420ad1ddc21b0c556dfdf8e7a167dc9ade3c934cfdbeb8de5925bf819e3c1053fc11fb3e165d57d8adfb931d9856f177fb247676a22ab50461e92a08e64e1f567d403266cf5b4a7d404dcdfc4ef0dd9280f0ca649a7a201d18edd5510fbaed5560334c2307710558783c23310bdac2bab04f64515510128b09c1daa95408316e58f02f95e213e44d571e5de165bdda4ef9dc86352c47ccf1e937f20fb435527a996f90dd328aefa91e9a003dd47da9d9228323825ae82303ae844d0e3b8ae615794c0d2c56527cf11920b65d5d4a60ec51b59c98a37966dc5f89142b0b6844bea25406eaf8fe7084788dad202e65007ab24740102610210e586c4958336f3f167732bc3363d79e0d95205f4875c08b3e653f6cd18f6041304c3c48ad8c07f2ac9ed875ac990b6a0f893ab84a7d9213b4ca6f84122d60730cb79c55ba68e3e20e1f3644c2d82bd44064d55efd0f7944afeb241e03c4448afac7afd6688f442aa54c393e0ad15699c363cf63d97a501316bfeb7ecf4d8854b63ebb3fec23baa75bcfc869a456f6f01da76cdb35c43d0639a386f1e88eb7b9730df98e97b97652d693747ba5b23fa5c3278d77f77df98048160a498686ef1c25e280f8bafbdb143e9cfd7cc6d7df7923ce665a52f4c1d32174b951114a25e0cd0b687e09ad1211893db6ddd16e8c9e52dd58d907e03d2bfdf62828988075d126af8ca546c120d0350935852fa15d9579a9a7a8df39ea0620dbedc4a603e3533cf4c363ea043679068e4f9bc5a448b13c4de1a7071b2a71e3be9f38148ef777b7b86b6504e80361a8f5e4b5b56677d27b0fa3d39c4c3d7249f14a93fc2662a025f47307b06c1230337f46950da44b69b9b82617ab9ab447bbcae05d9a093e67e6420b54f0b47a58e7d9bf066cf95b9b69cc98f7f7b0bb9ea4dce0b1a93aff45dae8551d57ca63b49249dd40677931aa158300fbc5dc5c9d4d8b4441b1ef131f532a75c0031f1a01d585dfa08bcaa12d45303a0dc43b3f8ad8076aa20d9621d134ed86acec3db2954af943554147f6d490918b95fae62426ae0b26fd98266fc1a0980e7cad7424032638bb3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
