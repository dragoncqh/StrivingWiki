<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9a65b9361ef010da2435745d855bd999cf6ebb9ff27c9ed0ff63d4d6da2a0aeb0d645a87c1c78d47e75b8b3dfcae15669b3e97f854cdfc8aa377477398eff0e21575f93f9e1dffd96ade3e770393e28e7d95c8629ab9872acbf65d2c02c0aa03656b9994669b747f19883cbf4cb6774204e9fbc0bbd82baa3b0a12c23cff46412337d5540b851f49b8fd6541c6c0d420e283fd784b5a01fbe328ea5fd09250f833c199b8206d9a50125c2c4d81777a784a4a458a4f572fc1902ad2bf79e77fca609d0cd7641bd7e2d3db58e9865e680cd57820e5e77f150ab5ef99ab44842ce519491cbacd8d66fbbd3df3643e7afb2cf2a1bc46877f3db54389302f67e50b34099cb5c912920bfba26f13054e506e78ed0f3ff05e012dd9cbc7f3dac98eee1a975582ed4fbfbb4ed91211fa38398ca6eb66353e7c77ca1ce957da7b3393685516a00cb596984b8e519cc6f94c877af8cf4d78b76437338680949507be862f3c1ef8f8980b2e6bc9a2bb8593080c54b11e6e6ff58e77df7531744d4151e43fd8fbd97f8c64b99867be40621ba534459ac86d906784680f4507fa8fa38c605a128e9be1c2b7db6996361ded81b2a4b62160a7734383911e7e9ee2ae0a738c16280ce9e81bd3ddd33627155d5ed40f929a07310e82960cafb7252aeb13bf471904f3b98e7a37109c5a38128f12487cb55ff5f068affd15b997c6939cfe67f42790e91ac7e1b299346ea43d325c50beef146466885bb26afd239a92331ac65bebd622ad365f9dd2e0ea44c8a5a105518aa9c93d4f45703c2cca82fe3d453e78a08181210bf9af95fa3c48135d0711504e0f4ee56a16ae12f2e756fd504e85f1867b106b4d779ff01feefda3b085ac22e4c6555c668573e796d168562cc5b274991ddefb7e7f23da5523d5cbc4fbce6dfd036e0768ecea21651ed627bfd1460aba90e068a253354e91e76f564f08dc119ad19d11f3fa8a149377b25b9f9277a63be6ca5398f3915936dfd65abf1116658bf44a854832705fabba9855f29ae56a42489e315b06934890ecbd2a1d2e10f06717b641610d1de57310d98752cbf5db0ce82987093b359eb3b907eae46c2b9e821d8b3c8f922e584a4c7a281feb90e5a1bbc7b5d3ef121193bbbe3951911966aeaa6bed2e6e754318275a33753b521fb0420aae2f1088ea00d812b629384e318fb0b8a81e1bbeb11b006c5ee57f7e400b47426e2625d787c3683dc3d50f921cdd824bd9c9f2f3c87b8ed760f61c16d7d075390d267a29fb4d7a7b599eb05872e8d2e8ee7f4ee10b42998ef3317c1dbd6337795ca3a4077aee37be259f55ef1dbfc8257e5c58aa029d82f51762a930d1acdd3cd2f5c130f338a13a13f682431f952293f881d3db40db1dedd2e37e29818914b7ec8a68af0abdca815dcbc3b85aede07b5602d9109a729651f08ef1c4c098ef1737d8689ba729fa0ca24acacc1d4ab7561ccdc9d8540215ad4303bba9d7d73b36995bc60b2c119ef5f238631199db9f0977086e44d73dd3af9fdba1f39528daafd913ac17906d4993a6d53e351e2d63aff7e7258b9ff74f17c4bfb8b1afd60ad082f2169c6d6fe0f162fefe19344c325b45655d5e37b03a50378db57606c4afb807d60531a8680ed1097b64811a895d87a46c9f64e48de12252a2a61b577ee07182826a528e88a4d7d390169398ce3bb2913d4c69685935d8f1a970bc06656a3172a9b77592ee54e2e985719242f8fd91df6cdf850735a922f1b477f04eb3817f32e9da1aa936a6cff375a348c930bb741971ac8979ca4b0aec27c3e165b362ffefd4b286ea924f5febd490e4464086c8034424b883015589594c2c0ab30b5335f8d6096d24c58e8f1b61cc2df534e8322f3f758694af9281db38d35a0bbbf5ecba73d092f274753ee7ed523c6b4dd38fb3438365f6422aeb9c7996ba6999d1187299fa179be5552c626155356aae5a90bf2f1906bfae5f5d6e6a25e23ab4db2934f1feee4ec580938492bd64a84e1f881b15f984aa52a8b6c8ef6e53524e949ae712838cb18109ada19c2e8bddb4ac59fc180e51801f7e04a95526a526b1e5a236118f3d775282de57910f4347b31dd0fd46b28a9e956bae4a422df57995e9bf5cdb05e4209064db41a4600975cc290c394a2e28e7ab5ce65411b5aec883fce660f49ff8e852a66cdc1d0bc850ae3663eb1361a92376fbabc7792e5a5c712d5e9a3a7396ca9b501b5abdfe2b8a59cfb23f9645b0bff0a2d87381ab690219d7196b477d0b0599ff6bce593c9396a3b22a47c9231d330dfcf7d657210fbd1c1fa4e064cc0035752ae1d8628cc9016b311295c5f78f072b243659cfc7882bd75e2a24f48a77a3c7d44ae985a4c3d8e59c016a659dc064e57a9cd65d632d86ed0533958a2be96cc5f7e0240666aa5002c27ef1e5042c29ee424c9b10088997dce51b11a1100e9932772da408b4e4c95b1b309cf85a4fd42fd896e970c0fd644aa5019b65b28ebfdd06aa1d01ee98a45ced7c56c70669969e34142685b97a13013f0a170850bb8c59b43635e6372a3d48e380d9c86817234a048ff8b099c8ed9855b5e324ce23909b53d14883fb31bf990e7a663b72c2c43aa969704936d565bf6e034529adb53f59153dc9ed6bcf7866338f0dbeeeb5e6a4dc648a2262c1b84731447bf45bbfab5e3dffb6a8a0bf5ee43844ed54c1d6f10c2987cd38245ff20034fc944fa2cae59b4a68105b88919a0e49097a9a261ee43e4582afe7735cbbab81f203f8a95b7269563a93705e90385e4f95dfacc0dd6e816aecc78253920dc0741245edf0670b7ef7629fbf8f89b4d3817ebddd67d7c6aa98c04a2f4f529113d9f39677fb69ce20e44d45cda6105b7e9f25caeb096b5424f87ca0ae776b1ae28de41b4ee87e1b60d2a74a7e4ea23d161d3f7369dc764a59fd0b274cdd6e0fcb2d6ca00c2a27014076d8961b25534f8c25f22dc86077327b1d256248781b824590fd9114ebeed7e860ad135d3ec9f1ff2c38c6b655e1df11422e19bc022f68af006512eba8cd9ccb7a9ff204b7bbd8b62b2615dcdbffc1f26e8176fa8092add0917671a0057277c99e4ddae9e27b6636ec306d74404d55fc0b85ce9a2ef02da61b172b998c6599abc15a0d33d4bebe0845886e86f68fe8134010e35b779795e292af4f71ea3451064a81f76a42c067905c44374c8964c6830883927b4ea28d35579ea9b97f7f5b3206f9dd4ef993d8e4e6c1c66d5a6581f4aae39377795e2b76f66b35dd6a6edcca4ea58533c6fab34c03e0eadbf8711632cf85c2b5e4e38d4451e36eea0711f3867bec88b189d220c1199905beff5372472d802535d64cd17eb68b32d209922bdbeb3a9dda325090649c0630845989e2c86fdd457fc032c4a129d6402a7e70a4928088d9df1989cefcac3e4382504a6b7617fce42e6b39a37288d1c34fe3a4d800b345f14097ae792fd3a978a9eefd739e6dad99585b7ddf210feebedd20b9289e3e8c47a4119f26040ee3ba6c5eed3bd734549e24f208e80f1bcfcac4f91807c42956e8096184f22f6c9a48131e9aa4247bd51221c688e2f5af65cdc5fa4a6122bc0655411efb5c1fbb96eea6b1de2e8ce4dff1f87354e5cf78ab51a3c8317b6759f3df31f6283c0e66c4bb1ef28abe595a292455eaa1a94febb064147cc360908b06926723e12e01886b269275f7892292cfa767e3ab3dc9a2733c7a38cd3f943a3273e3cdc338b6fa2b75c8695efdc001e4ae8fbe46ab5a1e6623c0f48b03c6fd074e471509eb4c5ca24ffa9b4b43f50cd5c8f3995d242b7770325073dfe54249e7031685ab12bd9ffc8a65ae6e6c04cd243273169fbf471e438bcd8de66bd2b3cf2989cb14a3dbee161fb776ed2754ec221f9c23b1f1f3026d5e4f7902b9ddf911f79b5f21360db2c7f0495ccaf4f1f5df313c171a35b3b113dd99d6126aeede472c3671d3cc790171cc7b516694733d38f26e2f965da5e9daee93eb117922b03094ea3c87515fa7a387240562e39dea266ecf21c31d54b5d961716cd16c732ffb4b1b69a5519581a97da50821beec540f0ff5401edc48ac801102546773a8d5b1b0500ddde68cb6a504e9a5b354d7ef630802ae87c65eee5065f63c365eca78ba2075789710eb447c329e1df4bba631dd1bb7da80e5f3349fb998b6960f4847709ecfa586ca9bd349a0f9b0e067a2eb7c7e215bcf118a1c301c239721c9fab965351a37e1e98fd8dd90064f0c85fe96900ba8bc3576fbd5233fcfa2b7b3920672ae16a1490fc1449f78d5e04e83bd0494082116cf66d33630a8fbfe859cb2cab46bdd71578415e171e9936878997ab5d15a2821e7e267984d2bb2fad50203828c741769345bfa948228847bb45a04c86ee152147d6897f851baa270c0bab91c4aff4145b831136c1c65bc15c6e25a177baf20e1d0937502ade37045208780acf1a99c4a91ba4fd6025a7dc44413305e971222111129668a639411101b0974b62239643e526b080149f3fb9c1615f1f9a663a65439af34e84c38da406ba5dff26e857eb27c86155b5a4b8a022524192e4c38bc54d9b106e0e3d434a9aaa44d14e9dbb5c2b7b60a69c58166ef6ecd86fa0bd1e2e9c4ca6c8808030b9ba164eca4d8d09893ba54177abfdeb1ee96e0ecf554e6a1d448969ede30197581ee3f2e7aa6bcae2d13b0a6b78d1f6ca87535a1d0f63bad2523540496dcfe44a5d00e17651e6d2899629d60d3ee69482e0a3c4f8f5a339c630dba17017e79ed3fad77ff67c051417610da96846af117b124bde2760e25511edc550f49ff16d025532b74e4a4748a04a61a8372eab6707a1cfb711fbaff49109543be1890820bb8f9ee2df980d5a5e6a41bb669ec6160520be11fac9faf4bd9b0e4b3d86c290c94770d53a227807e32da23222f8b5169c74b3db114d147ef02b336a20aef435effaf4d69f71b7ea72dff922a0c0a1c551ec9cb0cc2a81055738dfaaaab76e54543b326e28bc20376295b5237a3879861f05991da71693bbd444433450c64752e7c98b9343a58833b8c703b6f6f7b57cad5ac81a13049d8f339ba23c65888df584fba8769c21d6ebc61fc450cbdc3c26c10c343af7a5140b103c513a95f59758a3800af5c3e743486e8ef995190913fb5eaf66807dd25d5bab75295204a0549ecd38880899e9abcfdc87b1786bbe0ce4596a30f8930570298fd994787852b0b8315f872d3f64a87abcd5c118412bbb5e770574940881dadaa0f62c1b00d0f13542921f621c0f77f0d14ffa5e3e0c49cc5d1c1959cc08eb536169040b2d25c1ad9f013e4c261491e65edec95ece6dbe6d37d5390e6dc5fc84891f896ce8c8fab4c536c5e85da67d7df169596fe5050f7d7df45bd42263025b4d099cd2358e2a304bc4e240a5256f6410103c2b021143538e3d8092599a45c67195c1a4e23110089e181e0e7e9b28cf8d3371a51279dc6a0a42969038485158c06ee033b4f71a511ef15d619a9a1aaa4c35e028fdf64c87b56f226e697e73da21d3dfd236d4cb035c5e17173ed16beb1c112420655f43c01bd3c18ae1145d4b9d5183caa751e0ff334f1350dd92b5729afbfe56631fb994844d9e86c0087733ce1f5a32a24b1348d448ae6d2f4221d887593daa8d73e3924a4b77bb973848ba1c60e3dd89cd647d953880b5ed0a1861faec84fef3a368de01301f4f50129db7c0ec48e3d18c8e39ea088d5d603a52268f4844ae1823326733bff04ca0246e1e4d353b3baf891bb70bbabfa3c288f36ae423dea57f2256aeb98dd934901d5606a9185a3d9b7292dc82448e05f6e776ca3d29b9bf2dad312b76099255542c4f1a8dca3cb1f6ade3676599c940750f63fe45da1ebdde5fe98e5c196a0ddc49b5076aa184ded4ede9ddfe61b90685e6476f65b62a5f0db6e865bf9a8e430a94469067dd751b656cb1ebbe152c7aab7ebfd5046f44c4e1439168afdaec70ad8e7fa98f9ae05a7b56f0277d16315a51e6aaa3df3e27fb273bb3b0313b50dc82e0964e25bfa42d761ee6fd9d4629297e0767c3782ec3c8c8dd7925cd382a078cb5436e53f989300a3706ca65895371dd433525b2b93468714fe62178f34c5191424cc5969a9ac79a4c23ae6e5ba3a92a07e41e6710a41469ad28cb65d63137b1f093196e6127470ed2e4089e135f8817d0c35a3fe24360ffcacad952ba9c7fbb3ab651bae846e56702304f61754ebc1551cb0d1e164da3664ad08eb2fff34dae9d6c2f1a4b38463f35eef2eb457f6ddc7719bb1afad24245225e25e268f25f1ec26171097af77e31203825d6451f282fb83509743159c25f31c7480e06135629496c75963ee64be0a8c54f253086ff51f7963b4cf3bf4a6f240faf64be09b1e4c7441c61b55d930bce5bdead65af7e46b139794d7c7022952a60db4897096fe569f7d3e9d8c2349638ea4198ce0e108bf64da369ce9b8b0be30771cf7090e142f08a08ab39984414b10847b58d0f6d5727578170b6868d0da7b35cf41aec5d636e25f526586ebdb9fccb60850ad744a90495370a46cc4b23636471798736d8a2911443988b57f21a0be634c46d0246d182540a26fa81730447a4a02b5167f7363dd6e3175c20149bb0fd115f091e48db0ab0e1a99443886fa9dfc9a46df29cfa5ab1267fed0f1ccd2dee3eb082cc597cf75fb422c8ef507d6fc6e9918a880ebd1fe667eb284e0e990148fd79e57821b8448b214f025b857234cabf1128f428e6815f0bf4be52939c8a2ed2915d77c11f20dd672320e0fafdc11b43f56ae611c8b40a7f800fcfbf30b40939ab1a4dcbc7029d6ee185c45cb8a33581b4d3adec7bd5f891a3324b975b608d576dd418ed5762399daf9500942a10565df01ea7c230949efb1b6f7a96e329c6836f8590ee766013ded7a00408dc4cdc49e99bd2fbfd984dab2f12e11293a9cc6c6086fe59d5133c9e2d3367b1484b3703df28a6c4218b5d0126e65ae07c0d5487ef6bbfe20f3d645ac3ce6105219a8b7f5ba7b34698db7cce26128c1d348233fbe662db1f5f288d788c907b3b5502a8ab35e4253ca39011d9815f627be25f2ea7780ebbe62ef5a572527e3712c4520df82ec33677cd9e7f0e2ad74e1d56c97d880b492b702913230ea379d15f0453e1ed740dfb874cc7798ea6017436e35b5ba79d6c2ef6d16bf34c96474dd3b544e6bec2c78b62c8a0b5790ac5259ba26796ef8aff95056c5f1872bd0fe6d4004f0ae41eb05b7b49ad407a6896bd76da1551f6b9bcefc49cd8283c099d2d82dac241a2c7f6c998ae65971d14a7ca2c687e3a6cd21584358eab15f85b14a90837a40c15472b96c290b9a1eca9d630939d190c5e60e49e82f41c5363175a54fd4c64d8a63dd98f04a3f9f6c48791ff3dd439eebeb998478b2a8234a202c61231e6dc4b8a55d3bc092296cf8cf2ef748cec26d637897be27550d7246a665ae57c4cf2d4474e1caf4983c386c957f05c1337df4a8bcd7d251df29a860eb4ca8f45a59b0c2855ebf1db91be1a1103fca0009cf26f6c7de05aad937f8593d1d6bb5e5a3fb0f7202c4ad3013c092432e27ec90ed787e5ece065cefa89e62d7e7bcf02fbc98b0a18a07ecb5b8274406d1e41dff46596f3ab7e0890bae3b11f81140b9738bb76df8e9c7f9ba71e07a9e18d71c6dc85ed799823731009090506e1242cfac0bc2a7b1779163561560647997022e04072cd4e68f6fbf2843c3abb5f51d9850283f8c4931b12e8258ec1b0906e09204b38c00533386fd9b4393dfc9a6394e695044222394504bdfe0090e93e2699e0c0e31df54fbfc9987c57b5f5a35849cb2d5c76c09f435944f08d5a5d9e67ae18b67470401cebccf71d9ee8c361439a62faf6fb558530d02227306f3d03a38aa104f99c7cf4994996a525b5103979093559738f44f66139b157f4fd4e0448ece0901868b5b43521951bf8a341e6f2c628cdf602a6e53f48d302b8c0ea2d865479cedecde6b62f2cde265b63e6a7d02b0066f1f0f966f57ff2d6bcb6f6c2d8fd832206fbd31e6a8159f595f7daf6c391eb61b84e26bb45c917f8c7d31c2e092ebc514046e2e6744c72a68c50842ace867ffc7c9f5f2fe441f25ce7ca141828a4913fa5638a44eefb0c3d9c9110853482f54746bf393fdfef6482c57a6d4e086143c8d45660f81510af995d623784a3528bb695e81ecf6a4e2745bfd54f5e0ba4acb14c4976b13bbe623d47046ad66297645fac2258b16f7c7d93b96e5da469cecb6832941d2a815de358429557e39e9ff9c4ebcbcc1786bcbeff3133d66c8c93e3580fa629b9ab78444db68fa29640469a020ec7e08ce1763a7719a967d03dad86899b1bdc90c9d344acac79049b72c810e906964c272c4ad536de1f3279c34555752a3af85c985a4c10d8e2a8953cfdd6be74e2941205fd52f77927cffc31db21e942ec6bccd81424b1156ff10f93a1426e461075a9eb6f0de391fe7e420e45e57356be0862c1ad093d0be44de07675e4f71","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
