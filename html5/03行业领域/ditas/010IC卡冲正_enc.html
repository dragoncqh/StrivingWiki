<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec877bce8353d92428c72192ef53a6e2413d08a78366c184b54373c8025ed6976d0a73b3e8ef0a610baf0f542fef9361d2e4a496ec3502c7ba5a6b9f3849a75ab3882f342a66fdbc8722a150914e3e74339785e003456b14089cf6ac41b73cfeee3b806aa14fb7c246d90766bbc2464ecb86cea1a2a051bb831a877037b65fd9a95f9b446113562bdf46bd60df9a4776e50040ae5b4027a6a28edc4a58970cd4f001ab366d6c5825bb12cc07f26585c58dab6a4c923aafc0871ce59359e4dcaa809300bc459bd5fbd99a1f76f11929f3b7e4fe51c44306582a8b72f51ca51fd493b8ba9a0ba004e8be499a296e776f7413bddb43a1b27aa47c3ce6f7adea5f8cea67658de3aacc9c17ffa6a9fdf6d4dbc8c280ab9983b82bbfae46cec631b1da637fee17e0e0c2f0a8e1b5e42448bf869790878558b2daafbe8ae39661cc32f0dd604a9bf68b56bf67f6a6f2befd94418ceec9f24ea15cfbe97f638c4107301fafc7a649167df1becb123a01024ebc04337f07e20d57323b6d812e24f4de0e134037832dfddd5372583879dcf2f75de93a5913bd66da4e214c6a4a606487e7b9740b64b1f1ae28adab80f7fcc18cef597c5dff927961212f0a9795b180f0dd4c619633853594801ca316dc23f5ffaf4c871821ea110ca288f855473e0f8a55bbdbd5a551f3b567e2c48b17e6e109def3be6e603551d5c1b959e6da79001d780104774290a65925d04aca92cf193c56f79f98c03d7ff24999aa4cc90182c215c5198d5a7d922091247d30fc47ec3c397281be6081880956604e164391c5a7509d227e94035d8df18aad702fdda8bbdb055fa2ee926b46e9e30d0bdd76da06bf3c34e17724d909d7db9e297464335c20c1b027f446d26298b7b081252ae5d3f2a6790eb1fbe0542cfd53842b82bf143ee7b980e4c08bdcfc151666838ca0087b03946108679c164c3cd3a56837c4e5682d2c532baad629b57cbdd77b29cb09ca60d6c40abfa6a9085ff5565f053e2c313c0a2f619464faf308832ddc1254268a87c612ce62b2e528d7ff458e5b458aa981450ccd1414d15e9d2203e30eaf3172961cc53b285abc76f1911b7f57eed8d7b99e54b9c0e426e95f88f461bafae1733faf7b9903cdf718ea1a51b0354718669cf8fe1f1368954858c39ce88b8292fac1e50b31e6be9a32f0f34ce0e041fe16ff9a787fe6c689013ae352bf5ea540d843f5cbc9ca05e644a48343e5b97b72e25dfd8162831c01e828667f64e80e9038610077767f58ca37d87288db95b45319ffc4cef65bb92ba8251f954f9b3bae8251920c28496830fe153e8b8e73c6c7abcd6c91f1a387ebafab14fd2ec899eef698570f99eef5a95c7be25534696eabdf21785df994b719a3c2e962e6fb0d6c8ceb341ff1938a8da4389754161e097eb476cac4770c03aecef563dc21d7ee288136ab36be098027d3f62d3a8aef8af2746cf16e5b346e80dbc2986041ee81e3530a8839d95269f3e4f98029223bfe581b75525a634942a80ebcf283d549303404be296f7c5271944680dced8490802c5896997f46ffce16004c5e23e19d5e115ba0351533552783908ea71be399ffedca356c672ed700166ea835ded5755cb368c8fb73b04b700fde53ee0205db011f441554da16f5add5660182553568f8ba0cc8de9c30d21078686daf0e1344e86bc6441fd328667bec39b22b00878f6571af7f67ee7c4559022f3b74ef2a14bef6b32c5c8266e8de66d58cd304ce0f2209bc41d02b0af5d25db377c1aeaa65b2729407e7a5310e287a4fdddb4867c816401de39f8ca7240e148099c78f2e281901bf0d7a64f88401c85de882e2972d4a0b1fb1d9f86c42f2d6d4ea6e9a1e9d7c079ce2eea625a5b0aac0b3897736447b47fc3e32d7e49706e2e6c089f5642a68336e4ab789226038e037737579ae15773dcc1843e36d8ceb4197fcf8e79f9c75926946ac2947aa46763d5be3fda5011c33a52f2d01ab6f54f62d6412e62f2650ba6a186bfacebff941dec0a8eb98ece1d7ad232d7c8ce19fa073c85b4970594b4a4b67788d44a7444de3888e83a88c6db861bef58ac57ed9e7c371cff5df6c366d776d4534e87b44c4b6017a5e6d18c67f06a5e73ae31e93e7bfb59ce7eea98dd33f469f4c5e82d51c9b83b5994572712e1fde312dd1b65ced15532203b25656f6faf86d9808118e89d146357d33f685fc61fe20445d6336e4067bc82d47e27c7a0cc168b052e532ea8595eec83888f8c4319466847f2a0c2e42ee6c518cc6c374cb7380852821b31503e8b11e4c9f0254f2797742ee7cf99d94948ad736b544d9dd022c37a64debb0a132a0eaf84bc4ca268f3ab4d43a21a261fcc67c3271893e29cbca38338e9123a378edb98e4f66804756461b381c6da31954d5dc668832987dcc13b771c6cf9329fe9b04e38529a698cc6427ccc9eace03e3e31fad478519acc2eb0f9be7c6fdb8863010a24267751c6e9140f9c3af1dd7138f756926ab6ea89d657a81be619b6b83433f3ed3465ab7753c53726e96d77c9163e39821c03fc8513150bb0cfcc7c8e01e18183e3b1549cd0d8409eddacacf80d9bb31e9e22bc361c73242c55f00309bdbc386ea17aeffef4c3a5a90d8511001792e1e8704c5bd59bc93171fdfff361235d63924d118ceca7d5d502527ee2f54c8293d0c4b508a951e41e9e0073884f45e91d4ce731e07d6cf3fdd6c10fd4a00d39822a44e86518922db9d21664eb010ab740579583087ce58d422d8dfa12a1a8074f7fbddf519aa52de5a74a64032e8a17cfb6d7edd9440b47cb2309b2187eeb30825ddcdccf2e05c7961eda8b44fa1eb778a7452a9fd7f5d81082a20be59e4466c26346df5d6db299073996882e6281e239539307eca4f4df5611734b9afd661ab411445daf40f28750ba076de482316a2ed7d5c6e74ce0ed0d1f475c85fba39685492b1fad0f5ae9a1f7c4742c8a10abf680d54f5babb9e79b8295ba13de5992df2725a143ed126b6bbf1a8f947282e88ef264f728718e0fb2ad6273e7e66073f1a9c5d296046ed634c75d1ccd650bca5cd213f4ad914e53708d0e1b3b5d873758de6490151738813501d56016a82eab6cd76b5375ba16fbf55336dab93426d3fa53ce4edcc5d8b9c165b9554deb40f2560bb8b80b635519c2bc1c3aaca25f39d2203728a166c3a212982c210275441564a9b10489107cd649af9d824a207f9018f722346039f72884de53e5f3b270b7ba3a3d007f8922cd6dfabf852b479071e5f2ab5865297a2b575292717d1929994e67dc1fd4c575e76d60ef84da1a6148647a1e337674f27db8f26c463ff8f0422d425d1f62fd56c8f0f7e2734831584ada08e598b42513519c9cf425776c164f9548ce125fe1da11a0b7220de83bf4de24e222e5574e6cfa8d90151aeb6feb465dc9fa11d77b04396ecdd03be09194cba8ec20a48992861e5652e316f440f8404387faf74477ae0b3404ac584f8b45936edacb2d9f1814ab7f40f46813c3257adf27d779202d77c87b1cb844772533a29bba8340e57f7c6bd5507d946142ea1375bd36fd83b3698d14d8af68a34f40c0244678cf8f159de819ef3a84851a132b9ce8c387151ea93439a9f6c783a24b9b67679089bd471d6b3a351d1ef6070b34558d8ffcc312537ed070eaf936839d944e69e52120cdd2254416da358a66c3fe2ad09cf55f77005c347f7fc832ac1aeefdb3055dd92716d343a79165e92b85de3f2cfe55c4218ac7db6e7a6f8c3a831155c6d7e0e0ad22410b1def59edd07a92af52a8eb25f85489108e8871618e31d3b7eebe6a99d66a960c1077cc1ef2182022c18ae7c9af52efb34298509dff855d71b8b435b2ff422af6b845543274fe48e55e8e07a688b36cd7eb663f9e176127793b48cf5105801cb64cfe7ade07945733c95cd35e96bac4d49788619d94a87ceb57bf64cc4962014c1a26529797cd0143b23fec0c52776c5e1c7c287dc2c5d4a27d8d01c4d9763e9e96c301aed8ea12648b5a4438d4d2709bad21d558cd653cf6838ed5ee4d2e6f6b2e95699a83af869b435c370e41e606d3edde1d56abc2f05b2f22381aa1f04e74a1b1742faf6897e4d9ad58f582aa447698d4358c7b248d7b8b551bc46eb8ee8851c4e6e7f07f44dd8a3b0a4be8b95d0ffaaaca2a5d8bb768fb0372d7f69ae282b7179d277cdc4e2fa4fff96deaeb2aeb9545f2cca6eb1b010deac255fb2499d1bbb31c1c0b19bbda3e11e50f0ebd7e6391e5faf387a153ab6b3d81cd67f084c02df1362cdf823126fff0bea319b6a17fcc004374f530c2a2ced51e54ca66521b219b1c0348ecdaca6545604b8a227335c42ed62cf4a0e35b10598f84290649696ddb0f691d9e360f071804364817c74d352a39e032e24c06df3889b7a3e57ed82e9883fd9f4361b3e9b5edd3ef9c8f1a158c64d4c8fb4144fabd5343f92d937a07bcde40d1a07bdefaa9ee13ebfcf9a179358f522624a4cbe6aeea462eec8522cd28a5afac030941fedfa16d1e46d70a85cf0dd1a357b3c01dce805b04a3cdb525c9cd1b65630d25b89678710886b949bfb63c6c145c2a12cdf2f76880841dc1d7246909c6c6e2902fe5a90d7ff27b7162c99158c6625570e9df0fa8e181c5c416d2e667cdc5dc40bfac5d201875e9348d757a71ef03cb5b4402609f40a06dca3328d6b562b2515746ca0997f222562ca63b16d0a621763389d7afe5d412eec8e4405a320ede2cf888b4f327b330d19ccaad59e62215eaf0472ca0eeee52c232fb1378afca6e16e52149dd63b01adf4cc747c2883ac1227e4edbad85dd9a72751831c738c4e601b80644ab40155334df908d1ceb91c88abbbb62d57cba9d97593d31bf1ee5fb6e9d9f5b318e8e24d37a61433bf016003f3e66771daafe8c34801b26dc1af00214716dc9cb277cb9629e2c9ccd4beea48f9dc5c323d36cafdcecbe8d0ff4e46a34938c4b5aab1adc91bc8316846e133b64df8848deb6de65c8971cdfdda7def025147eba20ad4b3e8c117be460d37b49c1806eef8200b8817ac32f62e13b0cf75c8ab8d342add2d88f0ddef52c0a84520f0bbe78ebf4d10c8d3362e736dedde33437dad76ac4ddff25adb63439bc130f3b961d6713d5c8d66cd179c555dbf0e5db634b40fb8c4b6ce8ce2c6f16f3d71b8d5a9f83e1d385a2fd1a892c483c57fa2c16b34dc48e8389447d2e5615182a8fa73a76cfc5ca14717cef8edc435cbdbe3f8e5f5ac92a758993c6865fb2bbb6799ba815a490552b6fe8427160b5109ecf7cdc5850575fa61b26b9d73c4ed3049abab54565504c7f13ef59cacff02f5bd8093b75c0e7de417c7c3da31f857331fca94534fb1f1c426019efeb403da4c77370b824abacc07dbf1060e7208d18bf2de7e6618030ad0fb9921917cfd91184468ceb380375151dddcac7d180105c5742038cfce7db0710f9e542b702619bc2451038f0e73f1ede2435f95d18f2ff120f8f30f5ab5fc29d2d32173da9222ab97601a961ed4dc733a758ae7cdd496b952eafa6a1f2a9eccec3d5936c9b58b5c4a04d02d6095197d76c242fcb4a0de7b62a074b60eb07db5f7cec7e4976ab48b1e16dd4ade8823135a8b09b895982329a49b4b1fc956cde67fd6aa96e80b259e3a2587fe6b6820940a5aee2ea4335bce4dc4a5d3ae3e8a30c82343f83a44b13f05dbe9926bce3d4501c2ad769d051be60c60c08faa328bf85a83fe3e923b98f572d06799bdcd5175956bced49bcd9553879c63e76aadc7ff4020a6634a70a803104e2e4c542fb0c3055b844ae1b478d84ab5d68bbeb7c130e8ea72ee210a0ae7eb43c4de7bfc2967803dc3294760c3a5fb3eb00357f772798d2906cb27d0c54d9fd80f4b7600c082d326684b310de029e5a38dada2530c219e157993dc62116b765e39b07ab3124aa19ec7e4d4cbf64a7f038ffc9fcf6ca5652d1d7fa0c8706aab45bdfbc710f929ddbe6b377f68095af12a5173a85d83715ee4ce83899b9606dcfb5df69358f7c05af05b4af47fb04bb2dbed2e77d5ae8bd72dc5acc0766b9017f5b99f5ab64aab49060e88da7fa38a332a11d6ac55c5ece0982791f2e95fd8ee51cea52c61abc715da5cd762fc47ee6deecf3ecbed382cb0c4ab1f158638e41898e2a11e01b980856b5122b8407bbcbf011326d71e7f4c07831dda5dca3b48177850afa72b995e0f1c258065e9b2177facf30dada76a97b61de642fa3cd6d9e0064939921e1f0f55d7d5fdebda6a7761fd0c4ca6d891239c7da88a3b53c811c53e674d24f7d311f987ad662ffbdfae5b86fcfc376538baa7c8ef3bcdfb47c0976dc79b55840e49869aba7ffb37a5b8f77650bb3e933cac6177c6a4809ac045766afbf3d4b7eccd08e6ba96718448372537fa700e0324778f24d55d6f3e566fb6b6042541e993cc24ddf1dbe39fc3fb910e04022394a699b59ec6fc8ad5c1b249e23db938cddcb62b4f7d5b7348e8555009e9739ce4baef2ae4a01ced1dc3b3826e5f2e8a88ecb2dad99d53f12581d71d4c27cb6ba32f020cb18ad872978d792f53ef9e64f7f3d8ee2c2f9b36251a453ed394e97fdc61afc560908adab48ac4d8612b4e813d70810f2e231e58b6767722c85532b6ce9ff23e0c608b82f9c5425cb24f94d255c98a639129ea5e38a579effe8bd7ed351219cca3db5ca0592e1383490e6fe8cc87b0530e1ea7d5a14890495174b004fdc155c3cd447463a7b2a63f498831229fe8b0ac573f32d0a196f3715c00186f04bd639bebdbb4ed34bd65203d2a74a7915dd67f5685665e49854fd374925781426c8772b39f0660aac867f054452484bd0dbd0053a9ead92ccb2e6da93135704e85abd1c02ed6b8078ef958b98ea415d46be1e68ca45c51995ede6c6bddc111243039e37d4fecb9852dccd5ea0c4ec4fa8f73b541fea049d0a78cac1ba51d93e07b9baac16d265f2fb1e1f53092cb4e384d7b1bb02f9e531e1c46a317415fe8ff413a404d458aab0f1871dad0e031cf9200668ef37b22977138832dc004adeb16bf9e31e3c2459e84b2048744323d28b88c01382cdd3075e9aa2bc910b67a7379a03002a5a733e1c98935ed05b128f3e0fc010b1648635c78f6a53434c9b6999a5c6d67f0ae7965d78a43cfbb1052e7fee94d18e9ba115f3d941abd223e4533df5c66c70686e0eb68868e791324f85e8865d5dfa2caf49a23da22637ad45113ea3e6224809be90c866077ae5a0f94f4915fc9956e28b79bce13a63b958bd09bc4622f5b3827315bf8f10f606db7e5cdf5286292e47817866d74a4ea6d2d99e6be101bfbcb74059af4dc2b70dfc6b875ca638011d44a1f4f795129b19605b678da00d30b39290156c873d17cceb4a17d4db9e90c61066cd4646c1e99d84700625f3ca72bec68e6130abcff24df263f648692c421ca68ee14a1b40479e0aadf5de49b4d374eb911b48625e0220cc25f0a023e9efce07362241d53ef96efb1e52352c961c449e7d2ff04907268885c29022fe075628d384e404b77a79cf99f1aac96878381a95f201237b56243836375878808a13b3550cc78bdf037df325415e73389d48a96d625c9fca2fad62434f197e0f090812641c8cca1057c55eddbbfd367ed1eceae2ad422583670f019874d95bef5737b2aa1de40077bab92bac39def11c7edcef1396c63a4cdec354ad4cb6a7b756e3f6f71f9a004d1cf2e795a1e280dc180d1a2b85123f4bda87ddd5e7e6c1911381f81efa51ed0fdfbcfdb1ff3bd73880cea01de108c53dce77d837b5e3a4357efcf0ff4c0f9baac5ada20d482c6b6c91758151b07dbe5ce3187176a835666b6da5be351564bdfa886092c2969b6fecc87bcedf4476d5a01454363904fd883ccd3713234fee147053b983f1e950ef2a8cb88c90fa450a3e6b31413e2cf41db6f5474078bc1908df70870222b562cf61e43dd1ce01ecddbcc0f5190f2e1279700ca770a137bd3bb463b758a4f2c33148877ad6b4adfad602f48fa341c964598fff7bff246b39fb807209e8bd8fab91f921f6d759529707957e65d670c1455db21500a4893cd67c3187c0ba6e10616605c32895eb49564f25dda4d7c7673e18e6483eae8b710ca34726704d20b720fe99a75d2a5211ae54be399f5824012255a0a6e3fc5d2687f5e0c5464a71f97605f552d8ebdbc6fa4692ee4de9d6a782cf77e393fcb930e7a646c005faec3bff268fb9336afd4c9fc55d34af6d9bce19216e2a69bd281be44ef3d05ce37ab1bf5c3dabd4da9c600a7265304bf2232529eea65d00048e063e6416ad60dbd1419ef04802c79d924b3367b38a9dad22b5db056a3cbc57b0f5c3c081ed3be15b3d8f2218cb80aabd7e6470b3965669c2362ba5873235128506031050200ac796d0a6f9597bebd10febe6db969a876390a6b728b50be2c0a484fd97b418d77049deaa5b715e9fb867af1abba88a0966236559a45296ceda103a9688099f12f35c8f631bead82d03b6a2eb147781a27d1ded34e1a7dc7ad3f937a3012025a700324c0ca867fa09a01cc00c10d0644ca9baf4715b4b8784966da0fcb522435c8fb6e43df15fa64b909c0f1f82df121cd52432a3ce358d20c8b2d94179cec530d25a1bfa6d226eccb7541b43776bb38c505361700a954c775ef5fcb465e7d9371f8a6b0eb46e549ea36571e4c5c340abb41f26cf8fe810a0f818e94040cff4be64059751c6a59137b769165fca56d6d2b504225e314374732934ab7f2c0a54fab42ff7369c94204b509bb07883184395a68ea70a4caba6bb117ee70a404d22aec2df9d9ac63a099b00e092d0f66d96b13d035dee9100d1e389e4c8da277ed3827c8d63ed7b1409cc49c419238a435a2f9463b825d8e799bf5895222baa441b155c6413b854ff67c97f303251ca491b679ab43f5493bf372483f585bba6ae506d28aca44c11a70de9d5ad1306803dd633ddab22ffdfd284b9cd43d68d6b8e19def3e23189a2538c373dc90605920e2ff039d29f88c7c5018da6bd5811e910245b8a5a72b45e1cab08c29f2362b7a3b0a20e6d31c596c0746883fb717989787efa36bd6fefecfae52e14d19de61e071eee9be7e35088fb78a7ebae617cb978596a43c01f7798e27735ec0acaa64091eb23b426281442516c1d70ae9cf42ee723fb2aaad4b91efb992d63f4b3a3a1f7c58bdc39f4c1d64a906dbe4330552d100a1b3e7dd60464021eed43247634d5cc3b3f120482ff29ec4f804148a8db34e35b1320f8b2d0bfda6a35eb7210ec9b49f59bd88a51ed626c446b8a1d5fb3f9b742a3f4f6ca7cc4176f782b879eb64d6639ceb73c7e52c9702e814aa0cddbc6d8f3b27c19c3b5192abf46b6fac1927c0466582c121a576c8e62c95af13282d1feb8182a9cd15d6b11c0930ee03b6c6a74a0173bf655fb6c26b476fa81552c2c3b8e56fd93c221d29f988f65a613c607b457e3dfbc0dc9a664d61b22278f6bae6e1d9daa1afc58822c4a2a3395ff8f892d34646b3466e58e8d97bf09af1f039b726db3bf0b2fa663d704166115e4fb66c92fa9342847455f07bfb63d6ef0eaeb7759a39630263417204c61a140d1fc54a71f9dba2f583477bbd8d6fa45cb305f08e82484af0cb94e02cbf42740908d60e5f640939f547dfa5ea4cf048d24806487341d482f7b43fe5d463b92b7eb27324844945b05101d6098fcd196742bd08a2b9249375762bd6316341e3934a3dfc4428d780adeb83f5f348db81cf15a73922dd3c5fa4365330976d2091568163f6251ee30eb5b3b5b347469801dc71d0ec01aeefe0954f30401653cf9963f80f6e62bdf0046022d0763b5de0cbea2c4e24b1004a827ec7fe57d0ceb87c45aaea27bb9437bceb21bf3f31a67c7554be999da80abd85a2e7d24ac47f0442cbd9fec22aafbaa8267c038b6ff5976f6741e28832a04c561a6d4d0c2b2a41e84b59db75dabec587cc981cfcffac03970271076abff3da3b8e425b7d12f974f9cb53e62657ffe280f6bb9db56ccbb9c9d0a302322ce1d0ab7fdf3cf07cf2efb5c16d8e5fc3a41912bf85bd4d6f671f711526a81f289629da25f16b44878412e93e14b4547fb3cb9ae7c7c0377697f9d33858d5542e8cc33df80b1c853f74b2b794f7ff06e11128cd07c93ee14a72998954c25376a19a2e63320861841424e2516114e49b95b4ea58701f6b33e0bec8b65afd99ea5e62708790e538151b3db3d26af6cc5027f44beede85407f352f365220a5a284558bb6965da54c246840f7ee0b0326a8a8c6fe7ccef7f412c58a6f3e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
