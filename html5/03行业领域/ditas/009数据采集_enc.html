<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"94897d4b01d27af95478c3fe779e5bfcadee8083b84130f981f5676bce6772cb6d29e37d1eab8258e8d79ce4605a865c203a77932fe4b5b8cf4c0b1107cce985e41793699c61a3694a0a7e7887c0949d59a4518fbf9a1aad1769d90f6ab7085db43e80b1b28f9c06000ff852db8e76555b0b9ac560ad7473050fed4c1b50073aa0e7c800ac42c8dda5326e3321559a46c4d008a511f1e59d905b6090370aecc3c70208cc3a34bd681f7c6e36bd7577804cc9adccc54ab33ff1d525446fcf39137ee918deb803467be65aaa29474ea3121c567539c17f17e675b470c0a4c11f56abb5e77452d59d1d0fbe7a7a2b8229adf0ce7dd42881ded2dbc2d655d709f4c1c260373c31992f653d4fc0ddb5e79e342991ad80756b8fcc0f72df494b4a41a6a29722abf967322d7a0293e38b8851e5e0a6db50bfba023caea75f702e463a7d2f7d0e682da4dfb25111621504c2e68cb8986a512d01831d0ea29abae62ad907b47b28185468c8759eaf22230093f6141f8e3bd0237f632ab2fda493d8a862cc79af1e5cca7c39f9d1245eab4d1faa7b16a20c5200397dd7e46f27623f641c78b07a74c41b377eb70b9a69a3b20e9acac93902bc98ea597ce4a5918ac66725e3fea708875f4e615f3528dfc21bc9202e7b7d79cf6d8ca6cf00e55e28be880318e87d0a7a5ee1e300b342ca6cec7305b42fcd6dceabb7a4638d3d768c2f54737079b759d4c5053e808157d0048d3aedb31a6d0a7e8f632974a23d576ebc9d75d32a5d721ad69d41a01b137746d2abe1d0faca64d2c411ad904f02da5fa869d9b1a5dfe8bfbc9372b528a2e6dd5b4f8fe71db6115f2ee5630306655dfd278e94259159b3da57c80abc731c240e13985f0dd3df1befdb1aae7e7c5d5770d33e07a6c538379db4f707c1e9a2e87044cd3744f19629aa711ce3fc14c319566683ba8fe151cb6cd14f8926bd149e65654fb215e170d4c5ab07755b6f2283504d3c4ee34b5f9cbf9fdc9275b9ef5afecb7c8ecdcee332ee5d0c3cddc5c42730ead4c05c8e7ef77e07d0af6a639d062021c3a768830df84fac2290b1b141f5cf5d3721cd1ceb3c4a5437a8c9b60b76204b042e42a23d51a24fb91d8626e972b6b3a70849662cd6474f251679ea2900c7836b1f0e4ca5d8a987f6cd2591cf21fd00f2d33a93fdc7a056dee57b6cfa042d24358c7c44450f401b894f4ff208f7a78c498459661710312536abe18212679e170f805754d31eb4a83f198e389c22490537d44e42290fd965c043537b418bd63bcad49fe94895af12b5df9c512b63848da0a1fc10094a08e6524993dedfd0d82c7d74c105ed64b930ac538f062ddce77f455b4a8c55ee9481724b5f53de41ff27aa0ae99500bc417b0441de433de342e0c0f2f72e8a02af049e49f2aada18fbd759e162042c52f3ac71a1289107df7341f8d6033680027bc6e490328391c29c6aedbf6240268d5b4cab69bb9a4ffd7b28d23b5a50f01bcb0b08303b18a494cfc0834aca7916a8bbd5076b9703b8880010d44f7e62aa22ebbbd0b53076b8f69f19691e415ca417059a49c884024607711e19b890adc056909f627f887408a66b57b86394861aaa587863fef62fa31e582be5b6f0474afbadd7d432fe1b5183a8ec4297e557a56539f9fcf4a977a4a71ca20b92c50935cbe9b999eb7d470dadccc73f59a1f2efd5fc549c8ddd0a2b4bf7f956e3b9bebd21445b2d7207a412a00408c5b57f37e73b1e8d0422b9f466a0a0fe8ab64ea8701c74613560834ee4a11174ca204fd145468ff3dae6167b185b9bf304e33bd730808cdce8ab341ac3010bb991187379eca5c0d4eb3d833299e2a211054c8e27a1bf92bbfe36c148dbe6e7ecf6474dacc8df278c9ff9a25141c140e9a64389494a512cbf96e924c2af00dd884706c799a5bdf5261c3cd367df6a7d23de6805244a5a12bc1ac5863c52e46634eef2e9c3fe993210a66804ddd136eb5b4e3baf17b12e4b8c288e57abefce3800d222fef38d045aacbe24b7f9f21e884220f1ab9c140bdddb8cae727bf78bd35224591b86ffa7b183905c6f19db7cee33ca7bb277a7a8534fc303bffb5ed70eaf23fbd5792d6bdd12cdf987ecac0c5ed29f8ddca0dbc72398d9e839231f35f5e271a900eae48bc1cd567234990b5f427c49e4cbc48223034c28ec89efb2c295b53853d4dbe5ce50e8be884e3854a9bf4ae32829b81b4b54703e1cfe41c1774f8b1f9bd527f1b820d7cc5b620347bd88a18140cd9f6194b3069fb05bde8fd8720a64ec74764102beee22ca284ccdc04c03ae3c3ac78708de30e2f00669c05aa47f49c4702c914626e2dbf62cbd9ad0fda64f06b2d1bd8102dd6ddc1196f8dbe66807118cac0dae2decc057a6e548ea1389be9b18c47fb3509e9b810e8927cb15369dd47d1269dadc106ad95ad7882bcb637548fed0524a8c609869b626f8c7a927daa7c0cdf9a8f9f2ab793ad679b260d6638fabc1b2cfd615a4d05c10b12e59547289fb8a7b3ad7f7d2579cb7c36b1238f6f163c90f6ffc81ba7d2e66a7667ddcdff053872881323668211c30f99d929c4395695c95e5247f7c77f69758b9e87b1f50171ea46fd9b5ee0995ec640f10c7c15f0deb1e9387568a2e908a5bb71d01a3edf958b551d173452d98e8291d5358a15dd5d0e64a4bd3efdec4f4a4e88848b8e640a56f1e36638091418226514dd4b343b562fbaa236e526fdada906831fb85885ddb392dcb9346aa63c7165f79540c6e5d292c08aa9934d13164e2632f46e2474451a99d6339457060018ac778372ae0a9c73eed9a6f956a0b324a272c52ce8c943e2d825a2d391b8df43593cf31f12dc6981f6ffa18638310b7f94ce953d02b83c6be7ac11d00fdaab90c0e0c2f7cdfb1ee87a644401a587c7bb78797f1e2fa581b77fafa63ac65c0b10d5cf7908d1190357f0fe3bdbb06424a89c044a112ac627fde5ce2d4cbe58ab3206d5b1a4cdab21ee50ae30e7359844caf63079beeff0eefd718750292a1a2cb8d9ce226981e8045e9b8b28fe7e0563f83f8704914777dd004802cdfb2a53b1bb9c07b3336cc7590fd5c1cebcf5a6710a7caa72630538cbff166c2c9a4961fadcd88c4227ece87619e6914fea43a58ac06a12e03f9f01750921cecc6a23c47240eb7ddf5c180499ccf71b1d1fb875c8a882b84efe2f8cfd945e09368ee65e4866c4161cd8f783ca85a6e410d2ae463460614556547f6f4bc04a793a0059eb92f16cef9a2db073ddadf284973a187087629c21348c84bad4df3850df2d485a6fc71f1ea5636d20c12e9990573e3e6d8255465099d04606693bb9f02c66a2e7713370839693ac9e74c830d4270d1ba9fc8990baead5da41414d44c0771533ab8d7df6fd98fdfd4c072fc4dd5dcb8e7ea24bdec8b90948cbbb41dea65f18de09a32b80d9f9b7f6321bc808786e408002c386629e3573dac555c0270b7aee4b15749d4685ca69dd64263dca67e28f3abeb8905fa9cd4ef1629fa8e76cb8ff97b4d7a16a81ccdd27e37238d4b6f84a136b4194110ee5eefde7015cfb8372c7f1067c569b5e80365c09c0ad74394f535b8ad499e4e42b7db3eb582b4497f9e078f9128483941b0d48e709e233c49f3530d59bd1048d94b69e09891532dea6e8fd946bcfe689d3c1281268b1be0402d038efeed2da64a80f988c40a2643f4aae053c04d3030146764abc1a0a9f3859013bd9825e35d3c1593351540d2c98917aaf22459e9ea59524e4c0503d4346e30ce12a72cf43e355f27959e88917389cb7bf425f2fc02ff7b4e26aade0298a3657af7e4d832c6ec6911c5b56976f98183022e843a401d89cf7a47ae6d0427de0d5820c33cf036097fe84048ef94cfa38365668054381cb3b97767396b8b2242702e71ba1310db79fbb5cb93cd5868f6aa0404f8707cac27c3f6d61a42561d09c679b21ffddf95df4c473d94b4b413d4a0be62e7bb5ad558f1f8eaba7b8429f6b60ea0eb8320d9bb1816298a2045b3e8ebf06d6803b0e2dc84044ce6ad39825f6f2d59240d57cd26dae5bd572797da139abd409dac2792d9d2cde9d76c709001bec70b168842fdb448aa44adacee41ea901ca93b55662596f71f9b5d3257b1390983e9d601bfcbb55540b9c2c3c15a6384374f1c83b32bae216035d55461f11c8fa120658849b7a95d66f0befacacaa2cc8d8fd36b91b983fb27582587d6d9d9fccbf54ff374b7febb70bca5c836facebc6c683767dad7a1d7c22e659fba6fda05846e7e06344db925a09d01b336403ddc696a3afaa064bc5bfad4916fc700796bb97f4cd9fa57cd6a0fcc944eb6f23a4830270311e206c8c532f625ad40818619d5c2c4f8bbf307f1fae91554ceea1db3c32cc35ae2efd49a4de00a0f3657357ac28c6ac0266feb245d53cc0b49406173f702c8beb6175594219cd82436de26c8e5e97619ab8920eaac390c1fefcb311db7fbff44f0de72c6da4eb2bd43d9d2c48680873f89b0b75056f17ba6f23aff19200f075468df462673a8f23788f9a64878786fdb23b12f7aa24e492a115106d788549ab37d1fd2294e4be9c745507decdbf80623699e46987cfc38eaec3ba2dc34e40f0c8f342f615fd0e8344e2f08d75dbaa99f592ee09748f7cc64fda459065c7a0231c2e3c6c57fd0997ebd6e023d2e633fa559b75171420f2c65df3b90026b589822d5f83748618330f7a4d17932ae9ddd79983cd03c2d49ef63567348803c9d0c7b9c28f4ac60ab269871d0cc4f6fa9210fc82d03a26b639c77125620be0681c377f257ae79ad4ae8585a5e0b016a23352b403c8d381e97af2ea9f107cd0a13b897eb455cc2a4f2a864ca042478fe5c61c0f5a0a04b5e7baab5cd79d433d7900be70be1050ec9a9d701198a20bcfd0a1f3530ecd9de9fb44dedb875905323cb4ef7d9217544166ba39f747963538745a9985bf07aa139ff62fdcc9d11a76a326cdf4076f0a1721101f4203e0671c614e13880cb3265765873c59afd87642e3c178d64cc093d65c75433d4c36d27f60e7c3513d7edd56947a7b83477b1bc141c77f96f7f952e7ed855284b436638b349fb93eea5a8322942d03701cd2dfed648ba7010b2c3c3fbb6d0fe6040b2a938223a37d78ffc3b37c89d695492b4fbf3275db3731724d2afe0357f0a4f101955aeda396b7096d8deea885ac6072f9ee9a2d21470ec28410e003e1d283d0b61a8ab9fc7ef6ca17622decac089bd406c4cc873c0b552fdb469268b58f2ce8f3047adbea8cf60d626d1a38253946ec64f3700dbe3fe6f1708b6efdd73d4f7c7f2c8d402a86bbb0445e164f45abf8564bc41ba6726f9031975376ff713879c408c5ba275c7e6477080057e4ad4a3eebd2c1ea6896c6535611b7a4dff923dfebda371379c18fe0ce829b2754320b0ead67e11a81e494cfbf628f5d63c94942095544c85e1c5d639ec051e6b6b020a97e29edc253e5451f21366aacb1bf3c39b424326de2d12ade2a621ef2767ce20e9035389f761b528cc5eb00c1129dcc1935cca68c1bfdb1bc3e23bf388494758ab37625ada79c0b0c014b7927e78dce838ce0f2c1c734e90e0c7d955cad17c5469a84be535189d6936abf585451409d6d2e5f06fdf43958a8f502cc4c11f4d066da1860d806721f2c0988dd6da36936cb7aae9b0254ee65fc40e8a6cf5934adab8e9a1f3485ee8b4ce82c459fa87d74dc243e4f1b9a897fde26375966ca456479f96072574b3c2a0562c6f5b381120f3e004bc1d5491b123b613df339245299ee66b94836cc75720dd73e0799363d5b8a94422c0e85faf262de15d16e98b30d1978f773e7a7ecad121cbfb07233e70e958f2dd11cfb7712bbcd483a5eba17fdd6a8de0c058bd26bc9b7d4ddad1845231f324b3051ee4253340511680690775b8bab1a402e268509b9190a7b1ad28bea3297e58f60083a9ed58feb5380367ab968ae62c4abc870178b7679249bf94d71114a1619fe397603c39fa7c83edf5cdc5a9f27bc9d69dda04cab6df527ce23ae98202deadfd7dc37213807ea7589cae6b95358fd3c2d700175624abbbacabecfc5d50f39b9947b8b9a2c0620b4c02f50d55f76cc249e88e23ac41f09d9a20dcb05463dddca3ed5ca1060bf364de46f6eee6db342e781b3fe46c0847c0bd55bc3443533a6a0e871e4325532204c28d9b45d0b03c993b81877a6a4e67626ae6dd6314eca2f923acf0545f5f0358080c3dce3bcd61a449b025ade1541718e0b731e2b0076fc6015b1db3d87e745cc5473d2edf1ea009076ec66e4d7b80affe52b9853f399731cb47d1680bbb4b61f2929b3d8b2808f7c4a09389d10d2a0a5c4594d7eb548a1305501acbe3875bce68467ddcd09e820388fd387752130837a28307f47e27b19aa4391cc5b203e4c72d30d32c10589fed6641299c61b55197f384ca72f4360154dc1a391fad641465daed36afb9821b5856aa4b4bff2a3091bb19fa90dc6fc9b9e4742cd455e27caaaf8bfc6aef96b0204c0f67094e5bd75eea01457d6e86ff475422c8a9ee21ba73eb3f5df319faa1dbe3e4f1c14499b888e1321e4a173a66571b1b891426d0c3094a91a6bbd44cbff968c4a2f352243e1dd70ddd6f62ab026d05a3448f00c43c2308a2d8d810f32da7ae62afe97a9395e2aafee263b195944cef555e38a79b6cffe9a88b5dc861e9f25f6a91d6be6e6d73e4aef1e0a5c7f82d135c99b63eb8d9cca67da0c75dc0afb05bd96382a65bb42d3df8dd9ab1da42430ddb5fb39c0f439dcdb4245f699ff60b01597ece3335d1cd4c48080a1cc644f92dc754e99bcc70ee7c3cc1e6134fe417f60239d51540e82c9d388096a164f54c9402d16c4e68159c2e9ea4e073c80517655c830c100e9b8d7b6a12c83cba3a254679570408c3211b9004e0bd587ce92589639c25f52e0426390826e5266571ea4e868f1ad102c93435ed969a919022f246acf4be878de1e0482e5db2df49a4ae49b1847c7f21e2fe1cef5a2d8fd2d6204efecfb108fd22853b95579daf2bb01f55d6cd26fcdb3a08a4cf4f0da5786b3ca9d23e84d02162964f8861d4a3a6b540d5d0ad6bd4afeafc3d22da39278bfd5fc990d41de05447385e443c051cfc457f86ea71bac8ce561f98000b65a453725b54d9abb3cc77a62551bea5c093a04431f4ddc05fd13d78a73531cde1ac4473ecdbc8f3a6782f2afd497da0bf530a9246ae08565559c727757d120a28613f0197eae1ef8d60a9a0a492f28dbb61d08ceeaef82110fddda5d7ad55acb1bd31a3926d18040d2b440032c783d05ba0aa289a3e79343c4d7b8360b7810a3e487f3a15d89c9b32036509275831a0787eb8ff760cc822c900575de08de6d675809b04254682c08f1e7b64861456ba17a6e21c697474eacdcbeb869dd66d4286dd9c10be74d4b608e552c18eb8362e5d2a349d285e3cb88e41a5c609a993692e30c5919430ba3262b384e2325ba85d4d3d299c0ca6a546a261d47fc3eb6b9614ad0294675108cc9ac53c4318087eaf431b2f8ca34c15dad972830816ec61af1d56ec97fb6947c5463757cfb39727cce638d7a08c62c9a149a63b320d53befe858ddac2794fb8364dca6e032fe15d34a6237e8c5b36767ba3b850c6a6fa179b46cc8e850fc6e53319732cc010ad27ecf4b434aac1caefbe92ca829d1e00529e9cb5304f7da16935ea9095fded418cee501f0b24194677242a464cb392d128568b2704209507dfd61bbdda1a8c47564251cd3c73fddcbe8790c60276a85ce857ee9f97c704b34bf7caf9fbeefac78bae21a6514f4851e9c030354b2b01b48716c6db1cd211f692505022cd1e97396a045bac31e5fb6ab61c5c9bbe161297f764ea5ac8d10a9a71460babe3f9113b6f19687321651a8eb8b5b6e96d08b41012fb944eafaf7f2d1a46700b3436ac88ba8a1d202d3f2c676cb04b319ded5921a8841e07a403c9c77c81c00a0a039259487307d10820aeb5b726f496a3294a9d336799dcdc2e859b792d8f72bb6da12fc7650d65051a7a8a75e23b4a1fadaba0565fd3db26bdb1ff8b7dd2c85980fe0dfe373f7cec3b92eb745c40d2dd5a9e4424bf0911522a1b053efd8c8493048ba02d120b9dd06bc7a24dad23cb53a3a1036d30799024cdece04fb97a4de685a9437d74329c43f3e123985d25fb7bd9ff4096953f7658ff90b8066f890cbdb5ec65f2616659f6209cd7f7e457bff176fbfd21552c07a898742eb66e6eb8b53a48cd4aa0fcd966beb6eb9320fbbf4645b5c94c3df12be072764d52d1aa3b1619e10e3e272a183158c48621e969a7aff8939a17026948a32a4a3acf249d0c6b8c635a2ed9e724f6553204a78f4b1dd23031cc3f4cb0929c6138cb45b71b1b3054f9a694477c311485dce783646b2defa6464d0b25791c57e06706281a754c370dec3f2c2191574771b51072bfb97b2575b08549cebde13713a8f780d313f411f804964496942f4b471c46ab0b70470e76414a7c924bf88f99733687e57c42183156c3be9645386bf3fb18acac6f1d678d5bc3c5d22e89743811ac29e8cdefe9b51ede61e228858d05f005a6b39f4b0ca8b73d639c2c182d07fbb7c534ba9048a3a8c57fc301a3f8f04c113058723ac648ed73827f667161f29776e26b4d11da6b8f43dca72fff661b258b5b1384fe927edf4049b528e17396e425d799c8b7a28d453fab63ebaaab5104dbf6bbafc4ba631ee909ecaf1bd974f68f4e483cd24768eab0ed6ce5b8f3e16309027e671b179ecda42d1c36e00a6a9c536c11c4ffe7eddfb8378f7ec406801bb758f6600108f99eda46acaf8147b0d7eebea44700e00ac01efe3ac0d6fcd7e9fa9d2d54dede4b3a8f68e14e2b3be1b2f17e4c5b7ee4c4e2f93b5b5fbe1770fe80a8a754b3ef45607193c43ec16a479dc8ec8cb2f62cbd1c9217e69cc60cb38142367428422aa155b1545ff34c1876216ea2d2e35bef29e5fce0a75ceee57b9a63ab5750e789d27e785240bd88fa3f7c95ceb527613404f17e431d37eed44f4699ec9b61e33e9735c7d311d4670dfdd6b0bc7c7ad51076a3eb70e615a1105ac642e07dd103c099973327fa6cc18eb329402a27c0a20f20d1677db49daea2cdfdc2237daf3ebe8e3546b6126036198841d1e135bb9b7a1b6c6723d490d91703a47685d2999a6995a16f965488eea76bf8e62545b6f9b0e199fb42f99db581e10ced71f5c3e87579eb08b05adffd4435966af5f4bba9ac3cab71e76b122d357f809ffcbfe0b78c843c33c3ffdf27ade2e641eda517c698d9bb77d3bc4f3746bb340b31b7e4e010b81f67dd27f7b01ae50851bcf00a50a19ebe8946d6a7200e4c360a87d63d6784abab50b61de83c961bcd2e6c2ca9a79967265ae495bfef73ce43e3070319bb0aec5a94399ba512ccd232721a7e84a5fdd4bf89a7b36626e091a86178596f31a9bf84164ea1c227fb6dbc38813b481cc151b06591d8500ecb8a5c842bb87d048d22e66572b1230a3039837b536e686af2da49106c01c60f1171385c4314f3bafc990a43e2c2cdc8fe9eba1f6cc94a2cbb5f65cbf8872c84026b1e6be0086bfa1a630274c212a9cffde16f19add024edc8c91e923adc282223255ccabfded5acb386367d64440a061543d993f2ba33a91e59320f1b522fc67e4f7dc4316219162e5ca582258721958ef4bdc0f6043050493430795f3a5618ab4831e829f76c122cbfc2a556c124bb52a36439e0950cab748c27a24562bb1176c1f55419e0eb1e0581e93a541768e6a582aa1e26e740e897ba128358f1cc7d9c803b3c38439e0112e9c3f6198db49327bab846bba1b194d08b83ad5ef2fc7e60f977282b06d884cc91b94f87956e1246000d1d1b555130d1bb17947228fd670193472da38f87282c0276368483917fb4197b33474e321362cef42946fe712620df182a05514028b97ae51b730d09121015be16e107b4bec062fdb3267099b111dcc687f70b904758d3ede5681e4e50a8048769c0d32066308597a312cc7d19e49ab7db7cdfbf80d2cea2a921694c03bb801d52dd7f295f983c6e13d4b6961535386ed29fb0f3dff9c1615d5143fc4424f1dfda83483f76c2bf2b3a85d6f262867c7a9b07f7970bc843bd103b1a7302a046efda322639b19607267e6c1b2d66c377dc53b914efa2976ced52c1083da1e61a1af2ae37bafbdc7685e49d86e2e1ee446ef969d2e092f986ac153c1841809b313c76ddeb7268a9949789325650b62e6409f1554f327b20dd52aee442c84fbb5e0ce075584f49b8fa7a1be08a918194f356fb9a7926e85c424b5aa0216389ea104b4328781376567cee9a73f981ffe85c76e1d59fbdd85cef4aff59f51080b4d7f340e09151468c145f1a03271d3d2d6945abdd536a89b30ac06f2076f13491ae4cb622e1d455ed46212ff4aac11dc81e14ae1c3b102dbcfe09cac16e9f9bf89b19c6c297817d9af0c1d1b62ccc6c2be51ecc813765ec891500a52676418fdfc238c6409f6a45170dc88ba7baec5209d19ffdd7d4e6175dad99873e81ef433522795b00e9734da47eff3b5768895be06e5cc180dc373ccef1d45657d9acf2e7b75f84b5bb6d075d0df1d511528b44e82901ac7bfd450a6b6ed09ba3bb32deb00556818e1c637be555a5c9a19084563994c6fe840fdafc192dc4e9bfbae99bc5c1a6ecf9abca373e9c12055cda97596b64ff15c3865853b0b00d6460d40483fe972a00fe05e73204b5d1640f16b2fa426387d5b5512201717b10d4da7b7c46981f1611c49407cc8213fc0e39b41b368226ee2cf2872adae20668c12d038a5de5caad87f84a836da9151b69a5be25b077b7b114a36080d2e851260e1d64ab982b2136e2559c64b83df0c861c74b5e416bbc12f5f891501f72d4a856c9f16bdf13fd687593b95ee38a4ff16b506ad41c98dce724092b85513f48aae90e2c5a038d2a223bcf23fead841db37faf6bc3c2193377cf6ca29244b5a16ae17c5569ddc1372a4344ded9d7924c7a70d3274b7e0fd49f380284ae82f27ea0836be51bef45aef5c5a741739ef7627954e8b7dbcf217fc37e0150c8b9a56c82e26bb3d68ba11bd7bb73147530913a6d3c36d8073baa8f28974db87c638aca4126bb4a0bc7f9c2b3c0c1eff7565efcc79b56d85d7facc8897f721ccfcf15e03db43758160f6f37b6b4411c995b269c3ad1e20b6fa5056faaf8b181a1b989978ba58fdc7ba87a81d9bf76820d26014fa2e4cf1505922accc656691adfc9b2aa827e296ed79c17ae0bfee08d2a90f5c7efea29feedb7fa5e4a17b5f310e223f4233cf963c8110b51926cedcd544e92412390d03b0f68eee93cf72b1347252f7dcf60f0195290000933aeb76ac1fccf4ce927e18cc9aeedc393165f03d6df70ef6d4495080fb5e304dc496aebbbdeb827624a1730327d612b85ff2c37ca5db351f304d5e8ca4547e8e04c44d11693c0ea3cd6f47e7fc63ee6095c6d943dbc3501c06df26e146c32ee1fd4628d52ef932c5cd8aff74ced1a3e76600fb015e5f29fa8197e2bbdbb21fb0142bb48f186985d1c5609ffbee2f3dde2f904f1c33e6a5201a48908e805f2d1ecd4550686f59bdf4d270522d9246e694f59a8f2f17d9c6f11f10eecfc1bf2b4ab04ea0b15c14fac314ede97d84b7fba73ea2696e625f76c6d3b15de7d9f56ac1bef7d865d2e42a0ef2ecbeb9849a471e19306e12ef8098455c7021fbaa74da82cee2ee068f576f899a26deb4e796ba9e42ed141d91ac1d3bd77f696646bdccebdaed9d7d5e31ed748b68974a42d18a65da936c2585619baab44813790d371e524fb67313c955d99e1347e489c08c0c4151eef1f49efa5fe1bc8aec6506162d9437113cb7b6a620ccc9ed9f9c80c50bb9a080795e14f5fe1b0aac7277fb5b60742b9c6d02c04ff3dd511866b53df065dacb9a9f34db44c9b00e8eec0ffa2d80ef5a8326aae2524d018b78e0c9c51d8f30d80db432a77fdb4e050c8a47a20550528b56d271675688c9a2c613df371641e359d446df10cdd0ff3f12d4f03f85a09aead7b2feb4231dc2227e4d6b637e0baa72b1657c2d76fa122002aab9775ced0b9d290439358deeed7695d14b88b993c0442f119f7bcc5fa7cbf0d8d73095f52f7d8be4cb80e1da67f028721d3dca7b536ba875e0eccce1a13840870589dfb4a9bbadf14c72b59fd6380fe016244e1d841660750c9815dc32f9a6b985f6f51617aa81461af23d73d87f2a107fb3f92ed739d3ba61c4eee485e64dc953e4f7e2c98d613ebf5d77d502c4b991ab0b284f6c7ec8ee6bedd192ff70c76879fe18fdbdc60ca70c209ccd17b71701de1e0a69dc90e5dc237011628d7b7b467e63995d1faeae148aeb58ae9be206881e0ed74263df3d82f28f0edb1c17616a6cc5d973e1abd614af94678cb8a2b5ce241923c36a0d210d05bae1648526d15e46ccbac249f8781c8291cb39dbcda932933f092f69a10b2bd0516fd9504be182a18722be476a02478cf02085aaf6407dc453ce29dd809aba4ccbfbf935d4dd38b06b1dc5fac050ddc3aa773e334d8ed67ce1fb44036d4d474ccb10b39fa94d6989f27e2ed95ae5bdfe1bc22aa3eff8c3d5f36dd8b849bcef8050c737c15cf082a676f600b2beb552357d973d0708746cfce88302ebbad7af50aadba42820a13239aafe314751946a314c28460f1f00811755eb0c9fdfeac9586f9cd24c6f1f57c1702731b5e51f610c5a141851f78b1cc281e2389b487412c5568fbf82395d4ec82e9c1028405e1cc1829e49a46e38fa89edf260a440cdbe478a0bb6951efcac971a2948a9f1eb8d9998f3441bd1bb6971264d234daaa783eb7eb19b55a1d6a51091e247d1f824cb6f9c49b9eea76ca454619826850bdf040a19a0bdfa97cbdfd940c2d9e781095a5ed1ba02a3bb4d353209d9d7aa7981c7c59b0c8a6d9f5381597fa39ba7e4763970b9eb3a6fae862e94f0cbac2c7a49a78e51513fe3e1e90c2f964eb8316c7c390797bf00b5a39009c508cad8cfd2e303bb01bae579882cb2968a4d7be9740ae2c545ed47ddbb7d7a60f1a3011a7f62da2154dff37dc67e9f215a24e9db6c451a27bee6ec48253a29f2fce7bd0d3b7dba2c379ff511a02a7dd84721fa116eb008686c19050f0c04c85d2ae5d1e14ed1dadcfa35405603636d4cf18a6532d1178b1308ed26102c1b6f4bcd239ce88b71b3043fe3d0f815389172489f0e07b1275c83f96727c0b52f24f691e56a0fcfadf68f796a7c5e8e93ba00eb533ead81ee3dcd5b1d973a109212df07190ea284641b459228127051027675bbb8eb6708436676abe5e06ca9cbbf41f9bffbea18cb5ff6f906835ecb29b8a4d6a6f2819927bae5aa212f1f287b5c078a491ba7568f870dcca9dc2231e2ed768cba4ffe06993192bab2d25289f9d4df3852ed2cf5330f70209e9a122feace7e16a99c38ef0d56273d46c4d3e3cd9233258a4c466886f8f4c616b9b7dcd2e2be1deb2bef035153fd1e26eddd640ec26236e98504142a55a25cae876cd9fd67448d826cd1e0e287c5ed45866127e57fca9c19affb168b7c6c3cddb61079cd6ee7a6ee3827839b5de62a299d43a99a910d90b20e37006823334a2765b531fc5f542641c9d673b3d46b04c86438ad4d7141493104baff7ff3703b7e48794a77430055bb9816b33a7c24a507746f52e6131a2e527eea8d4f011fa6432d1b9bb5ed35f7dd425d73bd4e6650c55b5d7535e19d20c15fa96c7c82c67e6feb37f5f23c47097b53cd6a21856dafd73fa149ab265dfe4c8da6416542596dfb410c720f6b99c5754bbbcf93a18ee3c28920faf18b8398b5fea22e859b7ec5d36ea494865f365363502125fe11c470f3ddf893c8a1df0de6a500fb6d28e12580a82b55022e76ea67a5810431f5224fc7f1940048e1ff19931b47344f9e8c711066ae5ce0de6f99c703f2cbfc3161e232c17506b549e182490b14dc499f9a2d3240dbfc990e2c27af30e9e2437f4e3b1e2b36ccee85ee287b2b9d78accff0ab070aa31643dfd123d4d8919eeb8c9428e0904bfcfb2bb059a2bbc65ef8cc094d52e3cc8efa78e2ebc0830eff95d1f19c663ec221f722f66eb5197830ff03c1978c60a4c4dbe839aa29573f21303e51715ce8a6ce0e4901173e44e016018b3a13df529fb911f1b0ecf71ecb9decf71ba2ca3fdfa696be43511d2e32f9c67b6e80067964b1ec65cd707a56faa04e16f972fb39620a4218c5d169b7f112fe97685f83b798531fd6f5ff8bfc82215547f1b9a875da3909511c7de152b210631373a1e03bdd6cb6c85950105c5ab6b8683815d56dd4c1be6c2a15a868aa317263f8aa0701584311a2665061c694f39f91fe407ca29db3d30572e7666f7fe313b07e75a96a362637f48d3b8a8086c04b06638a4d9aba91aaca51144ba810e193c7c8f6f719a604ae172aef23c614d3ad387e40f991966529ba6d7fe93834e71726235db574de10202bbadce9989ef417de5c325fa45c0fbf24fa0a364d11af76cf977fa606d2b469f59950b7ed576d5d69788327570e67e15cbad489574b7b3ce32cfdbbdd9228260556806848f2c7b74f8b66390bb1000e7e50973e4cbf8924c6149e8e143088e6b7c9bcb0c7a70b2adcd969629f078b7dd5abd9d2e6b548153ead18692e83066109d7c5bb16b3f13d44410a150b4f47527fbd823787692eab4aa21e78bcf8e2e3805611716b03d45bcd6764f62bc9890d075a18a473ce8d7f6574c62074f1c1d6d0d3dedd1ec8c44a995c0e6696dbf11e044269317c56ad3d421abddc9e57252521be448bd0d5f43a1418c80896fb48b0db11625cf8a6f9a531665a2e66d6022ae028bc989b6dfa9e1d94266c6209448e4f45858a1057d4a5704bb3eb4be118656c8143898e732dda1e831d5b6d605f3c9742950f77e2119ce751f8af52cde9468944b6013c315bf9ad8fe80bf7e2caab1eba14bafe521baaa43b0f0f5b25933e1a3d4b4fecc7ac3653a3d3df8736eacd69b152ea922586f2e6695c8a5a55d55757f9fa74a233d8f8ced45bbcc55baa30e782688cd74d3943bb23b8f3c684517c00089b2faf6a92dd18e0994ada53dc92361d92ba224af60f07e01e88006182d331ced3a85ab667ba6afd02e195588f933f6488a3b8a4f1ce2e7c8b87361db7768b305cc43b10f42885655f4997741e26e3dfbf6612ad5ad95f39cb3e41af761ec0386e3da41afd01757e33909792a4558e328c5fa669d73454e2c1114642a5177ecef93ba73e61740ea4bf8604b10aead997d0b4302ec9b82a27788b5419eab1b16239f8122540aa26cda93d709ac34f39aec234047de62470195badd1dcf82c0c26c86d2fc183aeae1d3933218198f2be0444ba17243a7eb304e9f5cef922112f5b48fd72e3a1c46fb44820b118332e232fa6dd9a9adbc79c4ee7e462af6f2df193f0c4a2c2e4210cb42e0fffbb31dbf3a73bbb58370be427683d0c6d30eeb8d1c7144e28e81d304bb5dcb4f48a32b893980c94becd94fa92cdf226f93a1acdd762861825498ed5d4c3e3369d3ed0e54e512b48800dd586f132266da6085b77737ad3e63e16e3862a2d7dfeee142822dd5fa429b8b5a5527cc4751ba84011024540d7ec5de69f7351c15e34f6e430fd91670da8d28ac944492cecc85c4d7ab18643dde58c636dd02717feb954a1fa098881142a3e4a447468aff3bf8549efc5da3160a009372317ee384bb0288cf3ae5c8b37e0393af87108e265f3526323ba88091d86b28e1dcd4cd341aa2aa0702961b426e6c0e2d4f855b988ebf50a1ed3ac7f7470291729f43a6ab7e9cab58fb5d4266dead73179109674f239d29d5e22bcdd96f9edbec2a30c5f08a1b94079023f31bf0666d2653f1a025d14ff60a1f99af717b9fa13b7808066bca545a2cc5f83805cc0196741f5f3d154772d6968ce6018d6b07e80e91309a127cc185923c01916a12f6abf8f08b56d4215099be1b273569d7587bf066997fcc62d8de7593e9665aa6491099ac864dd6575d18f38867c83e828572e4fb8f616c704e255e61cec808c238919a77b53bd555b0eff98920bf2e7e07959f95d92e70439753284afb42272c0f9ab33c6beee117db633edb05207f614a5debc09a55c40fb7fc3e711f8cc8454d90987eab309aee239d321b47dd81fe8c78af9c13717c76ec6d34bebd8939ddb6c75c4cc39a3669322ba4642318e0cc0bd282c8a9ed4efbb6fc4adffcf5d963b09329bcb35f64eb90705244340233e614a6678c0188d024dcf215d17c8efeb6ec3e454b311a0581f31bc5b05c16bc76f6c8d96ac41579d0af3e16f56902274887561a289d90b0a91a17ce9531c50e706eac00d74a17ef2fe7afcb62c1b1c1ef1704699e28add0b3cf7364a75bba501df96ac6973b72965d6ee519373cb491624e0e5433c95e06825049e2f416ad36158d4299696a3c6535970e087324eaf818d71ccf36f9e50be19fa4315ffd41466cea2d202acf95edf7c4822a3eda13a6e724dc7c46923fffc650e6e8ec8435ede7e218c9933e17957248eadd0d962a691f30ef1c064b005777b758a3fa2da8274e27f3fd8bf39bad17f8bdd6c89114db8cc46ba07eede619e4a71cca236409eeff2d91cbeedc810ed3c0ce70658111e76147a2f6878c80beea1219edb8c79902a434712075c649221eb3a94dd6de7d37821888c267da0ce660c038679f172c1ab88a46ed806ee7ee41cdf40519f99d8f9fed5fe3449949b68d486826ddbc2840b86c74bda101e686aa3c6ce006bbd51b9cfb6228386be8dcd2dd6f57d24cef3c2206f2279275ca9b1548b9cee0679c813270f8559b871bb29f7d1775ed3cbb7432e5068a334fa75927f87a29150140f119d3d3e9cd080f34129b21f51ef8a6d8f36367f2c1287c913672e1236f95237621fc6032011a3aa3f3c9587a88dbbf101495ae3c195f3d0613574e6c958f02797de6f17c2030bc5dfa9cf1df84d53eb0b18ad80fbfa730312c15dd0d67d63fcd819a9b415563fb65ab3ae171d09841b8dcee16ce88d6a1c6495f08b7d59cf0f439d9c20f39ccfb85ba84ed639daa743337c8c3bd91630cda4404d4905ac40e017bb2f1ba9142c3c2c067e43f1c566b3671d481b11be46b428e1f6edb379eabd2861c7bb65fc458c119079800d89c27bf074835a98a211f1c57b3ffefdb084d35fae10875aa1c6b2e371c9145738e80ebf44964a83c0368af519ee4ff156b2d22e69d92e0110ddef055298d2d644eafb459e4180cb7b4adc79895df16f2d61955a1688c886bed4e5805502624ccb4bf2dfcd28da0731b8b58d538ae26d85aa40f31a445ada2291d839b74f27401661accba7c6d8ef6088f555d21a7c17b40f0b0791d0b827c707363638bb012031f439680cee90cdb7078228c381639e7be0c096c646a6ffb2ca274c84d3878cdae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
