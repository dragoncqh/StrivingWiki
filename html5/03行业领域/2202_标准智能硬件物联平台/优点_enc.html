<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2cc0eaea0c997cedcead930e78eeb0de794bdbd6875097ed01eee34273c27ab338094755bdd655495d8aebbf0d4a7f131d917b7a9bb84fe2df1871a47b3f321735a229612c9e90f724001acfdf261dd357976e3d1f1807ce55af6b22ce89c0bbdaa87729ebd8afff593e76fd3235ad147da7d29bcdac3eac8c4511bc75cca26ccc36f910b81036cc3492704027cddc28c678ed3475cf80aee9e79a9bcc9777fc4b7ce3c47f01759d16d02751fd679c837806ab3f5623b1575056d8b2374c07732cdeda01d3d3fdb79ef8421f9165269dda8e1ca5f84886ae168b038497307217fc34aca9423449f3321f3424ab96b9bab0d1318ce497d9f1b9b53cf662b5a7dbf66dc8001035b4f167102f38a83204ab201cafcf1706b82ad62fae7ead5d68548e9af817a458c1f1217726e23f035386c121995258d91e6b92b8b05dc7b784093edc2e7ce574cad6e556b3c36d34961233ec4054c8d0e2e0671457b5bf221433f756655a292c0b8330dec57e13b1d97f67e5455f9a0c00d20f72052b2eab83ec59434e634ad0ebeb60da8f021d6ff9888a5bc9a86e40b7eb6903dd04301b952d1d2fd95b8b64716829fbe670d40dba2f453df9288253ec84e62165efb8d52bcbe80b2c87efad257c768bd750b1cb1d3e1ad9faa13284c233d73910c3cba30ac832779063e6cd36bd21ecc521bfd896f8b4a1eceea8905bc8f258b06fcd18061520d3780d2631418105002c8cbd0b36390cb209f4524d4da0523655f416f747094260bec05efce177b46d8469e94f484facc2c80b91e059ce836314ced47b01c121747dffe5aba280c1f028eed63f196b3692452a3803312538e97dbb4592c03241766ab4b4c8b8e598ac757d5d7aa0ce8bc92e58c45a651f70e5dd0d89e91ea51dd83f87e1cfe736071e71c7b7360a7c20971c75cf3b55c1cae517d62682fd541942af954c87f22955d70c57c6cd091f66a8507bde2a250c9f9288aeb7206be336608f0c89570f75d61801116c527877cd8ec690856a84af685d172d68c6ecb2879a5e672995cd3770ab8972e374482ccb810068b37c22f1df4d023976039400eae73df3c87f9a24bc7f15b4ee0e406ac07fc9d1f8a7a9a153f036978fa0771c8d0b5203352581997f762153b605eece2862825a0b76d58dbe64632d87b44c3b3304acd691ee3b818bcdbd01423081c514f297c12b4f5f728fe0ea5c844ff3ec63bbfe274caaf2d0d288b94a0721f2a80cc13dbaa87f0f6787c39227fd6cf095d4668e1c778c30b931293089b6b52d11248309a653b8e5911215362bc6c03b3a52a6be573731ee879f6dfeddcf2cfc83ba9cd06b501dd51076ef68f74ef2ec2d67221c1c5b5e15a511734f8c7e244827fcfdac9c278b8b9c89742759d65e88619bdd0a942bdc424491aa70ca2027587c41ac7ce0064bc29f2045160dd09d1e215cd572acf681e78183078a132e4289b1589bd5872eef9516012f5a5aeaf96c2a6e20920d0fd4180bdaaa95a6859861884d2a4edd3095b37e1a80963f772cbcacf7c4ed8fe3f7b0a7b63c46b196538bf11c4990f571a275e1593386c6e26e64681a0544e20896a686a199ab1ae6ce7204224522c13b4df30d46adc751d57caaa4c47f44269d3c8f7591a5854fa3c9bd528aa8496929c9c565cdc7fa61fb34396eb1e6d89102a52cbf7444dcbb0f368b9c4f644220fd844e7cebffe20281b80daec5eb681739b9f5ad221db4e821bfd601179682c1c7f06fab7febc415ce25ffec930b0381aeaded7276675a9c1731c3bd4ad80f5598c901c4902bada16dea5e18470068ca005e3064b8091bb7cd9b4fd45248e504c67f7ff20642c4c581d5547ae3e9bf859738c436a4ba1a0dc31ddf54d39a48a22716aac9161149ce3ba5ba5e35350217566e51b9c6ed66381a3c20a527bf91e875a5990d7e74aea055a2489ee0be35a50bb1cc858ac3d7fb236f05f930bdf66c741b1734efa905b0ff88bec7462568a8c743808e918c7e9aa7b3ab672c85a6f1e26b5cf2caf3aee24324f802ab905d72af4b28ad187308e4aafd57637aff1441276b58b44de7fcfde2bd76e5826b90a8cf02dd8f89071b5df1cd73a423598a70bee3ee90363d5d167f234dd2d2ade8ec11a9b51eabc097b5b8654dec0e7851da16f6dac159a5a77a543719b2a3d8a74109e28ad5813af6daacf58b3ab789df29f29f8dc45bd319d550308606ecf2872e07c69123054a1a09769b4ed70b04d91a82fc763448d133f462438ea9f5dcc20b2f74e08a81714a5b831663fb98a78a448234eb409d49b72e2a13ce3bf4a1eb279908bed2fd22938e6fa04f5adfd8e3d0457d9966fa7456576b2965c5a8903e528381c7194230545c1690ea7f1fbc677cdc987cb6eaf4062d40b25b903b4dd9cb33aec8218c11baf8367f1408d2718f0a084610130ee4bded08f82640a0ac9428fd78ee6acdf5966d62af68d215354ba276c454018b3a1e7226d7bd908e8d477e181bab157e8eb8c898a6a67ec46f1c120e71163eb02b0d648c15c32af24bea635352c9ad0d5aa3b98c244b7e74b90cf052961f271ba034fbde0b5eef6bfc4eabacc6f75ad7785122d49d0c2ad6dc60e6e0344ebd6453df9a5e2e2e8b1a12e3e925d1c7bf72d778da3e6eed12ff4039b870b31d83b5fa1a6053e3b3cfd78d449d31b4f5b5bc8edc71a69cd60ee4e42a4406140bed162de250f885bf2ebcab704d00afa0c7d37a3cde95f6a93f655a909addd9be168b32f1658c7169ebeb2dff8eab888319c2bf6dec155867fda4ab164a7cddb84a7025ffc8e8a166689a2cfaaed53e29639f6e8f3c32e620940b6ecadcc04bf5291dc6b794747babb3fba928d22488c0fa7309716f946d30bfff08e2daf914134317d76fcbc84b5f39b766b5e78cf0564316a8a183fdf7ef2f6ade4ae39a2d1a00070598378c73d8f387961799107a24e0d746967d5815111c933187e1bd56daeeb0684bc51b516905c41ab7afba6b15f21a62b77644246cf307462c4aa75aebf2a50f2f5415ec3ffb772649ac181ea38aabfbfe16dd0b2ebe1a9e069f4c41c8c2faf4640edf9db4fe2749cc24e3d7b6c4c07f4170dcd417f22951c904fb61387010af44bc67530ef5426ea6b02ffb2ded038ae1ca472ac980440c19e89ee25962694bede25b2e4e4dba9e2ffdfdf6d2cac2508ed785e6b9094b60419e28e156a2d82bc34e34e9992925a9b86c9bdce1c04f84ea41518998a320f19d3bc48ccfdc9a3b9e83e07bca102272fca30d9b61c6263f6c090b66756b34d9c6d479734577c8dd65e1d11e48864797e912adf7bbbfdfdf05708dc7f4c18a37795c126efe7649b1927f0bc2d7d678962ad7fbd4830f9233a65b0be5e5710d4f7038cdf31e7aa3ab8da79b9d8e1e7f7b7031daaa2ba14927aa8e0a10397cb9678439e463cf87a91c6932a7783701bb75dffed945e42792dcc327af63966f09f416e05257d907a18a05a93ee6ea89f769520e39953e0e05b995dbc9752a95930f2f56c9372843dc7e575303c65d115ea2aae756056b2cd80646c511839648cf721aa34f718c65bf801b56f12dd27f3f4e78e60a30418527e2fd4f8329f4669aad6346bd617002c280e36a00b89ae5e5b863e49a94a441965e1eac6c1c2b4a4bb66898ff809827e890f3393cf15243c65786fec96fe442fcd9a8b5a947b242ce4dc75d30826d1e227d8931ced75f6a7a3a7934343d4ad2c65ddb2b87aaa17c20bb0a8f3af5fbe2c277b88dd2e5c9cebfcbe0d8a1d21b1049d469a689b24af6b11489a7d773e577b65d21bca1689951af3178a33e8e74b9e12e2ae7560079b994c6e3ad49cdf117e030b8920b5138373cbaf550f46a2cfd9e2f2724093b8ad764a716354f4c7e6a0222b1e4978f79470609987f93a740ab63c974742f3653166b59cf388c470e9e93bd53b8bb4895708b530e741b6114e19d78b3c9410649022e18215cd045ce9742fdb258aeb9b660970c70f9b1df469747ebb72f73f5e83df2522953fdaa38e28382e24a0339623294de4d30979ddbdd7932efc91c7143b509a0cfe9887e27bc8d3eab17ea4a405e1fbc28021c1520319652d7461ae1df64d213916895ebd816df927e335950ba9d09e3abe3872715f13677a7e742359c984e0c9081a38649a26a594e9c9490921bc61d6f8b1386bbff297d720846a1a3aea92466e78b2bc6f5509c4454b45bfebfa11cf5f325b50b3dde1c9072238d3ccfe0215a5e058d8e006a4c16e572c979eedb770adc936d94f965a357e4ee45b48b766bf25bc4ca1e7806efe4709148b24f926c647e1d0dbe772b70589fb6c1bbe2c8f5f0cf72eaa55b0d0c55cdc9680bc34d4b73f4252bdabf4d9ce3631b2aa693fbc742b20da1ccc8dcecb2dbb36e92585b3fbc75c9c6fb3d47875fa69fe0e17871f9374914e193b1b404c7cfe45c1972dcbc6197f450700ecc3a5a1f5d1fe664214a3ab5f95176ac8dc6d81d894942659b196dd2a513273c81146d688bfc321c9975d6a9750d36bff9ecf2e55dabb13f7d968236075202cf5f4ffd344e2d61d2015c4868212222ae2bcd50a3873f796bbd4f191a5bdcd2365e30d029d5053ccd71ebeccb6ea5472124ca6070205ca4ed02b668c2e02b7cf6c1f663b6db748dbda117e18d62eedeb56fd6d765638227e902106e7c1ced38a98a375b482d7a0905f067789a59fe7bd2b70af115ba325b63d21254bd470d1c0c72a41100f8b36d713e77fcc437e5aadf925961c24b7e484529d9f25933811f8a0aedc7f781562b7b56029d43575083bca1634b9ddabe671650bf24fdd053b6802402afe3d41b48f15bfa323ecf4affc9f89ddefd161a52473476e27e4dc02151ea077889d69c0696994c5fdb8839b00fa2900e45576c2072d94fd4bc809752c0256679b464ba4dd7a7451bd985126fe964bc44e5123e3d63a257c69ace45930669d03d5a3033c0a0b9edf799aef060589cd612aad70c518d29bd8dd074ef4c4e7992a5ef6e8a6ac414df2e22469351f97f81034644724d03ad4948c943005c62e71abc654e0753476be7573046f43420086c5cb2d44758465ddd91361bbd98eed874e67156e5fa75b729da6f9adeb833c410291382a65fac3aa82bfcee84fd58f97a5b0251d157e1ec8178af4a28294fe9e84a81cf9d6cde9552ac49fde7fee53e8441fc6b952e10c78fd52dec3006b41abc92637a0bf7e2a5f669828f89af771a8d9669853b2f9d025f3178ef391688c3864571a3de69a138c88a1ac866fbf44410bd84ac063f594dc748e846644f3b152c077c09fc8fd5f426208a316c57508322df6b6e63f113706bcfbff94cc7567b9913593067337478386f06b48238e899be0d55b2b1476adf77f5504a861386782631c639b62e4f97a34ea769b11ba370a31b18df985d447ae3158b2fbc98c0616c25fbcf2dd4f99278dff88910dae2195bebdedef0cfa4961b8211f29537682621acc552040aa8ee82d205abefd5466871a427831876d7a07f1cc7da88ef4eb2505662b3984999e0285acff26ac4e4044c273ac738b6dbfa1b4a56cb0baeef505ded8aaaed9eb7548217d98275e0e8fb17345dd15e50fff109b90070f319d62a5e6fa5c697f22c7bb06ec97710a0be8cc884b999511887cb8023213ce137bf7a9e0204b5057a97e9a6663f5212746d2b07c369edb23db9c375eb55f3a3c7ccf3ac8ae8c4b8865e54b33d7022fb43c93bcd05dd4631e10830beb8423ea0bd48f9f7a66ddfa9e0674bdf2b58fb18f7290893e04a2f7ba0789a3f48bd8ef5df0f7703d5e4feddbd2b899ad388f1722cc5e0caa719cd27dd0f73a6cbb56f6b4ee869f480cfed4128e6ba6d75e4c282efb3f2f365c8c0399a3f8bf750f2eebfd77d94dc5a2b938ca124492de50307a1a736caf6c6f08b0a7840eae11c8b8d158a55ce7cac051129933f50200d01ccb6e4c0cf8d7aa445e1ea4b97b74e0914fe3f17763753f366edcc9bd5a6ad68b18ac5d6f97af289ef17eda910773e4a66483ac5eb01be0c419f8c6c9ad4d7d50c7e7ab119466ff807b9cbb83e19c7dd613b3fcaaebb868ce112837abb975e013b41ba90021457c1a396072ca6dd45a212eb5975305f44288353db9f23dde32675e58a5db30979b3f766397f158d93cc0f8fcb0d1040edc89a2ed15f683fecd8f7a46b0197bde4937ffd448aa4ec483f2492e17948453b818e9b22970959b22fd79e8d18f73fa116d89c52fdf3def73a18aa3fd91fcb50cd939140929a212b453bc36a9af96b43d0052f869d85167d21589c617b0913d53f3dcc89fe1f3b360d6dc571a1ce9bfed1e80b742795594352915c026468e9c2c45ec7c718d189965e8f6a1969722012a389a65a12ad49863662ee20307b0273c9c7b226ec40822c1464356268c49dab04dd03befc871b9ea29dd6cd0f20306d625373b3255f82e914dfb2f21e0870c31bafd9c2fc9ec6b6023886994be6724016732ae86ed83a63220d02f1bf6047a655e5c09c4e9c19f8d8bda2ffa4fcc238d65cf8e4c2ac3058ac752640d4ce3d082eda5556a5387cf3847714ecf78e9ba4862d947db448f94374a9d26620db97d6f139645a7e4ed3fbd9eb69d478d3c0090b4dbaf427e117cab58cc1b8d2fc435245ee2524435565d504e24fb88348bf8468d2c378e4972d2a566be3072364d46ef672cf37d6f62b03d6cce936d751cd0adb7974f6149074d4fde6abf2d760fbd4c5266e5ad941e24a5b788db9dec6e18b1d27dd04b9f42d91a09cb37b8b6fe066c9c9d6b9183067d1d0ee0c5096d4ac51ff7fcfa5bded33de14488996f341bfcd23eaebfbd07a3460d09c3a14cd2e51f00d7daadd01adaa7d276ce8893680039144758c2d2fd928ea5b3dc2b49c338e7e354fcd43f56496bfdb3266daa54154a92f933a189ba6d75173454b913a3840cd0d468b4441aa8539dc7428983ae5f1cd830c983685bb74e7ca7ea691a18b09adace2fbdeee9d3eb58e9f582f54ab637a1c7a44c41f8ef758ab952680d15e03ba93d4b932fe71246c651a7e2297eb0439e6e59533e321bb45a1082287336b5faddbd561e374ae5a913594af435d568578fc11d8d940c73252b99f10d55463a3017a15c97b50b31525d59f375b693f294b3bfeaa2f7bdf63c7363e1d8ed403c62b5d2d284a1c8969c6b8ea7629b29af24348da889cbc117fa6a486262ea471a2cac26b43df3a214d633e9730a1cbb494f958495af9524bf4b9c7096c99e50712b184f59ac05fd5e3da5b13b7a433f3b9ae4bd99b94eaeeae9d1718f7aaec8c4fa8eecd618c55a0e2ed9a789b94681e795fd0e690ea4a22f8e7d47aa40e23e452c9d1a2d5dc647f503783ff7f6637300b027d8aeff87406d29c6c78c08f6751b7229fdb453e92f3491d716be403e2196149d3e8c6e7ae2187388ff439b0b8ed8148751708241f394ab31ca4cbd3775690679cbbb25d7a2806900ad81affe69a489b61005325cd2c19b0f4e6d5ef2bffe3604f3b07fbf76181eb9b36f415b7c4d37a78951754c356f26b295c8a8482d80ce17fe08592b50a2fce4318a38aa17520d076337fdb3ca8f54022c229df33d31dc9ea50239e72ef1d2601b6904d39fadc443aa6ca6e1c2590e170626c0b8f97beaa66649f35109653cd7624e8a53d26d77ac5ad648992c1211169740d35cf63cde84d3ce3052270e5430cede622e55c0a98854bafac160f6372c3d5bb03fedb73748f792154c6b0935da2d218e2432575d095bb7cef1614e8c5744513f533ca4110c6e42e23d28e881c63b110440e43b4afac4301d50bb034cacb274bb33eb96cedc10d816a945ed61218a81430a67d21ba9d323ea201afbc2ab546c6379e0415344449187b610ecaeefde2f12ab4e44f89e19a15aafdec2fd5f21e10c391027041e6c0207c5ef628c275c9e7a9e086da382a5103afd16a5bb37ce79f906f1197045afb887dc43e279220c6cb83f632bb2d5a4a07132b4f9004c53099f39251ba2715ac7dca1cf6391ed67a2abb65ec99f41c61801e6410c78934ae107d30425fee5b7ac70bd8cf28f79b3b615addfaa282db805b150c6d7d07646864ec3b1d2839babcc0bbe26cc0df6a7a59b340216524dc2f65653544db9ff69ffc509c4202996d55d3a30543829fff04490a6a1e7ac3bb6b49e8416c413fe1a0403a81bbc3256dad27b36cab13d1272fda31e7feca188a0e2b59bbc6008db7d80fae5ef649223d660781729f17cbc27eb3a93a8ce05440d60b8708aa7081883d225318226a5367f3dfa16aa80147dd3785ecf5477d4e907bd0a0fce38360c5eb3f195d4f13d7d546028170a66be257a7ee3745b75c2826ec095d2359ce5736f7ad1c4c3c9bfd21c51a08e855a0cda580a9b062c57e1eb6130f98b0bc21c611ff417a628df64c2ba82a7be341ee4009c58edbb67efb6763132b2b3084b1e2336f9564003c728d4efcf9a1552294560a8a3eb0736bc98aa8f8885b70f9f7a0b3661d62a18cdcb395269ef8342b8cbe9543934b40265338e17604ee75af929500a2104ccac091517e366943386e733737671007393901526c74200fea15b4562727d61970ddd24abed8ef81a6db96482302de76ed9ef85be2a5b980abf1fc2d1a89af3ff2ee68da2ac8db2fd0ca26fca40d7763e29e0e3ca9c3bc9f2ec01f2c236d9d0cae9652afbf2521e1d242c582ef0d5ec0388b13915ad3e1cc0e29715e1f3406d4eab322433ef5727c4be46c2f78abcb5571d06ca0a21c4ba4cf4696503781a36da3511f9d165b40af9173706fa0c26e08174fa90a1339d921710f934ca8675880d9bf0c25cd8a11c45d8b114de270188a2d42d10ad8da0e062e8cda81f61a81cf356b65ee6b633e7c64a1ebe322b4acde106eea5c43cbe62a24937f788b39e28a48b54998783d1f6162bcc2979348812d54dd7a4a99fc782ec2ca303604fd686228620d4a6bd3397bad9c5426042e41ffba349e6dcd6ee66e8ef0e33aaab0407e8af2bbfb94516ad264e5ca804f321a0780a5ffe7a8617cdbc3ccbeb69abd639ee41dabafab77334354a7503429df06a4ac6876d1f94577a90a77a213ef16285be128f722aa492827af24669f5dc59c9cd9578d205d1188b117a78ba8592f6e114ad19aefc0b5da6f95b0662cbee565461d19563a0745dc5e5b1bf4ea68ecebea1918957d6b9f1cbe9c204a439777bbdd037feeb572e9bd5d06fa6df296167408f044029411da475d1ede24e1d444ddf0d4c87e2462f96bda7c2603a355d7691426b89be0bc777ddedab098bbd51983b09454d96a65243776772f91c9ab6e705cc591b0dd464722a51fb99904404a2c274080b2e1362c12525d1a30a7bf73a4aa6224dcb92724a3ab7cf6f8363ca1c19ef353e52c29d30b468b1a6001daf55ed112cc74ee3a544066ed47168d22ff4f6b8e0daa3d4db93b38ab645f794173be4d0a57f155d1e628261d1a610d894f4613cfe5d32e001e4214bed1f37e44851780e8b412f9a2d5eb11e5ea3c0f5387c6fee0ad817b61937e0b2fa76b2aac6b0f424ef61bf18311710b41cce5f653f49ee9bd3eb01341d5f57a30aaa4f32b4b4e199ca6c2b4af7dc2153ada820bf5cf98de4806442e1126a059f40d9239638b5707f2cfb839f3620f23d80170656341de38e24fe592e2f088fb0d6595877cdd3aa70b7382a290603905208153c153f3f47b7ed67415ba86ec91f64c5133fe2cd304fc7ae6bec5b7f9c59179cb10f50070582b302a6356557f2f51917d0de9333b084728f0b135d896ddeb7ee55fd25f46fcd9347e01eb6d8907b9a7ac5ddd4234e9e8e840c5468e24c6572381fe3a352c6859b5a4fafff9a17e4b34c8bd031d69a408d772b26a832ba43272d7571823462bccaa0dffeefbebd443cd99e2ac25d6a0725c75ea8c50e9382d6d462602fa386aa2613ba55e6565a46d8179d584fa43a114b261977340fa925c0093fd13030e62dd1a7afc8714b6979dd35064e016ae8861e845f9106ad625fe7feda5d6551dae10db31ed7f7b71bf21b76e29dafb13f2326a2f0478fd3c601dcd31b5b9b821f081415a331b5ce20ba0529ec727d286077b8c36a4646b019eb62dec0b661ae1b4755114436026ffb7038195fdb3ffac08aacda3e5b95f37ae4e314f4979c7c8ddd29d2d5a5b8f65ad2f8893f56b84be619da11f01affda829f6f6e3cffde52a36952cc192a1cdcfd45552ebd3a432a5ddd1522ba5c975fd5f015a8e5d7921f9d87f0c3b2ca1c6ecc63b571479799ad7f2f474d69de68ff7274df4638520a639bc13a338fcb13c5e6e9fb948d3f31939f7aa0c6e7b29db88bc525f79c4bc006c8e49b6885cebb325c346cb8b99e19705d706a965aa19b171d135f5e8587f47de505024ff88851782386d3bcd2b956ea1d363731a13f50926a8727ed6ec2ca8ba421ba1ea78ee2c3efcf634512bd9fe137c05211c4e800cd296e941ae892544d52a5fe7708c26a537a6ba33f04a8290090dc311823c1d78cab68ece445b24f01d91bdba05245f9b58c36460e88c7f84ef971ed87165f24fe96dd4f98d7a9eb9bcffaed371d5ea0db120f6bbef5b47a6bbbfae3d922ef36dd04439fb6100b5f8e164018f16b6269869fc47bd03e5c3fa9852ee5b8b8aeafb3667cffc4169eb4503866e80266ec6fadf60dc561129319ccaa9fcd118f4edaf6597bd19d5045d1a43f589abd09550597b4f8a597a2eba953f3a8457c09f0592184f7ce5b5f30e4292c0403f2a63f13c6d6f324802fcf32abc5816c22e9b72eafc624011ae554a14dd53422955938fcde36e99a7d3e80c0d8b5f297425b564980c6151f4f6766b1fa9ad1a032815bc2cfdaf446b7463780676d519bd62e13c7a1452adc64cf290ae15b7595b90b77fd263bef6a7e3a853754befd4a5c067508b9ca38590cf176f7b7d9df2523e21fdcf9deb06d31f578523981c833e3725a32c32617dd37b874ef32110558f361c6ad91a11ce988cabb5a7008d06a33d18851918ebff6acf2224883dc471f5c0f882e9b6d45c4caa15d541d92aa1290dbb51b1ba3598697953169261f052840467e8ec1d8848db071dc22bd30f350bf23178de017c827688ee430fc36dd57a64809f7f41aaf280a90982f317e3e2f17c5e2291d1659742942bb30b314abedb14298b1f60d53e7cba469468cb8d1e7e19cc6ef97aa7b20459f225839178e37d7d44a14699c01006a9bf2e0095ec1188f2a4df507b6d8542d1818bed55ae793636adfa5c538f4438bb10f90e82a8b02b46192ccb6ce73e5121011e3e2fe29f40c6684fce7d870ad46c09ca304851ecd7fc66b58fe68183670e8d8dae4f95794029179a1ed60b51d87f037ab1fdabddb06116b4fb9b4b6dfbc5be23d92ceaebe14d7a64716de029536740d3055ab2f2db4792d729e597e833c80185c17bce257fa18f9bf8e55c94605dcbf8276997e7b697714d814b91b98f8fc95b2738991aaa1cfd93e50da6b3f8cb1b03d44995426652989f06c32c32f2cad4d93fc1b0c8f0764c5a76d6b3cd8584c8ff4371cd9052a57002b9e36fe76a76b596789fd941db1bbd182f68e918b2f502a90eb1d544b2d5c1cac60c762484812f53077ebbf9878028d9b5aa277fbc6f2c022d9a8e4baf1d3b68660c5c614798b385e905e55ec9f92d514600a34b9ffd9ca941180f3a2abe1aa907400300844c6cac963ef18cdb5378b9afe442996cff991bd5c21370c5022245331943d572f2656e65ef5da4a4ec0a44954a55bedb1fca98349ad4e9d2bff59fd101241c2f7f5dcd7bbb21597f64b342352806cf82772aa40c924645f04e7102bf392b8e11d8e28c8d87deb0651784bb7ad43170eb1d082e04081c9b08ec8224b4c6370886da0d73f6cb02af6a7807e8214b9bc5b012ad29ac5cc80cbd7efc5c08c1460092f7217cb78fe3d4260138e4731c24da123dae34083a467baf705a63bec596b69e1815a1971673544d196ffd200a83f73e9d93274c5df86ed43dc05fb4d7aa31bfbc5d810c88a931cafe6f4f56a35cc57fa39eccc7a7ef5a4a70fb83cadddccf6276ec6c811cb6e5d723fe9999b4bee7f193a958de260312cf0e2c6eab91566aa6fe20ac49b8d08b780243de5521d47108b58cac749b75c2fb9aa64c5f94684c79663214adcae247305c0f4279d82cab88f9ccc28d4fdca48e63c1e4622c937c9a54b032d622fafdce65b63c86636b764119d662b09e99677909f4ee8c02f90348945948de1c8c1892c757b12d35e26fdf1f44697a5b99e3186c4bbb0bc0efa1d6a1942bb72b456a7e93ba3f1fa0e91c6ccdac05bb711933d15fd75d780272978bbbc9989fe0943bb30e7a5a2f5b9c93a0ca85d3dc41106f025208c6870f2a3040d9d2c46f958058eb4794b914f9e04492223db04fa5e48fa2d5d12bed1ee3f68cbb5cb449ca17949cae1ab4b97e5b1eaea63805bc1ff34a1e4e3cb1e59f333b1d6a54942f62c8b556b2db9a11a120d7fe4c4a8627fa3c11ae55dd1a76beff6f2d63d90ab905ee58aa24dc6b23786a53038a3bc889a670358e5c7daf5096ca26eed5b317c86fb4c07a5a21ebfcd12bfaef8ecdce2fd8788fa37cb4b2e5d42ab841b8540c883f3031be89c32d919940f399bbafc1967b5b72b6e19276538c9fb7b940ae63e96d74f6223681d031dc8c6ce646fb7ed16f4211a6fe4c91a6458ae373e10d0f3a461aca666fba46b28c76ea7ca8fac571c620cebc80545bf25484d64ebea8ab4c3fb8aa6691aab7784e986255509758e60c778c2e487deb9bb32e03cbe2c993ca113ddc55e415fe8c1c7ed098d48fc932ae59141a7d87554fed071c0c3ba0264df7bfc8c38517a09382fb089cde251ae37ff67518425df66ebf76bdbe0f9e2ac60e677ee5b942895da55efaeef1fe6b68b886bd4d9e814fd384eca77993e26e44afee8bf087c4a037d4f269fb040b5fb8a198de8c51fc8fa1c1e2064c010f63706565b35c69ca09060f20403c4cf7c90e707ce1efa69bb1a58cb7490595333bd7b41a90e81a2d8aba721f78f711da4a20d7ed3cdce473ec3d76bea8cf7964cf7684261e8a066814b6deb0544b6da31678b778b61daba572f9b448d6472c74535325d633dff36bae57bbf50b363345798533fc33cb67d9dbca9f05a6c89244623e44e142926e02bebfbb33c0acb0594ce6cfa51f2e8bd6b4aad76589762e3c8011462610a069fdd0d37159f728186bf29df4d1844e74ac475f212abd1c60e2b5e5c7ae487553d189ac804904dcc78fab9898ef68b98e4af4ab95afd331853e1994a0ac9c6f448d68833cf26c3bba1e3a568820c7afd3db86ed7fc33f97f332dadecca6e3db5600fbaa689eee200e0dd499e596fcedef1a90c010ef18cf48e0b3752987d6a748851844ab86afd4a6ba54d4600af615f05c11dc747b205db52369fff4ad8f22d409545db90cb9296fe9f96dce7ab21546387386ecff9b25c3263b8a2109d644ab60572e99495bea7dd7f3a0229b2f7e0146aa06a69942eae4c842cfee9d1b49c76a6e1652777a8fa4f7975539327c7b4ee2515773a311ea1e1c9aaf0545df7c83bd6008f25f5134f5c8bbf53a9d83e87ee3864b519a238d076f0d75def1ad022a50f4b80cb6f332811c08fd0223c83a1e8f8773b2bff1c5d2e137b80560b95dd03074804fc668d6fbc683643379d72f91dc5f7e05330feba17a1fa93d35dc394a2b54c58bb2d1da1ad6f03d030cbdfd4e0a409d04eae35c88edd089e310c26744438e6a5f9620cf9b7c9e2fe1d11cbc4ca393c071fd5c6bd082e0a30f190b0b42c755c9aaa26bbb3de3cf100012c6f7a7b735fa04a3b82d1f6925f33ab459137e61e11141df7bb26b9940b9708a514fa966cf761747f4cff98afeb8f6b9c561aac42165a02a88d4923d8afcbbfc14cedd35dff4cc76c279535425abf3e7b6247cb5b884175b76dd495dbb73d955e287e19de3f68689a643a0ad4a603cd7d7109a1ed718ad3358e7ef8ad7b8d10986859f7c8bb3adb96197a132fad9cd7184b58b63cffc8491e6088159bee73584018b7bfd9134332f0d6414990e11c9925f3aba65c1137be9a7ab0a1bead4defd59a960e8ad8f79a4f8137f9ae3c2e1b9f19c77171dbb8923917973d335f24f7d67a9cb6f17873dd4e7d2d8a2d27177e0b07a01d5defbb9d72e51e9e859a342af426ff0350dfc53f5d7bb3f3d39cc0e14251ead4d2b5a23b3a97d920309cbbedf60967be88d83883934df9308ee2ab729c0f8943d9b901d01b25771646d170cfc559a3c8c70e35f34a405f041b65d0709dac3ab24acdd9f4109e9721b6932e63ec968d7a05bf48ba3b20fafc09a742314ae46510fc0ae1485f8283e7b3197cfd7908249da6bc47ad5326f26655400bb2678c358ae74586489df58e4c02bbcad3e0d50704c4bf0d31d1d0790ec33989363877e88e32e631f3871b22794cb5024ef28c111d8813df276439717fa8637a241bb0f87ce76459859a9d723e8eb370e15eda12e18f4b2de911d4ce3a4e921dc1946139d9f111426836841f4539ef62ee97e8e158a975bb17d06390ee31b9a6dadc2e6b6f16dcd11d3c1d6f3a2915209b540e00e910eeb3bf49881c43195a1d399a23e823fde43b3f3f14212f637a2f0a262a77ce435af9f74d6a08c0af5cec2fd33615f44e318fc6678ab081cb4dfa4959997ebdf2362df913f7fe749b0a0db84302269b003c773bbe6d63607f06237d056892e1126357cf710ebfc6ced7fdab4719a2ced7eca9de62956df802e709bd86fcce03a3984871df73d24d72ae4ab568760e0ec47ba0907a104c945224c4e5a50d90878283568275a6960041d4ddc917363c65caa5300be0f8bcd804460a4b3c1f0a5f3f959cac3c81a7304f06fdb1226ff3e1e2544ec66639ea4c40f122f52cc11c9baa94ea9300da4a1a92c9e5043d5af1cf4105f6e237483113d2edd5e40d78dae6119b55e8d0768f78cc500df513efc433d3e5a611039a67b61f702166eea08cf012c474f9f8aed53f2d6e5846bf01ff1433af1f8419e6830e5f37fd7c7bb7e272eedd41736ffcd98df3943b4b6a123fab59823aa7718","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
