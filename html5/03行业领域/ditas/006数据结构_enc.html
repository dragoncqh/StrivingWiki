<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33648383192c7f6d9dba87d753cc6390717db73860dae0013ba95a1ec475d342542108c69cb5343f38c96b7ebe6b8b24d56cb1e9a5fb2b1ee6a477249a3f6326b7fd4fb320a7b5decc5e36147173f6c1ee58d54f5a06a195c7093151c1e7c2f1e9e8f48260b19cb13d73e764fd01e84b9d270c0d27da03dcbc74b533e19961c53f1ad3b173855ed77759c0f52f84f8a19fa1705079a2ced8c0c02d838528e452c90f4143fb3a3b2b7494d9b62b60849f2b29c8b92917eae637d72d3c10377af9b1d66c16c83fb1b4cbe234e00274b53a45cfbfacce2dc71004db4e446928fbd79d5ad28b4739efb110fd14decdf8ddf8d9f64a45c45fc2dbd4de95ac28e28b56e4642289e1bec1cb450adb519adfe1f638177d2be41046ad654f4e1d2de15fa8c37d8a28b096faf781fa2e1622cf35916c894d82d615007ca623cd40c0e816a98be2b9e047fcb16b0e5443cea2dd657455ee6863419e114bc1fd3a9a654f4a01588926ff786e6f767857fc70e29b6b7a64a40c539a7d74e09e5b780369a84001f25ead8e0601d8543f4e14f5e06838c2afe9f71940cf20f19b07d8f0193b8e2bb03cc2184e36edfcd65841bb57b8e47acddd043aeca55b76b7b2fbc214838d355a4f46c134863192501495d2919bc238be113a9aa326bb4d8a377de2bbec1e4ec39f70cc6dc0705f522f09d7266836079f6c99e65256d1c4cf4253e9eae879794ba76b2f135d923950dd43816e344df67c91d453ebe43250269103eb831454d445651b72855549960e80b6ae57c0b575bc7f59151c512da065d9fedeed07e3d0709ed0917b441894d0eefb2d4a7401cc6743686b9c79eaf9fa2f5f46adbc122980dfd8e79a99c92d976a5cfdbc51c005702ee36a61c8a2216a33101742f5395847c03f3989376729dc33c2a1ec9115b8baf741c9fdcb198df29628914f0153d02278e43092e4f8d068e8c64cee28b3268beca5d5adec3b949acb0ecbb1b180e00b99f158ea27b7283bf121b0bb26fcfb064fdc5b2acb3a1f9b93729df5e2b6aed755823e1fb901ad81d26e67c9ce99c9eff5cdf312866cd28d62190bae567d3d5333e004f594f84b58365d954420031da0f1016ee44560994e2095b8121325e9cfb80bc30a44c9056a28bd05cc9e1fb8d5919220a9313ebf8cf1b88bd2184da94962398b982d9e1dcb9e847d1daf1e19f555ef962147c611db18ff82ae3116d63b0fa2df27015e5b2ebb3d5e32bece5bc78e5e87cb55b0d0f277208a918bbb7a02fb9936f09d8f39cda66a033a9b67abb94ad73827280464b906507584177fc8521a25b89e9b1c871a29f96c06f25b5b6330daf2d10f7021b6e34119b2a64b4946596b843a8013ffccc72b8e2248c1387dde190f37b0677e7018f4ecfbf4562986906260657694afaf6c5daf25edb8ab808bd0fde2dabc8edf88dce90944810fa8c6ac4e83a8d1101ebb22bfb49b19e3cdf9210d31a25c59808ca74367e8a7ef3bc17e7b3c53740e4e9e836c4ddc5b1f44d0ab33fc6a2a5a1c386d391e39c899f3dd2d93e49da497e95033120ff8de97de620919d327c255506e97cc2119d615bdd903f1d4d09895134485f45c53e773760eb4a7a53915e866b5a0aa8de36eaec3875141e5da843cf1dfafff8a6cc13ebbdc44b83534562d921bfa5ef4483b5b3b564ad97c8abdb6420e70edb063d815fbd9b118482def07ca9cad0cb57997ba1a71120922ec10a85587197fc8cf0bed7afec630cf96a1d0f07b87a776d140dac38d644f46ba644a1cdcdd9cbc5d45cfbd0a0f66105cb3dad65b921ed40a82cd329164f48c694b6f81e5fb3bc79833a32a45b5c26ea93f35f34fca3cc96843606be3c9a36c36909c402c0707d4a280db271ca2536c12c14d453e87c86ea58229ab4a090b1830d4e81a111878ed8eaad7a08cf695ddbf738740c90a030bd055304bb6641f7b52eb2b89f5ce91b98a7bc4a5e4b9a30b3ff93cced65e8e1cd4be9cc7eb837fa604aa4a5ebd9197259e0d6347b3e7424dd600a718930bf079e5400652d21c6216e6fc94102792a2a4bddac363e92224337f61777f80142a0caba90f87d0a90a13de227cd46ae284ce570938eb6c0e819ff174296ed5702d7a752fe5527dbabb030b3dfa6892981c18e3c3c4949ea4c06650a43d8665f8896d394c221907cfeb4557edf3d5572583759a9dff7f5c4839d2b5ae09453fe4ce2993d34de234b16807ba1bc4b37f21796746613cac0544a038f3a8d96d63b4f78b3b35bc2934439b226e8d9fc69cf7301530c1da42504211778b3153e35b87b968a1da2e37553ae163091392a12a547dc1dc8f77b5cc452f357df29634b6cb2e3ca5d260ada264f2fab7beefa1588474ac0979a78bb82750934c31c14a4c9f591aa74ca6bcee11137171f77718e02aaa3b6077f3622243ed6034e6f1863fb0691f82c6427aa7994bad64ea2d4ec4404f5fdab87bb1a6262c81afdf36bac6a88f6021fbc8d226a2439b95103938765f55e54a94fe9217abe211349dbaf9dcae6e79bf2a650b371bd521c9d7ed1b1d8a037278371f3cd884d327edb9b3c401fcc8f6baeffc736906d78daa2058d40ac7ef92f82e7c3913fee396510a9d5ef34443857601e3d68b00f3aacec775b7ff7c0231397ef85cebe05041b19f534468850bcf4e9bcdb3095dae50a61da143d4a8b3409ae425f6cf07c1127c1242fdcabf863417680a3e859bf907c92e57c2819dae333779ca7449e750ad00df3a7fd95826db82918432b5f9d45639870d51dcf55caa36e69fa8794eda8b6cbb92508e750c78c9a8c6cb4edb0c2eef3bc3a695af0ef7337e6bfb9bb461d6ec5d39d5127501793cf8ba4a2721212f0959b5c5aed8d64c5aa2bc335e865727a779820cbdc3cb1ea71670eebd81adde14305d3787edc84cf589e7067fe4d9d2c3419e4a3d7d156c44d4569b85d2a8ee8478bd4e15290690ed694dd94ef1d5971029842894ccf05cbc8c24dc23754df6a4d5e0e6d465e466896c085894cfa6909a4798d40b43c53f48230287d6f71ab8e98f900e31ff558b6177542db02e041cc3a34ee7dc3f0e4375a06706261a8aa4befdfa6b15c61df625b4cf99731784bd5f7227e5b7b22c8200df42638727b4804d10ce5d64e71f8bba1b51db885b0808dcdc977e00ab7f1fe4548fdb2a4512edf8efef6fa9010699127b6c3bc0b5ef7f8b729e175a14128922e9c797280468777cd182b89acde10591193366641a74d3ad3ac78b5fdd76a81cdba12d2035a71b7a7f5dd4a5a71578f7e129e82c8d37f3eb7d647e7f1c4bd46515470ea03a2b5cf77f912ab7b0aa55e93ead273f373e4cce06a49bd36b51813291dc80a2e10b7ea01904e1d5e82678cf20e0cdc7049eccdec13b01ed8d9557a12d79102457fb2a05bac1098c2b9a96812475ac3f0cb24ae721096bbde8c09ad70577c966fb131705b8deef206c76c950dc35bf1010ce3371c0572dc1b071580fb512c8fb22aaf24080df9565c27ab938db6a2b6236c22df0a7b58781c3cfc3a928fc0ee7907da068419a88ce97ff44eae324454e7ae53126b22d09c44274d5b657a9bbc1510caa71606e7937901d8e35cddcd33f26d3bf41db2578a9d8b231ba3e25ac0fb8c47bb6d92486d46b3f35d2a08547dd6b804d6588ebdfdf9814a9296ea7b6da19e5f2266165159c2e1981b3d314fac9c01499c3e506959ba8f263637472223867f69b05b863af709b96ce8666182f98ad40a4efdda10fcb920d367283000589105c56a8cf1dcf425cc7c962bdc167e62b5ed8934ec7ece5ba568cb1e2134c9668f3e569f9b49767e9f5b56e065ae2de1f0a502bb246b4ccef9cd01daa90f21f3e21a58103b3385f3df2fc176c9cb9a042329bf238a39cf316d69f2df6667bde7cd771a3e503e3e1f748404e4c71aa5de67394090fb28a4a2f1db34300d7a6bd3812047237b33d2e0fcfdffabc1622671ff1c5ae9e24ab5b87f91dcb2a7dc24e1b058642c38839d55139d5e15eaa46031abefb64ab76c2b82e02eea50b70e1075e6918f3c4700c859213c22671a777f3560d1c7699ac14c81f30a4244f992473d23080e47645abaf0d34363b82d826e39b54216e9880750ebd3e208a9e3ddb38de8d989dd191b7729d6f8e918004aef9d75bd525b9ec377e25c9a6e58a8fd23ee54c7b5d640bdd014a1a6d26576dcdb297ceda5b989f864880c6376b964784f9cd00e496c290e849b52419a30e66d85ca9fb561886889296d2274c430078c129ce06f8dcb28cd24a05c60068895ec99f4119a2212f0e15606ecd36f079ad7b9f3692c4ef9d85d474c2e604b818acf9e6b88bc04cfd79bbefbc0e5f6b235765d289c1bee24f2128c427991c05f95cd7b21f318acb95d714b8b4fd723687613b7d1a1f9f4054f71aa69d955cad03723ab3a2bbebb250fe78373abfed963ac55e4fae5fbe878025038b2169fb96f2ba90d0ec31d091e2a0b27119972e0efee6de99f1ef0757ca4d92b6dd60c3099c30c731f9cdf1d70fca1ffbae2e4d12ad9b56031728b80750b71e26ffe16411305d771f8d656fc839e5098caa7937d47d51229dff5bfc2c9acc9a5a398a1c08e6116fba906462f1cda6d311f4572aaa46c63d888bd44e428ac2e437a84498b5d499742ea34b686d88dec3c87f10eb19cf92cf79dd23ae1e52c417dfaeeb5177abac61b097df5b85451d4145c7bcffa260a4fe5f7930b3f406a10b60ca9b2d6158529c8ca6155b5c5d957da73518737f794b5984988e42a937f3954a32fa8b7024b15554eeed796265c46587a11e43afa286d22c24f367e8b5948b48677e814b0c2ee1ca39ba78f58d65302945a515fe9335ce57eada3bceaf4c152e6ed9b6855f7c091176fb0b8e6ca951e06f924e63cda74ad8e515795553e8315fb8a7c071b2ddbbd60c10dc4637ee37d49dc4c4ac4c0cf44be172e8a17c9658ebe0975e41614ef42cfeec62edf01cca76c60766d12aa911ccdbbff89efa1b7ebb8aa6236de28b1c4a6b66cda3800387a9e33d02702e436e139d53775f903c8df86e577f2bc1802b6bdecdd0c0e1afd912b774018c967cb0ef60deb57317af199853b6eab73071b6fbf3b773d258b399e3f04ec21b4c430ccc011a80ab0071ede3fb63c5e60dc3a8d1d38d72b06ff270e1cd7d1412dec03b3b0eb547f4eeaf643723fafc8d1003cc5e130ef5563651e2c38e0e18f5a20cec3861e9c3fc6f4161e67435489eaa9f6e4c9e2c89afc1b4c2120e6699e6732264db62e2e584eba141e34e810c05895097d1354efe5b4c075e3a738664e939eea996831338b9b78a897dd968b4e2a4c1da4300fdae674fd187bce1a187925c1cfd5f8157269830b7c251e63020e496f042b6d3184c2cc8a541e71c3a61aa245d8d3ae7ea117fca07a1529b42c699b6e7230883eb87564d0b1288fff4cdaa284fea100c36837b50d92c2c1756e54b66228cd06e3f5f2a77ab6f8658621fdb729a828015fa4b7caf496b1b8963bd36be5c468dd052795663f55961d2eebbd158b8e1bd9ee809e98e0ed63242617d160560696ffff01b4762db02324d173c6f62b47daf8f87bd8e11be30583871a0932f8225d0b21545af6020ce90d3d3ab9c99d9d765947c9f0b163bf56f614d602fb215ca3094b9d42f242e9e518e70dc4986075cee53192d37553b5599c14005c1dec58f479f1c58677050aebde5b9214ba08d32ce0613b5cf93ff8aec95e74b5dfe9f24ce7442ced45b99a0d5e858402f84147dd67f77eb00f0adb41e1ff0657de72a34af25e6906e067e607dbfcf974b3e13a4fa2e8e2411afc740fdae599b9441c626c8315a3e3d64e0a5a5ed82d61b0928e3aecbe6dc12b81cf1d8d2f997582527494f4d2c18542b710bca9aa967ba9487ae926dd225c224ce2b198becb1e5b54e5432864393ac78bc6205b26febdab1852d46f2c2f7abf89faf6ecf4e69c81db32b137ba5261d32f87304ad72103921095ff9ef74e48819e9e09d1d8bc6e2e04dfe67811e348fd4ebc36bf08c66d676be375c748932c194f7e53e533f03e22f99c46c72d10a6fd2946093585f83f8295deda3872117db8ff5120a035332363f0a3dc668e34ea65ef9019111f5ba39b3e0be45b892b2916c1eee1955f28324b944d1a65d9eb8f51c9207125b8dd49cd8e4592541894430007c8a0186b9d476ef8aed5bbdc9b1661ec1bcf7cdf04cb396e9e29853ed651f74fe5e5a478c41e7a2458a2108e1075c388b5f37d40416a08dd2b9aa4695c00a013776a249681fc10a0635ba7d2c043b726283bc2716e837fc755065f95a63ea79332c04edad8d42ead3b907bd5bfa5c326927c2a0d6a71826f3533c6e9904030e204c1925ec066c9483018490966c94dbc6f63dd435d775adb6b7feaaadc071861fe485681ad2386f808eed0eb75c7b0579bd3e9eac55128bc0989bd7139922ceba077ea49a5ccb3dda8465d5a77c113fc872cff2bff8ce0fb551e0631e0c99ede02db773f13ec318bb520b75727b1b3c4ef3b3e4175fdf7410a2a53d4092b5f9065a605ec8cc0ae0d201ef14f5bf63b223e05e5e7b9aab676a1890170e87879bae16f0c531b89cb193077976ce0011ac7f85b6ce7628d78fe3799312bae27a8f6dce05840e6228de971d10bfe3c44b243b5e6eb0a4df6c792aa71babc6535c2edaab30960eec744d6cd013d95c05784273dd436959d05186eedd858e02a65e6ad66c909f42b45503d155d704a5cd69d0b375c4355091cf30edb5fa080e3de710635597c54514afd7540d989e9183a01bffd3b779f4f1d992ee1ae612e951086c9aaeb400b71cd8c8f0d90df79eeb020230413baefebddd29851a7d4f2c894d7e3185af58f1f7d367190fd5de1c05772aba2f21b4c157b44ce57fc96f0d95b1b9ea96de116f83e024046960c3331912f4d33cad1c91746d55cc521b9db9d7cdb3b37a56d2035f38a73a85911667090077eb25c80f17569aae67eb21197fcf55a6bbfcf513ab3a43dffbee21092859bb7ddc31d4b1f0daebdc208e473a22548e97423a46f5e259760137b4eeb1935e4d41db612997ee26255031e91aaf193ec4a98ab3b2fb02c9acbcf72c30a3085af6ae65d995916cbfc03d2ecae16b3e433e1fc368980c8647034c27ed4e01043e40fae02beffa4f879e4569adca144c226def0c04845a563a5742cebb63cbf73337c4ede9ba3038c9cf7fb2ebe28ef25c47ac2013f016698ea819faa307480bd841eabfba718114f2306200904671bdbc7f34c032a2a445cd87cb828819405bc7df0235635f176517b53d5fa638a6a25bed3b32ca0ac2366ef5a21c46e2f8db8db2e8e03a668a8842ca49567639de60e06230bade7ebd1b4f6ca51792d8621dc4461c201d740eafff4cf5af5ca0e18d3e863c1d83b6829a3f10fcbfa4e8f2a2e4561f5e5df1759bbbe63c0ab0410c9df68b4cd60d7dbd6685316184b0b0f7ffb447c9a45f74dbc78d8dbf4eef20068e8f744f16a454e8cbc20244613030c5fd41737ad30e042519ead879d2ced07b7c20d3cad781ebd6034b3c322e163af106463f09c997bd4d7cfcbf2cda6fd1b2755fab10413d9870c0de731171c2ea2a505c340d4baa5666df36b4b572eb96069e8e7765713b29fef8df303f2887e43bf7e7f4d13fa83e22008d8c19b69237256679ce6f8153f6a6d11b85b1e4288a168d0773818cbb622c5c11d49e84983aac0b7dde2ddcc94487c361f127b14aaff2d1ecfbb178e197a8624bf5a1918df3b9d572ee9c8f22c09fae6ec0c850bec1c24441a113150504c767309d60ca191a7f86e4f36a0f437b4c216d07572e13b496f2d1fe481a2e1994f16eb0876448ec3a5a4838bdfc3b0dd68cc404588fe7e804d8bcedbe4040ad90cf210a5c8716f6605ca0ec87ba3b1032ae58ff5eca02fdb8a469fa7cf01d197f94a7fd89c0bd2b5ba7a19e13da3524ef1ac0905692a0ebbe595d714709bc386db2e002b1b8bc95d177f35f800bff51d6e94239ffc3368c57b4d8d2a5e9028292e38d751121c1b9cbe7f62330d1bd0629a44754039f2c5c4efd8a201b3f79ab717195e286c8331466db06bd9dbe1e9949473d1f0fb9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
