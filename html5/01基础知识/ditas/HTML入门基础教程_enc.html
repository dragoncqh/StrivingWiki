<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6aab772b7f7f30ed5c229a08cf978fa257179deddf523156fe12f9d4617b693120721a5398216890e42d3cab88caf5c0853083caed4284026c88ed69e900503c9f583e63d1b381f31181334b7d4e45566edafa40e257e1b7b1ecdcf2b9132f69201137841df587e57d10bd5037a21f87a1ff67d52a48fc44af196dae9d0e3e8813015ad487a2fce5869060a645a0d9c29067a201b93031bbc50e3b190435bdc1d746b886e6a811a7ce8631d040311a7281484ddb7ce05e3f8580e599a088e7f97a079b20171855cce2b46644a360487782916d0ee5349c5861fd880f12d7395296e9f5674ead4860fd208bebc5e299a82a76d513fbae5b8fc42f1d7291c884057774543bbd6dc298515e3e908d38e5bb0216d1afcac2b347a70aa8593fd61fd1a44c059fc3d6ac1d2b91a76563724799032ac8cdf23dfacd7897de5e19bfecce60365deb76f5ff26864b2dd03626c29f18e267ecfb3e0caaff5eaf07425562b6cf5854c37f9c4a656d1a3f115b8a988c7e96db2ba21f05ff0f5fed1dcf0de025ffeebb7ac42e1b4a95b79ce8c00464c4c141d92c07b65e5132946ba81835b17f1805466d01168888809cb641563882665811e6ad3ed7385f64e3024b292c1c01d1f19c08fc66f6a2609e9e5bff1b6fe25ca68d817df37189ed1121e6314a142932d1ddb1f1e4953d898083d39bdb9675071d30281202c3a3cecf509375486945edc213080d8b442fb306457c981f62845f86a042b17a2e26fc14932ebdef8b273379d67e6899771f61ff811e63dfe12741c36d4253b3304ac448c00cdcc7c8506861f9bcd7562616d8b2ad2334e4ac2cf2ee6a6f2f9abeba913daa92350ec6e04c6d04965312401088bb5675322b2624c3853441fc2b0d30473bf6f1d6a54554ae825ac7a04b74a477fc6709e345d8af5e1da34413c399019d7b4f5219630a7d0771fd9c32e1a49582144f336b563611341596a38fe42a251ba2798a83bd33fe05482df2c2f52dea126e51ffb9a79bb76f870a1f57c7fcc85fb85ce665e0f19162c36b2234d4f12619203797a213244165f824dd6e3d31f2d488940302deaf5e5ab1c180e34ece2f3f76ce129142fc402d289f3988f232d866c2bdf106d89a9ea58515454dbc72e220ce76216621c5f1506d83157298f4ce789a52e5bade3ec5c61aa834d1ac149f6456a55709c976a17a14fca107d6ef61002fd9725b7bc4039e7ef42ffae3ac5e48351991adc07f804a7fb821cac1c9f68c6ff79f63923f454093290754c814841195615f35c889ece6a67a05136baf5b396c8f27001bf879f01b0a12e550877faf764db785b4cc51e98034b6aff971ba359a064f61878530a4bbd1a9658f82e13d271b9003e107b6cfa015394745df9f077f8efd3a1e4bec334033120b4035931ead6f4fef3be6ff9424e272fb00faf6baffe8b576058754ed0184800d32f36e9da27eafe329995bc5be60150d80635731435fa750d1e297b8b032ea777304d98120beb7d41b80edc9b3f5a91001c95cc9db0923c49ee19207f14125fcac796aef2d8fbd1416b1499e4ee5a989a5c78a9299e89948103544f686e179a269f883dd20f6c7c42cfb54f4ed16dff7f546daafc0e3b7b7c58494e7940c764c85042f6ff0f95a5f276af1403981b6ac23dc85788ea5d338adeb8d898c874f3ccc0c2e3087fa5564e1394b3010755dd3d36e510ea889887a3d6ffc199ee8cc168ff0239912b64de07c7ce515a74a90c0f096933293ebc3f8af3756e72944f20deee3e708fc76ab990c4a79c04169de2ca88a177ae573daa36f944cd38279c9c5329eab77b092a0ee62c839529bf29073f16085cca88481791ddad856d4b09278286637317c0beffe7c9db594aae868897331e0a5518138edad89c0cc5cb644948c69114dec06ee9ab362fdfd8f71038eace00e9afeaf2f730d6c27dcb1a41172bcd8f35bf7c7b2ed51f83a1f0553abf1988b837c029e4bcbd0c84226c4de2b334b01de84431ef9b08e8747da896340999b7001d366678ca9e43cb58609a5dabc7cc6feefd1dc27e6ebccde8a11a6a421a20b13c3b10c34c9de8c3509dcfeda946f00f07ec7a70e5d5f4fa83f592b1ff026d74d9315d7bfce321ee8c6caf5a8d17dc3ac47341569b6a35fa198c6f3a37c44345d30b0c1a1d57cbae5ac503c6ed7cfed414474b833526e357384db82ef0d749035e4ccbe66cd0fc9df2d87557bc5ebf4598694cb185bd448e73b0ba216acdf4768b733a851324c85ed46f7bec0564faf78d2011da9ce5fc7b1d79213b9e5afc36939ce3b9184ff753bdf4a00c9fc9351d3b17b633c2c051c27cb7b7019e0bb143050369b285f09d76ef728f75b809e6944350a3a4413b2dd1c7c3708f4bb5c66492c72143751509d966cceefd5caa2f460dbc27ecca9505e61d395bb203e1c34dcf78fe704ea9428b601245ab037470a514b841056975e5f9c1c0cc98da127b64b74cece18a1c9f034a72139d4089724a69814c8db31af5259f113f032a29dbec689e52d6efc13377b7d1da81daadda7b3bce90a923fb222205fb2af399f7164353bdba96a0f22effc94622b41d56b70013b9066165626de34bd41d38a961f19a2c9265ddcc411173d01f60a177a404c8202e52cd9d94366e1f76be98cc698edf194049b71235e11ff82e5956b255e58d7755318c06897ae0538fe08832b16b7e50713040ab6f1e46c4d22910ede57fca917f5154908e14211adb70ffb3cbcf81003b8589996b5290c3d7b1559b49e73b24d2f95229994b4e8debdcb03190ef17792faecaf5fa7c854908f7d01c466fbe52746fbce552eb40cad2335b79e418a7e3288239e6b0500f32238162df3999c9da615fdcc99a5acb8129e6a9968c16937c8623fb4d66afaf053f7a53c43234bea3fdac5236f59a80adde56970b9a55ae02cdb5d99c31caf7c93d8892b173f4077841888d91df38c8070c1ec3365b44bb2c955d0003122007d95ac68cc2bc800af631048d02cb04c81dc1f208140e925411f84448a633319156d0e693804921b3302a82e4d65f2809410d11e45dc743f475be75f7ccb6817e43841016da31659ca2fde40f454c3c30ea17a8c0db5ad265d781d190454ee00f99fada8682ab9c44f988d85de4d00fb6992688ced8ee6ea93b16581f4af6f6f95f3b91dc24d007446414bf051e88381ad3674838a32d9a05066d6159a15d117f7809f93f5390958ad7b1ad68001c3a040b2b516fe41d7a022dca52a9a25f6e5f4afe6bebff748845b0b0f657cd9e3cae0328e5fdbaaa3a8468e092ca7fb111eb64f48771665a1c2e10b20021ff68146f3a554ab0098bae763c912ddab536467c925543e23b6a44bbac447fbd037d6fbfe966384789b655162185a7239408f7508218abd8a106d2286e5e57d92f0da0948f53dd2592d508aca2add640c444d702d81a439d6aeafef5d215db37343e82dc8bf64c70dbaf6ee44ecf89db24cc45440abb55e29b33b3dd60a5f665e9374e13c06323bd1949bb54861b6dbbb7e6a1dc7a783a6faa350dae2fb253d390f95d100e87ffed0072f72254ff810cc342224d5451fe11f5dd33cd7d37012f4a05ac7b9fb38a279059e5d6125a285f1e5b136fb5c483eb4ce85ca745af0ea34266ba333f2e8880f282dfe472cbe77bee3e677096fa2f5f24fe760030f33c0d50f2281204585011a6bc4436cf5f486ce038d3343f4e0aae9a286e657463185244eebd8d0ceb21f031bef4d54b6cf0a2f8e4965263061e615a820f5904c5293346724d09afbf74632e5a07700912e2ddba9efb1cd8c54e6350904a52bf37706a718a7161c9ae93226bbff1d8137ee287d83849da6b71a055c425248a5ac9f63bf28e552169110f5e6ec8c39bb0844fe37d5595c72d16b47c6ce31673a3843dafe97e68a8a80d0b221a28568d5253faa315506215cf0667e349cc0b08a6ef994b7d5d858fb804be1f00e643a7bb40d0445bcb229224deca05f14ff374038157e69e7044db4daccc437a10b5ee039b5b0ffe14fcfcb861061664cc2bbf65138fdf8d832e9fccf2bb9d4036ed27681f5caaaa165c2714a07414459cabc6ca5bf4adc9b7b62a605be8c7d16080a25654dc051f33ca52bc687b751d5e7c1a94772e9b2bd2df68e4ba20709af12c9e7df4df2742d4a8a1509384bab13d64e388e41abe4eaa73123725b74945e1211d1ddb1425f7f53e6e98ededffc749506569b440a7e3f3d04a5143c3a8abaf3b6d37a68248c2fcbf6759bbfbe539155d292e7257fa6ea1d55d68bfb010d1c5cd1c8be874590feba35ffafee7594493903d1a33f3bf7fe3813614188ae866bd395489b720d9d21830fee87332b2e84017308da9f06ec63827911f0e3e1d73451af856bfb49321b735e6ed8d851d6318f33a2858181471b9b7a8749a0227fefe93339d8f1ae0ebf3f1e825d152ae351b23afb882dbdad796c40ee721cfb28b654b3fc61bf6f69c9a592db6cc36694b96cb8f5bce46f5b41a85aaced5e217cdd3186ad4389a2a83bfb78b733c88dfb70a74be107af8f62daa41a580078bd9d3bbb657d0b4ec1d1f1b59c8145e580c34234031b03e3486c7b056125b21c4614f782c0c7db5b344c5745e19223b6691dce3e670976d8cefd4e9274272d9f28a53a49188832196b5ec8528c6b49ad22e5b85d88117aa74287dedca2f9e58a3dc298f370a0b92955b6c6e4dcdc92433afb9b3baa03f2a52888e45f4e90995d0fe7efe659252b09578eceb567100fc72bc287d3d3ceb632b6515da62e6ae9f09859aecae62b4e431ae3a5a40432d62f112c6291b10cb2c95a0b4fff89fb9e4c39a2b2f6340e227042fd5664161c03fd3f001b7872a6b036032656356ddc4a094b1ce9d8ef2693aed2e015b4ce3e862590cfe45c195b5e02f483ab1f85a7505b1e681d735fd107c424285caeedbb0f6cf318078c8308a31e9aeb8ef1969caff320a90f6836dee6a99756bd8ebfe179998d4d648631135c5671d357f5defd43f383651a2b6b012f3b60161161dcfb83f2ba8834c4dfa1875348198b745d90bebd2faa3a7c6e8afc0e41312b4f58ba33715edadb570965949690f21e672984411b21dff50ac4bf0e3a36870c738e64fe2c011ed2aa2e8cd9a4a1ebf81f5602933ba33789f0ee8c36a242981b8dcac8ff1cd1f275416f7c41e6a4d00d90c03133e02081fee7fb856242eaf26dd9a4a910ce5adaeccdf56c03728663a400190cefc6b57ec071ecf81b6b794570f8480f8a0b76a746474812cd349bad38a1669c422f3dd5dc5c314cb2ea77803f10ed445206ba19ae3394ade77798242d6b54f44260a600843b8bd3a9667d3e5173117b22fa810903282c2699dc7fa82b9f2b3563264750c5b894509879c2958c797d442577e81bcc0247a4bb02ca8d27c902dec211b7db88ce7f86436087879fb6fd4d08b878a2ebd3db0f640624eedd40ce9c82231e80ef76ed53b4dc240938ad22eb358417572fa5d7ca8a3a7987c3f435171edd9d870809ac22919d0984c7131b7dfef9119102e2a9d260ec9d4ae6c61c3c1e07f0c7603ff9e24231d3ec9a1e94772de89313230f645e56ec1840eb7d73dd444067c3e2e13b22e6ed1fae1ea7c1da0398af4dead691753dcd550f214bdd92f31f67fcfd5f4e9cf30abdc296cfc83ee55ac63fbc803c104b6fe6179b1d3cda5e44c867baa021ad8dd5399af5ed399f0d43e8dac2d52181890157bbdc6f4dfad7fd1b0beed224edeb2790f883d496d13bb5e08753f68bec748c4b84f147c5f1d2ce80ff3b84a267bc058f4c69cb48844236df34602e3577a3c925f9d038e57a2c26e8ad069b9e535c5f3fa70957a4646e3b29b9c0f58a064e62ca90edd45f4d6c799c3aa3717bd3ae5ef9fc73cfe416db5f2e78c64e366c0b376221423839145d371733378cc5165766dfa33992aedd59a89d6c997231b41775761f37c75107be3600d8d97d26857aeb60eda92e426976ebfd23f7d61fff2d9ddc871cb40d97ad82c481d86964ca9423060ea88de1f2ba3f7f807657eb5fdc1983d97fe9ea1347131dddde6f1b1040221847ddb655a2ba76b6e99506ee059e9f2431b4b6902fe6dbdad9505aa420902dc5bc171de9e7bd1b5c715fb8ef45e6569be2dbb989f7a15d6e76e95126ff971cbe7fe3305752b9a5fb0cb6a2d81b5f0fdd8031d4d0b96e6f79b9ce26a4b61ffb4cf2ac6b4036f2b80c7683c12adb54ebad9562947c81e0d6ea7859311b71fceb4895607e059c622748c4e5ea436084cda4232cb679ac79a3d63ce558e0cf1fce3df7a7b1c5bed35fc381817287ed56aaadca975f2aac738f641e8261a00e541a3b0e6a798ffb26a205fdf1f582586ed1c7839cd41eb9ab3c0044b330056ea318b6407df55b5c3013cd19d846ad3be20cd38870a3c44bf073c25048226096b83ed4ae0f2197227d1490d2fe2f7c8f811f4eb6267016874b26f596b9b5c4e2d768d30809c7559b08e76e13b372e079e9b82e63c204dcacfc7856156f7fb965e7bd08bb216722aefa1cf9d18ca6ab689042e1eda9993d53d194c70e3280228858dfc8c76fa37b373fb0419a11c691483bf93ff0cf62318c36719f83cbbefe91c5c6ab5bc2f1d553890d412b2f5c601bfc60cdee8dd41311b152f4591d1d8d00dd8b3909934a568e9818d11cc458cb1ec161eb8884b4131064fd0f6646d969563f3329244dcc29b5c47f9ea65158fbec9fbddef750efee98d443b271f712bd5b3a74253a80f331c764ef0ac35b5b4e979c33c23ff0cf2782caf916ca551d430a0f4cc6885f99daf8cef239a241c343b842d11fd3e5f9ead8c852c76b8900cb8bc53c6553309a0a0865e30815cf85c61700e6f60730e20cc5985e1ef153ed0c98e575190f426bdeafcc22998e0ec5b3219fa533fab34654b4ecba5276a02a4b41cd9a7bb633721e5a58b5c4a0b8de51f596ff8e4e209e880dfcdeae033b3c1dc639d8d792e077b16fd371c13dd828ea43e840b318561b0828b72d37cac36e062b2986b2147fb67baa27abb73f442069c8f48ad0191649e03a05de4870e36817ea656e366ae41070e57632ec6ecc54f9ce246aec46c5d3ce12688780c3c849afcd269dceb7aa5f490817f6c7ea85992aa5976b117997a81426e38cfc4c025285075c0c74e7ca000345b302df8c24e0ddcf5161460aa793fbe990d7c0e04949fcfbce07de4ee2e2bb8ab6939da5faa009d29a163190182a027ede237cd14fe441767ba7e4f7482173d30028a84e9027c21c9fc742eae16f49adb64c628c3fc51a1dc45db68cae1522840f4f2086b59c1d3bd9f733afa04eeaeb7e21fef6891abcffdf5af46931b72404365bf23437389a168918d76c1d8be8d2580d0189e8341269a3900d3485245e0a39e5c9bb112a3db076e722b5c51a8f16f709db6586ab3cd498a717cd2783fd9ceda19c4e9b3372e3f721ee0d9dc4ba4bf0e24a1b3d320608c991937278f891d398bee9a883a53e55fa7a03559ee0c75e2b2ac6780ae5fc77ed282597f5d32498ec82a358d106cf179a33e71695bae112dda4d906fb4e40a22a8915e17c43c4024364ff2e2c1cc9e72951f0c99f9c2e03f9b517e8c1f624031ee7f68fdc3ec1731903e462c5136b01935eaf3aa04f28c3c0cfd5f268a499eb1f3bed37aaee307fe23e73eb9830dd6f739a2c89a0d464ebf0c0acf73caad71498da1e29566d56bde6b347257cd910038f02d847d21fdc083410be2386b90ec58d1188dca350d1dbd1c9bc0c52f78cae9c1e892dfbb145056ab0f4b8e38a98cf824eeff7e32a986167c35593f0db6bb3921e289a23acc96b2113a77660be366abe4f171a4ebfca40d5f47c3075e82d7b8c6437f12e02d83bf1367d24caefd07ce800301d37f8e13aad05577950dc5d172bfeced5376ad2e17c03c36c710fe0a7ce0d6756bd1578553c25d84597741ff20b9f87f78aaaddeb00382d465564ac9cc384efe1168f621abeabf6d6d327343dabf5923cf95148d45833e49ddcb62a5374d9b6d97e55ff67fce7390f01efac3cc40fd1c1e236bc8530cefd0e3796a086b8c628017a4cdfca29660d041ef00b29038037310481a33ae7fe7b9493ef312b777e554d5e004194a5c7a57811292306a1272ded9563aba7712a89978a49639243985cdc7581d2742ce8e60a16e374a750f3683645dbd652177cf8c26b8383de2ad8ee7d6e61982f70dc6fa7775cd842cd6f33428379cabb0707dd171a8bb256cfb50040d01b408f210710961cbb7d214c5764af353be445e31fabf6e568f9e91ba36a34d429ee9a0947c3e245478ee7c06efa7a2cc28bc23efca48a9090eaebee8fc93cfcab34ec4a3fb0e6d6bb6d2b539c6e2d56c3eaa24221250d625974bda816aec231fefcfb9ee0c667e9f159e669553bf162a424e22061206422746025b658af35e93d872631d0db83ce3c45ca6c8f28c70bdf8742643a6a8dc29e80d3d4583d6ccfc53efa14288406c947fde06d159a60d8b8a76f317bb61043d69a11d5c9e9a8179e6275a74a1c9c80ceb495d38aac6352fbb8ee5ca1c5b2df2bc02ecb05436c4755dad48f5adf26394fc43fc85e3ad8c26f4eea5f5dbac19331dd447afd3f150e6ac75707525364803d2b398cf809b39d3938d6cd7c19a642612991adab700de6538e1aa899405ebc43da3015cb004df44110ba2049f8981a2abfc6c38b23baee9232888c5c8661c9b6719dbb0bd3aa6d2ac3377bccb40fd742839a578eaad2cc90ea4848d6516cb9f1efca0f20722e8c9f3f12458f477967c0b2c034b41629c5629c6ddee21f7c0ca4bbd6e8f9e6086a0fb993c150789f8ee935122e8950a6e83f2d91b8a4f41050b06b25a80825bc0aaf372e32d78bd436364ea22c27f2f457413cda0ea2cc57eea9c742e4161fe5dadc727c347cd9824251341ce3deebc9029ee74f2d4b93c4b1a2ed9bf99e58aa4925df2c9701fb3f313febb646b41badc94c34740acd6513a39b71acfb688097bc24fb4c695f463f8aab846d5270e4f1099d9b7d8f4fa0b1afb49eb206ae91d62be4d1aee0f556dce6a3b69af37a91134309b03c843e80303940faa621b115498bfe709e2a6c1fc9fa2809f8404ce05111f229ed1b7436e3bb7ca3b170141da25eadb904d07fd6eee5dcbb57d1e7eb98663d94239c21e1a51b2c9e344a5ab9233b1a22a69d729d37269b11ec2e18f24c2542b71187a8d5b41f1528e3d37ba9c68e2bfec1357cbc5651aacbf0afeef2d60bfe390fc1619bbc43c9a3be32c682459f4ea1af28f75e139456527b19d3f0bc76763752e9b401de151231b5c7971c247c19859a0ac5f300295e3afae61c07b03fcee55773963a780e6582486d21c0849a6f57c05396c965bfe33d762139ecb051d24b7365e8b022c4e98fdf4d685dcc07e03804f483f2f845c3dba54a36f3201064ece7ec942649d1d08f07d3b3d7bde49697b6a450b72decae8e15bd04c52864760ed98cc62ccbec8ec1f090f0351cfb1645b6d8912c9ee32c7c87dc76b6130fc913463f3702a2cbb2af64a92b4352212c7284c7d940ba0c835ff0b654d4b419046494c42c63e2592ed3397abdec37efbffae1dad701dc7a6c72e358d4525b780c59a31dec9f4582dd20bbc63dee8790742c7a65b07dbb136ae1875113b2e44888429deba9d31cb54a3341de5b4743a4dfce1840a617957fa8c313d750421973a9bc940947fe7861e254bc617c2bc4869d4e823405933f66af11772c1e59c96886c1d18a614807a59b94953d41ab40ad4392e26c642027bded12eb830ef3d35c5dab74496748480cb8794362d0772c418646500d8a388e6f2c9ced5ad321c0d63ba4889b4142b2fe0a8b6cb6d4668a3520b8acdf55f267e6cd0f64dcc0dad5a53247bdc51ad5f38da39a095ea8321dbfa314714e4fcfa3e0abc67a1a2264fbdfc08400f865a5205d494095c219a0f967e673ca622539dc3c9cb99d75d19b21178478e28fe767b7f8a6537640e9ab78149e188436f82f2244a8c9be7ebf479685188b83fe36482bcdd2ed0fcedc051c30bed64dc21e84c4e2e22c2ee5a357e1b108f4365933ef8d11385db020cfe7b2708a2057ce7124ae3dd2db541ca8d2df8b34be92cb03f70852a9a0ef664839da781b5277d2d477135ac603cba36b6647f06e1802ea57d04e93cc6bd796d7b8553fcc4dce91643afd7b21d7e5f451d2f37e39c5628636a5cdef5cc95344a80e597fbbdfcbdeb418b1d663a2caa9756da9647c8f60299f4479728c6fc7c08130522aa4a1a963dc63b8e981e3dbac1bd219399eda4ffabee4d609ff6999caadd6e8d8afc27677f0b98365ee43497396b68ee53374538880294fe27f62225c66b2293a89beca2614586464959421b6e74a1c91302d0f6f86bd074580f3db91bc2959c7aaa5ccb536f645547932df6a86ddeb48759a5c51f633c8ad05efde3b21666f0e04c136fd6e0887efbf98d3e7333f7d98f2f9806dd8bc5f0402b4c9b523ba2ea4d7a8351f8a55fac69a66e3a80059c4694b063904556d22053eaa682884cc0ed46f6052fe983ca0b8965f01153f14d59c8c0be4b1b0571265586f2152fbf4bfd069ac523bb200922f929f178040a8302280743b7558add328622d8350486ec085080448fb442fa847cab01041752ddfae869a7d1b5dee4666f9bb279fcc1256daadd31f40178e70a1ff5e9db3872fc555cd026f03abbb1b76df14d0fb219a3003ed5c14a05cfdba2ddafd15d6c4f7551c1935b3f3e52cb7ef7df693e2170fa6757d19862420f5ea503c0ddecfe635c6df804b471438968556495f2b42241c14db29225256f53f74200a71925ed97147fb640cb5457bca98bfd4721e10097ac1b14f78fe4ed5cdf785bd71fbff90edee9e7b8e7c472dd0e06946b48a2fcf6e2939b3785d2a926e990a7a51feb1469526defce0a0fa995f5ef44fac9accdba33492d9a0bb3574f85200cfe1d155b835a5ef277a6cae99350505d9f566c3da1d167105381c9e5079c3220b4ed51e0bc3c42a4fc985ae312ab932668adcb223348f91d4fb1998f165f43fc9051145e7fbd25ff7f20d4a9f5c6126f14e04a2724ca5568dd3ccf41a8e7623c121ceea6b17363f6e05ce1ef1a7bb24c48c8880593b80b6deb23c9856b558b05f8e0d20a0448526af7048e6e9d4fc38516b30d8e1f000e8fba4c2b739d7601efa268cc3cbf67f547cd1cdbf5465e225b5fdb4cb9dd0f612c304086f84e0efa4e9e1a5c7896d1f870d10bb695e6523d4947688227a1219330bdaeeb217bed480ab9c36f977ac263da41b51500aae9293c8679074cd57d45e74bc88b28049ff5535226c84dbe86c75204ca17d51c005a328c0605a37fb07291daf19557bc49cd2c87792872d965fc1316d424c05055d545f7706fffbd04e2f5e98bd93acd3388aa0d3ceff579dd5162c8c86f39efa037ba77062e77fe05dbf01ef03fc796938466c13abd563980d6638778e8df54de281b778655ea516c05cfb5945cd56f2c3009c34eb3220c29f93a40ced8adc528af694ae04fc9a5583ac468f242f30dddee0aac78a8f5d9523ccb852af2c824c9feef0bd19a695f3ec1a979ebd105206c4fe5764523b98dddd0c75632a642c21a03cb7791bf6a77afacb0bc69af374275d508ed394484d5a9429bb01bd2d7765b756289ce3cf92256d8df97b9eb3f53406cc62fc8c9c4f9be26c84a0aa82c89e497f67b9231e035fd51a9bd1bdbf126167b98883eed9117fe75dfd2a7c203e25ee23878d8731064472fabfe343343e2a3c337369bc3acf60b410e7b8cb9a4ca1cc20dc078002b1a0766566e048247c299cff3f47d5097b996e90118063d23180dc82270cf1f32ba15bc96ba01703e0fa0095b4d7164a21756f760000bb72e8d33e139d80acd68c01fc655abfc1c979d5866f2fb017db839df6971ac15f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
