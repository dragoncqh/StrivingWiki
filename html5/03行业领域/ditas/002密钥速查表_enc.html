<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a275616a5c0b94b9a9a7b2caed32b9ab970d889eea7d65361a39e8a88cfe9916323ef62d29cd00caef51feaa419c3739790b93333c1ed0cab3a50f2237035f919638b8585d82d772a0fd84eb28c1a9b48799b50fd943077649a3f586d2be7441067cbfe380b6d7c41ea0e535231a4de85df187c7b1280fd4e26c8a27bf65dd6841cd2a0585ef2f615a8db38c88b0e247309a6d9aa0aee872c1b7ccdc499ddca66956d7640d16e5d79e77584dc0a749c2ba4dc69d3f6ca5f9724c1f485e415d0a3d6b5a9af9791ec615fcc1dbbfd4ba74a5cddad83f85ea39cd6ac05ebb271104bf0484156ac749294265574f2b627d5b624c14a81519ccdb7356f62a877929e9a8896391d9ffda0419c90eb72ae09f457965d11789850b8318dd4432cd26dcb81292c1ce4864758fb0ae959369d06b3403a6fe22bfd575eca6c8f97c9c382d8ad125acda06f8629ed599a887f49be2af299fba08cffd56c66cf0e168449d6df023d926d8986db7a92132bb9cd34e5645e621b5277f4671ab14025a1703aab82d1c0e60196e9e23c28f923361dd27a63133bf5d42ba7c740943c85b0d15742f25f1442a874624eff7ed6d537fe0d8e7e17c1f1c69cc27869529a7e5aa99cbce6e4f42b04584c3aae0f3e0073d3d86a63920356c22ed9228627a5f60537e2003b9d4c0355af277ebfb4ba19389f14d87820f6bf667587ee55296ad53a9425f54aec3985039f7357bd475bf0b12a815bc8c5a63107f9686f02a220f52f6dff6e1d85f0e53ae808bf9804b28b05ca25a18bb6e718f9e0e35845cc043ab7c78dfba7275e864d5156e851036c20a6adbe618ff65d5b97aaa55cdd6fcc926483db1444f83268a048b4425c0555a8cd07ae5f0867ec62fec697edc3aca6ac2d921932d857e69563516f0207ecb0312a75044b1f999173c9bb71181790e81f09146e2efd9ce45f0da6e0b8ae573036260c2a3c06f34f0a859ea2fc3cea56defea46c8e72fa1da121824ff98e6717b9f10921a7c24f91125c8085571d1cc2f0a8097d4d7b47bcad527a4a31bedc1bb18c731a6fb91b6428ce367cdc5950e6f686165143656d45bfd03aee5200f39868ad37b14bfab4c1b661ece6732ad405496377c6a7218d5da95fa32ef5a6749a74b2925bf75b94586387bfa0765ecc6469732be83309e2a2e35b21a63efe56a30d745cf96ed69bb4dd8f4a55b68c2ee5e33896c3143a6d09877f98d626494dd7fe85338d269bd1ddc5fc1216a03cb6d931ec208109c925597b0125ebab7325e2b655f7a3b88269792088aa1f617947b61808bac2808022ef4e93bd268d88f8f5d2176239784cb2136e60cbf3e490d11d972d691031d14d2ae6044227ead227618398ad4b9dfcf4bbe9f5dfcb34be9b9c391d5648d0c650036179669c2b39552560ae86521f0dbef1ce9b0664eb584dce37ef4e441620c7f81457f35e4f09a9a505d9bfa18ead7e51b2d96f86fd921f553a765a3836527f60b57bc40f4da3daf8e13b021e11802862ce38e0333f0e88cd10fe0f60f5b964b579f76c6eaa2822d777d337b000e75e05db577b3e02bf338be975c7e79fcde6f2322842ed79fd4d9863538252411c7013556980e9832c4ca683036edb749d3e9c43862d3199fa829cc2387a8eada07ef631a1d057ab368f4863df5c02af478449459b3746ed904cc9f476a3cf2868f051ebeeeab68578e889fa2aa876ca4df08af2bf230167e8040066cf8f58e0473c228b8a924c9307b3689f0212cfdad882f29d9167d63ae4650c7af0bb8a3d4152326cba39e2957d32e4b29345b1b0bd999210e4747b843c9eadc33f55bd1b889ec720b356ac77b32cc713ae87329942e9f56eb8085c4a3dfcef95896b3521c6bfc7a761828450812d0bdbc8105937e7b5034fa78efcf52ed95e3c4e54b2956f8cabe294d7348c4470e4d96c0c0946c2d98c1c7d9acef85a978c8bf832b98852b5834e5c59eef04a10ab3fca74ca5b936812ac55e2eec3665269bba8aaa6e00a5489aea6f125c1c97891e83966ea9b7b9de1a9955db54fc7743456d208e8b28cf69b43bd234ace4829ed1ea52aad6a327e08ba991ee61c6937d1c70e7a4adf4fc6d753b4b4621fae8e8c5417dc7570ebb58a2c5d9207c6fa7e9630e57f62a8a28440e342536b3a07d01bd95a9c84a71e8b9ff638dab3bfa9042d3d08b7fa700e336e96d4bd1d9d8fc51efd5a9b42259b6136791b088ff5d93e6108705cf4d95196449acb9eeffb75329717455025223f44013ba7555212e302d8376142289d15e9bd71c1e3c87aff43706fd408b1b3fc3dba8918e0c0eac420a1bbf4a29a4de9dced3ec1e2ad674478e8699301c83eafbf29090f318d0314336b93a44be11212487a10fefc762fb144952c927492a54b660ca79ccfacc4d1e16cf2f568c1e1c550500dbed511d9238b49a28dc8ddef0578fc7cb0ff3a53fb4267136285d6204628d18dbd791ad59df8661d87f7ae649e158cec7b3edac8309e0c8f362ccb474e87065cd35ea7fdb48a008c22eb0231f01c0a1200ee8b1d80495e269ae67ec56ab1c5a3f462413f1c46de75f557b724d6809ab61cd3d02eeb5de1adbab5045437830f44302e2669b1ac071d88d76eff4b2a1bbb1e6c11b4dd247fdf5896f83fe100676c2ffb0082f68d5731c99d4c49abce1c581ad80bd26a1040f1ae3836701d70521289bd6f80c80d77e5a8974d1f3606eb356470cd9490dfeef01ef04dc573475eb33cfa955c015211346e049802f780ce9bfa19429f46496957219e2b5e6776e6684a1107ec0ade1fa43d27117e7d31571b368bf6d276739a29ad56b13983722f5dd5ec773dbb5216627b4a53c19619530032809dba407166881347b5ee6b688a9b4c8f8ffa5c2aed7b23211bb87677322e618c4b64c9ea554e724278c012c1c1929522a6d212eece296a3dc6381f8c7609445fbac1c151705eda903a1371354edffae7ea362c48fa283eecb80a757d126dae69c05294174745633a7df28727a5526f6e6a7c91d7697dcbc848bb4a96cf1b7490a0ffadd815416d04963c2c9cf2002d218735cd7dd73f83b7d9331c08d5a3c90fa1a17a5f2f4db2ca8d3da69bcbba4e0cb5ac6e8e0ab17f93b875582cb464057be8725b0d2cf295d027de6667139f134d29db14679ea6ebc557b96fc6810b1fcbc40e0aeb8d814377fadbfaf8a96867038d61ad101f757715cd7236d3d12856365eb554e08848c4904b84248d573af944249ae4262b6d5f682cd8c8efc1eaed07f29295b0fa66d3f356344e860bd56a80c8bb9c5d9a8ee50ca8f2163d088faba497babf562dd2c61d61493517171aee16d38e22913c21e4993e272881e953481a66a21ab67027f54de95acafc7c4664250c41762291ccbf6620fcf7a9f5bd8489d76b6ba0e1166a896ad4704d42f5850147443ba4cfac50d1b071fab1eb15e66a251327c7e0d15d82db0361150893f30c1cc28ee76028a8948f2736fb9a1694331273ce0e9ce46a132a875096b13f069749804ea9abf361fd61fb672a4e61d4a1870eac9c05d915bf2059660af8229f01729603bcf4aa63062ce992a7e3269d14a9d9feca872dc0162563af950d95c67cdd66d49e2b24a00274b487fe0a4fb00733325fd68f18fac183342317a04d4508b8dec760bb46ad6b02be373ef8efa2aec209107d2d02db813f3ebda22ac4d753ee4b1d82fc658cc5779e9008f366e25bf966bbe2aed499660e9e8215bff57e377c023c10e1f342f7adcd0dc5bbfe0c79185307785dd46f00401d1684a0f18a9ec23097f83b7c410586b9d858522a08dbfe2e9e5363706d4ec3d19f990c76da02f032a46091307307d00dfe11a64ec913a7ee92b71a6d284ffa331abedebb03e0c75498b7a3b0f35ada586e076282b01a3066285d6a69bd29dddd4a1f8734a6d3eb4df72164e224fb6d2a4cc0e76df416ab6cc780fd120108b53f7a9c4601e78be4a6627ddce558cc0e5f4b66ba4ad8c6bffdcad6444491237fe2a42d38d2a8d4c5e7c0246158b7164304b420b9220c32070011f314938bbd65d08d0293631de59cac0cd44af3fa4857a5315049fef2ad151fba4b842026ee690a7c45ce3251e8651320b36b306bb94bcf34bb74f9f9b3803f200186d132173e80180f50da3a88809c89bc37d1d6cf5074cafbf1d8f699bcef47467b13049ff9ed5000a211d179b573c05de184ad038bb0c4affc8ca97e251d7cd4343678da197abc322b615bb4fe959c8b19f676da690fc5c112f0b2c8b8b9f1dbca020e392ee56de0049d877c1268b60bd32ee42cadf440b492f1c58a008c1c207090eef7462d535dbafc68b6b1eec52efcbf06c0740b94f5faa628863aee8c687e5d1e25003e1aae1177f4605ad88458735d40a6a8ac1a76443981931e4ea258be90fac7ec5aa68cc453f1285f71578f58825691149745889c31b2df4bf8d89d31e5a3a1bd92595bc90f02826783687938cb5d1d44621f4f45248aedf8c82ec2d88d6a4b5cff2d303bbdcb305ab558e60bb550b39578ba6eddd85c608e6456f8bc8d62cb9c65265bcef2b5a9f9bdf816366af0e9278f5c929807c2488c7cc768d952da6a4120bb9281f8e27b99e70b00b309961c18a401cbe68adc3d5f50644ee1c43b3573e29e8e7e61e61f0695252fcba9155a0e3cdf97e92c8a0029ea0b0eade2aaf011c337b371b4951cbb96bf7ba24f52bb376f67c346e42da43a7b7036c339ac001f06db0d60cef1f13137156fd39cd42089ecea95351187a9c300be0e2c027d0033a27acbf560e2fbbc68fa3e2b7c29f2b24bdd1b6263805e94b674302aa2fb395e0898bcd26ac0f11a30e5518b289e3dbf6c9f19d74358f8cbcd536dd9378cf7106fc4ecff456a463b2548bf254c010832bacf6d15cbf0b6e2e4aa86f3d2179f6209d027353b8a1a2a0b0d67db12630c1cb8b27d3f2c074f3a4de76136c59704b1cf857d23bd7e9ebe4dd9660cfb7d74b955d401454e2b6f415f9de077e8faa370160d1be3302ecba2dbb614025718228d264a5adb0a3f759583eabf48cf66ac2acaa5be9321d8e20eba59c3499bc11b60a49657264b145580eb7e4853da11c7a8ce2c7308f45e829897ad02cde4ffd9b7183ff77e3bd1e47a40407bfcfd06baf2785414fbcf422345a867bbbef655c9e7cde686575efc93b0e2f07c8fa21166145e3e729415e041639bafe5881f6e97e6df2ff071b91a92ef4f4f5219686e78161fa1230b5d340481a4d73037e1be4ed77300e25415e1350e4533e4c97979c04f4fdff036e899a90e3991004ea30c7ca60a242ff447de19b6fa9b7cf23e1fd367a3a5765f12011b68a36ce093367032da31727abf94f6bf3b843653fe761002b62173bdee224518dec93e651b979dc5aa4c822cda38bb55f7289b99bf267743d3b384b011d9f50182838177c497c0523dc1b1c91cb3d6d7bf416fafd43bb9877bdc52e3c5a91e801eecf941b8f1d8f9c9db381db360ed49ad2c613102a678c0cec2af967ed751da35bcb3a4e8edbce9f7181023106ff17e11fd1e229821b659e20f2678e691bbb4ad5327ea70df897bd1c14ceb7f8092b4d4bdadcd9d349382ff5a2007956594d92e576ab2b01533c3f249d6dd0718f1974e9177d96a5ec78b81ea5395dbacdf07e00296a1a903ff3c98f65e46f7e7d008815d277d6e6a4973da3297e69dd8615b7b614df934f46b764a704ef0e2c555e630d55ca1f5076d6ee49655e1a7308af45c3f15df0da51f6f9068b6a95e13f8abbaaf9c73ea766f73ddbc7e15cbb388e35c02227487e44b20b762853bdd16f0b5ae5cd40aa0a99c063a599a7973b08ac8f9ada7769be1d70a0eccc2192d5700b74561af9b51ccb81689d2a447c55403346ffad42133c3e848e545659284c1d5f629fc3d54031efb503726257aa102b73cc115bd9de804b971c383f08ce2883fdb488fbe6555acf22f11ed2147c4bd9f7c8ae9100ceb0e743c8b320acd00d3bd1d14d50db204f299a35e8d0931eee0646bbdf9e46c4ad5a95748433af2243a5d9a48fba533e5523abdf9fc7aaf6a356769577f155fce70c326ed0049d8bdc18354dc698bbf82e2ee427dcc4dd6d2a7e025027d3e1a1bcfe5287f8f0ec152f4b32dcfb7befbaee9a9ddd186a2651b232b5ec71cc30fe6d1f56cce67872baccbf662a59be06bfe9d1d42c78a98c3fbca14b0c14199c5b72877fb84af66f64ca42bf1601c26b5dbf34da10031b397c5f41e953576c399307495c1e79388ee403f4531cb26ab5ec260d454ee4caf3b49bd879602523d2cadbb241ea93d7f4fe66b55359ef0cef8d5771673fc70cf914b91e5a2d408053b14d1e02e7bee4412d9f9e415f3e00dbc6d8308da474a6e842ce07d2dbee25d3841ae64ec204bd6f3673b2d0f4d821ceac4703a1a6e0e1db91abcaf8aec722999b2beeaa4388a1e200f165c29763d6bddaef6bacf84294c9337fd662d5d05fadaa6952326dc12926b74ba4570f23633dce8834b06164abd082b8181f69414a9986035a231eddc044c62eb7af3504a02f3d0f3a0ee46b017128d11afe6da8ae2a7e19ff9b39d69b340946ac27de11f80f31b00d6da2051eb3df3bf7e8e8f14bef0732780f7bb2be4e2c65963abcb6ca9a07e0c6c4a22c5a55c1e89b1b27799280b5bf9d7402c1c63a7953d403d53a5dc73b9ea390711d4115324b823dd10364de5c7fffb646ad0de0d794d422e443407f5cfa04f5e248360cd832f2ac486b26eb883021700397e1a6f27b07676a53623ece0ce96134d20402cf32443d828191640f713c44e7159e61470db1a63e06453072e6d43e68bc1330354448765d7fd4e602b4193e6e6f7151b7702760789a66b8c0ad07b6827bbced8897a4e04a8ed25dcda331b46f19e69d0be63b12ef8bc0193324aec905788defeca5ba35d73d992f85806c1966e147342ed73391b20681468ccc855316f779b1c4f8dc0a5525196f6d26a24e9bb516bf757860a99d5c635efcca3c0e3a0cf12b0bb62a7c228a40b42bb4040f2a536851a9e708a77ff1612757c2cb95d04ff48b049df190a117c2bebe99826e3d1ab5491c991c6fcbf0d7b6915b5d536f2dc7a9f9db30b4e1b181586b96f649267ce0fc3d6b51da3255692ad40807e7f982248a99e25eb5a223f9563930bc334591567e5dc8d265afd37c3e820b0dba42fa1f65e7738d4a19238c12a2d5ccc3164711ed2606e7e1dd45cec6d9197e26e67eb2d5b4f430713e61a20bdf37cc91e66ecc423c0aec7ba9b795b7b09b28e10459aa15c147dec22b10435cb94a109699085f80ed32296e62657cc778cebf3ba8827149dabefe6c9060842bcfda850fe6697a5ca78ee055da7049558d82ccdac939563d4cf30a8e6a0062c430da2001abace1f66cda89cf8f9bb1362b26859bd02ba3b1f7b9dc47d4825aee5bada600b045026993266da209704f2270ea9da968233d8a78ad5777ed5ee571bde135f368dc9511f7eb3f40929cb8674a28ea585ce9c735cb86dddb8296256d74008c8d2f96ba83f99c808a05d34c24050724cc356c45fb90c24549de7176ed907b476e4e1c5e7a416a18e69ab9d0836a168abc08edca1f0b3d38389eeb7ecf64b46da86b03b83e4378473fcff098a22ee890ad17391068351ad922de125aad702834d73d9ca5e8c1db7a314788f03526e49269063fbf283511682e26253337d2c6b4fde062565d35305b2358480833948d20030b931865b1682db548f54b285f0d0e4a461dd0afc2b0d6bc83f59c1fc0e61306375fcd75788f3174ccf3e0331508cc3062e0258b556f84f4daaa319f4002f0137789ef375d30aa06a66b47965ea306e3d83fc6603ae27c43adb85d62a2638c9d55a358b99be9d475796ead49b832d37a6ae865ac6b5453e0d562e7a04e08b49df0562bac14a95ceaa1d28079e929723b8bc3b3e56b84c95e40289bd46c1816d23ba02808f832a571090049481529b03def556203813f7e9e84b3d189be62890e17f19244b73a261e907700e368d6269505ecc7d89a9fee5946d1d580751ae61888b275830b952a3487e3ab8199b605d3a1f33a8a01671709654e23e061556272fd4cbf3c299b7684cf5d781d71ad1e5e9f5fba71e738c555d5f8c4bf09c5ca3f89c3b8a73a90ba769c701d06a786fc438d9022c07f1065b4ad959f5e6f02b94d48150d56a6edb0dcf1c7dc60819a306277aabcd5680357151383c2c8877d4b032eb9e3577726a313c197fe03c17202c23f736f2efb037b4daab0aebdb3779794b8b5efc69446105e784fc245ef61d10169d67dd3f7010ec77422fe69efb52d218e62718d5a3f416deaee6aff1a309263801369f9d001cbc99c2b4993c75884257c91dc9100cbb0bf76ac0496985fdb6cfed99b214a89abde769acbf96b9c70e997a09e3ba74c3bf0ddec83bda8bf39f9f9776eeca25c47b694ff3326973bf277e71446c3c5792678e78f5d945804469467f5104822b153004912128bdf2315930183be4301b71d08c9e6357c21694668a757dc02c9ec52aa6eff39cbbaa980586311d26fdfecc619850190b01004a4c0808f2b165f3f770225272fb9b53fc4fa5b840d7314b82371cca146faf29673f507823b3688ab874e721190c1eb2955b56d762e40850fe69d3e8d4713db122e1f91285618b6f383fa15e8e9585572e2d1df8ab852d6807f44cd0873ca6a0bc5d01c7c75fb746538ebf0ff2b25752df10e5c3acf1906cac49ede6dfb9d7b48186da1a7ad898eeea275cd6e5497be347bd84998df7fd90f786c43ed3f49f47468030165218408dc75ad44e48baaeb095ea08180c92a645ef28c1804bcb26a46662bc72ae1c825111cc36aacec96dd1065a3808ef4d0921844044115e4a4fd73839fa2c711d78ad6a8fa69e41362a18cfb695855ab18c703e62f00a8e88af82e3412d85fd5e3264df88509ed474c8adff6212e01666df87838751925d625c7c5e4b7bb467aa5c3cd3be46138722cdec28e62f464292398a9005bab3d4eabb6675018068210e079f77103871f2d0cab27e1efaea17d6b21c34b88d69e075aa7a6664212fa93e0d824d568da86c0be1a7a1feadb9ce5394b24747a5012adc052064769803025e899d806468c2963170296949527d361173e58810e5fc5174c11818fd30a9829f9c1b6d9d90af264ac9960fb1f240cc2980a9a83acf4f71626428e3e6ffc2652e53fd5b404320feb978250523fa4651a977bbfbe1cf77cebea4a9fcf27dd46de9459cace8bf5e230b0647cdd6a46632a8d812fdf2e0f81c014a9b40245594143d4f7cb04437d9ee5f8a7ef4f3e53370eeafa4730724047f736b5af5aab41f12faeb5e6eb001012ec400b1e430a05c06379fdab27020b709c1fe04f66b963a9be7b14b929e951c2ca77be2e3c27c206c0befcfaa1b0ecaa267b2c37a1627cbdd3c4c4444b49faf1c1db648b61684902aef3caccb6dec71c6e58621dac24905ffe63cb36c2328732e7e57583bdc3bf1961baf840c7e2548cf6fe2ee2cf02c97be107bebfe73ee60cf5444b2d952c3991104aef6dcdb20fa68846fb4ed5059ce42f744d1e3b101b9075f7358c320a899ae9fc0d2bd1a00ef9072d82be33ee3a8f014458a6c10425be9493fbc0356b4072bb89747ba8ec167325cad08d1943920d1967abef06801fbcf095c8d1052be143932cbfa120b5ee624d6f8d81f767bf08e2e05887b835c734da2adedd0d9c45b794f93206d7543021600cb8d72534ebe9831fa87fc5fd07b676a74160e6078b5a6561adfc477f56dd8522358777c5f2b5027d11dacd8274b76ad4092d31c4caf00107e690bfa25596e646635e35d5e8375743e39ad678c34863de8ad00d8fecc81222a781eeca9c2ce22dd9b64d536444b14c129686db0efab6eb29e907747688e3925fec6ee2b79b3d9b3a8970e18fa65a1d8b0dcdd0e1d500ba5e2fc7c2978b75741ea06e4feb5ca0e19cbffc6803e6e8e415d482057e54c7ac2daa9fd7d0f3f41dcd9e68e5b8f8ddc3cd234bca0257ce3f25734f2245ce0f5d19b9e8fee773783dceb7562284761d613f048cc1d167129956e010d765daa4571e395d8a92ed88a0a6a326bcff9085577abc9f8f3494cccee500b4cbea522429d1fddfb6b8d42c62afe9200a35ccbd54d3b053ed651ab5da4800ce2b709520f9a26f20cade69bdd721db888ca8b973f77e7d4aeff5d70242a6373e2a253be42c9c6531007b900f6fccae16011f297e90605eb33a7e176950221f623602e5eedcdc585e2bae60d2a4a75281d1d28654138f648965c7e139187805ea683bd73cf271fc8858fee78d3b7b804c81a4bdcfa8bba02e00c33ec8f576c78b6cebd787525e989cfd552e05e3ec524982378d37a869cfc82d1087928555af3327d6b64d6e01e4aadc8dfe34cbc49d6b6c5460d273bf3c31760b961bc3aa49463fcdbd4bfb51eb232fe7abcb1fb3767292a8cfc5ce4840b8aa199ace6bcdf1ddad1568d0446a26aa73df22008d8acde359dd9a2e4ec7f7326add4284944676064839a5dd7e6c3714222c9f0184b002c94076c0a9220981d4204d6081130c296666f489c4afb95f1bee386b64584b8aeb7627eb95a69c82a65a465881db3beecee69ac31e19822168a0952b6507509e2873ee6d6cc3b12af2f4a650ce1f0c30144816c7966a3ea2dd22357e5c4e55196115425208676497b983656d5c31ae4b856a0e186a977f68bfc3afbac6e60e109e2805d11e139a877a0d68e46911979c9b6a49fc02567c80cc329d9405b683f574ec7c94b8967e49c6ebb4c951546871f3b91d63c58e671848719d2f566de81d9e9652008bb18c29280bc9bfa906be95af10a9708249ae777a25523bc6c141c6206926a19fa181f1ee6c51fbf68cb18d44ca56bdde3d5d4be2f40d3c3f6153e01678177c88e7729421a1fe5edc4556c161046d123a50050eb41b74ad57524f81201cbfe1a1f30515903acbfa14d4a62aac191f4c4cdbe9ff0e9b31243df6c7e62abc76c4fc020e7312977ae12f2c6f62c35008d9359892062aad88e7ca1488de67e04502f64ba31daff6c4d1c3741ef55f5fc2cc856d1fffe8f2f2bf8929ab9d928dc5f7785703b4339ae8758f496f9d955b65ba8548a3d81623581bada0fc6ab4c42a6eef2bf30c45e102bb4fb523e6e6a46c2d6bafdd8c92d5cfa1a6c15ebc5946c6e215f232ccb6fb84bd605671fdd451c7e074150c42084af456b58bc4c8faf4dffc43de3cff0c02688b106480715d6f53b204416dc96f06a153f2521206e626aee1fa424518a384e687f1fa7468b1775a1a05d313f3f065fd21fbc277e6296784d34d5c4b2ac2af5e2d40ee845ceb57d763a78081fb5f9755265c102e7bbe1f500902b99709a9aecbbf728e9cd348d6ab303637297e74de4ad6ef4733bab5e6d7e948482d64a8c300d5aab9d6151070e316b4e648dde2bf6352373a9cb797c57d66f6c38fe3748b1d35a689cbea8cfb07b5007d4e7a0a4cd43663b02947b0a849dc25f03377603369e24378b0c5b3e422516f44c36b05293bd8b1ad63b28bc7f4ec68a7f70929e29fe2047475a4759e64752e59bab74a95f5e33ea84c2782d1f233c7bd789d992686db30bcc9b8ecb5a04346ddf0c80331f98fd41aeaecc18ee2924c8f9f43c00f4d972c2d5eafd2f4b96545f7f8967db4c99ec1c897f26df25c9f029f87fa95a946a3f9a0f9202b9414ce7e24fdd830258495ee3c1cae2c06b1f76b2da1d322475f39545c1af873d7aef063042836f0b3936a376ed8ba78ba12d343c65d93470d5cf8837d06700b8547ac0a9c664c2d2b142bef860bee871a4f315714eb6a17712473eed63b0bd1bdaa6374151a0ce1468499421f34416be2eee1afe32992fbb66bcbad29aa5dcb19d3877befbaba624f57ec79eb2651682a42b61f03c048bdea9666c239f568171c662c5cb839c2da49452bdd4960fcfba4725b38a1585a6799c481d2466b6d630841c8f60d39730f8e148821feade00e025abba3e895ca8ac373890c1342ae72f4f27ebe134e3650044a558509b2bc868ede427e25e37fcf6559cba60c3112bc3e9f206ff078a2046f080b049d5707c5578ab265e496b109a68371e23325e0953a7f5064c6f3fd53b23d457004a78c2c3fddbd932931cfbb9a08759f56c317333e6daf736a992d39ecff050ea88e4146222a84a0775c0af1a08b157296e3a1478489085d51b0425e3b7d3bc43a2d3d82dc67db09765974f41272d4cbac735fdf0d71b3bf00e2eaa9f3f93778a451119eb2f1e3bad33fccb889d977bedb99f169647fd9262807dc962a43452184203ca89451c837d3eb001119032dc4fbda6707947bb3ab4e96c262502037e259015107f0b311d3e821a5d22b874f7e86d667c3b2ec6769e2a85c069ca4cb9b42592f6f1ec101c9eb5fb525a54544a8a1bb08718dfbee9c86951d4fafb6ae0de783955332467e294f586bfd50550ce689c185c9a69b241f4815ebc05e620d200b980019d4c6da2ba667bcda628820876ebeb2bc3eee438f593360d205bef33410ed61ebd038f7928ac5f3f004f402473a4c43352445cd3c9cf9bc8a56e4ab392c4feb845da22a52e1d2df1be3ec6989f4297653ca8364ce673e7fb6b6eee0a077b674a4847106d05c1404c03712adc2d9117fc97b302dc6fad52d92ace91c53bc0689e9788fd7fe3c2dcfe814daf991f26cd2e26b57c0035bb858e95c7c24f4c089f0dab576f4f4d1c5b703e267b719767139667aee26edc0e6ea5229d0e48720676417c6b784f0d49d7179948b37420f24e573e0816efdfd8540ead525f567cb9b1d4e475aa23698f6a28e152faa620cd4694cfabb399d0f89aed5e1c42aa668961fd9d8039a14e912e8784d95a8779db4d837e34f3eda085082a0f41268215d749a4bc7e6a9fccc4c55b7d19825669bb06b7ae5497564c25e58949d394421c491f78476a25e0b42a981daabe841226d39633943a7445c907c9b4d565ecf3f8825f3a37f222a4177a51e81f566b8330c03319d3344ab80df7aae9225a7db04158f574fdbd645737a5bd5631136f1915792e57a875b605c478b3b066e05007768b757dfad4fb13ac714aa018626013649d8153d9435c65116868eb739740d45880920a49e1da9e2adcc03ce703eb03292940a361dbd06a8d1d0043351eb0f34d488ec04143c81dc5fcdab865d83da827d7d4465c3b67e4e8fd044216124db7510c1c4f0b8695646d0c6e27d85620a7fb0b7befed8cb2f4aef09ff6e8c28103650b442cfe5acb2b020593ec4928654bf6011f54b79c67bb5775647c6f3b7aff47ed2a3064abaa341c8cc4c701d973f32c206c22c6561c906a3ee7b8767232b7336d07e785f898a3a9a8fe57e4cadaf9465ad90dcc8f5f4ebf49b9091a12483e276c39cc3969ebea31b50e27d3f577903591b5442fd74d6235f7a8464ea9440d4547c90644005d6f70fad6d8cbeee28fd273208c862e80f1d1b279b6c12c2a9b7198b6e2cea7972c6b3750164dccece12f4ebc9c00ca6b7ca54f983c73ef9f4e1594daf29945d277b702a4d443537981d6fbc0a9d6c8c91f382b75173ad3bb2731ca1f6dcd740b9f1054c68d043e144c376ca2490a2ffd4b46bf7e13831b42ce1554eefd55fed05206ba0dcf84d116ab4ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
