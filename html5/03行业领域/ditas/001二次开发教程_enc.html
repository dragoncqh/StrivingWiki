<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"224cef0b6b993c2b6d69ff398b2c19b2bae2f1d301e9f3d534abba1a501e7ab3e01198e54980d6b8aaa7acc8e4732fedfec0cb560847e546fe1b8545a5bb3efc84cae8ce5fb327cee0f48cd45bf97f8562c1481ec193b72f98e0db03a99d12d3a407ad8938f363a94871ed5534f912e974af3c92b827cf96e752d42d5b2ca6e1b6a1b5bfa9e2b47e1019998db97edcdf861971f02d7e523960552dbf42ba121cc3bee5587b396fb1fb7907bd030f990b29cc06fb0909407c400bab3092cc1c527ce3d4bbbf82e9f518723a474a5c6264a17cb6926616a658fb9fe9f65fc12b3d4810d8f507e10a5c3a176070a6817fcd0156eeb3ce31fbe0560967559179edbd2437907325e222f84496cf747781c630ca59f8ce876c3caa9b94294fe2e1c03396e89e956cddf967fd72a7d1772d5b02eec13b7d0fdf96bfea0701a6e5b71b1e2694e4153e1ae55e8e28a274c029aa618614e3a02e72976cdb7db95ceebf06b511b370a8ba2b9140b1872ae222474c7b677bee1f4884e7fa3453584febe4e124c3c7da7a411cf13b5bce20b9b1e8075187d7a86d495cd8b511214fae27237de2bf53990d158bfa966e0cd17907fc6a6a1149b616ebfbb46d8e3a019faf81aea31ecace6b81e09ec8183d7b8a83120a0c2240e1dc02d1d84097eac88881e4cb720688e113dd0eea2d32efda2469e79d5f13f78297370d072a27e7a8c8c8959633b535289311335f6035f289d57236e1c77e5e3b38982ceaa6674e8af865840192293659611816bcc79ffdc6871d2eb46deb2acd6f7d1cdbeed248c251a37fb4d09463b77a9bc1427d3221fb7487ebe651fdc6ed1ab429d33b0e0a14528ae99afb336069aa98522c0dab5b98cdcf026007a09712bd3cc279f3c699f5f3cde4020a6910155314dd5f381325cb2be0d41fba162e4af73953cd39aa23da08eb5149898719882c7ab64f68057d18ca0d4102947ce4031cd5feca5ee6fcb129093216ec40996050160ef3632a8614c3f1b6a1569a21f4282f25c16208dd94375dbf0f6afbbe51a172db9bf8071b1e7cac26a503869cf1fb52e5e19a91ec5d4780f7f1a64a38a183f1e664164495aeb07d080a5c086bc1f561955ed0e1c0d686c7a5cf882076c1ad417f6cbffcc54d80da6b9371f72d8eb3dec4744a8b9c10bfa90e7c7a8f8ef0678f3c0cae5838c0df8f6f5e143c99cc8572fff5d416082d3276700eca149a8966e1b0afe6b9cfe9613da90f250ae647c050b5b18da9bb630f22667a8814a8bcf18f3948e29511b7ff8550637c2533eac54a86ddf1338481e6b7df9d597383c91157a45c1fb17d9486b6fb67314191df27cf7e5aef67f783c55a7d557ca955a5d31acdb4037ced1a0dffb42c18e0c2fa429c4a4cca592b6c32af8a2fc665b80f36af1f976a3c5ac4171b6cd61d14e31624da80bae2355ba9c35b6a12470fb92ea10dc7bef37a47fc3efe85e45d8a64f1b16b65b57b25f496bbe6d00ae27f36f1657bc1be61c12e8256346d981716217a065a8da471ffb33b745f69281b7ed080ab5b66da5bc2a829f816aaff68db221b326c7874c3dfb4cbba6ed37d9805daf0f7463b8fc523e3887137bdcf21a4e03e38462e119c1d01be5a1db03e3aab03ad808dc2350206a92b163bbb108ad1173be42943f2fc696b0ae1b374da8fad3c7694685ef49a8bcfd08d9a82e4636d85a83e20b928c0a501e69cd6a18037196036994b6a4a786361cffdc8bc2eeaca22c1e9c81c584f408cfe73a0327642cada8948923574a5e94f63b662171514fe1c782e2f08cd65226f199482d8562e6133645c268f36fbe5a764fe4207d100776e68c79e81209a0a78f8c366258519a93cb786d2f5296dd5f81ee89899e1a3ecfaeacb4edba8547319fc9a44cf9e44f82adf653ecd0238b432cf4478ba9351609e6af12887e3640c4ee38f7135f51a46011aa82c43ac4e68574cc1f5fb30f938b3a59352c7126cc13d2b72f9b764c667a6dd34fc271a5b201d0a384c6020d971e9e6525a20dd9bd3f6c4e6bbe477370ae667f73f89258425fdb6e5520cd180819c8d1827fe6960773af6482a047b595e47a999d4a9061b7a6432010d9b8b4db26d5f277f948890fdb9a33bd5fe8f85bfaec9832ab916c82d53c97ab35372cae429713b78cdc5d261312dcc473cc912a73abf6602207038b3288b74665fa3aa90cc25b0481f00588d53af5558fe9907e26a404ecb65e36c9b213542df89062a6304c6444c2a2938d3607ba03a580b8b90606aa9bb3d3535cfa0c1270cc229ce2d7e51269a6ffe928e986a970abd65ce3377b65bcbba98d8b6877b673678142c1e657879ed6c1a740d3591f7d38677b56076248e61b8553eb5873d48a44fd31cf481760259584aa76f5972d32797dfee9d4af20e070814c2593822de5a46b108a35fe25d3c4b941f28b443fe071c80045179a26a7719621e7e1cd6cd13c3eeb29ea45332b56734f2b8cd5f75fc966dab875bc309a3aecc91659d7bae8707ede5efa5e7b1f23a07d6ff309fb831c9c1f1b8e3f4900bd6763607acbe3cbaf13f31b6d811068056fb7f230cb3a01b62a5742d503daa4e90171e8eee7b44b1ffb8acffd14296cccc9c7df32ae9585bbd0a1d08e6b2fa966fb4618f654020009474c42b6192a319856668ec89a6bdcaa61527598a70b799be0555385cbbded8195a7b2f02adce8cdf79a1df7700d31454fd6131eef90deafbeaa0a565613deafb9485885789442136d5bbd99d6c3b8ed8c06045887eb1e8c440e93923477cf968bfa7da0862390bb1cc22d9b26b093384b5802465d6d51e5280f0163db1d19605d7a0b8728c8fdc512a6dbbcc54ae50d99ecc23650f74cb3554b29be3c29824bc000d80c7c38332793de72db7c1e76ca55251ea715aba4db54b7229d88f3377525d3d4db9fcbe42a3710c842ecfc0d1dc1a6b226dcaecba4f568614b8f50fce54d6bfc8c5186bab5b2796ffc9b289306f525925f49dc50abe926681d38fa8ccc7acac3ebf5fb815eb97ca4a7d5b6c2cbb7ec0a8126c4a65ce52312513decedad022ee973a8dc1572657bc3f7de2e83c7fa639924dc6f9da96a7d568773c646793a61a12ac4623b4775c7aeec285fdac9c310c4a51284544be2311326474c98c332adb99dcc584f32f56e2b4daa5658a8ba6e20455c143c640e983d34ea388bddf55a5550794b391f49a6f3c1a4d2f855297b4d36c8617512c9a2cd4f73779d7c2bb6b1c6e40c2e7b6818c5545ed54a3368a0febd54b7054bc535a3eded992512c927e82e0fabcb1d770aa5b09a9c8a060b47a01e1925d4e00d51e4eccfdbe78060fc1597ee134b417a7af184e4eb30bf0201cecdc9c0870c8e0ed26f8ee47c91c163ef8a849ee71fdde4473fbc511d5ce37ec2808c6386d973339f5135a79e8611feefddb1c434b7fd7fbe215c47c3f994ebbef40c71f601a2cc9daf1dc5c3efdd0aa7edf714de542782b18eff529e28ff72da6894308e619a475b5f446e29e17ce3fbdbfbacffc490e7692c8bf9689133a241bf2ddaee3b857f1ecdfdb89a01bbf6c786d09ef83c961e1b544b57c15e48de04d361af962102b085be2fb27dd24be2cdcba2e342d5301740b14e061a1a8bf2a6011b1426584284b42c793c94b59e0f02a2c53315d12e00423b4f27165dd1d7e5032e8f1793e75859c1843356ea5b548e7b85fa6c71e18cbded90acb30c0ba5b55d12501805c704825d0c1fd309d493027ea9381d61cca1684377f2cbf71df953c023dcde401696ca693ecee74c7f1fdc43db3e54e4057326daf12a8b9e993ba0825800374d701b87b534423a9e689bc8941faf19e80f939763b4fccff01ca5f2e7a5f17811d612a8c2598a3a8921bf46d38353ab3094e9d6118242e396c307339486cb9f035d3d73afd2cd6d065dab6a74b6a7988b869aa2e77b98eec67852c22ded00bcd588a5e921a3bcb6171a1833f2c307caf90549eff0f3cc7cbe6049d4d754a7142693248e50b5f975b1a9b40433eb98767f4afad45e08bbd425083728651bfd0ea5f65579e3390e9d1d639cd7181e1e0736d90d2bf2cc023413eeed02374863220f9f6a97311c818de9daef46a375d971ee05bb2406f8c867c3783aa120ae826192acc6982ce4fbd1bfd7924245e1a6ba155e180f3bdb1a70f7633b344cabde00519aea5b80f37e5baee0be9b879b02d10194a795bde76d1f270a8a99d937ce6e4014e51af5e798ce392239d4d68ea15250851799372866a19491b560fddfe5b7438f2c0f99091355a4b7b4da5136bd0a9140af75b65158ef634ef836a9aa22cefef20bcfd10568af0ea5773ea6aa27e99316d9f5e5013a42dd83867905fe35062d951f599fe394ec54d4647e68d1c9904737d601a39106fcce3ccf00c38d7f935967322779490afbceaefc8892594a13f5cc92f609f5c92938445effd3c301e688b86ec266ea017506f758013196246fce786377fa57055d1eb19efbf288bdbb9e5a7dc326517c52cc87dafd5fa65216f3dc83b7feb4eaa5eb7842980a6fef8f3901e6d1aeee46380d7d7c7262d32e558885d25f900ae9aa49b426d5316508677b80b170a9845d9ede1c0ce25982f6e796f39a73bf904a81ba7dae1986046261f59bd2092ad72294cfa5fb515adc2514498ce7eda720217e5aef583950efab2dd656263959a40432ed4d343d8fc1d24251676e78062d5578c0c06c45cad6bc81c7e06442b1c2d278b5973a63f616b9fd4eb431166f422546f881c37566e092cc312273cb93bcf682d849a948a56ee8e28f997cd56783415c83258b1f18a3e3d5a3c8549b0841be288442d275f2d0d32605c340a03f80dfeb96a8d29cc210ff6758df0a2e2a72c6854dbbf56cba43fa0c8b2d0dbc2f2d70f26aa8ad9c80b9a450b7dc4dd1208037ad8a106eeeca8831388778c80eedf8ed9219d04d79a2cf18cc74af77afcb9dc2bd91558ba26b90b77ba32ebcca13e39a006d7082349057761225a828151ddd1ad90fcc56317d8ef71215e5a5c4d752e1b36c06b24a3f2386d767ba9b8dd3f02bca0641f18ab5c02a9af104e665a675987a849ec1cad2a142d6139679c9042f9d4afed490019a325fa7383a55773ad8ea93f72eb18c6467297b8bfb495885d5a982730e6e0d21ad0b7a0156955f3833308a85cdab54c6a2f1234517c4fdc2b6fad6de84f42953fd181a2ab07acea58f5c3498cae2015610bb918e9f5f4af4d75bf2c7a38ee8f35daadbd0677952711d6dadb46bb8649d8709f3e4acae4188829fd36b9c928ebb7c1d956f25c686f6b7b394d83c446034b9202434b322022459250dcee54e1f082c3e936ad306c5e8e049d22f037adf27e09de14812b635a9cbb3d4e311a54c0b4b93ee340105d598e7abf872f4bd5402204a3f0f8180b878429bb79c6cd47aabf4af5df82f3755cfe78111e32850c78b5819262e138e743d07aaea63ba9e4ad984876f4c3e4d731b9bb55a914f3bfbb0cf5f06eeefa5a84e8530bc583f747b83a729a9c2deb7d51e4f721929535a973d9479592317864c4f1a93810daa8116d916eaad3053eca2c4b00e706e9ce06345613621f8cbd353c627e757550beb630380e253aaf5be136b2b53fff41c5ffadd1d2be657bfd95fdbf3ed47487e9da4a8918fd1a3453330763b9cbbcb66713ca87399bea33ddc2efab200be07134d0d653e16e9ee3d040970da7947b89415e44415f386b44d9911911fea63d16111b8f4ff13123c7a48cd6c6311f0240837b710d9f5662bd1156c5f50a6d637d906e34d0d77dd81ade7565e150c4668ca8ab9dfe0dd54d45433749ba04746ee7acec5d8dce562e5005763275eeb25832f60315deeca8d7d35b903d4d31340bb36c5f482bb8e880ea33980669bfafaa1092cd21437207f418c821f66f3d347384ce1cc1f6b47bbfa8396d77d97a02ba1861fa98a63155ad22982f899a0637eadc4a6ac25978a84f3789e9c26823b96c25c768cec212f23910dcba5aa40ffee14b71c68059aebdbe9181501bdce02f9b558904d4424c5e1d81c721cf4fcc4588e9ea39522f94683c8b7541bad0e76347ab14d6f024f6961f0b4ba1208dd7f19a11edba13ac67e506c9308450349ee2602f29b5d7d3f69cea44e1f1ab8972e027db5330559473283389050c30a13e5569ef605c10113b0981d0b4a29914a2022306c274883ffd39a813fbb9340e322f2ae12943ca3749365b55017ad309ded4c19dfe49a10918f9c22eb19c32e3b29a3a1d765bfcab50d1dfbae72f7f679753b04eeb6da3f6236b082c32cf301b2685801dfdd4f0312d48ecd8d6cd0050a223c1c52e55aa3f5eed7dfaac148dc022298827b5dbf48099f0a0e0a1d3d8804f084ee8c743eedf698133f6a13e406384f464417e342b9824e23afa877a91e031a7916059a1cfbb41ef52b83c0d3d5f08181fa351be172619123ace4e11eab52b5403a649c647a80008bc57cab3335929a9d129541a7362ca969a82b7d969481b01a3eb9530fcd5a4d5f2495309e77b124817dd6312dc8730baa9fe7058a1280ec983894653d02d46c326a5e1d345ecc797a1951dda284fe400362173e01d08a27e7de9380005635e24d97a99039db0ce81597e07a60957b95fd120e88adfcb2a59d9ae2806683a8c6302d4d64dd107c8c2b67839d68ba3f58f8196ca053f2f119f3e3ea74fda96f05692ea7253403063cc4164546255fe1ebd2d23e5c1e856f46265c86fe37e91a17e83af2074a24cf57878e251179f8c720a64416bdcc5ca112d3a90d08e2f34be617c8992028677923555e16a50fbe82b5a79b073a6ada7eee13aac2bf7ad66392a9a0c9961065c6a7cf290da52633dbff2f38ddf8bf711b5aee81fb0429d203967ce4efa1dcd3b835f2d819f5bd70cf0b04aa784601daa01b510c50c19fa8df1c84ec25401372214dde8ab1edf7518262f317e2e08b8eb5c32428d533a4cdcfefc8892fe02029c949e5ee7b6fdee8157ad61059af72c885483beb7cf3e559926e97f485d70d5cfb6e93e4e9cb87b1cf39ee2e3ae6c64f635112d352dbad8e06115039c1724164cf4dd140a60903f34a3fc2c006df2ffb7ea1e2d3048c78db1ef0eb83b70b01e6d15a5e2156563a79f239c104d664fd413d149e937e63b882e832dfa02f7be1f8d5d25b9004b36304288adaaa6021dd04d1476960d50b57f73cce00caa1d01cfed2362af08629cf9e96ba1ee75d1b9a393a51070a255a9fbdd7661310300a0491d130ef53727b21d83ab12db5a75927bbe605edffc1b2784401c277730d13dc440395adba2b15adef0a19699d384f7c62c067f264d3095dacaa674f05eab062b28158644ff8970163e61dcfc0d2a48dffcdfcca029b2011704142cd490b4047915337f73df36b6bc70f0626849d775d269932605e7544cdf1b754ddf39e7d9ce7595775e678b71657bbcc1441b7ae8ea5c74b578b6bb36a40a8a771dad7c7a4be67405f2873c2c307cd912d5da3e52aadab2e57848c102d98ecf2da0cb4c6dbde2303b5ed64e6af2b2e4d07f74d0ed2792a9a7fb8f2baec65c15e8818cd9347e4b06c3691916062f3da12c10d3dc675617ddcc4373ddf7eed53ab726202a80c5b42bb5bd3d938a4f5d977f57207dc2f3a14e96cc00861e612dc64b7f6afcf4dc891e4a54a5f5322e08f4332b5087b94f4431df6ef2c9d41fc416915a0f8f069036e1295ce21bff4de5053e741cdce36f29e578b6d558929c6af2ba2198425c9dbdce99ef3cafafcca7f7e3495699af2cdb43013a03355384baaca195677db99a47bd07077377e8294924dd6507fdeb694138bd9479610d9d53903b4cc1f187252a2317321fee808bf0e7c855eeffe301b3d9eb7c6f5d11e254c71d6942116ba0a59bb9f72c732303ea67906c3b817c4327f09dab267814830f4a63e9af4caab4678a5180a8c1adc4f5ea8dbf8f4063bd0d1881c3a5e64acb8487e2a9cc3a22652615c6fa684cb0daa985d3517ab14d6a688e55b5d889c35aaec7a5f7482e0949321fe6f4f0cd71328817c29dbff0d37742fd1136e43846e21aa359e79fbff60349f704ebf346399da8179db3c75af33a19948bc84505a6e3cd8ca18f777f5ce4883118bc812fe2011b123fd13107ad8b4959aa29d934877a26506e164504990caabcaa4d32e8cd76b2e3384f519ccc8d90b2e361b7023110a85c059eaca62a7e3cf136d98250781d6c030dfc463d7a83ebb061631d1a59e1c3986403ada7ea9e4f00380f61977fd81970218aba5b5a584a40868f533604e36f0b28d30d12150d0ad726070d820ce968f88ed0e5e7edd04afd89b7bc2723eef58004212dad0ae5b6a3d7beb2d6bcc153b048815351905b9088ade2381caa6932bfd75065b1034f098aff1e0da290f50a12a5ae3c32b84971f77692829517d80cfc9ed056ec078b77958213a17e22f7bda6e88a1e24dac23a66cf54114e3eccad53fea2897b198838255eecf09c13f631a08590e9d58afc2ae52bce77c7b9005894a6fa391a9e36661f8d72496a8d80cfbeb1f62f766d3da2e1f0977cfb4b6240b75b333d75dea966b56e6dee6f6c6db55d13edcb395ad001e6620b9e2acb6c0c7f2f133e9878ee9a7afacc178c78e0b97ded9ec41c1aa470827e45f134067d1c4db29d5193b67fbe226eb563698effc0c97060d03165da3b697361b3e608bb9a98721801d3d0aa5bedcf83eb0e3efbae33d55f90713499ad53f457912a187cc236ca511ed7a38a4e8c70648e555c5f955b2a89ef374bca16c64671aa74995b8d27e150b7eec99465a90499f2496454ea2ac8018a39a3741c7155fc7be9262e5206ca769dd8fd5a1f6d0f9906292a073fad90748ad76b1893609347cf0b59bb2822f57899ec91a93bf7b240e23bed4382e94933e81fe0159464ac144d62643c3fb5bc856053df579c53e1891cabc2a50eb5fc150ae5cdd74dd6d833b7b2fb9548c09c25a35a28c2f95b796e7ef38812ce281d751a895025fddfac9fdf7f9d0990e2f065a9f5c1b237dab13b1fa89c05bfeb77d33b7dced22855cb6f3b76694272c837bb48aca448d74e1f2e449a98c72f16f2342b47605aad0f3988bf687444eb96bc07c1171c8bc625085d411b97f0a2883e07ed1d979a20bb6dbe12732a3dac266bab63e975f3bf585c6713bbe48f5bfd7a2eb2e261aac29e15c79b337a2c62923cf8e5bf5c95f10b5682e6b7fb773681e4975c4022dad74181214ec97aae288064b82ccd05122636d4454d123ca1041503e68ae3d21749c758f64c3bf2fa1d8740c5960944657bfcb5b46f478f6113027e20cb86d6ee6facbcf3250c1648cc315efaec38af1fab5eaa9714937e2d30be8cfc501bb865e20f05708789c664f6b26dad88153f2d40ae62b232836f584fe112d546698daeb7347564eb60b5b4e18edd81aaa238a744e8dc66bd2c38316c41a69e9872703d27302be9bd300bf26e1f760a03f5181d44590ffeb4c94bc377545d979d6eda2514f35c67d800172ffb54867a03d6d93a2888e6bcc236bf45b505ca9636cccc86f70707244c439272c2c94f7c634ea58866d3c05429c360aafad20f0ce65bdb0f1bbea34792e0401e54d2fcfcd0e3e77e17c21ec9dcf4489af43dd87e3e7891c3e5a71d89dbf257013e31de4dd05acb099ddf779a6ff55dbdad0240ec32ad52cde438564c4978cf5bbbf4b630115f52c9a5af58c88ea1d6d719104b261dc35475a35e1198dc42c54b4ea7854dfab77dfd77b3039d4aa608fd055a1e010039ceb623c2d5ce12161bb463f7c52416d5d85a24cc9c59bd46362d0c3b4d1fe684bd94c0370836ce65ea0f5b2aa581806b5c2c41a21a1276c109fdab9b68ad26fbf795ff90cdaf8c2eb9a0b74aa40295085cd92dffea5a8a746b97a160d27eb74144355a70c33e75051c495ef77f66b0568debc0184e593008c3e0fbe5dc4b1b330a7c082ab19fb814a0ab6adc9c1514e4665c82a69b50cc251cd9596d18f410427a317404142dfc076c665aa4e07691957950e46e725a668bcb00350fa7c1f7a15d9a35dc509a7a83e8972f8305de70842a531f74099b05fc63d4b58e8d2d6b4dd82614805c518838f0f0b31d6e13e6ab000cbc1c16c758e32361887552aa01c26bd9bc8ba66edf512bc75985d67d4e31966d22c84e075f5d271a2e5cfdcfff7248f4b91be0138221629c5555684280350cadfe5fd715056475b2718dbbc670552a42f74c35d7df22ae63e86aecd9a6c677dd3f4b1167e060393dd7e65a5b3910e93ec51df479e931dcc5f0b0415b6dfc042158fcdb553030d121a8033034f1243e9373558ff46c0a9f53acdc688f6abf32a746c060d67ec047968782edd4d5c443413aea51e5e116c7d9aecf7c711f5bd67c7b1e3e3c37738ebc0ea08fa7a8976f3efa0abae36b24a7d2ea63b579db9333086e3d74130f8d33856d889a72d41b674ed42c9b39e7d32a44dbe3401b9b78006f6ab29c3398c4ce60141a737e50d3d0dbbd0a9b13cf82ab4ad5e400a641e176186b1d2fd3de5fb05eae293e8317e9390d6672ed5c0f7423ecf4b9c487eac43c0c539cf4c6a0250b862e53bb666dfee1150e0061479d30a87ab3a4b4f447009e3a279c0dc5088c9ac13d4257d98ae0f86bcf77ceac7e317ea52a5c820952f948f7113e3e575fe4e47e8df45ab67b7e8d945e41839a2bd2b9057378c0f7c3d0f02c4c11dd8a06dc5efe527f45a0ce8a6c34240f0dcfc500e9b6bd1287883f2710d4c53950944afced3ed1f317ada3b1fe4f4089bb2075e6024e25f86c200c2a51ee990bd9752132cf9da68660284c277ba674a2971ac5afaa16a80d2d021f9581f15bd97a7e8f4e8d6978c3a67aaeb0ee03642264bde3e7c04a9d031f2be332160787b67807cbd20f58c76e576f8c89c0d65317b594977fcacfd97aef2e0f630713d95806b9af075072a0e478d90fb3d15a011ce2261c2688f6c8b6e06530292b30f61d8f4dac5328c18a0f5e63635f923873c82baec239fddcaecacecf50f0708c4cc80092709f60c50087a77bfc8d846200c1c9922e7553ac6e9fd6934f16933acd43009bffb5dbb6f943dfd59a8c2d5a812e343c02f21254feb0f75fd19909163e5d9f4e80b2356da16d89b894787eae7a5abbeae4a9d7cba44a79fc869d935cb51113121e02509e7cd57d1503b495c4198bfdff2a2d157b04cbd3c7cb69b56cadc8d593eed61c3114792b9fd3445ac6b7c53de1b45cfbd460de8e2c50d56a51846bfd0791db982cb47e3236d16cf47cc3a9391f982b6d4c68e790e06b5253533163e153027f448b370f10ca975074d7b07a91982041b2ff04c3a82b220fb8be789b4b5ffbc92a26f531631c1881346e3dd7afc01765ded0ebf13ecbbaff6b2de68cc12974aac1d4209f24a4803194ae496f4586783bd8bf7a8359c8d6521869c8dd08f48edfdcfc7875878bb927de6175b771f4e9895392659086e42c3bd9de00d4b9eb75e746890caf3af6149de16cca80a98720e67bb823bb28f05620a9dad5e4f61ee86fbc80f8d12065c21c472181310446e233ca7fa4a917bbeecc1a5bd7bbab89d03da349da5b7fcf71e980cc2d997eb861f1f3840d76079a5e103b9581b5d1bb14e985c858cfcc8ca39c417d81da585e4ae25002338f5f149978f8525ce1652b50adfec9c8702ace77d0520bce8389b00ae4eb0d58e49facd7afeb7b12595c59f7c057adfdc193c5b42a2d08878c5b82c596a69b2d1c6931f253cdb3a66fa9a368d0ed777619a698cf2e17dac17a61adb47f273287428c9fad23facf1e080ca4992c64374a21f7abf6f6ec6b88ec604750f75900fa91b6f8d34d0823e3c9f5e78246b5d835da8427e65e9d4725622bdfe8cc8cbb69d01d63c306234424f28d4faaa5e1c09307cd05778548d7a1ed5cf9590e2f179b6b6f3b287d1a6be88c416ae943e6bb87833f588c9ab3819792be37f24389ded5904454dcb887895b30a17b574a2ca491a41c4d6714b11c1e845459c7b9c9e8dd6d05aa9b0b32b835215c8cfb31df6a41f37c48763ff8011eda67d7d37451fa8a222f45c2b6a4d98fdc2b7df38d4d186dc5237c51dd2fa37f196a4cdc231a16c356eb2c91d1aa7f8866e048bb57fc19ed117f56c2bc62e2462a0a8f9a95e2d945d06a3ea4641ea1fd4db9282c58e85b94a94ae223c5493622c0bf3084da637a8e9329583bb762bb0c5aa78d350ed707be9dcff3568c7e027d80c8be608bd247aba05f038f6810a36da2641a48293c22b987498735012a71b1de411b75127f03946a45f75b54eddda4ad93f549b8853e1d06d0183d3501d385afa398658f021ddab5f478ce9ddf5bad6095f5200aa899e4f8b7824a208a58b57d7a05e99a81e973955b96410ac28b6369d979dc8dd6a9099824f32a508ee73b4c22738bd00558c9c1b02195fee625c1eb548be509051bb7a51f4a43db841f779e5d121b867931f868e23a2652a21a455186d608a803f91d94bb4eefe1e3d159f462425f4a663f00f1ced1703c4dd8b68cc069232b7d8803e5dc69be711fc58d55f600f30d783159d948c13dd405e17ffb1a461fa5bb1729eceb1cc913032e85ab191cc388835318cfd13be4d34ef6e02e8439c1198d19485b0dacd580d6ee26c6ab45d6f9ad45d697090e6c303e27bea302b290a54b4369b9b37fe64a9bf838b2747c3386d544659825ea2d9e7f8539ac0d34a8b901e3b055687857aea060de938853310cd6fccbce67dbbbbbb9f70cb98117b94b6986335c870dbf15a079e15e0ad94beeefffbe4f509b21e3838dbb4c63942c4b425a4056c9ecf728bfb90b56080fd6c33622664565977d95b267e145d3fe7549ca97921a7fa9667a90616ef700686d73df358d8512c021a02ff114a753331c49d6462a3a048bd8314a672da69ff27ac6b46662b8df6170a755e82329ba8e4dd4f3b7cd34411bb6b733cd4a12643d3d9518927e97623c60693e5ce818b7f885335433ccf64e5586aad78b2b12ea11f0f824d11e3f5e74898913ddb1d85d1060a87f8b39529f634631537221d87e9215f207bd388cad96ec17aeae69f110cbbc378152dc5ddf0b48000a09dc74f97a3585c8b41f072183879f9f485b6b49756b09ca042b8cb9447796a4cdbd255a432558536758b7dcae4d22b8cd7d631053393762d4a1095bf992ccc5e2c3e724bf7b14c8c39a0ba24ccce6917b94e31a09fa7189f779526d4c9057a8678c5c01459d75b44df3076556e2314d9e1891e1160a664d63a63a2dfddeb70b34f21b033915cfc054bb5be6435951a0c557fb55ca46ba1e1ec87bf3062ad715467e6fd60ace7edd22db3306808d7ce9f7efede952628a36d1467c782bef5edefcae917b5d5f8cc986c170e3a77e28a494f1f376637392ecb6c1aaee68a40d81f01988786c8ca0afc8f4e31dc4cdb89ddaa086f4204baff33c69dbe7e752f159faa05a20a56b23bf6f12fe060d63da02368a648aeaff3ee83ab982ea3f905d977890bd41f77158f0b4a6429ced7f66d40bffbf767fcdb9f6f684f6d4b43d9942d9172a93bf5906974fe6784cd87a27767e670672db1cfe7eb1eaf05aaf9d64d0e7c8e1164cbadbdc9662e2df47f60b68a877487a5df1a5d6162c72354837f9657ab8ff338cc319680ceb861d582d748da978fb50849c0515aba2953b8f06208fe8150f2d6336c0fffd403c10d61c30ce071e0f084338b09bf9e8754612a239a901e3fa2d2b32b2cb04f344d461060b7eaeb6f6c7049ad84cab4b6ce8635f53eed8f6ffa8ca641375ef08cab8f4f6ed99908c858619f4c02f340678d705f0d3cb63612e1a883821710880699a849494382900a403bbd0757ec0951c4b6f31d1fd142505c75225659786dc08b498c9a3e6c13fadb9414efe6a7148a7066b79488a500431b5330d788fbc4e078394647cb8246eaa916ab764cce4b1c59f97c6ad31e6699b2e1bbea84a261633af4f1c4990b098ac50e042142ad6e08ae765f4abe57e8628a270e79d505bdca9e544b596aef9044e390a2a0f6956714fe30eddbea8f5c5c24334c3c8339a2108846da7424f75a1c89ae10d28b1b14ab59139ceb79396414502a22158aa51c5ed5df1cd7a57cccd6cb2479f43fb47d9481dbec94e027a1197cf3ee01dd92a45425f43b5c65b4503fb3802bde4a0a0f00c90bfd1a609fb8a8f24b66316fe28bcbbb3593b69dfc6814d4801d4f4e9108cf1fb1e6ef69fa7209c3287460fde8392198f3c69b4d7d73b93853114d390937155ee4c23cf839773feeaee6014264275b8f57367ccab2b9d4d1dc1a8d87a471eb395819010491547b133ea0173e6e5864dab29912e04a38c9662f14e13d554f8f9bce59b15ed4dd37a22d800a5246d3667a3100439749569df5c180e54abdcf7c553cc98afbbaea4e15ab5308aea3d4d93ee3bab2dc074bf0ab5466735a84d7c0148138aff45e447f2d6480cdf3691d5462b271b4d2c2443786a927d2c0250b7fdbf1328939e9e14cccf9ef4fee91cfd81f36e2d2d3605a3f6c759a534cf7e3e80732219b875db328f5187658cec1eeacf0dfb382d8986b4b3dbf5c769641aedabca9ec05fb8739cb7393359650a1125837757f34e060716e68945b8b56fb1e387dba2dcff5bf5e52d4fc0fd8bdd92cead38b548db774bbe1edab2876f54139db6b26f83a532e500eab4fdc461b5af1067337f98325a2a61467ec3e579ff54a7f2c6aa80d6d4adccadf4c64efafd3065f5b0c5ef74e14ff8196eba5cfa15d43bc52498bbf001fc1d114abe39934c28e364dee326b315c0ca8319b7de6957ed41a169a4dba384aa652c795ad18b7e8fac767acd2b91c81991adf0ca726a523f6fcaf291914fbf24781561c7bfed45539896f6b7afab6c2c66b3d186ac73ed4f68b751987d79e4a7f5a2a59c47b42e0ec37bc39d140a90cdd921dae55665819814851f71631e9ff212bff1314ee741977846ec8ee855e6647272aab05e1ad551c2f4fe046028bf627fc76a4cfb4c75ee7a3f052db28a3d30d6960a2897981eb76c4e6f099df790fd36c117028887d72d71c43d77e326ace6561c0568f86ac57f802959f0e8d12f3421fd6dc55d6caa5aa8101bb69486ea3e7ea28923ee73d8cce986330b6568ff3f880deec2398e48bedd36c2a87e18a8097ed0c2c4f7c7db005493c6923a6831f1febd5da7bc98310c06006240c39b9348ae63b25e0e60e1f85e6a6a9f8f688864aed2dbfba405a2519cf1762fd66d4007e8402c201aa297f92e987af1edbf75154a460964b65f92df63a37195e9101c4e06767b14a8b94464027285eb7a9979ea11eac9362bc5f9319e548815fa01272eef9be1e940605ba7bf41274a4d13303498dbee34aa3e19b8e9c4cfc776568d502b82a62a80c4ba922af5cf1bf74e81f78469f190ace958e6a7d3b3936df0e740a709330030299d33f0a1253ee1caa4d82dcca2b708d568fc8eeca1a0dff5cac32d8536ea5df1dbc1b16fbf821123f905f8e648b5309fc8e65b0a5e626554593c1f8e6f8ac81558003dc92de75d5d15079c87edd5df4bf886b8781b2700153cd02391f66c659bd48c43012bde0907d227cab64dcd8ab0d66b94267b33980688d851084ab72637ce106945994c236bd226e47d82ab56eae4cf477e4780b9609d848244e6c0e3c2e1bc6f3c4def647f32842866472e5fc9450f20c7d346a00236134eb62984950169ec4b7b1b8520df43bdd01208a36b224935388981cec7b226085523d7e00cdbc46b0e0f5f70715f762c54bc7137c55f21a2390b96bf3d3d1f18c1de0bae442e02","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
