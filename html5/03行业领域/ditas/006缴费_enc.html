<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d79641a45061e08e3df4d2d40ba0f097cce07fb7f9a777c52e1cfb3a6049cabb6465a099541f7e163055e6cbd5abda68b739658551a484bc439a932c0bf054922d0f3a737e36b3cec4f0ad2441a1d5951702b1d58351cde3899222b187f74284862ed6d05d35e1b18d9302beb48d0370399be171caac5ba1f9c94ec008c248bdf647b062456bdfa54319b01bfa4fc628afd2548065498480a4db0d028dda6fd908e4a055637c375589c4b9e2dda0a56e63556ff06e860ffb8d0f23282f6437104f7d6803d9317cce030271bbc51a1c761de62f29cb9edc3e4824c7ea7f5c656acaa3054e4178f3f66ccc2cc759b42d0ce7609b4589e5438ad2728c22e10eded02096a1fb6652b555a3eaf21b8c713ef755244c81300940ddc2dffaffd206fe1080b0db448aa53c223c20f480ac29d5da370e7ab2fb5d070016c4b26638140ca2a2576765a716df7e0f65cd60617df2792989fd995385a0e180609ea344b3c4347df77ff41a131a5917cdf52f932d225ae11e27f6dd96a487e6cde4c3ea9469c175ecf28ce2362f07e753a2147b49c3e695f3020e27df4faf7c19ef50cdc5ee0275268e9be04e5403ebeed3b833ad37f11d964d0869ae96bb7484e9440cbae4b595b163c895be659fadf84db24c369cacd4f3a77fe2a5c49c32aeb0e3f57b4221dcb13bc2f01ed4eff528528df0b75da0f5ff68718349879f851ef32edd61f23da27e45ba9f3777b3fd1524eea8697dfab0ab8242099711ea09eb8b3f731dd67b51bd7aa2617331f38b92ffeea76413aa38d5d797b4a5854e069db84f3ab3ae012e4b393e6ca4147a74b4b4ff08b7bcebdf44b209e1a84e279ad2a10180cf3f8578d9c353c6101ad95a6eca47c491c064ad2bb0501b1f368e5629945a490ecd3f900f65ff528e6ab82f2594d33139139eabc9aa6106f68068c1063609866e55d1706119035adde9d1f4e90b4b58b7d528fc6324b0132b21316587cecc4e26ea5f571e1bfb8de792f628b701240dbc82a06164074177aadd6a6d8c977418f7d3a1350bcd7f836f6cecf967a3ddd4c5260aececcf6c400fefdbd4e41b347cf2be03745a371e73bb761b4b4f4404b32241069a57b3ac5f01c408dca475ec6e31ebbeec21ecdd1fcfcc157933a36d805bb04672983e3fa1468daceb8b7b1ae019575fba0df264a8a3104b9732df0628e8c3b7a4f9d0ffae0414bf9fc42cc3ac179166c539f34265ca855997ee004a7ff85b9f45ce6d157cc086eae140ca7bcaeb4dda3ed07be12fe58249457802cb440337315f7f0a52fa61587a30e53c0c925b8659c0462b025932720950f46f7a6798beb16fc7a4b3d7d634acfa5e5528182f57b160ff2376387e588f21bd843b6456015a8b6031fb354ec2be70e10fa674b3e32a80da4603b2d7ffbf850d8d928d869165a3abc61b2bd4aa8a698e9eeb2ab116af6f23bd5a03676353757bbfdd94e5a27aa2c228377c73093579115a00297f18e0ed546ca330f8cb257290a893710d01adc0085dbc2b8b1628098b7fccb681ddfacbd993804f61aff9f68140a0bc7301cc2e84cc2a8828d3da8826a5c3c0cdb4ef121fab0f7ba5a245e313ff88c447e24c25bf87a51d3624a816ce77d3aa55d923af1158d5c4bf28e9875ce1a51229f0d0af12b74b3a49f5b5ba71251230d52b43ad12c0510c98500478e0c1b56b0273e2390e617d18ad70e81602e2c7d4470b08d5eb09ea4dee78084ddbd1b3edf7f99f9c9095aff9ce7733fe6cf9b6d04adbae9b65225758fc7beaa88149775ead862221c0009b7ae97a2fc785324852528e86df7c65fe99cc979c0b526236d8c61db4fdb127eaf0d6f92206d16e9f9d61e3b2bc34111123f232bfac6347ce94d5776f3e4bbbf2cc44d2356e32adf332a464ce54013c06c01a9029986d828c4d24292c8f3520a6da75547964c29b44895701839b311eacacca30d1a00865d1c832b41958203f5dde7d9c25dfa3c71c7c0fabf3fd558c92007b17e4fbc38c180787830f55b0b0690d5ee6c0e6303252ff604cf1b9bd11fe72ae73da3dbbc1fb401d4127c47a23f8fa08a4dcdc5bd2fcf64749948e1f010338f53ce15ace305be82925b944f0c0a41b381a7bd35afeb463f9a7ef6926b7809ef541cdf6532f7f9dbcfcf3b6b4876e55cd777a71d1b32de7499932104960b43f5390f6ea2ca94773fac57b27b7434943126b731930b2830d092d6831c7e494c26cfd6917d7f00055c617c966ca5c1310e985fbc59631ad6eda57dab9280040956896600c2cd51fc12e9d0a35ad2e1e11795c9a73eabf5ac93555d235c32542e56bfe38d73b8d2b8d79c0d6ff69e50aef4fd3a0d9505ba5c01c9e81a42a12ee2abd91131a36accbfe8c254edb31a70b77d69a20e22aafac2cfbb689c043aefd6a3c7e523b03e7ec02722f8665b05c06b25bce22e899e0e26300fb937ace82bb3b1cade050d2587d38013d1705945b17f9f2511ca4aa42b36242abd0d9012308b10e6042194b5f6fc4f16bc7a970b91f830cdcb7fbb9beb0f8a095ebb5c4f8155fa277ad7bdf3dc4449aa2a58e9b7961b4605f33dad9eca29f6f0abf6c01b5deaa79becde5c5c23d0691c9a92ee8d218dced888162438b982dfaa129d442e8e2206f024fbc18150d62cb31299e41ec83ee9882a15eb1cfa6ddcaf9e59d6a728dada388c24b1a22ae05d6393c6c6d0ad8f2eb0bfa7fc25eddd3a070da6420af7dfdae446b01718ed466b608a1361c17080fcf00a85d19ea9f1faf60adac1549e079376158db03447aa8c44a1fd9dbe98a6132241ace4f6db23628a646575c25a4ff8f88878852eb9a5176d885b5e249c971533029a873dac29cf9a06a9dfeedb73d96425ad07dc11ef873aa535ca3b56c4af6502778ed4584e920bcea1e82d976f4673aa2929e0519dd33c0d592c34c96ce887111d7f8879a65ffa933e048784d6e27eea8ffac5fe85e2b4e4413207875d80bd7f755f0c717057fa7fab41f787aff8daaf2f1f7e79dc0c9b809cf38169fbd0e464b9d38d37259944e5be07806e5f93f282473092317c65d56d25834c14545567ab97104e83601788cdcbda5adc89d4d40c5ae39604f59945eb6cca9677e41b8a636969ea47043bf0081a117912cf3bd71c0554fff61b0215f41b129a13696d2a924f7f873adf0157d88e8b81d2bf7dcc4be16df28b23df2645fd71c0f5882e4d1d9be54768b004c59b1fd1fe97a022033d971fe8337d107b07c4c246eec85cbba9b81c704f805033f21104ffae482e2b1f3d8a08dccde06a3cb8c8715efc626352e42888eebfdf42c223458080db0998e666bec11ab47a8e3b6e10b0fdf09728fc123d76d7d42e23c4c2430ec9f9d0536766cfbf2ecaccebd7b979b7a74e6743eb7305b911c5c8aa07de2f307e053ca12b28d78ff9e725a8856f11b16ef906905204203e58af90cb859fbd22157d29a8d7b97c28f2ad7c2b5ccd929e1ca1f12f3e1e0711ad371a69942e025f4a5fc7d67c0aa55a158f3bc7cd889765a5d0a1a930478d3736d5de236ff0bdebf477e0e473c2776ab2e3039202aafad7efe37beaa3ae5b824b73510736de6feb97d1c13396c818bd63b243a373f67f50f3747bee0f46ae9b5ec0521c9c364a327c7643a92d88e339e21d8d648736882d75219b817159c4a4effebe9ecbf39354f66ddbccf9ca4d9108e1d212d9b1d739c129c49b28c6fb4bb227905049333ab224f8d9599caccb5a934d4a3db95bc3f5c9d05134c041fd18db9ec0e258b8565334190d8fe74ca9ba1bea41e2fcb9611f4e71d3c81e59c62d80de00465b7aa53c244c0167f9edf2eb504897acc56f1ea50e7f36204944f39e3bae809919c518cb3a83bfb2c4231e0bfb794a1629c26497f40301f784b82860cc445e9a85a73268255bf4950034893e15e293ed007b7152949e3ce889663e50b2a812caab530f377fdfe56cebaec6ead4444259f6989f2f954e3dd4d0a1ce0a8d2bade9f3a71d70f64b4b46e29b8cb73db6e6093871c46166b82962b0b059376a2dbc65af5fc2d3d6fbf8f09451e85b280ee85987f1e07f8bf62c28238c54ed8dfa9c05f80fad039d9ac5cee89cf366322785fd707be0b90fd0dee1cb8e5550bc9cdb399436262283c5d84f5def732fde95ddafc8f086a13aaf03519027834ba283844465aa41dbc65ea273a6b9e8f834d028e4d609c79fab256a90c44eab81d75a376c856bf12d1ed811231a154d9844a8776bf2a45dc60fc9e0e621e38e5ff08e0bdc7fbedb65c1664c4c4a2a29ede9d2b8ccb04cf7402af2eb208940ee4ca9605a9fc674034e364f0afe0fb2ba9c0a6665566db8b5cc7d4400ef22f92ac4babf2dfa73da7763487135542237a70f3d46f34675e8445a16e4b0718def608fcd52f807621a7077ba5547ca60c4dcf4c57de4e90e123c5917954bcc311af916392965b46557c83c5b32054146f987cebaa2d55ce78c2c875a31e95e78d83fdc236d4d6c694720419f6820c0209b888d5e90283fc88486ffb35230634a19c12a2587dc30711bd1b2fa41d9c16db903b51b8f8c09f49baa3c1c2025299d5afe47fde63dccf7262f9dea495d5ed67404b358b992b8429613b6061d9b40b2427dde68ccb67f3a44ed7f6c74b15100ff9549ce0feefc431b9e8e5ba777ba70aa7011bb86748a46f24415f2d802638aeac2e68a6d997ce7c015531a1015230a991a0c1851b6310aa995fdbf2e0d523270c1d5dd26fa3da8b24064f731a4b9243fc2303fed44e42a6e700fecc24fa3cd61f0b3dec2d9f6dd530c8c4c79ba3ac1c9f223e0707e699f8a85e68bf2832a320827d6f1372adf8f1a3455c1de8becb91bcca5a97763b0fa11ffcc1de9724997ac1a37ca10c0361936c69e75ebad957b3c3df6356a9c8384262519a0c0b93bab2ed7319114acb34a004eac251c91c91be64d060953c9c7ae6ebe4edd548b0feb76ac06a1cc38d0ed2664a3fd5590eb34eb3fd8e6fbcaabf564e2514e6ef213f7b2ebb91f0688150158bd2b97f7dcfe15e3a8a460f0cc2d4acc9929abcc5a3e53c10c141cb71dffb04eadf038d8c16966b0022abdfcf03fefbcfc26bac59ef070220df9219d1637d4df2e904f1d40d057677fe99d52791410bd698f751ee8de56825e2fd1aca674fdadb881fcce02000ad9b61f89c9ecb35feee7949c9974d4290dc9728e37700a26a5750eeb665a439fa3a3b8bd7da81083daaea51ff0b5002b43980a5573f7eba3e745f3d335a3813dd60e0192af1c27e046d609594ae2dc549998e13effaff77a4ba89aa60eb717cfc13c766e080bf96a6651bcc703f28f5d84bbd42941b8545becf13650e3233e34a78a9e93823f65aee0e453cf37c0482985afd28981074ba3c689794a0612791647500ddac85720fce11bbffabf1037c769636cbfe9acf8ccdbac495cec70edfdaaa6082eb601bc421cdca40c8dfb3e1ffb9ed49bd939153ca6b280556bfd36c620cb12f0471879a92a1680a99c4d47e22d5046430c1ae4c3ecd74f3b9ebd99e4aa03b7b46d71f72db2a91b43bcc92798c6dc1cdb577b945fc9b44c812d47406079b84eef90f302be9aba599257cfa7a7f3d128030b95b499c56ed683285b2e2e340bded625ff9d94b77d2db806beeecec199dc82c9ead37b61d4f920d6789124595ce285f4f89d7b69828fe3ddf6fc741ea714bd355ca47734352749d9075f6f496ae0ab94868abe8c45441edcfd93191eff95fe26263ac594ae611286a43986e559bf32fb4ac0ddae305ee0b389272ee3f76d3e168a5d69a0e9a4b7e6058f728c48a3bdc4bc770f9ebc350f730735bcf7328eb7fb3696ea70a13dc288a71fdbb4915a14016c79661f7f5711c50948039381452efb424b01149c19614c329239a3af86ee2ee36641910d2cdf4c6f2946b4d09dc4337810af817c7c3a59754219b88b1f839ee44275946e42204abad48f080d8b8fe0d662852825d8fddf39c19d02ded5dba2e9ab3b49184750b2d798beea958bcae063fe4828534ccac554c385593515a183f86c1807554eb90e613ed13fa84b5090e4b750287efd0ed1876291f664c61d5a1e11acc7af2aaaeca14286bccb5ff8b38dc4cad6e4258a425beb1710f68eec3cbc06e2de1f59616dd397de62689510533f1a26f03cd7c9463df3d2e13ce4b5372af87bc475df3b6b9142841e4b961640989c3e1b5c3d6356b73ea355ac6e512a9680349a76eb8e8d97527820e9b57cf302ac804e8d2f5b33fa6d2218b0e5dc2675b67ec42ec60902ab805980ddf33ee9811c058550cfe2d773f0ca2a88be0d0718d4871dad46790a999f73d97116ccd9456664c530f188dd59e59fcd1f6ac04c90deb202d24e5c7e69cf8f27904c855a18688d712d30fe813535460e908bf0d7c75df707fe63e395116eab87621173675321c37eac3c2a403cfb28b930c94120e319a1b9aca039e4dc3f43d765abafbd9f2951f9f1b6d397b84b6335771597f067987926f378adfccf3e3697c6950fede5a545f86ea32c3c43b1efc8fcb2d23031e361aebcac46acb25a38520f158bbc2fb24109595e1cde62d48a26bdba0773511cb8858b3662592da402533d186523060adaa0309605d2d5d3b1274b8665a1d43c853373e1abd95074e7cf362fd5a78baf43424eb6b61d4b9e447a334dc1f3a8a2aaee5368759c23b3fc7700fc4e8871017af5e1bf78a738e6a6bba84ba4af1f7c7818f32b92aff360965861ba1bfe584dcae6b9ba1359d6770d50c4d6f3c39e8324926446cd784c1748e0ead1dc9b202211da612ece97e4423882d7850a19487a110673508c6382370904c4a24020a6b6cbff5314ccd43e04b9ea94d9f8a8e32f0a52aa03708ecb2f69019018a77a8770525fbc288940da04de8953c9ecb12a155e2b7493ebd9b8bf1f92192dd8d690674430eb07629c990745f322fcac106aeb4cbff2aca162a3f0fec154d1379f055feebd85ec979a0c7156cc8278b071660da87dd0e6acd0be25de3b2209d306ac09eaf36cdd340f2c8df317e674cc9e022202","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
