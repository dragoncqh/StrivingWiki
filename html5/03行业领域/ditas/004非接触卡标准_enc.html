<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bbed1231d4460d1669c2b7f2ff24e2e67c5fbe9ac5410f1179ecd2d6503a38295e41032ac4bef3b2cabadf72a3bb32d2d5ba61959eb6ae4a11a19c55cb83db7d09abc77bc31061b6389b17bcfd6d0c7190d23292ebc609913a16af42de31c7a05ee3d2adeb1ca502a3df882eb8c53880d8969b5cf3850a4ff6fa436fb4a41aa9df68d2d8a23c877a4440a95def53887ca7b8934d94c40102e83dc30472f36d410c0622ba936aa6928841b165b7ccce9ffa1f0b8de36b84fd8caeda05c6a7cba9973033d3be9d6b7e91fcab23ab6591d3f417e5c1ae77f2e13378518321a77ff21a5fd8cab3e0683920c1376be5f43f90c4a0defc5ba7a4b7159fd3018c0fac7f7891222af415efb7ab69824cc08090e24de456d7bd0389b5ddca87258bc29d763e7cb2ea153805c8e4b1eba2d8b61930ab81745820fface970906d3d1e56fea8c6950361fcf993a29dc7012617eb69d23971de6ffa4668e1c40ed6bbe32e36d134a1e70713cd508b7b6fbce3ec0fbdbc4749acc395ccbb5716dca5a041def354d90355245e14f947f04ac429c5e42d3b6ce1f480ed1cecc732a05cb158a2bf507418d02b4da52fe7435a2b2ee731696de4d69067fefd2ce94d489118e1a2259a19e979f435815fde622ef06cc3e3d53005ded6d3a37436a1146e7ca55227a87713d211b390bd5223e3cfc3afa72715020d709680fc3ac1e1c8721bed2520a337acb9112d36d9708636fef645327932d7d03b340eddc0347efd2d1bb37729f145d62f3132cfe4d3b306769da7b8632a1e18a60b936e5d6fb07877b7220aa095763a86006c8d36c12b8e9b2bd216fe3233117a82a68aef37aa652a8bfec38dda873e97c2243efe1308fd2a54a376536b194f5203df73dded5135f38c87e51fe1ad6898248bfd50919b0747afa3da843e80454376612a6acd86a675b175aebaee00be074915514d0544b86c6656408128c829e6248b9cd30df3568521dc986f8fd0f07f1d264704123aaab06dd61e03f0f9ed9ad1a77c7d1bf804a22e98fe4a8dc8237aea94ef512f58ed9b17e9ff40568e24713e172197668113e22fcf730d0c446ee0f23e9d8c44c92f089d06a629cdc5bf15aa0a7715c2a8d25fed6c5e7bef243d45c96fda025ec1ed0db3ca9799161350d9bdb78c462fa5c579b9a3a7b1dc4aaeeac65643f70b505ee475860aa79838e1040f9b9524460f30b5f35ba62e87f16067215ec4f2d3a7a7913c33948506475402d0276efafafb77d84ff5c2f6f5c326e759dd7774f2d9952852f96caa95f5c051ea87ab32887913118a21b7675da08dff5d075ab713195a23f9231a83e918e7cb4a642149a2e4b0b40e73aa0ce45030306e5ca6d068ca34fcd6cc80453dcba8f644d754711b6a189203d1ff4fd20076296846f02354d0e09e18107baf6c0d7100fadd92d8ee18d738883ad96a3d95216674bebc2a35008880b604f1f241b04bd0bf4f12075642abd0f7fdfd38e0f9e45516aabcc2e4e689b90997825cd0c7c4afd5100497f1b63492ad69d0a67a4cffac36ad18620b6245df4083e3727566b9a213cca282450e483f47699fb4fce6613b3935ac32032c69b98a2410abc485873db521282920b62ddda1c4e266f4aa508046f0956454136be9fed80cab7af49728083ddefbf39a2a0c9a8d9cddf29f59f12f560886bbcfbd778bfe23c5cd652ac8c67726a902004fc87056ae2e30971fb283b0a7be556ec20f3b2195837bdc7ee7644626b9f6cfcfd4af4b65306207610f79bd3cff47847b41d54e7403e90c7cec4dbfbbb8c3fd9ca90c552ff8448eee89b1b604d1c10c8cf150f26c3014dcffadaed450c3e04e9df7daac75b8faf304da1f59d3907d083218faf89f3a2cec08898899d57c21442c555aa38977c597f21e47319c29514ac669d70bc7ad7113b10a9c537df02da3b434d166d0da1266efdc04eb14de6f4eb1e226f0a26ae99ef86d57a8bbc1d5ba1545667d56dd03f39b4b51fd30f342dc7457104d8b1a25eb9920511bcd9e0422b914dac8aaa352cfbda752ff758aeb05c64aef727f43c71c038d9935f16b725c01b301d85fd19efbf81ecf611a47fdad25f7b64a74b9d108c399da5ce2bcb45b2babfa2a566b2301bef8f9c98faeea74ce55797ea0cd4d3b1b019e5ec3e80dfa811e45d14542648acba52d3232a6740bf7ea0039e2f33cb82c1e73c6c0743fe6320ccd60f4b069c0c8176b8121d1bd0968934cb228b4b4ed307825890dda182a436d491dcc9d5a07e0499a132045762b3f27b9565e2309fbc524a21c27451b3828cd431702b14cd8770f1b35f7d94bbccc9e07ee89ba9dcd4288e6745d548934bf820040da5bb1f2064fb3e64d1b68dff86b55897cc88e016381fbb684716086e773381f0a9fe50c5f431efccb891492ddc91641027582f50d6de9c0d6d0d7a56ffa2ccadc8023b0ee05fd9c9ba26b971eda2dd9c8505d33f9bcbcc7772b62e5b195cf98278d8eedee4a5bc6e34f19ad1dd857dd55302ede93ff4477af0d23933d1f050dd560c6046c2a963d79c56075690e3739314add32d23114c0b2331a837bb0c0f56de967c7a965c915b0520253e3cb85e027128ad1e9209bcc502632d8681a216836785eb3446f2344609a243949628448f7d79b186e1da37e7c76a3452b2269efa745d9e6ff90c181c769f6dcabf786d8bd089089f589f51ecf6f061bc10cb40d0fef096bc496a37a9298595be8d02a6ab4877f5bcb94aaf34e9b95995c92f0acef58480d0ab668174f6deafbe8d1ef95ebd273ec8c93d1753b1c7d3e7c3cdbb527648cf232b97138351c5509137052a1ed96fd3f7a762de297c599b35423cb4e7b4d20df04853832305e258fba8f9f8fb31f3587714cfae5b9c7981eaf6946ac6fb9678ce64555bce7e1868b318ac649e2ca2cf88e108f3e738a4519c51e10f9e60739baff6a3a5b21d1d98e195254e0a3a6e05e5d123d116df8c7344974e4e05178ee184f8262d7ab0030b9212967f5683258019297f8d6a0641fc8f60d0875c2d81c58d5193540e5c0e69eb4c07821d119b51bd944f0b1a424c632509c9ae271215d6c9f97f8776fc2f3698d9b5900ad2e9bebe352e61e00422de781a61f75e18b2265da21bb492938eaf8a185cdb67bee68e04b0d6ea0c8446e5f508325d332ee5a38b29bd36c97c43edbc4afd3a1c32cc112f9da5f9eb096785eb69e8ec7e3669225aaffb8f3b2b186f5ab7e6d6b03ff515dd35474cdf98b403b967e322bae3efd61c1b1f50df79db8051cd7a9fa7e46c159013362b4e3583c79971eb7a419c41c57caed45200a57cda8f2752d84c20d6a2ac931c24c9fb43eb12f7678aaadc65572846f35d6691b58da3979f3cc1333b00a14727246e7256d2b3ff28dc6790b577645fdd498708b3d35a3c9b8584b25dcc85c8ece6d9d418e2e81261b7b4649b0f143c52f2811f6e8f909d10f72c11eca2faeb8d813aea147a587f493f804376abd7e4ec5b4787005bf328bd3fb17aef9d62e6df44078b4f103f08f885664b2fffb9e794252371aa403fc26a1f5d09855117c76b37ed8abeff21f6ed34457942b9a2c0a2e7db24f04058379f893f97a028cf4e625397aaaeb82fa6a1bf2fc0be972ff90b01f3d7b2309d71c157fc57c6866272651410e6510f8b97c0a64eab4834adf2f89f64710e5e431c399e1a4ee7443c005c4bd5f70195fae6692f82c8a2871fa3e46514a630001299b2bc010eab9e75f15a078fdfcc7a6f9f8cb959c64e9462f3addc026c4657bc694183fb608983a34918c1ee38f9cee19eac6f508539440de5344f78ec616c3b9b55cd47f5a7a51700458e4bd80201d9bb735986c69412d4c6100ac9ac38d11b03b9d7125b4bf61f850441dc40087587475be537f13dac9d958e90dd5888828f163d5ce518636f6a5b662b62b7adcf5e6e6794fba0c79108bda0f62cd9b052db1739493f181767171925c6540296b6e7f3fe8118a0b41c14f74cd9d0645507ab2afd09f1c24103cc1f9d3bab321b1e8f6bada5d94db093abccf9eab4acb9f1d0473bf5de42d0e53f118335ada5f66e4053a23dcc50d0791cab41c6e87053fef7cb9c7c0134f0fc3452533aeadb5c78551e3c5c07a82b3454e6308a720b7ce1b936bbc98d109bd8abf7dc31d685fe76d85c24007661f5a807c743f18f1dbb2d05fcfbb615b3fbd6c5979c69498bf39443ba45541b4d6986fb9c5aad9599ec72b355058581882b7ff2be85bf45517351081729c728f6b2207e5af2fffb865cb2f91f44dccefe1240d2b76ac727450d3e336df9e6e22749fd6fd924ef70d3eed410472aae0dc302e0bf46d4febec37127c741b625e5c43578ea5c48649aa559b17682b14bbab14dabcac5936da33a0476269c24b68d893927580071b1d45d262e5fb98fd59b0eb6b5033f3979f04ab2d82e5180cf8f1727376741e29b618c788b3aba51d9acb7cde6ad0fce7f8209a76f543dd061956b80d53eed33097a85848cf6dae77fe3d3376399f53e1bdebdb6066ee2618fb4c23589a922345ee75abba8b6f95efca726ecc2eb44021373183925198845e8a1a179a3d783ee06f20b5bc1292151ed845b145bb4ca587ef2a3155c72f325668d19d7711421e35cf88633b19dde269a57b4b77c47253ea2f7ccd35db289e2c1d8d501c0aba95a2af8bc1dd0a6a0f4a85e06cf561e8ae252042414d24735ac5351566dfa6ecb2e00b0f148565160d51e1ffc80822c257ad9606ff8a6037046c3a6fbd11b85668f64b97dc324511ad540c50033d2f0ff3db2b6024144c277d42ad7fc20b3b880836a79e30c2dc49017efcd61199fbe07afa1fb90729376775072ad7dd73d71650a855a3d25b5ee85fdfcb9b827e73e7552020f2da5fa7b6481e047ffc0273eef63c51ca9fccf1588a2633addf414894d7ebac2f98bb3b827ecfea59863b9bceb33b31fdbd60b30dbc2a530ba9cf252d041696c628e51140b2ebcd93096b88ced190a83ab1ac6428612f45d23a692774b0d365c837404ef5b658d9867bbeec2dd37c0ac94cd5d62c7e15fece897e8fd71d02713e0b74d5d1afb36ba8ab193d766bc649a88abff24074b2202c335496464056ffa0f490ba0789c8e1050a2723dcfead58364f89abf986d8ad2ee3e9963c162a2c5cf636005efe6ff17be38f52829d2a7055efdff04474c10c0fc3e051c443b75c41a47634f391166792b5f98f8523459c115e6a709c40053f4511008a3d09ed24515c931a239973e252702ea27c688b2779b5eba805226086a3ee0f76052785e5f7c1d7a6309e3de52a4df6c3ce3e0b66c5cf185e087edd19a2ff00db49d8d13dcb1948a12954566563f5eba91330c2804206ef7ee5d8119e934b92e36a4be6668abe8770d1c5db7a5e105b1bf22cba799b377002e519f2aa3daf41140ca7956d5d7255251e060a66ee947cefa64c59333ebbaab7bbc705315c4f7b98e0d3ff1ba989c2719dcd5696624c7ebd1f0785dac18c5763d724d68faeb11076daa0abb399baeec4b2257dc53015ade0cac59d6a6f0178e2007074c5e69bbf93435de2c17ce88b916f3da803a1358b0cad5f1d23fdc931babe8b073c7542ecbcd9f1e81883d12421b7905cd5d558b9717eb18e83f339f3ef81282b2be544844187eefb3202a238823684840b7ba38141bc15fb5c1f99352a8e68833eadfcf2b87c1e6835186fa977dba3feeae0dd3d33f3aff423b9df1adab0a7910c0616b2e9239a9a7eb43d5c970a13316fe7aa02589f9754e0217e9f5cb07905eb2e09b0f50903e730ae2e82adccdb986997fa9ffd3236e937f88e72499e918bb076604ffe89db1f73d93f7a56b9ff48acb9822a607d29f1b7adab01990bc47337b1a010eea3bf402e50b55bd09bb53cf8fc851c016d1cad5ffafb5c167598465601f2045658584f3daa762dbb1b8d62f3765bf925c6871989c0f06994781d5ad32f44c5588301194b67985c48d38c6f4be043fd38849c8a543fd3c003aa61f9c1162ed6fed0abb87133e23d720bd1ba3673b94b368666ee948bc2b674a6821a10449b0022216b4cd149a33a74485bb06d62ea1540a44d3453a56b477d1ee1d928745e0601ec2a011793d1f726cbbdf764aee525aec807f24fa96db301bbc0cb3fa5883ac1f8b336efb5b235aed6ab35cdebf5f3283b161f09d4a0fe01b9db2694fc1ab4b7a6a81eb0bbf98d7f3fb797d6ec597a07e91d4ce24086e2989ccd9e88bd8d881621d6a0a2097e43123183fcc062b50c4ea04fa1fddb9415c117d7cb4d0be2bb14edb8d8550da972150dcb38bd5dfba8650e1278a2b2816b5ebe76ee2f6ef28c096d2c27e2297fec8313669d7e00fe3f4a404b3ec17fef345302e8cd58754d942c81ff354fae79f6a91ec08f75a8cbc666b1592453d54b7161399d711eca85ab8a52599adef5a7fd389fd2cef968aa2a8961be000b873ea17632942c120691f3a9a398b2a657c65e26982cb6eb3ba05e9f24f2472b5d7201149f9649f5a248fed001776a3b130cc8df109df24760b77b4ed3bc6e8e1df4f38b15fafc20451ccdd7cf9a78acc115337533ff439dd5b7c55632f12e3bbb3dcfe0f991fbae8f44df7229da2791e32a1b8baaed2c2fadea2eb1469105b718221c5f0523c506b119da34ef637c4c0f6db47ad83495fa9ebb6db1c899fa29693754ae90a747fe657cca3ca1b5679cd3ef0a206a3088edd739fe7033f74e755803d7a416379786d90ccc6cc145634a74089a56697b45c8d32dbacd39371ba243bcd5b050810cea714375b5d4b48b0798b954b73eadfbcd5875565bce03f14b069e06529555a4388d4c02a6c50b56cfc97593152bd845c34ae700bc91f98d4b0ab6ce169818a00bd7dfae21a5d35aec02d8e4495ba96eb02ff6a044abf688864e3a7df02a1780eaee3d06a889435639fccf813954c740a97d0a5352aae8eed1198333395342aab812f83f85516711d9b107453ff617b2f4553ee7b7173fdee357d7bd8698cf995376c393f2aa2ea8b1f30dfca2b71156cd10103b0c62ad8918707067b4c36312a4dd0946566b40ec5c405ae4ae61db986ab12a319303e9d4fe7771f558bf27d8e6a183f4bac16119402510df473485af20e1cc781d7d134c0abf669c12e6c76e958f869cb3956c87bdf661b519b611e48a21ad9e24027e6c0d3d794522e75c5d52e83509aa81ee2378b2f9edfb75612734af447728f41f23b0fc9ff4ba7eab68c04f7ebb40839ba0bc71e971714c0e6e97daf04c0dd4ea4704199679c564242313a94ef65f7ac9892bbe37657859f749607244942110547b8921f375b916336a6647c7e198ea5ad680c95e163a53cbd022a9ccad8212f41f3d3712c3abe96f10c58812e53d3a17864156e3eb1a6f9587fc61806c6441e7f2fa1dede88d0a3a6844c83fd4fbbe128974dd3e26800bbc9297b4627b330c201ea667526001d13b4d1291ae12736a5e5126f81117ddf471002973b38cf0fadb4ac6952437f0db8065d96b978c0c32ea6d746a00b9c1fd7d607cf45a1087341c2f365d9a86c182950066c9d63e85cff4f9667cf67da93c194661dedc93a747abdc53abbee8ece8f254a5c2e96a183c6ec652b6199354d632fb82e6f8d525bfabf7b0d215f8773e6755668c5989a2afe1261ede09347769125402b8143531f31117c318054e9f051989287860b13e2a2fdde5e3cc5b6c496dadf210fc85107183cfd2321b8f48292ad698eb0960f980ec677d90ee209c46034425634f66c675afb246533d2c356ce8f044520a77012d1aba03fdca61406c0e5a47fe903a20e12117278d38e0038ac97bf875e228f1f83289ba759db696540151d5bcde0a6c01ceda178d5c6e1d863abb028ee37d621f5a672c538e42dc52e794d5d1a493c08a69da9deba9bf93a2b75b83aeb7f79a73a80a3504fc19def3544dc938c2c3fdbc36f8191a3712141fe3ae857df9fc33c32a8de878150bb02dbe60b14bfc8712a977d2d853c384acbfe2840a0133e0f9d5899f5a8eeae47d1ef3ab9428ebfe98f21e3b7f0cbbf02344d4b3c84eb1ad12732ba9614506c552664d996d1bb6175f986930f079b5e2d786bf035c3f7a4f303da5a6dfedb2bac520b77d72d1db8ba64132492b737aa598c9e2efa17e2c95503bb8c1a8300086cf373a723e9a290ec2615ef09b64951d4a1ca48a81112c50d020904354f143e01e5599fd7b9ac377911220a56ac27e319517370fd097a74335cf051e4e1f1942ec40a64a4d08549805e9af9c9a8d41deddc879eb0bd4f42b9971a4630a06a97a673df3d2034f46e5b73f6d5688094eed48aa8780ba107550672858dbb71237adf212f55c2a97d575b30c5dd14dbfd953c1e3cb25b7de82e1231278b6e3d6c78ae1433fd7ed8737b057b78ec46fd6fcec8fbd3e93036337c7cac6aca6a372b70691882784ea80830a6f351021424d151d455c8936609e0cc31619c7ca05ea85579d4f57ab9ce8fa41576e31ee33ad6f53408e843ed188e1381c7d65637adde024b9644e63e24e8d48c865c47d2ed82f2570798506bbbc3b3cc195c7f3eb003f1a7c20d00c232b9fa56c643cdea7174aa4506b4588b063b26eeb56625b85513b6b918daf221129b3a26c4bcad7b958ecbbaa3f2e85cf9fc2ea5b0df590f6a5d2678e58f818310cc6a53ff0e16ed89c100c7d9d39fffc97f3a15441176ee85040fed77e04747f9ffb13835d7acea979682a4a2a22793ab3f4af1fdd396c630eff59e58eb97fb5d27be84040cf073ae92109440f78afe3d9b4427df3a3f32a84d4349b423308cf4e8d8d958623f392a82e42710f29e8d5f43e0cba91ccedc0d38cc093ac698c201597bde190cdc8debf501a7e83939da35aef768ff8c1d97d45710a836ebaedef21a6c58fd4a2bb163db0a5a91fc8e240690b1b8d324c85d8c2490eb45bda70e8fef15639d7cb72bb051f90cc448f73c40e71e0c65ce88a0f0873dd043b4836113bdecfbef55f11913b530c78d028708391304ed4fa15829f5b7ef0cafede3d3c3a42cc4dc9d80c0db995a62e88e82ce0d7172407e93922f84a9e4976a08d7f9e4839fec32c4d59b0bf7467010ca74170a2e2fdabfa29d014616b7ba3419fb915bd1eff01860cd547bee11fe95d798797a888027707c2cdd8eade84efb5a8d8de7a5c567a6cf69b2b6e064e0194fab9e7a9b5b77d6a9d659604837f0b3d8bf2b86967af94df7e7ce0f04f732f45126e1c967a1675f5565cb603980b4d8b8b73cd5444e2b6cfa27d0fe5dd28b2a4d14930fd39660cb318707cce7b2045247de3aebdad2c59367066bd6baf73f60a91ed0767d6e5b3166b997418dab8628908938baf9382621314087f278d02eb1c4525f32473e430feac7bc7ee498ed30b9754f3b2ac44369c776b333803d5b571ab4eb70cdbb198fe135461d775420b76a4ed9f535ac8599f10f16ee743f8e27d4d09799f29d2243d31c56e85c1ddfc75cc30e3c3c257edc3c4662effe3349161797c840b2e87217d1986680238a32d68af401aebf73b8e1185510ca558e222a1827c0417b9511a0e78a7bfe31950d1b600aaa7402b0fd287b75e62189d10d0f59f967ebe463655fedb291beb81f4091aa64a5efd3bfe913597495f8ede6f6046f36a115607b95cd0bb4550efd9e28aea34b8ae29dfcd173485ee5fb8f532c0379135e81845867a2cffbb5cc12ebf5b8d2919fdad07d7439cfe7b22dd67b1e01833a734b1fba015d5bebda3cab3d3767a45da52f83b790e60143147d78124b48685a9ec52a6df76b6f0443ed9ffc8b8d764e45dfea9f1c9b0d80309628abbb894525a989b789cf86fc9e3391de28c50735f5444be0076549ef0ac146b94aa42dd47c8bc8601b53e309848c1010cbc3622b591218bc1363d949c759abddd03a6e3e8d7c0dbc73eef4c5fb4724c63fc440a3cff01c42d179fef05c5ac09e62786ef15698e0b2e5483f5bc057f82074cd95f2b49627f4261d40fe087be3734de5b1eaf3a9fbe42787e9547cc75bbd1563e0f066d4da746157076efb59a7e31d75fe6e608374de30e66431722a49f31b2b77447f077577255e5c271242e989ce794550a0ba3565f0e1594d2a0b39d1b804106ef0e150e666ffa5584cb31dd28bb55f01447e787d74dfb169a10d04bc58149dd11abd4265e2c29bc2f3c10c8fc1b56e3f8b887bb85b7c7d4f3499275de9416618d456ec2ca7e20f936e10cff88a0b898cfa96c7b5bdc86807782554cf3e63f7a75e6c7a72ac957318baceffcb5559b45b13fc89aae0c8df583b07ec624fb0ba9e1be916e148c501abea131fc0ee1dd652c9b33d078a61502f77ad334f214e7539aca92a907e92eed9bd33ef3ea7dfc7b3ee06c449ed68bf89afdf1eb4a8fe303c9106d5db0a2537ce6062c221d5a66336dacbf3e0b66bc1b996af7da77d7b5a9ba2c2b9c8a1d48c0b05d4d9372edb6f2386f025b048277caa8e32cf751adf4ad8c505104173a88c5f31dca99d106d781c2f6407bc1b5a403230f737572b427e29cdf3c944a2f4dc824bdad8d9610b40a0a631e73a0323e5223f07905c0bb63de60317a51d791f00fc16ed35d4c071e393516026dc927a8ba645dc1ab4e74101ac00dfc857cf344958db48326ae34adca9f9b6c18b3c2a5e21305aa58020f7300550e8cd6d1b0ab23cb404705aadcd379a79d6f625080c8692a5122d6b62fa708bf5994a0a341a4e75f51b71d4bbb61043cb6179da85c704191c46a88e240d5ab2afbd0df48902d8d3c5c17e32438454582f226316fe838574d1440499d6478de1fc2ddde2cb888ca6153eff9df0a42eace6ac66a06afb445ec85573b6f1f432469029c6f94ab4ee4ed9a9ceaf6c937d14e121973063df9dea0877887f12d5221c4384a81aa96409c176c3e58c0c1af098266b4e400dfcdb1ec530b4845c6e67c2db8e9ff9cf35f2d5fa216219b142dd699b33a3cd11bcba734077d1a1b7ab46fb8414932cc1ef8d8cf25ccbe5f33918a579c26983055c991298ced8beadf32dfd937ad940e11963fcb440af609289474e0ae9ad99674fe2b7671301a3383882244cdf1a6cdec4329ff113cd51c4b4632fdcabea61bb3456953cf4f149413870dee9344eef8a13e3d4d67da430c6a6c225c535d9316a8fe3714102cdf1c1d4cd0c0a43acc9259f341e1e11b3f30f0ebe26c2faffd5c2618f317dafbd908c16c8080f35c41d0e286658b6eb447e65bbe901856734f9c09962e8de046e50d18e908db6238089a2d6afed38dc037398f157c9e9ccae7017d5180f9dc584544bde85a4cfb6d0fdc3605eee26bf05e22e2d6be2ac8b0a34234c666d8d8d6d72a4eedded46f99816128d536f567be1ca372eceb83d5acb05b4c0d4684be37dffc18ed6925e5a218b339b880e40d8848d45e207f0a471e1d8ad67c0e08eb89a3893f9b0ad510d915077443efec8034cffd36d6dca76f46adf275c4a3289954e3dabec42c3fdc0ed96bf453bdcf8a0a03abf8f02152a8f633775619ef48c7642ebe28bdfe2e0df4d0266ad6faa52a005f06393fe1e7fb29f014eb46f1e5752bfdd693694f551b4ab4c4f70665fbff229240e3026a4d9121fe102cd6a6be2e4dd5257980a271f8dcd84de3bf275f949d0a738040c50b86f30e5bd79958aa23334ac05fc1fa6d00b4fcf22467049afaa92656b54a5c34d8436f0ae3267d6c91d2af5c0653f5c7988734d4c933d8d46c404b676a289a1cd979af5707c34f624905232611fb23983bfccc0afe249c4619ab088d8fe190e2b20515db88d51d55350beb2f4e8c36d0fe6f2d7abc58e0210fdce8b3f238c55ae8f38f6ca418208d5bf9526aea07d1e613ed08d2e71f50e4c676af44b05a44b0121d5e03b196ab0f7c372b8a6c48b72dd3393b7f8ae67cacaf943e520c37e737b8e97ffa224cf331c3b3e0123b0980f502525660dddced5a3700d05f6539e54b389ad4afd58955d225edff2293997d2e5bae3494200cb59cc50c4f0ecb76338e2c9cf8432c9b65bd71bf731fb56a011941f70c63ca7db017440bf1bfe23cde8b834b506e2202925c51ce88f7cf3540f8ce84df5e066dd2e957b2a4c8260af63cf269e43389ebc3ece93b5deff886f0e9f142aa6ac4ced7f29c32f1f80d3bf1930fd02e9b76a18a8d39af57f18d63bba2064a23b8ac17d92f1c72be5cda5933de76f6c4d0dfab034fc6c8caab03f91be94797dc4845e19fe84293b0698f4c528a2a9c28007b30d571105f9eee2d602113588da7ec96ec91ba76672ae27f162f38ac4ec00d0c78a9ac9f1c263c641356b2db76e5796930eb4e0f8c98555171d7eafd2891023e9363624e225d65c4d95c189ae7c5115ae823dccfd5915dd1db1277a35232498472ba53b3c360e77486b437939f9e9019e40e581e89203384ec48daf4774dd32fd278727e8f569ed75ced8f587f0949a1230a310ca60e97483a2428affa81e723e314c3e9ada38243c4bf69ffcbb90766095e4b3e6a6fc99cdb346fe08b17573d6ce69cd8bb6f003b520cccde0e988a91358967fca303e67f778b355323083cdfe5c6e6161573bd9c80997509366a7c36d0093bb4066b7e30925fcaaefeba0052edb1d6f1862939548732d46ed90289908b55f068069cd6ff83a48585f89963794144e76a8e648092f1115a5122ca142aa1d71a2d9b79e40e0abc0ee54fe03d2d954dbe9ce8e4504e69180ee14f65819154c1b25b6f69f30aad880bb2d8f71461a1405520cf0245d49446779c018e1bb11ea9fad9b3b8da93bf619066cb584af102e32619f916d47ef561f1f54a3755f40e0152f4b6da031c872a359a49ac1e2e543926537698be5f7ed8706a3562c4a1a2487167f01fc9640b33f86d9aa89c469a1b3554e6d7de39f9e15030ef3369f8226a276794f15ce65668bd2639a86e7a17aa4e5b42d04cf09c5656c156c45c0b50f4ac5de0edcab1fcf5eb88fe4ca0eb66ae68b13fa9d82328a4aac2d781bcbb4163158f95baf062ea46d47bcb81992c6cf05207f79214e2cfa8d9a8df2b15443a2c9ef39c60007883cb3e958ae3e3a3b8ac96d7d44e804680b5fabb70604b623d83c23b5629c33fae4fbdbfef42de99f24ad30547959274c2b49191d8b1f2752c76fad92f1bfb6a6ce3dfad2c32ab6a131a5eb6da0e920ac56110adc9d84e470b5819e688b3fc109fbef8352e3e3a53238fc8f5a94b51a5d0c15c00c97526a7d9c4ab68b71c1cd3f079652d153b81b9409a4599610998953d27e868b399aff0cb9b3525a999d87d004d031b3e386410e9ba6971f9e7f110617a5f67e7737470d9e56a5c9a0ec3099178c39b1445ffba771d6d8e519624de5abf2d10846354f170d6c78fecc983fdebb5e409adc8854247e0348faaf21628075a7ea9980c519ad97c827483349d5cfdaa60ef8bdb201dab910817c417d77a54018f463f567639c4c2945c55566080be28412eca2df98537d390b8b181dc8cdd8defe5c7827271ef02abfc834aa5be8ce5b91ac602e7e5ef14e223da6ebaf34a1b5430d111534992a25fcd071796d52fd9dd25eb1b3a52762b2547cbdba2205d2a984f5ee79545738357a3aea3fada168e2c002974ac6ed68ae80651783d8a5a0d6111a44478856f9f736c4c23f148259f86db539335c6072333f0aeb5e391e11e2d74b25f978758a02791fe3cd82301e1d12b5982a9d0d2127e6f5d452c52e38fcc78ab44c5014d70fb926ba3de9980332f35a852e042afa6d3c74920519c5da75ec799017fef13a65f593e61762d58c61e9860e3485834cd305d72dc5104ee91715d3f28c63ce3e869030ccefd02bd9ad70b23f4ff0cf05e42f6b452b18b60f788ab5b70ea4d19d03a14f857f859d248c620aefc6ae87bdc187a2583ab58950e5736a95b73dca0ade4b35836df542814dd7879ed296954342d8a6ce2a643a4010c0a6a27f3c850ace791f82aa67a6dbce176c57c3e0bb1d08b6335cb635aac1111b00ac59ab206d4526c3bca13801314c6da9ada81b2cc6766c3e796d63ccfad3e24f074cd5ea16c36fb001d7488ff2d5a51a565fe3e5152cf3acd552b5212a5d1b22f7958a3922d4e52844489de775f6a758c704aac07813cda90a320f9645ce24c7254a7c6547c269b5e3edc3fee6a152cd15b07eaf5861b4a49ce2571db479b604391aa0f2ed134494a7efded581d2b753e416b304559cab4d047d20f93f25c0cc6cfe2b008f59795aa8464e18c2ca9868ba1f44afcae07ce53d3c7271798a604a5cde160f96af47a03d8191356fb5122092392b63a1e57293deb447187432294530b1a9f200fa253bfaa8ff66d15dd93759f058354e323625273f622be2bd0e42f966fb4e8365f6e732f74fc32db25d91d15c14074c5012722752ae4fda89a75ab0364dab9fc92f7e89a45707c11addd818d22c95f911037a18ab8064c2474b32d627397b8773080998e1a23643b48255b5c2a6684b3a565d3fea7925a05f045611010908c2111b1d15c76ca01a6ead973a9515b040343af93f284b2f18a9b79c2457c896d0e41afcc8c208bde257773adbb05b52478b9fc45a7096c288ee31b277e85c433e2a64b4c71d5cb5a021c18c8a58f2e03ba67bc6c4fcf65ae4f047f9b4d76267383fbc4eb8b3b0f1fdc584ed897ae55058268eb832dd57c1d788243725a9721bd99581821b27f099dbd0ebd6005c78acd89de1a42a8e9f5641271530cd5d93929df1558f9e30a62794b17340e32cd71eea277ccd8c3ceff670e0916fcc16f372b2cdb848c7425b1652a300753d4a787e60852900db7342a7d797689e239c8afc9097e0f01a06c5a0138937395d21d0aa16a29f5d0251e96a6868cb5d348cf4d9cba21c22e3116899f8c8a84fe7cb0eeb3e744557cc5225cf93240394666a112de68d7230165e5c89fe22a14859cb682f30976d381f71935de9be39c1b572c3cf8ce0e13dca1c3456536f49dd67502100d53f5de546a783794400e183912788c8dc4ff93d918433aae5c77eb1224239eaa6b5806f1e7cfc3a6f788ffeae2452b8380de493f67aed30aee456b76d554babc5c959a333cfc2d9a81db6af1df14673cc03f20e321ac9c4e7274c537e095c4074441e8db6063f5eb91069977b6c64d9b4cd45f44aea5c9acc6853acfe3e44ad5a29810fb9e36c01c7f531f2db1f1299046ef2ce451b374dc4edf243352a30e74b61db4c80391dd7f52e5446a4e6ed2b02348422e7790f8aab8d10ed9d9c078877a3ede8d3b97ad82948ee25494cfd378f6426dc28a8cae7ca136dee660e4ac23e3ae0c15e37a03043c737914ae4f3d09acd40668fa30804baf6817412027f25f757183a47372a56e8a3687b7ff6fa0fb939c6d9bd144e68c055546a4b7470b9b8f98d1faec1b6ea1d1e70ab3c9ff063f371f2134a981494eb6c4dc8d2af00e75645c8a2ae0e9b818893963f1155a7ddde74aaa9793e7f89a1412101b003b861897bbd8d67ce3299b0c1fa2b752b60bbbe1c48e9001dcd541e71b8aa18d04b9f0b662f2705930fcb8a714222dad3aed070baf135a40f386b4702b3503f042be2216db19cfa5d0873a70294ae2b757638908350660c43faa4c53811877db6ad2712b1d6ae9533230c2d56872bf5ca9f2373b135c2cc1b8b897641faeec0a1d9a14bc4983838e400c620b1e6f63ecffd9fb63ef76ce62eb15bfda094024be2f3ba96706b0ff4542c943942945f8801faf4189cfc4b467ebaef020670f57f0769477e5c254c4d607acf4ac7eb51c425d5e51c1127acf13443ca861a664b8c765e599a65d587339b8163248a02d3d44c1797846a2b27a932efd84a00ea421a5166b255fa2cd650a201eb14501159f1126394d6e03c6bf70f3b0547d048e73dc7cdf7924499ad2a2c865dce1da029272b1d2090a64f4c4a1aaf1f6b1b2b8a2a2d9a8b2dcd6ed8ff1b399a890beff336cbfcf64cdc4035a10cf0ab7953191badf1f20d1d5b30344b61c2c9b8a1f428982dc24281824edcae4a0ea0f071db75311f9190d5f11e2ad2080642f89df466cffbf805c59922e7737735cee4c9a503f8d350c30ed620309885b2373ecc4ba4590d8a41f1f78a54e060087e29d31d4a357c8698600aeff1d8b92b028b45b0912d690174f6f543d85cf8795655f9c24426762e1a5f15056eb1e832c0847d29205bbcdff1709a3fcb04e2ce7b67ea7f5558d93f25d4a0a10a436f9ca9ec4deceb386892be6dc50c0b9afaef14dc6181692ffac937769002fed34fe25b9487d67fb64baac3f12f52267505e106ec7b4de3ccb5580bff3b36c3be586df613c9c99068bd5029824832704b09dd7f6d9a606c151015dfaf09314e79d5aed141fa3fc48385fcb215c3938d6101af972a977594828de368bbddaf1da12dd2ca799a16e69a073e5f436a0533f268ad4abd7ed76d9a360880369056484f8db16d30cb41ec27e54c2e8684a8ecab8fbe4128937a2337ebf00cebf4f29bcf764c927fc617ee394876673115037c8f8f51d59f878cf37e3b1a9fdf134c92f6c6680941427d299df8a4b8f917eb0b0aa485c4e6ba8756670b7c2d91b5f043d4fc1b9175d6b93e35a1e6979fa90f312f8a0dcd8e065f2cf509d3f3d2cf8f9a3ccc46ea98656b2ab9d8202a4095a36948ecebecdde4f9ece4df01e57cc980dee28dbe4a29049d5da701714eafb742ad0992a78edf2106e02b36a9808f68656f1e19a78d9d76cd202b63def6da9295edee83882346c6048b0d79adf1fcbf4b623cf237896b845b68aec961f10cd59f80015ae7a6dc4b565b169b6a9156d2c289525fea9fc896fc56f446d6cd77d3e71c96585e7da77ffab98b566df29a9fe2ccb13a2734585cbd8257d5d6a11b5a667b9e4ac5fefb8ed5eed5141611d9aca25c93c034fff59c29bf56799e55f9b61b94fa7f7e3f9ae284db5d5c2801cf3c3249792271bec37e8f9a80598cfad87588c04eddc7469ab2d5e4d1b5a02600bd24dd871e316e26e13f483e82e57ce888951d31e75dd71b1e361fd06a2b3340125b0930199be3791dc590bbc32e907677a5a4224426411de421bbe699fee947c44ceffa79e24d45e39b09ad2d77242626d73e7cef38c1d597de969ae467683bbe4d5e6ecae9d139b499ac1a86bfa749b498413554ebd8f2533af113c5e3ff1d523c31d287d3dd036bba95d9d88c595a2b41912c5d3949917e2e029c70c9d999bf64454bb911c023f5a8fffee691e5bbc9523f3de87c1fba35d154bd88cea1fbade5f4b11774671d566ec8770c340582c1ecd53cc26fb2f8028475014182328eebf7b73eeccdccb2e39b4c26cc0cd39ce7a540900b9cece0089e33fec588d29ff91ebe138993720c8cf79050b15925ee4e59bff50ac5d44251d461df44601291b759ebf9f25fd4a42b2332166974e0e812bbc9dea9f61cc2d1e4c14ff6a7726ca7e41bfe3a2998a1cbc7407a6a13ab2eceb22e8af9aee7f55a0a6a441df0edc0076b63a02d386bec5102cf0d2437cfd5bd9832bf1fab25cd738dc1392b5b07694071c40e894fcbe8aa30352c0dc9837271a66cc8095fb8fce4e966e84702597c7ca822f68720b014e5cdb91515a03d01b25f251b240867c5460e76f8efbf6bae2b93a30f0c5eae34071a57541f477ef0aa5d989b03b551b93c4b2762374d98e084dd2805a1de4a2eadeac51458f00c1b91e488094ec9facdda8a093acbaa9b2d922bce20799577801443f7e4ffab6a4e18b207110a3317e87046bf08acab1706b3ee5859ae2cca3a8b55a9956a4269692919bad92c96435f45fe26f6c8ef0201e2993fa28385065f5a69b8883384fa1389a841d3b119f0ec02828b8a95d75062b5376dd3ef68e74e29d39cebba1c8b1716ce71bffefa6dc46dfc86dc26aeb38","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
