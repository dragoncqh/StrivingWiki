<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a2a09369d032fa8663d84cef6ba69d6e92f11a153dcd8ce09cd85cce5583599c1d3dca7b04d2be1514b244b49157a6ee1ccc770ef0cd7989a801147933e64ca69fadaed1d7bd24b0051181df2f566dde21afc93814553edf33d56af607b14ab7faa825dfd29dcd76f751edc28d3ba6677a3b1206f17e75c49617335d4fb06c53bb95cb42fd41759db84b6acba57f854a07729aaed17a7274ee1fafafb96fae71794254ab8696312dc85858c3e9818db908212b38539a4e0762f6db05123e9c099778a33a518c05fb698922d3127a52ac43f52f944405937f6da89041cd56c233108edd67b8334533adbb817f6b4f35f197248a81b0c5976fac63081708e91a2548ec71ff21e1f208cd77c7e3fed421712d51a8ff388a7489182ba464461e25604601c2d12821b8dcf643c6c572fce70176923ed38c12ae71a3c46787acec2ee4b4f5ed082bfb1aa04cc59cec22421ed3e3e64bd1a6c2af5cca2ab17852016a27541dd0b7b4e8a44218766702148e6c1cbca10d5b2d2a6fadf2b37edbdd8e4a72cf32a628fa017e5aff93847dc22d64b18e85aac46be4aa4ce4c23500c61fb3d34ef75538548585683d11ad15993eb347e49807e6f858cbb8422c68d1d0cd95b0de87eba6d3803f35ef9f2e7889b4d28c2f7d7bb8a1bf5411d5dc5819d02dc696712cde305b4f3739df37c85065f33aecf0e9e0d49cc4a75f21834187f808fe23d7c3aec4f1d819b8d31259f8b2d79176da86dac10bdb32127a8fa05328b63bd77f57c08e2917a530b5885fb82e1040a0cc68fa3527dd066a55c854dd394f8b6615ec6ad5c6bba4668a8cc06ce9674b5c1c65ed8b7e014fcd7e4342997d80e60055d8c6b556d4d6a2be1ff0f9d7fa036dd76fe2277d9d36dbfd1d61537fd84dacbd4d92625273e6ebf13efb43a258ea2ff5f7bdd15b6bf33547e04055c34e46dafb97cf2c03ec90e72f4dedbeaa06183a2917d47a45800a87088396c04b13d165dfa29bdb0f630e2dc3bf60993d60dc1a272e6633401115ac2e9eff7d2c369d5993e60dba54d7c04da789ed77b78ebce2a210291b8aafdcd88ca060bd820cf1ca5c092d29a142b1fccc9dc02882421f7811a409e969a00a4b20d75e1263da4f939fb05df12d98889b57beb5bd5ede051690be5fd03c602613de9172911a7eac696a2c4fcecd9108aebce89bf1e78a83f239671976a6be8bab65397604fb8dc341d68a2c795493ffa1b6d514f19eca302e3b3b92d74d23f8d2db3caa881f5076963f4d97e04bdc52924f41b0de10095098ab6708ae2a86a8d7df343511d7b932ba446ac3b1c214a08d2c55daac7375f6dea371dc53fff6eaed7f8b329e6f4e2697ffa5038c8bfbbb5013269efe11b6e9a31a3076af042093edff2c9345bff8014b879f8ea18b0da1231e0a1e7c16faf09156afc25cc379369c7a073c189266b8b8d742e8927db61e1982c32768431a40e12db17b815d85d3a63379f2b4b06983af1529161e2787d312a285fe67294ba10c12dfe5a00259a77576a58ffc7e96e72531553a816edae9a207a53ea38620430df8aa5ff13c158f1993061678988b9b9515ab5a321121db1c6586a9c8665dc0580d59edf294183ce3ae6fac56902d029ee7a53ecb8b220b374f6ab95835c4c9b05c7291b32d5d292107241083a385f7864e618f7404c8a09fc89a8481128adcca9f62cc2497faae479842a660906ae411e82907b3e3188ef8782bf91a116c27ee52ca504ac0d4b5e30911c80b5e15ec9e882ca32531598f7f74c3241e44967682d4f77d07547a1b427f5455e03709e42f587da46126cd45a658a7035e305414dc5d8d0c7c3e0c6c2f938c7176519ea9b77d0773916c3ef39f3bceac57ffd0fb1c27b9253a1b27379652a034ee34dc6160b518c1ccd4120803f821457922e1d43dbcc9d3222557d159d305d09117e873667cc8adcfa08b0e209f3fda63a9feab25c8887ca600bd662455530cb5d8e5386bd98ce11761e86c01c9e6084fc737f67b8e29f190958e9b77dad516b9174d6b75f4e7b9c27ae99fdfe85569c7406e55ab0ad878e2bc2db944384da604b8db42c3bed1f202dd4f1019f0d29aeb37d1bf7121837752468d79a08ca375b96709b32e715a2068d284b63c449f801a5e334844069ed1dc9d552a394fb251cc4792645d43ac48dd940e10e24a951e2674da2d993c1b02261ffbabe691d7ea43ba5aac0fe014f060291e5e91e65de8f51027e44312d2258b165777646ae5d010e26bce5a418efc983ce62a4f710c1bbeddfa9a6696a51e3a9c1e5d9ff5ea07451901c4bea8ab3b7d770a485057208812e5bf51ab1609a2707c61485832060f1e95e4b1f8981c67fe68552887baca6dc560856b5e1d1d70916bb21b91d498ea83bbd64c69e055a0b1165c08856a1af4765cd52f9c7cfe1574334f87fa7b819dc4d1008b70a8cfd9c657940832effc0f288a4505698672101ff4adc6970c1fed9d3f03d6d8052a46f766bdbe795f7bf3d3e95df5e9c09074f8fcb28acc6441da31a9be35ce0a36e64d881bac2939ad3644eec81e97dde6102a42dd34cfd0ab928efa63d8ded7a92d63da0e33db51259be070d0b065627d3a0dbfdd709747f65c6685444ffb143f1f0a0007c6ddd8612df590599d11d28709c634c7ce6d24516b6b235906643f1bc7814d0a6ee05508f46172ae0a515d82dbd836b8ff8faa7c8f61327bee13775b7461718331d569334c289f50f940e57fb46a34ad79ebc60da821398fddc6e86d7187a129e5f8c399068748735cd86dac7ee09cce5af60cd3e64aa69457bf37a27107cbe51da4df6ca00de3a80eccfee4ede0e1c0bd4e01ae8a981bb89efc8330376f7bff28394d56aeed78334efd4cccdd843c84b1d94977e16e8d8461b0d40824d6ed3467905b1ae89e06f01997a5e06865ac89a734321649ead0f6860d434ebe315d352e9721edfa944ce3df119dda3d2e45a7ddcce4d45a5c724ada5f58e47f00764e2c0d6f2a7beefe6d6de701a88fedb4c2f297832aea4d0ebfb4b8d04db4b0bde87ab0eb45d584147c35fedcab5f0f91229d84008844df2c7160eabe877d7227a4e4297c1eff27d723e478f2345b0bbf6090fc4fd5fe60109aed4bd8151d9267066c4849ea76d9a9528c4ea65e409e0727ad30533056d7d20f8b74b96882bcc9ddc3b17c8c9517a26c46d3f974a1f461eeb5e1300ab832bcef6d641e03f9e33c9b1ccbafdf44d8095c0f689aa74204889d6ac41088b70c49d81cd8c15f7c5f331098d44e9b5dfcf801acd14851c64cc5d52102f7560b4af35a0ab6b55e94ad18df912dc738b0baa5e0dd3c9f8ea893023bc027b64936ffc7789cd5bed125eaf84c5be536710ce90e771272bb848cc2a20ec3a62cd4f15b5f0f4561c2c5f89855dc04170b4dff922bc7b7412536c343d354997f72e7c69a910f3c931252b576a0f1e6de44055213a4479326d955a0951016c5dcfdb58fd71d3728d246b3283813b0bd2c1af2c545cc01774f0c6d87fd72de73c3a377d53725e732de4edfb5f245c89758bc1e1ba1cfa363f5a889511502a3b6b85611a5061a24726f484df39196b13d21cde5a2e1b26d7f9b218b8e282b51b347fcb813675d86784ec1dd100ade11451274f94cddc266c7a91516d34527bb6a532d686f4d2aec0535b4f09015c24bb7507aeadea2f0be9120c17e946d7cb3cb38fa91fc46d5de37936d651be8c185af664de584b4e0b580ccdbd225bf5fad8133f6ef0a00e9430ec21860edaa71080b91f575dea7862199868121fd539fe3cdd270bec11d8990ae3bc304af59552e69ee044eb3361253af328372c2aff29025995b5ae4a3eaecdc970b5f5f0c62b28b9226f1a271f782bf920ad505058330f635cbaaf0178fcf43911bd9108a74bafb7c41a105a7c190d7aa4137df0809f5e50fddca023c531714c91d9e37aa1ec3d6c44a4e5875f81c38a727074a00c896ef1364ad9c065e471c188168b01519ba997d44368c03d1d3dba51a91a37b1421acbfe2118b7c8c30ed4cf64d32ca197e6960f5f8e688df9bc0ceb53824615720abcd764eb7835c25e8890dc72a84513912794033a3594dbb959a5998d1cdb555e701f1985c9fe8434651c1002b7fbaa9d63d6ded95e176bb552165f9b98b31abd44b56fe16425ab1b55110bd417ec5621731101f7137abb9163f605567dab1b950ed6c1482e70b5ae8e67f3444bf0912c9f464a71abe0978b118659220974b4118cec3e6b1a248c984924e41207767928e9cccc8ed07a5fed7dc0daaa7873da3cd7faf5ab3abc8f41ac143e0b5c2fd48c6ff6a7193ba4c3ee1c702a02a9180888f88acbc8734054d30e1e6054a46c2998ce27e7575c6d816ae13666f36487085ce25829333eaaf9c89228748170a5425989337c42ecc99a1da8bd28f6274d6544b69512df8ee9c7790a1358c9ef0f0dcd9913298d64f8aa07988d3a1c5b82dd8ae6d2dcfe8c319644ab1b3dc6cd90c5ef5094e0c461011ca75184bd8024c8e0e6d7a894b7b7cde5d9a80aecf73a3aaa65b7eaa5badbaf53cf21bfe5198b2c04b04a55eef6355fb19bd7456c753af68d73af34d091ada6c00971cd67b4905e334e4e22b261fd11a443dcc76f535a0b5f58fb6954583b0bd280a97d13646b021e5ab310cfd6c277d728202f70355a453e7dbb38475d4ef40c42c48a129e6e36644383e590f83d123aea7ad7af75f97b0ab6627b39a6ecd18d01b5b7a8ec5267b4dff09812e8aa4eaf59673857d87b95fb4b460bb4c675631ab83fd3d9f0626505e7f9b0dd1aafcbe3b77d3389818826e04bb654d73afbee90a488820e408f0b7582e7848ad53f324a2ac7f19aef4ca62bf56c6493efad42bcb86198e3fba4593bef285920f0bda25a00a32e3372852799d4bbf1e00b6f798f39d086d732e9f13a1b89776fb71ba00c222a2ea21fd7fae09102493c60eed985c9fcca6aa079a2e8418290d7658313a8b6989c1f43e033d201acc021cf7ebd8df8a2d7a03a2b46a11b92737ca39773ba6094a31b06c29046730bc5f0e38adb03c8b60e4f90aed32e385d2572ca876b4d8562db2d41a7c0c5a4dfc1697675e2c02aeb2b3c41ab3b20632bf63f8de3aa985f6c55badd73cb6304b25cb0943ccdbe9f2e7a264c3c84c81f06f66157eff662f4a73e2a6b36eed280178a65a0b6585ce1a3ee3a963289d9d318fc220d3ba5813ca3f5155a2a3f06100c2b9000916481baafdcb01ea8e55279ab747f5a198836fc1eb59a0f4e1286cdd2889976a500a455bf66853718fb93c3ff9c537fd81da111d3ff5523e0ca85dd76a7a47b5d0e8ff16e5edc5010af8b651a838a421ef22ac39840e71ededf193111109ca49defc68ee40cd18670665f890a0cb1d2bc8a9c20e32924d486cb5b433f649d4bebfd3862f5c5763bc80e219583a4a4302fc1cbbcb055a13bd27348580f5956999ac3ad483bcdad1c8e0a37e6d23e78bb7b9c078df12b605b07d68fbe1d8d267024681e0ffb5300b04ea17d849e8576245b6579eb2336df27ec3fee6bdae4b63ecf00dd25a412ca18a0d70466c57e2f7c7c7d4406a0cc4c86c0cc97669dee4ab813319d22b8bba62994c44570aef98a206eb0436afd6239be56417628770f5228e0ced359188c187636e98cf5e530a39c434e12f3e79e72287a28509357a37abfab3e7ef37c27aae34465ed125bc07e323be03266c494a2f7a3d202e4d84f3b9837af010cffac878e9d0eb3deb0b3330a73d98c12cdc96412a989fe6940725cb4b3005f7ee5ab0e4ab78ae2c1bdbeaa530631bb2485376b1cb1772e6a30f7cc942b8528fda5410b71ab83526635fe53d717639b77ac5c4768656baf7a4d8c156538dc00e4883c942c4faf4361d67e7880d01d54a1e790de1ab739abe6887eccf79c83f7a225f4cf75d9904d091d236fafa4c6951cb6a74aa74b2b838e4985d6ff64f123a4d78d0809226041064e80e70b80fbed71a6d77a3cd73c700f4638afe0d347286477d25353d52548741db4d7c89f116acb8a026b688fb903506e53ff2aa6568d741ebdcad43e1ab7f9cb7520076d7a0d5efca974474a446cb2cd85890a368a05aea545d7dcf183529635207b83405bf1cb647e92f24f64442ac5ee10ec50e80dad0c7c22b98223f9610fe72114a909cd6e087d8a4e7707b17c3f3c95df204d41eb51dd7171f96c77b9df5f7d2955f17edec58b14ba216edb376285b880111667c8386cbfeb1903459c1528aead9e424ed3be9d57d0c2f0c9227de20e388bad880588f596b434d73c3bab9c42dfe07929a7dfe6d170f8d46595341ee033fae34be9d08925e104e7bd72fe277aa541a929d7f96f07805c0df363afd59cfbe77de1c88c2ba897c983fb29562cc4b44759488447e2198a1535fe6d0f921189b94e0884358fcf702609d3e3e29c708988f997558b7a02ef25b4abf08c8e4b045501f8396da31ee2928b64afc155716e94c0134a6eb18c8ca0d036239b26a355c2b5d867228d21a7cfdfd4cc48fdc55a14257d4aa2094c04d8e12b35a13ff63fa9fc8adb8c20b0db46de051d1b7e3dfc5fbb06c332dd4901ed7cee40f36a548103d4ef00165475808ea88205631a808e699fa29c1138b188b7e9dd97673cd796b289c75b8fb7c096b9b49b70186ea02048217317440a66e77a6cdd4ec376c8e5c1b7f64d9687a5ae1d3fe178c395e659fc68c535a4bb004897d419ba4a652e84ad283e713dd886c2c8edd845dccc8c5336dbabd186b50deca728101c2c8ea5d28671ea9678f9ba5f0c07b216f37e24c95485fde12f2fdfee50dbda70baf161acc4920e64da43bfabf9bb5e18b882748e705d666fc663424b990a74955ee74a2e93cd8f59d12156fd61282263f8d2f78bbd5d36a646d4d8ba427c1229d305f898bb2e393a1660d41c25e407d9259ce68a95795eb60f7ac4dd701e37846e8c3de9ff7fc2a6e362b1f623fe271798fd8108e078c1c99cc9d1d9cbd6988f44a40e6902da6529e838d412fe4d4f85e338c8cde8e81b9de291c062d6c524276fc01279d22e3ebe3a2cc243ce4a6a4792cd715d789d47523e1315bf5f1048ed2950d01b519746ecd4e42f92c43b564c15e789003768840f6ae2b413692bb0c8e9570ba7e597059eb568af45bbef45d583cbf0558a35b629f83c1964c39f93c05061918ad598b00854b94b844d87c876d3bf000a0fea3058c47490dec7d2fefb4cefe0d7864e9e9f087497c15d239711ecc2208e35e86008c5e6299e5bf8e17fde046f6e86b2c381cec025fd99f12d8761473e4e367cc8395436f61bf1d264ed862ec1eae69ef827c13e4c0bfc23ed40eb5260bb8a3e1c188af9e651f805a858b15179110ea7d0ec667429b91d553939e3c2c7c2d86de13ca3d07882475f529122e178e4270c2faf53c86d0b6b3febaf215fdf62a0ae1945124d31f1df5f62e4b7c6341f174163ac72e4b8e69c9d2a4f167adb84967fc785c10a45fedcb6077814396d8837e7423a8645988cce3f7c11d251d1acc3e6955855f6f2d18bc6e5f3fd47c946be9d2cfe65b1c54f900a6d7ceaaf39c7d9bc98d128dffce4786b60aaf6901b1044cbd6c8ec4342f8be1b297bc4cda429e7abc53e940792d5507f92156bf8bef61b238c70b28c36385884bad9327df5d428c29b1b9a280ba3ab5b2530c2014ea8c3e9212cbcc06d9b68437e4dd9965bdcc8fe5e53a8421826bec35871bc8e884dbdcdd1e353ffed5113d97f4df6d963067f31b4e52cbd98fc4a5748b6a2c2960df259cf458d79dfb338bf09786ca530aa064027b7b3e4122b31d78e16e309b9d0d6f5ed6ab4cad08d59d4def9ddbd9f0d5790174268d5ab7ab8b4e160d21b0574b3a845d1310bc70c1ede86eb7f060fccd5bf95628f6f90bc6a6362376a6af18909022b70d55353bfb64927648dd99c4d1525f297dcad0cdd8876bbb2f94a4504bce11ffa5d246766f48cc55b25821865124fdd89f10bc5d7fcbf57c062dcb5e61cc7e224ad40e868e794c4b4dd1e1ff335e006456797b8320742b214cd3ff8cbb8f6ec2d47a71abc84520772a46805b5c81b0cbedae185167634439d3f08507086b87ec6bbe69e28930b62381862b5b8693f1a17c5f66ada43480bce45fdabe3dfd5644098cb2b5ed4f12fdd1b0c8d8938cab47b28792d664604c0347c5d9ac2ba0857842748bafbfea04f260087f26776b795951fe237e1a1ca10290a53e47700fde814fbc9ea84f9dfccfe23d1493f8a68fc4e37d2b0375a7267624442016f49cf53c2fcfbd9f4c0e9c029208bf8bf6f3a829fe3b7b7b3fc6cd8d11595ce8f40a9a881de1f8d6117ff12dac48c476773d28c96fc678eae3027e17da0b44698ae9ffa6bd1be2a98386d5410021177dc84baa2259fce0e4d68d7c562b71ceb4867f6dd60c715b6c93ce91cce5f169bf3e2d70786924ea68f4e2a9f7d91e2576a5098587258e151295be7477e5da5b9a3685570e79024888ccf4a2fb51ded8bb8dd87aed420f181008e566b021bb745e6c8de8dfa135428837267f6444644c907c726ddea8cb9bcae217a3cea6e0dc2422ddd6901d6ed3b35e85c8e6f86dddd1da02c430dd4e9ebcd9b2d13bf89bc88b22170a8d3e9bad2f7800c97c523b7bf7ab7747d9e675bab81b7f2cdf7230a8dbd36ecad6baa45f20cd0e06dd04aa959e403dffceb42230c5117a18c64defef09f5764ea013b89a5c70ba90f423b3b1f3de61b6c793415145b4e1037bc544d6bfcaed8def964360f8111b27518989751ce167cb429fb2cfb6ae57ad51504c4edbf4eb0d53fdf84187d081b8a3e7ff7247b869af1585364b54c084c9cd48c17a05ec7d14c039af8407a7fc1fe2accf33318f6d35a8bd3b39108b346e2881850847ece85da5358c2cdc373e7743afae99aac09d5b9b69fa023518f1b81965f2981fd427325f19668307018d3f32cde08600cfd5c5512246a0718e4b090a45ea4f90c6646c4896ce09b9389023b206d34e0f657c2ea07f028c725ad7e23ca93298c6597081b318cbfb52954e01cc3190bd623efe8bda1ab7b210c57bd68c464b2df14d5baaf15eec4288070055a3a9ef5baa9fc81bf2472fef6105694a95b6ffe1c8a64658ba9fcd2017d1d45c8c7c30fd367a48b4671e8aadb1eaaf46e965fd32e4e376f3b5ad6604b0a1ea5749d29bcc8097533d344b8dedc104c206b78f59abe2e01685d93de9a90d9e5006c6f54df131ae8940ca8f4d51541b8c5096424b70595bfaab5999537468b2415dc22efb066cf2a0b311141a15cb2dc7ecde9c27911350b6beb5614844def2d1337f99e51b8d60d3f4ab13735002e04d3259eae2ae01e27fc61ac6f4d0dfb95c61ad962e1754495c9b09598c7c11c3548bfc5205597c911dd0ffee4c6b020de1147f571fa1839394e3d54f08fc1796542cddc3b91aff40e9327a8d4a35bebaf6d746665baef256051cdcbd0233e9420d2d1e46ee11d4f38645f9a78ecf88caf3a422979f3d2430538041aff5644574f27136a2f076124fd633905ead59ad8bea339cb95f861b4900fbc62b737757078cb5e758eaf5929e0ef23dbc318de76f5945989fa9eadaa8e19cd84af71ff79fdfff96c3fcb7bf86751b1c41b85ecd39138433f4e72711de340d8fce7d59abfc253d5bd96aea588fac09467b2c2c2066229264c07fed6343ec82467f131dbf5dc1af0dd44e6e7a790c817d800d6d71cc8221f24180f73c5fe3d4b28b15928a3a3ae0cf28158b02623d347bf4e72ce42be3fa859beaaae4c1e1aca92f793b54f3b5779bcc10d13b6e863e44d3e3ba7eb0ef8d5c11bf668eda989d3e802c3817a0b22ef7dc79c9059c5eb9c3a07f3172e5ad70a307597394af5fb11ae8d50f0986c1c15f7353189d1f2e492c493fb773039cf6d501f8105040710e091669480589d677cebd24698efc2d239f61a5d85bbc1db92a7078f48fe2049ca894c023302a3fe37c1c5a30f03d59bcdc0782c206a472a61061d102f1e35883057f25992168ee54dd52702dc05e34dc015b9032669ff9fbdbb40411b95953aafafac2d107c7860dbac30f674f7960dd5e8ddab4f1700be50a77831d7ea6ac7e4e9b6afae2f447030449c23fc2648a7820415ed6a8b44bb0dad835732eed55cfbd22d9710649456d78e4b07e6784b2e115aea5ae19a159d320ea2736420d3a4ff54763742ab44f8d3b2381578a7d2b90e55ef150ffae84b1eda362557a64455fa2cb0363f61d253d8af88225d2344684ced4c245896621b829ed84af198f454360847504eb07fe15cc58b8f9fa930d41d2078d9e0be0de9e691f01f30b86cd5cec3cb3b58b1e5c60e290871cc2fb8bc2cd02dc2fca15ce5410b4e48bc7f0403fe486e6667ee89d6f7203a42a8f9e0c6b8e921b1f129bd29f6f281e71d071721eb25aa210981872c7b225031d2d30ff4a7a1c6699f7856ee6083ac76ca5a1da5e777c258c643ed91226a138ce0819d360944e53ad1cb4d74a7060649726958d74dae5b2fe9d907face244915aa634eefe4c742463db3615b7eb8c64ad15820c6f539b7d740e097e608c64ad40d02de6e9a441d67c26932308ef075f68ffab74e5a9814ef9f81b906247890d9191358c4950ac904583f4afc4e7f10e54e2bbc743bdbd98aca6b8904dd86b784d244c3533fc217bc25173d8392b8f7873cefa9330ee6522fc12e387eb211d335bbc38deea25c0f2bf06867b016ff72b7378a25290e2788c0405e8e3ccf78830157d48c05f192f39cabd727a43dbf8ae5b2ecdfb24f6a026b6a47b6d7490cfb7fc745ca9ec63f2234427d45bfff4356be078868b2f96653b6b0db64149519197026195aa6931e9b0b358325e20e764632dab420ce2c1297255d8f9f9f885491c4f4fe4766876840e52dd7de33da791a01357be77d099c7e4fb9485c0af1bcdd89d6f4a02bd2387703cfe66bfb40f030b456a1391d60bd889649b5c11210a606f104f4dab54d2edb59171913524db65c0da12e3a40468e24de157ca8d1628880514467282a32a43066972c4cbff02dc1d8f9228d39cfcc62e6fb74eb50ba59bc071e6577e1f0ec500896c6f956d346122f306186b0996e2756fb224c57c83eff0fbd2760b7920dd09a85d08b6bb89a6037251e649f120d0276a05d7637270ad66eff92ac2444432e50d7d16d3a7b823aedce7e6328b2c547b1eb5347f80daa8a24cd4a00dd1677e69cb0dc48f966ef30ac53c837091eee62f5e91675849aad30bbd90fdf369e8b5b401d9a05dc31cee6bcb5bab6e6fba67f9fd87a2fb493b63b1e1fbbb722c30a06c128e64f1daad3a447a3a1835ff7ef333eea80f42aa9d4ed9aaadbe7ee6e5bba7b001170e9c061650a97945d85676557e6d985b6081db3b17189d6d077c355c6289a629dafa90098b42aec888e1e474b3ed011f239675de3ec6949d484abd56721b78a3c4018978d512da74e4f3399f08d6e1a474e542360ff465dc77eb42adec9885c3bde29b219684e06ee17367b86cf402950105d78aae2137cf710ab9a047f006496e2569f18d28ded306a19220ce315c261c9111bdb80ef9ff43eb3764a8deb43ea7063c9685c21857d1d763b691f51105346a676eb78717fa20e8b99151eac75e13878e4916a8e23578e848940ed809f43172130511461a5da02509506f653a4fa18c2e5e3ad1f33c008a90cb6ebce12c1ff8d343b5b6481a4340ca253c3fc5b6453f997fb4b822dc7c40e5c33d4259c122d88f389de5cf39f1e47bbfe00c29100353d0982cb2145ded913a1538a28c8fb62b61c26d0cf3f69ae7ecfb77526bc0b79043d65b101e79ee4ed3a19ae630ad45eb261401f420556e7d3d1b97f7bc024b9d6b8d018733fae4c397e91f4bc7a132c1f4a6a8730cd9b969723a8682da0e804f7f0ec7a89619e7a061b0a885f46e90c11108bf677e509d0ede1677d2f9b64e7464da86f2cf67ccb3cba2a6e868e422a80ac259751b638bd09168f0a3728d243a72d35a00d9e68c9046c35ff4890e571618b0458fe21606bb07d8cdadc00745a6fabd1b2861de4965dde7de5b99cfdb5b71388ec6bac34bdd1efdef8764d98698bc01ca4bf03d95805371a6d9d7d38eb362fd23f86b794bd199cc001f5410ddb3a57f987789676a05a0b4a5a6d70baab319cfa4361a3a1d1aa983d124ec2881ad2c4259080291510f975f4ae2add5b73b1e1adf63acf3f2a58533868dcc9a4a96d856a3f1518a4595101473e918fee9017074e07e15c5c66672eae5bf2795d51593749314ba41298808fb90b84fac9d5ec1ed300a63791a2d6f24f41f5d1fa12769ffffcaff09c701b207133cf3d6182ac086540d0f108ba12e06b1bdf2b92f4374bd67fdcf72bcc138d043d8c7d30738a92ff40fd09fa3a398381f7040316fa4805cb4ce89bdeacce33bb8d21fceece86ec107584f5b4f381f5c8a60adfbbd421fc7a9a6ec69ad8a868d0ace663266de43885eb4bca7b9d65197f300fce70eac97c35038e805798ecce96e2a0ab417f0c9139398c8aed2f331b9d77d23b628621852646525d98aff7201fbf2d8e217aef31b6bffd6a7310b2063409792ecc2428dee85aae341f78496f83ca0cf0503cc0cbe32fe344f13a386d2771d08e47e270ad558e7d0f504a42ae80819f48d36a4273569e726f8db07120e051365466455be267a5513b17bc6fe03c61851e66042af86e33678f58476bba93809e913b32c4dfc65ebe4fdd08fdd7fa73cbec91ef4682e2025aa00f3d99906a3039f4a06ee5a39b3a8b2fe7b3159e7a6fda46ffc5190b5e0ee974d43b5a329a0f39794bc927d8537d48618b74489ab0b5fe663f6d64b68054c9ad823d428b22a06a9f1f2fb9b8cb3cc8d82213e1162bcdb70bd45ca4313e4a64ee9193d988330dfd0f2715aed04da896327757987ee4c8ba9ad4a84ae6e0018c0efde0673776fef358290890a748e1a5acafd58ab54b4e0146fe06d7e7cef12194b3ac890f1be2e4ca1adb962b8d90bb95760c88ba30b16f41de0d6d1cc375c8237e03b28b520cdd49bcae37203438367052215125850df15ed1b6dff1783fbaa29f9422003c8dea382e123f856933751aa97559224f517838bf54c7920e2db0d2b2ab4093268500d66bfc0e64287c7530217579172278b5b0574a2a7afb146d5699a538f7d6b3dad61b121ee5e1d5833a153fcdc6a369b28e7bce5e70a9741260c8e5287fd5c514316c677a5cd0f4890c995a82cb6e099cd7ee4fb26003075e0bf1eb451479ded99b596af75080ca5301d0c18049143586d168024dd00a63638aad21e7c7b03a5aff924b6b667a5655cf3067fcbab6bd87dc47b8d6d65c908d19eed913d70ee397f474a60d22746ee6da5530a873189e627377f0cdd39dd18e5543e768055c6476a01223178b4c2130c23b801e5c49ce85e4f1c9856d3761e5bc5903ddce4710ad4af0300f72be47949e2662e9b7059d3d6c54a771062fe4a9c91dad321ec8dbac16978f8653f8c8d67921c0368e172b04a023b3ab91dd75ae5970a2406b880bb5f536511a6710e48209d91e968bd41c82d3db7ef5f2ea35944c40fc2736757f12c0a8bbfd0144a212804b698b9c16ae0ee5472ee73bae5974817af3680b0474b6906559523f4a87b09700dbbd792d3054da02c571d711a14b735830851b1828ea7c4cdc023aa2d50a11c817c2e0f26a6b2e76e2406b95c074fd86b029470eb9c78aca298fd9a9cfa9dbbd5ef746bd2aba3dc26972f9b02af3672f299312f095fd31e68001b781709c9f9eb807bf9f7ad775eec4074e619d76fa7a439947e2f033824c5369e842f34ee69c40c757c46aee71234746dc6dc77a5d9bbbfded6c6f83447716ff65e4a30fe442c5e079d60808e2ee115498afa6c928f0c25b63d2e8c8d5e56da329f094555b61dfd6d1444f3dba2ed48ead0ce50ce3865639c0ceaeb6852c4138befc2cb35a61667a0d092b0713364b730f0c7c1147f368f30457423df6599d3e603862552e8577befb7c0cd7966aa730df1bb54b7e55e5c40c7de137f58ec363781258c9630f66a20270cfec4c3639d22ae28861f84fe484b30928603be7e030871bdd533723dab5ccf36cb8bbecd62e8d3418d81fdc3bf78e7cb0769642b3e7e33877f4f7f26f29c01b10d12b5fe8669fbb704f5854d1eca5acd8da47a8c8b72f03ae92a26b783d4a206cb56f0ef233bf00899382be9fce57d705f2860d7f8f7950e1d57458538eadd00272c0cc3d06b45b6e5d3af313fafbe54d85fd3c0bb6dc25c46767507776716f0adcb7c5aa57688f74c2c673af0678cc5fd6faf654560537cd186791b5a14e63bf944d82452e727fd568edf38636e940149d95be06a390d7fd89997eba439656d25a186a31c8ef1d466de2f028b566fba427fa4e04e80a6f91f56eaf5e960db04e952f13d663375e4fe3cbfae1a0f155f875ee458b6f7bad96682a6a630364427f10e8d5b3c0a9b9b33ae45537c9d85710f805b23fd32ab7da6b076900bc89c53fe69bc111efeae0b0ca949531fdf74b24fa5fadcc2993f14a77b391a6c6708dc11b802c175315cb33e1233798ecb9c356c397ce8e30ad34d2a056e18ee5767051b757187c8aa9b3f4d72964ce3f138e6b385afdca95508005cc325d3a07627a0e0dd117cd550eab40699368bb2e3da4e2a8c83b7e7ac6ca5808695772e32171a62ef543f7ffc01f3b7afdb3f5691d46adc2ca5df118b2ca57641afa4f6ec98da56dbb79a22b7051d520fc318098b399a5e7569536dde8b89063310ca12e1c669872c52afb357ceb150585a85bcf7cbc9ecddc1f025cc7e3374b51896fd9941489061dd99f36c120821cc7779c65f2ad4d1be02ac84385adda805cc4a5cefe4ff8474d90d1151faec581412954bf9307be28b5f14cd4dec06273656ec5b8438a7cfde80434e63d59c6b51a6f023983b84512f5a0070258a3adf3c29474f3794dbb6e8816e5cf5577b7f76bc63d5e05cdb5a226f0adb9aa9c813d0c497c8c5e7206f835ff1c5be1f73fa12c0103cf7c415d551a7f8e8d79970eb45f0d1ce10e871edc19ac5f126121d3f1e10c5a842f0f038789d56a985daa787ed3eff5208c59e986d712894f583543e65d22bf67aeee11ceeb27106d5bd3d81553ec42476a456365cf742c4cada9c5165f63646694ebd50bc9cdcb35394bab13887d2873e5090c5621b6d680ebe7d543555b07813847c328ce751c26ffb1ff0e0d4335a8276eb336e59e7e351215fcaff001b6ba702951fae40c855180c86e74dace1d9a25bf1cf31e6bebcad0153c7115e1a94d4b4f7a6e1231791472c4d75389302fe3ad1db145cf9777a92975f3c3f6f20ca16778e80f045e6de451a7b10e704b2ebf1b90dc4a46ef36b5de559b88b3ab0642221444605e26a14531e157c78bf6b01764a77d0dd092b00ee3ba7db79bc61a3324e2e768f57958c113cab387c9ea1424e54de12251b6d7864a8e9640f22199ea6065d123a6eea464a62638e09d3618633c3be853d55b854a7568f96482f964468037d3eb5fae76c5faa298d75acad381159409bca3ba8df98fc2e0307ad8dd4665223f84bbe291fae9d0737fa194cf27c74f7cc1fba0e50259a9a2ac624537a397b6e1f5346ae2d1c3eed6339c740d71b87710e07a4642abf4ac30125475e8f4ae14ded33976f1d894ce8ab90e34ab2a826be76fa9c600b4e0266f7b36fc6e7fdabe70578d6133a7119be14da85c3ee4d70cd9001d6b761fde9bbec30eaa82ad06c3df5d51b459b39960d4469e949d66917070895462fe5a169cb676668849515b525a305ad3772e2b21f62ff7e7cac3b5d7ba713ceb1033758779aa45a05ad5ac3a2cdbc4068b06595c7a0528ab43862fadfe78c17cce4d550b475f5f1ad46385272d4ff921816c45c7e5f531474d2569f34b577c843eab1a67dc706b966207c7b834aff6d70644d067d9e8d140aab64c87a3c5f9be5425840ec7272e76d02e38a9652447c619d201bfd50609b6ace8655ee28775056542a04bfc42357aab658272f0afe31da2ad116156661dc184647d4f787c16a079c84f6d86e8b5e8dc4d086f80d675b194b5ae7a1410e9d24502d9043f1c4ef41e927b335990e094e474657c3362b205c0ced8ff1539ab3fd1b0693d922623e167cbbad3cda53170632eb630ecf4989419f7cfc892e7aa1957d252068264c82b05a3c2908812733bc6d613baa6e51644ae967ead616a072d574c75dbf53f852a7c9cca1f245e2b017442da59eb642d25414c874943684b450ba44f3a3ec52255ea55231f4eafe3b782c7708f2bbd30ac0c684871d8e4a5cf88628f468d10ab11c33d2e1b50316a098774c1b74575b2ed5c9e3b56b66a32e773da3865d49fd95c43f0b011cce579537dd64da2a536db4399169ecd6a1fd0644f17bd931cf35d3b624c3053fba9430b0fd97bd7aa790112bec0154ad0ceb9e4427fe99e9b363cb437e3b8f4150e16a6b833674c57273c1e77fce45a9a7eb5e2ba13a5f0ad37807ff149e5afc5ab1219b42c4cef8d80708c71ca3bd019bb832cbc9075ca388c2dbf87fd59a8f0f19894fe7a732aa5655fb5ba161eb384fab5c0ffdfea89d8c9eed796e170a5dd773aae5ed047f2b6b87cd8b317bad7cea0ef7d2712d1e52f7061b70cc95046e5ced3a895ae7a913f64cfc662e07060ec808c2b9bf5fcc90c07a000b0d7156478fe3d28badc4a17e98efdccc0dee4746a0d159b41aeec08b168b41d0aa8b19e52c00a668b1818c0d3d0e37a080a902897096307f97ef7b2e3a97ec1d1031f0ae63d8da629cd77b0c0bb8cd322a02b5a5583f3db3ff6f8417e5b1e08c97bb2f8b8c10af01f23348dd747866fc7153b439561f930233463939a8981c52ab8a6915435fe2ce22dcfba6854d6c21865b2155802c7fbc08d34545a5b9eee28f23fb552732255130a3c7c573ea57578239f7dec4f2e1f5d62e6d972a94a2c7019fe922a814c04d44481c945c88254be2dfc9babf5fa4d2c349d34bb3d9e3c454e8b68db1a3672942d7998ddc2a84d1d94723ea59259f51dff3b214aa4d4686a37653816dd65e357e3fbaee9a0b7a12785277a0efa5e53a0d1b508c26caf612d02caa754e34de7c4b8a7f47dcab290c04895e2a0fb6b33b03128c1a0c79001b4a669a9d9949a77f0444d0d56b10cfaa059082f82bd4a4694219922c5805b45b3094554c92a0a8a93193dde066a408648bf3f07dfc58f95e6d9294808893df46b4011d29bf6fe99579d363bcf75f084f339cc130378d58eb8fedc94a43f1ac0018f162ff4b320eb725526a69e75cff576e719cd1ebb720ea37ddb61f3267c4adddb1cc2be448d671520910d9b3460a4c6613b7584eea781f1305144d6bf7c05db8e31acd97d132cbb0dc91a107ffeee0916a248889a2504faeb7c315c359d2e297b6b153b3d96a73b4378f86aa4526f9960f685425dd200ee9558b154ae1e9e888c89d86d88234693b72433fd948a4094c7b52fe7d97b996b4d695851f6cc55ab5eb6367114b58b9624942b0b2826dbd1c7c03b6562ea066fce1b685b98b79313e345c7d0068f99c7fb5f3b6e7aa31b166ebb9aa2849c8043df81d0962d5865602d4b015fbd4d8cafd1fd2f1d7336ddd836dd5a26faf3b6396546712d05b79d8985cbee0ee73a45040032fbbc26a4a085f2ea4127a5b1961cc0b64a1fd2f6d2ebf31adae565865414a9203f7d8c64127a4bc6388ec30a11fa089251b9a93e5d3a309a77acc9da2274ab376f3d9249b7ab1d522d3aefc08f35ded6f7aa59731bf496555841ef0db83e8c3f9c7301c5eabd448a60883f37736972ac6c7a159ef4ce59306e8b45204f05dfd5ba7e4644131be2f56d4b1d15b41d1a52e9a35ff0edee9e4f46b8b05e6fdf596dbea46c5e678b6ff2c9f1ef26090875df0483975eaafca66048d7f465686f58cfe05495da0b0077f6881da2f168ed933d0eef227356f0d6b1e3e7f4c34d8dc6aa2a0c54beb2a2b4a2980764f99ba46b56ab4ba535294fc9ba4cee02ad26954eb57c37f640e1315f33c400f6c08263a70594f6a26480524a1da35cd5ad32315aa134defead9cc14fa52faedc8741139f7be898609b402c65ff407ba36a5933bd608f39f2ae8da827956b07e4437a8f4ef935893441a6391195b6cf6841683e2648c67b53595fac316128cfbb9e2dd857ebb0af766a7371a94e62b2bd5c176efd95e72fbcf25daecbfc6e130ced230a967a2ff3c3f62b49c8a81a0414325b8ce5d48c974061c0779c306cf6aa8306587b51c5ac591ec56548a3c8529b521e6a72972182642c309efe6d50e1e7a13b9943cc09e9c9f0f75d01b5a24d585859ce4354958374846d9e08ea066ebba25eed84ffa145ec8f0fee3801ef4463a53c2dbfa07414e24f70ce36cb3bb3980bdc0914f569953dda03bed57e1608588897e7173edc989145db7d9d0a1e83f48dc8ba95ba406f84761e7485612ed8e68f3c0ad1d5ae204eefa0ea0a320b3b4d9abbe1939576c3d3bc69355572bcd87b6932af62a006ad0c82b2a4331eab9d2d2fda1fbc2303494cde9da3dca532593d4ecb1b0e37625dc4e04655c7a9b80958d8f8dd59c2af36673ae78b2df0ee700a342505e1be263013ec1d6418af05dae5587e5561063cd14db8a771f7b5b4c48ef19f11d9c4d1cdf902fc7d659bbb70e3ec5e4663c621bb0fe523975f3a299905458bc5b1d2ffd3d5a76b1b72e42016363582702b803842cdb6f88c1a4ef3d23fa8369b9b58dfd5560299b87811fd314ef0622217a3ec2574209b4513b009e6003c73998943f86f8ab475f92f93e55dc63ad61fe77ff22bed991fdaf0958e677c407993fbe0169aa5466b0138f1bf333668592e1d803044484e848d26f03826c690c232f82dec2c75f9fb82e45b16e484608bbc2c716252f735db9987759b25b477bd77ad20259b8f4f540dd21a173d230a35fed089313ba9abd7d491618bbf340c92654e7293d2419c46139c6c94211b4ea51b88ea9b6205d20d74096d98752796dca7120c9d212be1ee4a51939ab9f7315c8d944704c4fa4ef6e3b2f5d9baf2f59443652f69d76542f783ed3286a0b998be17a83a1a8651c6e0ab386bae2022e77532ead7e7a84541aaca456d2ae5223b0e8f1b6500b4f5a994a39e9485e5ae6fdb36c49e848252bd2478756a0f30b79a9f32c6c7f5993a4fa7b4eb6290f05b2028590a71347480a36e9bc60de43cdcb91a0e858386359db5aeb0769c49bedf0318f6c6dd5ad672c5e55c50bbf6bff634de6822d076b6e0da84081175e2e6c36c8f978389f5ded19bff65ded3fde266bdfe57ebd111a533725761b961b1abf1140eb44186c13bce7cd8e5e83169fe9bc5f03d247eda2033fcc04ff87fa3b2bebfd60b287002fec20b58cbdba1eb2ff4cc3ddbdd945791796cb523618ffa131e35b9b4b538b902608401e1d3eefb3196a22f1b85021cb1d42d54482e1c810aebc028ddb2668f33109665309f3caa1af1bb5c2b4bbee5b67ff74bba770627fcbfd7eca2de3364cbef0433e41046842fb3b75e02adbb943d6268638bd36e953a8a54816ff6ea5b525f0af97baf1646d5b3641ffc6ca02540861e0ebfc19402542ca8f0c96e8869ed5cc3030f00210d4442f69157fc5c1a9b6aabc8ffc5323af184471059f3cf81a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
