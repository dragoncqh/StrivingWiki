<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"68343980a2f5cb2f57186f6b69cf23bb58934cbcffcd3f5ebe711664e410b4f2af4b5579d081c5c72109ae8b611b8ee02bae4ca74dda0f442c5136902b7f7d99871385690310956d21a88581c5076299557dca7db5ba65d26a9005193636428a576abd7ebcd6ff49e6fecdb52678cbe66cc939ec4268b84d93caec65f0129be0a68a8a85568f06c9776e3ac6ec8215728c82bbfa5166413f6b589f86e56434b9c12def946f9dde8b9fffb6f6b1e79d5baa64da7c64a4454a99fbf103bb84d1f04a1425892de3bf6b57f6613d7de50200a3984b4d228e4c0222ebc78f1f8e3d1f34072dbe39bb56dacc61a09043053d0ee3685e5166cc259d7698bc5796e8d8800fee14e32b29cce3b2d3f325075f6c55d8749787170761edf35eed1fbb09fb168227e71e045273d4e0f1416c6c3b4f7333aadfd66f58d2c695d6ab50321fc2ae9162a59efcfceead1536686958132b058e1f2816a70c7e6e64952d52665537e963e7fea6e9f6e1b30c8761964a0b2639dee1bb141775933e70e37d18bf82c06dba8797e8ae9a7f725bbc72777936ad155c1dcb8fb57d4c5766eb74587adc30b81da89ee71fde6e1547ee418897e02d15e0eb352afb712968cb78b26a7756b07ebc8ad57a80e769259d0ddb1e00fc80a9b937a806a48ee1d6bcf9d3230dfb2278631696cf7b11eede440d6713f4661e9763d933ebb4e2120405003d19aea50eb19f5d5c02e61c121398933a1692f540813169df2a6d884244b038654e6eef84258b8998739833490f7006c480266e61af5a38979b21f490052b675eae47c267abcf7a5febe8930d0eeee9c3a357f83f6fd4b70ad9608f06e42a8535d4d1a693fe45928d6a5f299d8a685b0ae8e05de38280feaa590ff167376291c34c3a0816e997c8574b1c44e9d04d6d0c235e8777610a954effa41eaf64ef80e4aa7413c72b2bb37adcb8f965c3ef7c02232d72bfd00dffb5bb8541af36ca11a42291a47bc4aad921ecfbdb5cc75d8ac32768fc8e2132fed0a867c2cde363f0e47000585ea9ff8bd7f58349249191bf577003b58d65f8278f22f61c88e1f0e62e134f9d089e9a4595614407be1e60d38c888ba8458300ee16fb25761f2e30b21ece14d9d043b270d4f491b3b7d864266f92892e901bf0fe56a3b931f9a50060d3723cbc2bbea1536bf8514f930e7fe8a094a27cd445a2dc62f967d62470241b28f0fc893197cd853d3eb7925278dd6afc4a01c41aad2b29d913fe6a45861b29a985771c7ff635c418bfca71e6dfe135de90acce87ec88ebb0bf46eac143c52697750720dbc4c103247cf6f27db19137b9621762b417067c1e4b69e495ef0be5fc166161d942fe18f5045c533fa5ac56294d9b8d09bf22eae634534d5c83f7152dd087668d82009d9274c0a9224921d97046b8210f5596164a9f81fc379f0c0d3247b22dd5d98722d196ea7a79590bafa7ad7b30676498144c9ffe0037c52bf0f3680a0959807e4282606a5b6e03b1f837e7862aaf327ef2a68b0285f05aa7eb7a608b6b62499d4c4bca3e9d1a066dd9f1931ffd4e0c7d5b3eb02ff048d60759f2df7f89c5302989cfcfad27bd18d02e56559c08fdad6b34054ddee720ef6668601aefe554b3806b23cda5a933a441db59a05baf1b1406b2c241d5004e8b551253d4f862df0e18c272e7929aaff475e4e5de90e1f2d5803394eac7787f479c1a0f456b5644ecba0d31f51429989b77b57323e36524f73d57d7c71ac6a2f298f21a2ef85cb160921a15faedece4495c0ddc95e28444dc8e594b7c0521fa8dcd313a6c49e2c19e277c5fa0abc2fa84fa2893b22ac372310bd4c25551516299bb5dd4cb527052849ec89067c5a9d6322f48d700f412dde13ffaecbb720802347545a50667e273c7f2436b44a5127d4c5dcfc06384b8d985b546b7df5cf77a1ffcf219b612091a6b9f7832e0ef2cad6c5e30d0fb54f0cbfe3377904e6a9d44c11e9f37a2fa52ed03ab7b62bb697e9961f18520ce4ee988f401bbca344ea671414306b1ee8f6217938536d84fa80a3346852f95658aba97843178ac79aff58331b5ba5afcbc257a48a38d9fe0a02fc02de42b3732052ea0cf4a715804ae1d58fba60f9dab481367b26e4c21def9bc6d7f19448f60e8bd6a2c683aa2873d309cc5682699e1e0775e63b8f4fcae7dcf90d679944e3721c87ecbbf4ea2b8f3cefdb5e0be3948fd26ba7e0e91c875373c7719b4c8229cdcf7e7174fa15555080b4701d4c29015470db1a13ac4db2fd4f4e995f102e05ef177a1b5d030586fb40fc9e05bcde35a3e9bb89b269c8485458d1fe7dda3cb3375d8800cb969ea644f1ddcd53c79a85893f55145cff7303f195bf96340da1afffbd2c4854573d4447906e6c97bb62596046fa8a0abb44c4da965bbbde01c5a0d04b34b36ceef851cf78e5c86dabc28dd80fd445ca3936f662fc5c917806e0490130f5c141726fcef24d994b5e0e3c100cd3069fcea1fd3d68cfa174e65e0f38562b8b2911683dc68d0d675063fb3d93506d55aa2e2d2076e772b6bc111ff5fe3b6eaf598ffb803d6b92d9caf17217789b73a0c3b72fe65df6fb50cebb78d68d51e29d66021288a4cb7a8c791e51c3d437943486fc92ca59b2b40e56e723c7f4cc1e47d88c5076cebc5f9dff465eb06f32e48b85c6c66d3bfb3a3b7a930b0ad34f2429c5f5e2f90e98e353f504658e90e8293d54cfe66218128e7d71e9c32db0c7f6a52acbef05e03098c4333fd4bace21d165fd1ab8d556806a505ee62e5f27cebbc3bc2a263b2c2122e7de1d9140e0f96ac16820222f6757bef321f3341401afc86a837cc7b81669ede6268323b74093a4719b0be9b22224566109176251a8baaed6ef81c3a54bc8aba79851590b4f933a851f4ee6f85b1bf771b69fd5db9641f31b3d776575acf9d64167b5117fde4d3b6072583b0712f589735e2c300c564dc88926fa6845225df938d3077c7cf56d358f95d30a0132922190358a35fea4bd08d3736ff658827e6b8f4f2163d77285fa91068fb56d2f37d6ef02b43daae17bab003cafcf2d81f5e9f604d376fa101619c881a3dc15994bf6f69caf8ffc0fe81800caa6e0ff484f7dac4b74d88b03a1d22f593f468eee00730967272c50a10391277b4b9c2ed0331f6d83a6a7f6be4115498d509e5a426cf2e9301a40bea1b190326e2820bbc4dbc4b91f5066149bcd4038b2bbcc1f91febaa20cd9090ea028352385a51597b9eef2f33ed5621693c2e707be3f287c09665a3767aab44df47464a692690299aa84a08bc28c5a1a78cb415906879c5ce0943c44ea0392e69f113413692eba8a84247a3bfb3d8bfca891a4be20d3ecf2d2247d9b80ab64339767111b6616e5438dcadc5198b7af62bd998d466a62e44a899993087a12a28c7bf1fc10e58408769820ad1d1cef97bebec4d02dd84be5312f2a0563dd52d7a489ea9e81c161cd25e0de5c0c64f23c9a1b04cda04145ab0bef62bf024735b6ec131e8b09830d70bb4af8a3338d6c279f3fa0231927ed0970d3e83a607c7d6195ce6ac107796a264b80071e147eb55b0edd23cc858c2c6097596595895476944500f8d3e32a8756a63c81d388deab94c3a80968e59a2620de3de8e9f2e5723778ca752431d3e79a612b49e0f1f32371edb649e32c21719d52f4cb0c7edd59748ce774c3d84ce2b65bdb96344634d5e28dfbfa7a5d63650998322275fc8df31a9cacaa095ac816065066da72a08343520e400265c7b8635efc586edaed934e02b0a7227aebaf6f9c21b87f61c4a7ee900d19d935f5d2816e3f6d456c6382622e92b86284c4ae50d7e3d161254dbe05268a5f488ef4439ee9d39f4bd42e78702a9d8d0cf5b845598af12a9e279055c04d91c3fd681f6f723a5f7a602bae332febc598ffdd5ab78061fc5c43d7e57b89cb9b2a073d80aefc10ba43f27efdf20493077c39f5417c6114fb16750637ca3d716889a2c8fb26f2d8c51fcdbdfa29b57e35234ea3531e356df5bfb9c43cd4dd5cbb18ac001ccfb221ee1b662a8b601e304ffa8190b4ebf80376964958d45adebbe10fa2112227f1966faa8b4ed5e377195c476bf39788e80f21cc0e2057750695041343bae5b52cf5856fb7834270a2582c81df9925917f58dbbf234aae8ad731020d77a7f4d923909e2a41fa8abdc8785faf8462459a090963a04b2899ca963307d91d8bdfec07de088f5f4b90945425dd47f1cb64ea2f2e8bc54ff294eeb92603e806b45c9bf6c2b6db8526693eaec7396bef9e41560335c926c8555f5892611abd2577dbdfae73862c48a56c64c65b523b6bbac394310890c8c724ad9e3532281899cae3962f8b58eba489c2c55ba422700a650b76975e7d4f756ea7a32f732fd0a1d868c9656b61db33cda85124239cd792550e1be8b75e98b97a861dc75a2d37b59dde87ba779ca0b3accd24cd02bafe524da2e6d33a61bb1b3bd3589d5177e4679b484a8adca94e4ff1c7bb554253b88e757ff46e7bd0970f3ed1f0e30d92153f3c21cc9f4f49ba00fce8480d274c89e80d4604384e609d1c6214dba77ec8170e9614d125fbb5f22529559fba6b1e3fb4f8dfbae401209155b06c4b53cf8ca97be041cb802962fd511de98e7ada5981f5bc1239697516b2375b0e587519243396cdac3929e35b6bfdc0909786e0150645c93bfff07eaf5877b7f5539f652d9648b5bb815e011978a802755602dbf75decb315a66fea027ff78ca8372fe817f40533840d577da724d0ba2c17233b3da9d12c56e3e1faf67c482b59712c173157b46858f7b4b3981896f9832ee065cd7eb18126eaec7585c666c80f47fff22a5e6dbfe46221e849cf44cbc82e761fa2b3fece60aefdbfd5a32a8f588a09451d70a139dfe891ebbd3d0a7b2783af6154a06e0718799b17ac8a35fac3cc7ba3a3138bae74c26fa77a5502b436c1c82c2e9ece2c006d93df64ca575b6bac5c8b1a9afd9c5684511ebc24771a0983675f933f95bddfae8bd8878f57c0331a769889a72ef40161ddc40aa6d1701df39d01ea01289561fa7c4b14f0345239c3de6d7b5f5d46b11500e1518bf247fbbc7a9ae576ab135ba83621d97993422592b903f0bd1a31f1c04daaf23d2cf8cb3b112a9fc8cbcaf53c7b910120b34145ad8ec9f29b39f13094a4d70161f5e38e057f4def8a0c0950640aa3da633a172eb62461259fc3fd9981a59ef905bcaf30477d4b4a28faff4138e96896e04b75d783c360287b85d03006c5b0fbfa573064afae48e9339952e8ab326a1f52052d9840a88d5f2cc6019916e8598c9d666d4eef71b3c51610ffadbd4de50741c7920944b1581781bb5a52872126ed9ed835ff802ea2d0bf2a09c089d88ebb91d9ad207b7d21ed4b00245897344a673282b3af8ab2f425ee78b7bbf57a90c1581acec0feeead3ad48c0a71ad3d661e57a0d840f9d5f75304c5f04590547b1475840bee5bb62448a98b82de6b73725dd1e0715c6aeb0fbfde4c647d3cfe6843bdbdd41d0fdd9c2e0d3780aafacca10093d54a5f00663174aaa5bb1c67888279c5b30a3d5c543af16f5d143731d99aa67ee01d3b33300709d77086a5592d200c861e4538f2d63b6be56bfedbe78de9710047333d21b4bf0b2aa604babc51fbea250255ed095587e217abee0d43c1d46eb900d2f54f3bb40abc2307191c492e10e1b5f36f241e82fcd6f51e82f574536a4cfc9e20202c135f60b71dcb8461e05fe29f894e0d0942bb9932689db87e518c16f929ac779a1ffd034a5a37d30032a106cc604f9e401e08482b76791fc574ae8b75ff98a186b92284a64b795b277bf3a891c905e02cc6fa68f9290363ab70c1504343ccf6fcca163a27f90adccaa7fb9b3384c9a5d7f6ca8c8ccc1e783f605f839ab906f670f31135c3a92168077e8e35c8f7d60ee1a1ba68af23bc166545e95d980bbc3675128f303c1606fa90700d5a680306c0598ff80db5c995e24deb0d622f07adb182c2259f258a1539227978f8b702ac564f239d8ea138636503f6bf908acea94ca4a9a7eefbe7cb6f79f9ba8735c220f655fcac0b016c4c26ac4bbf92b798e859690a17200f034d7cfa442579d740ba2807287bfc283c3ba82dd9a1c39211e44e9496d8df269963d5a49946322aeea6ed641ad61bcd7f7c20a395ffc7654cefdd9a78254c275b786e76fb981256dac0f6d0a8c567b19ca457c4a1eabc01814d828ef126ba253db90c235e573a5068e6c9f55691536a5f73e969c9147973f12c5ea6c70d1fe39af36a9247041c9d385c98fb4e3225f61ffed326c5b7e7bc37a9fa0b7c4e25f4a3b94561b07ff72fd17019996bd1528e34d10f724a04db5e8ea13dc75008c4879c3905fa89c9727a7064636e84cfce18957119a03d583f7070dc9990aadc8de194f8fc6665ea4962b8a2b14058fb4afc09923ac1e9ce638daf8031b44a2e54250cfd9f4372e67207f5944be88f81c4167227843c6e105fed777624900bad835bfead61abd2c0fd7b86b2721d4d29f02af9501e4e122f32ff298b43332f0337712659fe4bc00c10f196c731d6057f2211e0b087df050764a1945c1ce491ff522106cae2c1e2871b38cc34d7de396776466bcb7c6df2ffe07ea7efba916d3b30a638982737c3af7d57a62ed298ca48919070d45facab8528a69fa9dbad718f96c1a8488e4db5af58a033458d2875720c1b1abb6a12b9c8943eaced81ea3c21e890baa0b5d8788a1697d0f013683580f86876802cf1cfb66d84942b112b4e0a292086271e0a2a9301a7fe165dfe015049018b77578c90fdb840d27f038eeb0087e60bf9c4e67e028a568eadb5374f439281e0b434cfbd76fea20fdd97c769aeda8993f5580769ac4dcf1b5314fa6cc69c69c53814765bd82c888f8f5b8e47d5cd046f2dabea35388a1ddd444d45e18cc04dfa364f9a5b67e278318660945e1e18d03e9d466e65962ecf0f979f2a31b7145916a274b81e4c7bb29858ad24e81bece0b230492520fb18477d4393174cd63fb8e182621a9d59e6a547924290aedd79334237fe1c0e8ca0d05b9295bb5cdd3221b1f85798622eb33b7c93fc5dff4c1799a76dac742d03cff22db63a7010b1ef33c46cc6b50f5b841efc586a8d2b2cbd7be413142c3a3fcf872df59609bdfc17a2886051cdbd7e532bf9579f6467f2896dcdbd41a276c58593b52c37a80458faf4718e41b6a641b7d6e78186044f23297e73ae2deed09a09ecc6d6e63352c4ccc84cc44a73063a6c780360deff85ff423ccdf81b1a771ff612938e3635669739b473e8023db8b05f7f3a5a930774f61e672112f4037aee2d28a6ede108792ab3990fa7a6dbe01a3182086f94a112724b64c1720d687c1d32215ba6e80fc9d43cdfc11b086276efc88bf2e4aefc15f0fb090ca2f18fefed920134b429799de7406b663e07d8a7ba290410baf837c7dd61f810e3b7693b95bbd0afa8e49a31d9d80d5b801b11c9ab3e3fcc55033920deffca1c436c579be84ff37447917e76cb0fa9da57d831249c3ef44394305f39e1ee58138381dfff1df1376897ef8d5f87a5a407eab5f61deee5fba7c85fe5b5a452e12113c431e55bbaddb298934343bf1378f8304df0b12414d995139c528f64c0602798a5488b19dc8dccd9a110886c43f4d282f24c8dcd944d191f72b7492441a2296df42eb09436412513f6f765dc978091064c6772f70fd1916907317c60059a2457400cf2c6779de781387c42c48cd6671a1182376beb59e5bcaeeef92070f8a67bab1b300809669d39c036d7c6e09f290f594b446acd2f01c0006f8193d9cae7ec0e1868d186d5857c5e433263dca749bd175512154b42351ee749a24048c05c00650dbe64d574d0c5d262ae78f0b7d70de837187a67f5362f9b5d0f9c9c617e9f4877f0efbe9698f303d5fc024fa9b6d6c91a21d4c04162e96547bff6d0d9e962b0578d960090aec347d1c358af90e5eca273bd346a69cf13700edc95df5ea8bc1462eebfa6b01f28798f3077e4d386a2ce9bb30d335dc706b55e539e89fb7b55da9d3e141a7e913d20132a6e6c5f2abcdbdf2fbcc5aa86d4869a59a6b48916102e089e55be39877f036600c5e1607626d5e4fcddc0cf600d7877898be23ffa65c370f5abb647ec7c3b09a81da38149234959e70119411cc92ef596c9437cb424d515224bddaed7d3715166d4ce8be65f32e56ca426df2d601758aff12ce448cf8a36b62398fd4a30186f04c11e3e21a1fda80ddb08d04f9891ff4faeebaa08d2adc5ebcb7d999b96e0212a0b08df1a81f08d115fa959b19c4ba905682507cbf1fe8acbe09275d014a6caa1fc45284414f2c17a163ad442b1bc06e5af21bcc66f12bd343e66cffd38778c2206fcec9f3b06775c340f0ab4d5e13e0aa3239cfee1919a63205d59da75df73ca7885070170d369fd3d8fa432d92dc5f2435cc6ff7fdc149edd2dda09185e5d38a21d2532dd5899580144a08836608a819766c497ac90584e3aeca495ca4147fd4a2fd4b804bc0723b4d977e3cf0119f012b06e418c643a3889e4b5b4a2fb239a290e92038a7201d5d25c74edf0ed178e901542a6a07508dd78140afde55fa4b5a5b5910853d31a65b71c9fabaf4bd17afddf30ae1bbfe426cfc97745d009febb17674891765a494088921ce40ea1f34582d0ff6ac7fc93cff82a22d37961a1d2f2eddfd019700f6f861c0547f91da441d81b8d726864153a4c2fe9eaa56b5eacff90d062c7e244076a767a8bf2f7ee5ee0d57b014ec10bcfd81e543ac23f060ecc09cf955a48b5205b0df5136353c682e1dfe21a22f3252e4d2e4b270e0fd5d2bb6fc1f1011ccb437858db557a38165a649698e8e5e3cc12ea2333233c7cfb35f87e0a3a9ce5e77a4d61811e7cf1b0db4cba994b65557ac3e03c1acbd61540467fd8b87989ebefdc7a2e8cf87183e47a66f1280691bf6c4856176db392e7a69df3eb67d455deb12f494ad268d1d3fb8019c5264ebc061fcafa256ef3408cec9e6e24bcd7fef3bab25ce2b339c4d39e39658012dc356b6d317f1c769c2bf30a9016d7381d05acbc38d13d4a29949f106ce21ff1a4dbf5477334d7f3d2ed10f179e82fb151898c0182f00eaa54e455c4a85d7190c1f82f9f851e3f75d5a323f394bd820e2bd25dd04ae54271baf0f262f2b261e52e6a7b948b711b559c5cd9c5048c890e80f314631a829f2ae12e6f189c87c2ae796a2c84c28bdca4dff813fd8bcb1dfaf739ff8718e4ec018a6a3c6221a16cd524acb0efc5fe593d5a8b330ff1a513768bbe63efa1701b8a4798a1deca53003513c49922041c3c4f0b98b056713b8cadb3171bbab25b3aab9f16f85034e9b50555315f68043fe229803006a783a3a94b0ccce6126f6ff9b60835d39c2ab085c9b26ad0481cf78210735f79fc6bf0a02c355ac5ba0593e42561fcc67b088c1dd00ed0c4a8e02a7c2609ada6ae59cfe2121f4b326cf89d1139bdbd17fe345efeaa2985d11cc50a6a1c509b84ee4c670c6339bca1b8d00288804ceace68f0a14ccd60dc60caabbebead0a6efe85c94789b4b1c2e43af9aceae9408bf9893c7b55ed5e575576e1400d35b10d7ffdd770ca9387df3b009a92f411df32e880bef5f2928e0a3795b28baff9aaacd9d866fb10208c2d43f77e2a25418d850907f361f4db0b52fb32e222969aebd7fe4420d9c9acfe8906d71ff061a8f53e6bb1b1c3e8dbfda134c50b0738c4457e142985257dabe4aa025a4b4f50bad82cb1ef7e5c43fb5bd70d609aa6ad9803390e6ff304a0ddfbf8fc6718840a16b5ee2bea6535979b02090af888c859c5a8ea07763f46036ff3181f6a65d324b615872acc3f85f75f470af1568f77c63f51821e70770af02f5c4caf04cc23276a0b941b28b0f4c40f5316091c92e7a89e4fae6b57e66812c7e27a01388c14be9174b8fde3827eae5a24b48e6d113310c74665b9e5d21d435cadf68ff02ff59b8a97c01ad531286804e5a0ede8a3ec5cea67caf6d1cdfe893c1868b8066b2cada21b3e78044d1348525ae5b8967057733ee2058ecef775f93b74d1a0f324bf2b10d552b1ced9b0f97e8850493a279de71c49c9915280fea2ac6181b9e71a73a6068ad76b0176e74bcc8864853547ec81eef57537293361142fd90fdcd743235b040397ef28807ee5d3c03400b42868ffa87ff46f88ca231a97b68bdbbd444426f9e3fc9028b690ab15dc15baf42dddbefdabe7bc3eb6fed5c2231daa0866790ad9480281cd276fa8117d322a1c1acdca08d472dccf8899e8d0f6e8a5ebd49a9a10824ee6df45f475c91fd7588fd617ca20064dde317aeb678cf2cb8b6952e2e73229e2a4defaa26d8d372a28bca79d70d64a4288af6758bcafafead4569be4c0ef7b3db79ba1ba05028f7c5768bda3b50dc62acb46208824ea8966b0976c3a6cf2058231a4c503f3b384642275a50b146858cfa94b25a48d17806383dd31bedf5fc36d7572d3b9c44b9f279168d8b1b46058595b6571e892273676279","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
