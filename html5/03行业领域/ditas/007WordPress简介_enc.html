<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c9f510612bf8a0ebd5e02332725055c86166111e929794b97b11cf136fab8ab28b35408d5b3b99a2caa6c7385a330ef63c41cd0a7782ce5404ac30e157e85f76d22f677515ffec456dd77a3700890349a4b1b6b8311647aeeee6ecb6e32dd6e0051c0d55da2d935bfd2894923215b7146d7c3b438c6e7b565357f8b4858178b62f6d393a8be8f4d40c37967b283295e84dc736f70fcbddc6b7766026bce0531a3c79b09426867ff60f5549f3342a40c3b60414ed649630eabfe37c9c68630fdca2da0aae9e5059000549298e26cd434dbf877c7ef02ab0e29659c5422f6021a81a50b03249a60f96365de3d2ee42bb64fcad32c0eaf7c8469f9facb75e0af65da2b04b3b1f755480474aa9299f122b6af5eb79bb55198916ef27cf3052d8ac2410484d470e3d7a0c1f9749e278430701be43fd286c2440391bfc32400a5fd4b5619976ae3302a6a81ed77365f82a826636657fbaab27da788e1ce971e2675f8fd28f775aac30df247a7d90cc6a8d51232d133340f503d8164c39d05a2990bb6cde226dff1a309e739673993892400676f0498d7d1e9e0ee7f6082697d922b384bf75b3beb48f0b26c9185f5bb059281d7ce62da24f37821249f6213b35ff0420770c7fa41630076bd18b8b7de9e90f9e959bf093343fd598518e154f06bb82602fbcc8e559fdc610ebf68da6b8087eb1e71f89d5b663b0343cfb6a7cc0a40036944c7e46531484be3279f499c33627592b6b92e43a6c19a37531f74a52b23a77671d92db3e942d94d34b6d0b9cea984288822258da3ce07a11b488972f0fbcc780d6e62f19082acdc0a77cc37847c2aa0272c34f9fb817e02544ffdc75f0095f6f1e97ecad35f0bd3f79d307473e1c82877e1bbef2b3546813268408bb3c55f1bdefd386866105e199748c311863fdf285c92b7a8cf5aa89c4017a00b7e0a359d69fd7db979b6a4f66868660be1ff13b2f996f8d833b741ee9589d93003ae32cd608a362a303d7cbbf60e449b87c8dde951e718469d78feb1fd982303939e61a3b85d9c384925d5f5e6e4e267709215639126670d39385f445904e0358a6dc5ec95c5288bdfd363d67bec302f985657a0f1f83b3296f31c3c37956aa21eb78b91bf4b298f18f554eb9a4befcf8a4b017c2862e5a3baa62389a28e4234e23dce456b678973146ee79ce5f105723ecfaa199c4515438d15b1b6a109fdd7f0db41bfbfffff275654dc76063fbf431cdb132b8095a926d48d0d8140bb139bcf52d98683dfc58225e29fd8c26d9f70ee35f5ddc0242c9adc09e2d7a87c7317631255bf97be266e2e7a7c6a8f28129a117b6d791e2e27f94efd4ab149d7c2374c3725d2dadf4705e21af59f4d1fecd333ee107abefa57206293eb39958f7cf3a53b0acb0db3db5b093040ece1c3261aff41b664f0f2e5f0eead812ecad888d0da01e0c7f31f6f406af49dda306477977357f558cd6d1705d6a37b7cd56eb0f22f229e43b19f7dc848f0e601841ba0b7450c5fbee9f6e8d9c751ae9063381d3877ec2cfe29335a6a4da5ed4a2b772630da0a968774291a8aa15e8f3ccb22778d3ffb4d4d51b9e071632aa4aae24a0ac1fc7570c0e4044e4ad3cc1edfabc7cb338e2cbcb6b1f6bd19b1e7545b4cbd10e545d92c9b55960183adddee11b4ceac9925c3c554052a335960230638d43d40003d70671278e56e8625ccee93730f1f19961b05c430ac1fd95f45e3c7fae598ca69b6a944298c7cde6023192e2c753fa83f6e9cdede3deb6a0f63033dfeaaab54fabaedaa348104aba5f5285961319de68715287195c0b6e46db3f599dffc9de6b28792352a792308bd764e5d94a571e4005a702ecf9045fa1b7c686863c5ee916ab92e63154ba80af79f74e10f350534bcbce3bf95fae50aeabe5688aff9b320d73e03f8b5c7c8d2a909e16e73956242ce4dda321739b9bdc4ba91fbc1905d0407e35aef2da23e2a872da9b9194c452f7f45f7474283a376bc7e0e1c5977c6d96b9122e012004b95c6f47f28597c9be7f07146b241d350c4f4af2ca2f951debb85b5100070cc00e6dfeb765dbee502277f5e129aa38b61118b58ebca8c2a9b3f72c9433dfbba4cc7fec007a0b8be6d696874ed0665cc1a3454f459f2700a041cc9c1f2f4ce624e665259ac4ff002eef3f7409ff625469b79bc092105d82c9edfa5eff4cd23404baa61c11982533904c88a27a859a4b5a5262f3c76131701e11ac2c64fbd873603abdebdf0ad201e02fe106c66d1bd84773b71733eca5892d3ca05aabf4b35292e7828f813ed39abce76e42f186c6ed7b09dde2ef53a3e3e1462763a19dd8cd3501ae20b5c7469c8d3b43dac49e918f191feb4d408d88d9ea1f3f1ccf49561489332f4a537afcfa1a6963fd373752a6cf881bc1c50571997b22d87874ab758939ac1d777b6ee84a8416a7c0afa5937896263d631de817373fedc77c8d937244f531599b6f5aae42bb6d01de41ae1a891af7535bd7d72ee7d9eff7c90bd5a2b5774e1a0d6a148567c95d77b3997374b2ad944839a0f3bbe9f6bd4f846a51ecf9125927d680fa57bafb8b59b18174d93845deda2cd383fac5525bc0bd10b32f70b1bf35237130dd14cb38567638c591131ff8c421fae5be8eed0c57e5783763e583d02e495e633cec131d497eae87deec8d26e66691b041353bf7f9651d03a3b8c0c6c475f856589f678dc2e5b9c66c2c948a0b063c0df01b4f9222dcdf4fc4a76befe7ec6db35255b9f4d001b77975d03c03ca0828b7e29f33d21c12c898f8dbbc70a29d2dbb56cefa8ecc20927e81d3cdb9110cc2fa16b7f39254d3d37377889f31e12267123edf47294a4c25129b7ec5cc1aca943b2e24fa90620f2f9685dd4b19f10e909fc7e8f1889fcbbac5bc8c3ba5f42341d7b510a3ddfd8c6e3813b5b17824b448d93d1c1a51e47a26eb786fabb284fb1f539c6bd1a283ff5c78e4ef3823aca980657d2a69e738960b3efb3358547f3c2313c3e1e769d6b4e535df9bb5ef2ff31844adc7d2bdb0ea63d1e365f97a4bb208de5a71ab9edb4b64c8e080cc2f770d01b23316489c518f81437efb8dd16f63a46803f774c15fc31da26aaee46a760ab3fcafbf2590d92e1fff3af11ac170a0e3506f9a012b77f1ae4034156cb1d276af4a30f0f4c941173e4e4da9f2079bee97ad42c4be5df20b7354615a5f5aae315b4ed4364ff3982f93c55def3b669d7ec5fc95475a98c10961e9e63f48e8b24e888ad5d9c018a363343f540349e4eba8b8a7da22f262c5998809da88abf0cb80372b1e5d4d25dfdb700b1a74843f7a841094363f557acabe3aa5cdb69f4d985840fb43e82637a664ba9fc135b9f120d336941e8d0745e7a0546eb02af7858fa7c159fba631e5666f8646c507882dd10fe8397f8f81113f83b4edecf04a9a9f9956509c2f650f6caead6fbf23acdec79b4a13749c6b85f5c9cc3f76ab6e6da7f1bdf125f1a30e4e9c35baacf956640033f12b4ccbc10781898fb2c29035ce5ac8e0c1eacecc25fd92a96bc34e2d4b272d6f9e9d837d1516d52c1464b810c5cca802fbd84f1747de2e93641f6b617dfea4879e208aacf58c6d8f1c32ec3f2a6b12c51d8137790fa2c26c13a5fc8cd0fbc51089f48976a9747656bf28e3e844f251959cd8e75b2bea37e96a4c13e04d78cc1b5cc0823e1fd6f0d39aef1e607582377a69af68024b56977fd756605deb313c607ac4e6face2fa4beaf499ead512735e97902949b0770ddbdb19aefca587ca8f2d7eb316b1303bcf013e50e996260f7bc7790e1743c000ff7eff56c47c13f5c14ec078432194629f7320d010d8be7daba591802eccee740add69f05a47d5081481b069b84b7f6be4dbcba38d4055ca29f6cdc314be51a89d29104af0e4a13c474ef6eb3e4406b03d1eb9785d3e510fc34297315c9e351903fa98042640b96b4d937af3841564bea2247386d8c4fa6a54f59a91ab099153b54e5ea2431afccd35719a134e57aaa8d27deb9faac25afe0344c159b92450aecb39edfd351114c3981a7779a1eacdc28f46fc059f2ac234f22db8be31d3f10810ae5bd9e4548f92fe5e3cd39fab9738a997c5659900f63f632eaf8fb7097e53d27f95bac93e1594d92cfc534d5175cdf9af7009541ed3c66b715d50cd60c386e46eab112cde997618aba132ebfc4cdc679c1ff3c4d0f17bba678dd102d09f1078f1ef746db38d28d765551bfdea00a7a64a8b4830d5b186f80b54431e17f9e67ae03043f5b9ca1c51dd22c799c6cbfc8c0539ca5126fcd284ca56749e7f074904b4ee1ab2f5c6c81af9667bbe45d19e1e2880634e6a2716384bf06e861efa50f9e0f02975568ee9df3c45ac560a25e18b5065744899d93bc4ea2ac1a1fb0bbc4d10c13040e79bfbe1d1a87792925d6e91a7aa0db01b61d0a11bd227d09f8165775c6cef5b5dd874ba275b251238330e8a301a4e73dca44189f7391d4425d0e6c801df97b90be8b5e874628389137057595325cf38996b072c948d2315b1aee8371fe01a3ddb5d43f5c2bb4d2b30a4c1c689987b5a70d896362de0f25f8b40e2cc9972559065fb2b77e1f73a30c696a7e9d9279beb4296a75c1267de0f381ccf599d2bbd4dbebe7d3d7f8a841accf726d598903d09c3c7676a097f82e0986a94430c990709329d3066b6b7e20559371e1883cad40549488581ed21cc7f033afcaa6bc3e8f3515873e96f9d19f8ac4b91ef3a07f0eacaae1512ddcef90ea58675b41c12046889c5889efe7b926bc69744609a7755d17d4ae4101354d82bca44b88c0cc93a85442ce710963886ae448292009aaff6cbe65143b6851b41f8fa2cb73c65df08d516efb8fad8477221b99e3167495","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
