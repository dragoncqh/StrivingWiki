<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13c61d8c0775230b85fb5ea4e967b013828b21463b8354e13e5379a06496f1f8a8441cc0222546dea662110c80708d70f93c40fbf484ff812533ed2227cb0145bd17afb5f880f56032d101ae8b6fe514e2860f869dda0d579763d6f778af3ff5078a24ddd9aa4b9093a6dffb4665216f63e11b7bf927e4a193cc7b4d9932f5fdbd21d963bff74a01cdc9e17291d8fff7b15d286fca98bdf5997c8c3ed5645d10d3ab44e150c4c83d6250ec95e534c15edcce8b6187faaa90b1dcce064dabddf8573aea0a86aee9b658eac3169878f704095fc0552716f3d39704e7bb92f558d055759a0e2f35ac9a751c96e79527e7ae2f36a4fa56c1230e8c72830e2b65519b1477d6ad6cf688cf32c4ccf909afe477f40b0374c6afc2467ed5362f3cb356ec643e9468bc6877a5248dc89a704d92948d2c3b07e3ddea6931c4b6b9e0f572bdeac8eabd371addf6bf87d9c076b4b621e03cb71f2a397748bc82aba6a53b7d5ab490e8392c4d9fe4680154e2039d2c2ada434a6ae27ee95657e0765c98d752378c9b75bd860f7f03bb2a1cbce4ef80d8ba700c04b66e6590bb402edb53692e1816bcea66203f22d9ac82f2f15806f972cc1fa0305f7c761f9de0c3cdb18bc5429ac005065f16ecff0be84c5334cca2630d4e391ff20bebf0a8c16a4e6734b6f5f7a0d24e151f2e9317dc431100a5ab6c4fa0b04a17b624a798d92f06722062ea5212e3de7ee8d49a3a7cdb81c9dcbbbf6a43096f2b19e67858916a96af2965a3fd222046acf9d49e157c6322803b6664bdd06fd53697e4bfef1171d1079a2522e62b067a92106f3e8e89ec3620edfc3a35653ea3899de6fc8b900bf91af4fae2595894c1ea267c4c6a52dc9675d3244c9d68729c4ef07d0ca9c8885d2c06154007e9e18fcf924372c89d20cafd94ad4f91f7fa567341e474d0a8ca8343b5f3f12201bb22a9a78f5433a0a3a8a29e78d1d983cb827aa1239e53f6d99b16db54e2b080e0aac6e7715fb822fd47615b6e13ac8889e5f16121f3e669123b95b025026eebaaeef239b0173a8d24921787f2fc9cf86f8a65c72d1c810e164bc499b936bc28208f072d871c7017ba6bb48b8efc458120ed9481cf1a599b88a53e4e35f8f82a2895b62dc6d8ed173c864e70698ac7d7d74cd40148b8b4d28b2de9648beadb1546bacfbcc896f5a8ba4f653d1b8977682141a050fea88fa3320eec9b8fbe76d2468fc0021fbaaec428c5c155cea028d678c99a50eaa9882f4124bfa44409822397bfed1a5825acb703ced32715357b5ab06ac14aade283be8f7a0e5e0d96e32baa4a7fdb0f85dbe61bfe4b301b6ac0e5640f4cd5da5d8d5b415de6a3a8964ed9a646bc4a36859d66fd9bd8fcc9f1b1971289eedb03221cc50163f1c81369359d2c1eb32206380ab49ff21436a05f7224f98d495f8d35b5199adc50ca50d473fd3d254cecb8285af3fe991bca58c8033f499d80a102a5fc8e48b5616e66a0112987ad19ec818e24df82004fd655c6c8531130fa138cdfe6e082c1738ba46be96fc1fb4d6f36d224f73a97970b696661d073aa5c0f3d0c5cf5de69e17e21d67c9b69d3250d9a4199ef5a99979602ee2810fc5b293ea864a919f7561d91a04323a72a41d923ddb5333d2e77e221fbc2190d8476d4560d9c82dfdc9394aaa9ae09caf9af5971784b262bca7f4e9fcc6fe2b66c7339678682eb32183f6439886ecea2fa894bdc29fac8ac35cf1e396da2fa994c29ec979a7ac0571822040697a9a4d6cbf994b85858c7fb96bf961ce49f79f0964254567ae13c276acebc652cf6378d3f7b6628b93e880a1c38d5cb9adea905fb1db287e5679d45d47b4e566d9587c880974d594bb6c5d6f553bb98c731285a518a137804b3730c498129de2ac79bc1daa33630a86deae196a9645be038dbff0eda1a1a622887e75a0c60d4e3053d82b227dc36f815d78644f769b1a1a4dae9a5dfc6163715ed548a52743ab99b51ec32087640059ec6bc8ae8c6a4bc2ad73e40ff52e0027ec2ba200b0308f7924a67cdf644d8ccf644469ab36a4d8b3171759135606a2cb68a18c35ef3b670372b3567defba5328e1a14e6cd807fa1ae7d4c709af548987be08f760475ceca44b275474c8b82eddddf6c7512dcbc7be4d03adceeaea4b94ddae3b7d6483c49a62ca7cc9a0713eb47daba379abad87320d3500f40e5a594069928b4d2677475b90e8249ce2ae00126fc8133fa9d0d4ebcea0006d6ce3df4d80032700ae7c8c79cd5fab03ea2309ddb5a3eee7fda1d767d1f629075f1f1da951ed5f44fd70c73ae5dff358e326ed9d4c8fa7896587f49a9d7636417387cdb2743889dbfb62255e27673e59cb09665e632f9e281e569cd12024ba9233f7c2657fd0e8bdce9cabbb0b8a6ec4d05d385a7db1ffd7e7327bdbe8c19f9a4fc612cccb278b4136ce987a03faab3f8308239898572af334fa2b033c9119d30a9985a6342ff0b9dcfcd57ad65567cb6ea89a59024249cdbc92c31808856f18a92f578d9faf8ca1b3288d020ccf4d9c24849d00c294edba77cb30dd3b50c93c610b5475950839b4b8d47dec68923c3daecb819971aeaba9c6c882f0331ed926906f4def632c7fd8f66ecc90e60731faa9b294a46f58612203c7146f72920b8275be75bc1f141c3a43494c30a2edd6eba3c1adbd17a59875fc82dd36707a2bb03f147c28092404bd2c5c082f358076bce9f331d82fe24e73dff3c76904224003676b4e77ef2432debd701062962156e0e47d9a74c2243efbf5bf839445637a8a6293bbf7de3417933e78b2d4ee748ce305ca96581084351a5e27972cb681c11101fd0e42bc83d6c242bfff4f58abacc821e061140313c5ddaec292c9fe1989fecbe0905fed3364c84a82a8b1a22330451c751ab1cd8fd79acf7a00eee44c7147c39a16ff31d9d9afdc1d5072e9da903a8d516b7e8c7afd35faaf89d2af33234b3fde3f554136e2194988151e424de4784cafc222bc237be6fefb5eddafef9594cf8f7f6974d46851c7962bbfc8cc5d62fcf368ff8c6f69605e9d6f5ba9151cadad360830a7dcdde42c1f053cdd5419c3d2f3e5e342576037141a2354f54992567dc7811a4b3109500e8afe0d1b031e3daacb05f39ccd18fd1198fd9f643e4abd9bd74216181aa9bd54dd8cea0aa7d5ddcc55cb58af37ed9d52b4ed01d59e279c40b515dfe24726f34e5e7cd8945bc93aa77f2c562a5cad2ada44027cbd2989be4ac78aa9ad3c7eba23ea4483a0404db9af42cfd3a1127b6f771b339d75d34563a7621a43560297b335cb588e97790cba1a193ca7bc0e5f4a458a33ef585fd363996b887faf6ea3dcc35639dc98762b0c79fbc6defa6f0dca503e8121946b6d1fb68a163b1dccba6362157cf91916c3bb15c6a36e65aacdff9bd42ea4e5046c7bd2db020fd96e3540361b374b3f2521235db48acc5ece0367cf070cc6a3b72dc138dff59edfcf20e91014917e4ceb5c2fa382679c3a07b4b2dc359e7a661bb7bf97f9be4847761d049b79a5dc539c7c37c1809362489998f8acec8d1f01ea3b4163a37324db44bc288e2af04de0006d2b4e0513a59d6b5f93d4157382842c5c95b819c92e03b9ce41399b5c1ef4f7f52e6aee278b6936a832a250f930a287d7916b49257d2d041e7525f521bbb888e876bab26abd91926bd691f26a2b8a25e6df172d862c256a0b1b9706982240a76c09d4018f06422624e3590c585ac3c91a2ed97a6cffc27bb5389dd4afab91bb8889723967ae833e3fc9121c8784e35ec9de91dcbad3152942af587e0bd96c3391260f652953e1163b5bbb8a47a7350ffc459e61c11daf9f684407c2ed55b9754d3f185300030d1787f2a0994fb2bc23299f72a9a1f0a621e0adab8ce3e111412e9e4077319605ae2ff6d6a6006b35937ebcc29b1bbe84d3499adcd4a71bd6c3db8aca9630eaa350f071e408234d4128558cb5d327e7c93a7db75cf1da1c586b5d4064a21e1d2bfef7dc723db8bf8f19915a5841556470f38bbb1870e6b3c55b2a84fc00a7c4733e2cc85b80e06c816bbbe0f0f7df2d4a880281f1b8fa6814abb408d63726467cc6173174b0d4d1879befe74e737171a546cbc349bff93a421448a23a65ca30abc528d5c6aae3dddf25a066add8875859fa6851aa0cd510c131c8e1245f67033c173bd9e2be58e72c1c43b420ae5c211f3eeafd46690375ad23a3fe7719c99f0f9256cca6a8cb8c2d4b7642ca2cb86f6657936ccaa17194f41c11f90d7f362048c22e18d87c1977645e27c5acc8c7ef739b77c10ee86ad5e76e9e35c7b2c11e8db08485dd314fc4b5e58ef1371436ddfe146ae73eec170938d325a62944a11010f0f26df28c6dc64a2c2628eecd272fd893638ce9b5d1e9c07e58b5c08429ed597c4672909de6dc7cc095f79cd94041cfeb0902ba7224eb588742db56b8681e8b41eebe1fba3675a3a8f0b2431d0ff27cc9cf98ee65c4dfb88a01be98b2ba65de5dc4704dc08b8b0812a6b29b34f4e46cf0e580d9ee4b55073c701dbe3fc1240376e026e680ddeaaafd6c9fe024de6788efd19998cc80549b95d97e64bfdd07856d2f9d759a73a6e09645df2d2f3c1333fcf4a361198a9f45d459283bd1cafe95e4d1488e18a3be7bffe9b7bb116eda7c29bafc9a7437f91616cc4b6304345abf313359a31d96dd3ced3e00a2f924e2247672db95c11f8794b827df6245ef31c13fd7f6d7bcf2f0b3156a95eacf2baa62f6aa861575510af3820dca636d25ac5fa9105cc915b380a49eeb408365cc6190aea72c16b7a3b69d7b5ed360d8f3e1a37b3bbf0714416f14a6ad4077e281a8577b9ea39164be8a834307170690a666961f5186329346bd95d7bf6481b9d49c874a0e0087a461feea8bf3c8b0ec4d187be57d40c24c7f1015af6c85b19b7f82e04588d64cb81e8f1e5b218173d27ee444f803bb8d775b3251708e8eb8d1ebaef3caa2a13f8968e8ce8df2392e8d03074899b6b503e8c1b37762c4bc855e5fe299e770e49a08840478017c8b100a187cd69b02b6084c4586c63d93e0c83aa40d5a1480d5da30bd128532720a6242114b6f88f16b3a08abb5b2334815ffb5c5252ee17115a6fba3dcee10620a7b816cb5b0206187c9f339cd2b74743177c4d3bc7654021b08de730d1a61fc8d5e29e5b81ab2f9926019d35133bed1df172e12c8f41902bd72cbc5062a6773c825081d663c654d495bddbb7cc7f3b32ceb05c4203ad3ac7cd4b104d329501dcc0fccfbc943c5722b5ab5d475ce68762a8632bd0d3978db305e613d8da32cdf16f0de7a571fa47037e0af4c91cd813f3003a6caca8688b7c2f7521aa674c7d1e5abcf967a56b2cf9d890556f00b0677cd31c5624323f60e4f4339d615f3b5eeda0c6b39142db49d19dcc51cf7db7f473e0c0e5563ff1a449d8fd5b9ab0706f2d59b84f53572e870077c497712a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
