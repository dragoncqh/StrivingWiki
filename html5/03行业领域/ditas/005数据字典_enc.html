<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"24d6f621e4e0f168208e71893dbc8a63d9e80ddf72b27b9bf61de9d11b0bf6292a751e15bb77255f7bb780d0dd797e383d0c0b4ce7344840d57187f4289a3d6aea791ae69f81886517f0f545111e07bbce169170b0e5c75f25d17594a51a8d99af2f470eaba764ac14898caf245e6cb1b6d24a52cc2b992ffd87fadc346fb4e25e8c3828fd619bf11cbec6862f2ee63be0765830c56c1680cdd2434bccee65755c7b78763e28baaa1c97e3906b021657fa8b9401212088e83d8e3e4931bf33233e70b96c983f8b5f6393943bb44b497aeda043a11349a21ad099f3a5b714d13e7ffa032da406c9b54162dc545912ee5efb56410f3936c6092173bcbaa63eb263f4b5daf0788f91822c8e9ab416b6c9f0fd7423c46617a00f0c83519e6b2e6338edc05d8db65f574ab72e844b4298ebfdf17d515b2adaf413196878f6873a30f2c70954fa1381b5d04d3918243a4e71f8bf11a9ad24b15f44a0031a22bfeac1946643a5c0d0361efb94eafec1475d52ad78bbebb4cca9c46e4efeefd052fb56e1f568985c577bc43eaafcd22ff8f212e6a9654f011ecfa0c924a094372ccef9ec9cffb8655095dcfe2830fd603c3d046c4b79caa680249aa9f92eecc558899f50a0d300d4040a71bef4f6a21e28c67ab7ba0468f041e6f3c8fe38bc32b0263cb06a25e2aa0648d4697480088f370ef4513ec9f948a8e82d9ba4db35e84e8bd60df3c8d5efc80f2ccb494bdae2f666dd0bb56ea41a370ca6746d2ee3ea51a6e35b8e62eff51dbbaba5ed263a848dbec9062fa483e0756f841a25d23f37781b5b96fcf404ee4f7e866aedf218dc10f8c621a154150178f1899a43f32fbeafbbd874048ea9c053d34e8f5d7723dd6bd7ee1fb5193b5e1cf9a21279b8401d516a394d88330a25c89c6914a72f560e3c7757ce89c94f0fc11522b5acbf9a195bf3a40eb1d8dbc32a709ce8afc7b40a2bc347df421d0eb06cdfec8422839b7b6dcf4706dde9d6c2901d5771c64d942187b7262e71433face28d9c77ef8fa78168a1b2f7fc12df7fa9812ed08f14746e61cd647a3df51cd0fe78ff1a57ec119f1318c9ea9c68e8226935f94fe9d5b766e68f5225ed8723fad5fa831f4a5743ec5f33a6ebd5fd12b1596f1a05c7e71eeb9449553e1dc3766896e488eca65108f36e425163cdb189362e1e1ae95ac3e231f624df42bc544d79ae584328e2f8c1458894abf5e3725cd454c959adfeefd88c2c1798e1c4ba81898b4a8982f8857c9b5ec209658abb5dcf1a7703876e1ff12d438d55301b4c999da467052e165df5b48c60d77befb5903582eca0552c9354a38993fe9d15d5984f45d8aab14b299bcd64013a0377dd9ccffba93767a4bc6d81f7fe35f71707c615c1169f794d74b3e8f55cd94e087e2f3e18684262cf8d8746bbb644d77f5faa84b5603c257e68e2dfac0b2d2094a10ce630d436f5e9e726cc07b2b7c0e0f7d72d859eba60d5b36163892b13d0a432cd23a426f4d88cc425dc3c0fefe99ceead86236a525c51ea70cf059e054f52032066fe04736301a49fd8fe67041064eefe4e10fd6f663950ab34cb464856f6256928451cca46b67708a8865fa6df2381d72de053056756aac497abd7b14bdd7f27d033c3cac3f573cb5d66b41bfebecb50d80bd4ccdf76d976e644fd84df53f205a8505b9b3ca0e28902a5c50e8efb0e78fd78cca74cdfad9889e12133de68a933200a9dfeebd76c7c9f2638ffb1444c8056cf2d1d732bd30e61c5764396a9d61d9f1eb85e829bda748f8257811cbc56553a8950a2f39208fecdbff82cab9475ec7be25a4dafb7411e3b4b4b76ec15578e29f75f38ed935caf02da74e3a1704bd0af889a2c004b40c97ead9b6fb8f2855587c2fdb7bb4d0a65de3a84d3ea761f3192e6649411fb2d2f152ab58673cca956c694c967e0f8ac3ae439521ae0ec54dbb7a1a7b2f1c2c386800dcd49d8409d620dd92b56c79051478b84c2369ca2b38115512bb6b34c2cf55c5bbc772f6633796c2e9afada5120de90d04afd0c2c8d2e2ff8b27ffbb5bd888f3ae5dc86447aedc70e6b2b4ebfd7e779e943afb08fcfa23514ea83c0313798dbe35de12013391df40c93293e631f409513d66119ef8cb94351e2958addb1ece68dbae434d625bfe16fa674daa2d6b4d62530ec427668beac7c5c81ef60f17dadcd05273b9a0b29513b62a3b78ef9466a8d041fb3fae099b84da0ac05764dc56be95d84b06fa7e109cb09c9c75e084cf79e8e8fa0e1994c39094e8179ff33e06c36c600678669234403c85500fdbd00e32d8cdb2162e2d932a29772ab1e6048718a2e79ed27237889e70284bc0261d22a92a59b4eb6a380473023bc00035a7ced7429e36641271eaea8cb2895a3948782ea3acfd083d197741c4f4a1dc9d9eb9586a4f512bef2bbba924ba3e422c81fe8af3a0c11e2a8fd50673fad1e19c806e932fc007335a753046c3a228cfadfd208bd790480f217ed9c3a6aaa281e86e9739849584c7b3512ef3da8c178467e12ff04d364b3850164de25db038c233a685580ac87d786775ef9e3bc04a285f191a724437aae3a8111b5196fec501327af4155447b105e27527ffcf6683fa02d9207ab8c1a17c799f75fcd2dc700d185e74a539f739b60cdb9225bf38fce8417561b3619518f23f1c784c4a67b8d941c7b35d1c144dfc8b7d132a84188b8bbc9fc80060f96590e07d103ac9419dadbe6f7792cbffab55d6bce097b4fa9b438ef52e689164df6eb624c052dde67726f380785767a2a18c779367cec870a056c49b0e02f13824ec6f8d601d4612d08b8e230e12adb66c9bcc34c098af74858b540a09fd90ffb72bd6912569fc7938c3e85cb8d3fe393132056b416bf2966eb4e07383fca981e3b0b8744b83d27396b670477cc55bbd82946b4f2edfc3a382896b920fc9a167f2478a9ea1f64c6b8c0ab1a7957d58238274eaae7e39cf5be3452a8ac8076e27b569b142aeff81909b96afadc0caca679adb65e7c7c926672aac3c91c80f4eae501313743d5745e79dc9be6fabcea14760ad39960a843a9fdf71326b2893fce1a74ed976bfc730efde0ccadea85f3098577bb2893181ae74456953c438dddf2f19369c2f6c72612089f219dc4fae13c5b3367b6da852f0f7e2f58daf40faa86842e21065dd83fcae9e11fd596f1aa80a08179ff95b417f315bb07dbdd81ed996238b75d284dd438332de08b01262114f59735d3d0524e8936c92a3530cdba33a8e9e800c975d8202f6c0851fd60144cbfbd062b8002eefc74bf286f74996a65a5d40efb320c9cf9c6b9d7b586225fc2a3579d262b6c7a18241f3f9c1e234eebeb934a5c1d07ff816d1258b17b74fd334cc2bf5291276f5847ef2b0d8bac1aacd4d94ae30a53b5d6408899dab4788c6b6800c51ecc4752d418710c4d7ba845188b3016df85064babdd22309e3c49dc61f6b5ba4758558247fa602f675b201a0510dca3f5b6a8a7349c1e1f764f349a15131115d0f40fc78f2f582f219435518eedabe61df1ceef1a9c8febabe01aca47fe26fc039c46bc0a54bcf9314131309a2ebf2b5ebfd448e4fb28861e4063552208388368bee6989f58b715b454af996cd8539e998dbb550f2a8bb3b496898e6af5d72f8b9fb2103d62a93b50f4f6dfc90e7797fa42cb4132879adef718cd232158085b1542ae6e13f6824ff097ffdb480605c94e7a5d0c22b7955e13c43265312484fa770806dcb832cd3da72dd5f3b729fff9183ce0c613d9eabe0ffcacec4165ed71492a3b93627460af4cc4aab2843884f542adb8c7a631a24c82186b43e3ffa0e956b39a3df067d437a33d849e559f017be16558b27c782fd787087ed9d1584bed9fe0811159ebfb4dd5225077a27e91e0b14c701716e0f4ae2646f09ef0922670d0117d03fbc0108cca136186c349418939e2cf1500bf33f974f89ff7df636c57f65fc9d3a7cf6516af86511a8c04bfb57b1ec1afd590f25217ed1eef94c48fec1a658e7c9d87c0473b71a49653d0a6d490d7ebeb9858a54c73f7aae1dfa9cde2b51f856a9aabfcea7b5cae1d3db2d967f03053df03191bf1a4dc854fa1cc4ffbec93440d9460af2a205fae2c54712af165e87e827b77a1d691424383a5ddec615190fa6f4c29e6e6e97f5673d8c2c12ce078df8af9cffe5da687799fad1ad7e3ca7f5f0316fed7fca6a700308263579fcf29944cb1b8e23ef55e6570f7ad814d88054e75205aeef63e2e84f1ead3141bf7bdfbc347341292a2af4704e131e122dff5031b8ccf93febc70b11c3ef80290fbaaacda97776baa7e75355357129c74e481ac820e633a12220d701d3ba9534dc4a9234be46f01d8bdf5dc24d9f5125ed73c5280499e53370ee8cb748eea09df7bd25a754b447b54edb45fd641a94b220e0d3dd9a9521fd468890864a0761087c6298d0dbe472d0147107cca3af506795a99ffca4660fe7bad51610fee2a738407a13de1703472b13735358d06188718e17da02c8e5a10d17a0db8db3fdb6c0e0a43d32471609e5d88324f6599fdbbad3773aef68d39a2d62b5a885f72630399591752fad44a262c3133bb7eb538238f3538410d8a72e4fe070aff8aa612f5d60df0788190abbbbeae5b31bc878be74e7eb763d25f6940e913827d1cb521a5d9f55bb57056173c560dd60c9ec249d129f6a68fd57f71ea20894c05953e2040e0ef871a88982e967e7f7b23b00f8ffef0519e46a9703d65ff4dca2781c44b344b10187f5bed9c201ebd11547853599246d15c3727858cf29cce663f6253e728177238b1f4d977e7f932c141466a31ffce8ea6d21b689646a206f37e9fd6745b118fd8558377c2309040d7e97a377e51087c51504bfe31718a7ad2b81784839a6fee76620700550b00b33e3d053dd362d6c465c5079022d1590facf7326ee16b2757b1666da228c5cec0b98cf4f446f43aa2545fcfd033eb9c95aae86b187b5965a508b242aa84b93e4b59ce5069d79e3ba114255fd9d0066be5e83bfd4bded8d45f15a7e73d2026c9999512b49319c73f67a78e39c696ec51acdf1867cd8a69643b2af162e6965d4625c35cddcac2de50472a140b133fe18f1da51830f90ee10be9c39fa7d64e7f920e2b526ad7d574cad3a81969a4affa0e12b8aa7c49ab97668fa98d1fb32fd79fcc4cc116408371f14ed26e6a4971ed4eeee02fde35265f88c6c77016ee5831546bd6ace0ca475db224ca3dd94ae0617ecd207ad6d1ff58ebb7847aed9c1a5ff59d815f6be794cff5e5c591331ab35adf121b42059a9b286bd15d94765bf9b31c8ce40e59f5d32ee705b8cb389f4ad42d7c96219be13bc81e77c5fdc6b839cb1fc9ba21bc245ef8ca422cc3fe22781a0b9c66f10caee08f2d443346c2c93719df887bae0f294aabb2dc6b15ab96d9c48894a9533237a6089bbdaa4025095c9a8214f2713142932867efe84b8ffcce1ad62770d395d318936f0bb03279988a7d70425418f5dbdc151296cfc3387702808e062061fb8bdd20cc28a24ccda97b82fef61529aaca6d16d027006df1f8f6be59c6bea42ed314a2116e3d07bc3a7e8d5214d377fd700c39d9ef7fc4f9c3052fd90f834f73215343ec2b96f3ee540993ffbd12e35971343241cdfd4d2df0549b4adf07ffd805aead7337159013ea1da88d9c61f5f7bf5c3c9d1212f03d8b99b2282fd1817a855877838e70a8f1d8fb76a3d0c63eaedeacdc350bcae2a6bc33b68ede2b69f3dc4902472305f51afb677062f28b238fa827f9327627cdb241997b2343b64f3b9019e4a01101efdde6d3c66473407a52cd1b3f0704fa84ca3c4b9a530204e9715b6a29768f1e1770e937beb64f489a129d3111cfe254aa05ffb57997cd256033a2baa9f9e81616b110c406a21c4485717b23f80b9688c2be14e1f937750dbbb0940df13ee6b47cbacceac73f089df5fa49c9104302a1e3d0534a0c5a27a82d96a34797ec4b89f126f46329f3fa35b901cf4db4ca5162210538312324aeb5aea275a898455135eed8f875bca71bca0bbc094539d549ca7db41fd2c0df779eba580f4e09cbbe919cafecd7e12eb0d141898551d2ea03c57a9eec14fe956bc21579638042992bcadeec2a4e96fe77bdc50e0e5e4a3aed7aed6c2bf563eccf21f23d6969bbaee48166fde2f5e1f394788abb33008ab879feafe0cbb494f6ae8c6b6559686263bdaa418bdbb78b2a30576abebcf78a6c39c1a3a21f56af3a5b30aca4906175457b530a5cb7d1946f90db6bb20a909cb6cba1a62c74584466a24b770881e079a9c59540a94778a48397d3a44403fddfd831e695ec3ba977c91939dc3c77f419175562612684c3668d22e70ed168d84f5dc066df691c4a0bd7eaa97bfdf5403861224263f538109eeae50eaba8a4fbeb93040f5d527c543814b9f207fc0b02e99cd120cecfd39944811a0cae6822fec84a4a3eca43237214e6d5f2872b74f879a46fb42380fe4506cecf8e44092f78fe0e6a4831b8f7f4b0b06a0528122306440bdff38fe89822fdb9d430193fc762da96c0f5b25245248fa837bc99b8a68592d3b8d9708a6952ff07a9947865ff15e0d9e36ec0c36dca2cee019557d37ca4217c8f1bf29c6fa439fcf4a81b35b6b065e2c2bd9dd4522a99b0004196bca3a1818c63711bf2cf01aae59ff4e6318d63c994abaaf4221f8908c983aeef473ed48af7c9996fbbc0f41ebc5f706beadc23ed8828a7000e3ad61048bcdee3cc12544035427778afd16d4cf3fba8b6d83ea0f9dcb0615f44dbf331d06441680f7324f7458bdcd3b7afc3570a416972669d65cf02c585a6af01f7fe650e48d69fb324e8ff6e022b355654ba10130d1968d26e5e0a93a8e7424cebc04fe002c6218409c5043ffd370006781aa8822d8218b4abd7556151e58fd9b40def719e4c2c1e0340699f9247682aa67d4e5c2143334bc55b246724c336bb95d8564e1edcb1573d33fc29d63b66ba1fd8136f9fb6701e85d545e8330f35245a3bfb01ffdf3e42a782a061caaf6b6e6ae770408d9bf5d582f87b20b6a32d9d4dc84297b6ec4972633d82722455406cf06ec2fe8ed93c8e159dd7553730949814440bb6466fb3e331108d4108e626d11c44b7fb6051290070d7f8eafcf0018ca14b52304f666cadab2a739f7c711b80221189dee099c8f65aa89b472f5163c03cc0877b0e369a798b9a65c33136ddbec89ef5429b2f8b5675680f1405e33bdfb3874dad1646cde34a9c6fbbee65adaf5204e20882351ce7e443139950bc8180782880851d1b760e9caeb1b9878f32999482bd98398dfd1a1d4be943f82531ea6479a9386c5906fd73ecb07f95fe56bfe6145e05c3911e5cb486ffaf541ca070a37aa88ec2e5ffd156c9445ad479e22faea7b639b66bf0d8e852743965a80f5a96788a044800a39423f61cc33f0a5784bd427c9b909f7ee97f1b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
