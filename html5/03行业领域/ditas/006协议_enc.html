<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"04d1d768028899601577d3c4c8efa899ba9d3a33c1fc5852813ce553f83722247745072110c1bc14af8f1510700a36c20a7d4f880433fe0d841662e95b6d4e3e60971601da9b4f97421927ded487eff8796b6f8322c76d44c968fbb55f2c64ca988a48dad189f3487e6f7ad38c73e80971d6b162c51168d3a4d4002c47e72468d88042a7b484aa98e6aa4abfe4dd0307614b7b8778324ab941a75c2b6e263bd8a49c79b600676d5e9dc6b96b02fdeb1001032c70085cfcca41be6854cab679362f9b64d272cc041856705ad4cc609995ab1b55e832dd3654d0373f64300429a1eaf35691513bd464ffc372cee163c433120166a13733337211d40ff15649aeaaa468b932577e4fc692b51e6452cf19f8850eed41aefbca54afb4d9a6aca828805543b2cd72e98208916b56beca8f9973e31de564307915eec7a9fdf96bbea5e5cc19cde3fc734399525ab90e00f78af10c1cea689f49244cae3c5acf2bbd97ab56441c62ca4a364369c4f35f4c32357e0e3b6c7999a473279c069ae4d904b6b9cce08e33359ea7be25effea7c3017cafe368ac6f56ef9a16f16a64d35dbf907c45af242bd626c28be537217a89afb1f2c64eb39bd84a43ae1cd76d24cad503667c09afac6a1ad4cf75d882990a3393e5ad498768269807614f460160680cba8f78063ddc44c52bfbf83ae047bb4d239fc42490399b42ccf62a1a6ef30634e6d1f8de0a578ef67f31b28eeed2ee6c79a16a9d2523399872e9d345689e6af3983a8b53233eb1f5a843912c3d741f58e23f363a92496fb3dca8e7801d49f2a93a2e7d29187dfb31b4e6bdfcf96fefc7e6aee63eb93dc0c3af8b11494c00b9cfd910a5d825cbbbefbdfdd25d76e88812cd4926499ca014491a233de392a5bbdbbf497271971075fc1f5a3c99dac3d0e93812895a82bb23523c9ad505c440cdddfaf787311dd41bcc22b87efae15d6c702bef369aedf748672182a228144919923b536246ef1e10a134d4bf2590d138c88ec40bf4842c070922e9a16ebb83b3da2a5302889f91051b9c19dab54706e851c444669f98dc06d628cd4cc580c4d45c8a07bc5c6e0fdc956eb4d0beea72eeaba12ab0a2074d1c654646819d47435a00f7b01dd160676c8f336bf409f3d54575ecb524fa2722fd1c16e41b4ebdd606e8b553b31e1280a275a236fbb92962782f0e39123c68c2b9f036f2c2bd7e1bd7c6808fb8c7cbf23dea992f554666bd5e48be21949a6e2a8f0bbef176ea5d57ad304b92f21f2213b25778c0ea59b10458e75830a9eb410ec99cccc9d4815982ed6b6f5d5fa307f09a095d7779ff0003de65d0bc1638a4cc9d0c30a28af17396ac1cab237c3a417fca45bbfa92759af787ddc3fd2a3feb1b12170f09dc9acfcac960838b0fa226da1ca5740668a9f890df8e4105c2a3d7dc1c31dcf8c1849d613e4801454d6572221d583e58ba23ba057d1306bf66334afc61b33aa9b239a3bfc1c5f75c7528b5cbf2431f99e31427b9e0cfccfd0bf5a92b8b494e2c80c0b325c9adc3b195be74e15eec9b36bfb32266c59c336090447b8e369effd058e661b41aeac1392efb5607e6ab8439f32dafec9b50a55207ce389805bf236a56c0337c30caaa35060a6d8071762bea27ad98f5facedcb9b45d080ecf9bdcc012cb1806fdabeb0cc6ec2662c571e09e4c955032f532ae58aef57fd74b0efa2be1d1c6093150ef9f647bfec3d603c85954aff06f4676bb4f15ed7204fb6da045f82a7d827dae36a0e001f439f19f240f77a28818906433125cc4f912dcea752ba5a1c459f545c48d75d18ea953cdf6194b72e941ff01029885e07c25a686fccc53a19096a9b110559689d96679df28724e4cbf7c90510efd5c8532824aa313f7eb266861bd9a995794a85b6991df56a36d3a04c68d462fe57795ac4066f7a206aafddcc8517faf53357e0e5b99b71f5717f1d697c2340d9a0839a8921e94619afdb06c6ffaf7948102dedeb5e221bd6e554713cdca38f105c335975c0a0eb2d5019503046908eb9c4db061a0e3afe56437b3c4d82fe3d8016274463c28a1c493516e0d43f426bfc62326d77746a299512af852570538cb560a4495fcfb96d47c8c3441faaa0fa6a4e36e41ad921b387730b9c7bb3b4dc2f5fd0b166cd8b5ec0907ebb030a7f37f5f4d02d60221b7f92d3f374f32b4b0676c8b6aecc91d0c15a6038ad75e56d48a76f25935bb3e612b5cba186f489b1f2ff043c2badb21b43d9418528ec1f4c5ab0d805aac79d3c2ee3b87622101ba76786a783779de155bd6532e5fc759cb9450abf1a5ee3b660cc22f2a907072ee4902afca54e6d55fba2b707f57d7b1a1cb41065ba2cd3c561a582c6bd85bb7c6ca20a3de40624c078bcc7031c121456868ed6f49f22a63670ee9a7500fff3dfb06359300cc44c03f110b11589510ff3164af72d7bfe44545004a9752edac70a6af212eb71aac627dd2c7b55f3995969ff0c34bc0a9143f323e6e8bb973f57cfb6f3759deef44c4f3d7aabf4d98420573176ea4590f191c41a0b12f3ece7cb524bd63c9047e6976211bffbca6744795fdbd585fdd352727e7dc6a269d062d2e2edfe0e44a60dde1e8299c69a4ab189afff52ab064430ed66635aa55411093b6f77a5ff8fa328a33300078f62d1b0b4ee7411096b76d5b39a3f7719557296db0c9a2286f5593e8f6da66aa68b75185ab30ad171d46605473bdcfcc184a9c2067c88d07073554deec8722b4b6420739f3f2c26808eccbb5effa3b091fb7e0acb874d6c6e2163e31a0c5058914cad7f244980c63d86a08c309b912c597c8bebab9dadd242d5038e5a962a7852fec6e166eaf9b4a91c002eab506c430042c0c7b5e4f4eb2ebe8ce23e1dd7902a334affb05c49c906007d41211d4c8b5991f35509396cdb58211154b5d4307946005116e5a6e8deae53ab3ea49f7addf8ae45dd207ef5c8a2233ea14449ac5a350556f7c55fd2943a6af5e15170325b554544abe0cf00b1949e701b9d1111d1353c12ea9d253f2dd4816a48bf5b0c1b7f5710d3e00ff26ed26a82a636b76694c6eef7c53968e6eaa9f75c0d2d56c3828afcb4a2c4ee8d6ad1b58cbc9b17d337dff4ea64aa98f05777b1da796103e337b5df301b772e5c43e977e42b177dfbbe25e4c1ba3ad84b0de141dedf47512b582c3ab0325c376f279586a18ed0c2c7c92aeefa226b4e132b66fb69005f8119ce54029141aee4f67d4a44cb2950178e4239f9436a3933fbc6af583de0c0cb48ab535ab06799547d0c5d9314db17e5170a56b0a51a24e63f6e229d419007b241dac7bd532b24a84b0a0eb0fb7fbb509bcdc808809e316c1a710d8458ba635ed3ece9b5ebebe416f9b57fe3667a0fe63b8c85c57ffcc28161ae32d01e78e23d790529d5bdea415d0eeb9687ade81cc55a4e99803a7d2c8b89a7529c8e2fd32252ac4aec285e1339fa60deb0b91576a98c9df3d7e1c6a65df65592145621e141e742d9cbd13561e60edf47bd6cc7f9d332d7e479d373656a4625d7f8da745f1b93b23cacfe260cf57dd33e3d753f830e9292d4fd903292c9a4e7693379e2c5affd600b0fe22cf8808175f77fb8c673d6a286941df8435211bedafb7f53005b95b1e91279751731dbb08092c518b47403054d4cc1830d553bdbfc2d80a7931f4db52ab8b1e148d4612489908b65eba49a1399f9d84d55c200f16ef00f1e3fc5b61d7136d94c8b809fc9b8efdc5ce9c6032f8a51dce230e053f7536230d9b0a8c94fb62e2ea6459a7e93375736d06a8d07c06783ac2b4e4f713ab7b797c76195891a1e84bda2b83b7b87c24cbc019edb14f93cd5e832a9901b67fe8a64a8ec807a0d9991cb2c15b301fe7b5cb138a4a855996934da50ef0f8787a04430ce5ddce91d09cb9cb3392d43139a2140940ee67dd11e167085d2fde3aeec3130746af25581d7e3a0a428b6dec82c9903b97688131334aca3d2d2d2fd67cb934d23936fb6889099f052ed78c0569aa7a150ce555a508847e7b54dfe0aa3b674bff99e0e8c4866e8b6289ea976cfd75b82d8336624db8c5ddcb523db57028863471b6844f975dca3b4065eb63c41e11ace3f15e28ed1bc5940ed25b48e69f55ad6ad433af29b281a8b119141fd45cedd0407052d46b013509b0aa75c4fc8adefec1b0fe6df04deb719deaca24805fb9e8fb853dace81d8922536a4ab31f23cb4eab4b18e41ef42428b020b3436e36b061443b90ce47b7f6dfd975cd632527ff7f126559b7d75b33069018d9175498ab53045ea5b1c8e8696f6878b3d2d0a47fa47e92c51899307f2d51dfdc09e7d3abebc4ad36a108849117e45bd0891dd6a7df97cc0a408ebeb3e167ea5fb74da4680fd5072d8232b9aec34f4e07880d5a73a1b5c574a6777d168688a77010f0a440257b38bfdce29b70546f49f6605113ae2852d2921dad1bcc2a1d2da20b07de6089906af8345e3ed60e3845d50744d0827d17c13bc157178aa2c4171752db50f9b98259a27a182112956145a2ae1c88c2f44a1876bcbe2c2e2ef14076b8b91581823d95adc4fd2092b707d9bbf7ddad3df38cbb13a5b7df057398de7dd2a666cae5253d242c7892d6a036c8e2c4917d323c235e83a769a4b753e74df4588b5c9de6435e902b145dbc7cc5e18694e368b31d6dc9f645c9b1d2a7a5ecd200e5488cc67ce1f9e80da56ba03cf412b9da6430b887ac519ec107a0bec9bcf1f35903c2ebd4fa287e510733a7cb3a3700ec4b49830ec0a135f22387245a6a7f59796f2df401fefae71d0923895c89d4510862cd0189c4d776592fd126c9448fc548ae8701407e83cad8eddff5028cbec425406a789beb171e359737de0400a7f9d47839b6b325b08c104d25641c67a51d7cffab147682c7a40883ebeb43526c2da694d2d211c10d62cd2c502baf2bd2b4e0fa0992cb9bbb5f625d46acd2a085e5a613c970cd7aee0ea556a8c213ece68fa0a2cc5afd7b8aec51549a44a39497726fc78281c380232a26f589eaeab5f468668be80b24800364afd15da1ea28b5b7086848bd324dcdebeb640c8bcd06c3e5f0e50629002bed9510bb859cbdf8c65b59971f0fa562a521979ae810717b5e07828d7a2b9270e19f846b449685ee834764da1f3b894f013cd9f81d6c2e6f151e87d0b9f380cf3c1987cc06f1b8164bb3016b0433efeca243f83061ac7277d39b4303bfbe89c4684dad4b71e7196423b1355ce9f2829e4f67a6452359e561b8fd4e537dc686352a043272867f5357d0dbf452181fb656e7a3fb5b0f2364db37bd9e5b9f185e77f56f7521bcadc97fc9aaf38197de9c388e42faa49901eb091c83f7c950d7780aa57f06379f8c655b8e04140a9162ed76c183fe565886fb391f7af653e2529292931908074962766f91ed89ded77bf4f2c4ad8dd509a925bbaca963f176696954212fc1c15dfa3d86987273282fa4f82ffba622aade45b8f84a224531a92c3618ea2b59a83c57cc46b5fcfe557d562e86cddc86386319fce528d2cb4976005a6f9d9038da6c066cc296919de19510032a56699c97a6a1efff1fa7aadd18afc688d2e33f825562060118dc915b9712dc8a40effea81e876ce52eb0bd0b82cfabe38984f0f0301b79c99f3022f7804a9ffbbe269a688bcfeba7171655e83eaef548ba5f68df9982d1aa2b266f689cfd85374f45e49d4bdeb21fdcffb4f83d6fa347187c909bdfdf2f3fba72029970b36d125b19ecde7784533550cdd9807c858632484775740b624118fdeeb460b8239799e41ece83ccbc1c2c607cc9ad097e65f240f7316f69bd31b87930d889d55d26f0f9f159311395e0bfc64902c79c63e12787bd68174a8ca4c5f7a8e62db71ccfb60a82fea6229fb29c643c942e934ac56d7358a06886986110012488e79f811018e42645bb7efeb38d21e88681098d59ffce84909959f6e386dfdf3ab0a713e866b5b9b67bc2cd6a63d9863e09d984388f64531c9773b658ebd3ef3ddb03a999bd431066b96165803b7eea5881c0d889d48021df2f2aba961bc6f526c31917ea294efff2c61d0a26c0f7a277d6c8c40cdc77258770790106eaafd7e7e89f85ee912785a7c7998f20a3326c3e2297b7de392a080888d023d2b21482abf751c8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
