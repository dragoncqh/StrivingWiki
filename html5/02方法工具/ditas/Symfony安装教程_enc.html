<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8fd8bf53ade18e3a9442c23246c4734ecb3c374e47760b241a2816759259c8ef64c92ee50caa534fbf22dc17f00243cca20d721ae14f573ff56747f00d6eb9f1c3f2bad1c262ee4c266f08c85e34d8b00a079819c25b02b92856827f62239eeb28ac56380c54fcd94a1e1d93d097aa11386cac706debb1efa8945f77b42ea740f36391b35c9f08adbc02e16588a193048547033dfd5c91db80d50c3d4adaac965817fa15925eebb8b6a7fac5e8990f44b368e941a0c93a10d5bb5f12863365091f2007a7e2dd98ceb14bcfa84a4179d046a0cfd22229e82a5a30c23b3e9153398aa984cddba8391a92deb24c226e8b70b9f151ae381d83d98259cd25f7e214990b67b5ee698ffebb211ce21c1bb0b50d3c67836fbb9c55be6b53105a338ca7e4cc91d5e587218b849369e42bfbec60ba95841f41914e01ad1ff67e7e2b4fd5bcfcbd5bc499cfb917ae0e96d811a8f9bc43aa3cf9875b236b03cb8d7514650dea89e8b4774a4645dbf5509e7496e38994adb2669333649bfdd4826de5ed095e2da3615ad970490272c64942068b842283c0d9c6fbb1890b7d7d043f80aca1bb368545ee4e34564d24fbd6854cafbab1bf9401e6065d70a4b72a30155a402d4d51b4dbf329e9c98b909d5474e8a4d4bc82e9236b6597399d042c99d04953bda6af45669ae9082e5233ca55ec50ad3d5ec1e39038f13456f48073a850a18b6412f2605dd58e3e51e27dea3332142b5f66d8665a0bb00a6d7f8d3d298ed755d140a543d766d8a2a7ae0c7d72a1a3cd5fc49e7b9426116ac75645b586ec24b344ff61ef7fd0bde7da9b10e0a1aabd2f626830baa2b2be484efcd90460c9ee532768d364f44fa15c54eac20f7ffce96ab975fb551ad10e6bed69c3871f8a4200fcc949cba644d019cbd1e7303808cd1863ce6ca0038e98c83a08789af0638b1c5523d5e3a7e06e17bb4bc6140eb2708929714233f5203618df9cb8cc49b17a2115146077b3455035c57f347568d535c0e4cc64abff1a8633ee0f00e15faa51a4852897c6c728f097d936bb27b3cdf42fea6a76589db2c03255a8f8df0cefb62dbddc82f5f93c42eba48ceb234a849036898ad12d39dee084c803146a5052dadda23c1e74faca5ea8effc4552ade6743c8d9873e94e2034f42a6097fa61923019c4929dd761d114d4c011bae3907ff9ae728c8aa058c0d5550b72c487799f961048e1b0f1828ce1f716806e1ea4cfa9c492aad9d350bd8d7139b687e67bf0aa0be83a4b0f654e7beb997ef2457a6b7a9d6d6171a9dbfe0a704a1195c80a700c3735754897b9cb68d9bd1e088a9c5a9717c01df8d0426e5c34832b29c5c85550f350f71d44882bfc16454f16a6dd59fac81d8859c4687823c1ae666ca64227d0f7c76fd525ed350739ca5904baac5f87b360505c796aaf84d228b35d12ff58ad9bd03be2288af0dad187a8085b13bd82251222c20eef69c4fdf9f921680a62ed8ad9a1306e80d8ea9d0b3a29d9f943eff5c55ceeccec52b38ee7f3fb053b4852fc1e9d1488ae5d6d301ef9e65ef2c886142cd4f9f83c47aec5db7e3b7422f0a89cc1805e0e4547f8eed4f86026bf164783d6e15920c2bf89602906d33f8e64c13c766e51d44034cd9c07890554699fa42f8de53e5b61567ac6ff5b270f2e22a0bdadae81a91ea00ca9372f71d3c004f37ee94483c2b355302dc3c52be0a60cd59a2fc142c30fa2b1b2c370891c82a2b5eb9eee75adb4a5a986c8924d8f4cba05c4b996abf4dca7986deb1a39f4d665ddeeb9dfaac9dc5502a781d46023c852fd5bcb2a90ab889f40f5fd6c3d2a910d70248df076dca3f9f6283d45035448c7849cd4034c4e2844ec90f393099f0f65dae0c34a39cf3ae52eec9f148aef680418e431d3135e3c974eb1c82106e3b8ec086c4a7383c3b83aa318ff5ce2975b2d978882d37dd0aafa6c61733e2db525668684677288d3a6735dd7fed1f70eda941424eaffab82b40b0df32cfa99d7578b062b365752c22ac7e9c110196303d791eb6f0d14048beab648ecbbdf1a88a8d48051fac8f170f0a56537a7dc7d19a0e1bfc9a7d7d6ff4967b84c31623f4bd4166a69b1eef7b3d7928552d9dd9383a0ec1b2eabc8a43a418c6417ec44a0c5e85e057b2c1f7d92d0cccd50649d9f80ef82203ec088271c38668f41a50e8b97fff153c519f40d260fe611ba8046d0e7ee904e4a73f40e9f29ea43fd58ef1a413f7e99c0355bd23674bae0bc1e86a617b25b59806f9b4a2dab169c0ac27b37367fedc5e9a902a25227b3286122667c8f7ed44dba10e668e184f0ed6956a586717519f7c145285612d50097dc3c4433cac72acfee8164629ccb6ff8b53d5947c841a1144e6ef3ecba8544bef266300371728b4b4af26fa74f7bc505645f59f371372d62e49f4a8776943da26b72cfbef746ea13248ebe512868e3f39aa22c9155ab131e7498f2350f1714a69f1c5131c8f78fb66dfdd24a153ee9d6b042eb0ce590fc8ff488d57b158d0be400b9678e45cfa16bde13ee87d273c19a87ebd40191318d29dcbdaf33b5ad5987f1a51e0f67d9a53637a7f514aa5efd91be6d00403b98ba83e5d7a58f139ddab54e96a45b9af75bbcbe87815461dfc5d96f40a91c6dbb31a0d42f765e9d5f3b788961ec9f7e8e9334b8a2b55883179d858e7243fb42af8ab05fe8ef8f04245eb55dee96919fe45d52147b3c85b0a4604c4fe03ac2802bffa53944e8a7cccb1a29d42fba3e2711200af038818b3e48fb47129711e7e96ed4af45d966f56103dbe5313d7366e26e74927e8c1ec5fbeb0f756084ad22e61c1c3d3224cb1b1365849c91fc5e0c93a8d112f0d4e082ab846ead3605fa79b71572b34c29b6699e65db4e53426ea8bc95631bc60bf0bccacc706daf50cb1664ea456aa47c0d8d5163cd77860499c88cd28a2ab8f0f67d30c1018f6fd8ce27b5cd683e4ab2affeee74c0e3ff72530602b4d66c01d8115c4e407640f6628aa7d89f4630ced4c87350859692346bbd92c25e9b2a3f82271a8ed0824c8ef4cb9e0d5e3fdb46df388ac5a6eba87a8e06f5aefb5b5e8fd06f3cdb1e5e8075efb210565b8b2d64a680c4267f87b53be4307e2043aa5dc29a6cef24d606e22c36d9dd1376f71d383876aad5cbafd70ee27d7ffe2c9440a5347d4fecca6fd8db0362118cc2cb4c12befc5289a53242f55456f987e18c9e520c205aa1e759853c82721224f0b958826af680f0675bc71b0768f0a77b6cbf0f50854ea0bb980e6b6ebbc8bf584c656013f6dfb669650290cd12ea2aaf3915580cf1bae9a393931e3a961251056ad46e2c4e278d0576a03a5242323ace23aa4a7c0d85c34ba6249c62c8469845964c490c8d1f739582c71cc9d5fc306d0d643ae102940d04c7fa84e5faf7856d74af89b941eb987da2f3e5668f3f437f4a9cfdeedeccaf1380dc70c4dcbf325559f7a1c109e7a7a8915e39901bad3b1da5514fc0f54137cbe2e7f8d239c02b0a29b82f17f9dce4665ad5410c3bf527904813591d0b7b0bc464f2afd87f0a0f33a73a42d8eaa1c6bbb511b16d1b7b4313978f9afcc1b8aeb8b06f99369bcfb2b9e5bdb452e3163c02849bc9268a7e2ac7be1b8cbfe0c59d297f25f38c5fed399637e1651e896f4dd5a32042f61bb90b0859af3a4f5e7ae70c8171969956c51d6ff9dcab4689384673e1625e447468a35efd54a8e98ca396cd83b773a5041f2bf75f2668bd7541916b8225caa60ad2eeb145a59046a3f3f28b8409b4631ce038199eedfb2363bc9f36e240de83473abc9c35aee16c17bcbe5827122a93a56dbba9dd9284bbbbd28adcd9584eacac0103cfe8cafe5be615e9dc449a0230575e5b38e4425f6cb87d20e2a0b39be820561b9f3522a26967d8a2e109371eeb6e2ad314dafcf4e2ae6bf8d66a52c4549d2f1724a65bbf08915a265fd48a7f7501f4047ab01f33d2b55f625bd60876898f83ab05ec4a929c788d405d7324eb57848d2ad4d7e5f1a2a0f6f35320f2d02e9e052fb421848525da6d295a6adf15cd47931af3e846ab72282d4fc2fb6c129aa81402757ab929771a016eff9f762c310242f71322536b153fed104aa9947453623a3e9814fe2ca7a693fb49ad67d62e1d59407825cae256527186914628ac9767e3db386cc23927048a1abf25cbb5cbf548d56c8cf263b433134c3be8475ad6d4b24c01c7839458439c4ba6f427925d5a4d5b770952b4b912a376733b5d0301edf234208ab5d48f40d6fbc668542990970c2ba2092f035ed8d882de459adedabcdc4973c9aac2407c4542053345c4d0019ee19cabac153fafe7eef7011086f5f2e4418b34598e1eda69068238265f4358a113bf782a59804bb5878ef40ae06aaa67356732383158af4984e68c5e96fc790639349ec5af5068257e9d71a6dc0c139cfc8c6075e6169352ca52809ded45b10fac8cbf3329267cdc566fd519aae7513a5716d37398930b4effb09fabe7ba45ff2af07f2f7a986e32dd8ec5dea7efe122e188f8a5bba16424d1f6f14a98c28366101300c7385e24f2c585476587e307d67795626d7e0efcd64282d4f569f4f49df634153d859d709c47db4e3e6cb11600606fd2d87d9e44283a061d605281e9f70fa642f3a3880af361554041cc755d7d9e03cd22d6abaa3844bb47755d630daa17a09c1dc52559adc0e4b828cb89bab99dbd8449f05bc5a2ee319bbd29bea1f18cc74983d8b710a61d9ba05b1df483fbecb9da016773034eb5bb6e9ff5d09d71648d799294745bef1f9ea8af30abd0a1a649db245ec15fd8ac4342ad76eb4ba840431b986d85140acb93dc8e575ffa454c2249795effcc10bc5e978f8414b01c55e3662503c2736d1057762fd1e897fe801a29b57d2c2a404610fb38d8d71d909c63799bd59ce45543c3a25086adae336f3d899e92c75dbef03163b70c52c2c566957fa8391d29fb3d07bae343b1fbdd918f0f827a356b0bc786f6b8d8d08a8747b5a9ee9cf1f339b5f30d13ba453b78dec4ff21fbcaefa65c95efc3de385e5cb1d6e1e02b053cee0cbeb545b9cff0f2b46e31dcc559bb295c26fc59917a0f590da567230b41f68f4f87cf4d1b3e262834c4cd5ed7473d70a3fd068d8f881022b4519e4ca8cd86395f1706307f374e467eba1262f2fb73762818538471c48b7cc85f9faefbaccc54d72c09ea279f7e1350786e09ca5fb260ddb7ae4c4f753ec881e9d296374201f97b1adda8d654a7e54f370c1ef3ff71f1f807f2ce49e3f9463df34eb41b19f01f23862b47c5bb9cb26cf40352b49853f071438172ddd493f89773d60ee085e3a9872f77fbb8033446b582643a2266c6b7e16eb607abbd8aa9e3ffdce69d462eeaf98bfe00ec49ee780c97737266a43d2b73185ed0c22a5305b467b0555a078873a2737f58d699ef18a489375c77b5f0ff7d2124475fc98ad72cadfc0a19fd41b2e787ce4c2b111f5db0efba30ea0cd0b1014759c35f4840f88fe41c1e0548fd5378bf222d0ff70389987ce81092b6caee812a5e74b28f5c5daaf0f97d24028fa61e65ddc44e478c49e6b6e47463a96cd2b4fc51f59f20e9d635bbd64f6123c20f596777fbb9b8ebaee3676ead66958d90b4810daae8a50918fa8ee5b276586f7559ff880e09205e6b8adafc96b6dd02932b52c47573392bffb5aa10de28c4b25272ad157fac86bebba8f04f3635d20e17b04ed00c78982eba5bfd1870ab2ca9b5314e6e428131917219e0c3a0648a190bf9b8773e95857589a7123ab5d60738d14805568685eae3e6d0f529f339a607872fe1d0f5860fb8d9a4b726ae570abde573aeec259b08adbbe3b9eda52ebbaa77ebdf1a9552f0dd3f6bf1d90d4fb0cad36f1d875e1ab535802ea7c5fa41f4c4578436b4462bb46ceeea3254706bc57de813f9f7ce0ee89c5d56c80b5b5fc3d1ab8d3e733155063cf66caefb144d6a264d6eaf596d0604f90ffe4281efc3674ef7a5ca531adad06537ea650f12fd4ce093b4c66ba5e26a988af552fd2bbee11db992d708b8c10c93bea8712cc6329f00bab47637eaac4de5b2e7a9394f00e86e4e41e9a7401470e6e644ecea57771c3bd8fce5c5365670eb1ad1a9a5b4868b658a1a98ba05ec9bd4934e5eab8bbda5ad2198acb3d2ba7559ca94cb284d8e26615d0187cbd4d613d66ab65409d938e63b3e731c974e704e6cecbcab2cf92c7c39c6b8e6e52f4545fe7d99ae8f04920e107f3cb88bf9a90fa12c5c745b88b327b67c1b011b6210257ecacaee6eb926eb949f6fa9afd1b438924c77ff95ea714f25cfcbc4f17700f5b97cc40697689548f39a824cb1e32b9ee11f7fefb698a3510e176aaf81caccb39e8018704000d5167c3649db3f7e96449657434251be440f9cfe617b8bd027ec3983624365624bfa4e85592c8ff2298898bda7c9b790dd2637a660f9641dd4519c1476d771f3e6a9f4cec18e355f6479f2aefa49b270712a16f4f4373e18d2bb569cd05cb6745007754d79d55ca2f59663edc059f44d78e2fa988f70ffd0de14235e9669ae69b6dd3c949960e84b76171ef14f6741ff4217d80801a29aed661abb8f72bac3ba45178c8eed7a6521686b895e299362fd3a52e2015881d06714ff026e5fcd62259375da14e019916253de4edd0d3185c3f7a4b027a4f4f226ab1661af2fc3e19e7b985ea4e03c576eeeac44c8141ec71cd66bee1e9ece72a3ed8422d4fd65e8fa6918b6bda71dbbb92f938b3d2abd06c019ac216b98b2d10dac4084a71f30ec98f407dca984f6d54d658ffbbd2560035097d929566d325732ecdcb4e19928ceff3a89b91e7446271d81552db328cfaefeac98596f6cb00aabe48fefd9d94975e2717d006981c8bbc13eb0e94328dbee54815975443e2c7f5d09fb796d9f5a8a1e0b52988c0056cf33b0af147786cca36152dec70e504635aa07ab09f87cf8eafe9d328fdc3a3ea2e0fc96e4ae91cf34501faea0e80adb550e82624474ef44f25e9fef93ecb703499e3fa53b32f41799f5230d429052fb75d780b5025640e0ea8c830852288251b7789ea7ea6712caeb4f29797ece21eb6f2d53684abca9fb900bd1c42daca23e5198c7efa1fb739c49bb92a65fd6759dca6bfa8c05b3ec12160f70953304ece4213322e1c1082c3f27b87d90aabffefdb1b2b8e24450ec09d3c136879b8a5cb011c5d1deafced2172b85152605dbbd591212ae833226a1b0fc5c2d9fd4f7317ec11d914c6a5cc708df988078ae30cca52b27dfd14393478771136c249f57050dd7a629abda6f32b1edc8a6ca6475840fac576a529119dce746203a95ac7b91b7cc1ccc20af6a8a6ee109b490f3a752ac600aadf1abc0e88b78db9ce4f39d91c1903f341897c7a1eeb1e7284285bef18b28980e1c70145c1ccb4d2a9e8fbb2cfd42b49da2574efc4e78622e9e5e70ee46b309fa8e62e668099a3a5ebc1d62da1bfca28c6311f30c92d7215dbb6fc95a29bdf57746c7380048169cae99329963653129139bbfb342b689637832d1ffcc4b8d85e48c5f61af5ff98f483ec59a6d88b9f2fd150109f29ad74735279b3d419957b7899ce88e411b803d8b73cc3449faf8465bd35d8443c46dad30057e4af60558c508f15ad407238e981baba7fd7931812224412a88a9d0c42fd88162f2d684f07605e4c652cca32f99c537bf3bdffea9c6586804a27f2079542a7945661a827903eabbc5a7317d3231862b13c87784b77d2b9ace42c2a452ca219d6947b81271342941804594520c39e839f5c221e1183232ac4bcb631b2e94cbdf8aa56a738560822c14d5c1046e4e0bbbb8775f2634a0731a3908da07ca0296be49a25d99e4652e5628bae2d96b5ed08368703102299d8b36401065690f160b27aae4f5830a76d91e4d89420d0f948223ac2af1d2f274625ebb0f2ba12b59529c0ef0eecfa5a3154c01ca94dce642d0f95ec1736f09d6a6dc746c4cd2e679540c142c0b8e69fd675a747f03f6fe9b2d784f5930caf364f9f7dc2f577b8b46410b726af89fb99e4f3a130d2c5e4033a44a4c1f393e93d61b8ae2ab8db0b4193e5c03712d7e3efb4830982e68c4f1878847228ac191cade64e7fcad9e5533d261884ff4628f7a912d833a5eeed4970aabf51251c6d43bf494610c1dba441b71418c7fc47e7f9a848b55810dce63b792822b81ad5e000d522f64744c334bfacf25c347078d51be2a1967967aa1a909623fd67e6b455c4784dcadd8f18fca3322ccb6ff22dda33126665699ec10972a5c2a7b06948da3ae931da282fb75988725c9bf9a4968f8a839820096b031e5108b3b9d7e201e2438e82df4fb961399791c93c3458c593ff5f5862264991e7948337ef00c4089dbfee9c8ad3105a28041981da83496db75a3af8f0c83d3d857bf49b1f5910e663f01f8bd296c0de62fc6af79a3a61a1326b1848f7ac26cd6cb9b3e3b7d4e5e089d63da9badf84476b8f583b835a721999c0d49dc3095d6f1362724c293fdf1e4776e8fe29a6e7274f85719ec057da50e11248e46a9e80dd7252dc4b761cccd8ef0cbb82aaee81f10d5d806eab9ec196817bf5b2c5e04a21ba20049acd413cb0d5a0200dab0ab25830bffe73cf992e78cce13d56c7a764b3e0faa217b3e4849e59d07b7d33922ac20cc879311745495c36f5c20f3b6e18a0ec3837a00d96d301f64effb20a8538ae468e2497dbdaa83cf11922573e2b324abfa72ffb6c1d630e3b60e9d10c7a5d32f2a56b12ceb81ad58c2c6d03ab2b6a98b4aaab7b0d647b5592c5cfa0b03cf8e18490a943ebe3e0d0ec54ae42adb6aa997b1932f134407e8a82cfad63cb6e70fb17f6a01b63491d91ace2da9fa0221d00d9b1f078ed5052f8f5b20d31d492f01c87d1dfe08821ac115831d5ef95f31d233df372df589b43646c70b076aa20481cd2456797304c8d5e7af740eefd44926f7898147f78790994f65e29009e40a34331431c558e0e4affff4771bc900a4881429c020a36b6bfbd7635f54158e60c28cba685cdc9eced499615aaee22a0e58073e1612e00a70c7da7748c7fcdcb2b6f1255f4ba850edad536b23fb38ee524a5f92f12123ca2b76936533fa444e90c48f8c86da112e4424386f8a36195f45e281dc83f779023c37c05093c837aa0fe589a99dc1e51d5a9d4dd17534eb4ae83809d3c364e9414ddccea5ba5514301b14e580ed16b2345b4d7606665f073827a75f1fdf8bdb696e59cacd1922d21a6064d465da6a603e727db28c1e558f97aa2532d064d1b461215dfefb556d9e43fe946112a3928b356da71c5c6ebc5cd2f53dd214b4498a21abb105edcb00b28f675bdd8a6c3d3048a5d7cb5f376d8419d8aaa76105cb3b2e22a6462654eb3fec3ebd1fda58ce8dc82ed227a002afb3ec4f23c3b48781f89cd6ae5feb38a9a55ade897dfa8f21cfc630949551099238f22f71ee67f2e2d02480518898084993bca72d407924ff7a157f93f3303f9910615602fdbed989f384d98de345ab84861ce231123bb3685d4a313eeffacc5060be58c6377d26bc4154e7f16de1361288e2c7e7bdc6b0cc63a98bd32d29563144743f1508f4e5c432e553c53db1e82ba3f2e09184e3f074b5625392b6831d60ad8808408419de3c646a21dfeabb0da0f2c6785633afd4c50957f8299d88d56c2fe87085b0a8148d3f45cb41c5abeecf03bee8fdd13a615ae53c18393a30b3c4247155eba7832ce0d1d05bbef8dc0d0a63c04ee69520c869e0d3d60c6efad9006fdd82dfe6d3bdaa90718ebadca83e322316c195b8598ddace138c14ac3cf0406d2395f44d0cdaad1cb52f6ca66c93a8a9ec0c6e6d75ef2b0aa58540838a4f2b948f19ec080f04b8b2bf71dcc201d3d6cf65978f79cd20f6c040630bf22b01081e7f871a9e6e49cda55fa7acf2401706fef65f311136f797c75d40c70274c396f38be5d668cffbffcf4db5caa13ab5f75fb2a2a7511a49ccfdfeb332366f40a6d9db03174907dd7a8a3eeb634734a3e87b124cf19ccb37e780368344ec5a77308e669dab26507303bbc64ebbec244cb62c34c5df43187bf9d53853b7a93df3917d115a9fa594102466666aa61f5d6ca943327470eb6e1470be7a5d45c835bf463e9fed9ae426239a956e42531948494c2deabe02273d662c9e9069d349a8496303be6316ba0cb0ac58e0c519199a39557ef7bcc60e5442a6ee235710e8f9cb914ba8a4a36900869f1f5602b09320df7fae0c9b759836d18f29c8d6a5df16fb74d8ee7da8ef62c70b26ed9fcb79cf69d79d0e679493d0c03afd8e86adf7f048cc5078c3d015b6fc6d273a54f0d9c48bb7b1324738179b86ee92ffc29de37ac1b2e675e2e4143b8f89f08dda225bdd526e8d0ef339fd652fef618b57ae8b700254163d9b5095a372006323a6956128ef1b7f9005ed635fd40c7e7414a0168c8c8bc4c37318ec407f3cffa4cca19a226c46a2babbd31f218daa5ba14a9087a7e36d3bf76767fc5e3977ba3a853ae1ce93b1180c7f867470d536ec435a26b4e36438c78e5252f0f3f14fa03983ae2e9db33647f8c40e4239997b54bcd438c00c781441032869ead7290ff2fb4f962b11bf35f3d69370daca922cf2bc9d2520ea1b4a10c32aeecd751f9c4995c105091957f0d9959e77676f9a6ed38df13f8bd00e8713cea977f4d028bc30d67b1f9b7a99777fd69bf45b34522353dcd1f6417ec4284e35fd5deb950e21a386d0805fc22da93190cfc69874a5146024eb2e94a53b516bf6c2b0a87b7ade2075bc2ae66756e55c423c8680cadb589f8c4d674bda0578de11f8ab9d0204c15a16432d4704e9b02d5724dbc388005b20a2396d19b919bd66a1e5e55f6d9be6606dd6651697c237a6c7767bd06221ad56627ce189f0775ab7087258069d617060fa62cef0b3d8823e8fa129fe00c7ba23160341aec3ad09036f2bd36ef08526c69cf2a21060380cc9f2ab87163364b2be976ea5e45d1c1aa1e5804828b9b64c45adf5771c4979f41cc6d20ba4b02fa7fc5e7b4512caf290fedea89919961d86f0a5b761d799ea0f4a0755360dc961c5221d972bfbf5a270d03578fc8b56e699f47ec15ac23fbb87fc84f2e0485ad17d17bf028ecc721f04dd9c62f6a56397ad6244ed7b399f7ec626cee99ceef8a8c1e07dd3a985c837de77b114536107e07710f3a1232bdbc8103f2f4d7f548817882c08395672c29981003e48b6c7f3056d3105742f2f02712f98a9dcb8ab84ce93185fd732c6b63ea43802e8ef0e925341340770912601d7ab215c5018151e7f058aa23e5054760ca49159645c87e6a9acc4aa8fe746fb28ded62a97e268343ccddfaae778f72902e693ce85e2df511dfd481643824314c4ee5f4b13daa0e9673137fa240f1a5fb36137996c39860d982360af1789908c9b8f48b1bce042f44f2c6611221037860fc7ab01375d1a92d5cc0b4ab056565559d82a9b75155c67585920b6d706b90671cfb575e994d62f2eb67387b68e64810b91589923e32506b2c32ebcbf592daf901fe7d0534c747b5d4f3eac9647d69a9ee909206c705cae4806556be47f10c4fb3cbeb0ef9e873c27bdede4caa00a287466f440657364a41a1ad3016f26eeef7e6f7d7c9246d2c430e3eb5f915636bc98d04ba8b51fb603ea74d9ab7b86dc4c7e0a86fcccfc8af3d6ec5004cb6c60097971503de8e15097376f1ab0ebd38173292d8d619b1b3015c8135b0a9cfb447cd160eb837693e883cdd7117357d0ebd355c3941cbe60ca090cbf41f7743e31576e4f4362dd0f9455d3c3b5cfb97fb0af6c678459ecbc4615d8dc8d3820b1971d153960ba456cd3f82e2bf06934ed310865e047914e6dea5f3eafbfa286a239417206afd97af1a043f00249ac00fd0dd5e6ceab2cba9ab6f680b9cffeb01ef0f9c1866e8cc829fe19c2aabdccbc258cda96de9d2299d0b0366933d2dc130f7fd3745748ed3fe94d2474e195db26fa70c6e14dd8d602df4fb7d78f011a3a63657a5941a502ac9e873b5d0a23008c17c50ccc6777a952cd896734d5297701862d9e12f311f3eb55158ae0a18e95e54c95e58bb40228adbf03c2d5b42d9f15563d7bf89bbb8b96dce2c14530598f83a00d1caf0bcd08cb3fb88a2ecc5da9b5a05cf4b81377deff711513ea762ba4477740bd90c7b30323aad9ddeaba785cf3feccf7c944359838af9a774904787ec160d9ef76ae3edf56fbe4ad4e568acc10a8a70bc47034c1fca44eedfe0e2eb32d34becab28af9ab2926d8921e758b9e58cc32f3c366acaca0f8b408034490cd0b396c8c6345063ce3ed4fe4a76749141b9b3c53d602a1bbc50d8b98fd8aa142a09ee4f7c737580a29a92a99ab70912a72f7add4a539c3eaf56f9c162a5a242b1665ddc856424bcd84e6d2b83a9a872b33a36fb5909551bdc86dbe9a56436ec675521708bacfa90601121415b4f7a765979893dded73758ea5d2565cac0292fad21c1165d718499fc9d9ec9775924a4e5827b737ec9b0d9ed42354533bd5d81b4909cb912659a7fd2f3a1ed720a7f813479101d4a3cca86fa39860df0fb3b98d17c3b858ece29208072129b29e45f8d04633984b389c983ebfc04e1e9d0f3068e90c5c49398809c6d563c998ac9986b0c549463b1d859d23e55b23f41759aefbdcc6af12eb02e02961fcf40ed007776a3273b8e099152c5f9add8bced7ffb0d5ca85fc4381a87b697901f3960f88a164dadf0e4cc86946c7e1fad02a8e4de4d65c83458ff01f3d5270057fce236ae9d5e437ad95c40fd3172d6b8e04d6f34cd834a2ab890d7601ff4157524decefd06b778be52c726c5fe2dc136cdb94b6ffdea0ac9351d123bed0899d405d2d15f96276689430422a9aaec546234c689d953dc11acc670ad0565ecbf69e519e6c75ebf271a594195d925ef93445d8169be35cd3b7ede02e30245fe1ad07b2fcd6c624511f7c5c7dbb0bc4e18f8336326bd5996185c83e9140d627cf8cc35df97b169abc99ade701d5966a5ecc0f6d1e19375f4d1b1f09cd73a9313d576447ebd1811f0d148efd467b314c2e5132fad8507f0190908773662f146bc8f5ae8cf34c97954470a117556e96c8a5d71bca3c27f5ba966e453aefda6f4a938d41fee77e2d8c517fbb8b1b8c043cdc6c215f7053bf5dd861229c1b6c3cf53cb5663c4d9a88eb5b15102503a1da598c0d507336424403ab5f832aa7baf3244a8814c17a05c1e9998dd283a8129ce3b395d4251b2d3d9c208fe2b87ec11b3815ce4bce4e4e7c95761aae0fec58ad370438aa2f67b8b16bd89f5dddd7616cd5d89c8cd334e2c3adfec56a2026f7ad151de8b8decea7558ca3420c39667436adee6cc2a2e6a66707208b08857b69b5fb4d1dd1ab3c0e64633a49b4cb4a076b495772c4031f2f9f3e161b0839b4e802e24428ac2294c68cf5e9d56ce377097f306c78e9ce53b0a4a237946e4c60243ceaf7d5c54f58d71ebd8ba7ef0014a07481be8317eb595ad87227f4d07b377e24121d761948e1b501f15dbb6ad05141b5706f5af1aede8653b5a173d59650bedb3f377322871a01247bcfb08cf93b95ac4ce48b56061b2fe4c9a9f347f5c2aa352a30c0c008dfe8c8c84a60ef97f20b5c27a590fa7d27700f6a7c1396058767305f643f4166c792abbd74c5844a78f86d52ef4e84b635bbdece256f659f7b82c9d43a9f66b610d75a2bf9122ff3caf6b25e6a3669c1117993aba11100f95be8fc4e6d31fe98b8dba588a70b81782d0573ca9dc75185924e6e6f7917baaf66da7311918a8d0a7d68a05e6138d06f93a79096f68cf410517c17da8e9806fad832ac7751e40bd4301e73602d2d385178ee762fe85a6e0993e51c1afd6094aa0a249c3bfde883952d588bf62784ab159f50192b4ff42cbaf85a453c01afb46da1f2dcbc9494e0fed7237cae737582ffec8e1106b45cc0ad6bfd47f4659101a729c1d331f0beadaf23f5ff2526ba12faab6d63245950bb0655833ea794bd49cf1ab0026b74f427c79392d8b9ecbe604e8082c4dbc9ee7113d290cd1071feecbe056108a3aa58c8267473c7c87b598bfbc29a0411529bc8cc7778b937fd302eaa6f19137eadfa1e6919d8831c280a59ddcef7de431328bd61adf4d61475e004f56d21c0835587b08a767907019e0e4d72e92322010c062d783a72c33dc3dcfb0b9b32d3f4012c0c54654bfd90fd6dfc2b1bf96a0b158921cd29498dffd50c124efa81facab48530d7085c436c5d5919fb48427bc38242a2ad343c507da7e63ecd4e9c9c9a1cdd8c2355a5ff08ac1d70cae0d7e45700dec497f7d069bfa8b8ef953c670faead1f97431e2c8cce66a51e4df0d46658555784719d2014bf033774d7a4662f8ba50ea72a6558fc2ddf0c7488dd1d2df725d823e75980d15b2ad07f254bd95f6da57d675f3d7fc291325af915e893cc6bfc081858c3c69ea706b7570a40400100c0a1862cd4a1976c6e7d4551f54bd06741127f3f6885c844db852d3b17f478fdc7818aec8257dbc8289aeb7168fbd5d2b024252f49ed498da25a695e1fbc45ec585d942fee1d5a37d8dd3aa74059e534351fbbaa82864ebd7bb760c0c440bb4acb188b80d38cd28b886f0cdb8a68306bf880c22ac48c6213309faf819361a7e46ce96502818e6b3f9df60e5df33a02bdc8a01c33f4665456872e22d2b1615fbd6dde0a0f11ebe8f6d4c5f369217f6a334fc874ee8bf7a6ce07d12ed1f7b6f6efb2996fac0bbc250376b479e2fa93fa529b512d1a1423241eb52ea59ef1ac67f60ce4ce0dac6e19d2cd00a655d32d7984cc363e2ed94724f6acd6d00c50bd995b60d0033aea2dd12af076c92444ea483c55d73e9a5de53b591e0b33586be8aed4bf898a0aab83f0b0aeca6c9401467d740ab2fb5ff1bbea0077da3cf242506af29359ecb0cbab37e3c6ffec5288929d23f59fd0fbaaf12e1fd1cbfd1fc9644f6508d2a89846e7b2de9aea","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
