<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"be2fddd693e6ce0bb574371e70c2c15abb890339f6eebb300ee1e60c6489d866c06f1b652d407e89f1f12e6b49e2a4325105c8928282dc4ca80ed7b7cf4798c89aa5d42f7b2d916b64508e8f083a2c10718910baeb7f23678aa778d4c02437a58bf74bf92ff94b3379bbc62ee507de49e6498e4713eb96221f26bd5f55fab16995096c3d2826ad63218dcf7b7b0c476093634abcd42e42a145a3bb2bd54b957552c3761d6fe27b5f76aa33bf45ad6a1d59561d3698072b7db349591efb2dd422b8b6fc9ea0f28130628bab91bbf508f7d8f3f4cae4f8c6a75d6b48ddecfa58b6cf7dc22b3cba5b283afcdff70587dc7edaf7732dc6d2bd3ceeca926fad28eaa5804ab9107b39118d2508d38cb8d6f46613cdbaceb2baac183021a0fc35de8c7c9bd4992579ff98e357199763ed7ce59bc7b32591f7071cedb58c14d7bc9afc216e5e013b889dc2949792d7d45c7df4f61e46c9c7ea7e80c77e9ce968b9e1a576b4344d1b5414e65723b438a3904a282923ae53905a86ec59f05452698d97199f50bafe6e24ba340a9bb59e99112caf7c5505faf712a7db880e56da022148a8affe5e431e150351bd4979c29a525d0ab054cc100710094d8d8e3b19622a5151957899bc6a0c2a426eed6a1d86cf1519e2c78aaa9d2f7c0ef746718acf578cce901fc18b0093c61d663ea34ef41c99add4dd0a2a27d1b0573074178ecf6ec1108f0785bd9c734aff57049fb2d2ec7560beafdcef0d09d1a111c04f679b9ef6d430362551b12afaa7f341f0873a0e400449c4f3b03611469a1dd112cb884e23d553a4432f50b3c42cfbc9f883303d4c1c0600b3b875d2e4123321510688610345baab4bd1f81ba770f25be5f68416c34051d0a64dc66280e077d165d0b9da440560f270cd486d5b8d3ddaf182bbc611c065060451d3eb22c6b8020186d2acf1a25f9e1d60a773de01a21ae59e469f23ec70333ade2eb9ee88dae77c22bb80c19fe257acd87eea2c08aef5aee234c08e688988bf77d374da0893b3a27153d54ac2c45f5d254eaa3745ab8e4f0eae7ffa4eea2a6f73e00aa8282c78e728a8403735ffab83a61786331c1f84045fc152fa9f97892d1b2eeaf355533e500623c049ddddc7ab6f1d1c1eadcc69222a500e27b2b832f7b4e400a6b6958eb5b241d5fb3fb0c1d3967f3558ab260a304ab29d715159ea07937b13ad3498951f737ef5be273ffe10ca619a784f8e3e9bcf631aa65b66f570f826cf4406e4588788d0176051836510c683af588cd214a20a0cb6aaffddcf5233208546388104f9c45fff5cc1d016a397e9750af19ca3ecbe13721ab66ba7e1e0d02bb917a0e8146d0fb4d20294ae5aa9c1fd54c47970a48709a3b56041983bf7c54d9cec41f3bbc17024de65eee2ee142dfdafd900bc656bb83035b0bf04baa7f4f31ad0163220e7e7d0136f01a5bfcafd1506b7aa1fde31e9b5d26ae7ccda7e4a3eae59272f9065abcc85f063b65ac62d6ac136ab3b5067c0561165f95608ed9e5e67bef8185074d1618b37311b1b15a98486dc8b9698e3e18248f215ea140a31918db99eecfb3b1c8f9a5e50a6edcb061c6fdc634ac846f7cb06ccc9fe074673e753310b47f2f304837fb6790b81c2b9ea7bb187484a8bfb8e67769b40d00ac41033b82389b179f39a03e9b902031623c84c59cc5f039f8f910cb45d664b5c0a02c99e8625aa3585bebbca6b80a8f0c807cdbf02bc75d7f116946fa511dd753c745f5064e3f45ea7cdecdad1273b9ebd8cd2f8892f32e0e54c92715b8fc2c68ad1003bd9868cef344f134f541a666ce3591b8be8d548adbb61eae7f705d316f35732592cc3ce719053891cf767f38beeef60d6849181e85eb45a50b78e59e37d2195eac07081624b71c0205914250cea70a139381d142984fefade74a326eca3b80f72febeea24972a5636ba86bb44383d3efa29ab809bee394f3fd569cbab6d781eb2eef03be3798d5a5e30cc13c860790dc12c4cf84f75f820b2dd8b65610f9ce284949fe042f3b57c777827b8a76aacde1842240a7ee27b9bc6c45ca904d4620c6d93e2201f9cd25f3518ed30c778dad3bcec9900e9f9f57b192528cf46ac603b59bd2c307de20c357a6f45431ea9de327517aaf145f73dedc0bdc0f339242efa8d313c3642bea20ed69ea322214049bcd90b87b3a9922059d721b4b2ad2f6eba23825641c2fd369543e2ec01ee555beeec376ab61dfb59789542c25f58b2dee9d7c8a17edda802aeb4e4b24cc3e8efa12b61c00e2f3ff04615a4cfea11ef66b5a1a5646f11afed7851634131b0d74530a24f2ebb40dcb42b7de8ecd6d89070058171fee68fa10269f483b4eb68ebde063c7a2da3e7e3475a550c6c5d0429f23f10c60edb6ab29a7af44777c03563962a306be7c616a809efc7e52095b0122d9d14875f745884d4753f293b89889df6053c48beed1c5fa526b8879695656cfaaf1de0711f6d65ab26da171529f2d17b56ef37265fe0333484469b65101f3a01c81cc51d295a742c986a76b7960243f0b8eb7d58a8d9010fb102025e60d92d1c7d6af4d74051dbcd9652d147d0ba99ceef77b05bc737a03a290c7a15bdc820fab6b08e20c459180d79c88fadb63073cb21305a90e4b37dd2584582b87205e6bb4af63c2d638bb1922f814487ef4527f2f9948c3f8aa18629098765606aab2f3ecbf68cd10191025f3feffb9ff55b1572db84e92fc9ef505aa11f9fc402ff910d922641a25dee242e8b5a1eb857e3c0e6a7a6ddfd076be6e1e0099ae912ea551cc768a678e19087f412e84e8000188f024edee2229ff9017af204e0c48b3cf41309dc66253ff05b5ae89895291e73318f0bef130178ae06ad5b8e26955a013547574893f3b1a66a71ce1337aedc916a8857515318cb8e9658c2aa04ae16bf416f0e17f20c682a02a7e1d6735e2798bd01d922e52365a156a9d1fb73cde61afaed1505592223e75e1e22b0a3d5ed7e44d43f4dae82e35624d9c03f52563ae251f7417c610d7cd5125453894c46efd1f172b06c5039bacfe83636dea78e98f04a29e273d74a561917c38254b2591c96abd17cfda66a2a309b5be39957297ef0a1efccff90bf8e20b19f53aceacf42f73aa62a908b82bb89aea181167ee1eda73a3e601abf2606b9dcc9d46e5971564afec75557001dbc4fc51e5759f2c0fa3d6f1266dd59c127181e0920851446bbb54f0feebb72801b8c6bbf9c8d58a0c7cb0c8562497c41a4aab97088b2859ce967b3fffb2f03d20bc8198646306e5bf603eeb2492f46de23d885cb9aea71bc99e91ee061e52555026e6c4d410548410f9aa83e559e24d93118ef7b47b037a081914369649e71b7ca479a3e88058655b90d1c97275cb0d75112193ebc7aeb45cd4322de53358af577d14f0755a6baf2af61f7e03e2d6bda483ed851de53ff00cbb19e0df5b688696fed6d85e85e195b54d00968132e9bb3b0ae34d6ffd799a213966fbc0886c139989bfe9604593ce49a2f33960135146bfe8bd3bedb063a641abbe161a9c7f58d9139b5b9a93e3d2cd905124006586df170f6d86218f49e31cf1497fdf260cf3b7277fe2e1026d1698fc9f6203c8d9baf9cca7c880f0e15fb5a30949f95d565f5d75254875fe841e6dd4a22ccfb1f3eedc60a3fb1c140c34cb4b81196474ab904186e59c5888eb2a2d0c2d9ed6c9a1a93f824c22925bc3630896aa2bac6fd824ba1a045f14f2a23d1c165ba4acf9357e3a0217fe07799ca296485db005bb076f7d12fdca456e4ee42e8cd9e8c4031f69bc760f30f2c395272646d46798a47e38a1995063fa7e4ca5671f043b1df568a7b37759709a8eaf5c8024985631f5c171612a6b90092cd8846ab6f21b9509aa5ccfd7dcb7d9a11930e5bd61fd8f9eec398e8ba1d6417f82e57db7599fb646cb3363475403ab57308f6c162d92bcba259772dc824a298cb4861a022e61a56bf647669debc439f95ca1313a2adee6b87de45a023595de5f2b2ba677e7c8a4fee987af13c5b1278907ccc0d99a485f668551eec38ecd83a6141e5d7a6f8fc2823f505a8332b92cb742dc718b7c4cd78aa4eb5ab889b1c7128cbb43ad1627952cd1da156d72db785bc9ebccd3e073a770d9688a370c1affb9e668182d8e5722980e8fd855e95c720a0a7a6427ed44ad6798b5f9840ec415088919ead9e780bd5a1a30492c599080bd1e634873d44e363da109a5b40f5bf09871fd3fc6ed1c65ba1981099f1103f2c2d1ee1d1da0cceaf012d55bedb56a6c6719a71b1fb3f75577db325c7bf6cb699d46e827fd35b9b5ebaafcbf787068a8de70c53a1b9c95b067ffdb816fe48d68854e348e50d14014b98fd7ef850bb738f3021bbd74a6155ffc56dfbc1b5588beb586c29ec292cacf0c58a139439e4a8ceadc72fbf564384c6be29b3a2ba3069f6d2bea43923fa5cfd349f5184b2b4ec36f23de67d45c302a692313f46d8a94eb0110b12bd3036e058e8d83e417a480d14fe9aa3ca278a169380137aaf063c70b0948c0dbba2c0a4170ab6ce55529401ca1c84653eb3b6c0a8992e7365083b3bc348e8996942365e112982aa66c1b772976b5e602aeed53a54c2e84fbf54db1750c16187270e7c14042c1f13db89726154d6ab273409f5b1e81ffa563e1c62e67c701c21b90ecb9b9ee15719b4ad3d63e83a967601c826f7bc241b05014a89a0d264cc2445dab4af01919fad208898d27636e6335a2ea279322ec50e0a37b067425eb70f95e7962631554b2ce88a662fbb87406c8a9c4b3b1ea56551f1eb2cb2dd34c677b94ce93ca0b5149cbf322759963dce4484d2dad25785b542a911a2566e8a6ac9f170ce9a16e25ee894e0d1f9d1c56e752106c945e5eadfa9dd7f62ca89a4593573ce77635bd0d792d72b49fdcf16284b627f0473171216f3853be18544128bc6c5e94d7976fc2d3824de6e492b12d36a30bf9350728c3024de3b3a6817adcdfc92fafb3f921ccfdd7545c10f82a397e3eb9e00bac421d3ad5a8328d1e40e022213ddb2ce3a607e42ab116796697857d45e1ce9c1448035d6a73aad681e11246128d8e9cd552e527ffb58763aaf752fe64e7f7b5fdedecb6d9e8ee19b7f5a9c3e68f1ffd636229c7b0c734bc79fd1bb3bf2b7c09417059c837598f236655d39943fe4f3329054e8f07376e85a37168af3e9c0cc9d5d72f0ac521ea72b786d741829cbcfa21ed0ae2356048d176970c2d3c271e5bdee82762a607a0b927444c2c68654486f5b3179356097e0405bc35b8d83f1142b33d408bb296f554547bb9ee8999ec607d9f60b42459e02b832b68a0c611e656a527165f20a5b7faca1c5a96032031179bdcc4badeafdcc2d0c63cf2b4645df1e33b2464af6ed0285cae8a92f49d2b0800d9fdbaa694a6d50f480dec3bf9a9fef8846b79d9e29bcc8236e353a093d48f4e82b785dc64509a66583d47a75ac4cfcaadf549ba5e81ded06d8da2f4597718ffb8c1ca659dbbd4d7f5d283fb1530ecbc5cd0aa566a58effa7e055116024e0b0bf540accf37f03379a4407f5f90d73222c68719acfc0058161502b8ec6648b379173d6988f0eec96d4ee7c39d3eb89a796d0118ed265a6ffbf0beb7785084e5c5e0440739d4dcee099b8dd3478593e8a4ecc267be2902c7d9c21d5e711cfb8c6d9c172e8f7606c393ea1d5bbeb1c8974513ff195b5014c6eaba6d2103c06964da7e9872b4e771d7eaac43215bdbdd137358e896f9112e84c82f4fae8778c07f05a51f791b45d25ab0b40ed7b51d5dc4808bc8da70906e9b8efb4094da0c12046e3a1328f3c74f5397d08a8dfc7f8eb7eeddf00026efe80bd6370a93ec588cf659937af7e2bd5da7907c29be0aa419e93e276ecd7650eb32147b893522c503843af1a396e3dd37a667e2f8e6cf8aed8055e8635632d924c7aac1bd1f5eb3f9ad1be020b8fd4b22ca5f8b879ffd97b9c0b1a3430f9085b1acad6ab4700497b3cf0f1e94c8e50c0bd31c399b15f97a336f9c4c30ca4ce7cade0a51fa00e1e931c23cd09cf68016306e2f486a1b7da55f4c9567071c15d2515017e52410af7f56bb7ae3968c68d86b73c805be2d85936886776fbd589d65393e6f903034c50fa6beb5b4a97e730b9f6ef923784343222ab1e3baf52acaf66be57a712bb93392130778eacfcecf12b9cb8f0ce88132ac9607fcec0cdb9ce7f65d0c10a461a86fe356a359e074eec1cd3a02f4a8f218e3d7d26686b2b1f94ddc8f4ca3e690c4dabd15a7ef766a825093dd6def58bee4d6bc06808917606eeb6e15c337a2d9dc18557e75429aaa5d0049b7f3c305a03ca0c13fe3bf0c3de1ce8f339dd994a017706c896dfb6312c0a77a0b873385b6f8442a396b6452d8e1cf7a4eff400fdafd0b9b4be003faf60e4e1056dd5c05a3b25e8066eda3923d5f1f0a589cc75e1f957af2549675c9db0545a2bae443782f18a972a41fdbbd51833285215aac7515144645a2936b9bee44ce527d5180985dccae9f3dd9c0f4c18abf7590394cbe6541938362fcfc668a36a96ea65d158a7658ce502d64d5bb792a8d93a400cd462c603065578f30e8347a84fa36c7a89bc8bcb54158a71fd231c894321bb0e51d4ea32bf697bc45fee5eaf0de880d8c8b740e5781350c736d7a8ee90624272c27a78008e72791857756210b15feff113f834398da415eb1e3dd7891cab3a5b5cd5e9fda15de4e3813c6f8d59de0e8bac2941f22284e2bcd3fc6ee6a81c7cccdc482c9ac27b09b654e3e53aaa57379480371234488477b90a2234fe8b4ed79632bc49bed8d4373de6a779e53e3e883db42bca8f54e8fc7e89d45a383c9b068b7b88304f56cbce037e791dbf56a02794a4cf773aa6e15e0df12052d4c8478bccb55eb8e4086dced2548ae5aeddabfc30bb5492be0aa4f731b1be25fa1b08ebc695bf0cd02ba14227df97c3ee2d1d84fdc6e92d65b306bd1ef6f8e70fa49041339cd212ec5450b8c4a9bcf9d42f629415ea749178f6ae9c11324179335868b6429e2acef5867fab14a0c5f5a008976cf4d2f6ff21492805d4227bbac40ccaf4f272dd8f0138edbbec24294908d75ef25f54864aa43cd130d9128682f6789ecc63f9e2da55c0996a2b8c3d67fc9f03933b15489bc0ba2a896e0b68ca9124e8e7121c5b4056c44cb0aa491eba8f8e99bdab6f0bd0b07d29e26a4b06cbd92e9133d7133fd33e93926a05d7a2f7a034ef72b776496735a5c67bb34cc502e4705ae16cf86a5093b3061e2833c336e804e5d5f33df8a173d3c7e0bbcb61e79fc73ee627dd32a4b902123784e83497d33365e099a2c2bb0c07dee9d98672f8c7cdc709749da61527756bb49f186bf0cac4fd4ca7d023ea8aa3b5d62509d537e90e35c3c6ec55693a2d6b43d7741b779ab4e3053987fb784e2c3acde2a3ce327197eede3829e031efdd7e0d5a0b0db572eecb3845442040e5e630899db375498a194327673d20cc2482c9022e366d8b250151ff5b9f892478edfd650cc31eb31137348f6105c3df18b537b2282b6d0d71d12b8ef852faaf21dd092f14d9a80c10562188ebdcd1b9ae696c1bd26673381f956e2c10d4d0b8e06bc991c9285fb48c9fd1053d9f3036a9d9fb83d541b5612414a9aed1ef88188c04c7c2480c687834f499feab1d50fdfc522751809f4350d222273253048e36bd779ff502aa6641105b34d07c7921243fe031380f8112fda3079c5fb57e736de5a1b1386abba1220bb5777acb0135d88053ed5f4bbc584dd19678f8ef71674ad08e63989e7ac85b927688404152c74b3f04690883b2645371608024da5996f3e1e7abdeb2aab8fbd7b8723877fac6d91ed1ab4ff7f06ebf3aaf3cf4c64427d14879ea772eb5030d29a358554ac4de8bc3e5fc301bb9e46e27d62c08dd65165194575ef8eb3a193373132bc71e54b3cc4d3ac835d59dfa46590e966f9634b987b592378ba4817e79188b89421f6ca2f6bfedbae26e6c8ca9d657bd9e554f3888a892090f0e76f82e24a3407e00f0fc969532b31dbcf78c550cdbe1993e78c2764013305809e247a2f9053076d7db75c759ae15c318c6fe7c32c1dd3ac39eaff45e3491285582c23021aa3af710a542a56c11e5315bb21e09cdcdc2380f99c112a56c31c7a585c8dabd0241b1cae6fc148eae6389498bb5fc6b28ece9f7bc58b49cc1f40c2b3310258282462dd99621408f4262e68aa91b2e9c48851942c519e686f9676a4bf1179b27fdf1bb2a6e6be2ce184be1744b9ea3d25a96a3cc5f388e300d0bbe17a75487f0c0d3e0ce29b085fefafc57deb4c30dca711c5a2790975eaae037bbd0c0d7b0436481a8c00c63f8fbca3a08e972eb0d97c0a0a89550157d7f5048ba20cd85f774f4643208e94a0f10bb7e1b527a731f542b13384398500e26e8bb181f03fb754af6236e17145b0c417488dcd73eb0fa38b956d87f7b8e8f4d123e03e604635ecd2172b50e2f25ccf17d0556fd6045033651a6af5ef544145eee9186a3d865dd6081ff62902e7fd8648f765ed690b7ca9303e3600dd2ff3e7f9882a38914d46802b80e4bbd10848ddb3205550b4f34778e0ef2d73ad1dcde9ec731a0bf281809d05379bf2df6ea97ad6008c020479fc6741678ac36ceba0597980370989c69563e4bc3c5d0698ef0355ccd5083434ab378a1a62b943f019e235ffd171c358bd251b8d260421097eab38b83307b96bc24a48d793f59a4132664c5d30f70d8c685513aea81e3275963797adb86ed73df8b95bb6f22006c263edf56a4376dff854f8aa2e2ff575df9baf124b8b21594a713ac1f3fbfdf6dbc4fa65f4345a9979de755069efa608ee4506849e7ad06a58801b8608987a4b55a62a933e3c0da099a2490de0df32b6a472bf292b19cf6d62f73db056dcc8022c10388e546b7ab821ddac7dec3e9fd317e6cda2aa76240d8f1918e934ccb2ec3e4ab7b34906cd41e3eaf6142eed38b9adbf4be2835eac190f75fc4fe4e40febdec37c8b287933276b47076d0cba58becc520ce8398d60cf42ca1eb15f0cb517c5a93899a6e40e8a4282e1a88fc12658aecc61a81f60cac9f3108389c36c48009135dcdd5f2da81bc9a5921cdbe8b39489289449e56148f037d3a047fab6dfa06a260ae51382af5f7b2c4ac98c6cfee179925cb076a2dd6a15a5ca1d07366836be8c22091753613c08be0e054d4ded6269977f825efc5f8b894a32b63681d30db2fa4c7b2cf0e87815e2bb74669053ab5efe7ee2afd0ceccc5812b638a234540235d5fca884cd1c038e7c1b759bb7d9f30e79a3c50374713cf8228e28d2d5715d8aec250095c59faf575788c8e5251a45f26da11741a0f4b6d05eb1782a9188a8a2ba49651b3124a425f3386e4638cbb58e9730ce120f3b89fc4f5250b7c3fc7b5d79387f8593ac3505bac7c5e75acf1c9128754df442c737d5ffff72e3878a01a03f69c6bca81832d55bb1eb7d06452223e0a18aaa441800ac1b325c5ff9edebc1a851f18cd3b99fecc55da31030a1ff8674d49a5289082813316a7da497fe9858424638e4342cada3dfa2a0d1e11be807128a3f9f90958fe6a64fab7c08c14d67078a5259ec2f965a715015184e8fa8c42138279811aed7f75a6010c9ac24bacd8abba08c6ab5bb1d8838245a8156c0cc4a4e05809e4c74e4d6c9c2b31184edb252bf92bd733a78d763afcd01233be2cd82cae61992a787652cf3220dd8bff31e445e00d2f3f67b156613b91cbba0ce8a165deba95dda80e31b1ded8b4e3af0212eca55fecb800288758336e81658fd9c6630ccbe73829389ccef2ebd9bdd777e5306619f47edce666e9da71f8b1116bb8e294b55aa69935a2eab810f952a738ee522fea16d35cc7679c3601817c4a83750d142a6a011bb1efb7c15e01547cb8c7c71aae07e6eb22af7e54aacc06ed97132156fca83bd7694099b668bb4fc91a2dbe4853506724c48324a671f499d736ca4ebaf73b138b8cfd4804ee8169bedbfd6ac82fdbdc3afbdcb69901d6d253df1f5fe0be9027fface57da67530d9c5c10b4f1c3fba85e8a7cc7c2b267a411ab69533ab34c1cd4dc5adf3e7285b7bee3b55c4d5612671a8384ad83e80a16e81ee6f4869057a6a8a5ce640312b22202fb1e75648910a7e8daed7ffaa80ec4a8ff2e5de5bea1bc2ab6e360b951e47a2026b59ab6783d340746f6f550e8bfdeccf0bc35f704adac5cdb931724e06fc0eb11a80eea54931ee2ecfcbcc3162b342be862b85ad38f968ecdefdd78d0ad4fde3327eb52f466c5e0acdbd28765cf0c7eebcb8d2ea53cbc197b99c16bb82852cc00fb089bc4d307091b1499a39804add2fbd3d2e8c136bdc8d65b67d6ff3606e2fd2dd7d3c501292c0a77ff7498c1670e6e95e5a233c05dccd1eafdaa94fc6246184ca58cc244b7480565c71eecad6962a804ca8ea5ab9a969a3caf485c6d854622db8a2e86ee3f2ddae479d3befa353f8bb3f2e6116fb72138de1a1c5b0cc72930a37cd7629c0ea5429e7f2d06fae930642d52413b65b5d96c3bbcb659c6ea04426a29f5fe37f1f9d46bcb00634450cae093761ba1e8e6f2849ff681b8747c4c386c8d972ce2c50ced7f87d8d51443cacda6edaa6c0413f2bcfb0a729e7493484d0836418cf9505d8395cf796be658ab7bd1154811ee9c8102d715a53577030f1742c5a263694d0abc450aa0b9296decfa15bce11a23e699a4171bbd9b17c770368c5eb2f33267582539918981c1885cb69865afa0887a940f3c61cb6590637b03172cc4ce44218663fb5ec3202e4acd7183ce7a6322e1dc35ebe940fed81c27601b3ba1ad9f0fd8e8887862afb021d9ca2fd4e9a884cf0fa58684b6128aa7012d2e647a48c28f6627e94752caffc4a11847e2607f411630f1339a1f0db2c673675dd58e6d4919a0ac6cf96e3a19e799cc847920f9ec02b8299de18166052d7602441c3d771a696ad3949d2a6a860596927756d6184cb68c58132055722cbb13c9a3158f75f37ccf8a9a7a8c2a08befffad0be27b321f3a3bfcd76430a6cd6b69d3c4482e5104973d450060899071f59e198467f5f764dc4f53318cc4a7443241f80f91dbdc49db50d397f9615f6148161c9754468e62275b810a79f9e6975c82cdddd7080d1903a866a9007b90c34d15cee1c076649032d6ba867a59f8da53b6fe31d7e919816ba48e6144cf45266bfee1916f0e1c6b4b313a256b72dfa8265fc44b5c5cd3f51cbdfb467e48a683a9513de201d8d62579edbce514c754a434ed38cd520f50af5ff3997fc65443897117c864e8b9db3fd36baebd049c106d6f69bdcbf5c088910d01ae0ed225e5f68d2208f7debfb12fd0b1a8f5d818cfd778c1b73a55b7bccb1e93f2144cab0f69455d48dfb617f985b5a8d15f101dbcf68b88e01ab3b63190f961b816de6891378ae686d305f37719220502713b19833c5abc1e325f4f982546b9a4b0633e6242136b4a314f799571cf9012bfd2c5b96ca6071d79a126851014a91f03152f1eb11dff2d134db46dda7a9bb39449e183f5b08085a58cd2923dbf1e62f0f1358025fba8dea0d75bcc2e7307fda4783dac2874ee93473ed5a5b3ce1219fd0661b8efe9188b9b66c27778f263a598e6c990375972dad87bfe571c1e558f34df654f7b64cf7d25f657d2139df90c71c282c4cd4251673566d8039ef62636b7f7ca7c3216b5fe1c915928572773d12d640c1c9636d0665d13b5a26fe5f1689868b115744282b2d35636ac79032210d806445fb7cb06161b9fdd45501acc7527d1adb126ea652d618bc2380b1fad06e0a6651db4ee6e286e6570631264b0c6eecdae0e2b249977ca025f6b57047a2d6c3f55e403f6f186878bd66aa0d1aa61d3eb6c2585e360628269b0a019163c16f09e522638c4d84a89e949034e61b280a21102504b2600cdedbeccbfc790f96ed1802e7c550e4197a0e3d51d51c6293b4837dddd0d9701730a320ef7ad48285aa342f9c1f715a8eb26a201d15f152733d8c4043e24e9c166dcf55d8826d2485523fdde7ccc00b55838791be8d3f567ab8d4219f7858cea467b9c90339886224929bb6f3426811243edfd6e69a3825aef50f5219117fb20227c0108c142caccac88f0497b56b3825dc213779bc58801e3e1157056641730921d5ecb802a5c59579aa392afdffbed7e0973ff20fb84ad29b2fccc27bffb81a35f501db56732f45b9937643db766a4c521daa238b7f92ea9478a2e4a700a1591d13963b0e930a89dc0c0a679b79e5a0692514b20b9f8be964d192e50b7d24c335b7fc25fb99a0efdebf5338d88ecdf89aa15021a6b9aeffe698e70a09b0ddc834359bbeb4730b3fbdab8fa98840873fea08b206767cb67a40833454cb39871c6c8aeab7169bc404682fa8006031172a0d9e3a8bec38e1f4efddda265959cd68fd06a717f6a0b8acb45409ddc38fa5624191c8fbe904ff22124d32f7a87596b6a2af45dbf0fb42260834be9aa063be997bf3df88cd367591f6e9e11f078763d7ed807ef9828950d13dcbace63fa1a8b875bf2fb85361359cc8fc61cf45e6a91ef53a8a8f7c88651f5163508930f4f8ae744f64bf96925566e0a980026c89b0403f8101fe59bbac1ea888690e336ff7c6c2470decf7ffbe10f6bf1019cbe6c3e01c2fb255ec8c16ff91075459e3e2b268dc8925d57c7f8b6f438abb71c9f09eaba12f77e55734720d2478e9a5d177d03c662cea2f0591a80ff7cde7a0febea9371f5764e85548ee7f6040ba5cc895e54af5dc4625752533738d4f13fad3cd8325d105154cd2f0388f3fee3daa66d30d5240a5fcca602fe4fe41d61bcf25b6710db3e9aea47d466867b164eba0d55787c3e07c87807f27db990500fe0902b4b0bbc74f6336e5f9e31803021fb0fc88244e0e53d858907a304bb38707475629d4f36e758338c9289e1977bf28de930094c0f77e5c6f550234160badee5dc77b8eaeb507266fcb5a0f22dd5b47e28c523b5334aad39582dc70717abe09f8c3ef8988ff6ff84331ec562aca4a2ed792f9a235a117975ad672b6beda05a3fbac14fa9c9f9ec74f48b2b33872a63600455c5c283320d9c59b59d0b353ba61d93d156a93c386595d61cfed07227ea39e57cc32fb065a27f42daafd1fd4890813fa77d503e017f0bf292d2d50bfbcb211eeccc7719879b34c0b8df627e7c18d661151c749aac67597b1479bbffbaf802f3d3b9df1a2431ad3f91f754ba3ec2e4e7b8bebbb58662b25d33d2f087435721ae3398ed4b155fb6790ca94bca55182f1a15ce2e5ba55111a1e9b13f4b8ba7a9c71c4b289c3a7bca1ef22c096d769a61dfcd18b5dea18f178efde47a3d64413e75fa0508706b9d449057b8dc953ac84c3070c01467bc8cd88e4f57742fbf050349dde4208ba98fe2c4880411a7cfb1a132653ed03a1470283f015e1fa940e8a482b78c0ae35d6c4a9f89d2172f65eddd23763431fba901401efe8c7c701afb0e3add3487e276c4850e0d331e26196bfc72608ae01e1d1f4f7b62bcc8bb2ed8bae07b2cc4dd4b0637e5cf108147d2e1426d6faf6a79628018ba2401e2c0ed92016e582843a0664ce444ec31dca4dc110ce0045c0aa1d0ef56fc19cd26c1ab4f0c376453c03b2a67125e7859d6daa6012b71652ead39225eab64fc6334aed34e5fe0c672456be136a08a2812ed20bf6d75c8da2848b82033da1814eb2c0a901bd9469d2623650f0a217f1cb3998f2715e46c202d40f05e18b6d5c3949a88bb7b3be161868d1acb6b2921ce4cceeea413deaa8998fbea34ad7239ade7776e861e339b6c2341c76220afa64a350ed76cd40bfc8b6a014d0f6cf64959cfba1a8568556052453a3b3b216650ba2400fa29fe022cf72bc35b5a2056600663e745df97a191367f5e1823b21210404374b6493bbbbd1b31b5984ada533640e9be45054b2164b2cfd45adfca19e084ed2b5210ff19f988ec36f919b1667faa9cb86a625549dcb75259adf8e7a49c577579aa8e190594db8d89ccf41128c2ff858d02cc558a8eb3b026d0bc1b655fb0bbe513a38e5c38b1a76d8a70086cfc9f68451cbf4c70e029f323dab536f4f211fe5b1a66f49546b9e50eb5849c96c806cd1929ac2ff61cdbf8f34b8d869ad838e37dd53e3ff6fa87b4c3fe5827f851fffaffc910438efde6da4535d2a0a645f8473135734d308ca3af9f57a28e19be1abc9e03da816d21d4d1ab7023e3b58bad9e4461e6c6c0aa57a4c8d6566cccf9f90dff1a5c09a9d4007a3b59a5eaa072e61dbd6d0334f09be10f045f7cabf524b8c15368917c65dad436e59d39fdd93b5d22a15c528af17fca9a518d80aa716dfad141577e99a4bd362ab029fbed230ad455c139d3987f2e1fb52c0329b5a111632290ffbac8da2afbf8021b248fd900addd0c37fdc9ebaac1618f0cd6a4a900da63036e971aa758177e9d167c07721113ab24b0dcc6b4043a1528fd22bfc4c92ee10d7b62083f5007fac5d53ecbeb70052e13569a94025569fe54d5a7f326e91c2f4fa1027da278286113876b241d6d6cfac6933fd67cdae08b157b2fa7de0a6530a319a084a54e01fac8716d68dbd195e6bd56d781d569977130c9eda7a693e19b0383a575dd76e66fe1c29667316b2891297c907aa1b7de12d6879bbf3ccbfe8db4aebf827616186c75bbb4ce878739efbd840bc64b010e20c9cfa9681a4ba9422e4d087da7a18dfbe3c8283b09f93bc809b258e198524e4febd5267e1704a5f013c723b2e8547744c3af810c80e3e481a631b2b9f859d8082dc8a9002d67ee8c7d7174ad9809a61e371ca525f3bb9d1f85f16a72cc9eacf907ffd6ea9c22a4ab2b472a1d4ea445eedbe1ba1100585758cac73569e223c3c718c50f2daaefd1fe31c90871be23ee53a24e7ed0b3edf2c4de99f45bf74b282bc5b7ae87da8d62476fe821345e235fb549799a50349ddc1fad414d40b6aabf3c2454b24df2bccd7ff0171db6a7b14aa3d2f366b1c1733e2f2f709faf8a4fb89af7b14cebf903b706bdcc91dc0e46b33f23dd3fee24f610d0a1073f1849ca60f9b1a3ab91d0758ccf9d073d8e32205d1625db51ea586929a7511f1258ef393e2d67217601674d805620f6823058f2fcbb3ebf03c8ffb47323c49f8ea6a7b9375a2e77aef59dee892dc9fcd256a46a874928359d1616dc02ddc03e4249b0c83244dc8fc7c12d7845241fd6e01a0e6eb9c625738053cc5b6f1308e84f303044480c8e916e2076ea7970556a383953abf82f2ac0ddac20f4468d73b5127d2694e2d08ba8a212fccaf50bb8c8d344ddadf4a34fa79df489a2bbecd02ce3bd24bba279e77d0b0ed29e126f6da47b464aadbaa166e8b03cd6c3245ff2b76d45acc32f03eda52c0cf8211acf9b691acc4b5929bc2312f49daf3f62df555d3c6403313723ccaf55f495356242a40f7a13d4bdcfabba9afaadd77c446d40310c2ae166999fd940517611065190127b28b7310858edd4c3e5ff99388170c94f1ad64f42970db7d1e11f03e7e6c25f16d4c9dc6479e205bf2b87137adba7a42b67ec4813f7e5b334efe578052cac0cf6858ed946032baa9481e1683a2f21a2ded0d8914807f532c1d90fdaabc9dd9d62771203d1842788a542dd92e1ba13ed1c1116a9a7c3814c2e25f926a718fc21cabca6e83abd7164eb4318cf82e0c7e93d6cfa7006603b8d2ff76f6cbd648e061d1632ff43a0699c9ba6fddabdefc52938ad0be21b6d703911fe8b7dc68e634e9cd83dfb3a243f743664b326188a2109895017d3e8abf5fec6090b0c60389544c7ee97ec0d6422a6739df5341ac55864b7f2c658dc190c8985f8653f74e02ec697f19446ec9dac91939668fc7d1acc0546b332f9a16d3ac97ff46280d13e3326d5fded65bfa4a30ca852669d3d26db94466fdb4e3b843758bb7b900f3cdef742625bedabb3f52e80a03ccfe28f176d821a3c49b88714c957050cdfc7042aef7bc2a945a1a87fc77f2957b6e477afb940204f9a8178095915975b36eee7e8bb8d7f3b88a6d0da57bc6e89642b7f3714865f832ab6aef494198f44b2efa9203ecac2d18bccec24ac222ce26ae9abd5cb591a5684a59090e964b87364291869686845d387bf471c7c5161047a0850b5b5aaef7401adb517cc5ff27f6e5b81dda8a84f938715e0c398da5fb9059f4468a94eeb5c4a7b8c0c4f0638463a27fe01bb29a8964d55ed5b134e02f47450dabe3e49cb01da1f334f97e0abbe58203066fefc097a6d263dca764f8e858f88433544ed748976145c457fb615dc8bb40db1191ff017cd087fd18c46e008c5da039bd7211ed77e0475260e1859291b836113b7f5ed0c2849636e5104f67c92d10880ab265101c246f351e08aeccb4bc6ed28f965c20a85e2c6da84d497658a49b229fa803f8f295e6c16b639a1a9cdcd3e35374c17ba8b553d17c37b0d5f10982bcc7f5badc3f2d36e3e3ea0a62d545188ad5e7f2c71b168d33275ea625dbcc80314dd3b82ee3ed07cd4b7f286aef8f7810261a279afeeef81b9aa6e636481bb920a5e0d61482c7cad20e4cb4891c148c384752dc1827467597917859c647ef1ea9a90a109e9aeae34ce34a0fe0ece69e1850246a7543347f3e525f9a4b969e400983764aac4fd475444a28819df93e7de740476a4a5c307d1852823c8e333ec501d26f7d5376bf39862c91d2e83074574e76e6d7f727b41bcf7c45cb3d729ada67708649aae7b15ac6a87ac875534d3b45562ae3dbb19890a7c808712670ef430b5b9406d94e07e8402df90185fb4adb91c5fd1222e4e483921539d9daececee2d13ed2b23eab48285bdf327c0a5880f6e61f6025c719e6a1ac48251ddaf6fc1e0609a2c8b262a0ff7b519a47dd5fb9f2598a1064dda6be509717de61321fd14dc401333d418fb7ee957ffa5049cf1c1bee43e7dce629b25ec73483a1cfc1a40be6d14f30e290c2544feb33ce18ec5d42836686445e54057a486d2725a6296ec5d87c3a476d25e582dc377f974fcafccf8d6d688283cc534672612b7494aa0008d890e0891838e68496824f71058c39da92fe9f91509dba99790019cd7203eba7f5cb050e7b1e1f3849a5501f36503da4df8b3255881fa2ce964254be344b3d6c0e6495ec61d0581a4e190d374e1bba19295794fb92cdf583d174c6efb66be68664b76ab18c3dafcbae6910f50593bd8ad912b1888cd34a1cfe5b8f194094a9a3df13e3f572021a23ce4b8c9a35c1b27d601c71be924dfd1fcc87b6dd58111d7538deeadd1187123f31c5c057b0544d3454c6090472464d4d9c9382bf85895174ada9d1ae79c42c7f756c3ed99a145179b37d783171945d4837170fc05f2caf5187b586ee9dbd0f826a8aef33c38e74b9533dc7683e3ebf67c999ece166e3955f4621ed212589bf845da36cf36896913d648f54072d5d1fa60229fe816","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
