<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f6e0c36c0c066130d3a851d866a7913220331916ac51e5920da5865116f6016a9d0ee9bcd70a4c3cb1305979d97ce3e5f7c55b8ef5e22b32a918a1d19e1a55cbab166ab8e230bd0d6a121e59b8f5319e23fd6f22dcd1d1f9e1eace5ec3ed00acdb0da56a9708c246ff751b7eff6b205a8bded1d2d9bfeaa8e53d29831c6391b9483cae967838281cc0e065e047dcbaad80ae19daaa6b4a0a3355c8d1024a589aac6d16878faa7596b82c474d5693837cfa6ca4ed13adbac39dbf213876cd2489f1c5a51cf9d620be04ebb425131eaaa8d21d51487cd65c14482213fc8c02212f18b552c9d298a7606c0c39ce230053ab3dc547ea3d56e44713f65c7caad412407c72916863478ebebcc960aa7491c5abd8aa8972e29e0734ae88c29bbab697cb56f83adf1d6ab47836e232937928851c7825d04fbf42c4d0f47b6291fdf6cab0a25ab4e9754e5d26a098e064fcbb49c7d9259e63a6cf04ceb59585a1cc4cd214b3284832fd8fc6cf65f5ce559b400763d8742fe04ebb226212894406e157e52b70d0685bd83f9881f64899376ba49c35eafa543b0bca929587e2d6317240f207afc4e7c922c6b1bb6fc2013d90a88fc6fe172327f69b5735dd2216cdc98c2f56328085d6a76a7abe02e0a5a08780ba47c3d1837f30f1dfe3d8fea0df892c06571939ed227d3504e2fe699a735df77dff420baada586c94df0ca00d06a37a60a81f6d7e7f9e27bfb5c3c17b34b89bab8a62230963e7eba216a831d7ee049c0135d3211ec9dfd921f97223b84180585d45f3fdeefd401399874046dbda57e16d2bcf1339f97f598c2b509db3ec50136e3154d44aa752ccefd0a748e86dd9160943633c7db0aff4a7b28e7c9f0fe77a0776f7c4226fdb63b0ce3619f750d11800ce87abb40fb2e1c0cb9bd0089f3fd2d9cf950e4dba7c03ee2453105904b6e220723dd75e273eb84b7fc9a3e1866152f4e466e11dae66b31015fa07a6cc74ac3713c85be2b39da9fa89607a6bc8d9ef6f31fd1a57f229213da20bfc0de5dbeaca5d488af84186e6fd61d43d5c46cca760379e1af4a013423e10ca61d5fd7ee34ea20ccffca6e46f8ab4afbc20cf8dc3369248f0732ce6f88ba3eb81672c536c136a261094799309af0473e925a49e489ebdaafcc1cf68849468c652e08801656bb1dc708dfeec04764874f4c1f6dc7329dd3e2381cec757766ce2dae0aaac9999773f2ada08ed1f88095a4a06e7686f0af1674e794458833b162f53dc96ac0fbc28a1c00802e3de125c6c6c3b3899cac2d7eb3cea793e4ab1166278d8e134f38c6a95fef6c2e35b121f4070e229e933c21011fd2b9cb34161dd6f88b5152a4c72680041d71c538e977f62bcb245528173d9d662aa3ddb0ce2042785783b4dc24ac95925827882a492bfcf98d66824754f4edd51e5ba66fecf6b27f59d362e156b2fb046b8ccfd5980f264034c62007b65fb32f1a14922f0184fdf4b8d523bf0c1a0cae746909161fd40bd8535506606b9191ba18692c419fe22c737986e19cff8f4e79cd45dd3e4568c5a4ff42bd6840b146a993fc287494be33513d8a67115cfe8ade8bed7ed2ef82e7deec454eb071e27902ecd70b673e81c244960f1265ad16f51fab49247661c58105610e9d80864bde45c84618f530f1bcb5e1e1aa91af716bff75876cd0004816f6665d67c608848c04280275e3d533f550b9daca86271f4b4f89395923eea92dffa9342f56ff85c5a82beea6d9243445420d2bd2e2aaedb87cbf349e0948431ed5b35414c2a8c9b4c03e71b6adc5d28286d8ec574e58c71920e8746ac49f293fd9eb231f0f985dfb866b847209cf7f11460e559570e4b87a7f1e41df04cad65d92f8e5a40f9085b3bd0901e8234ccb59eb83c7c8791d3bef1272f96dc8f10ab2c9ccc0f2907b25614ef5e7a840d398590ed3f2de1c0b2e3b4e4526aa0cdc2a1ca7b64ab9d9a55669ef450220dd7a751c32cdfa39ea5eb2ed828c9adc62bc5117ad9bcd68dcdaddcce4a22927d0b3304bbbb7f2d008b3d1c3660877e0f29e0bec1e065eaa220efe97053a44f56c77915bc46fce5580dc39c7aae45a184c473cbd95c88c843432ca6243465b742d9e6e31bd046d1da9945a26552bfebf6a48f2b06ea163c9e185bb1a2c081edc674ca789c998abb331f05871808fadbaffbd425816766eac99c795909b9633a040306457b2a5c708ce54141728ed5ae9d71e38b8251d1df946ae9c454dfb2dc12a8149d6f117b31c9ca199751e9cb19af5eab1909c976e28ad3b9918d09b7cdb40291009a63aa20969ae0a5a3e731e4d769bb777051a73f805cc0b8eb750c21b6c44bb05052ab940b235315783e6c05a7b01fa23a8c19b9e743de4639fdfbaefe8dae416ec3d57f7ddf77ac958ea41b9afb7f13571b300fc0313b346b58e5122dae453ed528ada94fd9e10c7f2df59dc8b3fc7e5080fa11aeb2ad2b264442c5d94bc8fe91cf3501b49634b7afd84468c1057f47f97ea83cb3cccfb91625ed6beada0948bd3a045e6fe1e8669e563bcea07f54b2315aee09148caf6b0b792a17919ac7b5c41545349ee62bd956567a5ee26f50757b64499f5bf0fbebaa765dd570c82f5eca8259a2a1167ff4622ae5fe2590544b1395420bd3d623a9b465c8e04c19dbc97a710efdc787747300f9a8206097234086548c5891fbac866f81339582eee16bff04eb1c87501fbffd6dfb23ec52e8c6e14fa268b772074a0d7b6d9dc6e47060a23d1f1221beac219e8d0e337ff8c033b2d73584e2190f5edcedda01bf24fc9e33cfa39016e84b1acad0041a26f3e00be2bd8ea823aae80df58aa47d189c9db8ea91ab18e6e27fdb294570d5a6aeb1e81b82a1a02e59b410d05aeea0dea8c3b70fd42853bfaa5354b523247cce06c0450f13c3259954d093d2bf455ecd1266b3650ae3d244d4ce12bf57ea9248a619df756ff59c49e15133b49b9efd550e037e66468c0ac586b21fb2160f84220c84ecc23a1ad9de48168a9aef67c99daf62e2bb3d44be723623eed36559a72b918fedc89d59b274837c23c7af23d03c4d1996fbd9a229f70a93e27809ecb3533780d5ae0409375d20798eef81f0eae163c1b2a42d65b0180790d09813be8400393cfe0d98710ec72f59b2c72023b4a76e070725ba9293c548a3311d9cd1d5a3d0398b7a9525c8ee8140d3dea05e3f5177b26722136645d85f87f7c63181421dad8f13696564e1f2f614480b38ba0b24442bd195387c8436e3a80c7d4af88317d9f71e22614dcf1b43a2bfa3bf07447c9162ec624a85fa7221987a75a9b3dc2e0157abfbc48ca4a919e8a1088d2ccb40f888030b895927ba9d3b7cb146c15cc5a2690d223f51e1ae9a799de97ae96e8138521fa1cbf175f4cf7430a728a14b413599b570340318ba5c8eb5d0fb0aaebd126671112f962da5bf5f5e2c161737e1973a5c2f950f63c6f4325a81a007c860364a54b0b12e3f3bb7b74d10b89b06658a6296ebaff887fa53335f1fbb16ea1cad94079348afd2ab6c66a7d71cdb06bfe0544d42a1914b8f889412fd055e587fd464f43989600420a49a987a305cf31ccca5c573bd085c64aaa8fb5be9557f0b478bc7db7acf8b95a1451c17d0d50285f4198c47c0b20724d473729bbd2fe302893eecadc4172f68c57f057735a5cfc0cf79baf19a0b078b036ac37594aad5d6b2473d08713e690b70edc087305fd4a23bb8d781df0fbd07e67545259bc2d357ed20047f5050b3eedff1ed0d85c769cfe4487721d2a4d7ed006a82d809c2e0fe8131e059256c1e1ee1aab41c4e6f41631fc2b2bd227067a69fb7f7b78400bb5b8856ceff1c35f46fbd200881342cd4ea8e5fb491cff03e2fcb09872ab4d196cf22d2f33dc3072ad923301e27715006266a6984d7bc190a89833aa19ddfa94ab8193c967daf499769a902bbbc7413eb6537a7f8a985a95357adcb9590869488800626877e3808fc33ff05f79dc10b22a08e4a219a0be7793b91e9a1729ed8943c3fa20fb152fa54c8457de9221dd44308905f5c81a74486d17ee1d8933153d9b633d267f0310ad189e75358bc6879cc82adceed527c703cb54626550b2020379d899ef30222d9c4fe25cc88818fd6e057bb40788a66d7075a2aa02a8be253b592aa0d17dc9822330368992c48d0e1f03d6a7c281fac94a68c687dabcfea24fa593b38e00b2fcc4503395ee783d5cf765b9fbf9d71a25eb78e4e732192a96de877de1c9293e21e6b7d919a0712bdf50ae8efd54a2b8dbf297b3c4aa6da0712f8e09fee2b03a527dfb7254dc041c25368278956bbdc441cdfe20991527c90375247097bf28f33ea311720cbcb34aafe78e6829a979ca1940e4f6f90736e7e07b1aedcaf0f8fd3b347ed8e75b8c757a3e616f4521e515ff81a61b9804613e8c7abbdf03193153162a88811a232683f718c24e1f0a0ebd5b921435ae5f7e04296a9a2b20732b65b1a02c338ccf74c1ea616f5560bcc3eeca6e6433473f7b4ccf18ef15cd89c8dd718bf00882f441f9b8092306e3cc49a672cd962fabfd5c38988f46faa83c0b7da0f1055f7283ef769d25979a8cb3f19f8ea9fdd038ad329a95723c7765bdb2170d9313fb39721a04850a79f1863b7547ee48ceb90669bd720b4668cf083c255b21d5ed6f8966eae5038a5dbef193d051695995e6e4928492f2fc4af933666b8192136213482beff0738eeaeda26c112be107dc49a339d1c860b60b02c5cb5494b4d392da52fa17918651a0bfaee472b8fc4c5e946ac01eda4f47792899e6d7c933254861783c4d5b1c1587730cf4c2831cfad6097916dfad7889d5b2b40f902729750eee7cad8d10c8ebcfd77e93d955aa9f74e660800f047289e5f18aadbccb4d9579b337e33be25b4088359b05b0e8bc91c23ad0c647e904e1c14cc5fb6cb22264a6bc18db964a536b80aa17c063376b80a511e5f5e148cea9e38cc954bc635a5ac977c32835b378852c59a46df677c0ccc8e851556df87caa71e221e946ff3075df0a68d8ba0a288e6111f33868fc2e2923686bcefab37ecf8b0098180067290012093e2be46cb0347c3515d1ff315024e2e969bd9bfe21b968da18cef380b590d3f761c6d842c7f52fab4e9389bf1b68752f834eec9f9c7e472fe717a3716bc9d0ecc0df134161ab1b2995b13dde74f394c8c5de9acf6ff61270a0e715a8436cfeff452d9c66ce2af334a5e4082c2f0f69c929e6dccd6d1cc54d3fae7c9a9fcd85a0be6348d3d3983e5d4318cc4d6f7b763c2b0e9d436df46958170052fed61c7ab2de9b3babf175c0969044a30b88bf76f5adb56076446b508c6167cdb9420da354540fc82dc62d7cc65e5ab48aa4af3873644a08ffc6ffd6bb19a37e54c626969c24664573daaebeb88d33ef4963b95540e6f866f7d537bfad1fb6902db15cd99e6043a7e39a9111ace204856937add568297364fba88e148c17e06a743d3e1967c347172709a4477e22fa05d648d99ad97b4c34aa835a0862075289fa046ed4a3a7f540cd2089d9cd0bdb036bb76c76bc0422e1f1575f741cc0a66e09d4574080a6817bccc0f1149e4dc84a5e2b6d686efaf46aaeacc03e399afbac6d94a69d26659447f6c962fe4b4708448cffe63f6fe370f5076f4325cd3a076414a2c2c46d00f707f479afdc7973b7e08a0316a3d6d9c9ef2569649b99dfbbe2ff59b21434114657bbfe846cfe947451c90d1bf8a6a723c1d66ce01bdc641c2b1945e2ee3778c2aa3b71bfebf38e4f2e31d9799d380d6b65c5624a74a331f8cb6075db7c7e63412d64b7361a11fbd9f74620f46bd188d19f380c2c296fc795a4e72ece0e0c5d60897a47bf2a18b65b7fb9007898fab34dfb634c3458ec3e46ecf8788388a631c9b71e683b652b0e240d84de03b9727f7afc718edc055e9f97e6587d0e629860bbf7b0c80d06c80954e574f0efc55073fd571f4a1900e47c9af17b1419f1c7168cb11573d5c8c192fb056091ea7c35b55a0adf60504ff01b268ea8d32f194f6aebf1f02029db25911cc7005fa96fb0c42e9d411359f5b116da522f6d9123e2b9348c1aa813711ab2f4f520bbf5eb81655c08fc75bad1e80b30a79b7c296a79a502912e81a75fe31b9856dbceb0a255572e85d8d2170eea13762c6f2d15220e7e5785f825df178ba4f633d47289a3fecbe6cf102054cd9e70f1660d5beeddb7e09161bb026713fe7b01f0e8e676def568aaaf014de41fcda7e6672adff26d5954ff81c9e28000524a074b4c56e850e9b49aaf32c4b89ead4dd080e03e20d603029efbc5a5c62976640ab48199f1f92d44715ef920352f8de8046aaf6e6a76cc3dc0e83be7ada611dfb6bf1ae0f981dcf0a0b8105f725bce4a7451724b855bfa8284fbc811f4e5315ffd906dd081408c77ea1b81845294722845f29b9f98fe97fb89674ea01b03ce29e3eed529a189f0e109d3c5f9935adc6c820d392437c9afc21ecc3382e03a1f7fc3b3bdc0c6e2bcd9f964b8d26d0c18593bfeb7c62917eb56f1b06d4609854ac4e0a6d0567a728e8c04d9cb6b5afdf95ab321f05d8670256441f76264db8b80af3fb906802d46ed5c8a468b6e6318cfcfe20086c2ec9d19fc8c74c4f34d879116f734ed268054b70ababfc9d19f7e1c891b0e84b2e70287972014eff525c0825a5fac9c7c287479de016d492d306e628f7563dc61e85d73be7c01528348d535bfa5544333e256604b9c96651734325702604f5186316c77ab035b839f41c025e36fbb99813bc1cc484fd4036814cbbc3f16971e29a97890d3f7dbd40cb8672adc1a1b4e5bd1246feed2dd09cff1a1118bcc7e49dbc1052d400ee87b1007d23203ffb241360aac457111a62099222e77ece836d10d468b20f1886c3531ce42633ab372d050c9ffc34274bce308f82a2cf16f14952ca31de3627dae5e065a4d106b1f2dda39b303e8b15433b3765e219bd878ad72467cf2db94a94547b4049dab4080e5a1a2ffcd3782b595bd4c454d8955b470b182b5cd3f46d0ba6a28a6324b51789c7e64ca868768491e304327b88ce7d97753bc6717b3daf3350aec5c1346e04b7d6dc307be3b20cc86a8a1308ed078c3d8bb660619a65e6718cb739d816d74e63245ce2bee65bed8898560f9a890ac857c57fe5841c9e5b6baba6e35c9309458da34944a17f9a6cdd6103c8d1ad58d96e765d50c020cb3559255cc08508ff638b561e9501228cd9e4e0e83aa76c063649bdeecb59884a18f7b67bd2fd646bf05e20dbe1f2039768fe62c106f927300f0c32006f2c372557f104d3f1e8f8bb40a52f83d5cf5caeaef44d40fa7bfc639330adfd0d5439239a3bbe3eaf9f8a960e5e4411c7c3db8c41575d6de3a909d25ea93bc444658b88ea1306868b03b60421e4599be9a67d29b5b06ab3262349d8c0d4bc5f8c7a18334ddf69f9d8c996a89ac75b7e526220efe200ffcece912bfc159b367131caf36bb847221f31a98e9c820df4fbc65850aed5d1d1918c97094fc479be92f1eeddf4819c5777ac8154da8123807f640fde60ec7604b9b58229a8a25c4bd087ce164f1ed07fb2a170799d284edb062786fa18a6a07fe5a79f01c403be6de2e52ec62da6c3d7fab107bb55f049cfd9245d0fe8073368e5be079f2ccbda9388fc8fe455cb02c0d48efca5b4ab006e04a5d7770bfb846e56fb438591cfa65eabaa220dc8a2cbed433cfd929cb566e8f8e395d42f8a8ea7f9849345bd4f4046135e010c72ebb3aae3325b24bbbd44bb2f001ee010fc01e97296fc3642a663ffad8010d369e24e26dec143b816e4100090d1655a19a0f1e50511c5337e0499e81a4e1c0a6991165c310488989ffd698d828e5e740f4a627491a19d2777661c31ceff6bd10b51b61a1cfe76825d8cf97d6850304d949eead7ed71d0f0e6b9d5fa389c52d2207e6ccc7c8f887fe22e2d53b7dc22531333b5de70dee38be8bff8e8eae95fb1a0c146d512298fdb18f83a83a540d519159c2aaf3258b90cbb68ac4c5d8d2f35082779c82f7a77560cfc1bea5a8ef45030a082cad173d6bec4a7c7b25e292eedfcc56c221afc740f59efdd1bcf8fa8adcbc390bf7e3391c889f98e2181120a2fe3e504e8735eca199b6d652f4c3bc0aa72b20cea69c7f2871b9b4bfc24be107736b025f0655d17aada27fb34cf90155303f1095296443bdbfd89bacc5a1904c2632b4a89715041378181b21996b6f7684733128af52a73be8f659533f7f652f20371268dd57d39b46f31780e209eb97695d1189d3402aca5c11a7ea9e37bb83594a60e0435ab6c50e727ab4d650a5e6d7993bb8504b19a3e7e3fb0189ebd8d9b50a03cc1209547cfab9906ab68d4adc5d3888ba6c12956e49c0d875a0911b28795a887940d5339ae9f9608d991708809c2bb9aa0c15f9e7ae0d1af7a514e5179a44b958e08b2b6b75e4ef4cb10b8b3fcc83154607317daad572c2bba454054320b818143ba2b2030a6b300aa388cb03d02f742c3295b0bdc0247f8c543482abb398cdc30ef9642b012b22e7545cc04d0c31f3250dd3f069e9a3380f08acf386a13628b84dfe5c7ba289513d812d9f41ed92b0aa07a860434ede02ffcf95a57974c3b339c0518d2d0b093945551dd551dcc1206ea7c60dcfa65e264ecc36ee1c5cc71b2a6f33ea78418b71a56cf7505eef6935d01db4596d84188959aeffb17780d72a1ee8000ea6aac65cebfe15e8d9157bc3a7beeca3a361a34666ba8e44ab6101c8a96e6c0c45e4882a955a1e81fa989c89c4424797d4a342c0e7a987e017c304e403d17c2e425312cfcb811cbefefc542b9541376d55757e37bc48a4802e4493ee71c921aa96824ef5d9e1e9e8eb2ea8a5579c19a38679a90799fccc66b9e76e65ed6ed35b81df76d8c49e0299835b19a064c3a259cc1087361b62db9469827af28b5fe52778fd1a409c107506d5a6ccb3e7dab74cf2567907317b1d03cc2d9750246f25dbf09e4096f471b67eaf9ba76c87745af0abaf77eac938670ef46a4807294ea22d686014e7c304d58a6e13b12fe3cdbac803a9f7837c0e2893ec77efd20cf4f2742efc179bc4786d2579c3df87c51a1acbc98a5b55a8910139d542006b9d155100ebf116e40b4f9db3da3079d708b721b5eb39a489cbc7278211de6fc062b83a7a4e7ae3a420e588fba27eb05173ed73b6116dc9c7adeac02c6bbd84f94ed662740034f7ae3e7e854d8a371a661a234112e9ed249f08a0552094968f15c63d906a64f74f1ee78a723f655007484fad8f67a405366589ede304ccbae867cf452eb87a32d8d1a153b1c375a0691ba5955af942d82fc17668a75f380668e49d0193ca84f06bf6dabb9e789424951c071f0bae1aa56d425b8897b06f731c4ed4f7ba8c221561af3790ca0e5ac6432541679c675fb1f90eec684c44b52c3437c62f126092b78b4f1d0a09b6268a4c17cee82fe31e2fabe7811ce2b331c72f0b99c4f7b850ba951bc5d57221c1c7ec85e80cdaf7341c6f2f6bc68f676ce719751571a39d5bc17aba9c2a755dfaaa383bde787d9f7018b49bbfdf382245130ff2c2c8f485156ba2972a188f447ec66b5698e065448d387b36da044c7ce67b4ad6a8dbcc2e66cee1eaa611400cda8f097c27463dba26856ce54038a58aee6c670d5cdb039abfa7dd36bdcf5f62251dc4378a335cde58827f3199f6f0cd382860b5d9f01059258d818a2942278e9b3302b46c8dd8e0de0cda02d3dfdb748a354633fa7f7bb7f85543d67e11cd40dda2ff9d3608a3cc6d0b28656968d14e395d5a4bd108b7332f0bc7d6496f981a35e5cde981efc9a5c28b1a9e767891010497e567668bd471810dc775498da748bb6fb1da628c05a63844f850a1a936b08294b1a5e31fb9668d7081fff1c7dec79708a0ad4d28d92b8f7d6b64cb86aea9a1659d9b39dd5276215fdddc04f11d562f39eb74a2a9991bb21e39c501858355f83c496a23f4d6057f088459f48983ebe850f6ce2ca1a1c31a63cbfd6f7914585b80c2cf0c7044167e2c053c5914ca97a5902f747c3fb91d92de1cfa8ee6339d3cb580988343696edaf9c46ea5416c5503e71e4e15fb69162579947203abdaa9fadbead47df3b8fa44b5285bd1e238d108162519e89fce57d9ed0953e2b52cb0aa06948cffa72a2c237b3f347ff13f118f7dc8c23f6c9b804e9fd296bd71eacb87f0b273be187e837dfecdfc2fa5a16a26473b564d2d1d22e46adf84ffe8cb920ef20643d9bf9a951cae077afd8b2ed4d263af02191285669bfeaa468d9f51ab84a15e4d43d5851a504e4181aa99614a38dc0a0d02e7bb8f71b484038dfcbd5fb56164000f364d34667ef9ab8c0a8b8630eabb4693951ddc625bfa4d25b4979903eab938963ef92c7aaf1ce44a718397bda8a8cec73ace8694ffab924d2fd3740b96db26a74248456a28b03bc01c6ec4c718a72abc2b24e4063b7fa8f24efb76d7ae0297c7f47610835ffa9616160fb28f93c71b3f2c8ef92ec570d1b0cdd4be50f477a41389f848908c73fb02a9d0afb78e4a2fd2186f56df22c4b044546409580473be2a14a8a64257462c9cbaa0890c716303d39f3a5750d61669e7c3e9102a1abd207884d514168e2bc2b2749486ca1988a6ab08734369da5985209fe1b022d272bc315349dae1a31d4c8ad4cf55d05f88b8e376343aabba6ad70645f27c20bdfa51b9a8a872865c459bea7c74656ffdc726b4ccceaa570dc5110f35d8935f7b8b59dbb736b3b888dc23c01dd95b0ea62b60b4e9a18abd1a62ebc2afad42bc3b93c120040077940c8eddbcc38d3d5f1e2cb975155fb3e906b34c8e85d3e991d9d96017e2154a75e934184f3685e839bb87042595c64ed6d9cb63c79eabeeee92050ddca881b44a2d61f768fb01f89e8403220849eb1133ef093ebb6f3f1ddc7f573957c88f70d6a3a072a8d37ecbc61d0c42f853acba6f99821232f437007d601b21a8eac16c5b73fec58868db7f7103b5f18965c107655832042a1762432eb1f9b48c89df5c3ae7c805f88d1fabf15a60d1e452fd68149c946fc09ab912544508167e223cf55848e570289239b3c9ef24d29bbc35ff2674227fa65c8b9ae6715c81bb5558063c7bba88b923f93eca9debd935d462b4f85b0e54bb25b6e9621061b8855591d6a328a787f2e7fcdba7cda079fda2fcbea192a6657d6e6482727b505a33abb4a314b04269d08fcb4d5a2c026e710e6916c9da6cee5c866b2441673dbb264169821d5d31eb88b27f5b37bc5f4e86c2ea179a615d03fb722b828c2f9fa7a52781f6f4179024a0da482e016458d618ac12628ceed1eda0b2c30876be674166159eab65b4e8136e4483d7a5143782dd3324f80f9a26ab1e49cb587f80b0ff039e4c6a3d4c10f13d3004f2bab764ee2a239a7a3353f815df64bc821ec8cb8c8ed26d9e936d36e9136db5374134c126fbf22aa85c0aa80da9b733bb72659af0bffb91a4c334e9c59db77f942e33381f05bd2ec178532874d4f2c25d415d9f32b68c6d515bd37672df0ce23bb03a9b2ffbe44772643393a3cd1a5ed60c3ef418c5dba3cb17be69137fb634d23eb2e23064ccee14c2c3183f1c95486133162874e0be361b08840eebd01bcca1402fc8a4e1ec83f07f1038c193c7cb5abb2cda1de0598b4f046aa69a1ccf8f3dce902acd7a31e7079da92d63af1658a767e864e94c732eb49be135cc816a47cf895ab566d7f1e8a12776dc08772667622938e8d180a7f8d9e0ea57769d2fd719cef25b3da495554656c1c81cbf87f596c403ae23471a0b4c3c6a2e1d2cdc134cd0036f2b0ad86efbb94069581e4af6f0a06484afffcc011dc747b4337f4253640feb25ba2322f49df7ca1375bc10afb23fbb2d332b98438c26ffe0a58dae762d1dad39fe2b861e8147de46d6f12cb8df6ad5fb5a51ff2e9314d252f499e1877ac60dacf3cc0d15b74a287707a1c3a27f4f35a1b02b430c5fb34d4560aac67556af80fbe8c02085a0b7c57367464d61e92267d3206a9710af4dfef872073b111458116a4c0a92605e7af5594574da9f826bf2f590cac7d2ba2fae4fbe067a48b8f7d96495b50d202cb1da0b86f827a255fc8a8d0a41fd0bab2c4c4b0c49837fe8c057add4382e09c664b91b51adb12d9207870dad65df3ead196971bea3f1c9cb6f0c3424624f8813b4dc28f0218b519f454c8d53dd35ae0d3227156d8d8c40bcfeeaecdfa718ebf1c9e669e2d5febf6cd5c1d8f0a9ff0ee7206d1cf8e22c03bdf1b045822ae014b46382130ee1408fec236a0a9877dd35194ca8810f5e8ddc9fc9e05aeb5e70e08b2d94b50d96873d6f92e060b50199c2001ad29ed832b8eb61d24b016a92483b03ccb2567077b29fa10a00b2ea2b9ae1b4b6853afcae9811bd8b5e12a9d464bc31d055faa1003915b5a155a0f85a5edf7f59b436e17f344cf4f2e37f7e62715cc307657493e7bac72b6cb2769fe303d1b189dae1bb37d9ca316d2ac589d31722d43105e8b1e8fe6504bd3c0114cbad8b3c553ae74a2a049837e116ede1f1592f1131d915781765863f904504b7893cbf7e0bdcbf945dcc44fa013d92ae5bcbf69a35952a6d76ace4fcfc4a89369c291b35a1b9a09335a103dabb7604ec5ece8ced809adb266c357e0295ff9d65152fd16a5e78f44749e28cb74daf9b7d7d2c48433c3f59876e1dfc4299d8eb1820507d6137e5ff9703126d6034a3f5943cdd1b1ff0ebd18929d04296a9fd3363f721ad8a409ab2c4bde9db74850cb59ceaf189181fa27ef6e1ff6914ddb1ab27a44266b84e44044cf6e1a7c819d0b7a4917d59a31a45b1ee61a01ee10af13f3c03137e607d92018255b8141442b2727275e906af9d2d538aa43d0b8b6cf70ab905516b78920f4ff7e234a6a1ebc1369a5e632ec06215b7b6fec940e27a952bf8855a2b2c1299d18d4bc18b78ce40634a210da0c7a7e141130157070ed619ae4d54429f23a28b9b730d9345440f55b6eb66a4ea8a8f2afacfdaabf93ad86876d65d7027c54b88c245a5a54b3cccce457f28397551384922acb955cda25662923fdb6257f74e480fbfbd96896fe37d8e014fe58165e42706c3c4bf61ab45c086a71519356d610112abdf57843a2e84d0ac636ae07b58821779962b9bfea2cffb33b3d68a44a291b8c63bdbc553ee140ba93984972662c4d9db8667c19ebe25e81e6854fa1f54901b52b0f4daab3b6a578c7cc45d0c580a55f848e2b0933b78c5ccff9c064ec30e0b4f7a096443d5100c78841b43f9f125aa3ef74c1d96910b0552eed01442bd15faf90297fed915abf0c208a8be050f9736309c6c0e23229ad0d513dccee917e255334f5f0313cc4f40d3f34845dfd0f71c50fa5962db17ad38b64ee2dfd0ee7c8e19babcc389c870cff29a0c31b99e97edd0233a583a81710959f39257df84b5a3adb1dfab913fd24f5bd0ae31a593ec67dbb41287470319368ec6b957ccbb3c8f5fc0293904352d489a35ad645bc80e1a58a048f8f4bad1c7a4d7232c31fb6e6f967876705975b6e146678f27603140630a29b0e1bc1bccd4f5cf0e8cc2e5df2a2a2038dcb50ade534fd4cea391b7e6f5cb6f3bc7e2cd1e1d22e870b9a7b4491e706de03b0a952f1fd14c042c90c6766ff9729fcd58386fa77f737db8ce20338eff3a0455a3a1b3ae36fbabe2398b7fa7641e8630b8fbad8590d0b5c9382f60fab959dfa7f09e0a991ea8ca690ed3481c88c35b185004db39e79a1b2cf63a9b02b42fa328167859fb63f059bab2ca683691dbf1ebbd263d0c272f0f2fd9b7b174ed9263697305b80b95f20fa94002e3ba93d7c37d203af7e1ebc1378b54a039e63e14ad822861ce806c84ac9fdf59d617bd365d3f33eb11bec08900a65e4f96c9ba3a6bbad1c2cc10731b0cc6358e0395a901854401c4a476caf7bb275818a6b07155dc114e8060d3ad28bf11f48a0b5c05afc296d6d5c254b9d06841641a5cb6a460b9d16b3512157324537724be61a42efa4d342b3c90b0f30a4545974c0fcd07c1d1d75cb6fe9411b8faaec9b0cd42dc12d0a3c8d11a814ae7136e54d69d9dbacb6592d7380ab7f8e2a4a7c14af4b0a64284c923ba169e62f2976592221d96bc626c1a8289b0354fc0c110d643f05660351e4698cfd61f9e098c9e532ea9b84cdc1e5bd598e4c28453803f8848fa2aa0f32002a844c72db25e1498ee81588bca4c4368851cd71da753c9fd42cadce5be72434362a2c1a2084a32f94c97326a99c78cf0ed35cb4fc22893ccae9e351883e3b1c7a410f88c20d884e06939edfebf0e6c344792a9c3115d7d28086d53fb66efe33ab3c86de2b7a0d22f88a4e16811857cdcfa0ad19d0b1654713a7b0105f86e39bee4fe87c20a1ea7b14bc0aa1ff3ccf5c531b71ad52073af40c6e44e71cb42ce6063ea3d8095e5a3b81e4229bfaef079921bf56cd4fc8ee860bae23ad00c9e44399c294dd26a9a02f0c23b08155cb3aa2ca02e883709f21a56cf0cf84aa1885599471ae702ef481b806539f738019d140adc7b47afbc031a365bc9ee35951133d1219500894458ebbda6efae28892068046ae893237cee4ce75638ee2d11e1dabe2b0a57bdc52ee00cc9f478765554da91daae346b478f7ab59036c5562dbf1d441c21e426a4592ca08613f7a0e16eb6c9d6a50bf53beae5c7721a2b5f66a474087d2b1be6a2eae8346f7fa7328261ca9ee6a61c50b30bd900de4907e24855c10c773bb8d8d91e511718372f647e5d136199fe705dea4e536aa3bc43fd5c56b34026bad2e49bd2a4295489e7dd5e2c357f39b89b17d471d18e180210c4f95659f073890a9606ebcc783dea3cb4f3f02f121909c3f6a5748180d62a4cec74ffd5cf8064e4b1e578f9750c2d7539cd2aabbcb691ab42a90293e8c5743849b944f5a5d8775b1365e7981f3ace777d8c5eb8a1f87ce6921014bc87eaf2bb9896e0ea11a743a1599c9e3dfc5740c27670444e00aaa8d1fe728635e7293d44a19e8b51caaf35abe58a4e4720dd8e9e13922402a8f4e3c39900ebb2a26d95d839a65fbe1dd7d130233dba955d142703925bd13114831353537dfd6be83596ce797fe062a289ca016428a93dd285939e465bc988c2007d2ed69a3083884199ef6a2e170c98607b73c20adc1542a0d75f21190dbfb6b068e1dd34a3d7b5fa35318a460f82fc9a59767f1e4a26a93a6fff24ff66018b55deb62f3273c21119e9323d8c2babdc445a3f8dcc6db5de552e2471c7931d213ddb569aeda310445273aeaba1df15bc6b17e44b3f59bc34bd02a5287a53af01e40009031a1e5a5e32148c4874f5897f5847fe935fa395149c62d0d0926ad7bd10466401a5a05f2b3fe92e824ea8ab241d38b6333a9a085175a3e08a46d80f485a66e8fd037d6837a0f972ab90420509f8e2cef3fc6f7b1a3f259db226fac4c7e98c6dcb7aa4ca907afc26fb5bf6d1e5fcb0adcd29d79c9a523617a507500d95f36f20af381bd1ac70126febb2b93d37c863d3a5222bfffe4c049c9415a87f6a6d0e33a78cabbe9af9ca949050c949a6f2a2e89d3056ab1b995c3dca5f859596443ea17da13f12e26eab053f741bde5f926b08bc196b384dbccc4a6ff13e53fc3f03370f2e57732c4cc82f71aec48896baf7cdcb83f8defeffc75cea1947ebf09ef200be6175e297bc65ea060992ceb7d25760dfff0fc5017fa0d4d7361e69e5a37350b07d5c313408ff5e08bbcc32574bc1c83aec59dfd4c0e5bfc6de5128a1017c839563a9bc59e668afd1038354186a96abb69d5b4def7f89aadc6de0b22502152b08b79bc33ce25ec41e40d3a5bfb6c08b8a3c24d7eed7642a011bbf28efd8f49df5992dd2de7fcfacb5a35986f7c21273389d9659aa1da6226944d2ca73450aec4a1db454f888fc0613124ac01f12ac2e90aea41562e4c59430603e8e2e14b327b7e3ef7f45b8d69f1855b4d532d1eb2c53c1c9fe33d9d0699eb189bf0d0bff9d03ec81c9ff78d03ccc22fa4bded44748933ef8da86d34474ce16b91099d43d5aee60e94b0039d0bb259352a4a10f0107a9fa1873840c8339e62ecb4f39c9737823a7b06c883ba9a0cdc4f1f23442d15eb2b63831bdcb91776cbab5df63410b7ca6d0b309972ea7f549570cbcaa18da4a2a5fbc8414d19cae84ca4964a8270b91f1a7b39eda7a2d6419e1e8838a54be642d773f539d4180bf8a7bca1457c1e5d50b6005a18f5855c37202407282ad0bc7e44f99db64682bf2be213cbe44ae605cc88f37e015b6d7e90c960735c19db3decce8665b54727b3058350987f472dc25dae635050ec4238629cd97068492bad37af9d99d4b9388fb1fa6f281bd24119679b4424db84265aee85bd38046f4abff233cd2a1b9f4bfc6716b02efe05cc33bd7c866bcf6c46c58dcbcca6ce5dee9406742ea4fb7512bf6924d4664ce58733369adf82acb8d933b0c88cd932985b970268250ab415589f93c7a5664f29682e2152d276c621bd2e66f709e3cc0d3ace8383640f1ade2c418f528a2c0791334f05353b2d6aedba16229596b8f678fc236e55e62ec958e351c660a5c472e2a1632df7b1400bfd7d2fbcf117fb6fb001a52616d1ea59117ead5ef6386cf59fddd30c5402a6239061cac3985c5e99fb314f7121f3755fe296712fbab02587108b815b538cb653bca57fcba8ec3a999df89d42f44fc36c7f5661a712ba0f86b559f981b259c2c773b2ed8192bdea6574e44763f21bd047032d58581c0ccc47fcbb9022f503bc36e64b2a6d1fc7c7d962b22cc96eb514c0008fa868955976bc80e57aa45c8af6495325f5f162a5ba04103f9792eb4090a7c1da87bbb9084fcbd4018c80ecb130013a5a55cf75633ba1e39ccafe6415877de1ca17465a73872e8bedc1aa5c466d6fb4291f0fa16fd97192e98a097dccb7507b31e451da95cfbcaaee908e49e20d1448d1cfca73e236966ca3df6029544e40fb44001492c18de29515362f85882d694e438e0454273a4928be680c387a1fc044ee771f33420aeac8bd8d815218fb9c6e7a7f5fdfc85989360ad24d0609daf21e7cda3923ebeac18dcd4be8f38a7ed3dbc607c2b9be9c8a3921a20df06ee550bbcdb3630704c3a3d050a89ded6172a6140111a0421e99b36b5f84b484e34cb86b2b6bb820ac2d6edf4e1cc915aee89a47c177cf309e590aa7e522ed85b596ca091841e5726ad0fb6db74cf51a8fa9c7b9449648e5c3338b8befbf50bcc4b985760583e412ae44c085893871882e6da9812c65769d0dbd35cbfd3276f4d17043de6f487ec70dcb111b248d0253252114d6064cffc40bd48a8190a7c417a32aaa42cd9017aef4af8b1df44d56fd584da837c16cdc51f00bb777c2f4257c84558ff638db646c1ee903977ae94c3fe75fe04b2ad46c9e3568c4205540dd2de8698e081658db5f2e70eb21c133e8f209d950cd7141db0ef8dcb2348adb8c2e90504f912517f1e60ae9235ded23905d4ee08925e94c202076356ef2b694733d031b6c528042d648991db224307bfdb8cd8de0233aa4cbe58f28056db1409963042058126c0162cbe60d000fc233c39ca5ade4581abc8f8fb9f02646b12f42b5a9ffc1b63514451a708e95cb12ca96a8cd479cf0e9c1d6676ed83f0af6a9ed3fb92de74a182fc259d723351990ab52d1768dc6f96caa7f7d9cac17788c2f676d2b120aceff7ae5cc9607723c8956c46896cfa4d5001369ac74adac2c361ab9d8aa01ecdbb0a1789da5394681ae906099d8c4d3474e53ac2e7103a286b573d3f55577e7fd93132fd1e8e0b36199bb1f98790d93085672889218af65cb9cff31d0bbca8cf72627d0b63e894b1f957dc0606d530bb101eae111c2914b9bd10e37624c86cce75eb7dd5f6fde2517aef7b03cb08d3612964e9be355ac628d74f2f26f573ac1905a763f17b911bb74878e220e5fb4ab7f156b8c65448783ae4e27bafac419491e96cf6cb98c4769c0c6a382e2c8f03a0dfc0996e68c0fd0c0da55dd643fa506a0118a2c224a4ac2039c8a1d2cd0c1410572c0945f3988d27d23e5e7a432a28a9766775eff0aea0876714509592a0e8c3ffadefa12b247bf0f731517515f489cde63d8774f0af48d50853862187de912878bb412e18309b15b91e5c78301304b0b0642cfc1e57cea8b2e9e0a4e46c23a16b20116a98a5bf94b0920a88d1f763290205bd10f6d854fce92d370769bbae8450d3ee9bd9e7f02aca60e967a2c80ffd2fe5a9fb1e967de01a7fb0e54de8e1d9eb4077865cd56f9d9590b7d35ca7c7267f4bb29ce925d80c7f06e68a278cef8f3a6a62ebbf37c32c95cabb7da4f78b7de15341007fbecfd35e1221c10f86af66927244c5547cee6c60e8a905a6680eff3fe726ee2c3bd3bd996fcdb70d5a66d06c7e4df70d3377b2d8ceb33e1b72cdd3a526d136c2100ec80c82a80d857590da99883e895b136220d89728752c8a2cf95f1fdd9e00b99d4b963ad27665064e6f5a996b91e27f61c9f615aec699c4db48c33a9ab185a453912eaec0f7f36cd504dbbe46f8146594a535d5428edd8151064654bb63310440cd0abd92439e78dc69edc82a065cf7347720586ec9bf0186069363980749cf5bed50caf789afdc918f7b8a13965176cdd417d87f56c20122c1bd69766961c201f78b3fbbd12ebdfb92eb16ace9b28ee0dc0f2377be3626148e3bc353842ecb3d11c0d61e6dd43df62c57901aff2881197120c5c67fd66c87c6fc7fbcd7d5187660a942b93d910c4ff11a93447ca5a8f783c530809bd147a0b85c695f874287cbe2ccaa8020879d19526b7b7e7ccc7a405dafb617a276a65cd8e8b24fad14fb54c8fc268c6f8df6249f28f27d8d8521505e08df41a6223f7bde858480554e6aa3cdc5c1a6889093854cdc47a15ad791a64d9426508e547b36ac428e4d64f67dffa9d7bb700d08c96b366347c9ec2bfdaacb76834b0910f9863b660113016ea2e4f2efde9e74dc11068a6a3729dc86303d13435f4d1a5ca47d43a155be2fc2017a586602029206ffc5960aaa529de3c21bf24cbcff8d78b21d2a2b059a2c10f54a306782a51ab541f12ac969e019c7f0464152af78b2b9e1433aa4971d4dfcc561a5095f5dc871796b36ab42058a3c83360651bb4d18a2b258829a964074f34f5c0ab50aed6de5d241b9379ded7dd4c8548915ea0642146f50c6b13c7a58e03c6e6e53fe1182004c72923b224dfd2e78041317a533dae156b7e4d0a43fa250c3bcfa8f132c94f47b16887a47fd6ea15c855d59e93cb6f264a27a8985118096026e0d58cf01d97c7e106c11d7d48fb30f7e1a405a7c927eeffae30ac29630dba62df24d3c55c12337561a1b6ae949e42559cf95e955fc6b8c525e6cae989e6908a618942254d2852d6a10831d0c8434e0fd95ed3a8bd1ed31213d03846c718e9a645112bc3f3c0a1b4f860b4c91a87faec11412da37ec7d3be33bad144a1b986e3d1bcb7dfbe7f62de64e2ebe09c1be22c70d47053800dea3ee71081bb6ccf8e42896f507b424f48e998914e8960bd493bdc6e018a5b147243ac8204c7122ac7c86d57a5395b2353c09867e0acb5ac515b830c004fb4afa88c8fc9705814b290360dcb1b0f70f92ff983fc647e7827056f0e9040d5982804a926f7564d65c54fe80b17e0c35f9fd062849592c3af8a6379b8e4ae73a90ed95088e8fb2e846abe086a4a371814cfcbe308c17574b3edd89f345884eeda6f5b30641af9c4215f97cc34ff0ef4bdd36994976b0faee5e276d89e258dda9be67c1daf7513c0d5fc6a1d9942f89792368e87bb4d91e96397c1ebf09ae9308b213a48f420dcc0c20efa2d11cc4a18b7cc61c45020a49b6e1e419f32746831f60bdd578887e96f3295c87e9ce605f407bed4347348133e33d0a8173cdaa4de3afe87b237530b8868eca151ae42b117d833470bf4353db22fefa375cadd8112d0e9788064ab6b940d50fb1fed50ba4efd8ffdd5ca36944a8c167d2b2bc14c9b708f9bccdc5978337801b7002ca46975c2447f7d3631bb0ce2ef12ca8ce80df7f7659eb921380035e6a906046dfd4720fb8991cbf5dc837706d3468a290fe63a1168a3ec43f35574a10a921c84d95491276c2198381c51291d57d9c4a0873f4d794e98e5e24e3ff9f17d2976c9cbaf8104c397be0ca858e19ec0288e46c0ad02852ed4e76089a2ae1d84b722143ae8699c548f02350969e9c0d1938259d83e696fef5326d0f396bad3d346cbc2b60cfc0223aecfc8444d1fec065321b65371c3628d9b39f853c01cc5458eace8bcd66d715f5dca785d7127f3921e90d98c35e34cb8a37d958807e0a7287dd9fd089d03c5a81dfb7041dde9f372915b5e93438055faca1f8d6a5479437ff3d1813e90f9d0d75b53538ba38ac2d3804f5113bb5a969032b466875eb90cb1c1beac95867e43e72c4a096e188a2911df2d2eb979d0dbb09ddd4a65686d2fe2b0426acfb010360271f1ff8c6476d066ac4a7bded306dff9beb576e950716aea9371b4b585b907402ef4eb55142fd17f0896680508a4592d791905e84c03a2dcd93bdd74e7141954598e4477726aae410ae6c3cb83608f9152b01f3a0dd634efd6e0ad6f6c0207add99f54176971364f51059d18ff554709520cb991d640fe002d149d382d5d425b7730ae91e60f3b8f7796ea1d108f6f40d2c539bf022ca6baef6001596fdf55921f89a2cb25d3c708afaf9fe192f161352f3548e73f469c64c74fdc9f934122c4d89507c7b39159c94370931bf58e5d5d5d9b686967fb2a6cec40e3857c7b8ae8d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
