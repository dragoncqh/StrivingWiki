<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82f08eb77e9a8db1e4aca524995c087f2690f2e4f487139fc3130f609cf4ccd63eab54e94016433cc1304de01e85ae504c6bf9b07b35a56837a10ec7e220fa64df3f007e7973cfa7f12894836f1a84ba1654043f9d987e12a87a22b39cdaa33f572f104fee5c6c2fcd97f3c5f98c1987b1635e79343d5ae2d5edb1cc13a2a35dbdba7ec520483474f5127fc815bb505f7e878684fa32c081ffed23cefeb60c7f00faa60242f1a786508cedc68585d6d57196603a1e9a89f00b2251634c6c0a4d0f6d97a2ed9c224093610a5976e158b14e23ab0fb0ec3fde8e6c2186cc57940813fac5d2d27b7e85e4bb85fba2c1ee6013fa83c5d0a6bcbf653f4d12bb9a46e1209d6fcc9f5d156d227685ad197120a8a0dd47dff2619f9dcb40d273e91dc938399ad343822315cf430c74c9166e12ab500f994ab2a4f661c7597cb451f59bc8317c4252eb21cb1f299c2835c52e9b3c8156487fa65c0a19f36b5fa669e1910b2a637c4d9f84d8d26fe66cfeaeed20651922b70147359c1a0ce3badfb1a1efc95da32a80d3e4ddcd9de3f9006fa75030b3efcb51c28da8c277c9c5801233b7a77518f32efa06975df4317c9d23e4e8c8e267946d9a3b4667ea26d8995957153ff03836bfe22dc103e024d304b795e052508b69ada4db39e30cd633735e3f838de0ba2131b09c63e9189a9d79067f72f32490838c91857df856357754ea3e210cbab84e0e41ac1e05ca390ce26a4e7923af5921c5f1af9d541f48728cccb4c6cd58b1a2aa0d22a7f178dd4f125b64cfd4ed6ebe12154f49ccb72b2f70030eb14f3dc030d1aac017a63ed9aae70bb9022db9d8d4d245833304254cbe50e398eec4e022076a09dfb9afe5cae6a5ccfa9cbb7a6ca33b6651703f5a922ee5799faba96ef8190d85346f422f1838e363ac89158986cd170c01f48f0d4070e9655e621074acf6173975734211909a310a1614e2c7d4b324523cb6f2e0e261f3ca9a0ec91898f802265a84d2cc55f39fc1527d6fd2126a8cb6306fe8fde9efde2d35622607350e0eff099fe41da6c3fbd81e0e3e8b7891e7bc47421483665235edd0aa9a7bb3cbe5372a18fbf50d8dbbe7979951790d25d0d090bc7377c59f96ebe2a7393862139c2b1f2319169503ac0da314f2c7a0edb37c104a01308abe532e48520c0a44db10ac1208ce38a37d85432fb937e43118c0ce0e29a85358f8b590561ec34361d481fb00e6e74977505cb3deea37b29b5126b1ee2dee05b9b9703df62f4bcc9b3ee6fe0bfcd1431ea3cd55e5d7e88cb24a4b638e78ac4a51164815d32ddf002235b43cb84c4eeab957202066fefa0b95b8a906c3aa3ac7315292a4dce53243cfa0518cfdba5ebe341f227a8e8f4124274e35632c3b0030a95ad258ecfc9dc3d5fd1d128536e1aee297dd74786aeb7d13920c5fc6e59fa93d57de05a48111f997b16b57b27c3dd5370975a18c8182def01a4a0dd9823bafe8f1180f614395adedd4ed93d060d7a2fee1a650308be67cc7f3f3f40030cea95fbca83ed363f6d674c3f61193c44f370ff567d6ec7ab2293b256d4d361615025e949767f17923585b488e30fa1d46a651f4eab28e80eabea3037a9317d8241a4e0cbe06ea147b95e1d6da7e26767d4e0a5fdecb03c757e3470a5eac11cfd051b57fe10745bbec5d988c20c753efab80ec8712c0e3b0fcbaa0085e88946bcdbd1bbd2b76c1aef7d1acc28f19de71a64ef4fb8b08a6f1da486ceced2af205ba3fce3c9929d5dc2a1eb939c62a36e6840be2cd83e7435031286665d887fcda45273afd907cc6c5dd761953927ff7ab7c644f22ee8bd61fa21a91dc2d56dab2f4e9c67b43cf37a527b9bc80e6f7f3b97b4e3609b52f37071c4523c40398ad1f84366cccc07589e05b6deba8d28e4e07066b505eaae246e14aeab3b771ad988be13d514995456ea457ae428b5147416e3d6f18add9cade2109b12de5c1fc7a4a2473c4c3a4a211d4d22a40504129cc680026c5ada8cd74e7a5a44e29cc685078d7d6b38f8f880683a81d3684b77eab5d47509e13522f7ce5c5fae439ebbdd14814d2b7955749aa0d07b5cf4c66afe096e96fc514edf312b5bc48e0da0dd2affbc18ce10749abe403cdc437225f67dfdf5d8a6c455400d1a7b321ef087aa562b85b1dcdb297fc123de00a8f9ff4bb51e0783cdded5594a539b7128055d71aba1fa383230f35c094dbc78e8b9814806c0c01948e13208fe526cadf74c3c261bef3478e7c5ff6f54e6f045dd9f3e20beb64c968fdf50e5fabf82ce8145763cbe53d32b4db34ef68fdfefb0856a9540aacd457d7328112c398a0a0a71c7ea3eedd70d8edd0f1d8305b67a2fa494b5533806df8ae1d5ccb24ec132cb09768a72a9b948aa3fe0be653ae08c35bad84b09755318669d92a22ec3bf92cf4ce0235b1aad1ff6a63e48109a9f11b5fa384238a4b5ca04b11aa2a3df7c3592226211c6753eac822e83eb01a0790ac1536b957a371849cec7f4269e308ed08a75bf6d7d8fb6add0463d5d4dbcc7688800bdbe64eb344757d182788f36e65ad4470d61e0b6f007207990537aceb7c119f9f0fee9ebba520573ab46e1e9b41dd1e5559fe88dbf6b01c6b173eb60393095a9369967c1ddd4041945ec30dfdf9d4055c6f6d72adda0133232b864db44f9188d4d7da2d78cd6154b850b91fc1a1b33e24d19f4e3c95c333485ea7f5da0e33139d4e19d3679e6b7089d8a74dd8e151130d4d48a578eff4c6b819c04bdf668deb126452b85c59e619e294e9be5324d62d05053e4500ebcabd3a72bf01853f525e342ea334f09707e460b23e2152403e8976a94c3bd22f994c858aca103d59ccf70d17357a3bfff30e311a86729f813daefdbc9758aa9dda0da548e729851082e758e7dfc1d0abda210d23e3accffcfd2bb233de2648a558868d4814f0e093034e1bac424501ba0709e7475ca64eaa167c94c6dd414fcc468e5519942425fb7540626431fa1f7399557f7221186276607118ec64051432d5b03ca8d3055800a72a42cca61a69e8d7a05fff568cd231041a4b9e9546e5be2cd9b04ab4f449560458eb967f5b62555c5b12754ab3b9aed1fc4724d82fc51b7997820a5f167a9565a5a1a646547abc4ec7599e18c7616d96571d7b5e3ea8395893620896276a304ca009f20613ed39a1a9cd6b4ce26351c1bd5c480a45d7edeb1e5cb34afdc5bc9df93143b64cf5119bef3bf0ff1d5ce504e9ba05cae704c09a93f533c444ca7934fb539e2308a8e12bb3e09b143defcda8eb9890fd5a85d9cf23716ec383c19160bb0d547455ca2636e6b5705660cc5f99c5333f57b5c8f178eeafd638a03c7a628c2f3e7348ca7e6bde4f8e1c3d1c5e2ccd3007347eb233f9442d61d9d551d6381c0e10802b8a5e80eb20e32ea257af16f08b5b90053ac27498a77e219576232ced2d0d866c4d5577f8f16826e76af367b882f7f7c417d4a35cfc7d4234137db6786c6884e80dfd2cf6f77179628a2c78dc698116816e6acd32d3899d8b16ae29a2e1d3942c2391b541093c6ffb5061597f6731120b7e18bd9656372130bbbc0700534517b67234f8950bf584b3f86acfd3b96c6679c574e0bde66adbd38da67acb191ba487f960919436a492758daf342870d65f3f6b610e860e1355d2afb039a4d812cbbafb88011e7ae27fae27239bf418f4ef8fe6fe3f6979fd61809ef0ce1283b8051024eb8c70d6ba7f49de2dfeee23c574a2df032704e50592277be9a5171e41bf0e7a9ee6a652ac515b6985a842fa4aec183ce0c3ebd0554b77677f5fe75d00403277ad654e7aed986ced06fcdea8bd54d69452e35636598fe8287523e124f147c4e2656fd55049fec4c77cd32a753f8187468c97debffe8e75aecd0e2c61617613bf85cfcec9000a0b5b05d291e0ce4e24fd5f786967dcfb0a9e1b952f823a2cca7329e84b8616516befac1c6eda184e76e7241efd4846da22608fa369b311b26dcad19332292da47795501b7ab47a74287dc10323a3b5208223de4bb7cc4e6a76b8b4a6c54d43bf042b99d114234b9e2bdd150e460e70fbc54ff7fcbf0bda992c4497c26d8ce4566f1c1bbf922db4d50ef41dffdc97a7b9e165530c3a5c313e3db4d423a58561ff04d8dc967608369d433a2faeb889853dd19ba75f503ac0eaa325eb8827d24cb1cbed83d745c932ff28fe9d592d618ae8a7ea94faa5183d65a2586f8695a2288aa98585335157837973f9324147a444d48cc6471e00b1e44b6eccf58a09742e440cbf121769805e5c6f63a684e7766e260d4b22f51e881bd9d82d0e72e07b6a08542a9523fd9a7514eb97de32feb42c74d916320838b22ee4088310e26960695cb8660a15fa1ccfe96d459ba420f68293acdee8bb599436de1f5810445d6a8b82dfd8da3b16c7450def1cfea787f334a27b132da95916bc24cf32076b2756ab35d89a5e2481cde759a2eafdb6b367c6f1d0b40f8cbb912b985c54a06d77d6fb6e747cff32966b524154bac3f2244451f7c9b6d64acd053c8c6e0784d34110361a72fa4de3d31039f0e234002394018e3aeafe7c04020c1f1e3c32a68bcd6225152633c8b08eaa966530313e59b4692a2d59081b7730a601a7ff603920d31f1793a15d91526fdf1b9b7dda01415f037697873506d66d26445edabd316b59fc47c3a00e72ce49d4c8dac13f548d178df80ee772ee6dacccc0f25ede01d1868b55a82499154465eeed5d076ff6a11f7536ef6fba463043eb5cba88a5d5c28e7717a61220429a3001d13174b6eceb4a4b38bb55840022a666c0ed74d073840e56c2215ac433f8dcddd6a756c4f1d62428e57919450e1d1279b3d832e65326b83c77a46f5351b2db38346cfc1c42d6fbd4d7f55f6f6c97db3ea1800662c5624f9866a95b1d620ba2567776490bcc6987f667ff3b0954e86e53561ecf7d96de655649e0c9f10b7b6bd9b998be74cb89091579e2c71f22bda5330eb8db131502f5fceba65db7f366793eeea79f6d09524c13c6eeb4d68c0c8b835e6de8fd4a0b17e37b3f6fa674e415d971a415b44e7937321d2fb8b386df1934bc2ef4b50133b400ad1b89f71694e7fde92d60324cc05386e4e441637f43df1eb38349eed89f945c396132786c106443e2da95f5519c5dd2657397b85d52b75da85095e8f60df7808de08301198eade7fe0f4133764df5e6683d6736eb26b68faa3f72ab3bdb3c916278fcd9ec9cdfeb7ebf196207af88061feed3fd06e9e77776bb8d14274135be54dcf125a46b6b39da59ec02933f97834b293677f81beb476eb24ea201349099eeade14a20399dadc5e0eddf7a53d053eeb98d1e12170c144b101696e3928216e61338be6f98ae90ca70b0d67f39a186742bc5bc8d4cb25e97df49c0df9cf3727db5efbbf2d6ab84e1448844e430e87428d791688883609d4c15e2ff00ab7872c2bc2473dd73017c632e6976c9d6ea7f6c0dd971fbecf7abc7b6eb778cd24cb1e6126f4ce90879a93acdf74cb4b1a1617d28964994f7336f5739689595879bb7d1ca908e2b629f0e2dd47643b0efa4e60857f9b7a742d6859b23f3085ab313d9724d2e332d9698c796dac189f2a0cc5be6f1e1bcda9feb21a62e50ade0768149c6935d48a6c07347bb49585288b176d1a2b74ade56af16963c866f08891bbb340a8551adcbf4b018f12071dd13cc0f8b64d3c0e1e85a2c03ce4bce3b94f980b804cfd3c50d4872789f3e4b221754a9a0d3134a207b4d89f827d81a7555ccddc1e3feb14ca3c822ae3ce7e23df49211d5bfbd42b0c1939964bc99cc88af43269cb79b77783e121134752f79eec9ac4e7381155c21b3d48e7acc7652b249b52a8a51a5c277a94b240419d6d2a5e1c7671f9f4a347e37818f79d61940a33fdda05e1d76e56430a4d7b47673ca5d8a6d38504a7c903bc7ce1692c0cff2c2b9aa8c7206a97cd74ea3fae6c1daa9a1c058e1a55af46515ef457a5aa39f9221b1b0c4bee31e8c254297b19324320d9719c36c3ecd8b4d28362b96f766d0bcb71459b80dea089e5bf2a2c454b6f8821703d102e79eb5c9618f8f644f282f54fb870b6a455aecc716d663aa4eeaa96714ff8a1f4a91dcbcc66cc4494ff64ae411c9d255d249bf79c9fb2a3b3a73848485249f0365b1a66a9b43a5feb99b200062232c259cc9e80f447c9b800023512f52d1950fc778f39886288009bbf925a0ea0f4582f59b36157e3d02e7039d639d987ba84e5618d050ababc2b66b3eb7eab6e57d43ee6c0a6133eb7567fb514a10c0790a1f43580c4aff25e57e5a904e664c5f8f8231a93ae4ad7bc2022d9baa7b5be49bbfb4084c475fd8476b36cc348855c689f56cce12d2ec2d63010e1027fec6809c1f42b0bfe6d8292a3fcc2fe8cac6eb5a251e650f46627d6136d87e3e4e369cd0d63d98a13dfee7dd72a997d3a883638c3c956afaa2511d45ad574d9936d12523373efb13a824c2107e734d2c0c737d477cb3d6e3f3566cc967d7d5c840ded27a4d773ef32a4fc7f4e7ed725ebe135588bc6ca75d4652d86adb139dbadef454e5f4a81fe6f7f9f50960d24eadb04cb5f49ce543223041a9afc4d362be870ee394066e548199c838932761407a93c7d289445637224155f5d9b239fa194ca52c32f477fe5201247d55bcc6980dbac82822f79484448db0d3c48204ac35ab2f600af012b1b8bd660b3a3ece26b3c6a9cd52a8510ea66d2363aafd7bc2dff4e6fbb61c11d0cc33ee676bd344ed068ccf1abe645bf80fcbc8eac6184825c167c46ad496b56425edb289c7cb90b61c8385f51a295c46cba026bfc7e26ab08075ea3e124b2107e2037ac4ba0fa9089c46f36bda2a89e7bf1a9da03432a860700c9ebe9cbb9f78e33fa2d0888f7a675f479f8b03cf3effc0b95fda142df713d9c4a05c500a54d02d045080489fcde6521daf542c7ee0b8100c30a7d988ff0c5b0c71a22e7ec5afe8cf75e0abc8617b7fc776cbc882c8519159c874565fc84be7017e51702045e43117bb37a21adeaf9a55b4d5b3be29cb3b7fcaae8851e922516038f750975ff8fbc082a54c5e1780af1b3f2142f71768fb329279459632e0a4c64726eba011a59e5f5351fd300650d4319e8eb107ca532aa72c72583ad81e3d22a135d2286be3e124b0e77303c75664c08ae8e7f49ac838246faff9e84293688549dafe5b041e9e614a8a83","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
