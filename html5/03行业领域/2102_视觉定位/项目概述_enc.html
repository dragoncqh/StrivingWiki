<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d4848a285edf6e257c0c8cf207f7906ec5780f02fa1530af41d4de9d7693c5b0b9e17b41cc2ed5f9ff285d3ae2ba8ecbfa8eeeef680a6d8d2a713ebb2af760a5e47ce91e8ff819b909a5c3a28da67d740f982d21b04ec9bd83af6bfecc98ba7d3f729c5cd6ac463919118b10a93e8ae8dcf054502acd401f61f5edab387c0b8726a6f0ec8484ebd053bb2370f44576f3304ef2b849fe2187c6b218e2d589e2c5758f08ea3bc8fcdce789e5719b0c3108ae57f4530402e1f2c4a491add150aad7fa1d260224538ab8369489bf1791b627971253a4d9c375112df6257080a920534e03420e714cd09d59d612658b2acf97aa3a298e0cd45f624f3ebf2c8260af2587fa96e9134548c48eb5c98ee3380732cc5c74da6d102a12729fba93cf49e6e5bfafab024125a44999006088c3ecc46eee328975cba6a4157a43db1b9011ea7dbb7a6dd412bdcbd40c76fc5faa9290ed4925897ceefd50aa7de4fbb550f79eefa07d7b879e2ccd9536cbd55877d0eb4af36b9fce0f3618e9ecfdd4bc1e61eba2c431d3a782cfe18c24a429b2d123da62e96b1c2761070c99b79f2c817f1dc0d0a7649b38132e062b51ee29daff9177fb9bcb2969ba58fe37cf408424bc142cc9db538e8b715eddf70e1d628447f3f33359ea4181fa5b77946dad2636f55b14d819ee543f894ff1363bf0a2c20aab74130a6a1df66584d6a6c402c0523b07acbe8100586e6ddef7920287e52bca12ff3d11a7ace739663f74e059d40437bc0d574b6e34d6da8bb463b2e134b37f6e9371ee5f402fd4b7e5501b3e63631f893942113592b0f0ec6bac1d27225f42d5815631075fcbb38e0955834ece72fc0f0866b6238bf11a0cce25b34ac83029ae1d906b31197337eea8097905a1a60baf8336a1450c98886505b583f249702d5b3810e9bd8ea49dd9e561ef39c14d7e43573bc1b4b3be9c37739afc6d2ec9577c5f15a10bada8298a637cf3a545b882659a38a5750fab0c3f51bd93836de70ef09073a255826e5cb09f13655ff00ef0a28e41ce93486f02ce9ff16bd7606047eaa5114e8ee8911d101ca03d6b76f3d02a42129264c384d4b0c30e966caf56d1572edf89fc7caa49b9ee93f99ec0bd5867e26fdad9f81ca17e39800bc77303046fcdab6a7a95e95ba3df50af0a201fe24e305aef057dc07701642939c8ec7073a8417587379b6d13236fe96c9e726033cf8c772599998aeb0984a8536646a5a32989a55736722c9fda019c2693522eeaf79635bbe7448c216b6216da17e13b72b0ff9d7b4e16e1e1a94d30af3a47f38ceb22e18b216895aec4997cbde5e7954664386099d05f00007dc6a7759c5bd2214c245be5f85f72dff110031181ad04001dcac9a2e85082f245c9cd60c923a0e4e7dbf23789377a75fbdbc429bf884a9c4c07d9668b1dbedd311fa5e58553306c9e84f24445b7791806b8bb48ee0c5a13728c42c5c89a14b94a4404744f57afb2394a4000544eae1179e93133f598bc6308b6a4fc8ed6fccef1b59969ff90ad31f6ab316e3b0e83fe86890a215b959608994b0eb0509b9f75d71952d4f8d36a41f6957b1ab6deb2b6fc65ff5b339992aa8cdec5738b0af72052095eb08367bbeb70bd0fcd4d58663f73fbc1a510006256a49315065609a0ef748919c4df375f5ce91276f4fe411df4dce2df771990b1c8983bb4c2195a44052fe28882e62671581b54b032160488b168c37798cfb27edc85a47f9ea0273566cedf9e4807d7927c4b472d8179d5afd273b8b1eddc1a8c484ac9e1ad3ba9235616a53df227115c5c3fbf9a6684a53f852669e646b9965ba14063aeafa2584a100d052780f5ccceb6830078b65ea4d01484dd7209d993fc9b2b42163054d414be05e79db06f3ede72e2c8d321c90dba2c2ec305688bb9b78ff1baa31d7b99b911faf906731af84321bc5a3b41857b1747ecf058a3110ec26365085b22138c7a292d82a8222902cf9b39e811262fa43a8ac18ea237657f6a8366896186ecad294876b6c6943fc3f664a1d9781a9ac85f3eb289226e8b92b65b953c0ba24b5f906a0634490c5e9f40f5eaeb8b5342ba6a4f5e6ce59ab1bb4f56aa28fc87f11f29b0b294f239c3587a10181094b6e1405b7d5062d8a9c8d492d87eccc85e9894fdbdd5d06095a937408c20bf94a1b44ec63238d0faa820ce1eb41fe32ae4421daa06871464cacfda886c139ce9bbf82dbc442625b18e8437d2cb1d8afcb209d3703eb40e6f8f6db39324488c5efdcf7adc21854edfdb31c486b72f2ba55b90a43fb49cf9d1023a51cca40ca3c758d8d193d30880c798cad240d5e64cb6215808dbb4a9cccc6963936066576b0958c69dabda4753f1f03eaa8926b72a72ff53d8aae7add796ba3203412e5a52cb398e114ada0b1ba9071089af03f3b3db30a3483c58e32f047ec4d58daa4518d7ecb0fabec46670140d6d70f43bb03a520ff7ad434fec8a91ee361c9dc2a6e9896f9f8602f0ff6f9b54dfb81a5fce3de9454f05d795e65c9f85ed370e8750ddcafa0e91fb346689a742f9fc0cf0122a29fbe2d0534d64595182a206380cd1134943378d359722bf905bd85a619dc066a95762aeff87114478598e730eb510b105fd465d204d370e6ba9459bbf1937a021a650dd2dd791155192b047070220787e8a44e978cd682eae1a812d29e0f8506bdfabed7404a858f5dcf58d541ad5eca057db983dd17a2ce72799dc620ba127236ee07341f071bc980dfa1478719feff6cbd5eeadd63e8123e11ad3faf3ff5a1bf02c5162909cdfd257500c981c5740f6c271c459293591dfed0748b0be64741ea545240a05e0eac2b3c8ffae7347fdb3779747b5d7bb86935422fddd8b8f1ac45d6624afb795eadbebaba4e1bf4446f53c86de18de65f7408b2e49644b19aae8c89cf1a60e7c78a8a8c101c7857d7a2cb609fad2b3c6756a4fd0090344add396c8bd90505ffe83b411175d2e6502ab0a415a71ed2bf23fec7615a04a8104a5e487359424b0d5bd3030a86b807b4dbea80be5a0a0bda57d6a6fa420b5f51846e8490a4c723f122acbf62a8500a8e12c2109cc703e44f3948f2d1e7e08c3163f337e202ff997261bba37a9826b0607de2a95096109823a9e3740cd959ab81953a9d1207e1f78a498ec7167aad3f44debddbcea1c02ed260123e20c886fd53324b0aa8a01474e20e576ad3503c922cfb8f931c6cebc26d91770901cd52f81fb50e9188071e84ef467b4f3d313a88ce7146defc77b2cc23c91dfce98c4103f80defe7cda024018bdcfc1c67edfb247eaabe3ef352e3aaf9037b8600f6662c6554cb8d29aab547431cbb1018a033b6560cc1d99f92cf09ea8fd72e6fddb581eaafbb36895d23cdced3a43192a0ab4c7cff20c7216ad8694bb142ab92e40488866dd2e8c27fa53327209f5801fc78d27c2d4fdf916c338f9cf729b9e27e09a4c1e4d29bac1c72565a112dc8a79441b1b068d9376551da0b8e8bdecc3c62a0a28b307bd77ff1d2dd0762d513b187be4164ed688982085f9df61a8e81fb8dfc3e7e08751ae255a3899e78d4e268e3112d1673a3cc9c06d924e9b6e1aafa3a033dff5b64d102447564ede3ee8f1413871c2783e9370d7398b6a2f612485d3d42b1a92843ef77951eabd1a1c2742220beb26303938ef7ab44792dd8ccb20381493d4d6998542e211db8aefac79f8db82840cc51dcf3bf5de9f297b024c1199c4ff7850dab7d69bb6d8d6c69cd2fdb0b71840a733fc120bac6e48860250284b6efc208d61670f162a88acd26ca3efa9a268ef332768a561092f8eadf31e3bd3dcdf0dad5ae013d1eaca8def1390db12dbc36095946923341ff5f3c1bc95572f1857370dfc5253ad5b3f9bd1f4664607227d744773861006bdaa4d1063bdc3841ed0c305cb32079d3461725dfaed7acf9a7716b63ab3f0cedb42631daea106aa54bd59660458b5971a11276aa465780b3fd45ec41a50ded947ca065dc8079fbc621e734017dc5095a74a956352794027b0c384a4fe2052b74ae4d214661c6f822323468ddfe4fe3d7f4bb4472ff77f8d279d8221cef1d3e9a7e381e76c96deb2cd78ebc03a65e2421280c28e3cc00442df6ee0056f85d578ba8b90f81ed4ea01834e75945cccf191949aa6979ef20b06e5fa446f55aff65a304bc5c4b8945479b56351afeb626f970add7a9f8546a2c7d96a0ff90ca9bc9edf284666d18c56c428f130c474122b78ccb0b619113cdba7995dc13f6616be3181fb285b437a67edf4f140bb4c373caa52eba896e766a26ef4fe69faa42c9be81a55aa5d4fd673066e02ca498e3a95d809d1f53c5cf41c848da183e89469e50bce2c147fe42ed5c974161861b92fabfc2bbae8a3272766e7b878b15cc0e5f8a3ebd872c7b6dfe3840c31ed16bccfb6e221e5e1bf327f4eb9a1c0b5c2a08da70734010342786f74ced4874913c95b04bdf010e031dbe4e1fd5eae629489684c8e0ad1b78f699189fe59e84a6dea217150f852b711be885521e2068e5fa8f390ed0f9dfb1b6a98455a51095761de5908dc41475ee47e05ff9bb59772d18795cce205c1111e0f4dcaaa48df5ffd462da4bef42d089f76b7e54c318158d3b54474b3351e32d2557540cadcb9f54923c4cec251f25d8d0f1ca8182fe833297ca1bf01145d88b50917fd9a1276f9ceabf9889fa80d45ef31c0c9a91edaeca53b2f5692d94f0b2a8c670f8af6b3bb8471b87a9b2d541ae6a8bf9dc786ac2bc8c258d68f5b947e0f8b00b3f446a28e56890873a59614368fa9bfcc5e709f3bd90b49b37e950479092a5656b6f8a3520dc302aa33b4f6103209551a54d6debafbb909de050072801ca4125fbc0c753f7922471757cc5af80281cd3044640c1483fc708f2abf5f9b648eafc84405066310811c1cb2f064d5e45838710e2f2c33a0e8e4dedcb9bfeb0268179669a3b02a36bc5f245973ce300db1b724a4e78ac6430af642eb09efc47bd9495c5b9dcfd5bdd20508ef86ace0d932945e0a646ac7cd7c08d683b67ed75285b78858a56040039f27be1ba7f0c15d1acfcac36ca64a3e6ce4364676191bc0b8e7823cd92306b0f9d3a96334a47a284d9cbc49cca88b9724f8dfea5c2ad08b415290d760cd821dbd8f1a90ca7d19cb7cb55288452a69ffca3704e5644cca163c3d3f182d3b84898a1681754450731d48a707b8e1a7fb83a4edb8575b72639d14e55e681905c1c83cdb61bd9dfe745298a5b857db15193b86d40cb82239183cc8c5f363433af2c1f9a7d5262337fbc595175493cce134c179ed5b5392ebdadbb699a4e0235dee073f0c4c365def016d245450c0e9c509ba44b27afd9063f2c74055d6073da7ef7b38715dd4d701752708379bbd060ae4ef9e746a4404dc7c6c3ef92227f660d16ea8421e47d0964f559c7c1f1e0c5d6c79ed6f2c5acd2e84777da14cf2dc0cce9ce8727ca91b569f1ea481c1b21c4ebae0ceea2815ad09132b10e2284b3bc36373a89a6d57cbb3475330a3db228cc81a8588e00326dbdd5985605fa0b37a222af84be1e61c380936d81d11a692ac7781494ff907e8dc51f3617cc3186147f700a9b4ff124a9dd5d229f4d96683588d6a651a1de678ba3cc7e75cf5312ce229fc814596e8165af164313d5985fefd3d48403953a8412eb32e46266cebf04f4157693e2e9df5a448c7769c50264fd13a8f4795544d6019f58521b109e34594ec3b1fc7abe509c577ea564b1efd824c3a43f81e5778404554177755d4096d9b82d126acf76bb21a0d69ba305c42bfd9b6da74e67b7945ecf37cd6879f1370f4a743b88f4679bc78bdd2e18720b7cd7c89dcf9718ffc6ea497e76bfdf994def40c6153a5f2da14247fd0566c93d6028028b6ab72f08612bdb1debc37cde1f5b751469abaac70880eb5ef6eb634a169dcd0b8629bdc21ebf98070d09f1a3a33d24ef115568ae2d21f06e6119faf4d9cc3177b96d04e0f78ec2cd3edec8fc58bff48b9455a71f2cd5ee7fcfbca3044fa23a783c46695c0a7c4c437222ad7d0f55e464b57f3be2f72b697a38963aab08a8821ec006d65ca3465d07c09809b8264fdbf3a33cd4827b24a4327a266c44d56eb6a80c4da44ebb064d84b22151ceab5902be20c9ace04abace35c6250e0a19bd28400b0faa1e29b676397ab2c1e06f6c2cf81286dc207f8a9b1c92ff71eae3cc0378b007aa22c877c2e2698b942e1d70392749c6fe3e4f0b257be348a30e7317caa1ccdde72f56ea54995d14be8e20fde1b1a6bfdbe12f39ae6836ae785a3886167e24d1c46dd88d69e9a128f299d9f18255466b6038e1ae0d6d5cf3a42828bdaba64af8904f79cf4a2b59a0133d2a167de5aa27efa4cae3b4f18c3f0adf9ff9f5d7d3220bf5eb71ed773b80c9bb6794b74d2be16fceaf39f22e3ead3a3a950a60d18e496f411baebc0036dd38be6beea5a0c934a5ad62163f28a180b390b15be7f5c3df7f44707a11a58628a967a7203068992658ad0ff87b0185f4be130edb71b5021305e84f75828dd1d6427efe5301de83600cc5bcf3cdb36797fefe439a4dae3bf92097e6702459d19dbee836122e6cb656f19c4bf43209b004229b20be304eaf2aa235a1922b1fba742250e2c95b11bb71d63213a3a2e6ccc9aa9e3f692a538d49936e98cdca576cac3b8e9a4789ebaaa1473ac4c696a578d6c41a5e490cfc8126658941cf1328f420d5e81ac33fab241fe7449e645693ae6f5ddf4e033501ff574e569f98a990eadd73af85052b5054dc5f5502799414258509f71ce0e0aa6c7e6ae4a1b189fcdbc9e9f3ed8d2fb9de6f8db622c75d80ce86c2b86d430b1a5e5a5f186ec30c5f3739a667bd635cfa893579e91c3aa499d113dd6eda1daea903dc2f894620b28fbd4e39ea756729a777224106804d4e959e36c5878f60b5a24f106715733e36b1c87a33bde3cef7259bd6253ffc9b8154583aee9dfae5d46cb20c5b0a10fa6eac3a4a5ba5414d584c7a5649cf3c42907486cdd7f4ef12a29e42e42661dc28f3be8220fa06abe77110bc7b54753e6c18d7bc1109cd1b7602f3ea6930d49ed7b36a813e975570ec7a4ff83af690ed21c9ffb300140e2d65a2feb97cef580fce5ec76cf0879852596ac70b43c828b785f1275c0aaf91989ff102377cd3dff1a5bb4f36346fcf5753c5c374e12e33b1dfd7b1889dbc86ff6e696e257d7efb9e091142e1e30eb419a4b4bbe5ec659dfe373f6fd49b7fe7993ecf14113c7a363ce6aa52dba2067e14fcfcd393a8fcb91203acb9a55226e3926d437c9b2b915217728a54839f8d972925475ecda1f6acf089382a12ce79d6779fd2f5ac1e48b13568d99492cb5a2c6bdf314cb4c5b6b73091c004b26fa493c70ece2cea1fc0baa2098fd554c73576010bb8e0570d08f6d735cf6b8db3a2522d61ef74d4b8e67fd3ff3852c5fb1b9bdac14df8e8d6f31d5e448e167de7e7aecb12db30b9f9037f0853b5cde73b25c056c39386ecb6a7ab083415839264d502ee205a823fa7f52eda2b51e5420a1ab6e289878b09065f49c63049ed1bf3ddf3042b87cb73f3354868743580d323af58ddfdfaed61c82c031c43fe29e05ae6a28430f980e912b0b6baa52d194ce11a3239089ed233718e71b71d77d4a5b989e6b32c0bcf102068988c2c43bc3d91bf84f6907956e413b036317b900e63e9dd42079e945d33e5c10833d500146fd29430a981568679c527cfb813f9f9e09fc9bbf7fd6d60018ff7c2ffcd7450f8b70712e2b0dd94c2a01383937e9e15ae59b030e5294b326a41e35d77394ee7af2d18a366f8f8c62c6f6cd92b6d98417594e972d23c62715b2f6d8cc8cf609d5ec1242383355dad8b0e833524261cfde9deac80e652e311c622f57ae77d3a709ac9eb575320aa89343445f088cc8f0372b91c6825256675a389545f73f747ad9b3cb2ef2f1aa14af27cf9e67b441a18404369accf1610dca0de789cafbbc07b2e9e3e3d747895911ad257d643f8387f76289c991198e019940c2bb392f624ce87dbf5fd812ed04c7568eecc10b236a9bb1f89add6ca06102947d7a6eb2f18cded685f7a7cf44888dbc28fd5001b8a63a72cc90a8d863249aae60c158591f3e298cee1db7304d932fb99c117285182f9d40a5c68ca0537fe73231264cb8b704c17bc485c032fd84ba267cbd1266494b1744408c9b1d35fc864f375c1557e659f8a640af1bd377c2459775e9b4cac2677c9b64302a42be38011600f424218142ee4924d9d7840a2d6a6aa8e2c534480e3d8af7e93ad4b542e13ac50b9f11e235f17194822cbe44973e200f8fade3fdd7fece8dcb33f8235956aaa6404d4305a0f73593561ced135e51c6f47b86a3eac476bc49b0525c73106ebc1cff70698f9ce98046979c2fa7087ec1a5d410d19e7d246cab4b08bcdc735546532cfb7a97fa6b03847965817a8655ce83218e91f6f39e849041e76af98f55f1d258c443f1abe55de63846291e421f645642e8d34159697fb2ff99b314ee472d5110fe01bc5424df39042f23106a4367c96887111b8b5369d7e6b0b0174a0eb92c60819403baf278a99b22954902b4e3da3edcf4cace9079d176c8b5c2f7f633459911ac7ba4570602e2e710196c27febbef6bcf2a94fcb93b70af79d58e02820a7cb9e495dadd6c0931c343e6f56a3671f50a7e37ccb8083bac6720b29692f07e40e855a7c768a92fd18cf637641c1629ad82a7925b1e789d121a8211eed527ec1494bbff063b158646147d5d7357974d30f101428bc066930a5e58a5e7e7d9d94bfa65f800769e76157f2266b9f680aea9dc8849869b03a755a6e2f7bb7f4fdb64d10d3e523b7d083d779becab983ac9616e646ef57d03e5bf27b03b08793033e821de9ffbe6fbd1f73a6defa8002694ec92139e07b01b75496ff5bec209f7dd7f2f227dfb6bc9dedde2f9b1f2d7b375da3625de72b76fd18df098372841796bbac6bf910089ac228b8183136ce1a77ff5a510f7553ea7e44b1a7335b515851abdf1cd1607d6189438b9ed2e708808b564ed6b29a831be5e548223ac08dc10c482ca9e6e55eaf739c4e4f3eca9bb853c5f43c5ca032e3d1364fe9fc382c665bfdd3cd3d397fec3c61640563b05d59406cda2c99a2c6c1c9b5275c5edf20f1fc4dd16b9f4109ccace4256c1730227755cbb9d036d15fdc3e9399c191b0a2f493a55ee31b4d826589a99aeea5f8412966232757511c982f25438f9292f6cc6d34f0a07629cb237c6d3222393e4bab7bdc63da9083bb808dfbba6fc3ec90b3d17c98a79eb88bdd845350f85619df7d5afd32534a3969cf0ddbeb56be1ee1a74ca1b962723152e6e31231c00ad1df58a1f7c3acd5b7b276bd81d3c7ff70b6d6de13a11fe7aaa3fee3aa77b82dea737a2de5ffc14dd3beae760019b8afbd3e5060458bd53b7c228477cbb0d2b421b85f5ce5c7be526b2409cdda27bad994f32fac145749016d8a382bc2a44c311fd099de04d729c9c34a2b801dbabc72b1eb0913fd5abe4ba6ee85301bee7ec4d32aefd22aa71d51afb0ffa27c050a0d3e2be7e2fe72c6667210361ff754c52493d707fd4ad5e6a8e83e0320ff049f16278b7efeb624d9a568c154b846bf55738a0b8c716327bf1162a5223935e65d5da9dd7572dce179d4478d19f983ebd041f36e16e77b9225792b00e750f39bf337dfdfd0a0074f2b9d33aad91638405037dd9c4789c165d968c67a3aca82660a8370dfbd430da8eb2625df757fd2e150ec257fbed95af497ec1084cdd7f789c24ad0fbe089012f845a292ba44386030512b1e8ac3c0e587b9c8c99b4e48fe9188ca338b394bbfdf4e68ca339b8fe4e464b86e2d50073c467a0d399c3e48757ac89874f3caa3f126245c71fb1e1570098309276144f1c8df9783271612913526916d83e4011a1a98491536aee66a5943472c2a47bb2fd3e98ca8602cdcb6373bc9adf8a3f7235001789aee3fb3c93dc7b5665a5d60bb2c0589396eb736daf7d0bbede66eac069bb4aea0b825681d3950fbf33e35f0c59b9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
