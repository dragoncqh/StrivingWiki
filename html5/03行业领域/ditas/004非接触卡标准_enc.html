<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22fe4fc8a8137513e0019e7f985df39f179a62c35166c71b51f0dd5e16b88c48918556015ca5d963d447658bb83ff4790d9f52b57358528be8975c92b7ad4c87e393b9ec6aa44606f7966aa06e009a3fb37ea373e3a8f7553b7535e24591895b2fd9cb7e0ec3e1c2ea9ffacfafdb393e88857bd71c4cd3442c7f90ed8a945e694e2f76c82caae6f7484c859adb93e595f0a38b14405481d4bf28774af79ab274d20cb8cc5cbb04d8d24b7b31de876f13e85a0392f258e5c1d062d42135ed9a55f300532ee70266ac6c5afbd27e8e9dff83bd3db02f567dab34f83879a8914c9641c8566b2a01c2f34bca116c0551de8cf7a61a2bbeabb7b82595191d0833d522d7f09150e8dd3bad52b1ce2aa21891dcff04cc2e9f8aa21b8392e34c13c7529016c0585e7cbeeb95accf5f9d8876ab9e38bbc7d3434798ab7911765f1a76c64cef51a0a688f4d0bb17bd5afcd0d96a84de043a6c1aac603c0fccc9abd437f7fef3b2724148c5d6ea1b1c6d44b3c70ff3fcb5b375e1676c2654d292ad381c6da9cd057f35a0d4ab483aaeee8703631737c39d31ada94557300f9f57d37ec0d41765fe2d4d37d2c9175a1920d1eb8b3b93c86d207005deb307068b1d2c73d453bdb803938c6fa6b4041fc9b903419d1b1f35fc64c0d0d2dd151719a8ddc9d55e871b9c46dcc28f47cc239d63a69d6b1f857962df610284c118d05a02a0ebe03a71aa72b46b22e20d08bf3d69f17248067bd733a42062a83c53e278311fee2fa75ef55d7eaefc0c89aeb84d578a846b942d5f1ce5be79d3603f8b3c9e10601e3495512183b4fe94c68c6a9f708026389a74fdbb7ada5d8a4d451ae2b096a42290dfd214d736c72002a635297694597e3e48b3cb0dab8588588ad5e6e8fd514e5de27db473ad1d556100bb1ad28eaa615101875f392b6d8dd677f44fe8b23c7616dc35b338d208ed34ad93bfae41121ed1e232c995468d62007647e5f4a638e07eb0b0fa58bd1401e4815c050a48886e09f547e34c6460df52e74ba602393a201af0ff6f3650f4bb4f2f1462cd4aa1699f9055231996862a977b7ac04dd5565822f2f9e865fced774202cfd32add2cf1589ddab29a907d198701c510e2123ab9b101b9fac2a4345b09e52180aeec81fe5896c62791baaf0b8a748e48a026a6b32ef0cc8ee650ca87ea3af9a3a7d9953867cbf5cf21a7bb1fa76d272c2fbd7b6457ca9d62bf0851338d1e84bcb93985591a0c43668eb42a651230eba1d5e74ef2d31f591429a1dd44804885c5097a77aadf0f606b041f519c291fb184c29935813d93313799a9c20c6ca32e160caa53531764dd0da2a8cc248ec035732545bf7ed89dc55db9fdd5f86b1c07cbe3ebec28cc0bdac9d229050cb4263bfd495320c574f0bc42a9a2430320cd21c6f77668f8165617b8dae7248012976395b683187de55bdb50fce267c8e0e627b3029c834a4eb7ed35eff484aa8305b7ae5c446c7315158fe40554ad65b68030dc71482f59be36f83b87ca572b63bdb0df802abfd70e73cd80694014f71cb059833362aa065e7858fa10ffe52768c6789720ac7eb749c49016fa4cb84b2f191d5e9177adefad997f8342bfe8eb11e93eb446e0257f2542f2ce9e2f68aec02ef95ec70465c3cd0cf80db81c139b80aad55d7db6ff1d035cc5afe3d29370da4faf703594286239f2d02f2e276563617a60bde65a6939372e86ea2979adb375d2d8b52bcd6df4d9ef210ca8e458da0a08328aa6a72b1af92a9ab3b2ace6b494a7bdb3d6e69f7ea565a41d870ca0c910c482dd8b452df4cd3e4b57ec8d601470a96d79c8b59fa22ba410b76b7497c7366d96cfc550afe723167532f5b5dd07cecdeef5fd0364e64a7be229b4231a377b1cf377a053eeffd83643f66325f7081595eb88a9cc5f71a20e5904bf200c5568a5004227f0a4b6a5fa29045b2d428bd258ff37ffe5f9b790680d338886ea1378ee1dab4824e4f76d5a79181921489616c8d1a3dc6e6b163fa772c2ec873fba6b988ac99c2630b316e7a883a136c0ef72d97e533bdd1b69ca9d962cff953dd616acc1a46dac56584c61e9204cc49dae8181a26c1638325312024cd33c275f1d80750e7526c7b85747dcb2f6952f32795e9ee90c89245ce82f004d472dd85380d404e4da4cdccd249f8d342685b1e585b0c266a353ba18a334d0000bab2eafcc0904d1343b3d54c198196015f67c5e0ac34c14687fb67913d5467d8ac3b49d63cdaa7c062b4d9a4250109c2edb3e4c5489ca5b32e8a694535f30a0985020be871499e66e7ffb85c40236a29f3e0395933e74b6990d4628167137b5545d39df8ff888e03ed42cdf2f1c5cfa3e325ab167a507b9eff5c375078cfa1e4ba7b25e940b34a703e67859b706c3c38562cdca9df64e4bd811e8849cb5cd44734ca04da7698a384146e6145976a54d67b6771038d2044c6151519503e3ffdc29ca9ef0c39a85aa190d98146912dab21a9f533a21afc9e8c4d2f79dceb31874032c553526d0c78a5703160e4d515955b85289461832047525afdff3423c4db7337eccad3a6c0b17fd2646d935d34d281d02ddc31f79668d33aebe76e390dd0ae024ce05fd70c4399e40107906dc6b61ff70393d2f73a75e15f86f7bc01e3b12799136ea9b36d64d3cdf6dc5bd447225c17d2ba8073fb60de7eba425d1650169ecda3718d2a4e6fefd708c2e21f3324148eb08b05593a44be3011907bd1071c63f8aec59c312f162164809f977df4ca2f844583c22b9b5e660dd5d8f37198bc5a2b2994f8c2a7fc72cc9fb7fd8591276b7367006b728a1d126b1ea82c8fd5541be1fce923754dff6d5b4f6cc70566ade47a8530792991ff34eb354d0e5e74df40c9d2c21e5e9950f07ee80af51fe7f9aec35b64c1678206bd9cfb3ce4f7ad492595325dc3763e2e5f39b90cc156e28296b5de90011a621a43280c59082743fc3301e9de90a3e8da32bddae2b49d4c66246ebcbb1704bffa313550f68c8bbf4074707382eec8b1ac66caec5082abf465c19ceb255bc8e3ca8c390f30f860e24cb3ba21a5168d7ee52919d106f2e9c19449861bd24164919ba9651fbcb90499268c9912c895c6388ef6466e27f75cef62c54ee95e8f49d284073a8f77c42656157111aefc53a8f9c2744d21b623054ea55f8af44fc549b6e05b30eced6531b8f29d09a231773ac10c8feadbd8b4076585099cfef870a652cc90be6cf1fce04497b76242f613ab058b764c8039266d47bf652be64ab8c16027ef9ccaa3943e10e6e10968664b409664440e90fa17b5e281c62e6ece623079773f893a580418c68a9657a925d80f2e0a6dd2590d521c4d9f922108c4daab6e56811b29e069b062eb8467e683d7a376bb62c654b731b345f8b3312ec10b028967b8c566cf8fc017da9d6d7eece6b21f78f199423a9c86ce5fc70f1871603d05eb64a64740d7f9e64ff0c4ac7b89ced7cd218b60832463d8603cc23896603b83bf2be1b27bddeaad11540bdd95b175cea696ab67eec9b63c458e63675d4f6caacaa17198939bee244ea1383d369de3c954d76ccf70ff0f884edb28d3fca5ede7e5ebf4ba45e194ac3ef4294c1ae4bf1eb298a74e1ea42bf8ee95ae0828d87ac1ed49ea7700928e7764d0d19b11580506e1d30c56b552cac5adae8be278b390a4fb9e3448ede77dcff300faf32e84eb24cce9466f5dbd52eb7ff98e20bd329c9499ae0c9e4fa713e977f6d6451f6b75a044a8fd834f64b1047f79483f1e36902479cae6b32a6eb282f9593a29e1915aa8e00ceb47de4948a0f2082635a9e8f833c0d2dcba83e7b79bd459e4bf6827d67df792b14c6e388ab5e17a5150a4e8748a86f4162f79ad2fafb2aa3781964049a30550788ed9dd79dc77ba64d4069fb1157820fe08f2b6b99d42b5bc36792bda0574a97a44aacc4f1513da82b3acf73bc26c397be0c58733abf63eba9c2f2288aa416ae224a36efb48681a67a44deb52e16a3a4ab43a99154fe61b86b76d77b677e37eec410d65529932d53b5c7e9763f199efc8900ea1a2ab074d1cda87b82c77facbb1101da21204009383366eeea81409dfbfbaba747b7b9bb25d04b171ec2aed446cff53c3d38dc2355db70f01420403c883b5d12188a3fed7da05bc9b1f4bea29f8534a70f6aae2134d7ff2c903f04b94621820d6672b8e643ed32f7b36dd2bb79f1357f7d18e58153d4a0d3f799f411ac4efde758a5104ac98109380d308a1ced9330a3e2a4ba9af6f8f53676371b8980804db68092bafab310df629f287d994dae8bf183260418a46a8708de3521505a2bf78f5e71f8753cce66fcd89c44c53f67b55fb80a8a1abeaa19641e68df21a2b7c54ea09e90a5879e23c71741c5e36aa27f4b85be094ff68d68e12eac3115203ebed5407216a669c8d04ebcf190d739ca76f8cd1524b34920ebed6e23275f99ba8d85fb0f95e5fc3d0421bf6740111c1e8213699a9b0e650921f7b50789dc851419e1d7081d34a1e5bb4704f71c8f023db0ca82ac2d9df84d9d64fe97c3feac65b4a9655eca9fae59a49ae13a95b40633ba512fd8580398a6811a95e4002913490c4c83baa2a62a4d84a791e84a0c35e703d16f933ce3ce4335966b822ac8d27fb1dd2e8eaf34c0c8721b19c7c64a0db993e8900a731f853aca27e17913399a9c617415cb8df31b7d4659781e62d48f61c9489ee31dbb47fdf526179df3f6e1827e7741d3f69609c04b88a99c336735e6cc9d0ce26995b08925c5c7b652e3aa99abcd4b62e178ce76b8ede762db146545a3a717508ca080c11fd34ff2e0478d9bdcbe1d16bfc41d5608e6ae21a669d2b8229211c49b6eccb5b69bd02d5ab1342249b9bff86ac3acfa1ac94f27c469854d0230a57122c3b01a023abde2561358d2aeff436bfcf74018698a157f8cf176ca906e666a9efe002943a30b136a492696092995e1457bfca85c597801b33bfaa9e39d64dfb206a400f54bc6ae306ff80aad9952c1b446014496fff25e5e7ac6173d2056cee3b5c63a68e46a0ce2758cf4efba27470b99936bd0d7f6213b862b45dc94a8978221082de83e72f211fac3ffd74b366a55c49a1b0db997f0fef9c5528496c59046deb50d49298deecadafb919b027fed4eab8675fd9a1b18adc4714aeed2509bbcd2180abb4704d545251f4937868fd4713967bc68e91e335d419721104f2b0fdf8b43b517251005e5a8d437850e61550704c1f1df0e5ccf4b1fb4de0a2d7299328bb02ebbe40d82f45fb5c2fc19325950ccdfe9f394a21f110f55f1ac7b8a514a8183cb3368beefe437efdccfe0cfec981cb485087ec100d369a8b1fca14e00bcf078f4f3b899e8d4b23d5fc35a5c1f20611b91ec0c2927c1512ba9dfe5b9f3848137f63cc0138f36b3e23c552b38c852c49b55f299305b3b339b6ba462691ef687d6b306d6e02311b7ceab1cd21be92b0140fa74f2d0c9d688455414f2e4d1bab1de01c5e3d62603d645fdc9dcc2048974bc7997ec829d287669efd0c19932b70cd7c338c900fab9d01f97379e5210451adc8a86a23a1df2b697ea12484229e4493deefb1ee79ecaa3a0ff5ab9973b9fe7481d8fe17a139f90e42677206e9d97d18627fc0c46d3936cd27f412875897d9dbce6083564c488885b244375b905235be1fab0bd59ea7bcb1985f5a954c9ef7cd01714bb488b91f8b53df2d051420214fb14d0a56f5455c05c851a29ae73ea9ff9236418264630b7cbf660c82f254bdb3daf1b4f3a63459c0b8765683d6153b13eae8d210d2e899cd606375a997be601e893cf385a06d94226788fd89dee4a5ddc37c1d00d6214be31a8301000be774badfb3a7b114d579974fe96d4237b09c75aab37c38114234a28bb7afc38e0d3e5250bd3fbeeaf1eadf58ab51adc1dbbbeb8e1d845691abe7ac70703fc9d45d77d7d217bc181e47821da5bf8f13cd206880018ec48ae439730baf44d8e569962c294722cb76a7d21847b42e1ae3be060a58f034535dcc446e345613e7edce566b5e21ce2bf9829b63572cf4703ba8d7d503be6017ba2ccb41f8ff6c5f12e0cbd1fc550aaea53e398ed41d937c748e3ce54db042b8e33e49bcb7546d44330f757a41d0dfa04f4b91a23cb200814e2b7228f7a3838df98d242df23c04c2118b5f694336fd4d16dcd045566faa0ae89eabea5d325ad23fd2b5d20ea94a50e59a9b5cc7bbdb626d5f26f9c51f6570b2280fbb438b261a9c0a6a35886edac993936d4664e64f38115397759f329ad1600aa21c2c99d4d1b74cb4e180883e13fc17bd9e02c327077703cb36121d209d1f0f97c82798aa14efd7bfe8411f5287a0a15eabe54f19dc02187fb332dde0eb9c33fd5fdc967bf5cbcf6f80a8fbb2ecd28ce1f312d2577b1fc7d2f0fa23b26e7fc81fc0477f496d1104262b254479eec5eb95dcfe6c76d4994cbe240de078326ef5f5f94ed225ff67d1098eada8db78c0354e8c947731cf3e587a7df5f8b9ece7b7dcbcecf9a2bb56505fdbb211bf924fe29db9ac6fc2eb355f7b8a42bc857ba21f4ebf2929bbe96a83b41aa0ab7ce40067c4ccdb85d2ba2ef1980972a6ba91b3dfe695d3322665c0ea93b034e1d6373db566dc26af46c814d84c81289f2b1ae520bb3425bd5e04a67bde60ac1d7e9c81ef8846fa491951da998b87d06f4f7a4061d257a40ed0908fbc5b8270b48700c43e0916b38b5f2ba048a81c7090e7afbd01d3965884144fc94370df77abdaa40b89b660d6127d620d639cd2811e5fc958edce64eddcb080affd172decd6a8ae596d77b2b7039eb8a278117996393488ab353b867d0209312cea80d4550709e0f82ac721ea1de38190167a4ca5c04e66983a629d1f6e21b48d00c33dd73e7a309e6e830cd07ca8b39d1841003168bee21b1ed87f1c756e479256d91861dd3c6669a80a381a5c296c7668a43c8fec77ba14fee21fffdf72f74bfc86eb82cf0c285093023e3198b622ea2e6d313867b1d0b8e2d0c1b2fffb542c5bf46bd826a809bdc2339d3713a5c3b27f9d76b778850a082c516ebbfee819e409f483acab80fa2a67f369f1d7c7e375e67a62d7c641ec55f5f7106b3223dd689d84238e6910b82b3961b73529cfefff23b010dfca87ecde9b260e38971c9ca0bfe920c3e6063c33071aaf7bcc155f54d563dbf12368a427358a4d83e246c2ff67fde119c1cf63b189840bb9879af6214e6a555e355db654e158c994e0038c734d469ffd10ebb050b1325fc5a7206f299241a9d03f8444fed83161b9c549e2be69dc1dc564ca0fff3bc77b7c97a65e8cb23b55b10456196de5d2db414f94393d88950544a9cfa5270891809c4150b241c76356c4679e95df2189ba256bd64124a24ac3d8fa47d930c532e542b0ca1b71fb3a5ebdf510bbc361c830a7c9bb9bc7324897cb4fc261291ae3c64e4fc319398d05664dc8f3dd3fefa1ae0eeda5f8a9a230e1b63a475014e5e6543f3a97a5fe81c15c9f1bc189f3fd64c65ae89ea74b8c7a140bd6dfb5153d0cf12571b28900fa3090511fb73c073c7bbd15d4bd757df83c8a115fa2f33a8480ffc95134955646a997c4e40af5448a6251fdd6d3b1097f4e95fd90c6305aa28bce7b8c38e02ec7a39cf96e65f4822187737b0cbccc549f7ca47f7eea40095f639cae22acf2e07a732f45b3301d02b2ac59d53257b2017b26b995252d705d7687a45ff4c43bf43a154dce3c9d298d063336824ac6cad167ae2ec5fb1068ba7634e1c048627c60b0f41fb6b060c4344e45effb087016cb6d2bd080e787645debfbcdccb58741f50e09c174c35aa0c0f94280a4cad85e778b2d978bc0be14bbb47ab7b92ea81195a516c5af517c0a869bca75f92afbe609534810cac38f71dc87f57a8c5c5df68d6b7872d8cc066609662bf2473162502f0735ce5dbb43941a55cfede081735ce92ba9554d90ee67d9227a4bba4aa3e3ea958512a01e3f775e758cd91a0590b99c76dea4ac9a98d469fcc22717c60b823a0baf75201044f8272b9e8e0eb40cf3b9a18a6733ce10d5afd25b9240dbd38e0d2ea5dea5cb63b667db4aa69c284964846dc99dd692ac6e3a81e1be9823ef1f309073b561632bd474bc40b477ffb81c3a05cd5f139ba55c7dc0c77c0aab43f164c576877a4176f23f37f57f44bfcb147c9289024dbfbdcb519c240dd9d0d30055b1e4e36559e516ea6cb2eaa7f1e8fc039f5d3fdbc2fcad4069d24b81b2f76017658de65039d0d269fc7a5d909cc9b5d72227317184960eb5f9306bbbffbcc6d73cd75341476418efda5a23f920195e579640b2e02665321ccb2794ade76958c66f102130f8d42679560c102012d0b5d4dd90c8ebdc1d5a40b34dac3d51c431a6143a9d90597556f18a08866e01cabb03aa7f75addaf60863805f45e1c5fae532dd4ee96b9b74aa3a5e2a947567d85776ce8a05db20a7a2c54a64ae77a3e610c5d0c295d56ea23b5773c5cc81d0e127d48bf1b85d985c873c061270c283c80c4c7cedec5dab82446e496f3ec6e6b2315d411dc8a958a78856fce5b597b00a5f1ed5fcdb3e83c65486543c5bb1123b9b5c6cb5ac394b5acde7b6ef9de9eae547b24e23c4d9b01fa27f4ede7243593c2ba1cb51f509fa9f45f8bee7badcd9897222a562bb4edb263aef0dfa1c25db55b1ed4f7610d3747bbcfc8471b22c63ac3c2e96cabc3e5292300de244e1bd42bb83552444cc0cd2fc22b4576b75b43325db10d723c3d21ac35550883ba2146af798a7a18ac572dc632d017c08ae97601f8482ae8401851a03c841e7ebf0fdcd56e8457d6749d6f79e13751d0f45c9359c2c04f257ff13e2018b53564bca6db6048de40c6fb9db8539c02579642969e218f90136026dc6b25720917eef7f6ae975b3b9bde1e4c20219470ae41151c65e453446fd27d81b26dcbdde04fc6f15e5e49b8a0ec4cd7ee84f905f8059c97bcca44ef6a99dc1ec7a11a8cb25db0494a72ab5d022803023b3a3ca630c8560f34deaf7bd6aef214e4dbee0d95fc45a42ac00c21dad2555a76fe0fd7ecf8602a5ca862ccee460ef2c6c4a3dfa5a294f8350d1acda07320320e4c9d93634e297f75c60baf9bbe983b405541ec1c2d6f854c9cd5a4bdfb87f00e2880e7976be6b805cd54470569d7076e75901de13a5d63b7d80a84eb0bf11fcd7eec8f55c50a19c7dcc0d8320506ec58a04f53c9379b2cb37dcee317eb3f0170808d0d570db2202c67d6db676efc08b855cb0225cadb191c9de4ec28f99f503f2b34abc19d12d19ea5427d6d7f3fed3662ad73c43e81297082889f884c9781e673802de4b00a06b2f3486737066811abe37f8e505c0baf101c6c6ecac30d4f57e9a24926018c614966c089343a1c1fe29b0e8209a1ea7cf50aa1d3fee9277ff03e1cb198fe813709bee3b8b0e712e3b320b53adeb7cb8a034f08aa9f6af5b1a9737ff7a40c1e6bf1834d32802fcb00ce54f8b5974addef70b504d4b690c7be340e1a0dccfcea6f40f3112634bcb8a75e81330a7b9d0241a82c1b03648abbba3f0c2f345428474fda1cc59cf7ddf53e4413dba4255f50638da362640170230f2c5c2de83c0ab2411a1bde4e57b377085ef891df279a81ceb13a1a009566263d78f194e0ccf901638daafc23407161c2b69967a61a8b2fe2038b7fc444ad715945196b037d1f946365594f7f5578ffef7e90408b6b9948e2a54ec847aa44c2b1eaff27873020cd84f68d7181a5013d983b2f0e48ee8802c5471b8d8a7c5b8d00adafb07335f85a7792f15a71399d07b19c09f19f93df22273ce1a6060a345a3ae57b5caa768dbb27ffd1317380a4b70f7c290d8b95ed47b88cefa3c5a618b0ca1cc0c86f7d7a53f8ef60577ea063fb00bbe7234deb80e77f29c364872a302da083aa39af1a66b9fec8a5750586ff05d15bcd726b598e337f245c28806267d13ddc7d7d5a0657d3ec61a1c75e16f7ed151d46e72aa47c68c713487c73d62dd94d3499b2d9b7ae4b86cef501716ab06afdaa93a011bf80151b947abe8c24a06291a0f3e6ba1797f04cec949b932716e76987d44dc084ddc2591b3fcfcea6e0780fd89d28c07267e9359ee13bb2e5c8285e5a7bc5b505240fed7cd04257961ef096e3490ca8714f752e13c69d220da72c88aafdac5ab8364b8c45fae6012cb950c71b1f0a990b3b545b9c769fea5fe42162bcb16aebf484a7ede3eda91adbe45baa5a9f10a20be30220ea55bbb9b0b44283dfb2ff8829480ed0eba969d60cb17ce98d5813496ed726e8a3719038d4046f8067002081d65387c03dc381d4fe5bfe862ce4032e62c61c1c2a1256ee57d50cb3fdb745119eca94a68b00be3b906aa44a56cac1774177c63fa052e5c15ae8fb6407524d71685d16e40222cb67af9c3a8e6615c8c96a88269d5949c2dc87c9707373a126ecdc6acabd93307d6f93ec71e170e7d600687a86f0b46d9f9567d1f7d96e5110cbaf6eea7e6e9c4f52721e0505bfc9f120755076810b481e78ea4c13bdb13eb565c6fd85c556f3aa5bca3825c5ebff3d5850f89aed032135959b8d74d3cf694d5c8a90a47012a84cb71bbdc1ce15bb8dca8e1b1f3006c26909353b3b6d15ff45ab52f2215e48209816be23ef8e080fdb1b0067abbf22df6f267ee7c913718cd7955bbb8c77fc8403297db032bb27b773d14be125dcac0a2f9868aea071141f59490242d72f950e454c6a28a8a381d828eb24f9ecd0f4453c6a0e76824d98b3bd2c6a4306de3af212b9edd5c011ecf78ad8dcfe4700a29be6ddb975d263aef988b174d122383cad210beee20c684561db5a6c1689afd4b67592e193435a3532cd4e50f2396090109446a3ac1fdca8cc167abb203020ddec0f2087348b0ab0126e37a7efb653f38ead42ffc0466de76e73e453bce1f23bfddb6988801521b7d16a8bc4bf02d17b6fcbc3f3d0e5a626ca518f99669d65c6ace5c4392c46176413ce197f33947917785e17c664e277e16426009e21cb35ffa563f31fee3593dc39cde24dcf8edba9e041b86d4a63f831cc2ee5417ab33e264cab04d5f8becbab6b91f27e8fe32036e7e67c30935f787bd31940795fc7877aad80721a0874580781fea7c5c06897333948d58cb394d633356cc5bcdbf708f83a478a67ace142a33bc661940d779b7c3b7e4f56e9937b173dcb1f5f26ecf36c94293d634a9216cf3020b7c996f95647b4d75a1b6b9d42a4eb6094de0c0bfc4b1ebc21dd4a837cb307e8578c4b34429f35059cff66f145f2079c5cefa9744fea841fe404f6e3bbe4c8aaae326dcbeb8bc5b8f18cbbcb813bf9910391343f83a309cd6bbe34a6d4586ece7cbe393804e1c812b6d53dfe899e8f610a7e349403d17b0b6454faaa241118b4187801cbc0d099bc9f26d555540bc49810d61937a7c8b2e22c6f7c877b8135578081a44d4a8f94a3c733193238b0e2771b4a2702b3663fd4fb0f4e19c39cab7cd5eca4a0c6b5dca686838ff72f95c4da29071b66877787eeed0ea759da494c1c93d3413522c69422b5a3c3b43e2fb4dac98335f41067fb3a6b5eca06783aaea816675324b02846c7b9123b0dd982dc7ed5ee8ddf4088444cf01997db457242e5aa425ff3fe77bc78ab26c274e614a18177bdf0dcc4b05517ff79838daf93229ba5f963f4b16b22090b3e7234084d92d572c954a3a7607a5cb563348276ea4d2dd125834dd6c0ba9604dca81f885cd35b3458510c6f3fb27f8d64f833a5eddc3b6d312b8d5b2c9932f327c3277c9bbf790b0ec17b029d472e44dd45ff0d8ffac80dedb0ff15506cb8ee451f95b8ba5a626d93c20b0566d3cef6f9c0e442405532c7ce36a22d5716b00dfe02d5e01bce3d561746c05408da8c5787c60321f788bbd7e34d0a6e4dda4a51aa5fd0a63cb2c5235c86102ea75608cd7f2dc7fa1a6f0fbc497a048534a21ac7e4b9cfd53e589e4a27a575222cd3d20af44d80860b79d353554b7d87a313c44dd374109fd0704136e0991564fae44751e2484d50319ed0777798eead91b7e625db9835b91fe7b837a364808f39d181bfdb6b0381eab63e14eb9d2a4c2a1d5ed9550b41d7e40d4d3a0015d792d37974de0014b8af20fcda1fc40cd3f7e528d91253c07855317f2f62e81d4de0ce33518ea51e1a810a9bbf917ccdc6a99c1d9b01b48bf0acc8da31ab1a9676d80f3ca53a6d2e52c3d34987138408ad06ba8eede8a15352e04e17de1e70785939157cdd568677a884ede7265e2d104ed302bd51a5e177f6368f67c75bffb0d64622a59a4530e74ca6fb94eeaecc19824c3b4a47456f09c465be07d7fe7f26d4dba8fe5ab7c0c800d59aa444bc913436bd50f0e8ec746196223412df76a2cc88a7367375aa7f22dda54900144e939670030df06b26288731698f6b9ba33d8c10a4eeb2dbf9218593a2494126a9c0e0860e0eb86d276cc8eff8011b432c5f462f7362c37f30c304f8d49cb36efcc9d2efb4fc837415c5b6419827c693a03c839ff9d18b6cde440c5403bedc59295501ff4c1e5906e82f5e6e03d9101cb67b19aa33796d83f0ca8850eb2416959e62fb1f86ba175562dbc2ae34176e982db6a9e8ebcb3d2ce59b462d3a618c6e7ee401905ef2e88e83b49cc450342cf51e6edb3c0de7bbe551550fbd0b8018d71a83de693a1f385cb9b89b9059bc93e7816d08ed26bb012dfcf6cee541be6b55a3a68c3a7b668e788cced2da45376548c11f2753f9a9ba2cef0afbf857e2f099b6a459f378def06dbea256da570fd9b25d89cff5a84131c6f71602720f7dfa7221eaef9c9f78f8600303a578e84ca289e8f6522ea1dde81cfeb91f2d612b6bd9f5e632facfe6533b11491bce8bbe61d366c2bd127ec0a9c718f8b90bf9498a5f478531e81fc748d64a79fefaffd9ec47434759ce3a928a276af7c02e491056cd00d3025234414c291ae45166244eca8deb335ce426c724807107a48b92fc727a8a9595bb95685a6341bdf4e6dfb33fb5e5161830e56ccd5a980354c9f20cf433abd76374e0b26c625581912c04994db2e032093389d73d6a108fc3b84a412f93727fac58905170bd4000bab03d8fa7dce0a41d7ee946bc9cddb9b49fee364af80481099abdccf84f24c77ec1f27dadda22e9ef03d2428318aa67f58c4db9e9c758b4b571c3aae65fb928144e83d56bbe7f899008fde31eda49d69000352c07366a22e0f9ae2238568e748b5b654483e66ca7c6446abe6397ad81dbb9c7d899836126cba880b9eb18e9f6ee2af515cfcc3cc9a3433dc3d31e01f3376c37762c0c91a48bb920a1cc9d735d3fbde8ca0a6c03037068a658336ff21fe670d26b45a15d02fa008cb110aa2ca0ac729737ef05a9a6ba618853f1ce4fcc9c90af6757e1ab5b932c5526fd92bbed22479dbe81450de0131077edd4d44e59c775afff2c4e96e6ecf79b9dfb9889b4e9d2739c916d91d246bf78e9accbe886e8c3040ff11a962d98daf9f3c2c452eb03836f9c5cd426d3f38eb59770da2d9889f0dc9f35bf43793e53b08784ed5deb05ce4b184e15532e7a99baa6616b80c936dde3c43ff365a554a1ce167a293de2a083620fcc3fee1a673498da5e888c9d0024f055da20ed0b663b6386d5db3b15d2eda5500cca46c971758601d365688cd18aacbfd1bf2cf03b540bf3b081e1270563d04bba2f858c0dc11ce0dfe9fc2ac795586027f721d5de430cc227c18e8f10865b44a8315e54214d6d54582a2ea7b7aa3d277513d338e6aa0000cd95a163a45eff7190c305312d05a5edeb4bc0cb875b43feb52d79f1e75a69e6061e85d8991ee57799d7eb0e566749826e60b75cc82e39c9c1c9af343bc41ff175669d90daff0cd3e9db8b7e5c51f0a98f84b8fbca8fff9acca3f16e5f6630f0061b87ec9ca34f647be8477dc8c38deee3f3fdcb408427f67729a37a3ab09a512e77f26575174790e78ea3da2fa36ddb60a244a780b3b8a15a30ae0bd2769048c1a69d47dbfb462ceb3ae6ffa449d1ea046934a3f058ff26cb72b856d4d8469b45c1778edd98783ce1b1a629f1526831adafc171eb406553401aeb785e20101c46450b179a00136e81997c266dcfbae6e87be63471519ae5330040eba864d30f28d77df43e15e170156716902ab6d4e29e2ccf2f7812727027f8ad8e27b05a0f22a2aa2b9b62ef7239189a70417ce8f64991ecdf2e6c2762f50f5224c49a6d642cb4ff48f7f61c2e1de19469230d35c12782830abf70f5db6e5a420de750bd4cf6cfdcd0bba4e1948edbf7d5d1241c442e3f307950334a4a4e359a3ac1a480f923536c8acd7e187a3df13076ce8e6d41c9052b6dca0611a2b9d5ce8cd74044d24a853af86fc06370f23ca90e4b05ed4b3583d5a2ec0a0a06b7476f91b9a2e15f6f27eca200a598495cdc8cf5f53ee3342176072c2d52d0e35e4a9abbb2dca53dffd5fe012db9fa05dd2fc67b534ee30d87858ff2b868203a1f74357f4a1e582dfa151e663fd76f5022337f8f993214ce34d25daa7bb8a7870be342cf67372f36f8a1be15c5ed6c8b90721b18f77773bb35c5267a3fffcfb14b18df98b23a602c5507638e26aff45260692c6c9f2d17e2e4df05e69d715b99962b106e5007c2243d62dbd79b566abf8005661949e3ad135271f767841204c64f133d14d1ff4b1c2bd5eed5b37231d0330ed8a32dc21dc7a9e887ba1c00acf9c9f814ddbe792fc4ab049d6074a13b3494f887a8d925560e12b25e7353e38927ed415c3c0a44ba827e85686f218ba365fe0b7116560ae783f35220a279a43abef740bc7959d660347b07eb9a4aeeb20766fb5ccd1eb4a9f8d26b8c71751283bfd5e989af81c8c87a62f349431792b1c9eeab79daa55537d6a1004621ed62bacad25aae2fcca05265e8f492eb21ddcee50680dda4078bc8a46cbf7ed604b470bf48806254acc31acf7b7932b2977433baa082c887b29533d1b2f5b6eb6175d8a2a38f5b1d9bef866391bc9a58bca0f92de1c6ff77068e7ab8e819408de45f4e3ea94472016121474a5505748f3f4ceffd5b20ec648a18f81c8d2a81d0728da29014528f591c396c553b5933a342775a44337ae2a7d67dc5ef74cb16b52ea5e09f355d0a0009918c909a951711fb93d5bc19b36d59ad93c0bec4d58cdb923e4f39fa1b0c818eb6087a8aff45a32a7b5787bea49049017c47640b7ae6bacdd71d53b0edfbbf7f94e8609e91c299386fb46190b4965307493fe4012c9796d3b6a2c4aba10857ef5b27a0f6da675b4703007b4cf65b27c8f372fed03b473c1b996c5368b4357fd4a52e63e1580262b6035cd2b92b932980bf7848f83ed58ad5ab1e1df88b08789ff5152ccaeda67142ad1293c65eac1e78c161350ef1c14be8c06f3a76dff5732e349c4553aa5cc2f34bcf97fa663c16985b657ac951fa5f9976fc32cb95d824af52f97733ec22b175e662834c56cf7e4f1f2d794730058372cc3278d358ccfa5324472e150525bf97953d0aa1304058988ee3ba131e132d0ac5071c830a1186541b5dbbbede23e598ddb673b76ea5958923e3015ac742c0e975cf1a5b93f3fe9ee1a9afbf55a56db1345da8f55c8eadc944512ca7bb2796009fd1c4b0dadb9e3ccee6397961ce22abaccf3924126494148275fb884c9bb255ded2bbb0c235ca5f9a0384e458e800766c5a6eed2839e3f4ef7e328a36c5a507411e5aeb5bf88ae983d98ab32c0e4b8cf25f65efe84554ba16e2bbac590761dad78e5c886648e362d05e812d3058f96320b8172209e018bd5aec2b9b428a721519c1ec9e87cf399e0e4555fe51b3e742032f605451816e591acb189a8bcb29fc8b496b2096c2d627d34808848ae1f7e137aff44413d4f1c38496d4010de9ca9932ec4398d8e54483b9d3421729d45badc87203b8031de1f83fa12113e9ae2ca9621f5881fb006875fa48d33d7a2271c5750a272e40379ef7b898b65605f2ac5b00961eb8748d96bdbaca0ef6723d9971e2e1b607914090c4b20bf6035659c7620280e5473ddab0b2c55fca532dd988709407d0e1675db988e30632ecfacda5e5597c67f8c69f55243c044ae6fb95379e27b983d5ae2bce1e674de97960cc4db3f31fb122bff0add4274874d172373bace81cecd4e226d710d2a6fd031a42aa5495b02ff91421bb5543c86eef9eabfdb67d1bb77890e45c92195a77c248359043e5232a032db10733674baf0744cb952ef4421baf3275835a47e104ce6a9b82c998de7ee2bc8b56b1e6def5c47147a03f519606dbf97c61d01964c927ad49e034c3a21d9d3172a1d9fe2904a54662c95c8e96bbcb107c51e138d8ae8d0db2124121c440c2c01f19c64f246c57b8eba8157adf7591dbe19c4c65a827ceaa7ff88847fb55f188c551e8b464c76e0df610f82f05fc042e7d78ef52eb20275affe182d03b93cbde4496523a14ea423426d5c4db2e8b269db58830cfbbefc9561b1dc8c9f156ca6b0f008ac99b8bd3995c6e965005304ee47451f0f7453ba312c71012896d3ee7b0e28aeee79e3fdcc209c4805ec6f24e2755330755ec1fa8533ef27291bee1952d9e4281308ba1255bafde332e2be9ccfa134b2d97b43571211bb63efda203bf9e434dc0b953531d9ee038c072460b90e4f38215ebff9d7577f70661cefdf3406bb4a9ac09e61a3a810a30e5e56982fba491bb7d8cc2bed9c36b62dcca61344304e1eda007061d25d4b3b2e6147c401cb176448ba91f90c45631a6f3870dd573671cc5564aa6ede28020b742574c4ba6d843e65d10f9c65f017b11d7bde3475d3a15c483444d424943fefc2de7e94366d117dc51f9faf1fc93b4e4c669c63a8155e7e14936a1595d9992e7030bcdd90c95a8a604790d4836add323263018d049f4cfa7154157e1a7bdf66c8e5f9b8cde68dc4c4e8486fcb7f138651d0da88e570f020c941a50fd70f57a7b12c6b8e6e9a3e9bb83a7008be970b8dc0e6af017de5844a773b4dbc41e9dac9ac0e3aa0a73af3257b35ecd9a0f8b6d2b0dc7ded1cc11c4481775770e2f6be9a1c51d377371b03bb17eabb197a523b2115ff20a51098119d4cb74647bce9d9c63b7710925c6385c05b4774384865d11b8479bced150ca1cf4236c043b55cdf01feff9e1980ddf247e9f9d4e0687151f656455a9b425db78fc236612917f8aa26a951d0904bb951fb51dc586dba878db105a78b02bc394bcf6d49dc734817483b5c9253abbf699300987c43ef6bb62f59af2b6b822a77aeb9f0554fed798d606763947db65c6841aeefd6634853c03ebb4aa2a32e1fa712e085c74eacf8d872ff26c72aa075b9f76e2b77299ca9d3e00c708a49ecdf051622bb6a67955847c9bcb31624177ac27cfe2b600fecb39e28eb4cc8d1fd10222b2726559bcee8278feb8e714ff77bb4ac5920df9af4db52403b90639b39941dd400d61b424b7a878dd8b1153a4ecc4b1a29e5a5a8c3f6c5b4bc06aab79188bccbc4af16db88758ce4c863cb46f643e200691975b60c5508d50aa176974a7d918c290fdc835161723b1063d687869b73558216cae2256616348aff838184d2d026c7e98205692107603a3fc4e01a823ddc63f5e8747f0cdd646c45e50ac729a09c57523d45e86f86a2304ba1dcf013efb0ccda5215f452986254fb754c1f9bcf4d3e64c8aa2372055155b770c01955119a136a63ebe83e2e226a09111d52f6af6d4cf80365eca2b2359d4d1f9d4ed042c8a3f0eb002aec415224152e2525ed1f850378f760f1f2a398c9aee40d9a6fdb46353d9cd82326285ad0260d83b43d30d81b9d19fb0e34f4bb4a6e98cab3e0ac1822d06722eb1c31fc97b0d826609b4165efd7562cfdf18f0b90a98fdcb441d02c16c3a8d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
