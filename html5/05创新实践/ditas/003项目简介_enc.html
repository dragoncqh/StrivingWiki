<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fba96ca258cbef08c1a28ca24d6da1e674d6e2c1daa1e7ee5174b1156287f4ed1e240881f00446ed4f219c39f6b6d4b21bc7041aa81c1089997e35f6db31b44da0dc94d4a597d4c2bb54b5318ec0620d4a3e5d6d60ec1e2057b5fbb867bedd089ee20d9bd288fc7071a5e2f6edc94e0470de513caffa06f9627988560002bb718f2ee3f191ea4bd02c0bd45b278f3de13afe474ca39a38b6b765540b79c5d45190f0e61a65f78793ef56960c792dd39e321d7c5a4424ce766737e16d0088f84bfeac4441c18a00997a76e55e2d1a31099993c9afc50bc0f934042713f83d7d3be0cc091704aabf584ba635178824e25dd9e84e5ca7d40f710a56812c1e8c3fd654e28288612aa3d386adfef5ab749271270522a7c07e7f85d5b76a3bf4747d0e0f127920cc37300a9228573fedd46356897967d9b8b7379ec533f3f7d29e19c8d5c9dde70b38bb0ae05b757d389b71bda28fffe399d130c054ce5cd2f2e4319cfc04ce517816fa6986541bcde9dbfdf7021baa8db283b783f66ccd21bb7722421865ad2fdaffc798c2aaf9cb1bda2964ac9f1a5057e3bd71bbf8cf2078112d8bfd3e8c0cbad1b6b9e0ba2bc22605fcee3c86791850ba288d90e2a080f22e7f4e696512425fe0f58e55b422ddb58b1d9e4df718e6cd8f52cf5ca17364a8b3725ec6a3fe178270de92890ce91297a20898da5e3e813bd73702022dba3c929545e426cce7446b0b9c9bbc5a3200d915405256662594a9ad29b4631546fa8a53fdbaf9259710e262f807a1fd145912ff7e227bb4da22367972b6121fdb4014126278cd957927b21e6089292c6d699630caae369372aa2a8c1bdf160dbee391e78ac752c555150fc5af31096d2648ddd229266fc456f412594082f0abf6606a1344415bf2b5e41c6f7d1fa7f7129c0a1ab49b3dfaa49aa429ab1240780058ed3fa8a1c481057ac02c87b150f0169bc7ba2303f9b866a6635c05a89f0da5353ccc6705a2ef4c38935e7fbaa44c353e1ac9e3ac6582ed0e176276837cb855d7f50c8d68d6ace9dbb8a6b84e54c01241c2a0d58aa34f85f1f0b08b8b968121032e735f435c16740670576c85c904b5b3aef359398c53c731eaea84630cfa1d938db5ea2af770947e4ef450ddfe923006130e3c9b18636a74872b4e8faec2e09aeb4d4832cf9a27592e9e660c125bf6a6170e88fd223075c13b4a76a48967d8295fe24e13ca24290315cb5170a3d6f789df40be7c2a7fdeee694a6bcafdff464c8057b12ecc71b8ae9769bf2271a477107d0ec5276b81a51ae0946d818e3742147c3b351c53178f9c2df581afcd9aa4cfd74f177b3cc18fedf0b5d808bb11fa151f734b883dadd76b3f2cb07a193a9bdae1f0c05cbf417f3cb8fb19279c3da09ad60785749f696d04ae5fb2fc2a8b0770de47e9d56ce2965bbde285f39cefef6d85e58cb126441cc3a7689b7d00c904902c3388ea7904df8d5134595d52f8edbff7862abaf1c70ca41b4e8e406836708c989e604b13d31e5ad717106c3e715fb7929805a6fc9638bcd6e54fa4d9350ff7c596d2081f27a27d5705df256e8e019696f94bad0845f087a93776ab7f9a8905143f126a6d2804fa634e2b83bc35e728ba5e4d9c04f205688eb7d3952b0201b4e045e81c7517bae20f0a690d170f41f40eed6820ca60078b9b16c6bb9c40eed4913cda05cad04919f86ea18ddf912b529c340c5eb6bfe11eaf2fd8903369d3dca1417545128363030b7fbb0349b81780da1020d37c91858b2c09491d746866ce864130ea79017a5603144651996cf357bf8c9694a16f9613b858297b8979026b67dc016d65848a3c413b3f9913f093e5cf45ebf8444e3f7a76d2e884a0d2833c28d4e1e590a0614054e61c56b3a00443d83710c40679276d2ee5a42d87a97ddd536b51d2763fc45f0ccc19eda5f926531b76ea453a860522a6221ad05ac4a16cccd10d2d68f34c87c82c01b8da35ef38a143eba2f661053fa046522a89674b296bae2a90501a9bbe03feab3f4e91d9c2c2faa17270e2ae94a967b677ff7fd57e5fe97964105b26ce01582300cfdf57a44fe6ec7522e0ab6f58e41be0596820eed1fae012f8fd77947b92123cde3bac3fea6406b4bb8e21a403e131a81896dd8d97a35ce09d0c32e33757a3852ddacb51d7582c6d6a2b3589eee7087a3df2041afee66af85353c65ebb3ebf1f792eb52b8a1997913ed9859b96c237cf4ffaa448430c2f2b9a60786bee7d0302e7d0e442f006fcb8a77406a7b674356904d8a1141bd0a088239dcfc4655a9c7a55030f8a0254a597141a31f0adabf54fd6b763dfd947ad27385557f0717693170c1d1311c8d63124aa529137ef320055d757940c81df6cbe49be02f21a652d6a8e59f3b5737c4a9d9fcf36b434e932d5985e2f4282d14b155d590b61d48dd074a151502ceb1137ca9087bbe563fb37a41e406021cbb6337b20f6a4703259f2fb1b62f40fbd0bab1798653c18e82db16f25414aa96a002f632fa0f0026c781adf571ef8811a68c0a692999171d7e721189779e9161d4c1c243daa6544c4a99aae811780ee4f87acb4eab0ced296a615a90bdcad2690ce36d0dd2b8df1865c65334aeb55c4303b9b98ffd058baa815a863abe3ff5ce9bd1ea279965f1865a2f389d3135a41e4b6296375b9147a0aaf865bc78531bafc2814b0171c2f7eea273e3961d516e067124391eb4225e2b20a0726e0ac36b64ce2cf3898dd62cc9910a0d6338685cf5437559c6cbba135ff89eaf387f989f0834eeb8fb326a5fbc12e46574dc09b0cd0e37b33a822923a62fcec1dddfa217b17b57d87e5c3b35bc466320fd58038734375dcaba8cd7ec5548f8d7cb159d3f992f87dd922d5379968e7d1d075f4efa1375ce5b8528d6c97c9e36af1d939b29c274eefe81cb58f9e807fcaff9c9743c41edcddf4c0bdb17aac357a9c72ce09cd739e5be81b74d333ea944cbb651f88fbbce6a98dc24af2f6e490fa33c94ff5b6772a15b6cfefe62c9170f7f24b604c3b5a468f8a59baeab4e65ae7655e677e7a1d499a10313c9c6043e709c0b34fa68bf6529e74d0c2b00767f37355596d48daa6ac9565644410c3e6d60d7d01359bfedbf059b2e222999fb955b7f42d59d7668f6a75b510a21f1c404fc1f6e94d6ed6af3fa841acc8588b9483d9024117271ee9fc84479260f57c0da06309886acfd8d8f991e66909f9810b7059282820c13314a21787ff986cdc4c6657c1f6a224272a7551079f1657089029f04a12f955e7e585f5d5d1da5cb5b9cd4dd0de211e8d87be24a1f2930979407fa598702daaf97e17a9618d7334e141349d5e30bbc0e5cf5a5bd989b9e550e031422aab8a4d6f70892865912e0ca83e7776a563d51fb6aacab88934f3b1f3a7a9f073bfc55aca12684e35e5911abff72d62c9823942ab8647b0cd63c869ffa52e6ae4d178b40a05026185d4a52bfa576b861258b711b5ad304a114730bbc68845b2e0b559e9ed57aa4619621ad9e9e86deff182dc70cf2e544f5bf92a6169786c19d35ce9883a3f45e96b6bbf0ad8a3b46f2fc541bc249abec48cfee0cf830fcf3c8b3eb47a0553aa8c74f5f17ec25bf12df08d91e0215b6921f15188452a7bcd83cedd72817b70ef8e184d0fd0ebc2b71f7f39c1f99195e197075d803a1a069c410036362c09944d4a337f1b5bc2fda02f9c64c677760647390ecda0f557f32a597116fe997920c0e25a913f8dc20945b02a82b50e89ed81491f360ca3c14fd71b60a58652a2d95e1e153fc2afa3c6bf3fad03961d966cfae5db327c295cc25e9d2ca109ed35eb5972a27a39b25ba4bf2fb9dfb0deb7b8687834922d4e369c15a7ff22402f248744f73e7938bea16b2cbbb0862a21236118d8606b9a032459e17ca9531c04b763ffee67b7d1d699e38422bc18a101e8f5bf61696ab447ed76281b9dfb4b3d158be76085ae26928bbf7fc4ce2e0d15d3cf3f369f37aca15edbe2eb9f15674effca4b6046d25b70339b547d85d86e5103f7c3e7bd73bafb9c846c0fb402228fda9a57d9c50c7834b1d55d1d2744e9bec32b232b3984f83c9c09f59568e4221f63cfd9fde5df5600946a20cee787e65e1dce2c420a3b89afc35850eceb438d71df4a65b967f6b9d9bd86deae7d447379005a525c2a0f1069e2559b4e6aa3727d604bd7c2b44344696d59655e4a87b0cc7cc19fdde9d2bfb290306d4b60c55b5d4c68b0ea3e8ab8db0a2be6710001eaa02248c2dcf42bd7a514ec750bee045e71124371e9fa5fba0b9f96f82b11ac0a9dd9bfd2dd6cee4ea367ee24912fb5dab87b02cc393bcab11d9a7ba996474d5d99e4566459fe41f9f4c8f22bdeaeefe78f0eba27e899cf50d7bccf2666929b429a02852c3fbd1078ecb1dab05b72c87838a2b5ea8a8906f42dfd39c7e4289e2bffaca9c333a58306bc1ecab60d729d67a86c32dc0648ab14960d492e825c3bad2a5801a9f16d4661333319046a6c9bdd9bb20f2b95169c661d63542217fb421e2f6f392643b11a10170c56096f77f1914852718ebbf2def6aa1b7d32a5cd44b3ae5c00fc67f72744f81ce7c3a527fda1b185394b1ef2229c094263cf97310a45b67ad3557259f696e84c736aaa209d1387a8aa61b36af4ae00c871acd4100f6dfdbf21d859a907d4de24899eea6bea066b31181a4a16686fda0785d283d1b892bed84a86c8ea631240d11d172e781e4994abec6ef05eba2d0fe386c868f9c81a4b4885474df020f066695010d8dcb0b858d361ae9e6094b4f6a55cc5a868215e127ccacd01f5376fea0e431b0615be2210c0e81eebd07d4f994fe6b1c965ff0f971dc3825aad34ff12e9ad9ba8691ff38cb549bab9a8b36396372ba8fd7d3ea06f1bf94ea64dd968ced7fe78630c781e8b88bcaca5f788af4052a8a656ec7c559f2fa6555e74296aa824efe45b443d396456c39b275ca5bb6e64ce68e4db4313e1e8ae551ce711456f117d43a45762f6af2c68190352fb5cf5dffba894f2ec1aaa53ab02b2b6f12dd6734ce9652c48100c295f4bb5c152c387594ac922308bf095d13b607c4fb300da38468a3a6afb03a2e0023c21ddc342e8a08b5393a8b9afdccad98c6d37e326b1019552242fed48e965d0ca613092583984fe22578179dfa3c0df3a359cf53fdbc4bd778e538909e24a3f1a6edf51d6bd5995f6cc6e1b8d1916561d8d25f174a32e09e638df0151644c02e65d27c15b2051e273565f88dcf092ff9b90f4b8d1b2070695c452edb06424b95c3c6d12cfe7a5ced4b7ad44696c55046df6f404a19a543733c40892ee08051df56377051048c59a50291958f9115b2b0eb0d0269c7a1e4a32584a30132e072b89e717cc3776a0e23d74cc19674fccb2ccd3a815b3ac5f558b6849d9fbdad131133f0ac758b8f5f29700075cde86c7f85afe60f2796955eb73f4dc51c274dadfad782a81662989c01d2d0a37cc1f893241477c01935df70dad5b54877c8389624298d077bf42c94b99fcb8f3537a6840314e1bc4795940d8da28f8428444faee9ec72c91e1b8463161e07571b4576355802510ce01b848da2d92b3577e5182f95562f2c8b1ef83c7959dd1bf7eb7a3eb3c70e3893f889ff176ae661679ffe2f67cf47e29a09dd9ddcc3d4382aeedf06ac851238a3d4011d443a1c1e7d82717f538280d800ad1ee84ea9e7c2225094e6c059fb4603b3ac30fcd9b63a0496bbeffe70c435fb9c6c6d5789dd22d83c692f9e42f90538d3afa5bd26b33e3d9839ed2af1faad0864a3830a64bb0423d2704ee97781c3a3502a805fd87a086f6f32914b407b7458980440678dbcbecb3653b31b15ae43d92f2f5acacfed2b3ed002056b970e091d9d5c3b926d1d8957230901f0ffaf8332983ec9c6fa61bc76612625e41c7eec89121c816d2bd6c4134a060e96f8600b942d5211674a3f672447484f9524a95763641088da745a17dcdacbf78157b933c9d9d8fbe3dcd318d0c7a2dcd3658b3ed9187326d6ca8fc7e5d846408d97fa4c54e3a9683a8e16e6c8884f38264142dd7e89262cf004650fa490627b389c20a2505e40c3f4343bfd81604654cf0b8676b116f02f29add6dff8b79b1bd9f42e5e3dae93fe6c761e44080c84a22f7653279f3c78f9ce4227f0bb4c0f80d122fd2fbda886f83eb3681b91f5ee863e9106ecaad891447b5ee072b6cdc7f7092b015c53f28b99fe6747135797a63f3f30e91bcdb5373be1e3fa911807db44d107daed586ae52da45af0292181829318f4e74df4827adaf5d840e1a78cbaace6ae8f768d3b75a46009029391c4734687b7222b779ea11cdab3389f4613c3cf6823c3b2233be0f25395ead8ec4d8d8863736373300108ba232ccdfcb0b8de697e2a29c41ddeed8d3c5d62f8d46a83b0068789c80d47944e5ddf36da7988d7cce51dca5e82bfa67d489dca296b0ac9196d66b81577fd4cea7a513ed7045133ce61634f371568215263b1f4cb50591e61cf0c7da74055474392ca5f404680262d1049d9e3f38a820b9249c8dbc5be85ece58823403384adae524819071234001b2b5632f7f8bb719ec99215e90fabf128f09dd0450c1f1f86244aeb0b4133bbfed1b3499a16f8dcf1f31035456c453c89450502bcb89b12df64f76223a57751a200fd771fb81b18c369872bd7a09448ec54aaa520b233e313b61688091f0fb130ea3eb8d5bca5dd7a72e75ad2fe33845450b0512fc65d74999d44f7871d8469bb3fa0870842e121cd2010bd4e7ba6331cc168ff8db2ccc369a7614d0fea3250e808787829ecddb899424624853dd029b958d99b58260ec9ca015ed78ac24ea8b0e3f05061a62d2d5e89f5925cce7340f5eda666c816f48932d8c56a43b413c863234e521fd0fb9fdc4fb0805479de7df0bd68acdf93260841eb881086027a0c51915fa04f7c8a465ddb7800f39e75244010f3cfebe2e82eca4f4b3c40e012792fece26b957eada51129d2a7f637d060439bc50dce180dabc83508ffd5450bbc4f4eac3b271723a944ecaad2b2cd5376fd2d6a494a825dd69f71f581425edbe253b61b7a317f91f07b8ab186227984fb328d7e11aeea9d0d1b895c1ca60a922a2d526959efb73a36b1a3e7a9eec0c8f2859d2aeacb71f17ed829a810e5d875972af9c5712a0ded1f323cdc468bdcd1556325510c4ddaf241629844b1b21b3b7f96250dc170c11a42715a6d53d348365954083cbad207c1f68f748468d4d11f39e7d324cac57c348ea8136e16cef4521e5f453bc899cf3ac81949622c704aaec42857944aa775ae8e04ab1b9e7b99ddd9fc4ef1cfd906c815b8deb963c9fbd032539c8ceeb51666a8255fa2c86544203c5669d00bb527b72192eaf9d82364f12f08b92ba7da32a02c9c1a36044417e5882b4dbbfe8915915d9499f9c9c305c00e748f1922ea16ee2fd562ebe717177bcc9ec9ec69629d93fbd00e3bbd7a989ce73350a2c4c32573696f438939ae01560a49a6ce79b9790788404e68f558b7af10a1cfa1a0401ac36d5718971ff346ded6fae478a82a11285137c07c2127bac2346a78394ab8aaa95314e9bc3e4c2622545b90f2d0ea9a2279aaf500efc483ecc678faa8b1d1d0f309c24149d67d6007f331979ecfd7cfc13894ed4a55ade8c3443000722a53af14e319cf85692d29bc58480b49ed989e174c67386a5f0006b6acd9aa47f68062015b9ab7c14b66ab9b7225d2a40dd6817d45194f0af404d1b531f0f5a00457a112e37033672f914f224b5ffb18afed9091047f76119b72106ab2a309cb9c864b7be00bcba9b3f8938cc67852180abbca9455658b5c4850fc08f29624d689cc35af8c827d911440812d605ffb8cdcf760a6154c172b42461c25a0f71850264470b6cd325bdd162acc0d39871e50a09f84539d87a6a26baa38926f0d74fd2e771b7516c1ea75ada8cebd97da2bd996875be130d2aa6b1d2d1bdbd654c816e82c4d2a19c75169cb1452ddc972c4cca22927d32b0e2d5d40207b9eba98ce9a2945d62f28b496c36823481d4297602557888d5b70a917357deaf3b777611c6e53e7180886e43231d09a7bf4798ce027d32c3942a03639af640c2b2edf5dd6ba2e77c0039d9e75cfb3f4a37c8eeeff363739b739ff3d8cb6e04b795ff482486315225705992c92737598a972e7c62191b5666cec93393d62a44e7726f3eaac91738229851fb72abbe574441c0446fe02c96522def5b21a328330b5985693b7b49741b6d25bd17fe3c74d936fb164aae7a2936800102b78f9d955e55369261da4c06e82e6f5de8d8aeb1f09a9d3dca0e1e36afafeb3319f1210363ab4b4b12ca8b4df4d671a37323ec7dfd0dc74cec3a1c1f5278bc22966104183b2c9354a51476d3e0e1aeb06086d723146d7e5345dda1513bbaa0d9ccc379ac9fa55b68622be22060f9a4ca94e8ceace3842acd7547e771c8b64722b9d3e4a0e7b53ba6399f1e5521a1182ab576c3f4a4658e0fa1b693ce2e62a5b3a08a0154cf7a4ce55864bb4461b8f78de85d908f61f46a64e7c34654b4d2a1a8727b00600710c202ca4b6a0dc5a93c70da28669047eb5e9d4a55dfc7c40dfa889144477a5a6f053270ba8c86e537c459bf0257ecf95dc2bda2c2366aff5dd988de557af45c8fbb18de827c10ea5a836a42456808178eac096c62b56ce6a017972e262d90ace20d4933f5a16a258287559baa716f7f289535ce1054fadc1345657285d6dcbf0951e450870c7f8c2b6aa53982a7ef6a318a6f199cf44f646bec054b1f893cc5800fff98201df0e8280c3723a83ef65efdbc610465cc3be83fc73bc3e7710829b1ff9d9219ec197b16b1400e3c5352b1afe5bee8380573074e57ac13cc246527cb77ef87309e9640e653adb75e5cf3d5dabcdd5841c7dc38224d8b70bd62b1f95e4798b27bfd385def063308f73b9058ca917a67755c517ff2a73291222bdabffe9306ab2404a2e89217beabcbf3c30d79dd0a305560ea4ac3f43092219b15302b4172c380ef0e969d4b6da4946820f223d6747eb22cd85707d01b1c4340a6848c89cde62adc2cf5e21ec6a6843435c261a071d4f87696441c285396522cbde1acb2adfd2af9a6e830decb62b8057180091db5cba5b4552677cff3dec7d66c6b9906f31b4acc2a1eccde626a620b95c54295ced83164cf827d595b438f1d9a1f8be250befbf3d17b54937e4e34384095edf3b791962cc29a97e89c19a0a0a67c7f6dbe48ca08d44868e899fb31d94fed8b2ccc767a63bfaf27de6e9cc23e10c25062959897ec4db216c0f12d207e59578813e5da2fd6b4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
