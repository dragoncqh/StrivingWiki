<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"06da0be588f731c584809dcb9a850ff261870437b601e0ce98041d85cf3c790fb69649cb9a0c62dc698055b5ba8cc98237adcc81f967526dccbb581917f53fdafc343a36b4671730756eed1e8b041852a7a42709ac1c483643e7ca4fbdd2fcadbc57ac1f1112511de36d99b0f73d130c7cfc7d36a3a295cf17514f3f1fa39634576ee37581b7d7257ade01c518e119d8777947b95cc1b29f2878baab395f288216d9ff50a21af27067dbbb3a79b065f6af96feacca08058479f7582a0f96fcc97ecd58a5a1cd6dd6dda408f91823e8a7f029b7c3e3308a68eb9b6283ac1f2d0f211b34c282f690a75503d063731a642c42bee00f92711ccccc309344039a46883fc0921099a648c7418055a31c3a7b6b35f5936e420b9b1353dd4e4c63dd2b8153f0938e732af2c08e04f3492bc7e5d0cac5679395a89d7a8d50206d940fc58cbcb201d4fbe46c86244ff219c00006926ee07ae51c46bd270eb99386f4f9fc67eaa9447c99dfb1e6ef3e05e9b5aeb850699ee1c3c36d8ed68f702c94a73668c638ca0fca9295c0585367961a729b4afac75e69808071d3eae0324ab284f1b380775e8c78f3d5a50630d1b6897e5a38dbc7a018c3a572f1d2390be776b19998d4cb7f40d09fe8608ff4f5506869bf6048d686a9eca671057e83da4c91d612f85b1648530cda3831b117fb666daa8407233f551d1a4b0b4fce4fc7e1cf576220aa82526d62915c6b1d52372926d9df12d7ccc21ff654f8ce1b723e97b5a982aca034c75d5c85f7c96065baef1496aef1f15f4b2fa3f47cb533f470c05d5628059ac1719b1397b01b52026013889d7151d8c4ad67438a2556d569056b8b8142d5418bc74f77206e0cf49c0ea911629b613e9a7590e35c2ae41304b2c7051bb27a324bdb775cb9d420818fe0bec1b78a0ba82b94bee94372840b344dd684184dc69f6422730a428549959b25951e631e97e349b664d064900232d4ab734474e9aa9367e392d3aa9cb90600baa36c66e24c01d4f169e13bdd2b80aa1a8501ff9b0f47a96e17845b6dcd26fb8c6541fa2062b4512fb3becc4f13d41f86ef35f42769a39159f5d234b9267d763a794dfdefb1cc8eea0dad94cd11460d443b62daa73e58dcfc4220e6ce8594d882e9f32566dc2430daaa442f34aa6c0ced9a4f747232048b8617002e1e71da5b94743b6771517fd59a57a71821c7be4d132bb68b35df4d29d9714092311fd63bfecad72dbcb952e04519b27ffcb65585a5272bac4b39dccc63b6e122665da9820f9842589c80638986dce81a82d8bd96ea123102895b78b8d680dbf153213e6e4377e46a95991d825489149e97d3b4bebe8f2c5fc63e211bf59336aa1c1a9a9a5b7fbaab8bbae42c69f8ad39b194f7cab7e99e35d7f31285a730367e59974159eac3fc3f7ef5e5d41a9b87ad814fdd78d4acf84f5210d32c3318b85ca6ef322130b1885fb4f35f3fc5f5758cb75963dc040f46b1dd76a18f0dc3f6290c1d37ed5d63417974d91c93a0ca2c24ecd606964df0af82790262c7b2154893552d3b1c594a0fdebbcbc200bd40e96aa4ff22813058f9911cbfa03150672fe7e2a8609d4384b53499445ba6e2c6c0a2189ef117c69e185113f22f5dd286e2f1b324619a160ec95a907551ffa12daacc969b5fe37cf858b2de2b1eaa798a24db76c6748cffb868bfac72051c2b29aea0ab266f2a1fa5741955e7917edc09537ec0a49838134cd37e251f4c3ec493656f1f7745ac3e8e1c510b0d6fb1d129ca1f74b003a1ae5c75919bd63e18e847a31142d5a501237501d65c2c51acc4aa89a73f7502caaaddaf6146947bf564ce03a86e8ac549ab72bb0709e04f2f78be4ca268b530f9c9a43017ffd8687a8c3860d22d5b09b7c4046a7875dfdb0bf6404c90a3e436d7e7137e20a60ab6344c70c66a925e19f90dd2c6b559c7877bda72405e1a8623ffc455a96f2aa47b89b2ae6c5c5ea724632dbacc35bc55dca69cf8ff6a95a372dcfe496b97b0b26056e159e2faa554392d4b0d3768c987fbbeff1ab98324dbf51b700ebcd6b0dc9c0367496ea4648d2bf6ae76fd0009e511c01e06474e4a292580a2478d77869b32c0239ef7d77de7a1ef787e184357e2d87670e9be90daf9c8b0e36122724e6b51ec2bfab02fea2ed4effbbc33e50085ff02d6cfd288f6c60f2f31f397bdb702f691eed104ed629ac506472a156e03910e4494b1d5866ea7b15065b1796b60cc697be86f011b135d2f96635cc87ab0f260d969f5af52285d74858e3066a1138a4f7df845c957b19f3f6e0c60b06616125425ba63a2f5b67867fb7842fdc9187e51d52b03896a9e9b59c8986119d186f0316d60a2a88f9e766778006e9a1c44ebdef6573f9ce78294ca86539bcbd9b397f0cb3ba1ee0c9b41405aed57da1440bdc0a4d00e44efab433c3260d94a37ea726d05c8a77a7436d136dda69bf16ae8f6dc43218bf4a25489790c0fef0aff64e60e76a4800843d3cd61b610b2a62ed1fd6cbcd70c5b0dc9561d41a5b5cd61be0b7d243f506934c645b974dfa07a43b6f0253092f2557854046ecc015764487500edf1dfc23f77bc156d970d4f4751ec8ad912fb3a7264a0e40a39a37ecdb24b2407147a8081955b9d31c19e286b4c1299d0f6e11e8dadb20cf1cb81d493f5856e79f149e034f49520cda6136e4b539427a8932055833df1cb3e6a106f9715db8ae7e0c944f7f454af79d762a5a5b649a60d1c83cb71661ce10df0337adee8736037ca0313420e11e6dca6eebecda73bbaeaf43f9bea9cdfc56b292860b8b6043676c45651581ffea58a69fe6dca7cdeb9304c225c83a9e5b9aa0430a3b4a65272d87da3ec97ae837bcb39663f690c2ef957dd72bea1d622c58c6362650e1855d09253bcb47889833cc0a888b9a730f4d5c3c892eb20b7c7f5fc39459099e841a8d13e320523076ecacc0c1fe61f35a30af00217001b7e29ab303a4735a1deec75765c9f0956ee12951f71609983f2d5fd8af25b70df86ce9da799e08b60112419e291991f4437d42304914104d8308d17cfbb29df2aa4a04199b9c3d5142a383f2e411510bbd48cb7e445bd61d47abe81eb7e533e87134c3cd67327e61c46d711d35d9a1a24ca6c015f6b3445a4053adad7abfdfa01b68d2e868438f955118424c12cc6cf69ac4766d4465913c404d3d66b03e90ff363b1c55e8c1d06ff1e1a7ba4cd604b17cf8dbb6949b5a0c8c8c60ccf4b02c957d4e28fffce81f6e1f885deec71233bf013aab04258bad7b43e933cc197ec89ec5d606b2453ecd676ae089b50c7a2e19121ec2e56bac927ef4eb596b66204e22645215d85e30586beffbafc7a4793d55d49b33e2c0b6bd3e8df6345e58190e4196b55009da7b875f9b062807a023910687eeea57740667872c7219b7cb122a283ec7233d6fab5d31371dac4a380b8930cfde3325a60a1095f0ce4b479726f370c6420875dd37ff8338bbaaf31e18d5c35e3439590668f6d3e44969073651544cda3535b0be7c7c92b5f8bb4a6addc268037377fccf84087dc91ac635863f600c791beb3a533dd81d9fc6da7a3977b03d335e946c90734d00f84dd39bfe2fc8aa17e3224eca5149374e352538c6aa8971041b61561195e75463d708bd97bab46eb9aa6416fbb5af5896ee528bca9e0eb0837b0020654fb8aa7b27e61920230a28b0faf4bba52571858fd4176e28a69530ab0821878b7195568e9856018fbf664f4ef5942db489135f9a563ec84faa1934f704da2ebf1e531eee724eb10857fe33ca64c34e0aaf33f91d8d02cc42a89a01363bd5d9ac7fb354046e411e129f4fe5a0c7d983db18386748877c2c87dc51faa84cf37bce8cf2d9c602cdc67a1f4913e71a4e7dcadb698ba502331fca7209967aa4b5160cca6861420a6e0e0ba70ecce644ec9a991976e032b1c572b85137356a6557a77065b5cc944cfd0a3060e63cb38f4200995add86150255ac8400b785ef22b5c3fa60f39f8b86d2738f52093880b78dbef81c1971b7486355b249ad5ba62b45053fa4a6b9acc76c8102e66824bcfbe603acc32ca525c55b1e7d40e8ec8b3d4965004f844cf1ceeda1543d9108c925b210fe578349bdd196677b75bff7203b38337f6ab9f21a92b3d5cb8052d57ce0ce6b1f3830154ede773edb680edea0a0147177fe093ef4be49c9c6a2fd05ba022d18c3981b5a00fe3194157334cddc1164682078d40f9023824da5520c2233f05f46559dcf3406945a474453c260de4c0703b52ac4d876ebfff48a4b66519450dcfe2d528378250339e69abbe28cabf7d1f3acf3528dbe028c013803a2f0bb7097225ece863e51589f8eac33c425fe35fbedc83b5933dea5eca61a0169cddf3e53ca1720e2035753403807e4dedd78b6828451befd7d5c952fc8dbcb646dc7590bffdf607b2268d7fe256dad72536228ee1689c4c635dc91a796f12621a154376cdf728ecd349f58da97f32656da23badaa855912448f8b4202c6d3a8ef4dac3ac3251bce6b0a8ee2113815951473be5e9b475c26e757bcbba77922fdf024d4d0a2937c6cb69504093b1806ae94355424ec64e25d8f3123ac5e598ec4101a45b3ca5b5f1e80e646014c6d780a5831bde142e606f3bf616a06aaf56e51c50e136efcd6dec97a5e3765dbda7b1e864d4857a049c4eeee8abc3e60ade24714622c07e380a2b103e3e6d9fc52512b76df5bf109e0a9f6b3b1021cd43ca3c9784c9c021af34de01fbdb636d995229e06629f6c0e01caf66bf205a38aab158c02cd41ce1f9b0bf88164487ab2be764239a8eedd0824addae0931a016ef0bd4d4d2efef70749b2bbe4acd61f758a9a2e3e04cbfbfc9dc74f6bd14d24ce3661d119f8a8643e8c3852cebe954372f487a3dd85dbf358f54dca297702f83a4b7b82e4a0b588423e2cf06d6c22ac824237926522eeca233e488357c1ea37663bdfd0714f1474b5ddfb86c43e3d9cee08ed31a89208a34ec1f955bfa9755491b977c02c36d628b2b0d960ead14980e91899051f4e7e90d30d9df8daacbd794845e346b60c8f080b095060ec1b9bb00519928fde92c13d8a2519f8a3b1691c8e31c8b680000a28a29d5205177c55b546150d6b0f62067b33688c44de557a095e228a914ff9ef98175a55610c7334593d82b7308369e9bac1d30531b99ca8330a887163943ac5a789a21f2884699181e1477348ec48ef041f60a74da64bca8489485367b36a93deb856de57ca3ec00c19cb56b4361d7ebcb9476faf3a9f4d366df6e3da00e321397af620499ab9d93e70863f4cc7141229ad04ad882b72fad30f95a4ac824814c6385470a94e09535dc8c748efd78460d53504a98d035c307bf4c995398d6e4cb66089e5f2e3f4910331ee9d856a6255ec66540dfc7b8772519ffad8cb8094720c2152417863a30f4e319dfcbed2d542fee44a0e198e7b08b9ec5c173d129ea4fa0a0cd514beddadd285cf4bf9202dad382d946aab27fd1d202c9e45f711ff048b9b95f7e26f1d67e6d18b9cd851af9ad60938dd9a89b3406619e6e28cb7f87c684db3fa66c4bef9a485580f255473a18bd2c1d1e27e6322906e5ac8f6f65aec0f9a5dbf5944c49cff8e7c9d72d2267b6534714e01d21c24332e59d306247fdb93656878afb79ede23836ddf01daf96b8e03784c5c18d86e4bb24424ce2c5226e10197c96a44f23f3a2ad83d401f0655c63edcec9cff7e77e9739f65a6de38f940d53f3c86a727010b6c271b576c2aca1f086593aad8ecc31cde0c76e9e64f560ebfa6213fcf4f89fe2afa385538cfc68a77ec5440d74c4f27fb71d1e458b5a2b213fff51a9f563286c81b3ff7766055c8c1ddb796fde183e4dcc33daa5b44f0a985dffb9071b1117c65f769b51424ff24e6a2f266f84c950c484980399fcb7028ed9a082c04b7c74d28c98b681f463c2d57c358f3fc2159aa79ff95d465fcb241de306d42f962a5c5d270f39ce50fdb9bf707e562d2dfdaa19a0885046ffb3f2aa1ad6993b920238163c7638f414d2ce47b04c289ab44de587987775fd7079d79c567d1daf63274eb186451a9269173d9ad3b3ae5aa05e4d41e9254a35fc00fc8f8b38acc469c6668516618a1d89fb6ffe472b1174ef88cdd0bd91e67be59ac2d422b9c8c55b022d764f1b1c0fe5112baf7441844a06dc439010f73e0c0811c6e0422e08a17c9f4b2c46d4a16d416ef109c89e8c394aa7bddb5973c4db5cf5fdc75f44e3b0b4b19ab2a4f68bffd825d948cb79545be4200349988ddd9470d62cccec526a244304eabdb6804f074d72e67c78e2c97701674801e0d3ff15d34abe8cb051275af1101959ff8480de28f481ca22a7761c8d002c67dc4e044940b6d18556b8df05f35894af34f5ce1ff5b745a50da34866506fe0a986b76eb49c938721f90a8496fbbda408a43996bc89ebae59d7001d9f8bd2c350da3acb0aa267c4ac0f88fbca700d8d67148f370a1374eeb46203cee42446b44e3550d5a9a291851dd0fc63255e6dad9f2ff33179765f864f480326c97960e3a6444cc3ed4cd3d192ee98957f6531e51bb4bb7cde49c2dba301c4e2f22fba18e3f8514708c9e2b49f687304901662da63c943849322219d5c6e508162803e8b7d2792745282db8d6dc4c5c2b66a3a6e2bb58cf3e2412d14c675f6445ca08ae1d9988eed9b88f63f606a1e2c672a3cf22778f9bb6a89431f175d106a5b73e5e4c6988596d019df940bcb606cb300805c06487373c10e31140ca0bea39d19cdd3538c3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
