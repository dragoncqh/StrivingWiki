<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"110ae61c6075b657b0fae53cd7bbfe69ce5afd9fd6a18a0fa8a082e8e9486697d07c5161a34c940b234a5a28e1d2d207f244d58c4ce2452f1f6f0bf290e69e5ed3af8f523fbf5172a8982f8fc785454a1adb2e4c524527455fb89891aa3b50b106d98d12331ae10d62d3bff5e5b6ca3351fbb74e271ae90c1a92b1717afe6d2cf78cc7816718593f03d93aed4650c1fbc89d1ceddf6a9f2958ba2be060ddea68989475cbfdbb3d495062bad95d6143a5a80f101bd0ec3771283c93339dce99a1adf4eb3e4619bdc80d9aba29a2038ed99e1f0d35e5853c8278cce3ace7bdb1a984c217327a4cd202bdc2827824302101f1503b29f25d4d10fe00e1b04699439d300b68fd97a69880b532e3d3e8e0ed39a679c81e53e675013fcaba3dd82633f3a82044754bb95c8b3b725264a6f62c9f8ac21bbec7fe3e006aa266681bf8d8f7f3dd800bdb9a2ad3f4f07eaf7e19792ac4d693b4f18183e39b586357f1ef70592d8bf1c61a68b38405e05bc358b5f7c9d6810d768a5a83cabb734652f5d0c0214b367dc4fd4aa6b74c426da5fd29302e2439503b3ca00b23bd1c4cebc1dc23927acc2f4c200a8d9721840fc58660a6e174300e60a65579e62268047792c7c5bf7cca84382453ab3f3ab965be3d217003d446a953e202d8d2aaa16fd76028d614a17ee4c2d947a523b1b2d14cb7a925ae2ae5e4a1c74a8f7a0fd5475743359623f0ea104b8399bbbbbf28bef87b89063723ef46340a38b1533a22bbe0b411e7900e5661d9a7abd28fec53573e7a5448812352b1c485d6cc89661601e60fe52a83d0cdad86cc4b4f6548368c561ac832e3e4b70e1803be966ffa99e0746ffdd365a96c27964c3135551844864413ba9030fdbbacbfdac260f37213bb7ad535b5f35f1f6c851582b785ba18d1e19fc40979404564cf89100cef4f1c71f7350f58ae7d561850c637f3920f3f69cb530d055a1123f299490066f15d1774a75afc2b4abaf1e26cfafac63c29fc749db874c07b4c36e2381be065cb671cfae8fd1841224c9e0aff01b71957454533beff7020c9f51072ef477d6b8e8dc865695c0676494b041e848198981704ccfddc4a5e369459795e344fc7672c30e0273f07aeb4034b869d3919d450765cdc732e8db699e99d542c7d802b6119e11a37d2c2b6baae66984aa82e24fb463facc792461f38350c1c7a68b2d852aabf96dbffe1bd01a632ddfa09688d6d18dd038d82f0b9662c460952f0ed7d147b1bb8ad3324ff8feac0a92fb4599ce00e7a2ca23bea6c36c62fe3c90f32b373f9c829df1a4753a7aa13efd2c6fceccb43b1677c00c47b08857cc87b28c661a279ec6c45067cefb5bb1f7ddd4e39123b2460cb87a739c8fc87bad2cda3177c3b05c1ff74589a97da079269802a1f8d724e08c3268480940a2fd004b4c0c25eb48a15a629eb9910f4e22fb3201428d2b45d6f9b3530da826169cbf71a9c37cc101315308dfa928a7769f4d4def7b8b1d35a2509d40e47b7cd1c3881d067a9d6d4c115f6325356ca10e84bcae7c0c3557ea8b980d842dd88ee2e1aadae681be26bcff85445ade96b14e8a753c357e49834057f6fe133b4767c46e71848b3538405a2605dcba793c06e1124e5eb39b0e642ca93e05af58a51f006b852954117af51a45a885d859c59320eebd6d799f03ebf3c9cafcac468e33533d3f18ab473112af19680912bfd39e65cb38ab803491c6c1bfc9d40d3f9e99bba757e666cd0b6d36e39dad631c4f83f166f2f610c524b9ae2c13e59c5ede3b21fcd71c83acd809ca8c5fde5f5abe8038613533b0629f7e60bb2f1f172e10f1234f61ed45c129f71aa018e3afed704ddfc18e8e24f9d3ba380fd17177b8b2ff9a6b506a1edc4e88ff83190f5608a06606d7718d24bbbf726c1b93aa2a2822f37d99141b62c6c5313df57073e64ed4177859eab9c1ff251446bcd6486be14adc4d0bc957f6213c75c67ee6bfd0901a89a8b581be2ac3be2d0ab400663f19933bf2d210df03c2400e16a9db98972c67145294145cf501f737ad46ab24e5b56f266581b759e8ce8895109b3f7cc7e440c87df0feeadb5bea53e8a87426146ccd353d5528e16059b80047d099c757c6ff657041a9762f0e177897c9191b09792de18a2263ac08f2e1d94becac9b2c6574c854d80e3aa7faefbc07f21701aef283dc7b6026468f57a0ecf9c2d03f36e66a153e217118b4a6e1a7e691f7b16ecb665535db0383b9deef30cbbf4e08e4b81e5c8b49faf6676ce86b9a5358a3ace0a623b05997a682810fb5c7e2e586dc0385b7c9e06fd7bfff5da497c97732abc7915834ef04516974ab8e18628e5f77e06f0a9f6d13d29447f722893338532653e0fee20bd851d7ed7ff2936a1252ace12fbef8e50bea9228593e865d2354660e3d6aa7bff44a0b7e0e136fc50e3b33cb96240cf861212f5ea8fc0e05651362783b3340d45f14ea9f31fbb79ae43274a760fc3a1659abccaa0e35f30ebba86b478f8f40aa7ed3dccce76dabf228a26b86edee2a7b1fabd46085e4772c559a8d69cee22d977dbca44631c6a5fc564d16bc27861b95e3f457309a5d2532109ae8428cbcce7fc85fe2188b0e773abe9cb32d645246647854f889b63cd6105153b3ba84f037886e31019ed8ef7f16051911d1c5d32bdf47bfd86da8a187678e80f7036b6fbfe03f29f9ffe5e00a7b3c054984c1ceb6b1c18f0f968c7f8c1af66066a3438e06e1154ca7c7634be180a05db18bb2d349010798df0ea49a465ccfd6cc834b141ca86059efdcccabc52b00e37f05fd7e7e08739320c8fed0d821899081b02a595e4ec589ee9f5afec465ed634c583cd60f12786ecc7e3dd9f158006e758c33ce435b844a891fae448c22807ea84dcd1ddc909bba33079765a1c1ce422cf195fb17079af455f5efa71ca0036e3a29a5f4092f2319637d644b93d95394cfc7b84798800fbdfd1a9662edfb4ae01e71d839888382079f9e231856509adf0ab4d9457d3f7572bee53cc27faadfc0f3386f4285cd3bcfbf411eeea6ac30b68bc8f7054e7e7712ef2370c99f177d9be407c1ff721a245a9a5e2980db3745557e0ab131c9f0b5bc557ab0b0aef5ee97cba99598857001caf1ed1d835027a0c653d23cbeaf656db8220efb282f9f79b07ec10bd22283fedae1fa50c22fd3e514ed1129c0d0c57d29c5204ed531c6e5f37b682d966fdda5c79ddca9e385eadaf1ce3218103d21ce442b700cd556d77ea6a99621c32e337c5f08d95cab3ee13ef3e6c0f02c9032d033f7acdf45c94902f902ce52f60817d100e2acacedcb3fb6d33812f9caa4ac1869c243f0664b3fb4de7b458c67dce826bb59cb349735ea70f243503a66cdb36f973f8d9fec0a5416bbdb214d53208d6e4f0bbbe123bcb42a6ba3438ab3083cb31be41dbf5639f9c01ee5e5943e938cfe2e7613375c4cd64c29c28a6c26c3b5369629f40e9ee0b89dbd39c18b5b848221ceaf0e0fb6f23b2e8be90642864af431c49d92d0f55372562cd59b5b02645e7f033cb0002088876f29a871c2c4d2d6e61ebe259296e6895b0ecd798a4f4c7dcf70a95db4a64359f2a8fc18ad1a2766d1e6ef6d73b184cabbf7bb2639f181f203ccc824e5baece36439a641ea9faea5772f30bf1ba684bd79cfe5ecccfc3b38c4d25f28396d1487eda4390b2d26d7cf1cdaa488a11d4cf961d4cade50d5abadf7fe6a0eadf8ba1d0e6baa7a5ccca84dd765460ec75eee3f5b4c870c525472c55a4fac1cd27a58bcc3be2d68d565d5f06ce331dbab940c32d67ecf2778300149b4a356b7d23b48712d73327837ee0758b2ddb231b13365d4d4ddc3df791d336521390edc52030441ee6d2b022d02b86dabe2527f5c7e7b21e5bc05d1c821fd635679a998a6f26e07b40106a089105eeb0289945cbdb7b3fea107b73d1a73fe4e36406832a48d09e9eff24124b2c96e7e9b1d9f789bcfa626f11e7c3313612c7e5ee211267dcba96b6b8c79c032b2d8303a3c42a51aed707945b77b1ce022a63321c1706b2318e867b1850ae2c2769ce1c8833931886d85aeb33490c82ee3a0d4e4bbdd9eb27b3cb3a3f93b10efb2586b34d771940e153fb2e7d590bfe7b885c00e5d083fc1711f6a8e5a0881cdfd3eaea5e1d2b3943d43cba32df10ebaa2392248de0b3878202aa3834310c0be5f71c3a632d358db4fa40e038ec6431bfec8556be8c64952333f2448d8e557010bf09e531dd6b5bf7e1ac70d2053fe8a19a5f5ba82617568e8cc742c02a01638b2360251746d8466a33c745098ee9f5625ee318792e30e251343248985ca56fc752820e2f21389451fdc518a5f8b2b20feaaf9f660b3da3d7a384b25c44e65987f0c601113bbc37a8c0fb9cb8af4753788c6d20bc81e829a06a6a8e01b61039cd1d46b4343750f3ec53b0d55307b63336587c50422c9d20d943a500fa00ae57f749d1be5499cd93618ab46a1bb58eccb89f88789e35cbfef36d103b0003db5de60a9660ce9f91b1b880c9eea3e41906bef7fa1390ebeb78d82e6b57a5cb1a5c64ac66978a578c579df307b18e83d1e61b1063c477ed9f7d9219e5d1f955712f04e6053257a58dd9d1c0b7019ff115060509e5af2096a199cbd21a0114ac0a77a30bfce352cf4a8e95094efb6b3dfddb1c82b839c52422eef910456e13bd574ff5b5d86918db206e7e99775059d9f949ed40a312758d01e754fe851203ffabb0634b455b40fb46d650543daa9ef443a442280738615ab2aeb9b3291fabf4befa3a961247f62e03718de1e5df1d5bfefc2ba6d7492948c07022ad15b136dd2b1bd6f76119c4944fc19daa87136a3c8531e74b863cc7bba920f779749e7cc22f7e450bd4f6443355538b1898f557be972075b0184b62f357e9fcdb7507540dbc9a6fe5d28fb32d920e4f24c06d0a157b6c48fe5a6ee483b99992609944ca2e522eee445ce850e27fb8ac0a9cd83d5742f24dfc8465b497188cf7856a2815f979e172db83e54534521b5d9dff461352d4dcfe569ee81cd07262854b6319e771b0bb4b6f7b9ef70b8dcf697c3a4e54ba3c7636f4b98699018c78b39b3cfef404e176ae1eac9027e780a60736206479ccf1502ea951b7db0e897a6cac0a1683874fd7828c1f7ad52dac06f263c2e32d5fac9b159fe0a441107717eb74ebd6decb3a2d07d1da04169707f863022212cfb22fe2724f4ea67cdbbe35d9c41733250b2e9c9ea0e482f1daedc62b65dee73eb0e9d7640e8bb1a7bad065719084185dd2e5b02aef2e3f295a0048555cd0208a79cca96a99857ac74cedf4bb1825a8e06d178f3ff4a38b73ff2eb194d31646d5b65c527dfb281ca1877d9dd1665a94fd2ac208a3a7665edb77c36fb6c81f7da89b6b912213c02949844f09089ad7afd350ae0158b1b9aeaa1a5dbc19dd3d9f53416905a611732424d620be895306e4f7203ab7d88e617257da3d59b3b8b81091e6fbce4224f13ef882507c0af4ce22f65d0c6967b973b16902ff0b786f5dc1ba51b7514f180bffeeee850b0183aa06cadf9a944a48c73411770a748d72852f2566a130799b2bca19b3116f71ca9c599f1d866d5d914f21242c55e6fe5d037b585dee20e1334bc7d013ddf51ccb71bd7219e98067cdc92324bb3d430ef0530a51550df421528866ff68d5150a6e87c651be951fa8b906db46ee94c3ddd192d88d33b11a311652224b8035245cbddab0114fb4a7f217387f20f828af66aca3ebc9a01607d1af195886c56b0bec03dabcb2892b4c65456865bd5ccaf4222217b6f1eff8dfcc45b69c18d42719c819413d65da547b9d0f65019726619a338a6bb66eda567af4fa347e7a1ebaee892db2cb77f3aca980a280e5a697609e3f6edc907f8dff25c4797e5a985f22fa62625f687b1f88c1d1d48965a7e33fc13eb857f7bdcf4c9d4ff66f315e3e7ab8e1ed4342605bc5a23425c0c76a152f18fbbd88cfcafbf25b0893fb4d509a416bb9063145b697ed6bc525379cf9cec2460034812261aa245c7139c351286f196a456940b05e6af16374c4918c61d49eab8e4dfd8c6c63f7fb7f54430ed4514b413ca33492978dd9f0614ec07529b4db27a66dc87ceed1713f1c7583e52457bd2e78dfa6d5829acd27c73d5d2d8270908ff00ca3c84e8239a4a91cbacba08daa6b0aabb4b621859d5c8e7be20624a82a54113f88fbeeeae1af3150d47ed2890abaa62eb27c9b9395ac2daae55c2e4a2796e1367dd7f0e2518f398cf4cb16bbe5cbe13f453ae7a2465dfc918d2e09659658a35421ce91a8ef04a2d78d778eb00e18dda43a7c7730b2f59a7f603dd8d55cbd71617ad72a7eaabd56d075479dc1bd84001160eeb7aecba3e659a528e0080bfa1ea059b5f2961cbf835182ee94bfda7fad5b606834569936530d27961c00ca3aa3a05168ef6958f54030027f35adfab021f932e7a6f325ded9709eff618910507bdfd124e7351f40e3cf5ac909742ba8fe0339d16a84bac727c36f195064434b942f13f70efc5e03148249d7416d718ab662a8bb60e0fc81d4e0653000011e07bb9b9c611b9a0c391085eb7ab8c0a568a2f5a50baacf8be7cd23ac8530a8ab388c2069033e4fea12b67a9dfed917943d700abfc9e26707736afed81bba53cf4469e184706e5c73f14bf18d2fb302f276d2210564ec204bd17cd9007779459a98b10926f03bae60738b35884965f18ff1932feb25aaded8c7d96364c9891f941b6bdfa9449e9807157399cdba38b9fef7aad2c56d490cd365ba92f11d9796bcb22abeba723bb8ddd2a1f3d1cec7c855743412211e78c4ef02d670687b7d571229ddf40ce620e0e524c0f8c4297afedb4df42b3296aba85792496bcfc42264ece508d7c2cf3b3d2780e09177606e108be1b1d998ecb9925e1b0d5dc02f194f9f19a65e16ba8db1c9c765328e47aaac55549fcbd733d3ad2c168128438c068dfaeb20a990db6f5e07b7b5f0bd19d08f1822642718ab8f85aecc10680536f56cf443a59df20aa62fbbccb80311ed18c80d202721d1691f69e0c1576f399fc53ab9421e7c9e7de6d20ce277944b577a933cca3b692d3692409c9b24d9b73b6159a3314a207edbf229820a055e7019c1b9089e37864e55865ddd6fc452edc48110632206046c35ac288df4ac76dbbad7d689367731748ac55b83f5e092a0439da900d616872b25754f6be6bf45605f7b2cb67eb88189ecf99d363a3af282307a1bfa0d4fc06c8aac3bd41d047cd9e8c0f256122ba475ba49e4505afd21b99d74ae30b9fc56a969b3a4b62a73c38ce9c413b3394bacbb05480c6f30631f6bcb3ffdf6165e9968ad08f6804ce6b50fce0749451959785bcf4e8c54b071dfa5725bcc3fb557e6a5450a61575d9c59bba331dae2ad89d00303110b1b4efc47ee94125258b15d238b2fce6e7fafb6993b1a669e3ef7054fb2685048a4129858013fa7a216190c989c327620e258d6bcc9315402632e3327b867563594c0af1c690d60286648b5fd0900698a4864974f30fda3ce2bc5b37ebf81294e17d653e128c6cf55f0c858ebe45531c152214f03644588c6a95b94daceaaf02cb9ba62a20afa4810d0ca8c415494de80282f6e86954fac5c9da35909270ac2da3312ba2110efe7e1966d631229029f11c13976bdd8dd9b66229f229bf301c1e207cdfa4163c42de0d276bd6376141ff8fc02bffefcc89dcb58600051ef9d5be665c4d8fa659eebf6f5eef95653d89054b05e8e74c6fb168dcc84a1924d38fcde956c4aabceaf9cfb48df171dd9aee83348b5071f5076a620f2bb434f5de35a45d2eb6ef0c385e1c0087a6d655fa7d80e1d36ece67cf37c2b81a58e4d3b11e03240bbab3b23207f2b1d96cdc21e8b1e831308aac4589987ae38e0088b4dfe8d200beda546412a90aec856a66d2b2224d73f5a6cd96ac82177bc55c53b6dea93652983c5a0fc2df9be3766031f0f12be7b2433053ebd3beb2f7836628438e241155a0e5fcde4ba1e0eab08d20df2e54018dccc494825c9579165d9d5dff6008ba306d9486ec3bdd07535b1b0a9a851dfa64f853e1c3ccfcbe749d27fd28a13a01a072316f7b6b30a93bb87430f24518fb363a48462101624f05eb7ad92c52ccc077b9d92a81027b69cf1488dc0dc487d9ebe6e96f882a2febae5c3b635316dce43dfc5c538909d2ce375bd140839dae8deeb21424165e1e5855af7c40ec088558add5feb1dea047a18060b63f6478a5b7edfc066639a653892b8919f218bb455346fb7d173dd6c5f34d312858e4e5612ba5c28a6be57dbd20eba52b434c0d1a0c14f1981de9806a3f5aed3d39a0b9e6f423d7d3dfa5280eb8a1d80c6871757b0f18177982ec16aa835582f69204b339637ea20423847670495fa367f080c9e00cb0218b16857a4b2c077f1ded356438186c6b31cdc9d32275606f352214d2109d4cdd3125848765dea120caa112202fbec2197244f88fb82c6c684d8f4fcca5143ff216ec58e918a24ff79eff1843f198aae7556f518524764ee5b120104b048553e55a20375e76c4de9ba9322376d68140a938f55eda7f7832b123da728265a8aaf884eac78b7b3c90d6c2fb27708f44cac71ec1732fed1dff2cf5023f5195acf2d397fb364b04d082356bd8aedb6f53e786d8e02fe4fdc147b765f26ed1e0734c4ef0aad8af67f719c8c47c56d4e83abc63ae8724d8f3e939397cce20b4049c7b687c37897911bb2c8d9e64366ef4b8fcd24bae7c3b4ae3d5eed654c94dd42f937004a92ca2c36715052a78134e0a8a62eb48b99e05bdd5c597a0e06c6f2dbfa48bc085290172936c36ebb95052a18a5f76d05679fd80860aa74025feb314a285469d151c1478cea855d8f8217c809630d4b55328143ee6f5f6bb2c76bee751e9777593a64a7a4f68d4e1c4f4945e33f3c64b1fb7cedd59a65239b29178f45c6440e4f374988d516e70d1d217d5c98fa43123408bf6d351ae6937af7f23bca2d917c590555d797ccc54f2afb934c8b617f9edad3542f21a558c8dd371e7671299ace8f19f841ec2c7f8768e0d852386a67ee4848fd3d90d9e00d47f20e1201d732fd3ee72a87541630ace6ce9eb395903477637b792fcdbf7ab9d22cf2e2a8565eee4029e95dc8b869087a4e284fabdaff690d99bbc6923ecba5ebd8202f0a160abe171a091cc396f1ac8bfed094d695523b26bd621c94771e31bbce120c34935040600d5996934566ffd5c1ed85e12e349d53f76650c1efa321142d324287e54fd96b1c47035d623998845a880523977bbdc5a02c1108a8c30046f05f94ea23e2d2ad9c5d6c8013ff0186187df8b4089a8319c02d9b15f435c8f0311441237b5548f08f37597318d979bc95670b2b3faae3b8411c660b1764e13ad0a1103027023f49f240ba1bbedb1c34a468c645b60e6145e954ab509048674cddbded71f15ec425c4cf905d03de1a16f7081c11c2bd057b12fe755f5c7018b598eae2e900c348ab9d2ffc6d4c7fa3da2a0df095f567fbe48586f7351f718dfaa8f6152f76b01b5ae400b59bded94a0d1682a315da072e12cfb9cbe10c5bd7c0f09e77d7d4d2585d95577000e6f1539c97f14ece77b889b6d9445ae8a09a71814f9a1a82cb57a92376a90db3f3c519771f59274aa92e405dec85a07a00d46934d7f8b6ad96edf7b83f37767d0142ebf962f879d6def6f189c6ae8805ecac19fbc377a946b9554e51ee857bb84d684802751c73a4209002fcce62","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
