<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d7a4eab9050bff5c103220f78d735d2bf24861b62b4dbed83ccacc7598ff985f7786e98d8ed75c8713bd66560e9dbbd85e8b36e25b1a9c22469f989674219f70bf575fdc2583032c99e22c843a09e5b51eb79ef97f4b70ac5198c6a402f80938e3e0469626999089e0ed9cd0e1d3d28000795feb0471eb4756b180ee977d0f24a5a04e4b33f7197a4b06ce7d58f62a9f1b67855dc2714e475de7872c66c3fadf308e7571a3d225b14f7c2790c26a007092f094e8472069696b581b5ca1296de05a8c6227ab1f7573b8ddac88cfaaec663efef020443a2f1a6211227c8791d970020831a1ea1bd792e8c2859bb0e2e4355ca664b991dfc708eef76e6c7f7557191e7d3b5be3b4cb4b6ed3662d824d76a976de88d8ef8a650910e8101bbdb6fc2e704a0bf173b869cb6a72297e789c0120f451bbcf246c29cc72bb4b5a7c7f068c13850fc0288a0f5dd02d3b01848f9ae4e925ddf2333a5270d8a015194bdbf802f8ea80df23f9b3644fe803d5d99db857dc8896a389f42e5298fdb34cf354c0805104cb5a8cc53bcfd6ed0eb5892f315b427c87cc0b8726d9f291ec5e5f3d3a8496a218ba78b1731c2dcaf8664ee90633191cc039b2a535e57b2236c3794eef221eb0dd2c33a95b70bea91dd55bbdc2c073d9c6ede15e02810e2d160c57f2609b42e1e8536a8f490b63cfa1d2d087c5203d6df5054722584eb4f8c11f7d6ebc7da9c9f073414bcfdcbc22de6ded9e3e75ace82de0ebcc62fd716b18f4c53633e9fbcd0b8291c034cd619be5b1f49909de7430b87c9a596e46f841e267c63262b0ae79ae29d558c184a56ec4b088cadba791829ed7bb5213f6905a4c1ccbf8dcc25477ed08be0f2f9ba6deb5cff9d564e4ac2862423b75859ecf1413c2b570302c4f4d78e8645f20557b0f823ab92ce77c6eee6e5da1cd8e10d6afc0901ff34c4259453d84c1c63fa4613518b615a09e6ab49beea22fa27789c20e0a5fe6e28491337139079b750df1ce836b58a07dd020f039d068b06c627d6c3f39178a8a65ca0e262e8a93e4a6722a4965657f0a33c1a6c0ea723ebf9e1315f298c0fa1a36bece043df8a3a2298f4b02abed1e3b7cc8404c4833525d9869319db76d24c565e065002d1387fbc1c696d1df15d3589851a1bdd20264d6de4d4c41c7c7162cd455bb71ee863b1a172e28efcf96810b5b7c9ba055c6eb7785c15d5c32271f327a361923a0a977e1f5215ca60c4deaecad1a66fc3824550f5a14eb58e9193212c506a51bba0567aeace742c0e55526629aaea74a67e8a64fa75ed120136f1527e52752999753c7eaa5ecf72cb1a625560027042f7f2efad2d3dd4f5ac073e31e7547f68a1e5efdfc3d9428ddc8b85f97f1cad6a22067e727ee115e34b51de510d00a4badb7f6ce3d55eeecfd3e9050e92c14b19ffc53a56dc1bc07db8814310a4b0bcf8f089aea8346f93d2fd1a912406a55d58ce7446490211ea72c58138b637f48d8808fd2c5fddc701f698a1ac0903bd632414a48f4cb55a85c388d7f167cb94cdd77c573358925a9f130433bf80d4050a9a7c1e229f113a35bfbaade8887e9820962890d25bd0536de5eac4f318dfac69bc8bf766b52c270b4a807677910d2676fc91bdb862cae6146bd58050bfd2060b0aede2f3374d5af90b18a2a1aca22970b4f7505e6e6e40ed86bed20f20958c9943dba7e805afd7b218b67f1f68d50080f94ebc2aae870519bfa99b613e72ede4cdda07defb6ed6ffd8ee5a3f3e894db984cf88ff79aa44227b5231e433d3e3c54da40fdd29c848ec0f68f72f87f15d9909763f7a3fa7773a7a49277b641ecdb93938c0b312c085d23b95a390ab8ee2a5d5204854d62b20b118107b6227bfe37a913cadb60ff9722f624e351bbe1d4831f5032d15ee287109588abae83cf5280ccd4e37e48819562d0cf4c2f9f830103e792e00ad0d1ba67f15dc6f757eecd0f5c787ec89db42b4314b89a99b8381be7a4e94b3aec7de40dba377ef7e43cf3399151ea86db4940f601ba88d555d88d9daa29d611924660a78ba08135fffd83eab8e70d0a11bb6949e9b40d3c34b67e9e3bb723b16ff55bad38806e7d9095c6b8876af26799898a829876fe303b5e3707bf3caef2a7468ae8921ce07e1252a134f9912f3268646673fe3c475cfc8c6e26af64c2ebeca85c13c1fbe521c46110ba11fac49e129f9443cc7f236fab811de3986e4517b473567c4baa490d28cb0ecdbc9096d102d344e8d344d3c34261db567d6c4ddfe4527d9d4e577b63b44e094df80ba7ac4994529c1b70bcb342080465a6b303fcefb3e45d51530810be5eb4e6eabb35a5615afde8a28abe41a9ed84cad6856a99054218800af802a0110060e3daa78559f8eb77108698aeb0ed46ecbd34f442cc972bc65e51f391da58cd7db81fca3339b3b21e251c69490dfb8d0e92432e9a173b50f1bd2a6d53660127457a56b3ff3781eaafe62e42c31ea569c798619dbf47b26083547e06b230b72e71fb17b29e2848185595379e8c26f0ca9d12517685a81167c825c68ab3c029493cf72ec8369ce321bed4bb5908d608ef3d163d4f201f08cb43825d19d5709acf691de0f8cd419434247ed21944d928ef032655aa1fa1eb18b86376bd14123f6294e1dbde8e7de573d7b711d55c4cef80548a66cc3436f03840053d6c560dcbcc27aae850b97408280dfd69486dea3fbdbeaf21d74727d4b53b679f866994e2d90ab85692398568cef429c3e88e7ccadb3bc9f3de3850fadc7654e8a60d54c6aaee1c6b73b32c4111ff8d53472845c535829ef09954f9b88475643e8703cbc00b4e9b445a3a5e06bd1c44f03a9fc8d55cd607a6729238437b61b0e3856c3905ef38492766bc74e7a7e955cd69e4a09b1509e4b98cd4ea45519b51d158a8422dbdb149adccfc00202b37bad6dd68a0b4de089afe1e69c9482ffdc7e18b3498078d154995dcf5abef900f86c47136b64bc98ed35829469e06accefc77e5df138b9a499a89018636f0a6fe4c297ff8c8efc760e7a0d19db6ba6eba25f84f0b738e1022f2c893c30540cb048db4b89402b584811c6e9b1d07f75450418f2b90d825fa1c00ac10d7a9017d7b3b50786a9700c9546bba8038d0d363435359d0eb3617b256e3b0a58810a15c0dbc19e5b95036475a50a84feb728e008fa4b3c75a0706a6f083e22a025d31b2a84654349bc1854439389c24522c71af32cb9e7004e9f47c1efc4525587291c032b2045a444736eb8db2dfbf4f0d50f195608d485ab369732db068445a092980726fb79425f12298f20966569b677f63ea95809dafb7929b65f3a1e00eb9690bca9dfdd09e14aac1a766ce8ad0e465700f63b376decaf18c7951591e10a0653ce23e939ad057c2b0ffb5e71ee8567818680b8fe8c80f2b9659dd5ac545173a264b49d868f80e3a0b19f6eaca6d0d5d199b98031848093795fb25e637429de489619aed65836ceebf5f1e888addfdff250f18e9622fa01d8ce51ec3f1fdca5d05eb566949e9993be31acda339eeb61f37e22e4a819e05f01729d5f6e56d6d13a6918fdc5d104c7a49bf6fc9b9c9d60e9ecf508210ca5442d9b7c4ed2675b97c175d5fdd6b9bd0cf4b1bfd50f2d2d2e5569d4869eb166ae1a27ec294e222383c2be360573adf17ad5c56484a22018fdc40b5d2abf1ffdf1ce3d410ddc592f5f46a691828f255b353d50973364ed20ffbbaa084d6604b0993d790b660b5be6e7ac47897cb8c397e58d858241e5595a82e4df92451db03378c31e3b33684e02e0b454f304f8a205329e78d33c4336656992b070bc08306a709dd23dec5ff93219dab3ec998cf5262968c724b3d4b639d417aacc692352e0d8a803957a90a0981ce7ff7a88467d18a1a27461da8f553e82161b0252a502fb2aad073a7c6e2c3f59a502499140f5bce6a453736801a584ad23a9df99ab737fe201a98cde059e771d04d877241a0c6e3fefb0b1552c67217a94b498c08fa2ff1392e0da767a03b8183d13f083b862b3af9365bd10de7c2320a6f8febca60b0625679c17ceccc9a545dd1d807926499b536e7d5608e30da2d113110df660e7edfd493c663509010ea4d84ceb768f49801ef86d0d03f9bf9a3cbf8e0cbcfef9d714967d19e81fe36db92c87ffaa5ccaedc6f480dfcf019d6a85a9f20b4e769326606325b756f9e9ca5cfbe24c7ee5897220993f0370443e1231f43921bbf2901dd6f66ea4795aa6986cbb5469f11ca13c0dbdba23fe7bb0191ecdb283ece8fb36f9262e17fd025bdea893ccd63ce8504f298c3e0bfc6ff722fec668dc09ed680fda32e83ce61b938550a1157a790cc90c063c4f511b5f840a091e2c0080cc6c6bf442afb9ba1691e12ea6edecefef76d6bd3f08aa262d1738bf4c1baca5e6b842a9080a2368bb392da685e170a4c816654795ad3c1bfde2a434adfbfebc6444508b2820a380074a671228391276c6be9fa3b9549302e60d240322dbd51f1447134b3245ef87193a6dfbfb7be107183fbd2cb5c0e8db40512f808c2f36146293615ce192d1d6cfc881221a1f176e0d2bfd44688cd55c89f6a4bdad87663f3cfed002fc2155fd042f1e70d6b8cc8f53b2e5c311f57f7be581ef06f8753f8ceaab90346d0f8cd290c15ac857b17f26506ae73373953f54c0ff693ee3c7cabf3ab110bac009e176d9a76fa9b3617b870cda03a5da4e0b3ed63e1514c8d4aaac36c5e931cccdc542e8972c9ecccec98dbf134d5287d6be0d8c70a02bab468e4d6edcda3b8b070c718de9b3fbe95a5eb73aa74096edb049aa159f1e04d2d172bab19d5e23aa48f5e4a86d9eaadf7b856f4790f332fd330d6c3e99e70123234dc5bb94ea6a69f5f71e60108bb0ffe437280b2e363374025f11c843e2a931a9393ac417c80e95243e03e52caf14ad815a60b9f579fd298b3bcf0bcf36ac0a13eb76537f7aae4811c992e15cd7db286fa0a2b06acb9e0d65968fb2812f8ff7425470fafaeb87c79e77c4d097b102f1939f5db6bfe13ef8be9dd838c0ed32fa7a77fd7d95566af7df5c8521191752a3bf865a65f3c67d466aa2508038a46a1b6bc03dc9acdaac9734294206f179d55686faaf828ebc910adb86644d09850afc219d7798ef1055bc781b6acb639139a8403c5006da1a7012fb6910da767a994fcaa6b19e57f87f6d1f400eeaa98a3e4661a1a618fb2608ebeef9915692872b42622ef3e5eb93cc762d5516ca0fded876f5d534de657a62676453832220c8085b688ae6d312d67bfeabd351726edc34b9c40aeea81dfd84291f634571a3a0f563e023928ce7d4ab6341a759a5cea1f6eb5b8babdf8e0d3e80ca684e8f00d5c1c6071c8ecbfbb986b420fea0ed868964b654e0984fb038d7cc6cd3dd1dc78dbb5cbd72db3cf0b9838552d76ad615ea2bd79dbbf7f69ef532869c482b4cb6dc125632094a294e7a822c1458b4d582fcbd6478c31ebada89efc7a60861fba9553dae65c4957a6faab73bdd204b0830a71db32121c2e3f5e73c7cac2ea6bc0ad192055c93f0537032c65d7f143bf9fc074fb42e3a98d9dbbe4a6bd9297125eeaa60acc8cf3d3cb88030961e02f3937337f214c63046a837597ab0a3fec9cd8972c431f735222abcc1898556a9be92f761ef7c6adc1100d28b349d4899a36b7e184f7d83f19f9f0d401a1d056a104aefa2f6774f7cb2a088000b9bd33d6e0dd9c20416d18ad45ca98ba62adc7d521c370dee3ea2d2404f3a152556a1d64b807493f2cff0c32606ba5e58f9af1766adc3b0c04cf9e0922e6cd697c5a1de7e6e7847c071769816c8bb00563e504c560aecc7461bfc8562922fbb97efd726a505b600e62c769b1f3b5c287aff2ca35a1af7af17313e931761eae05e80ed06716c7380efa106597033c1e59c158405eb50204991603ee9ce932f8f60f19d90c5980b89ebf891dca31fdaf7ce215cb26181849dbf92311279245826bd3cc523ce6f51092e7ff62c202d9d73c8faceaa9d6f808a6511601a6c5dbc8402e18c11d4d26146a152bb682c01969cb44fda4db72392ca1ba8534f70aa8689cdd23eeeffb31b33ff638b3303e8485134e1379c8410eb845a7d8bbcdc21c60af703bd471bc345c1857c9dd6bdc2703545954fc9d9b9ef17c6b5712cde5f9006b09bee853976d9e9ce46d62f9c4e9a7242349a0dd7977f46ad296868ad665da17e872349599757f86c3212db8d247fbb605bac435314c2fb509719723b3209556266a89f50e28e9ce58f798cf92ae6a1d1b5dbdd71bc47903a2b4d65e4bcd0a4473bb1eb051eb43d8905d13d25d9030ca9816fb721b1c91a9232f58c69cb5194e4aa229a899afd6d8a46a6fc1a78f3db5a21a371c1cf57564257e0a6c2bf9c1113bc76b3c7390903d0205215ccaf48b1c2d6bab0c2c105903ca4906ec9671efd21e978233cc5e8fcf759b85d06905a83caa03463180506b753b29aefe35f4d7b3965ea2222ffe78a0981eb433fe6cf1a6e9454b6bac89218a4a83616618a741a3906639535142ae1ca91909875555456b8a8ef2b7d07cf69db2071193ec1d348a8309a5c62b76dfbf6c7341f3e2d9831b49b268384a56e11e79e7f72871ec86236abfc351a60aadbd905685912f09a2df9359869568f3f5b090570c0f1a0254442c45386a3a4c9a71782302409c3d55cbd1c02dbedbbcbaccb232f84d6746245e18eb7671594f1295713be5311139579f10dcf59c815818101721278288599b846ec27f335d3c9bfdd62a7164c1070e5d89627e939d00d8534f59b12b37acda6bd8a764a28cf088f061c5d5ad6a63f9c21ebf2193052b3393b8eff3dd8721e1acd045d52639f1005a453d82bd8430f20f08927f6edc714357755d40d25b0dd06823a73d24509cbd250615f5295502f836a104934ba993684091e6c334a71db0cfd94ca4fea61092ac3e851db29c5ce0b847a877ecf88ec95926d7ecf3d3415414e74c69d50b8b589cc44649e8d226da9d982fd8cca36c6ec5465485a1622e6f933fff147d0c034b49900eae7a7f668b896e1e6890d9f8bfd20195b82a1918fa53d4b1f826ef631b0e772de7299280709f2e1a16af73c5f0cc3742a19fb32f28c4ea741f9e4b0016d4a145b2882b6df0618a9da4a83d47134eb2ed8fee26fde0f26afe6d09fb4618c863db1f5a6d5fb25b7b0f352045453b249fe4ef4be414b937073aee8cf52411e91d402c84ed56470327366897ef66111efd592a3b84db860911e61ce9877b15b66a703bc3aaf31808ba6aa562faacb4c1f7d9f3270de6cbd45552d5bff7bacccbe30fb2c0e2425f588b68dc476135cf1727492bbf5650618ebc616b10a5d828a96e2103942f7e4e4e92cee75bc14ea4d2416eff0c15c67f4825fc908504bcbcf450e7439c8fb194051ad765713afc7d1a62a6bd9c24603b5e47116b0bac6555c00b859e571721d5e36f9e32a1ddf93c36e414625843dbde017c6f6877c78821fdfac9494daec4cf05144a489938775d924727acd9edf49ff9c7f7e17204c0a6f1d81cc1bc4c1310782e601d204068a2ceca67099c2fb40021794b325e500bf227dc89652c8583252f4b437ef09f76dee44affd89c5b0f4d54381ad1a6f4f42b2f022fef599fd14ee4a48262a19876f7dd75e7af6dd7cc69af5d301e092d948c54f762eb221a916c42a42a0ce46add462f78f448117991b468241859885bc1c7803a79ac5b3b9282733a72ff0ee9c69fb6682a2f4b86053b0372ced9d243b965e3ed739061c9db8d9fa2c946d3d21efb0ff7b71b162fc13f5ae8d84a4286783d0f474db5eac7e77805d918639d8cad0666392e053d20db0411f22d3333121f54c31c01a3bdeb6fe8436af80d01dbdbc6170a39e813109f2c67ba02346f653c3201d52f7fecc4003c67b4cb7af32868696bae20492c5b880364188e8fb2a7cdec2cd783f6884830937012e9e6b2fb7d8fce607809542831726c2847f3e018fe382bdad148d037024472f9f4ef9fb8c26b4d91b976230b31ad8cd598bd93a3a1eb673ee6577a9d9445ccb5b9b25ef249a26d1ac167037799f3174ae6ea430ec99527fcb2da3308eb8c64d696f43a08574ea2061a4c156f94c5831af731ffad651340d7201b2d7edf19c29d4e22d80ef26a7709092044eeac97eff3f14180a285372adbc741f221afa0e51a7973b158c4b9a879fc993d777b3c455c0e237f23bf32af87a6dd2e411b5987b84acd5a43816a1e457bafb20c7c4f43b4c3a73f96ad20ef77a945334717d13592a33ee2324310461c3de8f67601f70f7f35a75f93e0614729f0849ee43324809b50a9c2ac4b2fc5a95101abf1d091535b600dbf1e59f47c41f5f8e60c0c8b0eb3c0a834d2f26d2b5571aca728b3f38d1603e5a019ea0f7d7db3205a46684d83c9cfdfeba91b9b8500dedbed33739e6b530bf3c8aa17115faf2e5ae0e95a001b576688d3767b0a996ab42d399230f2ae646366211a59937d3272a3cafb7630a77619025e3a156536771cfeb14d45b09f07c6fdeaba190d6153ba094c1d030e4f4e9e0a24a57f4754577c9cb2e0dc9eeba3a486c8331b1a2e223d601bc9031aaf38f7c04c73b65db7215cd18c495e8ae0edc3eca67583ea44ec3b20ee69b3e04095123633afecaa81db4669f01b1cd8849309bc1f98793961b2e8a04d03d4c1e5103ebdf316869bcb8520531f292cc54318292dbd1d9b1b0c7c8a15e953c184e07d6d4e3450c5e8ba289edf46aa850e476950fefba304a80790a0e0104235f170bd65bef53b1ba6092b303d742a235065d0114c2bb36a47b8b280a538787fc690cb012b442a906e20ab5c8807ca08e182bb33732573d266063f0092f8428ff6b0594645fda00b069269daa4152c361c36b2f06c5dac6341429cc6754d07519bf1bf4efb38023352b371acadd25e79a52d99f05b19963df8e3b28b3b822a77f10974d1697f7f9a63194650e2a96a01e5f3205491de46303435b56e6bf81c6bad09c291eeb5454186dfeebcd7d72347243e8e7a9658dfcd17ff86d9893df0d152200ba90d1279aa563a7ae7f0e851641c3afd43bf9f341dc96cb05a7c91a08eea3ddb3bc80bac7819229c322649ef0c95d4fb79fe1914037fc3edfb2e05b2e3e524a9332f459e2f2754d7c460e43a023d4cb8980c342d708bec257be150de3b7b54fab389418c3eb600c8931c21ef4bd1919a99a243e316e48e84400a01f0b00aa359fe5e340ba5c7685143ab3fba2aa267e7984850410daa600044206fb18993a7550691f1656afc3ebbd2e9f333bb65af49f2e74218a4b458ac709855723e13edfee582692215d3910e76a3f2ead2b8873ba3f26c3188642d44f48b4c7a25ee53ff6215068b84b95d4a117e013dee592de836f7355ea53054ff5478b4ff3ac6ae123486ad6d9fa729f59014606b257444c43d4ee63dfa662ba4fb9ea09ca89d029ad3a8d3d49de2439b0083dbfdd63b3fa4b911f34785837c729e3ef76d855a1df362f780073f6d7284c1c84c9266c610b0d29f5ee9983906f68e717b4bd55976cb02609911043820a21c627c5a7feeed89f148a0d80f6a10c04d5b7c840a6a5fa7ac578257d9c9b105b15707e95124584013cd311510852e1d0e6719ccfaae622041daa69dd81641dcbe7e043b29399d75bcac03321ede58b357b81ebab4c202932776b6dd14ea1d7d8cd28db71e3536c7f0e96fb2d3500eb6735e93cad3d5e590148d3dbfeae018c11bc863662accd60c349983","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
