<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5b336b9846418367eb19d6a1b4c20af36865fc9c14ec1dbacba6abff3610a5fa249c48c40425ec56901d8f45b9a797d2278c3ea937083064513c74b99a25528fa1b375c5a19b2be760a45784a9fe483ac6646d22adf344848f4d70037f66637d4dfba4d5832a1c34713b5cc41c9d9325c461f27fe0ac8402073882cdb37b0892aa3e3eb758fd43e903d5bce03e140648c7a1070c41e35e62972b2c4935d39db863b4cca30e03ba9bb3bd6c23fc2e2d49a6f751725fbe09b497edbe547b15a31d207fd746a755f79d053445e7f4dc8f3c80cbf120a7df3d374657d6bf744f28cb56dbe5519aa62e11f79945a6962e3e58c7c00a5d894b0622043fddeda296ff4b413201bdb60392f33807bc911ac27f46d59af51c0cb39c75c6eb65cb23ca90e82028724b0bdcdc057079af2c637a6cd4f6db6fbcb2e8bdae16657ca1aded47281fff45f8378e691b4e5e75ee7ce0c17ebce1ef0ce8cf669a921b1b2a7a3d6b6d2ebeb1df0c39c11e3c6ea55444fdd4f381ae2cd7d69f349941b07e3d7689c318b925d6d2797c71dbf41bdf5e8f334e636b43a2a2ee6115275c75574551871eb99a3ec4e23a157a86ce0a329e8127d1160c6d2b7e45a1747db529687721c02fbf00ef684859e9617440ced79b827811f8509ec9db57ddf8839b195383ea243dd977edae769732069823f11bac843ebf4b9b27cbe88e284ca9b5e756e36866933e18a1c029834a6dcfdead562775cfe67adf3254030b9c3df3ac898ad3c3a3fcc676d6888ef897a6835a1fe47dd55d2de62160b979e6c9af1781872e68e2d945ac2224c3d5d911fc6a59154102f0da6245850e7d53c08f7bdc96dec3f208ffdfde1aa38a0774c10bddbfc000313320b1ee861e03b016237cf32132a43d3a04eac264e92cf3a9fbb39b94e3d4b2aa4359de8bbcb7342f11218b7812b6ca9ca11a997e3aae3e85cebd90bc07e4f693b6fcda709f781dcaa5eb1928b18a067a442c5a619a2d6b0ece576834e7c755d8fab51547b9d6509bb027d44bdfeb30a8c27a003c701e8b16b9702e12c83994ca2e020cc35ee0861a3e1d1aa2203d962a910d1dbb0582b69c3b01511de9c2614b0f164ae8b80c13a644bd8914be6b0905c3c4c7b6c03a985f138a49eda4d21ebb359bdc15d3782496f1934dba0adda4281e496d7c4176076ac10489feadc7a9baab70e982500494a4f38c36f180c43859bdacae5c06cf9f5f78660a541ef01d7c5b81c9a6fa9bde27282547432f9a6c62214ed7b51d55ed5cc9a700e5b450fc43cf4c321a7eb61caefab70cd7317b59285a208a2fc21ae57f08fa410be2d4a972e1f96abd086689ad49951fd221fcd04fa1d2d0aa7250643de600bc94b257de4dbb67b4a264a02247f6c5c047b495907a53e554791c5294bd5b25ee95d1ffc16e39ca6abdd9e92c7be2dba1b0b02887073305f070481b09c60f7396febbdef092cbcd5732e705ed99fbe8276cf6d8467980626a132d6dbe67970ae58cfa107b5463cdc34f83858556cbb584aad5992d106881ccdb0c7907e98fc906e3258043d300f247239034fcb1efd1ccafc00b684e12c4f62535b10159b15082be54632cf2f0f92cd902253d78585399d7a7016eae19fc3270b04d4e302e9b08c0458493e66aea7b919957e95a321fa88302399fa2bbd94a85d4ca2264c13c6c80baa1e10d8b7795cf980882941e01397c9f98a4f66be5245770e419e7ca4db77d5a97afa3ab895b352803d3b71f7b7dbac8e6960b2de3def938ebe332c9488935ad1600ade938107de7a688f71fe00e1a24491c59fa0ba9e4e1dac1ecfb6e019582da4a4c64d3230f5660c850be1a745d2ad5db117aeb113a999a7d9584352053b7c83920833227bdac78cb366ceab2c086ac577d82ae27cd3ffeadf01348b88717a0b5e6f23e944a9ea0cb05862fa553460543980740a62b66df05106af916ff5aad73e7c2e5c7e0c8f7b02539b4d43ffbcee9c00698b8a0bf3df6eae3ee83770d92c3eea7e01bf81ef6b023054763fa522c4ffb52ecd068283e8115f29f957de126448e537274a009b2facb8f8644ba47b3d2f82d86de1247d4aa01b71f7b25074311b51ad3a36e15972c529f5ebefd81d9ecaaddec5b7916ee91cdd8a87ef130954c3d30d71c2eed96dbb82b1b0c4ad9303a02c3c5ac3df8098e8588c83e32657cf2647afb67a16ef9aba71207dae631b1cb66090812cafb80909a9a48f4bf2264ceb79751b1a2102fb4e2f61fed342e5b60d8305ff01168fcb30539c5f4c399437bd61796bc3718b82a328591f140027b0aacee4aa7f09d235fc2bd3680f6cdbee9874fb6748856cc8a8b776181f1d2922037238e6c827f5c73a2c99a0d4a906c27987313d3bf08587b93f6b16c8d01017bd831e83d1fc6c47370e01fc34a355664fff0e0c2baabacad8e2b85814b5a785820844319037fa3becd623392f4dbb41b604b5cb3fce449beb30732e0d36ba314c3d967f8acec40bfb890a462ef4c3b29ed865f8d36923249ab25764458a5bce246b0eb90eef9965f8bbcc0b590cd717d46799b84f552e5251831ea430447a2750690e213ac0648be4c01d0cf29e1a91a7527498430ea087bb02155076a597af4fe56e280f2dfd2d3a401ea3591b7c0e7c834e60eb8e7b3e8e710ffa7a218091daf3d140b64bfec5099697e2f5358beaede583976511e0927d73a14385802ee34d69d7af40facd48fc38eeb3bf74cf9e9c565af1dafe9f84fceff44bdad213d3c01dc6054b59680ff646fba2285ef4628f25bd7cfa5522f3a51a2e0f466860853f8c41973bc2b3ac9e202730736394cd11fddab32828fb20a0e07abf5ff10a103cbb7bb02602dfcd5b5eaf3b1b76b2a0fce68c6520b556fd9bb938370084009b43a314b9826c96254355a79db5138d6bae7725934579d7feb498f8400ae64a27151143f63435e5e67ce5b2b2b567b20fc82830bdb31965ff75ddffd490e92925662e881bfbf4deb2d9f75a1588b71d721bc6f9963b9cbe6a0e2e8e06ffabe9127eedd0abae87836118caa8e2b4bf07e6573bf6b9e5a701ebb8c2ee685b408424cb4b87b440b42c8f7d2166a68365c38baa27a595ca8b71d7f3c9b6a5f4c76a56dfd61801fb2fe330ba09e8e8dc04370ff8276dc7065964f3ca614b7bc3bb9ae817e94a6aa7a81fc12a1c1248e10aac106ca254f5ad93348d9ad776afbf0c05da086b8d57a7762c3851b923fdf4d5994abde3910075f43badb0619cb73311b20e55795458e663c34932c04a89379edf5f44d80b12fb27d668a049e0823968c7e0be35f3f98ee64ada02fdf43aba46a3144f6fbf9b7fbca804eaf043cce5fbdac7058647bbf4dc92b0cdbca2b95f38af3447a08d10f43c7efbae5904ed0b3013d3ed7d55e55642a7ad397be737834c9c6e0f2e3b96ae57827bd579667503d671f6639ddb46c2a51a536f4f8e2a3ec0a0ede66133b744e3c52186e4a0625d38b8fcff6c0b529960e39bf666e215722d80bc2e005a570cc8fab824329f82d6f52d69764ba16337e82a7b975d93f042c6201b508eb8693606ec9c18662c6a64a6d2b25360a29212895ae0b8b87820b697524e261d3984082e22c683a788de3091f0106b2d775d28d9936fb2e834177dd15e665a18e34cbaee00218623c1059b4cfd4128ef672de75479991b2d2d517d58910209ed7117b4d80fe4153d8511a55facafdf6b151db69a92cb3b6943a96b697696c3d42de274c762cf449212af8f195963f9d615ba2c62a8f6cb8de7dd2c7cd4c01a789ae2c949159a845dc245ca9216e24967811086625e495175c9a1d6b67453f666150598e8b69ae8283bca27d0ee40740cf07badcd28193099f7a83eb1e5a0d83988b11d047730e39dac726e660e5581624f69150f80dae6298233610f5c32eae2f46a3057c49852975ca3c5b2b58aa46e4b5d494e48f166c74e529b47cc4fe470490590968270657119467a90422302d45a8db9d442e4d4c3f96fdab628c8397c07aae5e3600e8efdce911080a61750ef342da67ea02c3d0bd6573840eb4c6a750cbb28797e2acbe4d44b811b9a17067defcb87e1fd941173681f19bf33e20dd24b3aecb60bc05ce21c103640520a2dacb9874b6e7dbce66dbd80b74f93d2bce58139a3df0b3165ad5a5acb0f522e7ede0312762d83c80126f8880a15738613046fa669579ce397cbfee8bea9af385c73d7265956eb8a4b2a889c522f2d57f9ad79a188cffbc0bfc3242a7e5c3b7126ae0966a20e4b8835e770e40f207450a3e29ce9b34a0f5b7cfbcd36a6d89cd7a031e948483667328e1e485f0937132112e1411bc0d8272542ce0b6cae38abdce2ad88488f1e5babe154c04915675233fbb71d429b90c3c956c152e4c3874c54b2081e81deb0fc40b502a3cbc38c31e99f74989ee02f136b6196ec71c4967c7f1210db10fd1cdbf40f1fb1739efbaa4467cad2bf4ab061c41aca109fcd19acdae72e762fd8626038b66b5bbe7de824fcb0303a8870620003bb6b83fdc2bb7844094190df6c0052b75cdcafb6b7ddf5abc306f006479a7b79a0c0b1f60047120fd7ef55e21de09d1279d636e24ba8b5a006994a2c5b5a3c0465d1963590cd51872bfc91aee511b5e5ad7cf5e855be31743d263605df52b66ee9dc5e2817f5f290f259f19dd2b817b5d37dcaae44c6b3c09553fcb4f3712ad17f462a45f5fd7ed2cd889f598172fcca268176ef8462b7a2215e7473f3c665330ffe16c11ec67416b5eae11e5fb6bf1e4f7457bbf5fc495af7fa8da8dd2c0a463cdaff5c3990f16cf9c92ff7918e9a310fbc96cadf82317d3712e4e84b6a65b4d6504326eded712be470ade6b888f8d27c1d3c2fd077c6145708f1e9834e17e61926fd1bab1ca2bfa3c58e88a2f72a6eb87d4b773d4ce506c8fb59ed040ced66562b252caefc67c3f876f5cb9fa7634d9fdb855d9aad6c6f6a13455236f50b0f330885d5d60914e6b24e86b364f30afccb6c3613e85a55fdd10bf25eda85549ea825755a7cac7dc8fcdf4eac537d0cf31ff18ff10e3fc271524fc4e35659842472d7b6e18cf6cce0b7d628e862807a32d983cf25182c597f4ca409c11c422e71b0866441fe3282405a0231f1a3c247fe53b4a15f25ddffee535e24b58cb8ec9f432c270c557ee9d117d6e71f7d5c731973842f763a7a4c462ece2533fe37da7e7907a39c5f0acd359943408175c57fee3fe8bf4663976e1eb0d5ba1582d4dd52839425f19d0731656027db360713e2d2ce09c993b3eeb55cb109c3ea6de931a5475f7fed4f016201b4c80e65a0a6ae68cf81c814d030996babf2b9ae7367f28fd6f4ee51d3f7aff256f251551a9e77ec497fbd73b397233767cbd94c91b44ce889095c6880041a3e18051afbe9f0d51b3e3b017c9bd52aaa9a6ffd840b188117a3fc7808c143bd29b081af32516eb9b9a0be66c9d8078d49bdf19a1cd4b937af171361d3784963dfa6d1cc586416e415e1cc2947ac4c00d7fda4ec7e866182fca28925f2380b90881c29969dc4f761e477ef714394776d1fecb3ec788ff2171f01ec51a75ffe5462dca0139c3b52171a0d1d0d1e6415980049f72280a941b731cb0dc04bcacb80caf8344b73cbbe0827b2af7336f10dbaea3b477869f323a451e944ec17693984317194ceb7eb07efb8d2c10e83c24a60fddb6e2d304772412111df3728ff89c9e380249f4f36635c574d6bcf88e777d0506a8485261086313d1ce7fedc5076e782aa14e7f376634458f8942a116a50045e16648b653b2750818d64bacb3605b98cbbc78444c6f5a467b6a74422eec942154966ae31cf1e01eace91da53fbd6a4838e61ee67897bac49f0aafde28a974dce0a95dfd00c038ad60916aae312156d4b4baa8b40b730e6c6412d10aa0f30427cebd683b53262d4855cdc7072b8c67b9c703a09ebeb9e3bf3d3e2b80740282313c28abbd3d3d7337fdeec13aed28856c14f6f62081ecd2b738e4f523ed7d4a8ddacc8af9504ca8b2cc03d4ce3cd5e94b3f4c9fea695cbf1e2df706762efd2a69b6179864c981975341bd9f82f47280cf18acbbcf3a7140d2bc2788a6d260508c170a23b358a2c0f414ca1a72bea7e2d23586f2b86bf420e8b98bfa46b482433e5bf357013de16b3e64ccdd12242ecaab27fc49615432fcc485cdb3cf6e56f521482a44758c3a8c0168febe8690124f4d56369dbce2357426c260abf73c3122ef3ac0296c3921e32d83e4d657e81fe1804853fd96c5b6880d8a8243f12450ccdb1b800f52ecddd0f2384382643fd96b7b59ab237e3eb7d00142aaa1f43bedbab9203ee496d4d842196cec7ecc55cdd48d73b07e2bc2d6e56b3361c1dd0d215df8923c44d8c9de38609471550108c57123dcae3688fd92df6818eff0540d0726471c823cf3250734eccc2bffd21e697d0e02317460226afaec609b01edbbc3844f5f917f2fc3c5987a3160a66c72ed9aa0f6bdded4620714647bf0600037f67de2e80a761d79a8b39e6171f9a6cff88d8637143385f4e91eeb06083a45acd26c041b0da6f65fc78d1b091a39c6cb71e942ee3ec699880710649c11b1173a2ee27ee411a1078275c9a5b222b8faeba44052effa63d6d27990105ec1eeffe6995d7a6802b3eaa0f293ecf7fcf4cd119cb4e7b03f10a90d6022a62390ea772d385b40c8e2128413505004ae36b55528299dacb42f9cdd9152449d6610d877b2af89ac4f76f10480d1477507b68c0de76332700b47050c7cfe78dabf9d8094b96c4f0718daa6346e89b8319c3f5e2b42288aee59aac54fba58f2b8803a833056ac50668c026b487c5c98389a5beea2b78c858d69d1ae10e0767b9a7d83965bf192db4dc1b88b83e43176c1ae3311acd8881d01cac05c82336294f325caee988c2320c6f87cdd96646257d9fe39806eaf7b52d21d281f1fa0cc9ca8c35d79e735e2f5e65fe31581017b1c2199ae7dc1e68f9c6994b2f882987e43696a3171484e0356c3224c8f9f0657fe65c935533b1934962457cb48e17523fc60e4288f3c5254e2aa8d1e85c30dd04e6fa9fb56e49b49ad7ac7bad337b5267410f210bd763eff691f1025125f49837079d61fe0d76751026f6e10c95e2b6b6e1e20f17f53b529d527e9045dd46caa9196b94caf892449340478a52c8cf397bd0eedf148e704c6e67e6d26c1e39e98bfb577c0f1de9ba5aed9492108355e6c97aa5f5c5c4f33470591808eb5e73d3dabe09be6f4f8fab5aa602aa99aa13f462dd6d7bbabb723eacbdaa631cf697e0d4eab94d010673bb16f6ce9a323726e1471ec1c814091b75884796a30ab183aab03007bfe7836c337b4e9710592cada08180ce250274a6f4bcbee5a9ec78fdb8ac0d9d38cc56ae18cde71b9e39d2e08b25f214a7640a45e4f7e83edf5046106b11982d59dbf565439072a8f1fbcd4bac8671b57550288bab950bac1f411becba61a346e74ba21080f4faf6bac8956a00980db0f1f0420ab91d99a476be3a74527c674518cd90fdd796df529c77c60cd692115c8d274e9fb9334fba673b93fde0469fc420b7254c13cfae079101f01165a7e76d8834a39f769d0ac1250de5818e3adc816dcafd198923b68797d0c53a6bf51e6f96b2a7d8b1ac00b134cf87caf81335efafa67680573d63b70d7af4894ade4f4893f1f51f4dd7bf28eac614dbb3c0982e93645eec29d55999c169b9c52f5d505ed8597dcaa2caa2879fa3b00fe00a9898791deea9fcad90c2e4ab203c3365d5ca75bc13dc8465249b7148f2e86189839f2ad245eaab0867d92b4c9eacf642b6a81e5fa0fba4f30b92b2870e14219686b73bc4a73577c8a1ddc87c55ba332ca064e14288cb1770606bc42a80aa16233bb2efd3692c8f2205143c67a41e9b7cd0141cec3a9c0da6953c6efe63883838b78f9dcb8c418ecef756a3058ca80a06af11cb38b3a8f862b270749df39c6702d505a1e9b2b6267792a140e904bbf5323030d3e34330245624f2009b19579575bf29be947054452ce246caee50110a0473f97fc317259adcd7f2a6ad12a811c698ad9541fb9d404e69db216829c68fc00814f8712ae226adc4b40efe33f1a1bde781d788f6d47d00203884ae735edfa93edb85e8b47bc6d592a491e605ba9672ef19cb01021340dc21690d0c90aa73c7dc65ecca2e31fbe62ce22fe37edb149a6b6f4b7b31ddad2e8d899676202f61aa0c39adbe2aaadd3251d963c07a7e8e5890f770132385107e4f263b045349b66a83ad83d6c5f8ea76dab1a6df3911930e710e50e2f0aa5be5c3167a6c397a84f142acb4273d8184d4a31d01492ec791fd193a6cd726a8266780b2205b9cc96152eeb44b12d52ea82c98526e55035390d8b3b8759a9af94a2a6a9f9a9f8db2f89a795d49f233444f0a222cc5a88cb3a14909b51509347319a1706eb62d9d7673e9e9d9a4b1f06c8750ee5d7dc13612d3cb0e6456df8e40fbe17b4aebe40350c27e9eea7cad84b6a1e45c83b24f2079c27e9bb735269a5ca660e6abac8f4ad472f920ccf54fff710a565d39fe049a4ef684ec7b0144d01c8a1d930274d6e5f796e03016190e5383139e12c9e655dccf34b3646e32ffb069375a51d52593356a50934893bf64eb2b1d8b67f86a02115bd3247b3c5d5875822302975c0d59ed2bee0e5a31f266d37ca0d65c0ee603054bd2a00a5abfb167d31c1b99c72e39a0215bf9a3f7150fc1c82deb93ac260ffcb4a6a6244a5c065d56cb54cb3809712ff6bf104d576d136e327f1dcdf137ade5e8227987f7de0916aabfb34b2c71d62265a95c7bbd5d331087a55aaf6d35ebee2fe6e03fe4f80246a9f5f123ee60ea5d1fc46912c2538f28fccd02788d221394a22158b164f2f29c5576bab644cea905729fe58b4d0b60e07626606a868bca44a207fe043885b10769a3830fa107542f08577933c156c498ed4d5f037521e088b161ce14d771d178e6a19bc9891b94d35ed4524bdeb9ef7cf849f3123c66c6664e713f0d23857149a82ef9457c6a9d2e26a375b4d6ed083b0015c224989f91399465977f86871271b57fe1ba6c7a0001a136c0df6f0dc3536fa26307e5fbd6a59fa5a149eb3fc4289bd28f67acd1b51997d0964b8272ac2503af1a100d21a96e2569a73d25c1140ca7032d756c5220e540771347ae172cd194af284b918f91bf8a53e93af1f9c2b3a76cd8aa717d7345212717915cc5c4d8a8e65a90f50fefcd8e8aa87a45b661d42904e4e212a4dac1d2438956b5ae03ef8ba6fb5d6442b49ef4b0298194a4a22cc294ec9997b4abe1c0c5a455951edcac5eec2c5ac2c150a17b63eed7a1e9f1045ba6abceda7c3430a62f1663776edff7d6798216b41c7e575bd5106a1455547facedcb875e99bdce07b124bfca481d6ee39b8c156aecdcb6f73e63c7ea3888ec905a89a8ca8d498939c2f5df61fd58623d9157422dce534a0fe8b4551444d44b47426849eb9c0294915e580cc7c099caaf682f5992c6a4f2307766b81be0bc150ff38448c68920decaf853a135bbb676b2e2723a28adff03312d1072350070c22588582eddae0b9a5e7e3c2bdbab7b43c2967ac42dd164aaed40037bcea37fe9b8e69f2be551a8bdfc76483456c1e81ec728175aec96f52b3a5bb2c4c0e1aa62a738af43f972180153a5bb823150387bbb42211c93a33b8cc018d7773ae68932452af1d6aa6613c4e9a1598248590c50c142ab46ee39b676e138bff7a6377c4f34f1b3ea0d0121633535f812c0485546fc4a2a7e24c439a7355c708148c3a67f55c22ed7ca6e15b830d973d17a8cb051f4d035aca2d54f0a11890f44dc6712ef68d18666aad09eca68ee81a0cc0997d8020699014dfed0db43e0b641fe581dd90f664ee4cf36f6062a07327d41355731c1a431d937696a81f8641a06ad1e307c3d2a0a75d238a30050d64975c70397322c03b4628905d235b6a43b29888b4f4c156d329b4354798bb6756b834ddfae327b1385f22bb90018544072ed4dc5c8f22b38fe448b4099d95738309b426454758f2e9864cab365d64d9693061c93e91b921020698b4b2d3248f043fd035bc4b2b621c2dbe41bf8b60f059127ab9bf0eef80a5904ca30e8a59978ff6ddf9a252e7f638185a4b1cf293cdee9e507994527f06c2acf80b5c8d986f4f62ace2ecf73a23a7b5f8f2946801d4114262c663102f63eab8cdcfcba161cb8003c66e5c618bedb324bfb7b4bf7481386dac845d4c809d7859c1d40d2a5322f820ee27e634f058d01bb9ef46ab20cba0d96dca72295ac75be80b11590cd10b74d08c9b17e6d2f292ab0b1f91290343802fb7603e58581245fbc7911197657564e5ee5dde4c127c86f918487269a0b243fed9e901c9f05b353c9ef3658352a370bcd48b27cf7bbe758cb4b2010132629ede7d3c42107fb8aed7f668fc91913c6e4acfc90f1a36d10f2d63a684f958a610e5dab46ba13a3980e0f3d7e73a6abd98eef699381f6cefa6bd378c3d4e0e370e649e75441f192c7e4acb90469eef5540ed8ef2a48977d4003ba8f522abdf28c3cde24049ec6e079e78b89bc6e554eff89285fba762b4f9be3bd45bbfb907a7ed9ef5582a633f4ed5be1bed767c38a486987d7ace5b9fa3847a23b4182ecb0c53cabefab646f9281ab3ffa26f765bab61524b1dd7f98f61ae72adc21ea13e634c85490db94ce8136449243adbe4d2a05c8a7f80ebb77085e251fa8d135dc32df79523fab76cbaf9eede644271cb985943c4dc926901240e89cfa323897f8669393b6791a453fa9b1f1bc0cbaadd1db61b2a9fee19b40768c32cf57aa53bd79fdf514c2f3acf2e926d470d36880eeaf46f97142db7af07b59b3a6be73747eabc6872c551061b67c7600fddd9b08c0397c3fd1dbea05f45da3f24dedbb644602850fab78480e13ac9211a6a2b47b007d77601ce8c0c28f6c4ed61ffeedbd6248aea4de5864e0cc77adde8627a0d1e0a796884ebe3946902d627318af4c15a752bbfd9e1e6de9ffd01d4d0b93799dc71c3fd8c6dd67d03da4440ab8f8808a6d233d1e535909d2ad46a92fc05fdc178a415588e5a879e332b86fa78a27bad98b5b14dab0f668fd01e936b07d1b844f4184df232f14bb6ce9e38bd2261c0fd119aa5f3b587beb9f46c62ed80dd80fd0ec5ce7ca5685a2fbaaffafe539eacaa01c06fddb51d45c525777575509876e5fe6d74568832fa193025b8a70c041fc4b7a40906a80d8e95b719d7faac3d46a3f34802f11375d1e3ad939a2bc6fa7e18e566c383686691b3d2adafbfc796a3df9f94fac2cb1dd24cd2edddf078d78aaf95e89e6ee7650959b6b69e44b98f8f886704d0be4cbc2860ab04507c289504f654e00b905a0a654ec3813708d06f16be937a09ea8b7938cec3a1bef0d973caf0107d3f7b0e5672f4ff42d72d376b7d17848acf7bd12cb174e2aaecbaa6e941fa3157a43df2bd4b1a9d7973be3d6e80ddd2965d9e2b1693cbc3f069d3ef104e68226201c2b5228044a5e285938b9e5d16fef6a7b654b1e4c9615e50c4346b4b3a12ee06468a8cbf9186268eb316a766f8303e61a971d99e130910e4bf690575dbe5218b137c46b478ce8c2c3acda40594ab8880e0e7699986407ef9ab5ea18888776633232b1742aed32b887c0e2c42141c3da448d1a3045c710dd775e40a3d27738eacec2ffae1edf3cc68de276a334ee505610f6291b70bada1fce505e705ee65ac87af97d7eadd5c39a5299e381565c1d2f0ea6eb6b5fd6c563778f39190e74a50f73b381ab1797b0882d3e9592d9dd3fa1df5d11c69d20a0eb806f06b89a6cb172ae08b492d78abaa2c5300e78bba084f059805bdaac4c55aa03fe6c0014a57cee91e65ba1b598da499baab84e9f9c8166c6b83d61e55eb8560d26d15d258b9f676c5638eb6298fbba8dc0ddad975534888e8601ab11d2412bcfa6e3554ee40d07a21eedca0938a8e1084ca24cf26a180b4be82bdfe23575ff11cd1ab237d7437ed460403190a9f7f25f4be5e6086d6959b9866c2ea6f1d3a39d7d73cf4d2b99fe94f5f705565621995a1a24f8172376a2a6df64c60eefadde6bd207fc28edbbcca2001fc3ea7925bf8e3678a8faf83a01afad999c44d6cb18df5b0d10a963b9301144aa033ec819709f284b2a4769dcef8c3aced18e8f764896c870381bd182697d4852309156616e9141adb2153a94503e3e89291752319ea9507a75191f012642bfb07a601d219efb1af4993ea8c78566f8c52025bc9fe242bf475a83c096687fa284bf4a0aa07cb297cdbe54ec5ebf3960b18506fb996128345bdd43476611a81305b27fca8031111073360603b2ec1d221ff4894a2f77e5872066809f510aa07de0fa6fe2e7710c7551508a3498aa017ca2a6a87bff4b7ea3e9c68f39673901006fc60a764a5fa66b2cede5d0f2b31a78a14538b2f9f1c4b1ab22c73b22520a4f086d6813ecaac2053fc24e42cbfbbe5c6a2fb86d6f55167fd2c3089355ce7a2b2dc52800dd6080dceeb21fa4999ee850944dcf6121895e83c5637d2ed71c2074418a7d0903763b7f4fd6fb7272b7cedb7659ea753ef40d54da43c1c1efe68f3b98cfb1a6c157fbb65bdda67653a8ffdde50d5d881e81223cd44eeecdcc581032e3a9699bafe917b4f410f4c6a96b29cc2bab7c648707704afe70d46b6084cbc038f2352e64b122bbe9baab8cbcc83a6b341d81ad24e91aaec65db6562b972e16cb055d3d4ffb8cea6dc6062820def8adddbcc278708d5a42e5806a1e93cb4945474b1a01d8019951e1a35949c22a1c1ba9a838a616ad5412d80343126011e69bb0533db29b65e9f25068c78fc91ffcc5722c4da908e60a54f8d2bd549dab17dfef25e3dce06f57344a07c6f6a8e93d3ce9402f4db1e40dec6eb57c29a6289cb9b71ec92e4de6cfbe4c5bcd0a0f67491ea6d73ceae238a75404487f3e65144fc2530e9b1c7124ac8c23c9a94d98b9fec4669fadbccd78665fc6cc5c691cbe3a8e52a8dcd5ab42f58d32143f9260bf25423ec89566b7ec2dd3c0835215cb519e6e54eaefbb8a90a1481c356d2beac581f4e8de212acdc95a635071d12f96c5b405d8efbdd6bb245df38f139d7667d586cbf5ebfa2e37a1086ceeb334c2b53b620637eb7b87e8c65e4dc7fedba78ddedc5513ae90c8d7fcb89c043676ec0d941566570e472ca31d6f024d14a2bcfa0ee0215f37f3d47b6f05bb109c95fd8f025fe7d5528cc7cd51a04b06354fb89a9195346806b8df3d35ba70d7c44a9d9c3b0136c7444677e8057f1d31b8420bf24e2345c20be1869d9b4d9c7d72c26e93acf6dfe6b5a8551bfa89e8564488e4cf8105d31872fa4a7c9ff6f0b8c175ef938d5afdfb701155c886557417039b9aa83a570d075919d5d0eefa3f0415b34e9d1c3d0968274c6fee7d0818548a08ebaba716b3b505bc530d571a14dac5f61709fcb17141cf7d0a21d54b89d509f823a4ebc70864d574c81043c1f68c8d6c9eb58abd912542a753e3318b2598b5bb190dfd2622012d947a2a698c7798128b6d28e23aa901c9c31a6a256a5cbb04a4325a3b1e347d4c444738e291f1e45e7c7c95f867a589a49fac2039a3e969e0c53d01db8850eccba6be11e9949dbf9b86e81ae9892c36ce248fb8c17150111f4abc3435485c7e063b154b9f4b1348daaeffef42575a0b5b56384a7cadc59f1befe5a04c7c6f32d9ce84da4f9c13a26018d8513ef3a9253fed16ed7f200db3d07fefd36ae44e3fc5395437e2e2cfe327ab9e836170c4b0ab75457c89a410dcfff9ae74b4564496d07395eb054d0a920d7ed4b51b1872ccd9edf96138c3d54f048d359c7a414daba539572bc50a192725f5164a7b717e7e25452fe3e555795d76a297dc1a78e2478dc9a9047397ea679180b0cd60f6b32805b10f1477686a9959d04bb814c4e65814b879b9642343d26870b179dd0adf5598cc3dbe07882d8abc663ffa6c9c32a24816f9c0ad7811fddbe10db7b74a48cd21c8b8b144f4c9344994e919aca674a05d7f9b78fbf3cd6173d683789ccd14519329a99f4be8bbeac5a3e5900ae34559e6531cf289a47aec356a20c52f9c1238f95bbea6d6a6195ee1217461c39e691e99e032cfc81415e3a7860bcde3e8a3fbecb2a3f93d9e40eaa6679ac8fc9eb4c967a1102ec62d394534ae1221b3a9731322eda8793af8870950770b8e2e36f00e9068d5a9086e223aa3f9a4cd51cc1c8b0733c924b9ee4fca06ef6f01b3e10c8e6f25f28f047ac94ed49af8c92f632b685f79f4b819185b9106dc693c29f045a4dd2935153f726aea68a161e800c8551ca70e99c3fc6baf95d18e72db83a008133f14b5aee6715c9f0a2716b2f22c8404a7798ecbe440c0404217e08d9ea51a9473ed530805b04ad5c747fb4c477c769292b762d8efbe3ef095d980dd0941405fe9e1d380a9cbc9db029d7bf58d9e109b5fa1d6572875da208116e65bf0e6f2978799c605a60dbba2181cf57a4c7a148bb4c49a763301eb150f5a5f7516a9191f97884bee678aff70e3c8176250490c56fcd18580a12a5852905209ddbb307eeeebd4911a10443928421a820513b677aad16f1dd43c5961c14809b06b74dd8fe308fd6f2625abbad3ecc9af8c085b3f306854c7d5c202131bf3f7f04ec9307177873c48e0bd9e2b40e4d85e7b0510d537be06fe0c9bd171e9ef05ee115d67b59f1e87ddb5dc3bcd728de7a0b219202501dcc02a4e010feb4d66b539eadaed11a2e655fbbfa0e2f57a0355975a64f535b7208414866a09755d694fab4894e34f8bfe34a24f404efd1485bc1355d6bba38b1e5196d05012127b179965a77bbc8c58813811d7a751426288d4d0b481a4bb5ef40361809d81d64d74c65a16512d2691bee8fe32c0364407ed71e6bb91b79e73643980389370fc0b302aa0956a2e824a06eba549383a99e018951c499d5f76e12c367119124f32baef15c7eebca7f98f22d61a01ed61e5356bdea06656976a935317c63990996656a48c0ba6d525f375818c70dbb64ab392818c8b1f9ad12a9edd6e7e36b95267d85251dd0fcd4d01f5f135706a31c14b3322592aaabdc8955bed68ae1696f556423c365791fe3fa423b58b9f79ebd05acde11227051676793d6dedf684e8b2cac6eddd0af0264298312d9a17470c44770eecd6f007eb0640ad76becfbb179b9e4ea56bb929f962a8c445bbeec3bc75967745c017129ce26db68a5256736f6aa61a0fc972198dd11d323cf6ae0d985b3d71e35cffba4dccb3ec66f700ffd349cd8c1470ac805c51ce6fcae3a61241bfe74aa32c98135aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
