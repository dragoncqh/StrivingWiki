<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1513eddbf0fd70cc8caee38d05491a74c1a2f5651c2c633c20d79156f4f03da299d4ded3ae422cf80d546431451ad7d4ed790042385276e88613f064fceeb166632fc1f83bcde9db3e928f9622c6585668a2c9a0238cde94b4e25da535f8887bd951f5de52436ac10cd6bbc5a797648d14360532eb65c5bcd6fa9858cdd6c532d5d14c539443cc2afa33dde4c8f5739b06cff1931ff7c99316dc7cc4a3233d40b4c5c0c2efb9e7d5d0ca3f13aa1089b3ae20ec7eefb8276c9584f31caa6d5d8d4b680ed7ebafd0373525d23ddf29053c58d02972f40f7c7b0fbd44d021a937e01afd1ec5bb1501acaf86482bade23d89ffc4995600682b17fcf2f4deee0ff8c6f2d8ac756ccba7ffb652b4fe45d60432700f1acb2cead31ea3f9c53adb9bde834bb425312f9bce191e49678fd612b33ea4f275986d29c76ab1f12b40ff86e9988f276155066dbbe646847ca31eb6ca432515393be362ed6bbfcfba862454d4c454cb4a09fab986a6e4913ff3d30fa6b0229e019251dcc6707cfa25ca3cdf850b6f98296be7781adbe91ed98e747990b8daf76f75b4b4f3b38919f918249e853c8630a6f2a1aad5f8fae1c465b160a177b29080de33b605ccc81ca92dce835f64fa378fedb34a71173b5200d68801477dfa1e61531bb7207ec8dfbbe18cdf3ea3a21f71a38c1b518c39330a580a609b71c45d3ca5447fec4ffc39cc1cb818950e8dd57c870ffd88f4f33720612c0700d149ed2ae6197a93efe220c7f1f78b11a3c5db49f292f6fe3f8bc11b964724a66c5e15747c0b66fb527f906e8c1d4af6444a9830c9f555d109a14b3d123130cbe7b686c86cfd55804e2d2382340b5b3a706e6c1ac708d7ffb5ca31c8c66d596f7387799d460f0779fd2ed32fabdc78de3f3f321c5c747cae57bf1ac717b27dffe4adb27cc7df15f1c3fc3d268be3fe463e0776b63f7f808becd1cd8fd77ef3030a8e6f8381507644a2ff3f6bf5596497b0c1d9513af8ed863fc2f0a4b9b59bc5b5db580dc00d966479746d8a2904864b534f1c6fc88165ab388beaf7fdbda4ad3027178842c7767092c1187b88be8e5efe27cacafa08258b00ea72caa660daff561074a47eb599488e22cb5d9f5a9dbbfa6f11fbbc0686f97282874593ee88d3b484ca0fc81b1f53a30dbb9ad7192c5c2008ea027e09744ac47048aaa5284abc7140d00f59eeed0f76c936f1ac72f5b837eab6881b97750a4a8d0b5a978d8f768c805d3ba1fffe1f9956ea7167832ba0c7f568dd8aa72033f8c8c14bc878d1f541c3b956abb4159db1c8a9d4af238f245d7c962e35cf1c0b47588e0cba4a475884674bb8978805fd5178beaf197c3b90c286ade7161e5724b5de4cc47d0972fe258321e23839e23f7f72c67659038496f12d63c60be56a4511e506f42cf8b26372a315cb6a211b26dee221277e7212118ffb0bc60c74710ee2f2f5d5a6f1385b55a49147fb562512889b6d0a77f72eef8478552f1679e98f5933a75016b92b8a77806bf9c7137e84a50c67713495165248a136b4bff4215d85c9eb31cd1999744391ebceb2cb8822bdef038a1117a99b456f5716189b3ef7efb2c733923c5fd2ff47b07ec3d4dff829146aa819f208f49e2cad86728a5e01766847d111711ca4623d706c0c25e236b3c14bf942a9adb27ecf55fb1f7ea04929bef1a25a11a880d68b193c6298f54c15b39235a3a5f193f493ea62ccf9a6ffe910009f70173d58f77a118058156b7ff6329aedd67ea8e2e8c08cfba4d5e3fb5f5d8f996ec2514e4ebdb97ad68a9870663b7e2d993a911d93264b9cb011197eb8399f6cee4e9efc91f6403cc8c2c0514a2e151c7aaabd55e61a37c6aeca31553598838764384573250d61fa056789088e6ff0b47f463c7947ad64a66624232bc4067411459b74b7b06513c6671af05bc9f4e5012d7ff66978c9b1fc23451c78953bbddf92c0274ab51687f49bbd48bdfcde082304f884affb950fe518d1d1fc73e11ffd6a3d74d0b4d3714f8651fb81efc3a5bb30d0db90b3c75fa4b0a9d06a26c48d30329140f7b49c9476eba9aaad696d3b62b9caab7962a27ea268350d889d1d3b0b3c72192c69dec1ee5e3eeb5ea20ae51578fd6dbd0c4a46e27c837b06d006790d896992e6e8d5fb018e63984ff73252021f0e81b5b1ee767cdeb77f4ec243d1acf7743c25ad6fadcd5dbd2c3ce950a7fee8720a1dbd63702dedf6a921373343bfc06201185d9dab3f712fedb5b2b48d7a213b7df18f82c8fcfea44c1cbd706a3e16b1367c683be805de64a69e93ba78cac6f2732d54c0f64c386c3991e37f903bd8daf962bf191711f520cc0c93a80abe7fbb4caef4efb0f8925cc67f3e61d11a363f808f310dc4549728de613362f054441f9446e366ef93b85d143f42ba395d0182a2c7d808450f4b01d8f6138900e6aac21d6b30a1bd68566b80a6e066e28ad90d2c6c95d5941fbd513c9eb2eab0c18daaae034e09a5943c575c4fef0d772c50cfa2eb51e60ecb58b32e56ea68077b555c493c1b532e45a67e4f659fe19215571c1159cff9abfbd0f3ded36cd3cd391573fe91ddb548544d86c575cdee3066b5717e5fa8e73e2fe7c4a2f8f49ede2d2bb025e4aaabcba39490ee7b8fcbe4e41019a5c679af75d14dbd25160eefff1279ea41849bfbfdab16088950d21fabb79e77b9365c2721218f76825ba1e953b626cb28684fc0e0c8916d09b442426298fdb4360e74e2ae5f365bf591f73fbaddf97e452eea15981d528343ecf0e2abb44fa645133e0d26e7231937dbed9a8241b7ee9ef032d7057a5edcbde7ef306531a4f2325723ef5fbdad653c7405fbdc87baf4a72c2c2877c11f2f7e6939c0b2810a0b61f6f78728c9e07f6b6f75333941f2d986d422939f5ebd9d57c6a6e2f5bdcc839a5fd2a7c2067b02b3d4c7a392131876bf0a8f9339368f3031f15f5ef47e81395b70af24110524f85351bfc781dfe8287197c430fe6425cd4bf26674611ae67dd7afcefce7e836ac57195cbe86a294f7e07c2c084898ee93677dbcfedc0961785ae6362d94ab49963436572d99458247a84e6de08f92d1f3491865fa16a43cdfe6cfd384ea6ae4008a6e0aee3ebeb06dacee805182380b638b3918f6b5c26ef7a4e447bba15b83af177da3b753b7f9c0635ff794ca404e3b16ee3bc4a679510795182578e9330f8c29d1e1892a1c27328d182aff5e65e0f6283bd232034a0768620d09b2f66c739e5775b4af2111d96e3ca0ce4291bcab2a5d1e1eaa0bc4f95de7c9e74be3fc4473090e4babeb9ca2a9aebf1a8ced004ad10d7df19cc6191ae218a1c03799256050441fd7d157dfb54c99f30b85e0d5c38aec38d6811021f7cd3969ce9a2e2999fb509ed69a4bb60793c6f96faebcaa04e98417d5bbf5139b72fcfd33ecbd2aee0e5a6fe26009ed5dd392666518d1b4fd2bf7580779cf0be4c04b6a73acabd2f1b71b0876e1f390c8e13f63c40f21dfa971d70f01c1546329c558ffa3b22388ead7f6dede11b6ba63392a59154bfd95536735e567cae8c07bd163b95be505766f20aec70284bfbd361c810ba9dea51451c570b8110a6dc034c7de5aec49ab3155536462fc057c8790bfacddf2411d3888c516036b9522ef62fba6f7ded997c8116cb0548ddcaa43949cd90d979b1df909c2e5c895382b2f42edcae4e87571b16118a06cac2a2449a7d089737a20e39d23dc397753a6340161b371d32398fbed9d490854cc8997b5a452e0c873ecf5fd0ed369daeafa828094d0fb1729c9be59acaaffec4d0c44a2ece471cf94ff618cdfdd76472d866c3d0ba3c85480f6449a7c1545270afa43bb0a60fe37deffa9a2d7c157e07665a9efbccfc937497f2a9bc610861a0013d605086b6493e07524f1c97266a47b5ea377761d8fb61754b23117e05b15934ee7ca278746e9ff64f5026a79c8b755d563fd0b3c0c5af26a4277159fa23c536f233e0071becc65c31fd2989ab031a9b3733e393c816c19337625ad2bf55c505b8ca99bb161556c42eb28700a53a60ebb41e834a8e15c35aed70a3436e77d57980c904bf83b65e1bbf2b1918c482eab3d572c91c89b61081f08df4ea260296ab82178c1feb1403f85a6331171fff797d19d071fa085c256bd69cc66e7f5bfeb46e700cdfd96dee2ea32bebf7f9fae2410ef2f6edebd1351cf24de86ecc0d135eb5561d54827c976da3deb64b4714f07e96b31367fcd81cd772036b11bd518262386c549bba6322da68d6f6a6a75444e83fb3d732538950696c7b17673651e56585c92d0f2d94bbfc0d93769d69f12868042165a36ca45c7eb3f31fbdec895f9ff37655a97f52936712d410aa1a1db7d2aa0ba8499b900db826b2a1a0fe9fc47c17b10e3514caec71445a639f20a0d5058bc09701232f99c7cdcd7e60c1752f16a12577f4ed772674ff8da1e32c2863f0ef1c4f7c381e49359c98a4b35cbd30369277c1a2a72084200d02dafffdc555a441ca777f441a5f0f5fb56762cc649b57267c78681937a2052c8d6f4d251554e00645f03f070c152ab725994ec6e01d958b96ea43b9e7f169c314babfbfe99ac352ba1a6ed3bec0e1af5db01a1cc130432db1b20494aa8da0fb2ac84e2f45c4595d98ed60058c4db91243d59a6170def53bf0e4bd8ba7aae07709d4f802d39d9b67fbafe051959926a65fa12f556514e2b85158150c617fa1a020d134e9ed98c175d7dc865766fc4de6f2107e342c60b4612fb5de288e4cd7201c1ab3d65147eccebda67c603c2380174b11d69847622b4688c5a3016039b7e0f7945f2259ecd59dcd0ee04e2eff29358df4727c47b36e07a3eb4dc70cd3fdf19186ef0033536021904dcf7dff48b7d312a312349afbd57c9e724265108977b679cdd171b81d819296ec53f81771b312e8f26207478ba3b591cdf0c2fe4983c87e9946f5e9165bcd49740c658bb1ea6f53e05b1ccdb32b8f7e1d71a5c5268510ac710f20676c01ea416a6ecf8d4a03d10c0af2fef5bca42018f0efa084d490e1b66a2f5c27f50c9ef23b99301691ab78712706f71ada49e83c12375bc3da09b61e7bd9702e0b4f33ee2d6ff6daa48885cd86e454a313f5ee93c07ab5f98dbdd0e82379e2f0ca06c2395f54ed6482a20e5357d8a3a8daadaab997736a6f9ce6551d9a226d45a17cccd8d7d9bd3e0b75b96374bcad1d75cd203dcf036c066f92761d1cbc9a83b6ebae7178362fbdf84e5e6ba4ad0adf4d7dbc0b13d08d91adc8c3fd3d930c21a89850f535522d06af8866f011c7ed7d50ebf353d9733825c3d0742f267aeb9aa464bc3ebe3dbffe37d4ee52237ffc96939d715e6efd59b1b3fd58a598c2b09d6ca466bdfaac11714537cd53d88f6bfc5a8314b9e3559b579cd0062be0def13a36e7bdd4afc6f368d1347bc4bc22eae140396de7fc71224cc7c9fd1f0425f86e754b4a349655fab76e771523a9f864798dabc721e0365150e35c8053998ba5ddbbcbd37898ae44a6e76926a356743cd0f307a01b04b86e01fda3e5dcf5402b478e6d19366e56d3a5e61a84fa1e5e0a3e4496ec490224d298fdff9e5b288ace7c1f18757c73b821fe7396cb101614c83981a25c59bb2595d2256404fc09bdf14e41d66d0ec98b97f907ced0c20e9467534811d5568ffa712bc7aed41e1a898aa848bf76960e53a7f9d3e6c76b75f31697f2222afc168c7e06ba3dbc53bfe5c394a3df99d7cbf9aee38a0522651a7fafe9b52aac3032be531f5c2da72a5b9a2ce7e984b55870825e712947cb47cf13461f904665a3a485b6a6461ea41eda226815272738a25bf0e8069b6c4f9912342a644e9d4583f4aeccdba16dce796a91360992e5867a1b8531398e79b0b2690214a91490a676ad595009cd90161552e49b636c5b96dc8c425ae6b0470eb28a054938e30235eee243919f7a8718530dfa373d5551ffd55a35b39ef5c46124c9a65526c6cbb75be787a918ba1684488edd6786053b67ee0339f9a8d489289a8d90caa1c0a218f15d7de0f5559b514927ac04f43abe1c9e1a76ec2275bfb42d094a751727313ca3086eba00c63001a9a17beb422fbab8d157db608c8105c9452152caaf16fa191a9a2ff9106f6aea13a8c5940673dcf3b8fcc6fb5ca263477154a1b87d687a92ee8e3168153cfc2fd0826cf0e585591eca33d68784f3d1c02eebc6f354abcfb63b5a29833cec3460ca097f813bd437d4e408de4c708267b1cfa15510fdde1299b311b341f2e47c41b11bd410ecaf50a9f8af7a2b9b057ba8bc74dbb17f8131fb5f5b3507635d5831fc74f66ae0d28e1d0762c01470c390095658b621350fd1dcc0810fbc991eb6188948f2ad4957728edf34c39970e0af213438589727c27584151b23a082c56f7d55822adf6d6db3fe48c72372800195c8ef3ca252bc8ada0723c7e20c4c2f473e31e0de4cb5265c0aaaf0c416a2fb9b03f98fcd551cd92635462d79984c1bd1dadaeae8903af5970d95d53a67dca895bf5daa99ebdef943ea5a8c96db1afcd9fb5ccf120a6125e58fa2b87d605653951c1e102ceb8128837c994f51917e7f5fbbbbac9e787fab5b10b4ed58d972082412a7defdf12d0ad3a1ee9f15eec106447cc60d46eb03261329edcf833c111fa0364a3590c8b1f493673375d22551e188b59da92ab2964a75bf4aacf6ebaa7ebb0046bf4418613e87003f5b6fb2a3df53972c5c58fc5890613741e47f89f2cea9bfc0deda435123ce49bcd0111363d59580cf169f99072e9cb04032358554fe0727ae9781f0260bb4657beb96194a4d475e8ab34d74e48f404c8da2fc774da3e37426fc61c1539482105b27de8e13459c06f28322699766ab2f20db70140583596f4f6b740a192ed5521ec385246496d5de5d4dbf1dc1873256aa6426b56005d859c27b4c0332e92f82cfb81626a9b214edab30787b72404ec045e4189fe27ca1d24bf4053ed25280fbcea32f891ef6b59555693c741c35a0b3f11a4b232cf379be942804e7c9a39dd335f61d128c86950ee13e995c2e3f6ae77424a135ed64795e258c705704f53332078e5743cea8fdf5e3bc89f547354f999fb36f2c629854902a35cd9134eeb3261dd9386fab5a95d7c5ee802669e2cb7fa8361f5074358a4335c28370087df0a39897675f12305ee0a522f5e4652398421a1e38f70ddd68099035bf1b52968990e4554e5ff3cd1e6400686169b5b2e73411f0cf24db8b9754a3d3531189589f9eb90e1d015fb8795e5a0d1f54a5420f4d19a1e8bae245b0073121e70bedc1759fecfc5b04bcb042821838015fad8b88dae68be5263732a7e32353765e945afd16554adca880ae3e6ff49a61abbd9fcb6ddbe355fe017f4f9af3dfb6870e8dee588983171ed522d0590edd296309d4e559580420c3e92ff6a9f70b2385938bfd41b16ce176b6663412211302447fc19da7b2e3e7ebbe9200e873245dd1f918202ffb462444f1e254918c92883eaa6d8ba9c53b3d6f78becc2db9566625fa43b15ab33e1697e936c3db6bd777c10d92e221bec69a2ba4a6d1758794b6ae40efa64248006926c80f3c119307978ed04ebcffed69c051978342261fe317806a48d411e148904dfee378be044334d5b829b825d07f34551b7111eacbf328f0776fdbf416186640b4f1637f260b7b37ee507bd21e2ba1ea9da2b7c7830848314640b4a8a83e6cd0f15568e490a2ec396f1a64e131f27f53a46faced21bf9873550fc1f2cb68129500311344eb735e56a030e0a1396060815679e6ef772cf509e8fad92557b0288e5062b389bed0cd603630e382235ca9904dfa0d04ab86d10ca8036cbf5de0d477ab26fa147919b6628722223cb64081f53886fa48378187e65e7c02a8399d9364504f7f9cdbe72d783b526296fb7f9332a1a181310bdeb6b65f70439424d8e636f6b1cca0c1e44f5a1eb00cc818cfd4f1953f6d0695ad11b2b6e6e8e00ed0b0ba3c56116ba30ba18e6de6fb2a0403bab5f10e30ff3ea2ce07406b7062d5167da11c4350c9650ab9a5bfa2aa174e85d855e1bf5f7112b3180705f879148ed019a184b896996aacdf4ffef949e62605885d3a7865aa5c7cb3fc2467cf521489495f795cfbee319cc3481c8d90faeb73eb77a02c0c4e64be790725d264b6d20d84709b84ade21676582200ec41497e7ae44e3089c01f240deaa2251592a41a2d839b0f1bfd9eb2ef39acca5afd051c94fee1d6954eb776f7748b4973509a116bd8bff61ba68bd3bf1043a2119972455aae2c132f35fe860761a040e0ff7ce43ed08843e56d8901d8326172a4f2cff652c65a4dc1a33fe46825cbc42e8278f0a4b06ef2f6d5ddf2cd262146ff413f514471bd0632408f72bbb1e9212df406621e9a666c386c9f2931309cd7af1c42e6776869f22654b7bc012c600e2c1313e6eb9e2a1085a3685ad2f054c6a5157dec653656f6737f25b5ffcc40b20db67b90199a2dcded98afa937e6d73dc156accf2e81ec9b70b392fbe50c8a1798e54c54cb28f7d637bd4ad7deaef4b54dd15d24c484c180de3787023c47d180259f4dbe93619c8c15a7e84cf5b6e2e9639b7c714137dd2cac4ae8625a04a3e52eec5c1449dbe6fe5bc4de04a7bb1f316151bcc4d912e58892a0c68b459e349df22a1880e582f30eec1b75a8958a9404154d53bc64fd7e99fd7060494784724b5de5973cb33f03738f5c8365692309b4c98aadc2c8684c884ae4225957790d61b5cc5af9700d28a0410a5de2e754f948f964d61d2684bcb45ee5653409fdda410c063d74492b0c30674735842e1b52be367e089a411eb8746f3d0f81fe60268551931c3bfce208d81ad2b442f2d5a63f9bcb9425ac01000de620bc42ef514f48552620b62fb26716343fef98622e2e12c45de31eca3cb8c56158375e20bce24caeda4deebaf96d84260061a3160c0a73206b98b78487f0e3ba9dc5bfdcc9bae9b55e8bd2e1de7020e37984c4dbf866af80c15c3cbcc4498a91a235a1bd31c857f9197db8d30c43efba0421942b27d6f9c222bc7c23ba748e86c05d852be1bde8beb82c7d84bfc7747b4fef755710a8dc279598f8025705291c317d7fac0bb3aab423c3ae9f4f838e8baa5467ce08dcac0852ba5fdc7a2f7cf9127c6885ef62ac5bcd771d4d74c53e7159b0885938c67526e1715e236ec1ffa99899c37379e8b12a118e7bf92410da2cdb2921ff0b57b822230a73c578533494d36f019654ad17edd75ba19617ae39b735a8b493b1a6a7b1e2e8edcc7c3f719b6b842d4bcc3bcbf19c8ba7910b143ec8422017687010414f7f083293a318456ab78ef069b45f1aac962b450ecdc770d4da5582867e82af64984232e273ba80849e826f1a51e71890a211c49cd27b801cedfed02241c806ffcef178f7289acb9748326784178aa4053fbecd85b5e5886e63365275666864f8219b03d98aa0e03b1773a2fb951f0f8f9276ad3ce94dd5c090317d761672348e995097fae1fc3c1af8afa494207156065526f43329da4579f260b2665fb4b7f0271648cdd9753c252f08eadc3cf3e96e75195afa3abfdde6214188ac0a4afa73b7d346680b05b970fa50d6ff42a7c31aa29953dfd9e6e0b202b0a390dd18693d59e258df0a6aad4c352c2971162625ff74145a762d140bb7fff87bad7d0c26f845b2cc1f2fc5f2c82f758f346cb12bdc74ea675e1a3545abdf84af5a0eea286e04dfbb2e6439e4e08405b3d16ae19ce41d2c74294f428f5ae83f5425fa524d2f1a9138d9dc1258b5ee0f3e5e60fa291756b36a08734c99ec2005b83ce15af82f239d5a7eb5acc6c7dfd5ef4b6639618fb989d2881e7f02e733e4d5d63000133511557048aaf43eabdb14f2d624f4f265c35a417b9e8f0471c6751799286b13c95c9213ae8db70f4c6b634acf2eb1fa677e827ab7f1ab8cd00db43662e3c39a86d7e4cd34fb610143e276d35cd79aea7263e6a4870e7b0a7d8cb842adb70fcaf8e058fed603a5eb08486f993768e5a70ff5a27d6fc8df06ce6b2994cfd7572d7b2d9e922c09d41f0b296265fa18358d99d1be4fe7aedf09b984c68ed49eef36e104d6c312dd751db380321dd4875e109f35f312f1b7608664ae3e374d63c1e4e35623a7dee541f5a4cae06966513f316de417d5dfaaf6b7e1ac6f628554a027db9086e82a4045805329575e46cbec7b84a686cfb47eb71103e91142fe908972c4c28c5b5d755034824443156108f2bcd4ecf8f5e210cae6383b33c5e2191466e96c573b7a746ed5914791a70af26b7cfaae23b04c4aa3dfdf985ee09c54c65cfb4f0536f2e5c413dcaf14e8d7de316cec56eb5c14bee76cd3eac894937ac1358803f1ab29d66e7bc07bbf346b73c2920e1b82c1fe46d3d3d3bd7d952bed2d8910458f63eef006d637ac441f88b6c7b759ee9c115a4254836bd9f059df3de79592c93536becbfe084f8e1b306074252824052b626313dfde9f207c9894cc55dcb1f23106bb0747db1761752fdb9d42b289a8bea37f11d578653aa243c05fa31a7369e0677d9019066022ec125383df0560e49a6bf8ddfe4603edfd52a8ecc4c603549c0e953b99aa628997b52017bf8762c97f7fca2a86ffe42e21049e04558dbf0a3fa9957a4b5bc7f76cfc8260077e85546a36c6c6d6fe81f4aa50379c22d8257fc65b1557a7c18a093dde7d12f50c09c010aa60a83046dd0f6aa710689e337f34e0f8a440491cf1efa623a0c39f367f34dc201950e447271d2f6f05b394d9250d93659284c2fe52b877905168525a2736de9920a2dfb5c0067a6774fedd49eddf4be7ce3d1ea0a585c6bae100c7f4435c188b67603dbc735b41b6a5400fd68431e705d0bc3a6231db45fc36528b3c320384a46e661703b06c5bcf4c9c34057a154d452e61403d2bd169b24d5ecaa4828ac9ecec8882d1d28a16782d44c893e4fefa62e30747c57b3d4c120f390ff1184c07d013f0abdd9594b992dce7ac7c41ca25cf4444a5feaf09b14c6baceb6ab2ef8dad72a2ed2bd703a05330eb68d1c3aefd207c2e53bc118e7ff8a928af7b5b751c98fab62e333ecd8ac881849af8f6240368349f74c66f39ab108f7d1dce27cbb030db0b38c3493f0651c861488870eeb405742b3f6606592330b6a3025bedbb944832a794cce2db73521ba7ea2561909a74e7418c1ef0a9bc8826f8628a0f81bc27b42b77d406db6a9a5611e902fb79fd281940f50989437b1eb7172b19111c0566beb5d9ea147b22a2f1626e3597940c69c81ce4ed897342e17ecde02ebff80f8486a8496780ee6864a6abd72cf5a4def035c14fa0f36a5633e5a1cc662eccc776947584a0698773a4ab61f58356972ade8eb404d9998bb482581227c24194a30b537d6a43dc3649b0c3d78f347338d4c92d0705099f06b5dd91a7e5cdaa0429c633c79d0efec7f41956440f56715af78da33a3bfa74cd0a87d5b1a2d82426e753808db0b6fc26676f81af32170599b9d7d693dd100e038fa55cbfdbf140c124d8c2534be6b3258c1a20fe5ff96684c9cafed812abc46af43914e92b67ad147861e36073303b63f952444d38f510f908ed625bdd24c692535f5487f9633f0facaea96f2f8271b5fd852bc797bd49c0562bcb55e9d15531bb4e6dfff9eda8966da198d66fd4f965923db130132c697169f09066389c90d9afff22cc3adbb196ff7e3a3732bd68f4973b06724d0eff800a5d6d5bfcdbe7c5fd5d730a8458f43951d9ac09f98f85a2c4043413027468643795601648a17b1854dbe5b42446aa57270d98db76a4ca47d08cc227f391fc86694f42e41f190f3dad1008b992567889cc909e392deb80441ec5ffbf86c4642ed3d25e878a95a9e419697e42d6ba5bf2b7d0f825f83617dd01526b29ea2ef6e5c6d899c0707fd80c36f500a09d9e65e976a89b51856e892896ffa642a656135ed1bd565fba399298318b3fbe90c468431787459fb682db79b2f5d03726f63eb4f0b317eb6d1b1f9b8c09675a520ede7a070742b810e4765026bb2e403117291e569ea779f81a4e425e554b26ae58e4a518e2783c52e0110cdff1e01b3b0f8171cd1fb831c28544daf391d83d1ba5da914fe53acd8249d8e0497039f3f2c8cfcf4628089f76a4f933c9a8697e9dd18c2b424209530f78d4336ebee08261d20d39d20c4591c1b7592f264601f989bbb93a78e41910a43c9d658f70d03d64c06cd10e7fd4ffc3a16258ea7189b5ed86041872a272976eef18d895d8f62c8ff3436c14f53fed88e4489ef11bb98aad1d5fedd66dcff3e7ba795726df61cd1c65f303c07093d6a2764083bf037279406fb8ad3da2c8298cab47ec8340df0191e3c88ed421a56832b103ceae7191251c2b4ecfe77470e6fdfbe7798194c508f283cae9d26700d29af3756519623c268c952c95e8d6c9800d1dbec4d6e09d6d16089d73c3aeefe1ef34f49af8336abe67a816cd596e1c08434e07a678e5b061275a677e0354d06b73f39c3d75a4c8214bfff6798c212a9da6e707f12b785ccc5454e034d36ae44857319d9b037b15473bfbc9a056b9f6634e302bcc63d2d54b8120c846ca99003ff4e80767cdd2f8b6a95c782bdb7130ec87a70a5a8a84a159aa8629383068e9987d5b34e32fecde7ffbf035a81a42bd70a09fc3e314ef2ac14a631008e078edc4d9289fef2c3240f450f25f64432f11f9bffeeedb71211697108adcedaf532f9ca838c452ad31c47af53fd921a329909e5accb62802eb07e912984c93bfb7552b7bf35ee30177d36b09df543879e62ccbf70361b3b66a60c958e5dde01d4e46af85550e451f1095bba519b260dbcec702791dcc1252bdf3d753d76fac494d93204ba04c12f0bcd32c439ddba7e85a273c064c85521e55fdf02756f0e153768ac25b21f9a84ac65b9b1440e52af4f67d0793dbc4eb91274887a0858fc2979744899125bcb44d904ceed8d52af3cea8a5038869d3fcee11aeb2d1083ec7d9070a743a40cdb1509c43093883ec2b91430aca9850d8d8a2d76f8b452df8ee2e754ac42b9d4971fd484b12db3ea25b13bb5bb534537e4b1c72d8122af767be9d62422d163836ceb9d4cfa373ea0de8f73d6848e1dd8fd58d2d7f6711db70b5103bb1c8901c6dc8071950bfc28aa4dac92038e981ae20b73c0d4d0aa3952b92d8184bf1e61baecf9e6ed11f41f103fd2b5d80f88cfee5b654ed4422543ad551f787ea70d71ed9862199cbe01f18ccb6c0049b778cb0682364658f3612d60f1b815f21c9c8e4029ca77c2af95829ac75b60c6290b03a3de1c1d2e1872212a2bec0a1be87374076d1e25e9ef77421e98e67f0c1a2380c27cdec2aed559b4d6f3f1e26dc022b2ef932d657f7c9f849b0dfc7e7def791f6d9b47147e2dd4495623e9702415568c72f6fde05dede880c1d46083d28406b72b5800cbb7b0eeeee16402a792b5c38f0916b00c94b97625629d249c41c637c4be3134f0bfb646afe21827c76fecc2896b355cf9b390027053c50b86d8f8b1bb38ae418f76ac790f38e0ca1df78b18264a6c3a015e33bc730f92b79540b6c698261cc4f6d7065cdce408dc7ad9de7428e1ef7dee16db147247268278790b9d90ce1114c95fa2dbc8a70021198539d650e14d34225763c315f13f683847cc0ec53b0a46b578fafe07a43a72d7a3a63c7b57cd660e58634958e416b1d3a5ba6df6a16b7ae26b5d5302b1751ea0f106a0742889aa51d4d959527486801d3791459318902601a2de28b2f8921627ac4c2a8f16a35b4773d91a86ef6dcf66b1cc009dafccb2c88e303a68461f4495f719d5a475c6738bc9302f4773b0cdc78e68727e3f3c7802bb2072ac02aefdd43d50f62038a4eab8e7a21670d5cff664d9b34b077ad8ca50fb2fa1106234ac2096d6dba42b7ea59faa51a1cc8e69971b982d17ba1e9f3f91c4d90e3fdfbe019cafd23cfcd7965f0a87ca17bc5cc5e78cae5948304c62ab8b62c6828a33757884a957f729aac5eb15c013c756b37dea812269a3f370e0d4957636ecebe549042b5e7b502116ed8ef9cc99331846eda006bb97d87f1861ad4b7d273eb19511fc5742e493976e4137cd9bbf6bd6ca13ff49c9afc186a26c5975fb8f7ceaecfcf421f1a87274679422ec9e89172a637c554acadce93778e6fcef1c7a038e70b6b98a9948e07590ac4c30065e0a54f87b4037596a244cb669b256d6b81ab7d394465451ddd17ae3e22c4f97ebb9cfa85cabd398a0b62a36274aecb198995db829b43acd3fd8df7ef8409346a97afffb6b1d19e06b146ff01a8a4388e0244f832e029f6f6467ae511fbafe94904abd66ce9994dcc6e080d5cc1fd21609bb11a8f02af70da497571c1bef57b1eb7161a41cc9ccb30a153fde42a18557c2fc7a1d6cd768e29d0e5200ff7f28b2f5cec319b69da9d16ef2ddef2106967952f7737cccc52204b5de9a23db31247fe9437239606c5f2e0480c02d5c746f193775ccbc8668cff0677644bc7bdd903af64ebf1670d7af2c7e443c30c3206cdbf6a62113c938688059374f45b7aea6c6d787368f788ea43992978f318aff8bc02928e0be93c2368e1e4a0c6b6f935a92aad4f80743586a4e6d414cfdebee490b37d21646992e6733bad0186cf5f30280ebfa8c8858e0ff71afd0d66846c85d2939135f7b274851970ebfbec02fd0441cb13f3c89f422105641c9ce5797051e99079c9e99b13c43be8a8c657794fc32d2a21acdc20c3931b4957c0559031234e5452bea2c3291b7b468c3c2b4bb5503d077cc6dda3e4e2c2dca300ebb951861e0510410ca1e37c85305b8beccd95d8fc3271205b4453838b9b5c774d6962cce86de15c6bb31d31d5a8946c1661d4ab7091ed3934fe456039badeb5de2f523fcd3730511fd3894904adc829c8210347406008897923fa67661a029f01ca25f387e9f30e91b7ccb6622ea9deb6263a4cc7be0f0b2cd3d0a59769da3db361371f1ed62ffa880f8da1d89d50ee4f30fa250c7641146ae841c42a22226a6d6cf7e9d9e219a98e5f8be8071fe8dca079dbef92950c985602b34b4f7de2768014589cbb9068ef49d5de61acdf22f1166626cc6a46b7bb8bcf736ad070180d65b47461968b9c5cc6f10f2d39b253b1bff3c5361cbf6159c0642557f97e59fa86ce7a81a2864f7bc6dad3e6694713a3245de8794044a4f65019b663ee62209fd8bfa0b22edcf04cd8104cd31862b24aa76522c303ea86e0d9f3f10422a51ce25ce0ae3dbf9b660c5234b47ad33d007cc219fc11137d561cd8f23ab5ae0fbbacbfda040db22f27435d90eeba400637ccadfee5e941e663dba824a08be5abacd943231bc92ed2499bd98416f8b1a6f653339682fe6213b31c13a250dc55e8cf5984c50d89cb94eba70dfc17d654af75690e47c8d7dcf99e825c96b7724f52ff954370922314880eede01dabd318852c1999dd19c8dbbdf75e80d6c81f33c424f81b0cf80d4ce4c3673a955cc619459eeb88318c4ae86c4788253634811e4d80508f9ea7b556c386363c24d8721d3ef38841e22a1add467d3089b96736199dea08827ee746867b58a51435f4a2d70ead7cf1f24bbddda023848924075f3f8a4ab4895dabc49c5338eb845234b5f96514563f87c0608ba8c273614d7be87cfc19d8a628dba0e550b1e7afc9c13ed19a8296c0f6a133906cc0c92ccb7b2f33fc4b385c464637f177ea65160e29e8a19ca2d15e340aec06d418bf11929430fca69a68dfb1054972b3e7b68f665f2e87ee2f1f2b346b010c311c9e197d01b670cd56daa2b7472bbf2e28b365ede3ab358116204506f76505e94ff091e193fb2d2849943c89cc9811c361156c107644fc4b2813ddd0aa6e106fa326cc9a781af835973bf728990ced8e243bdedb6fbe69c490df1319fe0b999227c1d879854d18e9b1a746e323a41cad67ae2a3a53233ae2ffd15125d3088c3612e5156bc800986a055a5078a392f2699ec921814cd207fc67c4912d9d8352baaf34ce7888b6fc81f41c789a70adb2a9456d75878db4b035849e782131400e03dbd9800b9abc5d931b241d371c9a97529c748068b9cb62816517a5a5889e8d013576ffe05b9242096ca290c18c4b8f938f61451eb995297e54036ba1a9185352f06f840e9d96166b0ccfa7d2199c96d56d8bbd036232a99be387cc713d2254f8e3163a9deb046a6aace5b578300415ee5fbff3d9c20cb2269e16cd1452ac2c5e60de33bb9d6c6cebf0f74f385031d3a3655df6602483c04da7c9827f69c139f1a3186644dbf0a4fd76f241f48f58f657fc5174ded68fc8e2e7b0e5ef5df8c757ef1055af3e13fdb542dc07817aa962b8c17102a00cce6c21dea3fe39b098cb58cb2e184e834de8533f0aac0043b3dc1fdc2b32520241c36b7004c02cfbfcc2f5bcd81c30076d0e72c42bbe550bb9af078cb88d5ccd1dacd9600e39e73ead9adab29f300ee48a7840d18f4412c323833a65b362de4a5e7d5882a9dd838a4b0029c4bd7907d0dbd9275bb5b168ac4cb450676680526dc9c8527ced3743231a3c4a7532553901d8a8e2bc0ea00351c4cbd33ff93b34938c9a68cfa118fb011f7006ab789315e46fc73e060d6d8ebb9df72baf76e759ab4daee11bf656735fe3725cad2c0133dcc2a4bdd87bc1f3507862dc2d63f3c6b12e9b2b852f9f65cfd51a3b061b904ac3370397cdf4c148ce52acc0d001404bd2ff6894e6905e243fcd64dfb0b53fa86730056aada4d655e8cae35dbf6cbbb76547fd46ad5de4a34917b43f845656b30d76e04f606a3b6d55d6031b73a80de25f8f9b5d297e6e57dbef4ed6f6c22fe34f53508da41313ac7b50c14b5f3b4fdd7d03b61e5b9a4397e89c38e1f479f020f54698fc9adb26f0b0bf37e031fdea51d653fb7e64860ec19c39d98bbc462000035e81bb83300f96ce927d38e1c853e4bd5893b5c6597e1a5548f99d38ade284927b97e2e0a11ec106c1d4852d85856dfc0db6a660bc60f94e373fda1993070c6716e9e81552ca2ba54385b1f44a42cef5a69a142f154bf64e5b765f8c9b4d441d05baa8a68fe161de00f2ccf6b805780b9fd768e3282f026866a9cb1606a668d40d7abb6f51dcb3ee19acc2af7d561aead778d71ad6f1349ea798aabcb2c46d6070fce62900e7dfd8640cf6cd40ba4f7323109dfc162f8b96c12549f785ba7d4faef34926d3978f3ae73b7e145fadac8188ac065bcf3138251e860b2a66deb3cddab66636884508d59823763d57ddac8093ad9905fe1099cf032557019e4a2e5324ae95fb13a0b55d8928b194420e7b041d018b06ae4ec68791db7ae067e7a8723a95b31372d5b05126b91cf5837d18494f482b254828939d52282221eac3c0808f23b6ec5f5992aa5cb2d811b9b274e04eacb063591ff3fb5feca269550cb7ae073f318b4729c95a6dbba3293ddbf59372ffd270b592d2f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
