<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1612efccaf8b760d68df8daf30ee29f135e1b6263111236c943151858b9d4c8b1f7b8527db13fc5cc73dbe562ce1a9b97134cc1fc279a235cbf9ae39a64397f4f77e0d8bc4f18850ba6b6c44db5e95845ddf279f2802fc518ed88f09ea225242cc386f87717bd84263b38e755bf9767ba2dc85c2fa5c55e2478c91516627946a7cfc7e47da68c7319e107333b865ef4a727c5928f024e8cfb2f2b016fecaa577284f72898c2545ec697620b46357c6d408ab3a259ce454e06e221f57fb02fdf382f8227676682fa0ba1400f97a162c6ec1f55da683b40811429c707a93be1a0752e9a9a77fbd6e80d02fc2e4f599a11b39734ff185b1780e3fbbd971a630db1a0ebd64ee582c6a9de3b0f71a57c6d4446d8d433607e2e5665c41f48b9026dff34b38f7053217a2bce6b4e25caeffcca6a6c34ff8850118fbcf220ab2d3c251273c83546929e3363800fec75c0bd98b74ff3ede916ff42f82acc2ad54d4b4e7fa5280cb1cf5989cec8509515300cf794de17f4ea10a9d8ed8f95abd2723ed2ce688b38fbbce02c5254b6c9ce754124c0e32b0c4ddca47658095bade4727e7e1f7fd3adf2d0fd4ff3d7f6e4e317ba77babeffaed5c519067803c1899a02617a2dfa018a8c823a67d0bec55c9dafc010c4b5c45b4ba6cec0dd4a5fbf11c2e6fa57a2e9943474e31ae1303e7880f3eada4a14c46ec74a83eba80c5129078a68a68e6515ea99cfe3baac33d9268a5435cf8845f3438800bd67610a9b8b1d4e732c9fd0817880455ac4c2eed7f4a225cc5b19dbb817de013d0924b19a4b205728c427af479c4209a6314116cfce3456a9c1f7dc7d3579b4d50f1f76acc830693148c796b7372e32e564f987a550f91ac6f464d400a9280386d1c59845d167698eb451613b0264878b8e3f63db959d3bdd8b3ea5d8575a5123ab2657859e59a56d88ca6043d9e708cad48fcf0867d5261a7d39508a7283c85ca3bccb7a45d5a90968e479f87b0cd55957e5ea89726c148feaefbf45fbab2dc59b9153bed38f38f31db8d58f88fbe8e4dc784ffb49e4ae21db46c71379bead18ed2d82ed29e846615533df9603ee31755b35cf4c02dfe8ecad14a69409370b3d86f823402ed2ae7baa8c234c0fc4bf90c69f7b67beaf7f0b966fd58617910e176a922420eb8f69672b9abd526bc018c1649bec685f5dd6f6b8a9e3af0c3dda2d0c17a13376ea0726dcd444e9d5e60914b0e0fe5c8517aae455072d72dba99e16114fe5d11241b901749dbd0582afb725f2b58b4ba7c9d1647f4651ffa41188324279fdbee6ae788811a4dd40453d07abbb312ecbbace1de77de808f82313d3e75c32983921b2a2640a60c932e385aafe1de8a01cc16133ee98124657e36607aa189668e1892108438248a14abe2d2ea22a60d8b8d5f20c24d2f93393e9568ed7b8c20254a6fdde6b866ceb45aaeeaceac6adbfb43a11077fec933eda7c15359c5325f895fd8ea3ce66e047f9bbc4c1caad473d4ee30c0d70ec0f20237cc7ee895d85ff546546ab8e87df1c702523c9430c2dbe3e30da87d5356c34683df75687e2782f432c7d5d8eed6c9bf3ffe96ce33668cb68b94556aee5b314883f4bf27aca352e6deb638f7f80dede2b54dee84c5a42f38011106dfbf777367840941c5a1fa6e9b900dfab32bfd4fac2829974e985a71e1ab9a2ab209dd8468747b2ef52ce49bb1361fe7af05cbfc6b4ab225fc4c0bfed9704241f71e1f311576ddfd9e600c326ca1de47612261b7394a9a71d9f3ce325b79caefa975d7cfe2c51986206e13960d9e0921de3844ea0dd9faec06b2c6cd7926d8a7838823343eb953726cf1d09b156ec34d629d6b5029045188ffb23e0ded3e38f7ab072d0dc3eb6f434d97cfee4a05f02cad75bc04f252f462e9a2c639072e8610dd1b52b2e4109c66efa7d2c3e83b7c0ccd0ad8a81094ef77db83ff6ff6e5d4f3a3da1d23f2cdf240dcd9c0c603921b52eb1c9fcbca00cd34c3045f50d65003223b86da3e84b0c191602d79de677801aeadc109d27d5c4197fe0b87235f20515cff7e7b5b73a2b6b7ad839582c8a30aa4034cb9e1989096e89ea0bc6b7daf44434bc687b9873e7e599a5ee10464f3c08cfc559dda979166c03b9dcb1f8bd0d96d2f850ecc0e83b06f6a44d2c06a2e85476c3cb659385917aedbaed706969ef58124aaca73af762fbcc9a7318390d003c478c45f478840f38eb27ebde756c8c61a1d6534d88e8293ed05f439f27279504b4578b918022bab5750afdb73724bf2bf5d8017593c387435ccc55e62c7e70f1075890c22d56a0748904ed930c8e5e8af40a6db61e49c4f0d69dbd5e2dfd1818d2d43da41db43f2c1eed3aeef95fa98639c03fe3671841890ff13756c1113a5849e82ae0ab9f710853e6396128fda563e1f9e2941270d95c0aa129f7e8d885b0548d8d614e4158855ba1cc3fa3533f7fdad29ca23d3421a81beed6d5b3bb56d89155fe6c1a129a54c479f29fa7be514e4b250c2eb5bd5e827d88047799f5509d1c16e614344794282d2de4084c4adb87d4e1dc28b2216dfbed29d525165eaa143ecf9bfaec0c9330dd5cba63ff5c51b02669066250789e87a47bad3a98e8f1bd06486dcbdb1365d59445f907b35a35eabf05a781df1dddeaf43861db02fcdc0466d2ed38f6761e6f0b9750f0523e2f0cc96b6731b7b1dd3e36b15fd8649b24c3403c2d198a709e883141a34cdf469683e7bef47f45772de36a0dbc8799ba4def449a5785f4cd77a3b9da6b1e67ac07844436873f8cb736b5fa5e83dc19677a8dd0af68fcbd2672ec9b20c0cd56c22bd8e6533f4a94875dc16c358db7976e3c65f1f10ddd1d69cf57de9f6012145bbb1925a7644cc4b50f6adf5b897ddb6db93e55151108105a181b5fc584a3650868b8f18b516a924661271389b70f2705f9d0ccf1d98489bbdc44cb855c1c0207f36b1dffe89be30e904bea886f5bd59865e76c58bae1829048a9504f5a0be3b9fc5a1c992a3c4c2f7485e0f8cf6cb275b1b42aee5672e82695e6e8016859db9733cb70a710cbb209085fecb64b1cd9e87ec791d9d14d6e7742bc361a06206391b2af754c60d495335bd9edfc65ea5e694130bdf9f6091350218185b0bfd34b012f7dddf58a84fcfbe5cb918f89bb2f5c5800f6c16901ed08da1688683b98b089d8f59de9bee6be941d5a1d6bff8f970fa28fe95198cad7a1d52010058bdadcaef0cda2bb7107736bcfc81424d74f1fe56da2197a7503d08dda44bd1c0d519da8eebbb3f510d07df84d2de61310ac239c52c802d13bfd6123e021269df9d385c96f2ef5cdfacef636e3fe8620cd81ad8fb776e15bc219fff2effe11da1ba7422bc09a304b6df35a50b08fe3d964a7e61ab2b8f53611b03ec96a1eda220a56cfeb7f7181f290ed95435b389748f2402edf25c3cd0b8ffee414bd5735d95569f1d6e471064e41950842053a510eeb2c5be2bcc4a90340b3cc8ed5d55fa131b50b07c3b94ddfcc1adc83ee73602c0f8208527317896ec411682380f8c9947a6ec072c2de0bc751ee73e25a173c8b1b425bb495a958e0950c41053c84d7c34b34e5990c1793e3e34c60587e3ee35a2b5af129bc8d11283b9fda37f9ea13b784896605df249236ca93fbae8bed306df0fd04f66bf1bdcc26c98915564bb0cacf27b1d1f20c4475a7f3462ecdeefa96c63b62b28f6353b1439b46dce8c6e6394125ce63638048e89b7f16883f3b242e2337f9b2b1d1f50bf71429cdc6df1e7c76d08ce4d3bb9de5bd2d60b5704957119627c05f451ca3a7b4646ca8d5bc559fdfea2d9555cb42c66d85ec4082993e78ece7b07f5be2009ced79bed6f6161074f2c02a5a3d95588c1592ba81e1c3eaeccfcf7b675c5b33ce2c9292d7b8ce5cd8035715f9f83eea8709203916d3110a1b6f944e128c689004e5b6b91807380a33de8c22cc8725bde9ee6e6c0cb29a3ca7dd4aa92b58a9a54ca5c255c9afa52c675bd60c4407892b3814bb6c5693ff82489f080953a77c5982b82b19bf92228c155b863f50df19c64c82e19b56aa1868ed099405c4762f72b1814247e2c807d44e5ff64bc4020722ccd27041698e03a856f54a474f463323f683d0a8ac8f8cba241db7bb439edeb212cc23f8e1329ec4c85a519aacffd3b8d80f021d1fc53a32c430c482d789bcd7ba9bd3cb92de1fede031028f447a4ac5355bd97e2633c6a80d70db0d21761b9509bfe606bb9ec9a6ea28d2f9e53cca7ed4fe0acb5ac07a5f7005fd61628583bafbae344874c7ff7579af79b4a891294f85fdb16fbb46e1f163476dc155e7b01569f0eb12958ff71e129a7a5c1ce47654ddc5606b2f682bf36992fc7a2674676ddc95b4e0b91fbf3b80a8b24855a78c10d3672807980b7b205618ae68b4e7d14aa7ddd116143f02ae86b0d9e3824fdd98dbb967a7561fbff06e640c643cb99f00ac40a9e4872e07a3f90bc412300d1b1cabfd29321a66ccd7dac7ab91d5e5c1d25e24261e845ae2aa8a9df112f36d7075cfb7d1cd48bb426e2d1f68bdf99305b93267cd0353d078976f2b6c66f06fe741d043768776c9036669c1dee6209c77260ef2f736c78f1f4d6032b540a9f9789f5e0c2bb6edf51502da526de8944b689815d868000c3fcc1a73b6902e75b3349ed46955c6b1c8f324d648d1bba5ac3be83c2725863d79e695166d1d350d54865f016f12a525539da42329966610b37aca086074b901d9c3ca66892f921a1adc7bea0895c44a287838dbcd11bf70b27a1254054235b3ab4b775c0468f0f1b8812ad4467cef2a90903513222a3d8c73178701723d8f2509083c627194c64cfe95b95a1672793e461d06a19da64e8e9c08cea155c1f33976f16c4421f556cdf9a6969a4dc6161d5a8cc348e4df2fbc01053b20ea6cce6624ddf5736b232395765d2d3ecd54f8e53d767d448f5dfb55fdf53556ced3f54905bd39f75ec069551c42bb40c7dd6b4fe78d7c85bd5f13582716ba65064ca996b3032af2a5fedd1b485399c43b5dd2429c35f9108e5610ac99d7f81749d8ce1d98484d44300dae3b94ede19de8489ea560a03638e323ddf3c9bf70e1b28f9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
