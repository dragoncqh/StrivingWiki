<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4c8e0ebd8829a100a29b3aaa4b0828d397f6f1899912cf95df3e7fb758560280844396897c49bf7ac95e9c7533b795347e3c13a1721b905d9b30b3e24a0e76827a1849359c9dd5f91708ad20e325d935e445d6e7ca13c4d12dc4e37d7706a93ed4296f4f4c046e9fef4f4a52644e88b1677cf501997b431af1768dbeb76bb453bc6f16bbb90b8d80f66a2cc42f2c601ae13b9c38972ded75c72cb1f89f63a514ff487c0d1fe5daf77ebe41baf70afbd6a0891335f2a9313df07e164b6cb681ce3e6192f90247a5a62a5f2896d9a4e9c5be4285325b9f0cd5c0590359cc6ac6ae48d9ff884893ab061820341acdd712e61856671165f9ccefef425ada1184dd3e60b64e6ed6ae10793236bec4c767003be135d4a084bf1bf2e23990cf65382e9d5d6e8740951400683a21aa42a595b5b143f97c8b5a419dff43eeb9a95ce55159141eeab700297c3a0a6aaf32296f07e09bec702f02a2b3b5e2956a403d0e552361cd1ae5949f974d82c47309abb32489ce0e154868dbeab68d82ac04ffe3c2ba02905c0bc669aabea942e21c1aa2afaaa96556c1f630e01b33dab48b0266d17017a9459a1b0f132578524786e58472046aa8ca59a9afdbe7efa89efd4f53b181de25c2dfc1fa3f9e62b512d53c4535eddab3028fc3b499529504f26f9f6d1c8e3cf310c530a9fe9eda24272b5357415dd6583450c68a195ba82fd6687ea6292ba8abec2749119f48d1efae08ed0f63d1ff63a160320939c8ae0da264c77d545c4187789cd1eb90eebc4927d0607a9b6ff8db9c2853ec5b51bc459dcb40a5fba50f862b35bc2aa960664f50b380874c8f84d5527e398f850c602ac287c187cfc2ee462aa11ec477fc078353ab00aaeed66eb2fab586cc40a5c47211c5ca7ffaacd40f4ab16ca52caa80dbc6d185303ca0472be40cd4e58be3555cd3e04306876a2f6bf3ca9eadc10943a62e1d2f6391c0b0e018aacdc1c2cdb6736273f48eec2657220292f7b0f09dfd8cd934e94c351ea85b87124de2c008df63a933442d46b982f76904d258a6c85c64fb896e15ddaefe0d3176d76779975179ad85bfbed751ca8bf910d8534ed85546ca5e37db84b4dce5f50c31234136b15177ed66e20f036f739c65f24de39a50ed9477afea48dbb4f1907fa504e804610da915525533cf36feba22671edc9f43b17cb8b2cf7cedf0ce739a7ab0ba9e539a08af698920bdaf54f9c5d2878967108021a1dd063cd5b9e013cc7c102c4159a5b600a817b3ae533f4091e12d023ec3477499fb70989e67717786d33e446cd10e08c40adbccbc962301bbd501a9830f12a6cec7808737e52c134c87f5938c1f5df4955b26014fec4fbd91e90508140d371fa89f89a41e2a07e758ff9605fc6df4687bf2105544ddbc4698332ddb6cf50233f70acbfc10fb6ec8e3c59d1362a2227f595b6c29ae2896d2371c110b13316ee6874cbed5c11d3d557f0a525e1a553e92520edd2d10725baea558b1c534bc4cfca77a3d96546fb8ddc3d419c91ae2132d5906f91ee90b7bc4b6072e25d5c3e4fcab21e15f182ee202c2f96942224ca3e5ff7b1bba7ca49be26ed53123e50dc2448e3f8b55345cf472a595d8eb25cb3feb7ed15432c8ababa6a95a0b681573d81fb7632b9c30ffe7e41839d3694753ac7d0bcda19aea7a68fe6ac6b1d5e46e412aed9f6e9b0f0846c047fc2cd0c53299e3873222cc2bcd126cbe89b2484cb82fcc206c4b4049cdf0d8e0b221178517a78f19f0c75e0fd6bd43caa124c59651fa4df0df7578b5b019515b0fbf187e118af493119a8998530e6a755adc7e660e8218df05430e373bd0f881b1977cc0d0153d8ddfe5e4789e64b59c81b270ab88f457d2b16aa3eb0c8c884eaa2aab9dfc0db3f2a101ddec1d8794d93cc99f75d0a9beba3b0723ab5ec956b34a6d9b75d441ccdc25f53e3f6014946668f92979fed9910356270bda99aecbe6b8e07b02bb720804039ea31ecc2e101157548defcc3aa8b3107c1391ecc410f15d99bdd14b32822abbf00b27182b2920fc7d95deb50e0c446a0eda36807b4412106108631530644d0cec4cd7451375fa15b48dd52aea6a07bb9b7f2085b78ea0081280924ce6a525930c2e548be2918192a67b89d4c5d3cdd51be786ac60bae9fb631bd8a87fd4559b1f478767e0f4f7ed87a9de333ef352db96f1c887cf9522f5f2c00e51b5cd3efa8386c41d062f50bffad884ba98db8b4ada165f2696e163de73f33416d6b7afb7571f22a06734734ae40ef01f5144a838eaaa42045c6055c57c445b8638963abd36df36b168f0b378e5c439dc32daa385ba3f8a64034015d5dfd031a7a8d9719f6a2dba74b47750e1bb53f1888fb131dbeb6ce19a324ef2634849740cae3df1f8a44e66d7cdc9022cdb676f694cc694e3bb1afba93852af78a8a947251b88c879d85abc930091646c99bb482a089e796c376d646829a08931301e0c7f35a8815fe344d83efa6ebd9abe267a5a5c845a83ea1b437d4217a47f83670e40dd61670f056b39d6c6c64a81358b7eeeb077a31afe5ac36a93de1918542aaed0dc72e56186a4a151c7c8ebf7deb41d777ad014149b34a84dc8e0e8e359f69d5a5f8c94ed25bc623c003c7bd337b6937d11c616373020301e0d2c4262a821da7b3dca9f73472e68f21a7add99cded5f3233aadacd74be583ce2aa3bc2e495f1207589d1c5893e56078aefab4e3e759abc093319a7795a0684174dc71955a5cba9d303bcfca2ff3025eaf9f4cce6ba9198d0be5562fbba1b069f76eaea2a1c9c8372f97404460e6c34a27ebcd9b219a0cbd1377e294c19b74429d4f608f097b4f464c15d1430f29d5721dc8ad1a09bff3d76b3bd1bcba7dd5154f43cfc6aab8dec37065044a37770434f28370245dd2e4542b67ab69886cd1f13f7f2375e02af7095456eb8c8186b7b0e9f39431667bf96301c2a65597b956712583d39108c20099b5530367c74e462726f2048d78dfa62d51419cd005ebf015868d7a0f110beaf5654af38e6bb845d3a26804ab3a40122ec7b574614c2ec7edb44dc87675824dcfd08ae5a97706345987062f1ba3afc4bec6b1d70d335298e6463bbaff6bb33d928f5d69d9a422a328e77a368584362663e5e6dcdaf37c701a561b2306fa25f2bd41829520c0af414530e3fc730e9c8cef58f861025c8d64cc2d3a4621417c06c2702cb632dba888d40eb45e3568ae4e6a3803d32b2a0c456b8ae295ecff644c1870303f4b334d291d9358f0f7714dc6851d52f986ebadd94b1059d201fa11fa1cfc79adb84c17e6d328ef0e724b4114bf44578d20cec9cf40781158cd03258a6df07ae8da8963bfde87742c7d9da2b86667f0cb4c1e305c23320560386efa194059f2f4354148f110f76809873757c953ebfd2e1b555f5d14b6c551234148aae1251bc11b5b88718fdc62a3d3bcf10514620d14d933bf98e39ce4e0c32432b1bbe6a22a8a1365f838c850f5b05eedcd7f4f37fbd678f72344c177e3616f70341acba5b3c20060d9302f36909ca5f6c4df8a0d06dfcad1cf389e8fdb1f40e00c0d19e68199994fabcd5cd2f70ae3f3e3ad764e6b4c21185444fc5abe64b603be85a6b92228719bc8ebeffffdebfea1d4eea1349112207f807d95ee9fb2d780c1baf168748a80992e3f0ef29c509a2041e83271abf2724919bcfc1c19797003fe83d529efd8d63c3f09194a7dae463391ab49f516da3d4ab05aabb2e660486f7b72a8cc4f7762ed285916c9836d294368578023057d142e5a7d4fa30ce88ac3f7eedbab4d169dcdd7512313629e0c61afa92c701a7377996a4d365a534136e992fb345023d6ce4e259bc14e27405f7ab40507a8f0979e1e8b89c6fba11a682ab1e80174717eafc5ba2757bce32ebbefa0e5b411a6a47bcf922304e90ab25fcbec753e30951a17939e66a98496a2eea258abfaca100b725e79bce1e83c1658d1f5a9af1c75a32bfa5ee25a86f4019363d4cc99810fd766b4ba13b2ac4a70a6c484eff35c76685081eb546e993113615a563798bb108193b17aed5a5a952f4e7d7217401d5f89c8ec0af9e450cb337c18edb7e566122b57899b8912fa824b14c602f58949d6d2e487f2a52e94323d8decfd9ba79177aefbf768989c4b4c773d2cfdd2ffff62cc538a8a9c14238373b32d83d5387bd38f23fb717e6855235f2af22857c1e8f2abadfdef5c6e3a1a9f9ced82151ed0dad8cb00031ed99567155c59b631b850643fca7df23e1001fb82e94ada6579c13cf30a23b1bd70a519601d3357bb780f01a13a931cd4b0e50869ceffdb1fff450869e6a3704cb95992eabe7aeffb882e843f6e9489a0910f0f012ecbdbba704c7da7a1848caeeafaac65beef43afbcf5adbc54d6f16ab55d13fbfec2d21e9e9bbe94d2d718b40a611a30ec672a66324b526dab0349f3c0b2193584159ba52d823191a669f31b0c1a6f59fe3c5a02900fd8af7b49072f3b07709f8c360baac9ffc2ef6c00358eb2f72b8c8c7a62c014c1de953207cc7256157eb702f3187dd160609bfc0cc724a3cab59b3c448bc81bd24a74cf4583190f34cdd6df349e1006be7f5b6e5163b528a0ad6ffe2f2e01b31a8e2738d610b83517edbce92619052bae0a323476da56237c81f272ec6bc53cd8009c98b3c00bf6912f185535d1d533c714daca10e2088476c216961bd393cc85926085c5467ef7afba2820a6b65a5a0f35147311302a9013d5711e2efa512b0b902e5070e5103b3d40b2518350f0962d2092609facab26dcb0cc8ff60173befb050e61a5fadd199e6519f811df4d3e08d2432b6d0e123273a7f029782240962cdc44f97473c182b51c4bcf956da8e53264d4ef28c7e235f265606ad4a781be5d766bec4bf8e82a67ac410e882980bf2e1cf428a1c5faf54f81c1b8881a772862b34f6dad7f6182c6e09585950a473b4586890efb42dd324e159faed6948108067039743f13e5eab0379f7724ce849468b9e1f0caaa3896ad6ce23412b5212013239c37db2555d1d2e7ea80ec0e6290fc8cc9988e74bb758f951a97bed796fadb112874134a0b0cccced004bae3a1bd7e4eb5c24c392c4a4387c78d155aa474b8c5aef138830ac5edfa0b0d9079aaccf5f36ff850b025d57ec29835ba360edb37737ce23fdbd33b34191543ceff384b648f0277771c5e97a98be11d6c57254855716344fc0145876b94f0ef3e8a8a3b1cc736d748efa291296fd42132a2a650f664ef8333625605b024f9b7c4715a1eb566cf2f730cd64435120ce8679fda75e8e225003e693c2088a82069a00dcbf35cb64a7395e0f96d111945792c45d752a2ce06bd592461abefd3d5183ad68a0fa881575ab4f3d0486c3cc4904186454c8a0cadc4dc332f9a1b407081f58ca199793faae9dfbe95fbae390de43c010327f702dbf252491fb5f0d3322838529c73b20d6534d8201c8ac008c81c8a67bb41359f05988a2c7b614e9012cbaca256f0828438cadf913fc34eab87efc074e472fce1f08a61b06c091921ff82597bc157b394f390ee65cd89c901a471e467d9d7ab3e9cd6e7d315814973ef861cfc0134b23012ae75c4cc153a58c534f3b73653231ee4a53b8a977db91a71d17673513a1ae42cbe8898de4df312369b6a0e36e02baa0e29f129a5eb4bbf8c81c9737b3b8eb3acaa06f970483e00be7562a1abf5ae3d46dc536a218ab9d47ee04546fcbac605b6dd9610aef4d52a76b64c56cf1e1971af6c739ecb474464090db819d01aee59f30e08aa21d6e782be20e2e12e57af3fc85a1df298b66f6abcb070a83facc47f4c6792625e03232a6978a463385d4d4f63815412ffa7da8ce3bad0fb7d5129d4574f77a0f71ad6226f738ba7fe6b5a95131017c2d3cbf1c767d12fb1c8391a5b7e469d33f5f5969095f0a94b67625e0c6288f72ae07c4affa61e3ad4a30b8dbfa5ca29c4945a6c39a07c8f68edbd5ec18719a690bd6c068b76a1f1372e7e49e1724987f7c9be676f9590a5f5eb541a8c9de86e0099957363ba921511623e4f374b207f83eefd54206e1f05b9873e6ca807b9ef2af6cdf2fc36c80813e28c55be2f5398a895a26eecd4cc174c77604cc2bb9a37e37cbb76098e0187d55793e5f9741805105b803fa0bad2b9e875a917ca221eb034882ee8b6f654927309efa99d82ae501e47d3bca01e05ffdd9780aa1b2469ba01e66e5ef1eab700293dd3f08fb2005b84e6f198c71c480c5f34d0ee037318735b3f5e0f2bc8f4e2b468db67ef0e9def546d7495d520421eae7ecd232f5b96ccdf0ca61753f341fc124aa6e31282f5846064ac1cc5e1f9344ac4aa5ec11e672a373281640cced0d061a248b88fee17652cd04f32b1c7dfd4c41fd7e033dc11e1839c74d1cea1121f660f37fe8caae996a3220669eb1376e1964e5ba3623aaedc420134ef0191667022ad47146a7da51eb1ecf1b4ca7e0381c37ef08a39ab933bb681946e4e0870f57076c927eab7d6e24f1b7cbf43d2ec530f388a6ab47300903c21975287ea326f4d2eb7c4eb674afff7c3475c7b43fc31739de1380748becace259d7c135b55cdb0393d073068dc12a2220d08d39dc186d2ec4bbc40e0bfeabf00010af012fc5b75e60bbcf88b52ac48729698a0fe9ac26a17ed7e76312533fcdc554167e3169811380b656b88d9f18bc3bca3ce28de88d4244e7a8c4f2613e9d59188409c2282569ee300dba2a57dd831a2024f132879251d87dd37a75f76c49e0ad50cb477e7e8e9356005380340ec12bd9a040c17aa53eb20b8c987b67a65179bd2591d717c25269cbd704148fcbfa2fdcfdccc390d0f1095f83a1edab6e5ef302ac1befecd1fe0cd516b54d191222c3cfb44b48f608621548a77563658cec9d4489003e29f277a8c3b7df2f9ae479d4599448223aeed5ba0b631bc7e59f2d2b6b1839b92b987234e1cfc77f14408540ea1f4dcb3ce2bf3ccbff9443f04c16f0ce42673eaea83d3c2f5145bc042caf1060c2ca1ac6d36229317876437c1b6f09d7d4b9fd36190b32f8fe5434888ec777bcaecbdf1da470df7e9be1cb5d61a3356b0c2acb26ae1385713e54307c6441b6dbf18e0d92f453f03745d8dec08b19fe3dbd8b51ba364df8f56394814865a2db92586b7557c9546bf0c8d8740d47f3de58c28630fbdb7ba5fa8d629324e7f94828db7ab24d9f6ad6c4c4285a864650d76896a8f8aded4ef11bc5d631e921f7aa3a15742f9c3a0b58582d435b3dfd3efe389623efa661a89018ae4afabc715972189faec7946337e856aad9f1592bc5db4d5b40f12b3d36f992a8cd677205af11c318158775cdd05c78bfe4147322a01bce8d23e1de8dab75150f21b599220a2d5bda54dc452733725adcf69ab90b5f0a6ed22f27dcaca96850d3012289c26bb57207fc840f46ecc794f5838c628cb43419705e5fd1584267e7c74cc3de6a077c260dc148537d7c63ac7336340cc8c91925075acc7771b97a709bce944ad0c693788fe5ba6b797ff27e9a5f578b5239cd25b117b55bfe848dd12b74367be94bcb2755cbc247858e348d5cb250af69e0707fc85e7a43e81d5ae0010278df876f5dbd3a1fdb43cb1324f33d020eee607397ebcd861fbf9ae26f5d7c2384f3f391ec6dcb9fa33a9d39c3d9716ff3a7112f266d0e54b37f577b6610a7db1f01e366d63a3e5c1e87093757c4776f33787d0eb06a78f5b8196a0146aa98484eb1228be93d4e5c04c2ec0731365e208d7ba68d97dcaa365903960d8058edbb138997405a3a9feb1fb68ca951c19203ef672fee2f33181d7c6bfeef9b72a40c73db2240fa7c1cf558d412d5ad95e0137a6fbbdf6ef195b68975e1e34973658221d179c7f7056fa9828941fbd30d41991ee999e3f7a02f14d4b47231400087258705038682273b90a383a80e7899d31d3f9824db1174b982628942dbd54cabe2f98df62dc8c39a1a9b52767f22199af95bc8939e3ad7bad8127f736fe6469453cbea8468c183309fc41ce0faa1508b631feca7634e324ad0d924babe792d17f13766f9942a3910fa5031cb7326a27c71156d5fc88e102048123e487d7133ed85782f8480998a30b0ecf2d1abfc5f0e1732702bf2022451a678b8a7c866975445f0e29603f8970a01633878fdb03d0cc49ebf19c034cc9526d206d37696a60e96789d0af18dea89407c08967ab481b5b419070cc4f0eec4c996195221a07fe2150ae583fc653b04d4f8c69ad2f8fa450f4cc2377ba5e839b60a3e4c4f2ed15e4d83813b85464be00840c4ee7243dd56709697d55c598116abcbeac1c6de1abad9f5cda5249264e3d23840372a2cce862029f4a88865c2515314d8a55f2918cf53d4d5d27fd1627eefb09e6e9a2a95977c1d6fe870ff853187797c3dc3a7fc48cad6458dace15ab93faf738fa40ba50c9664b097252fe7ecc184f7ed52d22ac4a2676f7f9951c30fb7d028ef91233d315ade8e42af132632d6103973ad87edf304bf103f9aaacc16d4f68ef4bf8a01cf6aa9d71c38bf4e829ea09d809f867f574bf70ac5f6e250acf83ba01db2a8ac9ae56b21b0723921a1607900e35d58f4d369dd3cd4d39ba1a5e7cd9dbdeb7ccbe7be0c17cfd7eaf5f9ef82d1673543503e42f9e22a50b1d68a744dd132eea583c4c565940ee8e03e8d1de1015ff0a1b45764e24fab25498f21f3a71d9bf4db17592d7c9e03fcb924bf1106d6b6a9cbf7cd757af9ee8ab4342b0422e6015464b44e0f00e4fa06ea3c6e9f825eb78a9695566a20fd74548e4945a230b01cded6548dfb88ba9418b9e9fb961d26bccf83c8beecdfdda1da9ca50b73022d34278150ce4df92828da0a3c393f51f3ab03efd6a44a9ea978b94365bf649658a89de189862bbca6733f4486039b1832c2acda50d43ce707d745a2169e6369a76a1bd49c6c70df388077d6b9ee28edf1367aeaa15ea4e0ef579e3424974b4ad2baa3dc33323a56e101d5e61083d591ab7feb4fadc36b9ee3d63b39b9c59a2168bdec32b1229daab5bad15be06c2cd99994aa7b7c71fbb9c1220294e1a98b9706b2e703fe4b50406f13323d3c7a61e19e921da322989bb697b277db39167a398ab96ee2c010154ccb756bcaa37c03e8284f7e6074d9424b1ea045eee52830e542edc432a5fcce06adf96b3bb12f1338c2bbe4e7b0ae705c31a024b604cc3a55d2aed1f62b236fef3417be8e44418f228fbf60b14e86b3d9015d26dcd751fc4317cf76997dd08b0bd9cc3ed9da29adba7161745bcd4079cc4bb2f1207f1b2b8c3301293f1b6d26d74832648d281f082106e9570d70489338b55f79be275f6426fbb7e28e75333d5525768023ac89c4ff9fc51b7994f60f9a8fe06ad95b14e70e97c277c40ff488679235393a3c48fd6c008773d746f7533efaaf36e92535634d709f770047747e65b0fc8ad6ca77c933c724ce5db5897c1dd0a4dfc6424ffeda3128cb30ff75189b733be86a38be63e0904ee10d9d1bcc742ebea88ea560e4c64b19a16ef289c2f9bd9986a328d3b99cee80b48ac9dcb7769e1277a306bd8db402105b0684bb33be542671ba35d20f34112a6eb70a6f889633929411e1720f9e117cea616cb9c136c541a64d5095aa775e4eddfd0c3f93fa940e6966b14f8a0b96b74dc2f0d9fc9d14fcc554e06c3691b1fecf34601d50e50e91de6d59f4d605a579dc206a10be8a23c7f02943c8605b03b161e82ba95e320bba167530ce1908741884a7e42d42bc223e352a2bc65e5c9cf70bc2887fa4cc31de2d5e4cbff3d0f877138236ce2d7b243a24a81803d9be02bb924e1231e71c157699589db3926757fe9a23a609690d8cde044f0505c780f566005025c88329a8fea6277e57f6c0a9984d5040c67b3c1e86f806466b3cc960eb41ccd4211dae77337a18dd8f4ab258f09a1f979a7b57200ad382b8bc03c68ffe965b23dba8bdd356f5a7df5b010d8df6a49025f7a38919930b4ad08ea7c4cab201443c71e6c2810a11f095b3c0417cdf2f576c70c932ff4e138c75155ba8169378d3f01193f0c0901beb88035c8ed4d2ebeb0ea924342c94c70c8dda917bdca4e7dd47533455477cae39163790953b243651427a0260179005bbc6b2ce7351991ee82c9f9aa181846097477b108acd51f975239641a86012503e260028c56c147b797f61e0ce9e0d8c54003a2a1b87b509e42ca2f3dac4e6fa018fe14f10eec391c7d22a8d6254ad48e326294361f5a9db39f1c44b18deb03c4f73f4fbe3cd2c6b8786cfa56398d73f5f3ae0a7570140001a929756c5838dbc8bd730d9132bf741b60677ff1aff7986af2bd21980557751e73e1e4e6d9fdff28487ec8cfd4ec09a8bddd4cc02043762ef3c975a5ff2273c84d84f9682e4a702dd7e286c330e47410d7554d656ef71a111ba457376bda2fee30d72db42c41a3a1ac4c67d546bf9f3d1c6a03e7c4ab2e1bb457367c4fbd61d31b1647be29616980776fa48c728f7a362ff54ad34c789c2fe5dd2e23517661c09c13ad7eac79981e66950ec8395b60a1565204381b1a826d8d638dff572c189d0c7844705d5b6e89806ea9a26b20c5ffeb3dbb5dc062b13a16203f43f5a2efb69050e46d1ac61532e5e85732aac2a33c865824e66915960465f0390939bea6b30031e1a38d7040072d20f0dc9a392c243c621822d880b0925bcb7e4f32060324f1b1fb82f2d44f4a4d570281acc603aa7b566c1adca0b9fa7f99e6d9aab3e8847a61e636dfed533e4e583daba504d8f665e965ff4da990499ce717d721a72543b19f125f281793a0475f7617f8ec1c1307851b3cd2e4b9758d6e4839edb56ed4f75cc5f1338d97a20ef1cf1ff4b9f446c2d19d350d4e68218a5d3856b130506a175f35ef0967ea407c777b2b0876a3220f71010407a674a4f707133c8208ca8123d6f86d56d09d3bd62af4635a490e2d11fe57fdcf774ae97e2c9893e984d926dcf7c4bb85ca2a27f03992f29c64143e850591fee62443dd6c542ad2768728241d7c1d19183905b5e6ea3b3a1ff76c78355d1968c2bfbdc4f1e048186e63573df906920313dfe565d5257497563cd35345121bf7c0eac66aceb921ad1d6f6eda67b7ac511b5366008297b5dc4dda3bcb7378d2db0f56cdaef2fe633bd387dbfb316c50b9f5bfe43bd607c31d409728ac4645dac691c08b53f3cab60b7d480c9ca18df7a077c27b5476df36b07b93194a68c6a0ed41840c91c66c3c408b001a1828485f0c7b030c80e0b894521f9c537cca4da875f517e39007445330cc3d60c59619c86b51cdeb8d845fac2dfb8b78499ca9d3ca30b2ed9cee93132a8d88af38556f9401e92c3aa4ea68f3e7e9376a4d3d371373ac15b0c7f0829613f98ad6120e892552850b630f1e7840b343b1c1855b214c2c9f504a54ae098301afc8d94fe1abc6ddf972cc43217823115575cd6bcdf1e5cb12168f8430094f77a97cfa8ac809ab3d822c091df5557861ccb92fcd13a76058d8413fde66b36f5aba758f63f72b84ee2479038a861f2d882e41aa11fcf30d1b3ac8c989973f631a10e1a788c15efec1178f2ff71c93fbb9d4a075c4306ff38f013763062bb5cd24faa69fe1ab8b6bd2d3e6d2ef3489cd4824746e56b54007fbb4aa69a25a69ab8a377caa57b5ec094580fabb5ab215c205f39edb18863324e956b2c555186e19c6d43b751f40f70f59cf3cc3358800db0c2025c7b0474fc3488dd3169945e4ad6ec9a8a844248eaae20246b51e92e397f09acffbf9b7b798e04b6e9034040b726beadef7b6b62f5b4b4e71619bf15a2500f65ab401ff857300a6f44020c666d821ca135dc3838b792d0c6fe8195527898225c8a1c516576561beac953c563a00ec59852df05c9970c5b582de511a4926756e7ae1082806874b58f31e98c065dcc2bdc032f6651ba6e6857e5758f93fec7ae133392ce8fdbcd9146bb851cbb78d599ef9b2f705c58e09d5edbcd3b933c5f4949c04f7ffdfa85f8bac00acbea281eeaa5e0736b33467ee6734f57bd0d9dcece68d7e9c827246cfdc97b520904f2792f274272c564caa8bd8a4aabbb69b440c994f838342cf88566d0dc9daee5f01b3c565797ac464af847ac1cafa61745b33883566584f3619a8fdf8bf237cd4632ef21403786757f4cc7bba35ea35fd1241c6542f550c9a376616e1547c323678f861b08644542961a79dd813c72fa1da18cfbef7daaac094dc5c97469f9ddc5292b7bc82208e198c055c8c21a0941a60d4fa02f0f32c7e58532a2c24a0e3366e570357feae5c517901c08c260b293adb3c266635e48152514f8cdbb002a94e34c779d6d57943ac5863c7f76e883127352ebb70548d955f988674c98c65159b97f8f956bda64fcc1eec6c2cacc1414acf313944bc79719f85ce168888144c31157b2058a9ed443108ed8fb3dba31fd93bb81a230b52ee977096edbbe3f4c28e7432eeffd695c1e2eccd635d181aee088665d6a37255a591bb3225bb6531a32e5b462224be756ccc71d96d56da6f03815d323e77b83ab4faff9e3df0f8df4b3a9c7be5118bb1c54c1433197f1025e947c29758a940b83c167ac336cf28e54d97e928ef54ec9ff5ed97986af6ead632c5d06412a713f4fad18142afb8ac5df214cc66fd03ac8f80f125599960a022a400ac39b0c3504645ec45a6fb26d048205e4a0f4595f1383c812a8d60f9d3353078ef41c5d609ae483ab7b418ab6b6be98d4cad29598d3908960c4f85843dbefb183c9bf12818608f360109ba24e5bf14311fd8b50d93221fcced24845e4c5bfa652127d57b297138a7defffaef901bbcd0ce0254fbceebabde501bd7cd5bfc3165ab22b7a315614b661391b1d42ae9bee504621679b45a96e6e9c4cfe4fa808e3cc146c261db5bbff755f02fb05849a71314470a0ef5b5119e5378b6575830fffac96e7756042f70b95f88fc721b62665dfac795d87e1cc33caf9bfa07171d1b637ca8a20bf6c80f5e871ec79cd55a9e9d84ba54a333fdb813a45eded05f50990c5d695b5bb367badc545627077f75f276fbf9b45dd9b156543e30952d3eed27cc97c54eaf135194fd2eb5c5145","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
