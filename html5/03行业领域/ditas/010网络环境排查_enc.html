<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bb8c66e9c5f60ac8536bbb53938f1b2e1fce7aec4adce0b201d197c043543613f28397d000e0b5f9d9eab3604e8269c34a4b48e0ca26919a9fab0e1ffdb7feae6221418c59bb01f0c62b34fe1b9dc33acfe4b251befe0f928fdeb167b7bb638740e93251dd917fd893eb9405c22fbe2d718884a30fc4e1bce7419c3ac3c2e9a5247d528e6a6d985a50224a362227d8925b6fbfd3616cf2d40470ba86097c830f4a7c79d2fb898803a32ee51dc573f4b497e4f10b6e66f45ecb49dec7b56aa66003021093070c1c2b81bd65fc2701ae2a701f798b4c528a9af7c4e051f59748adc784546526b457fe1cc82e42c2ab3d3ecdff8ed3f770b034a9674526956c7f3b0e81c57fddc8e988d3592c53b654624fc2089a580c5b3d9bd85393bd5117e3d0f004dfa26f35cd6cc8351c2fcf94e309548239bca82c50e6a7f999447278fae3a73d07a8c52cca22f7b0a5f4b1850b293e260458d3cadd2416d4bb5b57733e8f7a665f81589da479a519e08e9804d8be035afa586cebd1eaadc38a4293df5a042f549cb65ff0724c7c4de345861d7b8271f8cae1bf21ae5303c41f47bc0642849acd0225dcc408ac37a3730c028b25ac49d972952b5b2b42fbc1a6be619196877c8419ec26e97a50d481582b57de53b4e2c918b5e2fe40348f3bdb1eff0d2df208223ba887a7487acc7b599a270e08d5471f84f9d6fa0a6bc9ef453806952c485cbcb2b83bdcfdfaae944e7b9e63e19568ba512f2f6d466ae31e39a81dbc0684b865cc290cb5e0e7c38bddf0851865f03e059b3e4286ac04ccd5af6f7a12f0d85a83b786d812fb533cab09b8377f023dafc63ba130e4218bbe3c5d95f991a1821e0881d9d469e383aecd4369b4109d926f10307f291e5021671930d5c2b5938daae636693b6e6f103b63121261a3a22a221846fa75175806d98b8328dcbac8ffa4e1c13a5fbb251ac19554e8b6c83357073b2558b41c7ceeeca276e0f55cb5776c31845f1352115c9048bd77fa7b67e9558fe046a96115d1b01f152887ff5f94f98e1f730a56778805e58d206583c81a04dd1b2fbd0e4d364fd8aec11cee49d22ce92e110b4ee199ed72a5300e37de2d0138f34b1595aa4724aec85614f4894812815e6aea8a8c9fa855175d6da7e33c2bd5a86e3c5a765e001dc39e8f31dde8d840d710a1a6e07ba38d2d78f98baaaeadb936bd2dc7afe17722ba662c504741eff20683e0c4c92b63621cf0dcdb25378a0750167118259564221a7472eb9363dc1916a122eee82bb6e8cb805acbdc77ea6d546154f63b851f25238df0c54c3c34f2c6e78175533585c8119765a252fd99f414004785e67699fbf4ce1ca164f92a3e89dd57b270a20162efe712dceaac0b1a8d8960aeea1fe3c0024567682a474d04e9af03a1858b894b072a85d93e7cd5add098b0feee2d595991137b151503b09b3867a10114057552c7565ae9dc5c4137b82355893bb7e16bf1eea483ac01ca98987b53a7e68f8d0c7074a2327d83cc87744bd56b8675b3c0b6a7edebd3bbb1665f29110cebe97f7f23dcdf5462f4d9825493a17ff9b644c6ddd3388c43399168fd835b32d6a69802bdbfa150383644c6d40b6d33f802dac14e093f2c34b086a80afc42d09821a2e710646c8eabf5d34f01d518fad2ba168ecf535bbb516049a51c474472fd31008f9df5d9d967ed9cc17e8ae162c19f3033e23f77461650663511017e5f3e0e1c3dff87fd523f618f857ad94de54f6778fffb60688cfe13d233500d938a7e7d115941e33d17167ce5b95548db28bf6e57fd8be6155774e2ede56e238a79f2ff87386192a1059f8a3a32f61e95259722f4b7cfd5b1ab1b1de8a7a11a0bdd45e7c320d5ae4e8d3432bb872a6df96ce0df1a869d516d5a2d6819fc9434a2e1945f0eaf19b7dc7cfad48f3218c4f25a3780ac82f1c79900a85942002f4bffb69cb7d2de1c2873d867a3359ec6b6cb59aa3fa9095446914f801fc38c7c12977cfb91250345ec7c282749d6700c0c1caefd129c45096f39cca7e82f025eb0b9cfc6d90d988c28d7be48292c4c49235f2be5e3841f8c928d89d6b2bd486fb515432abf3a259d7599c36becc42c8bd0735256e539510effecf8f517783114ccb409989e2666e8c6a01bee5d922acd6e543d3324504a76da166af8c25e8655d758733ec40c7be8e64ad98346d00e18a06e6b1a5c17928f047011159b9ef49f616d03a9719e0ee2897cbbd63d9ede58defef184a50b80184cf4fcb15bd1b515926eb6506079cc6f21b41e01c682dde39c47417580bdd2664f2c7811c98dffbb547b647583610214d549cdd3bc891acfef4efef7ba24cbf29af7de490d7f40c1b25d85aa80faa63f84f7c0d56916639f088ed4153986d1331fcbd06a16dbb40d779c58b21f5551d8c90f2ae3baed6b736c723408c6e7ffcd098c6eb6f91497df5769010671d981f2f64f35facad809a0791ae7d87c116b0e52b499af67cc367848616fb14b99ab1779982ad1b3536462ac3813bfe580bb1a1131b19cc1f5f031ba86f5447a485b340140982fe8a8218b892b153ed26dc48694293511cff07111314ba58840217fb7b1c7aa866214ece4c9e76b5fbc0ad1c6e393b601c516f627cb0158ab0d87b3c857560593c314eaac2eede7b504828e8dd585af20a25025babbb9fed45ee3426ec163653a8b4539eabbccb7d4f059e26fdb894d3bf9cb5a80e71ac66b8b2edc552ade8787efc83a8859ee472a7c7689d71b3709b31d5d034c8566d7799324028ffe3f714d69017fcc78a65ce159d1758f3a257b6757a9f6f9c8e66f8d418d5e520fc0357d983a26360bf2c80bbc63ed159df11af64ee028c0c98c624b6fa568080f8dacc53664399d5cdf9338ad9a8c432efdadfeae423712ce874ad1afc79d7504d2b47ca13cdfe86fed7123e0274336f33af71859d76df522569473eff1d8d8414f3dd5bace81f4a531d32706a2a960525c1752ed51a7974f1c85340bf386628ea956c6331f2de30442643dd6aad74c610f02677ef4235b9adff03c0d1791710dc545722e84ff795f391173db19f85bd76159bb7e563706d445d72c8efbd05bbfec036e5ef413f5e19cabbc99034f52755533bc2aebc299f587d5e2bee12b063c601106e4179a096ce6a51520a24839fb6e04ce6d2a5deab53812f26c1457442e41cdb690859f62f36d1efcab268353ac38de9127f88bdf6661b0182a4f72e20660a46ba2783b8f126612dcbc3977abd44bd4d852f1dbd476d00c9b30a7fd5611914e0d7767f23376ae382970ce9890d497dbe3756131f4704f31eb97022cc42160236239d5c2f12cec20eb69ca4ae5d1bd5f4359a5537a491f8241932281daa24181ffadbfead0d926f6f7d5d623d874fc247930da402cf8fe2db29c7861cd312c0cd67666cec378e91891dc516268d050c95ac8d729f27b4186a1e66e1b16bd9920b36765637a0741bfacf0b5c6620969be9f5d671f3362b272b268d57dc260bdb235a13db6a1dcedb5ac922012c09da4ee63372fe3d46809f8f09074602d2b3b81733e3cd41137ad07450004d6eacf21a9036efa1413a21b3e248dbc573e5274ee09c8f2d85be4bb96e73cf697226b289eeb063557adf32dc01bca871d07a9fc167f6c51211769ade1146697eddaee8c0a26eb8972347839700582062af3462bd1b3a0153bb96226d161acd7a253331185243396df3e3df3a00965cdf6847c44da1eb42fb841a2004661c26b2f3c415314284fd0ed9d9fd8e3c97cf59293029075c6732ce461470e00f570192da34158baa28bb9bac184397eef1f5f2e5da12dfc81da3686d9ddd199ee4efd742fc3ba5c0bac38e12a3275edd910da05f3cb60d9e22000a76e6f020aa6266b6cd37f76aa54fe275fb7ec8c0d1d10a0ef28654f6cdc011073f5bea2d97cefe3dab4f07fe92a0cb2079844d825891082e5319b107d134f208747f515772d0e619f2e84d2cf0c8fdcfa38ebef65082e1ffba1d63c3e0a4e762c387f8cbe5912bc74cd46fcbeff7ba358920e313f93d3e30307988be358374046c8af47d7cc9b33aafc8a518f7783907c403f3d3ca9531d5603e30b52e460519d87b4be95f38d971b72892a425a3ca36768eb236ae437aa0fe324fdbaf981c9080614f5d81686f8e5d48306bf25897ffb30076307be28fb9d448ed0952bc0dc1299c5ae128373621634c622e38f32122bb3777fec0d047c15da714152119ab38c95916caacac56060f1e85df3327b286d48982038d883859cf99a9451ef8b622ad40e460003eec6d66492501dc89f20fd508f967aaff39267398839d4d1d08c45edf576eb3dd134a631abcd1334fb4aafcf3e16ea99c083401d7f8172336c5fcb13c38b8edb965f42e59ed2d1fe7333bdf8f88607259e97a2ac1adbe0fbd101bd6bd05afe608a27ac4549592565ee3e06ab8a17484e187e101a1e062abd5c6ee2b02b0273ad7022727022d368d2d437fe8d8a20c4bfa4e2e04068d5bed400b2f6f6218f619041791804dc61e581eb0fa9988be4d4f055385ab32631935a483410eeed8d1f8864693be85a7f993a97227e6ee29bc615db4514630ea6479a2c96b88e85e95048c9007aaf0c5fdbdb0b7528e3a1a03ae67ad8832cd29f2dea120f99e849ec48ccf08141482f7fb555fc3d58e16f4de65ebd191d55db7932fcd0846a65187bbc027b90f4997c3b953be12a217911721e0c43e6862cd6a0a45ccfd854a2fa896b4e340642d83f4b103cdd990d9cdc7e061174e5aa825665c0c0a3b98b898ac9331b87c1beb41654d4c05f8269a9f0407d4e431abe2ceb28a9f75c99d8d6456b9c9ffeb6e97ce7dcd320bfdac66e74c49bb6d1e07326746d592bfb3f853ad0644fc842a0e2ae517fa4153d3a59733680d3fa39694f6cbeffeed6bfa029039b4d9bc58c743b11a70291fa7029d79b76b25ebd4db6660db438fe3126a97cdca1c6bff5531fe6978c90e2177abef327d8218348d01da0e32ccbd26c942c92d9f8541bae90e5c60722285a942727a46cf48ca6a15adb57e5cea2d3e5c2c4dc82d2aca6d365bbe7e75ea3be442eff7cd37512d9c1a0f85eede391d4864ca82cd9dab4e353e08d64fa212a118eac52b6f42291f02f12302ed817d0d4c9362120befc295b3776c6a2a7d8add7c00bd1050745dd4345ecf5e7c48b4815ff28542de83d4a4f49a9319ee5211c70231e1ee245663441e8d1aa82055b1355f8c8a79e317ea076d8a6a5f5305a56622190a3b61965bd562b1b87dc95b8874753031d3323d941b69049ce80a1e1e6006a464b86818dc33ed40cb0a305a993ca0f5eb9fb196ae232067a5d99324715b7fa3ec58fbbfd4b65fc2a878c9b56dac5d71ad74285e3ac8199e38fb5bea9140b8b46a067c482b3e871a8e24bffcce294d737720a69b12968d5e6c14c965d4e00056b5a2f22eeb5c0a58d9df9ce7b3ef8a7051c0ca517fc35142d67773f7711a1b0da9862baba91a9a153c45814ac1686dbb49c5496d7b2ea8b3116f4ca6e241941408172978710121472829564a032ec16cd68b197cda3b411ff3a1effe5c2c956d8472a4fad9ec889834a52c61f1e9724045dcf7899b389dd6a679a7b0b224dd1b8f6c98c8ac2ad5b013f0751a8bce10d3e445934b07766a1d38a04a9b42f757584424eef9dbc195329cd4c7ee55554630fc52313d89db1c4e942004f6db8fc308924153e8c770d8f5fe41a86eac6b865827d42526cb50baed24a8d05711a806d8cd40d88e29e6e4231f2b628381e32ed6c71a28318cefb5ac9db7a0ca352e9bc9e4a08e39d0cde63ab324d9a9905e203f9b199e323706b4a039d5f145cca7e968c8b61c12cb4d11b4445eebfcee1eea71db303ad73632f25a0697e5d719bd6c29f67b1e494bfc2114cc15d0e73cbf215f4d7de2d9a9ea1f7299d4bd2a07dc45d4ad45803de98a55df93b9e04a224554419820ef0acafb66d71ba9053681c4daff7be74ba984fc7334d9191fda9f53354f030788349a44d9cb6383a0f1aded1a5e217189ef866677614127ed6902a5b58a7e276ea53c55acdeef2ebf5ccac1449eecd4189f4866fcef91c6b59b54d6448863d05fd13c05483eb0c904769db3507c0fc99d23ece1349047663914666bb46979c92c3e8367db8d243f3d3f8ba4dad886aecc0d9cd70db8d048c5bb0a4740e1c623d1aa0b895cdc7d9888cbe8d3a500731d232ccd1ca9525b6e53eed2639fa34b2b0b6c001af962b676ab31d2589389f33f379d4369ab3a4efb9751787afec65c1201be4a60a86e7b21ae256c9a82a000ff07cf0cfa270ef00012bd97178de44d304a3d7839b59abb470db6fafd5bfe330634a6727ca9548afead229bd1202891762e2d4a11942a1895bd9e39353be85986f0177d0dcb2eadabf29c34fb658b08ed37597652b4a4364c2e15f6d318c845c5dd729c1ee50cacc8d96034d844a5d8a474515766a32edb50e4ede61bebec003902806f2bd5cf86eb9c00db03d49878ebd4222530ec48752da37643d93c0431919c0b833c998d80d495282a1efbe3164a5891c06aae3a20979224b254fd3ab235b439f962cc4256294b415b9e314c002221a2eb8199cc2debf4563b17ba3e489e52f34da49c4688d542a631fc9e2ed2497b8abf27871ac694f31789193c9d845533811cb6d659eec33c84dde5f3e2aa999e99b0939a1bf139ac80aaf3a9ff18211d52f86b44ab6491095e32e57d2b4df6bf24ffee8a1b1c4a062893987710172c51e374b25c32c7d92e80bc0db0217ab1e00db89bddaf0e2587cf1166af6a697d29e3b288f57818207394494f1dc8f02934c76efaa8b7d0c8b31dc42774e5bd6c93578b0f407f8af8a4bb04dc0d149bfc74c1272e82a9441451afe6fc88a749570a00a33d88d4d64373ac42067362e482dad5c8780aa97a78c862801ea6c65cd58b00b2d74e2b570f5fa17ec9869cecd5e8c8f6d578b37b31787cd7e359df94155c379604f8b156f22edd3d7d6c5c59426236b470b2858283ccd53e9027762ae28e8842fbbbfc64030aa3a3b6db0d098f553e8cd459d6cb0c0a0d1eec5ad403360a8cdd2a3bd4645cc65018b9459e06827199cbe09fb400276d2da292ce5014498a333201d9e03290d31dfc332f2ef0346f7ab47cfa687a9647c043c254058dc1766aef2578424f946f4c658137ae67b12538d5e8ed2bfb8c5f505486d25b12d859514bd5f4ea6852fc34b758284116c6731421c17fccd6b86c3054b8828d4eb5668554078e6e0bc55101651cb63bfbe8228ab2f9d0a712e056974eed97c6da0358730a888cea0301d85a602c5f3faad66f3fa790bbe81830d96c1e441b18a252fdf6c6ee8cf2fa8a9ec7064ff3ffc3cd5f71f58c4fc5b3dd711ecb2db689d7ea149a995975b770ab9bca9b8d2bd4b4f9bf83fa46589d52f65490af39b021fb7d6864e103cbaf42648e18b7bc6a756097c0b36f94c0a134137bf7aca567735498efa676aa4ca8aff2ff6fbd4e2386063b12c5b343287848385d10bfa3d658b85c72e6155f988fe7891a7b6a1a49d8a53d2aba26179e95f8d7633bb49f3765911d5fba1bba2face1e3256fde597c361305ee856e628c0c3f9a4e82140580e04385f4a683a39e12995ab19266f0423b6a33c31f5d90af331bdc384f56039a032b3b630d2ad7d5c81dc41eeed15dce1c243336cd43d249c61577c92837722721037d9153b811b3b71e5aee957f5c8544bad5530dcb5c17469a2c0006d605b0521a2ec37d90785e255f29f245dcc567808b380156bcc588c0ebb72b1aad44019fb67d98bf739d23e453dbfff9d522b1170deb94fcb8001ab54b10a8a7ab2f1bca2587a152fd3ca8cb5f66614bd69e0da0bcb24db2cb291a42e078d4a7062fbb78e156bc7e7689e37db05664626f485903a84639016a6e600699499cb72643a17e0ac471df684ed75bfc3e3e348e8c77691d6b7f03c96210cd80e6800b4bb89c47d7faebce04ac52b4ca7e6f7b8ec8dde0d832cd3d27a77a25890faddf6744ec88391c5c9d4853c97f2b0a9f9d540c4b2da46ba6e41d994f9faf1ec7216e8131d8c9e8f48f1cfa1cbebeacc2569d1b98b8f812430f845ec4b898b6c2240ce4fddb580ac98fff770c51999a69e5aa46cb455d58d4c357b454d7f0bf692213ed2285f3843050cf30792ee1abecab799327bc859b077d47935297c347c8008aa5422cff0c9faf0a55961298d1e5bcf7cdfc991b3c4ff1dcee6bd4e572a16de8bbdc41c795241e58821b34311a1447394dd38244bdf5b434393472d31bb623d3543b8f49e3618d88bee7f7e578a4bd9402da6a99b771465e6e2e1c0290f62c8351fc066d4896c1c749f4a9223b9da59534edc113712021263a75cdb88e8ee3d4179be14ec6981acb341d4a01169403c85119be23a960cf9b7aa122c91d1963f658fbdaa2c502268b6f57ca21aa5eeaff53148330a9a70368a60b74ebdeb4be5a4d16b9cd4f8052fe9be2205c6789d77aa5657ec1f359a78fef1dcfef39f6469d9bed02d267e1e1f4c375c46e2573b4a398f0cbe1f7073233dea761bbede28dd5c92f1768edb6a4b5e5ac5165bf4afb03bbfd9f6ccca13061c7633da0ea7ebe7098b07b61e83b6d1575af45ec7991d1c18524392846a5629bb82bfb571d03cd652db011ff0bda1fe6dd24a62c1a34c4d985b4e0a810cd92b45339bce49df8795fdaf8f18b36bdc415daac5e8f7347ce3693e44f961097bca556362bd38ca358eee595386131e8fee739f3a14a703d7a8fc15d6b9cc565d2a5ea0f7383ae0b472d75cec9cbc4228cc9a7ab2cb0792ccc437760797fdad1c0c08c44b51c843b9dbeab66c3225703aae47f500a7b4c3cdbd136556805833023940eb42a0e9238c994847e2798de97781787499d2e9d94ff456e831c126aff60d8ac5bb9c0970011436bdc7e383a358a028af6a35419a26e5f41e2529205527d93d77fd71d1c865bf1c0baf468d1472c43c9338375cede5a745ab40c31cbe49723fb51ec209899247385cd4b9d965bd2efd3cb1720caeb9106224ac93a4adaecb97073fc4e5e611e7f12ef2d348c1c1b6136a60f37b4214f31cfe1d8786b1ec6a60aeafcbd8f2245388dd204d2d9a7d50cc49b9435b8c2dcfd8507d36d97274a385cf4f297ed2921ffce68a6748832c14d6ffc29ed2d4692751ac2256f5de1f4fa7f55f4abd6d64731a7495e46acbfb02c0483b9548ed395ae9386504f77c3768c905e0eba359760b4ee55b666f3e052fd6c36c33936ce6be89a210318bea6f5ae1f39882d06801144ae8b6dcb26d76c689fbd3517f224132cbd76f422dcb34ca4b02031fdea2d5f8176ab6ba574b7a09bd3ee4a127d6b8c78e0a15e5ab6a8961bccf1f4f5bf0864dcaa23758fd5ac80c5b417d20d34fda7928a6fbf199438785fcfa2e208f6a0e2c63ba56b29712f1205bea4182ec2bfb01d51599cba69435a2e7d3c544dfb176562a94a034fd3a2fc59589ea830ca737929ea9e745e97026030ef0162f340931631ba5f83afff4ff074b16fedf9ea035bc0728009c2af9133fa7797d524ac5c50b94f55cd6ac894e82b09f184941e945927c78a4acd17b4573e6bb19ec2fafa251f56b0bc1280cff711f418d3cf8dac04af1a369cc45454b1a8abd1efafb54e36b086a33cfb6109d6174d4a7971dec38911849a16b8662039b8078f11fdf573678e8aae3e8649f34a1fe28e98db709435ef12192e8c6b430f52d6a1dfa87fabcb736cc9320175b59aa3de4ba3bd8324d9b34497b462a7a318b4406d147240204301a80cbffa63376956c1245ce2d27516070e0c151b41cc7153f1ab50ac9e29a375c80058d1357744d9e79838e86f04f899fd80b649286fa3a7b0735db3b5a78282d7fcc1ea5fdae65290e18a12594029068e8f6ada22ad234644cca45efbcdf8418f81a5928a05745a5cd440b5e5828f6cd55e99ecfbb99d81cb3a23402c6e48c6ead1c82ffe0f739723020ad51e486c714291a03197cda2f526137335bdecfe120b69cad677b1229da8f833efa7864ca29bd3b086cf9b7a0101021b4d6e09c1474a7b06ba35ea7418e2ff2f6ba74da119e309bbcb35a9dc97cf6fcdcab2be791efc8d4fc931a62a89a778170250e81a609ae47cd92c54dd68cb1088ca37d28cdac06f00c5df1311202f32d1ef8d32dbd83b81f1d79686ac54c079ed2c875078d23b5efc3237a374efc80fdbb679d72f7b10967433198d5f1272739216f1aec4ea38954c8a43b873ed719b8a541345b5874ef5102539713c9c894ebbe16ae7f454945c2ad7115be013cdd5a370ed3f08af3b43849d6e046e376831dcc3a21dbf86eea3dd5e4be9f7e919097640e24680d9bc55307d057d190987b214761ae4e79baa5337d8d996b6f0f66af616bc721a29dc48ce3e5e94af3e59210ad269f5c7991c2412531731f925d5e74c4e8d522e7a2368c5b376b4afc86e1496c1d2eaac1a0f3cd01a07b74ea9b6f2fdb0769ce6e71057e8844ce63557314ed7b9933b04611590660fa50943a4943121bc3b49ff573eadcfa61a317d3af6c3106fc0f73ee626b50cf9d51a459d151e389b1e9da53796824842055338cbaef0c2ed85091e1ed42a3f412aaeb74e85abe71b12ef9f83aaddebd3e6e544d7b97cdea74b81d5642a8daf95c4cd571c2b938e04ee3058e12d9aa164b419ec11d20b43afe26c758e103b6bef20b92f6fc5b0e36c2f0bb7fac997c80677fbf3e9f21d0e2d28ac89ec85ed5589044c4b30479bc1aa286ab35299b7a348b5bb7a8c8d58cedf96cd1ad5e24faed74bedbceb9053e97748cf448f9d955a1f139d58d90197165fe3e1070983ba93dfcb2e6b329691d08124692462657a495115bae6cd7c240903d16a953515a5fddfaefdb41e67060e77290e58430863fedec69f67509e66c0c5aa3b9d836c0f3da04c14fd0e12ea3cfaf3e4a7e1a03343ff18a42262125e8f908f8aa9b5fba6265df448b10bb222fd757cc0342f18161e0234c446bfa7b7a6d8ed446d4f8b3b6c15cf42fa9f542d1dfb45c862be82c5a27b1fa9242a1cffceabf575b7a89fcaff3b4483be3952301ca7dcd48be4a01e0425fbbad81e84db9fda45f76fc777e71f1395a1d418c311ef1469667dd99ad4f8297a4e7e555059bfa00f6978c99a787194bdf7169a9874b97142b6d1cf356898b78ccec8ec9b123d98619f948b8f2c27795abeb51ed2c9980a08cededf7afec60ac3035f4eee945ee3b924bf6e44801f431e86ba6d8c48a599a38c70dfe7379155f141c4c18ab51875147236bac36f303a5157fa8b839be8856f6d6779fae3b5a77e41f4c33c9168f902925b4796e207d960d0f95c4f64a19be2befd3aa8a869ad6f04603bebde2adabc41a5512ce9595e381e9e326b4f740ea836bcd0bb40923a0c0c283b6b1913a4c11606b4b37c87b7a499055276427bb58fe5efacf9b137240e1e4b4704e6e39a7578d811083ec9b170dd8110ddff78f64cf520ca6c35082d91246542bdb7e04d8157727a5a7dd5be77afabb5a67953690c60793113f8dca0f8658af3293db4e7cd3f1ed7beea8f10bacf0d0586997e6a045d35817bf0fccbef744912c27aae032f99f1d6abad147","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
