<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"78de671d2f337fbab57f837870a5141da1a4292e104ca3d0dcbef17a93a60e1aad97a56b74fc2d783934ff821fe1870916390994c9d3fad5fc4f1e83a1a3ac66ec7fe47cb99299e2ae455cb0060c0c17b61e7bf35e7ea11acd39aad0a6af5da2bd1bb55dbbbdbdb988999c6c8e8a39d08ef1417f9f686e8b6748cdcc3b2cc042b3a38227862a81427eba9d3a7e295fcfb0205dac5b84b52a3c8a91032c812b13dbd4ca9be14b4f91d3c4204d5f7a9d60cf9d56dd44abb480077b405331c2e36d656b1ebd90c9d7199c2f4f315ebed88a5afe72e8c73281a49effc2c10fffab0106ca5eaaedae9f39fc0b6bc86c8317605b6a5555a3336cfa370a24f1e6aa90ec4e2b1390ca92b536b64cdb600f06fc19d72535cc5c33201a634aa8a3e068051ae990fa651ebebe9cf95337b6999099f18ba838b4f765aeebbe87336d0a55dd676e18c1581740ab2272e9c4c16caeaa28403d4a26c176bfaf7df2310d1b85d1652078d7d5d301a36dead83247e7076e9145dc4b5ec6c1f5ce7bf0595749c1f7a81e16d4c891f91989536b0c6b70a4c42f1cb1d359d3b88bf93c75c81ac05722d8380a3b18254ab1f272f18acc69074c60181a83e1afde631607c84190d6fde29360b7c10118d490091baed81f6f2968ab11e81107720bde4b8c09071ea444d4f481700a7da203980c36fc5d63d7e6d443fe24ff34dc4df1b638100383c0bb46abeed601ffe3b0da609ddf15f8fb8b80f7179e421fbf6a61606150fd574be83047626ffdbe7e41ef4240c2fc67226ec5371d42d97abbacf260d984a7ff3dc01075e14a8ff16e867b92845c832f4619c2d25e4d73525796ad94e6479b3e5671305ea60ae557a1d8660ea7c1e39435b4e95f2e20f02e1c4e137f85af80b6800f841a5f2e1350b7b4f6518474be0e0eb78f7ce172faa44f25d7ba1d94ab4310cc04a04eadb3049cd5beb102c10631344fb8ba326d7d3b0866b5aeb11095aa6fb07e7889737ecf6bc56729ea6474e916c6b2b220c6a159b964dd245bd6017b08cb578a83ebfa81dbde7f00f444236d25cef6738e2fbbd02aa5fba4a4bbd3ba25a06f55b75b9d1f262339d70657ca8329493d260d34153952a881f273719f439fb2e18154779a0303a6583bdf457b3a30eea00720612b085edae96db44e6326c2daa063c2b7139d0b7328a4b5bc078f4bf5f5591d4217618b184339394e4bc503b67a7667896fef4d0d7faaabfba30737cbcab77e9ba11e20fcf51ece43224f86185e24101acf18f82a3e08a488db9df2b26585eba52b3317e3e4eae84af0cc5ecdaefd036c915778449ffb01b718a7c0a94ff0324a43245bd322815f1d8d663e38dcd9f87abcd07b575c5805344cd06cb0dab24ae7d30f7b45739912d523d4a1a66313c76c69a3ed0a8e6e98ff7bdb17c26cf941838b3863bb8d646885fc961a1ab1dfde3b7fe4935af4a367b2923b6cdd364106d19a7770a1941a039d1491981c8c4c204fd9477a2d904d8c18c0ed3accfab569f9210110de3b31e7b38715b66d26b64da7191a0a6e8fd7a52d9a0a0c82c2e692857f01c626cb6ff62e27a826b3e5a398eae422f11a8bfb7e70535e88651eb9ed2dc44f3d2342c479caf352007bc3f8ae044dfa7a5ba966747b7b54a005ddef08a2d36fb092d1e0ce12aeeee517aff64b40bc166ba70656ec87be4cac9e8d9cbe00f2838ecade0843b6e18fc3d4b5088628a01c16a036fa0e57180e69400362ace0f4a0ba34a14e4188da8b36acd454600c74cbc9f8b2f8d7faa7fbcd009fff4643eccfea1709d341f920e1df3b0ff362a87bceeccf2aa148bee3f17ad81d293659aa5e19b7abd04c397231f935644724f841e99b19651a04796dbb36efd841cdb3ab7df867cb9fb63dba735e8a6ce74c20c8a7a3df3a8c524efe4afe24e9de68a8a1478e6078b3f51a70ed51d33da67352ffaa4beab9271c297d24433041ccd122d325f7e90b647f5f65d343c3b3e7c2f03b9f8d0afe77655426222dab19596a7139c89fe00e76b07d0ab8c85000e724e4b752abcf50852558e6ccb55091946c779d5cd9e912d3fa931d9d7372f010a1f936c16ea23447151587057ed9edaca910be2a6bfb7772ef5763cbfefd7a8e46d9d1a7adce29cb9fd2b5349c7fb083c1a72340c0191d0f1567521579246eb340f088477729cc3304a61c2858fb68ee29e522112201ea7e7c60aabf443b9e4def3937fdc901ce6c80c0e062e4015950e19ba5f6a4fb658359146cb06c5d98a8a336c0cdd225790a26bfaef45a273b928235ee538b306406d6df65e5b077ab4a95e09a460ec2d372ffa0a1e15e6c42dc58a3ee1838e19de38b7b8bc0b0cf8fd518716cd7215e33b90743937de02e0cdf85b7451c0515b6d1b5cdb20ce630a7df09357412433373079266ee8efa94acb115338dfb8eb8de81b14fd048b5ececbbfa995d41e091436a0e19feeeb01e978f94c43c9c0162359a5c7bd5c446d1152ce36a61fad6c5a53ec1b0d80f26245c0f3c7f0ae5a596f20e02147f584f1d03cc35cd47cf5879df503cb8333f90ed97070fd0cc3742a0164b702fe25a981cab9f59206ceca3f3991a14f7d3ce159ef19dfca3f67f61f1e95a79095073bbd07be9aa617f86dc71cfbe147b291d37b4f4f787818b58bb1347a406bc9bcc49e051d4d47f36dfe8779912f0a8fbf0864a8000a25b36137fb3cfd4ad85bc176d72b5a69b908d9d09a01093445212e0b07ed1482a24914e4cdf75483d1bad2e5138493d82d154d05048d20103724abb59fe117cb135095dbad51e8ca60a523d465d3072cec80b68cf5ddc948c7f1140a0cb7e227ab88a71594891d295df1577366b72d510d3d71406509826b90ca1f61f839d72d103d789a276d158d75c7548f9a6e0ee6899aad7b9abca32805f9855ad8d2303efc9d12f8ea7cb70777839f012be7b9b948056e376831e9c81ea0c529e4f1c6c1dc996cc1aa39ddceea8fbce22a03c08fa4e8f1edd5e36bc62e1d2aad6ad271d30659d6f9a1f3282135ad9d7a2687433e7c63b40ff17235d9d4171b664951adba359d06e0f49c5b5787155417147d5903dc5744a3b528d1e80539ebf796d4b2e98ed339c16dbedf205933b5bf5f07a3d4949b3855201de9adbab5bec2bfbc348f37d4340849de7679e8f8c4585c2d432408913edf3d481297b434d7a71bdc0ebf9984ce22071ca3d5f388141c2c0e24d439df908c1e05962080e42724d491ae476374e87849f4934abc944c5a8ac2acec05b97c014e1a56fc91bd369c39623ee1368c24c830983268c1472578713a988ad54b9022ec6e440498bb62c62fcff32305c1e10589984aa5e0be0803b9b118f9993497590556c279c4a47681b30dee570968fe5b1e0688475e15e8669dcb68a8bec570e629e7d497515f1840706e791f523a9c9f05c8fe8821f6eebb34b531ff4d3ec376f6f831fd7d7d2022f973d28db75e18a619d0852b8222d9405fb3592221179e03a055bc370e4c2b9f6b8817b982127566afe743b2ff5b87f3acb2aca9dd5f438bef5703166be8d3a52a95fe50940e317227c73cfe9578e33f158f8110b372976c892b52243bbebaf26326f0dbcb6cf2013964ac143ed8f581d009021805763530ea845b77e77e6c601b8656c2b4634c54d13b4e758bb69564cebdabbd1402159843fe05b25ea5e9f48f15fedbd60666b345d712e938cc90741677f7a87af9e19489768fa0f32021006cfe777f1afa9f814636b5d56308f232ec690c939c24a3bfc3f4529b15dfe3cb4224e763dbb98a91a321118412484f81f7cfb28afe337dfeeda2e16a60475c42ebb77609323f11c7755efbe0d1d77f17ece38f20d88065d0512cb68444695c19fc4d301bf930252e5602562623f2606081a892843591feefc0a56412ee5ff65058ae18eecbfcb3c09a57a5b067c5c55385c123206d2eb9f5abc090c14c2c3a5444f6b429e08f9a12ccd9911af75f4df76f397e511324ebc1a5823fd21c8fef948703b6a3b9b4bf7c4b2bb8cc40af7b4bee1ec2b1043ca99122857229faa1c4a4b2dffe0b260664bb4ef0637e91962f8db30f4155f03bd0551b9179181898cbe1a71b053704b0f966a9221edb9a268fd735a84f56e01a89bb2982f75545b2dfedcd814d9cf0dbf190e7a5d9e73a8d2880fbc339c510b7de442a4b72b2a1406f79418dad91b4b8f4e8dcf4387728df793cab830706d3c1301a46b721b27f9235ae9d4b4fecc3be589f899e0cead728af8995b2c7489e4aca93adf0ee7e59b71c54971968cf7dfe2fb90faef0e111a064642e705fa92bf56fecb9380d2f05237760e96be74cbf2d3ac081c054a98c959e1611828c1f99eed29c09f3363b188cbe9639fbc42e3adf4a0119338a44a8a65d41c6939916c9d01207c51e1027eeb55aee13e8877d4f88d135df7bc5ed2d8143df753b24885661b9f814e218343228e85563e0ea36f82f7ff63e5ae63782edc600792d968177b3e40d6893a9a28027c109f60b66c4b6ef1ff3fce1dce99bcb46c4007ca4c287236770655986334deabfd4356aa46be5027beba0b3bbb83320baf79baf1c64bb50eb5d5f9e89eb172a905cb1182f32f84bccab0f3b6b86aa9a2afd4c4f88fe8e74556f691a6b8e7d1c3d07648aa00dea576d7255b89bc9341306ecf547d984fd5266e3c6b09f97bdd6f4e5b7a18d9368f2618474bfb96aa90b3acb76d87ff81f3836c7765d35188aa36cec81ba57787dce842ef800eb500993fedab4f9eb3b7c20a556429fb6fd392f54f823b7702ffa58586aa90c38f9a4a5967030e370c66af18d6ca2ab113606efd719e5b54bae2fa8295123b941d820641edf9cc14e13e9d5c75d9422a0667e9fb5c15fdd5a148b25ac959fc236fb4fd6818c876e80bfb15cd2ee872f1140eed6734cc976d364926f9f0fb00232d0f19ff772e80df5e430136d893f9cc99427d55798b0268bf0787cb2011b2c76d19f005c8ea4fc0e674ef463de4498a796551d2bec33766aa95fbaab0f7e2422bf5c9cdedb7fa4329bf9dc65c06a4c95b3a851816ee83f6dfaf2a52efdb420275871cf2582666489c5c70774a5a4421336ced172a4c218209caf601766c41548b9ff74ebd04947090a545b6adfeae25a6a648974ec477b1773cbc9cdd2f3e395b8ef6fbf51606b4784698c90f27198588c78cd89274b46a022a88135b0762470039f8c65374619a9d3e73a5c01cbadb2e4d71d29271615d4ce334b1e27d61401fdaa4c31b637557795bef9ecf009bf631b1d427d542b6feed556d1b40f24ac2fecb8815145bf6a7319d4bbf84d8feb0ddb65d3eeca070d1d91a7a1ef135503505d7268a72d430804ca9b331a80c9f68024b785a8c5ee5ea20d6b43a6ab8c417c9e3f5f5a29c25133dce253bf80380b107a68ac2c2acef94d1546283b3bcf57b78bdfece961705e015b02c4605cf424df7d11a95a5e3264f9d05569ae6fb44ea5919fb17194f17700c88caf219cc7661427b67cee74ae7e944ee1bfe0117c8d67304a33406fc82334c1be96140c18c07dadcfaceb42adef68a28f92a456f1935c826e804daa2acd0f2269ef0be95de4f4d483e04692ce984fbe598200b196e517141deed22c64d67e0fff8265e959d440390e16246677dc9c26e8c4c39ed6a6a541f4a5682f5c5f75d80ef57e22c1252dc4424c7c4d9e4c2440f236b6979490d28fdc937ef52487f728a228b7548728c1c8c6ccf8a5d6c05540f8e4b2258a75f259c1ab13b80df4656baf7a50a7c5b9c8e58cb6fedc5c160c46aad199511378f0695833d2795afc98b03e9a382178770c17e9ad179e4ed3851ff7a1c13e4fcf101bebac9fe460486fa6ce27cb106438edc2cebc93e755071fe8cc4fb61743817cd47dbb344fc8aa0a855bc0882e7683f291f3606433d7dbd4735763cbfbbaa206ee2d2c37ca7efb25651c3d1292843d84b8fb6e861c2cd91d5d8c8c2ddaf9b813d0a7decce5df81bb17d2376be7df4794be9110b7fc23ba988bd852a74ed75dfc77dac6af86961408ed6a21e720845bcd15c4c0bb75d375f3ba09f62795e85eb952200d674d8ed50965387f37288c5a1c5a79bbf5ec2cd7ee23a731a2f4961aa80d03fab12f88b28e3f396573fb612fd65f7ab2f9177aa85a810d64f4eaa027a7ad7f79216c6d0fbb3bd8d3d156949b8c4bbef6a959c5727880fb15f07b6dcf77b6e56706c9f058c3af6d3b81571bda76fbc341a3a9af2fd261522329dc5dd66a0c0110bba3a42686755c911dd05a3ed081c7b60144d88f0b3ac26f3b790967c8c6c716ebb352641b0a6416c070faccb3fe7747fafdeebf8876f08d9e442e8a8623a19a03fd09684a415d6b263b82d9f61f6072dd83b1a455f5cbfee9533c6ef59597388877e3a7727dcbca73e4d27b90d4512321a7760b5d4631d387b9aca4d532060fdbc496bc4cb48365922b0575bb887fa01fa28549cdb6ee288f307030e47e03e1cf743ec5546482a59ecad8fa98464473663e59ec3cb21ecbeab88d9762da37185726fecc020ded16e454d827455b3a40150dc49ee48a603e74a1b844f5f443e4a67b35c19bff23a83269a31536ad715fa70f7d28376fadd045c1df2e6cbe2df2236b3171c251a2cd666f9f4149d4b15faa92f669b645ff3b0a40afa37b7936985c4760911c45d0191c55597cd9ab886109db7341e9673ccba18a4ce09543e7aef566eec679b439c99a4bf6a330e053bca6cd3da1e8ccc39cf7573ed13b68aa5a644305dd5d8ef19c0440d067530cdf4274066c9fca5e30dd438c554625804b5801f5ad288bf6c7f8be069939a6eec078a31e3bc803d3c6c6c3eb6bca5f454a196fc8fd410202685863e919fdc5788d1e187eabda6dc9330c80f3067fcc23b455c481906f55f0e975bd3a0f710655e3725fc4e85e3bfd85416766509945ca678e33d5e0c5307f6c7abc714b0b2cc90826f08baa26cb61c6839b86043179c608b6050b0d9414d1afe0acbae000efe66cd50c8fb0a0f5b7d7e8741c0f026d57b6abe7b2cc92090dd9b87ef27cab783ef9a39e1fad00d92c67c853251338f857cc8a2b4c9dc5906d141615b0a14d5ed57b671b31f84de70621c1f862930252fdfa87cf6454168f425b4123208fc887b5df6c84982717c8b3d13bbb2ca52ecc2c373495bf5d011d16e91ea7d0bf7bba8800e633c1ea75fd1dfcc3878fb91db07219adc1db435d1844cc13a6d0b97cc16a279d07cd882f4e8dbfddb8845c5a65d65866dceaf07ca391ce0022b4385c67c6c04bf53973ce254f2b8ba9a96ebbe9ceb7a27c13e8430e6fdcee795766b07654e6696c741f0dedad66a523f4bb31f1eb4faff6cfcee8655e3286c74e236cb9e70cc379ec3676fbe1727c01e64d9add3fbe272a11efffa3a60598800ac584f4df173be257a465b456c52662470979b19cde487c10c991f4b5652200ca3b88364c4c1cf23a95d0ec537f2f8f8c539b6af5533eafc016c112d7e853966edbdc5d78c6d774028410c70ba1158a739bad260e642af5abf531c83ae1e3a1aa9525c58cab3f28ea638efa2cb1c5dde14d797ef9dfb18ab6a7d1d7b23aba652d9257ed93c40a284b39f7e822c087c2b96090c09acef0174dc0bffe1141c7b369256b31e4147052a74c8f00dadfe9693a0cdbb386e1668776691bae56d990ff57c48980f7f1d5178b187a1dd01417cf854a68b3c017cfffd943eca01ab62a370469f2edc80c9737e1922786aecd764aa32bfc7c6a92f36ab9b091b452d8de643b061c29d9cadec9578f82d2dd7ba28ba12aeb15a0cd23cdc2756ba916ac89a0e6bb1a3236a0543f304d14f14e0cb9f76741c40b904639a645fe87785ba131f6a677a277fab47e1fd167699bd22db5502e3a359b800c91ea7c52323f45853c19e88cf78752bcc6f8ae84b2772d369a53cb297ed68de681c5239857bd81638f91ec8c2ac19dfb006ed14d08f97b96bdb15626ded284242c3430346dad5b4219cef672c23c632ba7cf3755a67b80b6845c23772e0e5cbd92c49e65752eef6f0b1e12dcaeaa8d191a6f5f19006ab770e156a58d074e765310528996f675732db1a7207994ce3f593b06ea9cb7ff085238f19556788a3cad8b5919f76d928f167e668b4d071e04e7c645f98e59866423423812ebfab1d3020407947a0121ce1f5930f0591fcb794ebc9d9f685754eebc0e735fd1d737a0a8f653ef1afc0d2bde272e4d1bf2fcb53fe4c92ed8757532b2445a37ea2dc28e3d9c27d741389f75c0c3475fc86c79483a63eb49fee7a42560c2dceb81d44537293e1724823052d4388fbab654075595a5b8d2abf479400ab19b8f6a1466eed999ecbccd1e1f62c3a788f51deb80657423218ddae4bbf38faaa968737bb4a36587bdfb3692d479aecc39dd3eea81429dd5a23c4fdbe8bf181a0e0cdff55652704ed5767aa0acfa7739819d083295a1e30684f09b83f969e1c2e8be4fbd94f5e0d4c9bdd5e88a785cdaef1f3d3f66a8186b7dba9e6f63b62885305e1ac68d25958de6b073bc2bb04b619a8953950a5cfe9a7df33d640f646ec4a2489fb8d880109cff6b9e0290762a0ce012eabc81bd33075c0f0426dc7f424bfb2fb920f642646af49dff8fe6c0c3299efd962c9a0f20f27d33d9503c881a6315ce8d29db97e5fa1024e8aa4cc486f6112de5840853e09864625d863dc8682888c3db9cbbdf8c3afd778346ff324dbf9e34c8bed7e95ecea309cf23cc7830ed2a87795d556c638be358a7ba0835eef356b41fd2db1a426021fd82d34080e004f71456b9eddb186153f6073923ce14e766e4ca00194f65e39f6fd517c8e2da9175b44a89a866f81a893b6a579604c28c876916f05500098f0972927687836c204e12598777beb2bfb3cc15cf1e6a4a22d0b93519b0d553e52b1e4b52656223715664aacf645b9974d08dc1c7bc4101b8172d45345bc1cbda7a0b4c30cbf65833d6126ed297822149729c87aa91ab5936d6558575c5ffa20e9bad697466f1d84539c9f42a2f96a2bebc92e25936ddd93d4bb8cd455ddfb81b6f46639bffcf5c769289c898e7a9d5ff69deb0ebd6b2899f89aa542238a06f7560e2be2d615fa7723f58c075c8290f9aaf4862f1fa4908ffa9d4a2eb45f59fd931841e6f18d549a50591fb9334bf79d58c7deb8174de6646ce027289e1f8b845af84dbadb8fa60eb87ae42302929175d48de5e40d465e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
