<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"efa24f1c5efa183849293874443e0d30a731c845cdd328bb1be87b844ee3ba24d6c5e0191706c26b02450422405afdd7451722c3e25cf754245276a71c7f607a29038143e93e1779bd4a7908a924ff218a82ceb6f0605bf23f96cdf4987b6bbe172d4befbee145668e2a4c9324e4d01eaca0e4c1e3210d232ab13724fabac292f571d5f7532ff945fba9ad0b028b5e9e6145cbbac53ff75ea5636b0933810b17716773e61502ec589a4a5870b691cdfa9b4a5eb894b1a49cdc6b3f17ff4e318598eeba2eb774e0c9f6960109b10b14016ae3d8981b6870a3c0b5f4db77fa75b86421fc817d459df7bb6a2847e1fe367a9fd362b8c249d5cd21d0cb4553978f698f1253b65818b8ff55bf7333d0413ce7871f54a1f08b57ca04b0af46db346951585c29f88deed3ad7865a508cdd423fee9eacdaa0b9f8cd0f82d71c5ab2358e48dabf0f89d16b1312c47e9e72450b5171a3546f597a52e17267d10cee4f1246d1bbef2148591f8283143e8ef9d31608cc9ab0e1f61737836b23e13dac732af00da7972c96af00a62cb23759c82db2fd37ea8d405a1bd9089052ac6fcea924a253e5e4f53d92163407b554e794467b0fcee8ed1edcb725475f18dd8e519ff8651975a1cf144db8240d8be8e719e11d6d2107657e3831c5f82b08270da8f78bef06db8c56572d75e0c0fd8fe708ca831dd685e483f1182a6b3321c4de489a51bd70bc27615e3ecf68cf5accc925696f4af05ad1b6b7799daf51fa0a6d1df294fb56eaf980279846a4ef7a073778bc2e5894d812cf93944b489478f6349d3c6e39a7a46c3bd298bd5f77d591d13d3519ad611fd5a5a70acdc0dde1b9f1545eab089a20ccfa3ec4170299da552893322dce7eebf23fdb424399aac06394ba132680a8380b022c4a751fcc0c779c4ea976c711c2fbd3e46219401945b1941175d45df4d65d857450e7f396ec2f4df35e4a6af1be4af149e5eb3226c1e53c59436fe80bce4f00d65fd350c578a9c2c112906d92b05072b47a4f86cddb81988b756894a936de0f25e2a4934d688e0c7907a4dcd5d1559a5e9b906d6a772d20fe5dd50badbffcb63cd0a5c3d3f17ed0419e5f2a695d60c54168cac39ee908782c8cfd3231152064c0f94e1acd7644b9270754976ac50082b9fb63a0149705faed817f14fb403f17ee2ee8e79bd5385c7384da7ab8823fabc8b4abb7680096444b325d8cb49c548b63881e472449a3573cd1128812ad21af34af5b491b8d2e83cab6b6c7251f92f735fb3f70e423ef9f402ffbfdf360289396677ff7578fb1e3e3867faf8d9403318809d477c74ea054474936fe6801c21f085aa03ae5b69390026aba870e111814b8eac337b03bf8f311206b6430bfe2778a0b4da7be95eb703396669ea6caee9ec49bc1159cb6f1e573726e68eb64f6ef9abffe863c9ed960b6e85b86aa77503d072624e2249b8101db2aaa95fcb3af73f20f4e1604d52ee7175a7e8167621c51b3d54d57bf909b91ba43cb8af24005623ad8f20a4d7f5efdb8e258ebd734ff64d88bd582199155afd9afd08e4d30194e6f5255fd1666852353f47503add265c01adad6bea1d1a35c41986a01ae48399099692722e320777a5674057a7988983bda88237a2a2a3a52648e319f4d64989cab8d2c04fdb334688e5a5b1d224488005bc3eca9df0c7f16ff889f164dff98b4b5d41e3995c0e970a2f02ad5d3a3976021ba7a8455b88d88d8dbee6d18f37c802b54743a6d8e91fa0ac39bd05f2aca0e335553922f2b4de90d591661559714e053c1646213df123a2b107ad837fb8e9e644c10ae1a1852cac5860d2353b0f195ea9e7d94efb30ac32f9e844d6b36b21f3b37c6da10d45320a864a98c6b131cfc78534c27fa8c6f427ba396bd8372cb95cb6c29f4ffb9f9fe0d7682f2e3eb05f016fdffc551a368bcc3e9948b6b4ec6fd79af20e2b169f7194d44b2e889567d4e0368b3ed64e55fd19607e61715158e1a882cc5a1c7dc24da05b07b2eb4ec3fca1fe46abe3f312be1fca3d8c3bdeeab248ade9f0006b1f07a02f66348ee103da6978bea86c4ea24aea4dffc157032e6f33ad00dcdf4509b5b766f2e9893727fb79f49633e882bf320af2e02025f90d156f707b6fb40466284e68dc7516a5a61eba12093d9781f5d874388d294b9085e27a695b09ba6e3494c045a3fe63475ab1030b093bde117afcb7a5b8e97fdc5ec9d0215cd7e7c948afd9743d3c6f0e4471bacbd120d9e0915c3acb787509823bbaddb02efc5e07d07acde899a399a04005c8f0eeaea3c71c6987b622fa105a8802a4bd98c358dee79475308fe243f4fdf8aebe4ece991fee055e8c337fc8a01c63b616119984ca7b214063490edd5eefabb2338fbee2a6cbf52d6e024b8645ab4356bfb4dc4498266625ccbae1da7030e16b1fbba2543d086325eae1ce448d4a2f529f87b3ddc2c55c10eaaaaa636a4974fbb24265b1b8185d036788d463da398b9d236c3fa3c13887b8c52ece6f3ed1b7a4a183d3c52615132312e6d1634b1d474040a9fd2bd29bff8ca31eebeec3c1b126bae8592e49230a5bede75430a97b510749e7fb3603b099c7ee29180806048c44118ed490e15d68f056e845acc88d263e9974dae17b5a93b684682b57661886310875a4e96e457851d1ff70738bb18bc2c21e29d2cb286f18f29e90b4d5a4f2f701517497241c05f29d2154c91f13be7845890729eb02df0dac393c02761862b56b3584e92e29681b9318e886ab304da4c013eecb31e1b682605e6f3a726c50846cd951657d5bba436d78718e6d571160058b65d12c81f2e27b7e9f3c607b56980e2a7a12d7846186e0da1869e173467c44a843bb111a8ae12915144dd47c610ca468054ca53799cbe3c39bd8e3ce147f8db7b876b62b531eb272436931bbdd544898ff2f62b9059f78279d439aff00a32b23fb8ed68098346e17bd5a76a0f5c411175df9271ecb1d6b79d7da2ba01b824f583d7d0920146a1b951951dd45552dbad424e8117e37eaf642e9a5bd5709df17f7811541a1185bb7a7fafae3247877380fbd0a74e293e2b96f8646e528bf1694288c90c220ad19e0385f2125325c32715a08d8434fa86f073d6f0c92fd060bcf0c597837e459ed9d876ee2251bbeff831283d8ad008b9ab7722ea5ab8947a20b983de4650675e7a9a46ec6c64262a73f6337f7b96358999f31f3e9aaeaac4dba9577a4ac6ec009edb807e214f3e232c90f8e99988536ac4d3dd4652e44db4cb0a44efcf9f275fb93d5f2c412049f688faae3c6f31066709f1b351fd4f6adc715feb2c3ec8028b05a70a6c40e939e57a030ffc98c6c33a18ad7db65c5ac355bd23a7522fb74e4e4f98fd3d7832671af33826efd9f00e3cc2d354adc974f15fdc0ada94d9f3456e52aec5ecd6a02eeec59a8bf4b5023779c20902362ebff222070de9154f00ee3a43f53bc37a15a2db315053fd743a87cfc7c9da5b6fac52df38dfd2c05ffc75b4a50398c9ed5691a9f5fc4708e49370e7af12f1ebf4bc7e7b0087d1eeca2f2ccd41ba93896d3c4f55e8f789c5710441f74322fe0aa4340095532a2224c0c5d71ac2a61c67814e65567879ea4df84e992eadc54f1326f7294b060e47ed23681284bf8cfb999ae671f9eabe84341b61ee61578b90a6c3e76a5205fd99f6225da10f6b795a800e3c266e17401120dedc7e21cd0e32ccb4f4f032c778e10948e401565810fb08fe23e4cf86fc234117e522d4a50bc124e379ba25bc7ef5792bc7c0efef3a68961271ed61fbc5c33d2a988e1a6936f25f43955ffde21e7b0289f62489c646c7d7f30ce3c5b81e229eb57cb5c8d5e3ebbe1eb9bd2cb8285af9c54d3c3dbbef939f716c9a34d66efc8057fd0c47bef57e0999d12d980a85fb2ff87792d7059b9bf95b9c8263339117280540636f21796248280f56aa5e287a3516d089032d1730bfd6c4e1f8b4add6149156e76941347347c60ed92547cedc1d46753fad457aed7ebed10ac81c871b271a78f44166b176661f20111b338421fd00a923003d46bbbadd749a3745b8b0403eccc56691214f5ace310603e4a759580a7cccd78c365331f01beb143e0dce866f0dcb746d46746bf17165d0875bedbe0c37835a6eec4054735e8e626f9ecfe05a16c6bbd207047c97ea162067385fec5ce0736cfb393b4066a79a908b8368e76523b0fcbf122530903f341e577034dc3bd50ddbc5bc063fb1c42187b6c314c5f3a781aa3c820dafb123e01cd1c0fd8869e88834c6e31fa407c64f481c0208cd419ed3210c66076509694869812623ff74becc904b72bbee730bedac397605bd6f6f5db1828d324d9f2dc3370267f873b524a4d0b853cb02d9da76e13b30423ba6bf5da1ee8de72f55a2be3896fbdffc672b0957ff4323e304308acca71308acb640b5479c3136c95a50805d0bb7d9e28611bc5bdd007de352a9fdac419957122f04628b886972f7d5235ecc283b1b8a30d535ba39adf8a0c7841059343b010d1fb19f1da57266818f67de4d35bc60c453b83fb0fcbcad255ff684a3f60e19387bf6de919ee6709f65de3324098bb4ef7ddcffbb21a4e621380305eb2cadc92f0634f0f03501681dd363006224815c9434c13995447961be2fb0fe7f81ec01ab0da630fa682b47e34f4be00c187f11b07d87b574040f7f46790b6133adb222e079f9a29de965894cc0262d6ca8b47a1c65857f83b68c44b471994c0fdd3fa2754e9c46644d6ae68d1d20d22976847a49b259d4b92ea837887f6f327c75d07baeb0bfe3c49db2eb11b70e548687ad32b038d429392ce396bf08660921c4889f865156a874862d8738501112c7931826ae0b861617841309aeb31c4e17a30285e2a98fffafac7d38041f50e526bfe708dbdfdde1963ceb98c404d04ac28ddc56831318aef7a0857e8542890f772acef2e63261cab6bb703e1aa65baf9aed6ea7886d4c3b40104548035c5fbf2b03797e246f0bbb18471efea3e6969d223d3541b75531116bc25924a8647630288c8cc4c8e699ecf11e1e12cdf167e84548dc0acbb27f0abe7a850193589d20aff799187c85efc7d14a0fafbd6df730df3de6fa1ca1248e1f1069e6c81301f596ef6b372140b0985fd3ea264c91fb07a3c2676cc8274b205d6d9aa131b4b3e79afaafef76d09f2004ef1cbc701bffdc49f27c99c32b3b78bee2bdd725a4a71f114bb0c0b0aa15abfa6b28038893c1f6a1095595355dabe978d4c8a67e33fab0a2fd8cee99f280ff05acaa558ee95368bede2b469d781c5548fa55af78cd2239138625a7485281d4b2387983c8cec95837697094cb9c8d9685a54f86dbeb981b8f34411b6833f4fac627f1e648a9b086e0feb514b66588fdcb72f0683a0b63b097abeeedd3c89baaa4414fb4b67199fdce35fc8933f9636a55cbbbbfce9fb747f90da3875ca8d276e76a0f639921aa4e58fe04e9bf4761a2be3daaf7acffcfd56eea85e678b96c350d0b2812c1b5bc2fa1fb72df4a5fd6490dea14afe1afb04451b93512f841fba372bab35ae6c07430b7968646a0709d17cf5f1eac8386c43ef99743a0d7685f73d23afcd3488034e41dbaef347ad91368d98f56241579971e16d8d496a47db87b003cb0a4badd583dc2396508acfda224ccc7007e93933a5da80e31eb43e8d0cc795e7219b36c28188ee0785432c9881c4216084d3c5d9c9e38b5124a5e94f53963946fd015df713cc15ab3f19f039cc5d75b2a1f3f5e0afc46379a5c93195692e6be026f4c600d980918d6a669ad2141cb59e66be2d64f772b93a5ead0ea00a82b80398e4b2fc40e382ffe5ea2a1e8990451dce87506b6f3a5e60d50cabde7db9a2f524595a45123ac766a97c817dabbad43cd31f35aa4618e58901fc33f3a3894cad616d6d1bd0734b0e6766d6d53ae1c2e75879cb4b40ff8e22793d4390e1fc3e05aee12cdf0624687fdd849a46182833e9afcdb36243f8d1832f3ddfe2aaf1b976d27eff6b79c7337cdf302afabf5849d159fd0d636d45ec2294621b64c12b113398642d72151db0b4e530cca36a7022f2181be2203400a67c148fff6e4a0bde4e8f73dde6b9dcbf6fbe414b90265429cc9f9e7cdf6b2b13dec94677750bb1c047e211626a210617cfb3b53d5b9dac44bcab365f7081d3220e8b8104cf5a731ddd97b84a721d3585340a98dce1ee4bebdfb46f95d90cc3dd70a4bc6beb641b701b38d03f984e48b42d170e9157d0d062342d26d9d8842f03909236353d249b1dcc6785c2e1bf6518877d5e96cbea9c9e974777e9ec1a54c8fea9a13f7e15957975eaf1bfc509cd639324d1160b1dfda7ff3587d17dc6c5846f2f46da4db2f18a12bab9a45bcea6fa035067bba58d49ea3f71dd8bee1b950ef10aa3452497f5f64e1027be935401978c8df252ef1406ac37f71d11d97187623d2381882f0a0c898553065b5c1a2f28833a557c0317ea4d98228f49d7413a699fc0e477d71421392c2c6973714fc6e509a38e476d1bc1a7306e3e04b7f42c8abab31d7b39e887a3bdd3cdbfc20bbf9b344c44cceb54e3298fd62faf308162a67d36d5f43563474ec27bbfb3ccddd3a5248baa09ba20338f0e76c3dfa757bf8fae069641e36c4cda601e4c5e8a68a6a15bc35b585e7261ed9bedc0bac54138a130e83f251a981fd05293dea9fd81063af1db3ee4e18c30fbd96e003627d0a6fdd9003779d66394fd5f2315cc9346d97d6a49b573ce3f80096efab09c2660a26f1cc91c532124b1c57581dbb161f9ede63a3e9e7d29279a9769fc5b9d05e90ce6e433f7a820fa157ac9f96518b73d1dfcb6a324959fcea749bf36ffacb2c8389304d50ff8323d139b268b75d26d13692bd120db4d4070e33f8b8a01db7099294c6c2b99523d456c940369b264398a8284e8aae69b06c6064d4bd152f1f36e1d61396da124fa31bfe75c3b3abd53af81c74d9a308436df59837dc1f7332d23af5eaa9f322aa47f0cc39f3b540637be2942a20d277929e9ca7abd62abf973fa114ce853f7f59f17deb4ffad1897a4b1c185317a0312ed862cfddcce6e6abd333117f7bc158ad948bfef0a75b9fe3533bb47145bc7eab72671ff386442b6062f27eee5e86e961a02625b334d5bdfeb8ca22a21c487e5328ad2131fc0151408f54d6474cc1a684953c3f8d3b6288930f29025c010b52dec6b99bc8263255cef58d91e3188a2410001f95642e950952cc0f33d471ba353b8066daf4365c5fefd76744ab6632e9e0efbc7f425f63a57e48cf4cb2c07a5296b7bcee0dab0740e18b6f8f94b93e5a51b2466b13dc920312ef07126800700efe1864babbd85b8b246dd4283acda87160cbe6d686df0039968be15ace63eaeae41ead98ec318d09b2397cb76b4b96ee87a058ac2e9d4a754673948ceb8878291513c6f5bc7b9c910baee5a7c53404cf27b3c51fc292167fb84443db2acb4f0fca4ed7e33a4ba7a17f99706f98313aa159ecbf4863039219663e65c3d3a6c557ad5e23f9af56e3f25de90c93742cf686d6416a4cd3983fd9169ce1951ff22f8d6d9aa035e2e37aa6333c83c0e3be245f3e1a0eb8138b786b6d4f9ce5caf4ebbc61a61f64277253f8ed583abcedc725cd520a654d972d0cf66b40a71fda0bb354152b1a9a7b3f5a98e0576faff2e3a0f7c1d3d060c8c31b0e64940fbc307104fc60cbae2b7af0777a0ba3e44d2498c607b602d04ef9a030eeecd38dc9e9712a735c30b4a4b9caf69366fd8b1c21ea858ffc59aba48d2c608928837bb11066cac3339b483ae19c4eb558e14e52e5db08fcf2deda48bb093b5b4d629244c8cd41542935e44b85b50654de7f02894e3513c36d0b463a6f5e85c4ba9d8e6b1426b344749284135f102f8764d4a5786e70a8d32b7882701788de247b89d6c17a6bc564a01e8c24a24200d35eb28e5c7b3c6ebfad37d4ef2648dc60c7e41f0261bfadffffa2191bb46dcdd4396e0ea1282920267d930d1f5b3a7eea092b52ecaa8e339bdb2e03bbe30dbeefc7ba3ae28a0d66d690520e5e3c9ccfa4f1650e186eee824612817a3b3a45c9d2e427971c1fcae1da97234bac76dc86f56e72a3a83c48040194b1c1a46ee44086758c8d1722d1e8c8957e3613d499e2ac2028dbb2f848aa45d9627780f977aaad5621ed0bb327c302a68a1318931ac54e8bc8e9f3397cb3f4f97603e550f25c5d0b7a2ab467c025ef77c3e225f4584541a636fe00f2ebf2e6070be5bc2ebc9a8049eeedc99e86058319f8f4c13bb6d375e49036143e2809aaaf8f2c258457537757258335d20c8ee0ecff3caa01451a8d4c7fc9ed02c8f94808c2042ec6a8fb00d9c76d725cfd7f473341cbf90eb1ef93a6613aff62c9c43795aa7e7b3f968ced1e1bdb1ac7bc9b265fc9f4737f006bf899cbaf81b4ac8bc4bccdc1207a4c1c68a4a4f2981d539dae4822868ecb000a14d0f81230ec64ffa6709f681fdcf0ded8285a31e1c1b24e74afc3a41c6fc6c485103c3695b2722b1e2ce31c3f11d6b25381230b80c6bc13651cca1a408bb4bd40d96b274fad3da5c4411e73bcb1a856d3e94b5a453c0b56fe1d865264cac42db1a5ce0aca5c17ac58059b48b1fe6c87da7bac173f4c7d8e6a48bf522f7933e3ddaa9639229c5fb24586a7ff0a78d7965604c1d4ca60f547846ae800a2cc83f68848dd0f90abb9b9a7fe7a858cbd4217e82dfac9ed37f233bba5a35784dbab0d21124144b8b239ddeb9235f7d4637b613b49bb89866d30f7102e043ae6d3f95140d0175f6147b6fab7af77155aa0f6336f71ba64cfe5e9328e88573aecd903a41dfdea4a759b25d63741eff110d79a844672be5c35f94d45e49fb857801229bc95af87d09206e8def5ed46c519313de00a8c39e06f9b2914b2a6e6d91972c20ba1f1f56f39ee64f6e5ede418f84c890a8b3cf67c109c672ca6d7c26f4e3250c744a204e1f8296faa399126953f057e4fc835f2503a3026c6a386ddcc2e2daeaa890bf671ab786f8aff15e1f8c0a02c59bf5d9347505e9a57d5ab964f38308a7c882d678cd8365fae6f692e8af7032493579a191510f1e9898bc41c80f595e09257d32e45b42c7d290a75b855eb29e992bd5e8e930a75d75e1d9b8d7129af094852ef78f4c8e846a98ab4daef367850422a9fa55ec2472c78422ffaae6c7815d2b7d5bde9f5291b7ddb83e190b957be644a09a022f7ec8407ccbc71c6ee5228a236df8679075fdd218956033b15cdcaad6dafdc01c669ab20b937ca8466e9e1b698db9dff52761f3946d8b12a0005cc2cafc7cfde9835c87d0f2776311873b3c28d25ef4349c33acf405d21e13a7e8ef8f54fbd51d9845ffc1e5c8cab13fca8cf17b6db2006845b53dc7661e5541c8230a2bb0f4e52c466f1359d5bf70fffe681203a07e5e01785a4ecabb8dc82c6286527ed9be5f24ff0a409026f2509c98285c6f4253182085617704bfb62981c9195f6135ae473d3a208bee3fa82bed6ba9408c58c4a565e71c15b026b67d0ac998e4fca4ddb7a9089db237f7be4fbf07bf385996a1117ae195e258d815292225e41804ec2fd7ea147471c58e99716277e66bbfe07cda9a8c1e037d09d6cda6210ed8d5f5e4cd50b439cdd15c8eaa2ef667ff6b7409230f08ddd6da445383dd60a8773065e43704f3d3b7a8a83659b50bdba3fe79738c855e02a586c057679fe437521feb731bf197903e2b4bc27397d7d12215ccac5551d50206cf08670eaf2d1da48c934c6545ebbae8072f7d8e2a4daa30d53a4ae9b409f036b6d4322b81e55a7aab5429963ca75de89f3b02520b44e3ad2e5ac29d20e7e8b69ce2db7c89000b910cbe98d3d5148ce6ee84adad282568bc274bab85ff5a2f0437c1754f3890f8d5261e2d4a94c3d8db7089903d8cc48d96322af4d81756df1925cd4757d141b8a7c3cf164e4b90fe5a569d48c7056dec93235f816a15742922777f67159e6e298a6d579995e64d64adfbb1dc6e046f25d5210038357bb67ddbc123060a058ff48193f2473689185f7ef2db553ffaa718ff78be185a40a5b6d1fe926187fb4a6a4abfee8cd84137d7c38501d3d5823dc1d0b1bf1d5613287579d065c22c6d66a19bac84632296a1ba545ed623eff3f2542869c84efe5b1afa760b330f699b758cbe3368a7ccf4c4e1ac6af37dc70878d45588d95bca75fb0c14a361cc1610295ac627b38434211fc264081eb2d56cbdfa306382e3d15d72e8a9aaa9f6ebbc2716fe2014bdecf30ef60f8697124c2b29b7227574ca0205f6673027beda7a6293b581978cdf1c773da4fb25ad5185531a818306cfd7abae9cf372b79a1b5909fa14ce8695ca2f85e2939079b95147ebb9f12df1da8b678d34d790d6f28f34ba68431def1bc79fbbe89ff72591ebad9d57362ab1160c3739056b202fffdf54d9b60e37a099d5b5c6f26e87d099b7343720437cb67334b6a2dc6bfe69e63600823c8852a1e19364443cbcd89aaa39aa0f2f465c2c8ec9ec747577577de8c8cf64c4ea4d0e821ca86acd3460c60360883ee6dd092f7e915f9404e3ab8d1fd40c7b67f12de437c25ded369f70c27c8f7f032efd03ada7546dceba03b8ad7c6fab23f7e2e83edf759079174bf04bcbae5aaff166f3dd6a01f7159df1a25272e197122a944a36dc31f8eb86bc0d0a4b5349ce55262744f44a429c90b35d21a880c382028db77fea34b7752ebe34c61ce384a6d0dd270077a587c7bcea8b8ff9f5137d08d4c94c072381e797285032968a46d42c922b33273414c8866d08b96dcc13103471b2c523a267197a3e8258c0b607d6f7885982ca046f3b065897d6020230c230ff29e587d46b07154f8530c3094d70362d634fa12cf2bf5a5ebf15650ba2e48a1809486987c726ede4b96fb8a86cd1a9532232db608cfae302b647ea7d5c9f2172a572b56072c2864ccbdd7023bcf6e2330e5cef7faa02b2bc3b8785cb2e54f43bc59d8f91311668b326ddd6363f61550dd82619cd7b6c13bd1f11d26396878f0c0153aa17eecd12a4921a359e8fde2fc6b7b31cd84d90c951416a71866f31456ab4d56db04d1696e0e052e3dd0c09efc8be0682811710ee74e8faf5d2b323711819b15fe7ed2ab126f341ba72c4fcdd1b6b901abb499c7d66e4ba7ec7230251d509245d078d4dde5c9d13e0541226101da9b0bae73641d44a497e34564dd9ec6e11843c9cd4d0856d2b7bcdd7ccc0eef5d39ddb56146ba2bec3f3024314e8164ecf054830c03f7047424bc283b5a0151a8b4ee64a307e669dbc577338fdf2cd112401ee2e4367c767a61230d4ec07b97d01186bfac4d8720588eefa144e1f89d5f982170c95e164db9bc059340840bbc42f590b78b2039bd3ed936c9e12c10f90b42190d462262800d90c8b05fc86ab8d1f5d77f79fc3c220011e3027bc788d1d3d6a78256ae77f461e975eb2e9a4fa1d492d79bae24fbec24c6be482205d83dd3a1b45f28572862bdec5a9f860618e83b091eb06393724dd55c0898379a8c3abc5eb82a1d7f29721bbc05032db4a17586ecf89e195857c26b803d3bbde713e69509d1e70867667013b50bfddc6cb444782c00b063bee31e0c5dccf846d75d533115fbae6938ddcf0e6ea0aed0c8680ccee167e5887e03a991a41acd0d93751c0c49353fbc40ce997cea78b8737c3a0ec4ba9d62108570e07a10d56dfb60a05467122577e1ceeb47459cb1a98e5bcae513e34d8252d6da3b85f5aa0132e4db1dc058115754441517708d482c95ac3974b928b82db6f8ded11813291d962129bf2a5529f78118f6c07141bdbf870cc7b94514b7a499a2748ffd54048c3df8d8a515b39cb577565cbca56725fe76846eb79ede7d6f46e74ea9f85ca0d7604392bdc70eea57d367de888b64f0a9d051dacbf57703858b9ad7a9cf3829670318ae9ffab0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
