<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"481043778b1905635abc09078a3f626f2e04547e738d4817f90db05acc8b7579e425b649c3162d53f53e4c60b52f2d2b14f06f0a6bd44bd6935ad93f368a9ec6d1d08a064c055303cacba52ed4aa5d635ebf846c422fe33aa54582d1cc129193594e73a0d9c42a55fd9c8d6bbe3127fced4957ab62d26642aa971b579f46f22744904050b33ad1a09498ba5b99335849445dbb84992aefa16b6069048e6376862520f772c6d86307921e2aab0d1b75e15a330c4b17a13564dcb2d294a4390df6156ee6abb33c6b3a233faf9071ace6e92614c530a831aaa49ef03e8b597a7e4b8d35c4305005d91284a8f3b0e244e3c39dcb7bf36d1a3960f0d2ee0d8ddc44c7d134380d3260b8e47b33a2c45c676c0352c30da877991bba6e630a59c0a01b194873b1e3cf7d1b8304dd4eebdd15514f7b052c9404405c5d7b599083bf10a1ad56c30e926990b860b09d880250dc906594349536a3adb4b8e2e3bd077cc2cadcb350818204f8d63a4f011388b3760da57c67d57adf4e421b80c8724ce55c8ab255955e950818baafea12cedf422699c77323400bdd7798877949fa5a3ad05b021a74cd3890ae1331d935fed9d1e112bab2fe824be8e6587ec9cf4ee2a115eb1d40ab0936e74864ef4907d150dd1309dda503abf4925fe40e93dfb22df9b72a3119592af36b47344e4969363a3a5963601b84cf7a898dccb41c6cb58962a32dbed52cbbd6ff469450eceb0ad94fc1d4a90fad9331affd52ea9606b0677ac8e3c94c5c6e8b7d34b641624c747a4a5b4b214d42ef7f72c55b6f1e74a24bd4ab3ea566088d2dffdbcfcb950d10863aff4bcefede0ccc42f1b45bb3b736a9752ea2ccc70bc5b1281e890ce2cf9977121cf0bf37526b06e18fc5be933e1570304e5abff90193347284ad7543dfea50f50d5d7167fca9f64ad0b31ffec1f6160e096597470f43cba99209d1f48f98623ac8fa1345f31af83efef9752ca66a6f29cb82811abbd92da1c4f8c768bea7e6df0c27988993ad86e64b45b4f7a4a2b79711f75d83075a0a4052e8fcaec0baa67e77d2988ac571cf60e1acc14054a4eaf11948089eaf639df6768c5ef21b8340bd67f5be1ab779588deb27afde7d24d93dc61ab7a6d51a1c6853222a2a09e2dc2ec315eb3471464e6257d1f1701e6ca2692b2dedbede44fa4659493f4705615144998392b97fb691ae0683c52ea2a4734470553a46e4eab5cce026c2bccc258107ed16a33cdb5dfd64b9c1f1ccdffc331c9385f23e3e85b5d9fc2c3a9497565eb1339bc44e28a80536704a37854f9e44e29df5fbf896949a2c2e3cf0250a2483a0266600956373fba294a05b0d52bccfb01e9a7d2862dc2ebfa9dedf99efd2b6a9c5f2732e107b4d44cf8ed042243436d9065e19289858526ba13e639a049114725493d01608c563b66a7d3c08615371270457bd6b0269503d0262af293be86aee38a941cb76dd55a87c4fd39c83016290aa62d5b711545e3406bce4356f0ce7bfb00d3f33464da89f1d3450c97a7832932e30cbd3b2e9509cfdc1c03d271a819fff867bdc75540ffdb9b3f4dd4bf484d7966fb9030ea4b3ae2e57e65cd88d35879096fc8541e3ea73b317f98db79208e73971e1940ad56835d014c21b6a7cd4601e8f95b423cddf21023faa105d54d03e6f487cb70fb0fda3546f7843fa0a786c554f092b947655b659e397c9f9817bb4f633a752695f6380efc90d4e20abb81458f82fbb0a3016a08e02bedceacda4b43261000b90f1583099de6104dbdeffefa7c84e5fca59757ca2533192cea0715773f22d8cc7cc40ecf997eba21c0477b741ea98dcaba3a1b48d39a71721e3869e57357ae1d9bdb1c3023ca60807d3523476823f002d2cdf1e850711a6f139d1ef7aa80292d645e287c6832ca8a14ed899c00df207ede10356be5f7dfa1edb1b242b44f4a85687ea4284d8855402319a82329a2f183599a0c501cddb0558ec007342b76fc432a3553673ae9086c0a9bbe2503f4df92162ce9e8992e9192cc73f525a8b681a8de6e78fa8c42fb98309e2e319f9b87c7d62e6a92b635832f31a0867df04fa12580d67dd73e94df5561c196416f1ba8a1455d34712912b01b6b0eeb0827cd9920c60608e1d8906676a396e0ecd39f2ba823dcdf0177b49adcdb01313441f4e4c58435669faffa256cf757c9dcd378764e76fd905b020db936c17ba3bf3a7586844ff44f3fe0418fa7e56b2fa1018d35610a9d4e9f5daa6dd880ec3d7404d3189106ee23caf7141c41dc93576fe141ac5cce23690177c4259a13f1e9a61566748e20d5706eb7df7f05da9ffbf676dde231c5a66ae4af55c52b853833506b71ce9741194d45d841ab9efbf5cbcec8456a7480ee611aca69056e7c4bc3ce73f196ac2f222d5a4b429a6df5099e0a59d1b1eda6247c169acf28e796fabaa6546ca8f1df0517c6f03d037ff75f674d92912c5134ba000ab6c1dc42af56b333ce2a9eba1690574be185142814f9506fc8fc16d24c5ba5e3a9e245aa9e77dfa5ffc19efcf86019700c54c732d999da729bacf914c72044a0b8c77d66951355015627da8b76566571aa22b16c136f9366f5f6ad988e537073371f569704140c0a727d6f5c8ebfc1670e96f5b338608653a15d275f90d52d3e26e0efb7a1fdd377f7107e02b24dbe43428b611301717af7e5ca28e31f36a03fb3383c1816386d34459dd25f3071cc248ab4c7e5e062a33e84d951d99d14f377a78ad22ab7265f1b80100fcde343d7c5f9d697616e32c9d8b1351c994af1efaabbb18644e4788baba4440448bf6f4d961d9be8278605b316317c69062756bd3e6b016288d4133abe909ecfe3f38324922622074becc95d1cfc0310018ec8bb85235fc320ec513ae75e9ef3c1b1de6618d631ed0ebd39b43e76e55c8cd3e54e0395087caeccb1f8c2032fd9e991bd1c9bd4bf4cc5d9409d1e7762931e43459a49734dc785fb2b978615a0912a55420c394708dfe9734af64c34d1b2c38efc6d0baf341d47148d1e4dc6d39fc6b922175b140a068867fc4b51c3bc0c509c530b34604e9f882bf53a41585530caa5e70f112e8cc1f244b73fdf3c98d11a1a9d9860b8e830ba07431bc8f9b0bfe87a25c0eb3a2a00535497047e47507994d66bfc9e82e8889a8d4a60e02bcb77e38c36b5892ad5a7932bc9b6959decd7a99d5125fb8e59c10ba6f47651379ddf3cfbebac350b8bbc2f2f7c732c9dd1448a187016b43bd5b159abbd561636910f187f5384bbeb3706aa8ba204e0eca94d9ec69ee5d4c8fa284b888ea401dc7f193912d87c1aed24f8e4e1da78602dda097ce7b6e63480cdc14b8f9ee2ccc1022ae617f3ee715d75ca1215832296cc1fe9ce9a94679175079138ba10f2d239eca440787bd9a802638c82d97b01c102b63ad50e118871d79179f4d5187700862fc8a322aa7880a6a86bcf2d13116671036825daed8306481ef01e3f540d9ab2c48ca764b799dc9849b86abca4709a951c9ebcb9d9d847e9d5cf030f1adafa78102f688eb1221eb075faff2481eff76fabf474cc76da568cb87af37b66e2e2e3919249d5bf24ab4a5f46887aff7828da73e33ecbaf4868b42f4ffd866e3efb37745644949bd4050ae0e7ea2fbea0760373b4b4226baa2c21e99f8135f5d8305ed3cc10fe24bbd68a6149c48f2aa8270c8e12fa2ae88825f5662b62997d8b9a8cb662efbc5b4f5578bbe9323fb3944cb928a8638d8985af30382b9735e8a9fa62a41437de1bea53a873b4a30a4ca59117308fee39df514e72f5ace4841f2262d85824c36dfe583c8e21b6d576df92de3643aa0bc1925cf5f6a7706cfdfd17dfdcfdabb22a95a8945fab4df638c2de5dcb504d6c09a812f24a1a74ad61c44ce72e144cb41fa296013426f71e3bda402bbc9db121ccc50d518a6db421b784594ca278c5879dda664534f316b1ed1e94865bfc69420c35635d7383835d4a6b520c7f56edf64f8ebc4a1f52888d7fc83aa86ee3eb537a18b2582ac7728bc925eba59820410014bac3bb3b822e6820e3ba208583dbb42b671224c40d83013652479b4714808a7790426b55dc987122b0094b6dda7c217640d5082525b548f18428055ccd04071c91c0d1232a196a971f18470c39a320ebc76294eca1418527abfe1dcc90b6777b53ebf81c58a42f0ceeab20dcc74e358b4e66c1496c82ba9e3a9013d89e6c9202d8b5a42e6b92ac9ebdfbdef13b6a5a672b02e250148ddae8393d85f4b3baf57af7fd19dbb33b8541dcf4e39d2c21c62a1c97747fc8a9ed9f1e67daaedd71277db7129eaafdb4f6614735b3f4a1bf7bbee81cc76ae628f83ae11df2c54473c307e59eceef52814144cbf2aaac9593560d480773fc9dafe049b7ff3b7267b8d546fc0f14e3098110b48cd02338691fbbfda94db18f090944123745f015318a73655462fa04c0819fd0a16dcfd32214014066f7c0df7fc337d72654115959a28d66dabe6f189b7d5bc1ee74038d4077e8bb714c9cd2a86996a8fb409a83fb2dd650193dd9a34f896f726a7bba0885a5d60942f2606b5d071c8338783568e08ed90e9ddab432c233ae10dfd0588c9d1d78c6cad53272ff8177f87ae3a322c06e7f9aff71668d9e600be2797da823df47b9586971ddca9363deb67ae31fb6271a8177766cd426bd98c687fe7fa5caecc5129b713d0a4c489e986c3a1bbf2a0beb828df91fcb3727034e7eca0ac9ecb40731507b7128279a3bbb1f04198a7c10269ffdf44bf1ebe7639de57062aff6d9d0e6d49c50b9dbab92c2bbafc2872e91422c98939c1364dce1383c475a2296b4dcc58fb0f9beae881b78d822267fbb526b2cd3dc383df3510e5e73627400b881cf61fd0601e644b980591e6d2f44ae91923793cad01e5050b3f903913aefde7ee86f55334e9d23a61e39553b921e701bd503f62db93399e3a3fd1688edc3d9cca9127345ebdb616b4327d737955f7dbd1fe9ff9a04497372f388c54ef71d78cdc63c73a57c3b9604c837dd8277c61dd1c57b2642d8251efff7ce8143ec55df43601e992b79f537a8819083bd83f8ff45498353567dd1d288a918ce8a640c3a1a8624a667e5f92ded1bb81c36ed5c4d91352cbfe65369ca2dab1eb5379c341e03053c7a9d2ffc7207fcc62e14ce11ee816a47c8e745fb2c9608479d39304baeefe2484e22d28b1448c339ada45e313f2f7ad58ba3ac49f621695ade0bd9ce8e74dd83ac2ee3272baa4cd5d4db202e3b7bcf004c03aacc0da2ebff689fdf0b9c09ef6df120dfa9a9dd6135e0d424c7c4a8f30f8dea14f3d151b72f5bebbb0f461e49edb3ac3f9624110f9676474ca468a02e757ee085f624f858a874c9eb11996cc9b1a96ab9856ad28b1a15432683b789033e4a3d9f4ce9dedab83b8cebcc8bb293c6da254fcc42c94415f2cf868608da2c657bfe3127ee00a3f001c217587b24c9b0448bd50eb97c9370e58052ab9ac50247d5382732c3b75990a0869b4053bb69199bc174b321d2b112cd7bf90c46fad0fe94b4ede0648a2670ddb84259f19fb3e0b581abbc5091470bb5e954ff998e524599f7b714fce805f3945f68c12f874bb9a9b30b05f77b8e793435811b15c8a0a44880553d3551e459e411b17fe795072b1a23679e9ad78d943887c847cbd6605c56aa7a558903a4d02b5374124d05c738899e47b2fea2d06a74ae5d8c3ec5cfe84f0ac5716a4d29e44e775acaa4c7c6e454f61f207e4dfd39c310b13f49c63b0538e94197f30b84a2892e4447aac96cad64f414dfb81bdd94c6927015d33e210abeb046dbe071172acfe70415a11b4185bcf60247a8d90f2b44dd82bc9dc088cde7c226f73b78648a33cb580c939307782d329eff778910065dcb47c2176dbdc1039a4ab6122428a783abfd2f32a1d28f3bde563bfac760735a1557a822a0bed76a9e931a7f0c0efd01365cbdb0ef711b2709b9a9139e5b7bb75fad52db4cc803428c9b86727c78afcd3f35a6a868eea54f4e5d2c935a4df6d9f331466c6d5b7c4a22eb438223e6538ca570707877c79e2b1795e8e11c25c007e96934d995d097e7e15ef10398eebb7f20136514a45e6bbcfa8afb2b1ac2cb6faa79d417c54167e0a8a46bb5abe0d3b50af28c68d1689bb09d38b68cb52494f26d567113999d8f0858a3b3c60b23a6bceb801c53248d32c6c0062f8f07c55386776d4a768abc284c6c5aca1d92a192ca07846668da2095433995eac5120cb5b8b3f18efb3868484396c4e9b9aab81b3c7b23e0b3c51fd376b16d0e70aaec96f37ff0b742bb251feff3bc9673e996739051d36d228bbb8757f54b1ff597de57a5115df354a0b91d3d2525f2852031deb13ee270078660f34f4358527d9c00abb3c0d6820fcf8373d7ddde4cdebf1342616d3b6202d37a47a6224be423574a547f5f0b3c8c98a759bfd393e7ee1ecd8ae12aa981701c7143c31e92c6ce74a559c28b91fed708a9363ce672cc84e0e7e4cd618a9aaf510a4e36ea902af69f4bbb840e81f5c0b442febe4068da8f76c10d45f6b1730eba1ba3c39d8e8558088be7a9af6ce13fa8b4d56da007dfcf40f7c4888c1e283f7d4af70952521991047cf09b586b56762448e645de7956815fe75e31a28bd14da2404556469d8cf597ae057d21e7bffe66e7a737eb04e9f67e8b2097ac888758dba49baff6a95d2856084d63eec534c7f7b5fa5851c9235751a383615e245d929c55c632eade5406dc55b9a343cb3ec0882a76c44d0ea043fbb63fd58647d00eb14ba98cea04406fde9ea5b999396bb5c46012edcc311a49273c7afe3b925fbcc6231694c8be751caffe1cc6c64e707633202eb7f2e223e8e4ee27e90de677e23146b2d97fe05510d467f967082d295813d3bc16492b2aac15cfd27b972203c9b8f115d44234b6496506dbe3a839527d4c14ad5f55ac43cac7a95d375af55dd9328bf018357ef3377a973530aad5f647b9411b7ba0ca299dd725b8f9d53fe9d03cfbc67c10fbf03f90b5215902a1599975e9d9d6681e6dfbe8f89b93c80bf95935ce770ee3f47a4babd53aa146e1dbcd171dc9143364a0bc611f856e1b643b1c075954a53832d9768fdfbf14e3a97c2f5341c35f4fd2a8030ab16df6665cb6de4aa03766744b3a66b689b7cd6070271cd53be836baa6fc03318d00ffadf77514749469e526e65bb547af457f95613436f189db07285995697b398c82fc2266d64176a9e0314ce8409846ebd3ca52cfd3655ffc61f6b83a2c711ec5d6ca67f38769e3a2376bfd4b57a2803f7f96ddc2e5c01a61d6f92b027ef2c578094dd03f20659ab9c3e2ea459884cf5264c46e91c648a82c292a28ce398c58928e1e6bdd6fc2d36b87ad9abcec2e20598d9a05a40bb7147dd8b84e580a582c50dcd795330f0e52d0c7adeb31d7d706224e048eb9c981b37376f56757e1a8ab41ef2fdc367adbc1ddfbf6cffa9a7c1da0864ac22c8daff83b3644849447ce51b10e90bfb9a6bdcd05bab3249b3d2daaaada50bb5b6f4938c08df1b92a2f6fae3a15c2bed35733b2720c208db1486f5f8804f653b984bb7c4781c064a3703109973aa6dbcb4228c310d502b8c3c8217f1a974ca2568d8a3c4823d29cab69f1535051fac865afb9820ff9340a0c9b76cd22dcd2076c956ae8850e81f724a53bcacad8d5ea5c33b893de8f6e2f2a2cd3d9aaff0bfd4eb7e00a7e972627db36409e8e7a67df6015d6be938e0b56b04a36875e5127525708e53256aba11174619b51332b5595d911bfa3f34f50e296d57138542ab3552b714364e5f67f6764f85271cd3fee515db515d60190b7f1e85114b82fef0af27afc85017cb4aad41b305a458f2477735af53ec1fbef8ac5fda0bd5b0e1a94edf6e9fe4b8e0ca8aea962e8c12e78a69602d5560c1c97663235545a010da564e9e1889cc73bade21ca0274aa8e9a4b7486c1b10c38ed3ee52785e6ae64abe8d586b88be3c0a2ffefeea014666de1f22f76410c4a13567a2c0e5831daace75a7ccb470eb7a874fd55ac2fafb21bbcea676c350242a3be61accbc38790cfd04ec1c5e56a2052cbf6ff9b8945c4287ab7bdc26d7e9f355b1d9e8fc61f3642ee6a44439096e53f5378f7ef5b3bd26e09d686999d61afc872593242fc24111cc47387779feae71b3ef8505ef52f8dc5ab66d76fd7b795e16634db63563c70ec7e31b5d69abd50ac46dff7be4642146aa323b0024d2e30abb40b9d33b3411c16df471842990725a2da127f60d54ccee7cbf69969ecb9852aa4b0f0bd64a0ef577904ccd68145a78dd12bb0c70c18f5d9c76251296becbd2119e5b59230e13b1cfd31061fcaf6e6461a7cd83dd4959c8a8db8cce7cd729993542f645424308b2c142c565af487e55544be32625c87d5b943dad1d3bd0139cac0a369fccf44138145f19c78923398009eef45709c061d5c7817f6a7df03029ee63e95606fb60914225b31e22f34f1a44e2d908d1f1ec865c8e3ea962ac57fc859417f82550fe8ec14a014ff36af4e6224e11bbc29b9dbb355ff7914702715b0c3ba93ed3250c9681d396f136211384f8010f0be3cc8b6415cd0c14f704810f7fb40d37a44e9574a9bbe5e9e3b890104e44c03180c2cb1d263147cb061c19344fdfac27dd0227561f8a0d23aa2f1610b13d150d51611d07cdebcba1e0c9d6cd8b22ca885b56bef00df908ba939f178701f9150097a122bf9c9caa2aab5f35f2382eb2c2d0f39dd3be7dbe5f7c7e39f8d0e3629f379975ab43c6b3221a6bbe81d57589bf04cb7188a19bea2b9d587ab37acacca43c8d17e3b8db99f0cc732f118b22d075babde41f605503c62dce30f9f816f459842d7146841744d1854ec25adbe3c735a025d237cc18aa05d9d7d45461a7411d2f54c25cd8d6191694cef9cdabc15254f863f07b059a8bdf59379d5220249f757518bf50ca03451efeb76ab42d88001f9cd98fb3fd655902384484a06ffa2807a8c6da1d1998b103c56e7f5e250783b96ad8e683641b9057ab3135325bc5b4f303472507e5d8409b1bfebd6fb37c15b11aecdc757d5e743e57113a751e376eee00b6fbdd50152c1177eb217d83f955409d6fb53d0406abd394bc3955750b1a24d058ead3ed52b2c4946c2c2e1f2caf1e18231816b9b3d91d5e6e5830520f935183f5623b6ff4e45e4b24695b64992a985352d227f4880fa86a69f9f69a1736b6f2cc9bfe27841fd3adbdcdc5bf52cafd9f28c5e7c7f04057e6d6e654db6396962eaf95548d31e34e4e45f2387778f764c884da9062c894f5e4e9591cc28752eb1ee01d4db1dee08dc82b0fb8e8811516848368623d56d2be754b40386e4d23b0a21135d801bfa2bd5fbfa12fbb4d7b0f55b46f37f07ddd0ac8a544d417fad21432981e45dcc4c1c972a0979393cf8320451c22759f9f37bad837c0070191cd9654eb98483f7284bc08d7725da9364a01ed61738c21796c1faa712890d62caf5b358efe20a2456863b2bb28943a518ec89ce2917ed11b875999abca1279524edb5df902182875593eba0562b6bf0f05c257db445aa5cec61128197dd3b86e430995b67fa2c7eb2fa88109f0743c6e9051c00fe20bfe2e9e2915610277a5ec87343b55cc0c732b5f0a8fb84fa17326cf1c0621e20ddd0d59d0dff20ca41d74a14e73e91fb1d4486b00844fed0c9b0b6a1e4bca5fd47152772bd927527916882b50002de2e6e66896a5bff39c67a0397fa464f48cf216daf81f9073df0173cc1ac14e97b5177e403f12fb7ad4ad941f7979383585387233ec400da86fd77ce4ef382f04e777c992745536a080074560206e985e7a1e5a6d902096efa4cae2de4af547227ca2efc21c9c6511d9dd5295ea443fa72325d09e80cd37a6de6655a2d48e8df3a89895a09d235b73380","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
