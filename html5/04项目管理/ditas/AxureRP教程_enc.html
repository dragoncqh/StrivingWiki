<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5b89bfc7af5c87cdc803b2c193edd1b3a53f98081f60ac587f6ee104d839f9b4521f5d03eecc7432d9918cd3fb96eee2c233b030e5301a0dc1b68844c923cb61edbf82c4976444a8f55aca7a5f65ee66ecbac79feb0b3c0b88b1b845dea78f031dbfcee623156333213de3fda5ca32153f68739dd754e6a5bd926db66ec024208ef9a85ac8d8a4cfeef0f32cd42760795d24a696b38272feb41290bdaed5f316d0c06c422fef829b79c39eba34899ef7d5d0d4cdc98f75ed15fdf7e156b016d7be213932384d7f07a72d166586bd5fa65c9c4cc59ebcc648bb1568475ec32c887c85974e6d4fc06c7dd3ed77eca8812462392e209f6ee08135760d4e3ff7e56fb9ba59df09832d81176bf4c996d07ba8ef75cbb9d492fdf7e6be7aa60b955e0fae690eda75e1c6ef35b21d48e363815e4cf85c2d69535723ccae99a16aafded44ab2bab194c937866601d46ca966d741b562929acf184ceeacef4b2545130ef92388e2a68c967312f22b38a41a574ca6635bcb2deedc33b9585e24ec8dc8130278f03b05270e432a328fb64a89c48cd5002d82e67cdaaa536038850d91f2269eb491c562565dec5f4bb8a0d55603b5d0a834ed3301bace4af99ec4fd5966df1fbb8a9d6ed72b8d2eb598d7e378902b6f723f16399986f54f75b1dfcada2049db6c4b3400fb383c8cb48bc9c6b0c41f2ad6f6650244c931c783ccd4aae7e9d7d36f8f703f3a3526aaa18f68ba721afbf27c1d7f0a3b95d218f792081cd04312fcedba04336fb3db7271349c23f8f14d2c14a66bb4f7c42561a6c6b1b89974d8a110473c449bd1ce8a7d720cea39c9da91593f81c7558cebed0f66c2e4ee02c246680093d90fa395bf84dcdd7af5929783e11a74b080129aa3e8d0cb42f0700715bbe8799cf363be61357c2aa14a76d2cce93d6843706bf0a856f7a4acb1c0862bf58b54499c15fd23e735d6e2c06c8801bf07922ba19341ecf68038bc6228004750d53eee3ecdf146debd25bbfde1004ad5a574bb990bd990662593ddc6390b0f1a7ef608ac2e1f7a942df353f0ee0bc59459365825923b678f1b15a0951785dd4a8e63828059ecc0080e7162f32d7e483a788e9528f43677722cc7dce79166bbe6ff97af2334cbf0e364135f387e0022ad1d21b76220ea1d81d1de0b173c8b2c4c9abce61118a7e4fe85f4d6151b1b7d01384951dcd6391e015e4e253172b14e054a3cf77725babe32f7835b0d6cf632f2afe072d514254364ba14fa55ee7db57d66e413b4cb140032c1aebb73afee030e3f9aff5ddd7639782678fcc8d43f56641f14c782be27b9ac8bc43c3024dfb6d7e57c99ca6c70978bc53004a095fec41d328aecb0ea1d654d43d197d5d86030455fa48d444cc450e7cf5ceb3c3873c93f97371c0e2055e63eebbc6f067ca529efcced7dd440b6de56aea9be2a129d02dfb6d8ebe8ab9d86d6e1926f8fbfd8f3c132cf9cee85d141904167c15efca3a3b0fbd53a29bc7e01756017996d537b1222f2e4c6791d3813e9ed426785e37e4c192865ece10acc024483968dd609a5f78c6bf421f00bc3a42b8cb418cee2628167157375ee57e59b33ddb34efb8baab6bcb2974cd8640b2e289df81df75679cef9a670af9cf26bea992639773345bfcdc0ef2f5129ba00925390d21538eaac9e10a6e1a7cf8f5fcb8d7b268a0fe787b2a1ab305cf5707c56ea5fc2b374edd18e55def0851fd1dd3037451baeaaed6229fa6b599c0c72b28a599706344ce30b22da40de715f4901da1b0e546afae8a72c3976f44727eabb85a6c90f102f3b912b3321eb309a215fe5dc3ce544ccacd77c66b8c8a7ec4e04895ff267204880db7f1cd6a34289f56e22e4e31b12685f6a74f17c9bd19f6e2230d45b899c879a39559747f00a3fe0f4930494eee0e67974a137825278dbad5afd3668902be41ffa1be6c35c83fdfdced29c45555236989638f69165c6447684ca8dce3e5ea3af6bb022615a7d9f76027909c354c8425c89e4b574bea61c132f15a752bc4821a2ce24410be0b875eb0bc206193067d4ff2453489dbcb095e6c6a7586c0b7dc3ab8bd1cc657ba41b9b6a5f77a649a20322c6585268aecae8428f153c91079c1072b94d5186472741f31c7997bf919dff8f33ff0d99cbfb176959c3f251ff6f76013fd9aa90285d07fdd9f745aa7c9a904bec99e0bc3a480d20eb3014e82d31bfe768a8a583889782ec341b103d67ff828f977db462f9250b14623bb74dc553ffbf6bd88e7b2619ded8c16192441b56d84bf218a1b115e0d4800e1dc646a9d846a858d3238f3120044d81fad21a6055e22a8446a73b9dadf62f802068931d9c1a3970c7610e47991ff25025b0954fd841907c02361bc5baa5accab3b3a64f77944a9b1dc5510eb99e8f11efe39415a683acd7df873e792263f3d0fdbfc38b67de616bf8838ef473244f80ac08a03818e362e1063b262694bad595ce206ff9cc487d949d6be2fe05c9cb8167e0b21e0574bbfe9cc00d9b6c74992335b4e5379a3327402766397cccac4a6868da3a87bc34c6d62678c6aae91ead161c2b00a4296dafed15f47e4aaf71031a9890aa69c9c61d0785b6d86334d998f7030a1cb8e663145e824774160d911e779a09715213bca74910531f794b1edb3db833e48ccf2543aceb51ac91ac95013f5ece659146d7aa8fa5b294bdae5d001762acaad9350594680be03e445f7fcbd87f7bcde574b213ba118b5b5943d9cea258e8afbcc85d8bad2a30eea29ba08488384d806722694e2b0790910068d4c2a30047570625b9e1d7d850b1653cec1599e514f67ccd208dcb9ce5d386d135c56bb776d7f5e15ca0b1ac2ae067f97a57c048baf5149f014625257fac17307244e9b8d656a5ab97743fd120ba435078b979ffc4de706489899ec8b8d5bec83ddd8b070115751a8c32df4aabddd584599560634d850a18cf9efd6e4b48d314aef59b04e7aa86f43fedb6398462efdedc5daf8b8de809674f4b7f41f7c0f3e8b8ad1e94870230a8827042792b88a7764f4ed137cf50cb3e4922e7da710ef9b9dfaddd8dde424d399fb51421bf2bb22dd04233b861971712b44d4a145ad6a4f24bcda45d533a1e1914a6e95fa634a06cf0c5b215da42024bf51cf3043caef6521af3761f21d0d5b78ecf007bac9614f9cca78f24a341f7046ab6912ce0e3d03f7d1b78f32e7cc7486cc7f9fc31cb0534bfde624c6cb3cac41a98cd4fa691e7569ea8d1a75e4a5b40ed4b5530455ca2aba55cd1332017dc01d7590707a3a0b376c40d24c865a5a590f76eed4bf4a548b03e68c85ab952db6d229a28759d27eb4f5f4829c1317b004d50066fed8fe2f4f993d4d707e9a84039b500d67ea9c4ddd8677627770d4beeea5788f3aafbb7d18ea733828efa3d8d1f960ab2574dd291d319b48cb26ac33a5f21a5b9700dd7e4617970f1316d2c8f614f07d15d455c85c8ad52af2a4cfa651f629266b965e192c68133d5edeac5c82c4eaf9ad6f045036fea19e2af2a8591bae75cf23c2b4206c3e40942e18e0ccdfc0bb85fd68dd325789200517c250a7d1ec9a1db4056fb846c13acc245f3d13ef3825491318d43e8d1dadc2a2ccedc63359daedb4f0c10d529653dfe3af435986037a96dc371747241fad43e7ca838736b0ccd0846d8d8c11e4ad580b22571886914d90d5981e7faeda9b7a91739596e9c474efe17fc2b8ad96d0a2a6d33d45c82001645a74c4f8faace237a284499f56b921e65a623696608608f2fac12a77a78bf9f699d35f5fcefe5fd142eef596d23cca8a35da8a0fb9fe5de7e2903ff6d35860548ab698472474c54fb5f770b0b530c47abd0be68f96c3590988ab7b06e512a8ffbdc9b622f8a0e6c02e9ebf7dbc369189336c15cfd613e045e003b9e4e733d127fa9522c1d9c478eba4806fa000f5120e96d760708d6341c5716c0409dea78724e40cbf740a438d2c01aaadd10b5404a65b1c71c8835e3d08a895c8a60faa6259e5405f08f85a7c4ac2f877618bc5710910dfb0fd832b4fb4bbb3d358462c493241d85bf5f8942c571fe729ee59015d94197341ab0e3e11762324149fe91dcea45f486c8107deef8490b37ac2cf90cb695f375c7ba6fbad7fea273e61b738e01c6b4752934c8330cbaa076081b761486b05e484c3bee4b130db618fb2876ce21faaccb6204202b641f69feb971c35b2a20520c61f504131075113340fd3cf7cd9cec48746680692042507ab5ab9b8571d038e380d5a736d6785fc4a3c6da8aa2462ba8fc1c9be0be31a800d738d48fe33a80222c2d9fc152a181cae3bdd74151b5f442fb62b81d0e740bbfd3051ed570f590260d7b6a5e84f60737aded8cbe9da8c93aade530c701a8253dda52e33cafa06f2ef1feb0bca05fc47a2b5d0d8704fdcc37881fbc63578a12fc5574764a556db0fd9aa8aaf3f9d96b3ff839d991d35659214a4a22bcb1d7b58f6d505473a1d16c02f9867a8b5344a959e056b3739d99968e266408654c35c1eca144d1c85a649c8a547e2ee4b5020745f141804a55c0ab7da7224f7fb07bb93a70e8162413207f337b8589de96af81faf048a13180a2c462e02bfe7aced21e447f3d841a5b0ba44749c766e1e3f817815f9640abbb7cf58a13e2b2ce54ef2ad3f082edf919b5d566063a7be2eb86b60cd9d1e71a55dcb00075b39cc1028516fb75fb7cf6b062954d9896635022fbb016d877fff9524f0d6401b08236df1a29853af1b0a05b93f8a1129c1b99d22265e50cbb7acccd5408b466f8cb36bf45ef63b4ac42e266a4c94d899729ebc337c802b9bedcddadf043bfa6c0241880272446d571102ee5a3533f01adb29172331278e79826963d23c7629ed68a95cfb02b130cf0258d07840a8a514d62ae235b6c331c6fc99abae1a3cc58cea71e18b856f4825b06f0bc2d05bdfe5977fab1e9b98cfc9b5e3881220779779ff81c66f9bceab44a5624f53ce3a20da58c96bfa3b9a8a4b4415bcf780c8ce2dfaf79cfca5acdd96d31b730dc90207d614e6197558ee868e71013b0e7ce3b3f462dfd03bbfd34b957c7fdfba78928a0a074154218f103e59576c055fd7419f3707e11b3d3840c36d8d33e787cf67704f38fca1461299e626fe248418cc34c4e1e35add5be7f21c98afe3bdb3d31f360f702fb1c2dba0ad00355932e37f7345717e2ea3dba24c2f93e6c05710276b5e7abdebdea7685c4d3886d21608023ed975fee44e1f10aea3ad016198be62b246e0359887971dacbfb6d2fee19ee443dd35128e3c294101e6882b7935f05226820fd4c19817712d26131add6184e259057d0f14b1e719c3b1f20c8c6e17b401c9be0201d1fa52b5106d65581359e6a85df9617e3d31c77afe038598c86606ab78d9e95b0deec753389d567dedf393640a8968f42df8f78f5ee74a7b461e8cd979b6aa5efd2b51344ec66eee8f82ff41ce16603ad0a90e01f60bd7b70457890c6c998e087ba414f6983dbd0c90c54639b563f02edd3c88a2ec246c405fb9b73a5c7cd58e7d7b58622d21f3860ccda14e998a66042cb74903df25b92077a9c83f0fc3a2442a6cb2d85ff96ac741d0422eb92c2be3e67da107d06c2de57c4c42890ce327a81a82ba57d2e240cddd8096734b49ad23264dda5ba1128a03f33f6fcbfe861503c3ca255f5aa8c5be3bc030f9fb78f2643558812437f86d64b6537dfa6b2b636c4fe6b9974c3f353e9b624cf92322ac38b07648d32af14723dcecb0f552f15599ff5fee2d3a50f00a649c92058014f9993cd9fbc1850becb8e76c0a9f3dfd5038e7906857750bb8cb57ae1c3519d75fa8b19187fa2f618b2e8df3fb0f19661ffa029339a514bb5ceabcc65e742ccb3ef872783d781fbfe531f2dcee85cbb118f2f1edb0bd2525a117f1597b481ed729d50171733c588f2a122ea2b870d37b3dd24b8acf09c92f2f60540b7e3a8e54382571bf14b7c2dcc6db660596f41e70a644721a63684ca45095005e16a9aa91c4204c248af53310bffd30ec1fab4aef75fb6fe1a3692b5d1fc6ce7038f08bc6197d386fd667a741b566280e124640f7cbeb22290eb25e466cc7eeb8d384df37acf4910a77dea34119f36ce2d5ca680a8c663531362f0950d5ad66131b1757b8e85b5b3566f93f766742df69e28dd711ccaa2c08f5177e4026cc09b7a0bf192da6cb57646d0598f2a7897da4535e38210cec4db380b62147b2ed44b83654487547fe226b8fd5148f70533348b8196c2cc65e4c861631afef825f227ff57f4dfd3e6cdd164dbbf5e2974b03bd0a8b900298817c041fe238b9ed629c677fd1bf15a782ebf0087b925ff9bf69d0b5e7e64a983f06a714c2c604d5c609eccb39279f5905e85943a11457c373e7394ac1ce19da069dca22a73d1af625ac981ef4c9eea1a7d1b0a91f4d766af4c6bc4e3e51ceac4acd475394c3f7034b54a080ff69663d5fd88a35a7c7ee29f92331e2f6f17b2bb139048324cdde6586306cfbfb58a6a3b6d90ac31e9a4e2ffca6f44030c8ef2bde924267649921ac15a6a8e4213729165bf7703e47a9de501e29802c8c140edf87e8e94e6b7331bb07c3a1fc30aaa99ba78e9765c20da73266fdf4961e38d5488a9569566875ac01225b3e031b89c725df2e6822fc809c121ab05f1563b9c58927e7e417e16305e9e673022481fae5eea814ddc4d296f21b55ddae9b4e37212d99b9f52c8a8dede4799d8c5de7a2d49a69c536453022fa12a5ba80111efa98041d66754793e00b192edab1b0a0c2bff624197b4163c38f70a7806665fd36eb30cd3e4b5580102275f6a9d864f0031cffd806019564e933ca1dd37e8ceb7eb8c4a298cb569aa02a96cde64fee4dd6b675e2bdd3fcf0886db97328be48d808d7288dff617dbe5c4bad19454a78c661d43979b4785f50776f164ec4b5945e226985369dca35f57bf927ef412a5f3ca2e6944186b36970cb57aa232e8a076ca3e1a7c1e847a7395077aacc20742e0d92cb728b50514f8f576c7bd2d294a32c7f4a145f60f0e271bffb51d9b2c61de5911a3065cd92aafbf08785de380ed976780d2c8214c25982a3aca5d9c948c996ea6c07e3a9d0cca25c956018b84737f644a5d7f591eac50010876f3eb788adc49451f8cf214f52205573c9b9b7d01733fc8b04e5fbcf06ef7e53aa1bf7ee4fd2cff7fb0ab9d0d74e6e54ffb95c150078affabc7ba87669993a2db53d0bad29454f2648e1c1549c808c4ecb61c0433c362142d82afca3a92aba6fdfc800ec5871027967ccf5f471406a87fa7e7e724035f85fd674550e8e3e94abf3c769412b19bfaf137cd16e44b3263e0e9972b3237ee2c1441c0febc05af9a069874de3fe2232cf2c33dc8f753cc151c52d711fbd26abb6c90a789276674b07a6b8e7fb623bdfad19fef96d0c4d6f18ec4c467dbe2a2098362c8f081b8291b1c2cf222af08109f02d5e5690b86da034da786aa17036e5c22634429c2e74ef3821f53b717118cba8a0214462e314f19633102d5fc4fe460bb19069c2fe4654b37bd84038d62dcd1a2c6d582ddda62c051fc44624e8b44c21673277d9d3c7a99a35254a992fb0292298d59f9bb720db5314b8f45ebd26b934e4bf4d28af7ffb95dddc02696fae584d38607b4980444a2a1397c75da6de2549056e5642a1c256741b5cfd7b55150dcce3c6ffe80f05706623360ef8882d4094e60a377ec1713d583d224a4610bdb971e7344d132047c9033c7335703cc3a22ed554d769fc6de7b90b92a24a56b3fdc925fd5a0d0f80cb25b1683eb64f7b7d553aba21c7ef2fe18e82c431de2c85455b0b7f5ec2ad4ee98d4d127fadc51bf66de3c971aef962c176a9652c3f945cc0e0d347989f430815b6174c0742cb8ac7a0353deada21c053bee63ee837091cd0135de23415a3f79088da570062f5605cdd079732b55d2f3289a60e6a69f4146b9946d83310d980990618388ad1478fbc4b1371018becf371549b4250668be575ce21a2d9f0e12c85c1807370411e5ae4efd7c5912f2ac7f14b9409ef51be7404ec38f7c7e94b2098fa8d98a0c4976de4c976d915d4659e5a3e88a80270e6b0f770bdcc1683fefb2b81f7ff5a1ec1f70ca882f6c2c0d5c59191afe14cf4761dcbeab290de2be73ccbb221dd54ef9c7f5072688b97c2f625024b5d855aef12f0cd51d02a9d00e7d8d78a736b0e63dc24efacaecb475cb9fd03bf373444cf2dc06c7579f26caa62f1864b6365dfdea81a61f0626aee1b5f3388ccadf98076142e3dcf04a5ed287c4614299cfcb83e9e9904882fe414b47fc2554b4670d449e4bdce74b5cb9ee8e8e1db6436ef19f9e2ced58bc0b65aae28f9eb99d420ff885a7d4d7fd2915367fda2706a7cc9c84a012f7c814118327f19f20b9f795b22f57cfa1404aa17e252193fd9d50fb41c3f62bb0ff97115989e342e4db66bed6a94f430a1d718ec29c28a5da5d3911005872c2979ecf57dee9752fcb48f398909529aeab8a83264fa37fec62d4675dc1aa79317b4c2528eff7f75f39425ded5517a5e1f601227c3cf402e624f2a1aba1db62a9c69f0811eb0f743e7be71e5f657df0f5de0c3a14bfdb45a96f44b29eae30386ddd4eda3101e60fde5931c140e520b035bc0e4a56f8c107301a1262c457c95a7e79779bee259e34a2a696ab2a6859fe86bb6f2209256c50a953d69795f19d6f436f5a96b6a4f09fee9c19b1eab39bc1f5534e93a1d9cecf2ba0f27a1607e3f34aa94613cd9a537a236dc49fa5ff4a87532ce33285fd8b76561e0311c5f2782f87cb20bc3b6c06ce8289d9d1208024f7716855171c404e431bf9e870b92f97b30a561459833f888d490e13fba08304836925835906c359ea480dde9c4af5ba0243b7984b65d306627e49de3e8a2dfbe4966d17cad1fd2f238a8fd00080899a81cb2c7041f8ee2fcbe4156cce74c976032ea66181cb7789b5fce5536e9c3b9018477a39f550f9f8e5c533f3a9271f2873d647b85907999da38c011551c7ef8e8fff8a71f3cce1d9efabe33822ffd4877b4819e59cc4339830d6753aac5474a123dbdd1fcd2ebc54b69d85525330122463f37325874da0ee8541f6dd7bf8059d602c431306909bcd1cc7f24e5e4976a800a4563151c1ebff115fc1082ece8502d7b7b25aa2e96ac3201a84d0dcad8914fc0bf7adb64266514e8dcbb2d15d87186be7eb07b4c9fc0c3262bfd086255d23664c78201599bc2c8fb5555fb1e36b6b29d4a386d2aa7bdcc985988fa75360e95c886c42cf377a2dcc4433814d28cfd3dc3025fafe38e7c772d5c1120efe62c24e0a11a5ab52f4e276445b441901d61f74255866136c52005d101275d6446370d6fc82719d9c59878fa5f341ce7d40710651d3e9fa3892567e492e6f04ba2842758b06a707f1a203ec5d2f9a18a2db3ef6baf2aeb62740194d660f44ad05b568a26de98bfed613db58b57de8907fd7be334320d467ff7f1ff34b7492e746db06f022e87f411c1e8685edef4719e18038857a9702f6d1ef6a386fd8346fae65c33c010102f7ba601a96c7557536be35e215b5e8738dff75b1c7bfd1d1f760a49bb4992c810b7bcd124e394377b1c5b42786096dad7b85783911c4883faacaca5521042a39bbec98fa2f49659301493dc6a375a47b99aafcef8e85dfb3a44f4108f9f46636dad540aaa39a8c1bcc30281af7ab61c354d7c719c57a85dae873f54251646f8f87523dd20e114515c5d7f92fa53ebd8098b82fc88d190d39306d59b4ce35fd25ba0b294364f3f83312249d1a1ceef03aa492b829025ad3f05be32c5e81a8daa2904fe76d3e990e7f7de4fc211e5ac6f3d5d85b78387ffc4e8dbddcebfd41a80ca2d1409d8870db044f73d412aeddae959517d1c0893a5a4f5265fa0899e134856c7cdf2bd8ffeeec510f9dc0d9f55c2ef50bd06c1ccf7593da19291b6d162e387c9b1ae4cc8a29065c33fb20847d1df9360472fe09e164702e125942b62801069af372346b531da1221ea4a1df4ec1c93de87d268a3c4c8ac29473d55143f41b87392d1af14840ec255950660fe1a1eca23f42b6de7c7264c5fa2021765eda741473daf947a3dfe163287570878857331ead171bdef582d2d7bf89d9df3ff465710658eff388cfc230da258b168e56e316d459d85d680529217e5abda28d5a50974248771ebe7428101b06751148c0bf630320802caa8c6a60b4b7f9dbddb953462534fa1733165ac490dced505aadb4ca8873bd57796d3f1a8a6e5e85adbc9c5c76f675ac50e1243e2e6bb6d2f006e5f2ef23a07e503fcc7e0b685efecb603890904e43c0fd4892af431e0e0f30e8d9bb5116f16f997d5694fd8a5069590d6677d0b4b888d6214049e54608034ab0726e46e7414ebdba8ee36910baf6d3e98b739f9005c75a3c28b03f984f612d58ee281bbbc395c43d44a38cbe8afceebd3f5a88396ba2846bcf3ecb97a1e1eec2e6c07333e5ada9a840fc67cf20a3edf792f1c5e553b7c21c704e8752bf19e3e8fc84e8391f8acca4300444d4df3eb87f1f6249ed9f77808d08ea2aa53e2390e18fd9efd65c46845a185b8c17446d7447211912c291fac96beb1304e1127123a25c9df244ac0a86635f8fd46468165f1e3541ec9181b45f61607643b5d61b4101b4dce7680adab953f2c09571a2aa13d8c4bc20edb5e4c8d563ce89dbb72d001b3f75f317787e366f322fca95e611458964e0bb2aa748a3fa91e745f78c1ec439ea8335c1cca987317d1278c7fb2eace5132a0ccfbd28bea23c71d1ebb3d202ce1c375295d59428f534fa0c578ccff872ef0b2ade2ca9a254ae73d383062f61690a5c393bdf387f853b760295f1daba8cda0a359ba49b7dac0dc03da126b36b0c8b77800b865c9b82733b736a8ff10fffb70454438cae1fe469d4ca04fe53e198eade84703eefa294413158006a12383b450629696889d226f24d5cd500099e5315ecc5c22fcbc19eb73d7b253e85e0c8d85a0a81bba0108933651e0f252f8c46c08ab5a1e45c79f464b0ff451cd18039e4aad2a9ebb0a3d56e932dc26b7c77a98c9d78b987f879bb03981bcd26e8c9ef874857de6ce535a9efac81d0a51f0b554a43a12bbb8cf8b7baed7334930620959c266d2270338bf42867d9856406103f76a963aad9c70c3e9f8104e9283c181477b4bb0e6eaea8786ac4737ff998724a3916cc8f8918280b41607d4c0a46a713f0b9db3253115edcb24efa8970911ea288ac86810f8cc6a565b47558924352d18ff21cc34dac65a39192bb599dd4d5e4f01f08c4489479635b23f28e24eb9fd1ea28cd20b53e7b8de3b756d6a7ae108123afaccd3435d04245ac4dadae780689d8a1771f96bfce9c062013a40b877354ffd6d978b2a44114105f4e76bda450aa535449be9224907d96f649f4575178949bd7e6830a819a98a3a74a4a219168f90b77346a83dd368b5e2453074a86b412cbe6a80dc1b65ac5617a39cdafe9a80bf0aad71790efc00a6fbbfe3ca3f59e40c2a838f5575552af017a308910a74bdec8ba8758ba6d016ad394e4aa315c8ec71a694d663160adbdc4e73d95f7e037ba659b649c54f5d719fb67d48299b0b63daadee1dd62ab391d45ff3774e52cdf60ec97f0b0e3f18a9f5f60149b4a9ce5c8ffe48b3dc6270d7984c564010e5ae280ea1bb492565710cb8a481671a1c0af8800cb9541889f4c7380da4d2e5e9a90d759e1f692ba6095a75f5d17f43b6d4af3a7345bc673fda249c82549ec0c2399b87ff4e0fc7a21e7246a8f10aa7a9ccc8bbe8c968bb3e71bfdfc5a142b7f3ca7c637ab2687c1b5bccc07248cc8495d0a997ad8369b755f0f7b3010447f67c0a0ff29412a52ac6a0c46267cac527787baa835544946415a61fad25420182cc76539f51550126a4b71794cde1583029a216633249945b7a81424f50064f99b100091494e2e11f6429e23c926d60d02971093cc32c80ace822415b2bd443cb926048c7248c3057cb20b989f4e381fff1b91cd43927afb69d4fcee45419c1bbcf6f7025dc847cbca5ae531977824dfd634e3399ba0504e262eafefef14342bad5f0e3613d38061d209cee4a07ea16cd4b7213aff5982df7387c72dbc706bc6cdf446c617c52d2a606ed01785ba11a4262956528dbaa3faffd447ce493225f6aea00f6191cc47ae3d01e597bcd9a077a84c087e7b7fb282fd8f2a09921635f192f0b7d10a72c9ece7cae271561fe6d1e952fabc07c27cb36ab5e95b806eb603f5ed2bbacbafaaca64b503286ef6c1ee404d5498eb6403af9525f4b056e1ef97e8044b02029294d051fa266809c31ae0a716ac2a46d93df2c5e2f5243386a77deace3174841bdb47dd74da0b6dbe70beeec79df0d2e2d28d05a97b361128b7a7f06c3e798bb9c0965ee214ce9c59720e718b556805b03ce0e88cd3cb7f09bb1a33acc5fa6fc8349b9c7f38b7794f00bca94768671626d67affe509095c8610c3d57c42ff1c02a4127e61dc414d42aba639cecf85872f723eb7cf7b7428a5f55562e07041d397950225330ecadb8b196c300a63741f9af96338a17601a9c503f4076d28aad10fca2a1352ce94f0292da34265fdb76ed5caa55a48d5c80158aa04578990080fa3b743e15fef384c311dbfe099738dda9e6673faa9aa325539aeefacdea187c5f9420e6e126a4327c803a9dafa181de982d07e515d455ee99d96b45ab2e078c46bd57b2e4e44deeb561a99a1e1136f11ea2e63553cda37fbe6833341fdcfebfa64748f2b503313dd788ff99d257256cb498b8bf23c673b721562475e4e3258e28ae17d76fd46fea439c37f975a5150023fb9a1c895d09780dbd4dfde5b8e964c7460af7ca7a230ffea67ac078b5dfb0fdf4a1e853e8abedc6894ab651ee5eb79fce8223f0ce54f13fb65d70d80d3006beb7e2ce78832cd75754c8218025c3f9764ed0657ac4b87735b8d5a777b0277ae019a440dd14ef75a3c3e64830363ac7d0e0d266eed9cead1b9008d10004460635f82fbae0c03fa4c04aab9e51d5e8d5719df5ced7edfa4bbc3c98445bd328c55960d733081a5e6d29831445cecfe7817aaddf9225fa6d434c813abcc1886e6b5bb60afdd183dd2a96b0290ca1fae3dbec5837933f99da37108d27601fed37417ffd4d8b5924f99bfb83755d4aaaeb8b28354eeda83624e4967cff7c6bc324e3617593e02338c6eb78e3dec1085b1a103994b03f6070185abfea0d94b14787e1f3e3d55c6bff4e236542cbfaf2fea32a171b1b32423bd82ec0de2bed74858111fce856871bb15fa4396fa0dfaa6b7f377644c620ce55c82ef4d160a4d6badb194273b1c1db72b638240307dda77973ae9eca48468e6b9215f74fec4eef9c0ee942d774d0a938fd3a4f5044301b8c7e03edcf69217216da0a7269969bd0622af603a246861dd458802d28b0758236a55b1b45cc30d25263891f9cab53b5a9a072ae815d694da45f15bdb1885ea899d3907366a839e75bfb7d970e87d3239177f84c61b023b6b9d4c5c4ddfe9e94a51f2b390e7a89c36dbda1ce22d8e05926ba7bf0af06d6892a8d2f3ece55e4e3a158c6c1b507452aa0db21734e8292645db9acc135321737c264d9aa5ccd70243e1630288c17b4994f3d53c47b74a662999cb1e43d04c3469486003095a536738c342363088f191bcfe99a45039fbb9c57b918f68bc359d0b292f26a5254a299cf6911483e8703a0baf659d663a6271dd103a78b771334006e4dcdf156846761f8c4855c50fb76a34416d8b9b3f2797774b9833371c10fad051bcc9ff768479e493c8d0407abd592931b492713e643ebb64a6affe26baadafdb955b0f68b952ab4df7491036f3a60d458df1fdfd972b2ba133843bd5cdfc37adaa0605cd2ce783349f6a62b8060b50aea32641a900b865687b5e1af621d3ada19a27578717627282c61e33ec52addd37f17a2cdbfbf886a1200d50f55920e8e1d76b16ba3304f2fb10963ed5dcc11241f1f38702bebd5e0206fbbcbba273d4a1ac2a6d6ee98c7417c1076f09664a523ff6baa74ed572903b6168d4c4ef7dc9cbc6fca293e05a7bf82b390ecfe21c43bac0c1840903e8dfc353fb76004729073403a48e9b6804425cd4e45b3b59c4c6a9182f00213f6f92b91795365776eeb581b0b8bc0d78a4562fc8b5e27aab29230225ca7e34e89effd8a3e7c0026d925099b3675f0db305f222462b7a1cc0fa7ba1700e1c75f032103c57a64f000f906d4aef4d51f4b56f4b1d978839032a2c6479ee790fe820ff38943acf1398faa4507b14d838dea6bb713036b7a27ebbba6d252b3fcef229217e28fc42b8976305b151e9189d62c05f22d644ebab39e020ee2aaf5bc4b6ccd42873f36aceb28567786d99d5e7ab457ef0d01149428c267e7dd58676289d338b43f3c747fc521091ae2f08c541a1beeff600949ca00ced6238f13a2c9a57352bc4f7965302bb0a988c5224d3960c8a213be8c67f91df44966abe4c70960a90acb567bb1571c03489454cc5995f55dc32519be18d2dd32096f60f783c002e159f9c282796dfc1c3b0b7456d9ffdd3d2c6c83c279993ef61227ff01ecc4030004b7116f118ce50991aa65fcfbe7f9727e9acafebfe20d9855b6588a6fd4193e8b75db7b8136d0479197323327222bc3241772554c7ccd68dd0f12b44d99abf9275c6e104145307ac7f502bd13e11f953ad68b444420d36499e6f4ec9ebb30dcee3294e0ef821bd951bdd5bd4cb547cec072c80e33b8f57a6b2362973e7bc3a027acb32608426ad668d7d21d6f6ba96dd9f3ffce4e5a68626f0568d32a718ccbbaaae26523a3624dae9e5ebb6c4e4aa7f1792cc6968830b094b5928ef9b266cbee353beb11b8a85847aaa70b0aa6c84dc21484a64864e197360ed8c858ccfe02097553939f8d2b94a691d4a2fded5b68810baf381960d3c07b322defb8cb8c5bad3a2a29f40f9e836fb42c0c518c44060672f2374c7090e9567bfdd540aa530d5c11593d2988d9494a479bc5fe4807293bf163eb59d69e56d68c5287c4db7af7382f7bba9bfa219db2319959285bc41dfe33123f7be67cdf60eb2346acac830bd0e0826c85c9ecd23b13699cf09a606232e9b123a24c00e1844ad4833e2e9bf3b6faf9aa5134fbccf6ab4e106c69dfea19800d773dbb8eda7f8afb1fa5aac2b1170e16612323ca549eb0e42e8d2ef835b36034a5a534f060ef57953cb241bbd090ce9b5800468fdafd1ae466866259fc2eb479c4993c8450e6c574775e5e8d03177ff9d38c0825ea6fcc6ae0f68579b86ac19454bc087c13924f39a225f8d3dd95339bedc13bf0b8bb9c21c2154e1d447163145582d11fa2d91c6720b31c9f01b460cf25ef635173ad34b2f275dda3d00085464131e71a3ecd4c904b2fb6b51bff02609e8c81a0fa933aedccb0d4c1ba2a718ce3ecc837899c222489078f7b7420b1b1c03295504693c0b963046d9d1f478fe674924f921aedd23878b05c969039267b24d48da238f23b3b087c716fe09ef6badcfc9508a3e8744813136edfc9400c547c6ea172e5b94a501f2dc70da0d75f8788760a2588cdffb7d1ff45c7461e2f25c08db00f1ffed7f8aa2e1abaac952a44cd3358619e035157182754357b26c4a49a3152840adfa3b9a8c07d0eb542da8df3949bcd04bd3435398d01c75489d9b92f9a8e51454544eac7ec191933d345b2074a3fdb3f8011764cb496701058f3ccd6c33d2dd51dedc387b33b70354eb4df942d59fbff33a943101dbce51f264457a686f300a7e53f6767a1cf0c4c13c435f1813efa3b0d719635c2de8026c91ccec30a1cedfb1e07ab512ac769065f79695166df7764a8ebad8a2ad37205260866110286a943fe7a20c444c1f98fc5c153e41240dced1a027f58667f4ccb9674b332771a42ebdddfdd05f1b46a9bad04f413ee2add94be425899249e2233f8d8b3083eedf17d40167e566f65d1bb93659d890b79553710a9a771f54a504381e7e2d74ad1b89ab057805c7284327611e6e9b122180d7380884f6c2a213b3201291919bac02e86c8b468dbdf57d06340f956a2019d456655370e69bc860f96ced2af88e07bc0f343fae9afdf512ab06f2f4788eb955e85fb1019dc8804ba0e40d1705141edb34334571844c546cde8b28261b6e1231b79c60f957fa10c05ea9abec6cee6c95f4bc7b30902c9a49a3389aaaf3dff21f0c7dd15d9ea22473c4dd54e67998d871c2979a2c1fd9afc168f8e51e63a389bce7b3a0df8d0ca384a4facc39776f6e5b9aac56439837ced25911e48f6d32afd7594588bf60c267b033f61150f39c46baac3d4bd602f338b8c7e9dd15b799643cabad2568953271ac44ecb4dc9ac77ca806d1369c0e30d96952a2b72ca40177164cf0997e2774f1811e3aaa9eac552b24bd0a2b94b9cc1a39d0073f1502d632e658f928cf21d804531f70f9fed78fbd3b603df5ff57520bef818a66be3598ad0ae7bd3e4a391e87db8305c05002e1250e528db07b8c4cc5f1ffbc75dd9309f70356ac7848bb387562f835104ffac761192df7f311d50c96c694ba848d407ae81a6f7b7306f2186300412ae3efd092f1db85be07384f1e9f10a08290df08c131549a8e96720f453f7dc352ae3903fd5108dbc322de80e59342fa7c4e7f936c0e9fb83ac6722e97321661d8777a40a332d8be08d1dc685565ec83528e4d3da6ecbd98518ffc8791ceab9414f45d6ee8f3e1c040a8a3a3ebb2ac080b4b0bd3ca53c4273ba1bb23f95d8a60deff334dd7b06e0d7abbf307319a8b9ff217ff4ff78f870e70c3d9bc22160c2eea0fe951cfc46e392155bf296a7d15372efa213688dbd467c2b5a8ac95c3ebd364b6630c6b3b6934acbb940eca90d6c0dc5a5821e0a5b2ad6835de0a28991dc1e234c50443b87c89262188b7c5e8620cc1420f8eec8a550c6fa322f9c3345d3b2330ba366ba8d2cef1032f14026e857bdf45fc907c1065889d3cb9e5b43aa02a83f068cbb52e035d2f9199bd9e545f45177f7468132b4214da314559c1b04d06c6451f259f2d4f1192e2a658e4d7b772bb61cbf322e922473fb85689768db1b1bfdc46b65005b07d406bb2dd6a78b178baa86aea7e9d6897f93f16448bedda2aac83012e9012fa711741310a3368c8f7ae43af7a4b3cc3e9e0798167bc331c65b47504bc63a8bb0cb8a8194add45433cfc3a6c0057c4f00f74c775207c2ac9c3d291604855f73c74c43bb1d5bf79e32fa649395e20d3c5f52d1e9182c2b2f009cd47b7420727e50745723e2c060dea5ab7dd1690786429fb22a6aefa097d52b42f3eddac4d53c75e8bc494be2e6b564bca618e15408da6f8fbde81df4c41eb42a5de81f8d3c39b416e8601018b979b17f81a1b166bc7d7e1d955833c6c329be0cd57d327e73061d0de11e9157d2f839b95794b019e9a3c3e709f1baec93a005366ca334f0801608620e6d79dcc1903c1cab0715353e73cdebfd60791b9cb0ccfb5e0dcd368ab3a7a70818c709854f6301ce72ff9bdf12462f86fe3e6e09167201174c6f58aaf653c8becda3032bc011a89f269da44af0b3b82219d3a1d162f4e6e085bb7e9eb3b1b40b14243212a422837b9f995cc8db20a0c8416ee1528ba55ba64939e7b24b705a2f9231d254cb508460ebac29e41f04cd8f13c7ad60ef4c355c34a30a6af4ca89adecd68c6e5e0dd3352eb7264b883319a36a5e77bf687cc815b3d632a05dad5989c74fb9a46fe80fd6312336016a3200361fc1b0f0215299c70cff451dd6ba81935a6dd2b1173db04cdfef411a627e6a519f5a3218efff285ba04ae1b11b1c0d7eef8a09991814b409bfbccfaf652f14022a17d98b7e9e89dc1cffedfc639bbb89254aeef942e0b9e3052795bc1c063420b5f06e3d280e5ca1b6ae10cedd795bc4e4b7066db302445f37be6362dd911d38507f7f75885c876ac86c2b1e8c996f42fb40100d049b2cb88ad4da576af164ca082530ce4c5e679ca722576a7cb1120533512083d23f5c5ca209167393751f4bfbad1d384fa224ab1d4ebf8c85bd42902eb216d0caefb6273988e0960aa54741487a95b7eaee1439a133d764d46215f9e0f4027bd3b2818b22bc8e94af2d8d17721eadada3ed87641642","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
