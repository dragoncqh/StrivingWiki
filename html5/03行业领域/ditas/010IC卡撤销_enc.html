<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"56813fbf6c55831fa7389b5bc1f3ae1ed72739c3141833316627f4263d70af53422f91a2af42153c506f3a5705d31c7a5a447a6f5e391773c7044ed9c59710751ca2cbd980c2fef7f4d8c8c2501c04f3384115d758204de6c7f744eb3eafb15ecfa559c29118942bb833588874656c2172bbdd0c5fc7dcd6000d7a8e25584905971addf1eb44b3660c845975f88ea06086fb70039a63bd5955e28cfe3ce7be35d6ee554bff85a6e851beec04560f98dc0fe026b1309a898db327cf7d7c3158399b268ff9a9f59f4cdf7e1c5ead723b670a47ebb6672c569d9914f391ae355e8206afa51688497ea1df43882dafb4760312aad0c1bbb392b8f28b033bb94d8b912e2a54002340d44f4da8696812da7396a1aeb55dea8e597f324f814e09bbc9805bfea47abfccae6e1863ef826c41674c482dc810ebba8f251a2ba064ca4ef7611e8e01018fbef8fa114a48d30a95a4e34863e1587a13ca6388baa13a8c4b48cbbf14059f62ffa12322227333b992114e9dc144e4245e7455cd04c4136d2172f33289ed76da7d45ea3673b30c5ec928a311b4957205714a48e907314151d8984264fa27d6b205a8b5f842e29e25b9a64707951074bba38009d201d226fd7051564d65912620d954feb23912ce68c42c9774b4ba59a9593a633842d0a89d05f408fedf3964c1b01f1da18fce56907c91a29af640e9dfeafebddecc658f0a21fbed196e7b4b2510cd10c5fc7a49769e4e0b4acd9f2a410fae67c03af55a7d30576b66d0b4d8755d2149096b4d4d7aae8e3238897775a0af3b44ed4106fb5fe80fb4597d90dbaeddef6f55486897f242e6cec5de2a8e6f827e1e9537edc0b2a3e1f365450807da2680d4bcf1bc27e49743a778e9b1f8a2c4cb6aea1f8bf5f204935dec7e0a6d5ebf7fe1eb80f9a76d3a55052ecbc8e4c01b40e135cfa5d9b5fcce8fe48e99b8524653d434749e0636b924fafc44e2f2bfeac19f1f19305bf413e1b4a1fcc900a677cf7f59616f8d098f7afbab126ff311bd5c58470e0fa83efdf57a949f8e7a857fcbc20095375096108229d3d54dbfc355d0f734768fe89f8af22455641e6430033a83b144aff864a31a760c52e1ac385beba7ca0bff2ce47830fad154779d2db3798c6fbab1dc52f4761dcddc8d0e3b2fd44676a6572fc46e4f8a1864c7eaa62de736712df5e5456b035bad1e60a2efc742ba20a4161f7412138d2fb197c009ea9ef712a44b0955bc055a41315f4664f7683612ca01c0675c1c39259694338ab56af683a45e4a8e8e47413408a9feb5b0b5260436d083c7cc6a94f7310c46da08913a2a3c8c3a0b16c3ab7086b2061b6db3c5c17b16a992e4c0763cc30f5ed0edec65172f76b2ab5baec1827dc87a6e7c0792f4a3879cc157033cf05b614e4bce6ba43ed3988a7d8862ff0c02207e6678ba9fee0ad04ddffbd544976a2bc99d1373b389596e97413c1d8dddbe6c836b2eea0b1a51ca0a45ba51f738e8f05544e8e941a1491973bb829debcada8822ffc97063d3da1c2bba8a1b599dc97061eb0e6f687f34b268f2b7e59c2aa0dc65142ef2f21aadf4ada0924137e3df73201d68a2560306a03f48fa1f04820bedeaf3a7da455276d6d58a272904eefd69fedde1ab200416bb2582f3b9cab3a9976825dd5c0bb78c3b565de751e53ef44c13efa8e3a6b30f425b9e7864d1cac4cd006a5dab9bfdd964a511747d7b46d9daa5084ac96b0265647fffc14d9222becec84ee1cff2d19c9a2fa261d1ca128a015343ccc7ab44bde3938d1fb96e62c5f0db35289e59bb14b0f4ced9b8d37393a28489649122a0924dbfdc910ef971cffd227b750bdb994bd3aed727f7078bf66cf361bbe081ef1825d5e17319df4dc251f586a0eac3078f2668c854f99fe2833e8be3523bef10aa37f6f506da02d29e61a50b3b6cfe8f15ec30c804b85258cc616aee9c6afea9c3d3c90a0060255f41c89efd3fd8797f498b8111d875ec87d461c61c25db9974cd28d6452f1fd3345294112156aabb74983bdcab5d6483eb52ab08d4e9d1434aa71754a1da01321d247e399d4ebdcd3cd0782684869c5a531c797be50c38fa209e360e77ef3cd292d83ce41f597db1aaf7b271035e0aa2b4f51195c04a2ce86a08f96030f49d2c9b2146f222d2531f8c0d4f13a6faff3a58c770c280b0d54fcb3e7caf66151a61aaf987e9f01e91f65a6e33334c88a4cefe2af551fd85e4ddd723950e8848bb6f4075668018042a5fd4ce4999037fb523a5e5bb250a8a7183838f5eb4d287fc02fd10f6f0821baac7efddf7de06c31c0647186c992cc4c3d7514bfac15514d95bc5a700a8ca244fbd3a6a6848c491309f4874628e8008a053444a0948fe465ee2e3672ab85a7b4d82209be3a5a8d58ff8276ee1035d117e443cd4e294d8ed2106287c9f6c476f6ffe7174bddaffb53ad5a32336fdb2b703785ced10fd0e6db94dd1158f071367fc9da3de372cb48aea94c74a0f33a4febbf7ba56d69843cde57a423465729eb288d1ed7ea9e56f1466c2bcf8d574547b0640aa83f4df1f4c758aef913ebbd24f02e4aa121c671bdcc7c7ee62ffcca1ec3ae957a67d232f817adaa89c5230eaf9b18499f55518a75c9e02d381edf6b370149de37d75846c330947e4b5d2aec5265c1d656a8d893a046db7cd6bb6716a94243a6473628839c849887b578ec1161bd136ec6aaa7b38a5e2d6cc4e5ae1b8dee0ed8e8a2c87e28d5e87991b1bed13efa67c072f1b80c89d148f35130a4b597e4232590dbd4f4475870457b15dd5896c6f7fed8d0fa930eb0636749274f1ff6320951ae6ae1f845d6daa8b87f5ebb73a16586500e57f871673c81f1f5da14196d88c8221ca96e4a7d392fde06b3edd1194eb3f4e5efdaef884fc26299449cef780e700a9e868a7fbfa00e1f3d0bc82b812e3a8f950ee32597c6fbfee59f29ad1b915b64272dd8fc7c58cc2b6c48b9cc6b4a1b1c84436d6cabbbdf14184162163e9f393a6f13bbeffb52f25bce468b42f41d048554b488b67f0d0cc8238d16e30dc78574ba34aea0cd7879889d397c4b2a2a32ab0f822916d7d5e9b030c202897d79fcabc621aa4b62a5ebf9e94db52fa35e39d1ce06fc726b22ec2b412635f86b18ae629e49afce6a8a61ee463f8b71dac12933b9b1a7d09576753d742f3030d39f9cff7aaec59b3e12fa477cd22b17932578df9ded382d0f817f17ce5e9f48c31cf886216bc47597bbd5e975b4f14f4f74f47a5319b2cf74938ddae28f46f4741fda52295be5ed9a18d0dc0c970e0f2c189b1cb4386d0fc203c7a5f46d947c1b36c30a1eabf567e97a4e85d8efbdaa13ed523576cc37f0eeeb23bc6607b1231996738efa986f8d212718ceca0b95d8ed6b80f3e89172ba60293cfbe2e9525ab089f9e7d3dbca81ef5e8af2e93b8b9957f46d0c655e5656deb5ac4d98a1d2aea3f5c729938451a616aa4a9f099e75d2376b0655cdf44d03647983cf97f89d88f4963b5c595044431d3bd49ef56cc391794cbea39de0a018a6a824c404bc81140b6887bc4a53244ae798a92d6a5041a2e827ae5832cdbfc60ec1e5c4c9c268d1e8d91edcc489a301efffc6c832b21b8fe2b1ac226cca29c3b65e2b79b698aaea0ca603516917a04a341c1afeabf971ef839be4c9b8c98ba145bd08dcd98f9f98259d5352ebbee2dc30092bc445fe248fa14aec4d06602b8c614e2576e6bf8c34f783dd2da00cd885ebb59a607d9b16920659fc1ef238e619d735bbfa3f4b60a730f96ecc9503d6cad70ac981187b5d410e7b41d9117bfd87ff00708c755c0b21a47a4f29a2cfabe0a74beefe4d037a5889857508943f853c4ccb145b400f393d5e072543cdc35e50d1a25820c09992a88e458f5525a059a30b735cc73cd54da4dadf3a463a3a9e24e272781bcdfeca02ab43d7d4706912972ae9b6440a6acf0b62e304b33bc8e17f2c21976cc9afadc6e3a4bbcc5505ab645ffe3ba35c77682afd8bc2617d52514f5a3004225b85c68a690e7eacd845f281a2d137b79d6beba2cfd2df537d73ca065de80b305a7bbd138a3b925f544ce6842858d45283efe6450b0a5d6a90450bc9b021d48b58c2ca01b7fee4391f17cb21760d3f710c08994c3bff2cc543fcfff964099039648eb6eb282480d075efd9e03de66ceb57dd732ebcdc12681c19ab3c92c0e961d8e860acc41bddb5a01a374c8df5ea9091c3924df6238582cea5b40968e4f2ea2dd62aa61b41b97585b4cac83425e0f25acde2d4831a2b23a282f923c6e66ebc8efb0a38c04e52f22c8dc6dfd0167d7a375d62725478fa8c2e135fa8366b9b1658578a161fdb40d038f724854380fe007bfccee4f09ece1a64bb46d65a260a14c852b9ded3ed8e9d1db9759c7846560e12507ad49ddb034ead459a553350bf785425eba1cbccc394614327acec490f2a93d4d736f595dbb89a24c8cba15329bcae3eea4b3d969a522928fe7fae7c8182e93416f40dd91f46ed516d860f37ab75ba78534c38d747d92c95566524352416a3e4a86843dee64acc618d775261b1d732e0d28f73c53a359f467955707b8160bd4d8f46eab0c99e68f4277237ffc6f0d5ce9b8e0e91b9395db7a27ff1ac1b479caf838f36258f036472881a53599c5969e1329b820eede84e752128394d62431a83595399d8023fdd9f6d3fb64d62b5005a6968d3605d6a782a7d0471e2d5d00ae72e90c92025f729672f2dace7e14fe61e2365f96fe1e2d37241680aea047adc7fc725ec497dd1cfbba61c99744f8a3ac1aaa57801e0fd704aeaa0562f78a8d20beccd85505fd7213681da03bacb64233a63d49e192ac7169a63bb3c63013d226216b8bca85abd2c2ad4eef598ede5986479899617f77c9da3acf419300dbb5652d7b344547642a6a13d67efa4a72e3bcb8a5936a86f1548993902f027242fd76ff4424a41007b4a0fbb126fc58f180ee5ec46c3c3ac443c371858a00a334c4e807e696674581f96d81c89e830d314e0b6851ea9d7d2ce518d9a553e73f8fa9f69238bb8a52c908ad79747a49459d1709ae9f63b60b9bd95950b69f0b48cddaba7b4eaa24a1f3641c31bd86bb9ae4417ab84d62d6c14069962ee95d8bf749b2b7465ec51ab63f59a6b3b319b217947f67c4611d0fdc5fc0fbd899985766e3693daabe4bffba19ed4c5c8459a51509cb535749e64050cf7506de5e63b7debe412b30b1a0e63307d9f0628b4cc6182fc6184832d75d34d63631ee42061727820b1f2a04e8de500a8122596eaeb73215a7744fe9a437a6f7703d8970c6b5733312f5f4615b6a42b880fc2f6d3d14cd281410c38eef392bccc0dbe9302d4bd43b795ffc7b0fd8bf1a10f6f6b2085845af154a48a7a70b495650b78860078a64b548075edbb2122bc119fa26eaf9098b9e8e3beaf33c455c572004da29b2894105b981d2f30967ed761dbb659a694e7f6961138ff19a7b609d08e00bcd0aeccd64a2733ea11389018d9f7839cc51eb16cf1a52159b5426eef24d42880f5af9a039b1558763840deaf65a28a08f201c366f36b28ab4553f6d6aa70b7bad20516ad21e72a3c4f715ad17d78e7803e041162eb546daf6b8758db40891f69efbbcc52ab4867af45f43754842aa04cbf6c784ea2bf74a83f7b1265b8d6afc894a2a62cff627c83cd710d13db85a96e85563907dd367c1b1ec67a54e278fd880f166a4ddb248552f73f42e519dcc12371626c482de2e29b013e6c6b3c34bd80d8571942c9e3559b063be750aa8245b29970a343a4fc47fdeeb74e0d7b0727b045b164ceb62993dd1f74fa79bd066f9eff0860759bd39ee504233b3ee62ef3778b5b9cfb574f97bf5bdbe96e5658b4b995c432aa5f11ac0a5e0d3d41a1115dda2b1ead3ae48fd3fd0f471c2f6b972658ae835f7f25942d548a3242acd0c9d751ed85c10e039f867904fe54066015974560b892a0fb03673ca85897280bac7e993164e83c817e2336e1807c92e33c991dcbe9ae2ef8ebb6e9bed35dbf3e4d9595807672b8920738d03a0d38b07476eb45102c48ea40dc8080bbadff6f17ac08041ee7e6522fb29b8b9b0ff980948ac042cf80dc420e2ae65688f36926803c18c0978cf7b64261ff5966a609e804589079b1776bc129d7983066b34f9204a218e19d253dfa970576dafce8f16dc51035e8f1c5d42f495f1fce24550b65ac65226588750b5f74ca82dfe7ba188e932848592a024c7d047144f646bba2e201ee8e3f4b4e71d2fdde58e870dfc46b99678b814c81755f025eb6dbce5869cb6834d7460a32e02029cb723d38adb942418acd548a9c7cc8dfc472ddb09b82fe2cc66f09449dd29917ff20b924c51736cff7145f6700187d4db40567625de8cba451c59d403b37a980e35f429420136124e15193c73f4f4a870a57169cf446573a0b0140341c6a0009faea82ad587ee5401395de0c1535d49b91d904052d3a6fbcd69fbd463543026489d47e3a79cf70ded35163cef2cbd8436f247864e491bd0bc15e827ab28599f9b2cc16b4bf6cd973cff74cb51d9408be7c2467534cf818f97d92ca5c5e828633ed6b590b15209b3d522bed89cb7f625f71d2fbbc7903ce6c2c99a30c138bdacdb7ca46c06b33e0ead8adfc5679c003e965d72bdbafbd54166262c3ba3dece2d7f021128c58c0defd6cf8ee3eb5fbc8dd034245126cf145c60387c5cba0c5e08870eaa93d44e3f747d4960c9bd9919a4dd2a5e9e0fb3659e1cc9cda2bd4d5f3220aef463a67f134729060e3cd4a156e5c0a873bd08beb2e3b5257c459ab3026772e30f763a6f1581e10e1f2462f8ceb2704ba5a069908d1814802654ee7e2559653c15ccc527311bf473ca3bd09edeee8a34d5992e4bc68d7ddc7345322b4ace86f6fe46eb441a56a2d39cc4490a0bf61e8f1d0663772adce97e2328702bec84f8a7b3c082cff677d1a2defdd66c2a7545271e26830942974f6adf73c5a4a8b2eff375f569e21d53f4a78c81937fb2e09c78c0a3d8adefd7a215314f38b817276e30cdcc8f8ad134ecb65750be15d928cc5650f989a49f08075295d0d82d0236858442a2772925418515a21dd7ae0eb3e460ad09ded3043cb7f2f4ef21f57490a75fe6c493552a97efda3e535e3ef1518396f19023fc337a80e5eb9ebd9db541baab13b1ecb20fe91207e773ade8df09a8da1ed06dcc443fd1531db4f2a798005a2b73ce96e09717140872ac0baf69113698c07a725fccae0fa36af277cbf5e796751faed2fbdf383f68052a756bfbc55c35898e8b232b3fb1c707b6b94722bcde5e6f4b395831bcdcc7b5e0ebf9a0897996925348ebd4737cca1324ae85af96095b7cd3e4e39d43256216fe9b84a8638b0ea13f490db198b00f4f0455cda95b7085b1f00e59d270251e5525df84f5400d5fa6406c8dad6ad81517ec0dad381ee19528d6a64832b58bdeeb6421ec5c340cdc9852da3d5482030f9498bdf6699f252fc8364caecda33b4b0a908cd3f17d8ed9ef812b6a922ea62c6ac5c021d04bda1c4494a858aa181aa6910540dd8215f17d6af602cfbe664ecf886269533ae8afe7b8338e3e08505896204cdaff93bd7a37d41d332ccb77f45af543e1ba86f7da875e5950ba8ff5bd6b84a685d7094b6f75ae025ef431930250bb374d9f04f65031488b987fc3a036fcc32b0ef4e9bcc16f2a0e72fce6a4c2a84f51c8037df8427c1716f8e3b10a002444f9ea2787e5229d0d6b673be0c949cb9ca273ceb3b40e17fca6d25cc1b70723932a3bead96a5d9e8aec6a06fb5c96ee1feff3d193bc172d21c9ea1b1dcbf547e630a6c6cbe4f5abed3a3a369f7808ae5e6987ede91d9fa81e0d8319618810f23592df58a08f56fea8adee7cb0c42d149685fa40a03094cf6b4576b2281f0d4d92595658415f60198f6fa2d171fe607fd50ebd1cf001d91a953717098f85394defa1d488b464530e105e3a4b21f5338c06e6791f924cf80266ceee76c2e8d9e227b55a725cc2a56ca320ff2660d8c236ba653dde5cdff50ec02a6127c7cf26977b0e77de75d051318e4408172bb17f61339d4f4cea9177294ea3a4c542aa2e675963e713c4db8695f63c9881b3b52f95c03173a44a6a5525968c1fae41b668f73efa838c8b21fa302ff1016b1dfefa01b763f021dba5af0a9fd12bea48844597f00aa82b08c204b9da54d6597c10717436bbfebb35d40a5eb66263e52551912eab67542ebbd4a3f3b2f33f3e7c21cea628d62f72b551ecfab69162e0d10114c499afc9b6ebaac8517a2dd9aa2e45dcb8edbdaf305f7ad09cab67f5a294e79a9a39906712fcc4c1cb3f396f54dfb9e0276aff081c72b000f41c10205e3039bbc84afc4d97fdaeab1962472210df742f6fac4a8fc2ca693beb713d513b1576969cbc113260e70aa3e4e7d58779a9185577df23c4240fd7df015eb2582b0f4a002b7691f9b259a9c9ccc9ae9a9884664a9f418b13d3f23924eed97ba5d2601c8f941157ab8f9d0939c228703fdfe41f736fe45fbb8ac92078490996a5a1d16a90ec2e8d91c0a06ad1099596b1160aea2e562e1d3265f9ed30d5241e373cef6ba6265118759f87db888097bb23fb8333e5312998337c9f452f39f77e25506fb27cbf250658b6b63ee9fe8bc5361a25bcfa5acadf4dc124d11c6018a1dd36a51ef61d9b6a2b7e99585ed3b1055715f272c959bf289b62c73ad1d4820da8705b444fa316b1b4f8395dbefa9cc468dd8f80a1f859a6206340d5fe40c7990808b9659f69139030d9fc0a8249d002cd387fe8c1bd278f5afb043afa0c4f900a36938988e6dc24d1aec49f72170951a1ceb739a1297937eb6c20c35a5661c5ab598c0e97a177cb754c874a75711ba11c8169f67f1fef02f7754fa1bee37f737e5b64ad6d50efed78b9592c785bf3db52e0256c5950e43ea2a28696969213df5301f5e63ba675851055a1baf2bdbea5d65096b10dbf78c3bc040e6b45bd82a8f13c3b5d02a04e9f9dc3aef8f869f9cd993ed6073ede044c06b8312a540460d5eb6ea60b136954dd992e6b80a5d4f8a50fc94c3c92195178e4abd9d25e0f8d8737570303397859a761d4854b8092844dc42a715efe0bd145221fe7456ab6316840a8b32075cb25b01e075d8e5cc01b134b1b4d7d269a5a88bc0535144be6eccd69d92099577230cd93463142de01aaf343b8b2707df860f86e1a30c272100b6e7569483e26db4dc89dba80e71fc019d526005a075ebeb767c2e08acbc6225d347bf6ef2323e7d6586f63277760f8d64c24b9aa0245ecd439b4eeacea4bcb6081b8f821bf9350f2b015efedf0f24dc27c1635031cd7db1a0ae6a394096be38d715c72ab392149b22858a94730e58b00e475081df246ff907443e64a881a2ead843e29d2b0db096fa20317d02401790d07fe53f572df500c8d51cd24402ab79395932371cd58fbc67c58ca68e7ad9769da16aaf1934bb111a73636803b2d5cc798763193c287d22048b2884d5d14e9cb100be5382767fdcfdcf52612e71446c52d3ab7ddc5d9956142ac61bb7efc69935c52225d35af34ce5178cfefd3c24a7517401e93761c8ed5b21afdc9400f6c83b9c367fecef926109c81bfa109797339ac02397930d8998e2ea12a2903b5e16d81c0efa0361bdde5c67139efec5c454fede81b88353e3dba559c3d6a13a3feb63d869be3139d37037245da8b9d923df33c1669e8f795890612c532560ebe132c970a818ff5f42705efbef0bff0ab367166ea749b4901e228cdc9dcc8226e03366003c0463c34c154fe69bed3bbeaa7dc4834427c1fcbe35635a2fb6dc8cdba0f9aac8f29ed3b966243a95dfad9cb0f505ee3b5346e2129868df5551de0638ee9df84d90b0b64802cdac870623a59723449557ca4628b3cbc17d41c367c178eea41110563491b953d4e607fb3dd8696b13054726a64f2a08492b2d99d0ed996c8e455539d1a574c23c9e6ffe6cc0187fa1b53fd99abe2df98243a46065c469dafb28bedc22b3a68b2aaa60d8b7604ae00e4d47b146a2d0b2adf9ac07ee47036e7163b79f64badc5d3c988cb1af33c0bf577626064f5d98fad585a34ab8ab2a4022642441dc6140a0cdd9e73309a0e2db5253b2cf1872564f4ade4bc5cf84b42c77c56d3ddcbe1ade856d8926195e8ce30f9bfb41df5c1fcb31781c07471519b8de3f9b971cdeb285b964a3b9b8c7848777ecc7b31ee267db674e2224e12eb2ae94cf2f7a7399609a31f50bb140e17ca16c8a54b0c69b4c005baba0d20f38dde003839c0d7c6bcd6c754b14e535332a881a438af2c2fbdd6c9333a91eff5b9738d35720ea9ff756786ac85827eed5dee5fd640f24e5f450ddf1ea67cbc1178207fa3dff91010a3c2042197582b2cfccb0f88cd8a4ecd40e6fd52bbbe1f93df2cc6d3509939c3903e1a380680d87db3ad66d91c2de12eb4ef40bbe3bd6f5bf8d71545c7e657bd4f949d2f9a4aa8c9c67f8db9805d300fa83c5ba2ba34c63ca422880622387d7c87aba8fd8572cb17d6e60d474f78b11af0d17a525ae6f012a87cb2ef010fc96d9a21983fcc0da92870f6b6a681ba74ea879b2a4fe9824683198f1623be76f17bc05e3b77791a8d6801c669a78986d1e3a1381901f3dcbca494155cc57de051fa6b8b576411ab78432ed51248db0efe779c561f7a49e11988ac551581f78d8ea0a8be115717d931","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
