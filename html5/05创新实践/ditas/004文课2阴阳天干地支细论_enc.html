<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eaae91b5683ef6855371d094e01178147afd6da2f9ef53a8935f8b5347c267bccbbed1de1a1d43848b274889c705a35be8568c403e7bfcb3960c89631c722bf5df827e0eb510e270924f9eea2b3e9eaec9858907f5c1eeb741047387f8b773fc3939d180155b921b21472bbb1a9faeebc2ee84d33137a80678c1b2b2aa9960c702432bbb6cd28d2866c1bc5a2dd52764741ed999eb84b25d1c2dc08d6ff107ae9243801762e414f8b1aaf3f2ef8f63e85b29ca38f4036fc10bf350e0860f8d51423e5307fedf72dca939efdbc3bc868621b60b7a8e4fbc5ad93773bce440080160260d56421f1ff7526a3f6e2aae9a6db16746c309e6f7dae7c68d32d58867bd0fbb00a9984ba167f109e9338417d5559b813a269fd60df1bc69e69c87710d0c0910d89ef2e04dd74087ff264946283312a893ed2157ff31383aec9486f42ba8f296e8f595790baaca4b53d1402698bcee325bc3ca4ac151745a20e46474fe6e1813c1c1d0d4fd676a201f31186850afc3e77b4b8fa0cf8c90f6f104afcd04866c6b000b453f5b01dd94c9d437a4b6dc57cc2cd5449aa0e0c4cdb4fa3dc97b7d3a748bb66aa410c68e480775dbbc44aafbae735bb8ce65b2f08b716b12eeab19cba59532c0805e78b076d02c38ff9cd204334b88a08f15d89555e0b49bb2d78540375c73f60f238a7c6cc9e1788042c211a9ed5711d1232677a7851075c6791a517cf3c2e79732d7aff2613849d322759a1cad0de3969056ee316fa67113ffe4129756422dafcfa84ffb57bb4e8752830c69bd88ede622675fd3d917a9aefa797c86b739fc726134ca786e42ecf737ce7e455015bef3c2825406a0e3c5638c8efc6a0cb8f1b13cdf0f86a9d09840338d2d1778be7967d3994a1ae1739086c2e3c6716d6a464bd499eb7a26a2b1a0b8b14b394356962a5f646e087e90f733c28b4ff138b8d64a1bc3b0b9acf54e7bb5d2f574da0cc2b83115d21e53ecde83c309d056a6ee0f0fd7901bba052f4af59257fa2f89ee1a42b73b085d2c284e07cfd12012ff4b342287aec3bbf2dd537aa7afe9594c772e17b9167095870df191658948d85029e07810336ee403061e0d153ef4636bb1315c9ebff8aae37e416b1fdc71514babd219e29d5334dfb6dfaa7c9db0c7bb810d97a3efac27e116804b9e80d1ca2f6871cd7f040f1f039bdd96cf0056340dc480860fd5ac3792e36e4a98c50faf4bf7a874206acedca7b5238d32a33306e9c18b73ca641ca316a6cc5e5b1be69cd51462eefa317f0ff6d80177bd186f1f4895454d128b95f5c3509a2d8cce28f30ced031d7e084a597e163dd1e3037bec81850ac9ab48c75fea4c67765087820a53bf0e530f4ceea9cb810176cfa174de69c3cf38b660b1cce88c4df72e345b3c86e6d0fdc13cb68706651f6fc8950725d6b2abd707413e4e48dcac5243ffdf410ce72144f4712d695bd549c955c266a5123833d3e8e9a51d7b2e770cd6e85f1e10062f3b4e616f80a4cab364a8a8c5904ef714f8cdc4a4acd5cb5b15adc76bad767b4f8bb49975c47bbde2c0dc4b854bb78cab3bfad3d6ec5e3401a6c2f1abb15338f8503356c9a5506abc68da0ee776f4685392702a68578331eca03299fa71f14e25b46515033f302b1ed9be40d49aaea6c707f3cb11dcd652fd518a8fc7af959dfd476c5e39d5c55fec9dc9a71933a74f9867d9329247b6eac8ba927708a31a3f6ff3c0a5ce933031830815145d47e8dd799df3cb5d5026f4556d9f98912dc9c2fbcf3ba021d558629c54df95af1fb4f0f9b2bf269bd6599f55060ddb6c205f7ebd2b75d0ef1c8a9e528e2894006d5a7e38d6e1a4d076bcbc13083c794a190182ce1b71b94551d4af83d04d5a1aa9505fcf659de7679f0051002c816315c8430cacd4dd12cccd008368ebc2fb9e842a30d89b53654ccea2bced6772a2b6e5890af396fe50c57b5398aa201bfd20056528e32b1cfdedb8c023355e4d7cf9bd58a9554d8c76e9e857522cabc27c2843b30dd24fc41844282aa5f0a2ee378c51a9a100a562c9ee5dc41f94516a02e5c651577ad315b6e4d85eed630fb94b52210ca348d1ae9e340490d368a2aae3f2b91c9275a7e3c2c6eb8f79e32ac0c1f2d7dd71a2ca5fc36636c1e9729a3aea04e339c095396f6369f0750501767842c209824ef5c8d95f08ef9c6f6d02e36dcd166db85caa7843d46911a7c2d472016481e00d2e9732255628c5c08c38bb74babcb6aa03cef87fd2fdd9c8615e34f1de4371be90dacc9c318b8d697ce6f8dadb42c4a0e65b4884428e1d2fe4142d0ba1fbcdcb7a2c4fc933842e8d17378d18705b569b50aadef07b3c8c04257fc521961ce291bc8fcf6547d72b7dc3e50061a06a1cc8dc74da8fb9596297dd8892f40c5ac0f382860fd393c4f6a170352786dcf83f8214e94a730e9acc313e04d8ace5672999afc0baef929af147f6a1bdeb6402d71568c653862f1fd8cde8c689739365a2314ff877675952002d5ea722b942fbc4c00060d77f79cded4380d3b082e52c1349ccd04a63d5a98ac9445942034d47b57a981627713d71eb1867ecadc985878326ef393dc1ceab1802008a3e0d59461123a4dc4365e722ddf1237eda912f864c14a8f179365051604a025abf3ed116ef9c258a78191bff66ada8abbd4cabcff6a335adebdf361f928b6fe236131e9292adc89206584b69e37ea2ea0e21a6d78e360f619e51d8fe1658bfddc013668d53740a38134528dcf18c9be6d0d6c0cdae44fdd830c1f019b201c21a1dc4f47696c0cad072ccff67f2504852372475cd65888a845ec801e3c5c9826c15c96740153673640143741bc1c547eb6aad3a524981474d55149ed0728c5f0bcd5f3e42f34bd521004c6e7ad44789aaec277cab6a0029e197701038102686ecd36fc19b6d8e7b0a3ea405ba612010c2c29e07cec81f57970950b5ce6aec6baeefe51780404e5da5bf0d2f35df92c75527077d46ba1766010ad816be11dcdb9d058c34ee147c153d7ae10e865094eb837c53d06b7f14712c9e0a72f5aced98a4b3121ec8220fede665cce34e18edd8d8344386efd2162fb3422b711d484c14b4741ab59d2c48178ceb8f09df512f67342e26878833f1fee3278a3ee97b43745995d26e08963a43ea0fb81fb100c239718ec1d12e5b0fa16161d85f47352dd7533918de4ba2da7549dbc87e4c055333af9d9f4593ccfb005b1fdc6dfc7ad042e22aa44ab2fd59f31ec8a13ccea055c2aefca261ef94ec4fa909073effdb61096a8b91393def64bf730a8af51cfa9cacfba861aee3bf3616457b229340f00eb0e6d24a653291f3a0c5360f7f1cd58159ee3d2d6608e64c713a7a420160890426ae60d45b73d0dff588882791007240f20525f2e9038bfee8aaddf2a0a609fdf12bacd3e3437e38fc5ee30bd27f9b37ff9ba88e7db480237585f5b2945535700e35f21b44f3a82c7694382a487d5859fc2797686a1a8df3df97d0e7221c64859a37aa7f9beb968be1e57117c1d1c540ec4e9a16629996f1fda3177db9a8ddfc1ad3c895d3e667795f7bcf072d8cc9b32a1e2ad76c72d6e736c06f5563cddfacfdea6ce9f6c6329c473135e09954bdb7b666ca9076896e267862ccf5854e0aefc9731661f235c499f2a1aabc5e656459af095c583fdd6a23cc7b5b4a60c45e0f804013864e682ac1d81bb8686a4dadf3c4b8a5c6a41e6f9c56d0d2eee7404c20bc4c383de312efb11e23f4553aae61db52314239b618f677a94a06ce0a8faa8d2ae90046e40ff7073e37886db0a31a518b8f6fb6cff4342a253b94937cc488ffa59f0cd21f679607c04262071495f247d81f792565a4e52fd16fc10fec233701a01d36a95334599e96ae5efb2f5be9ba16ec93804a1235c5d4eca325765144011b790ef55155cdc9e881ae458ddd0231ba860b9e569180472c6787e43266f82aadf52338561f3ddba6bee11529e9014945dd98454038e934f4a91e2efa7a56ee8d636af1c5af524fc19fe8de270396fafb233a5611a4a3281125a47d4f8acef28d07d9b093866ff311d15d8d3a0416fcf489c83dd33b61aafe8d08718aa41ba683e4017f3e3bc6cc901694be2b21f21cb9055be73fd12837aea62e696b35c773084489c7472934a1e3e94671cddb4c4042d6f4f8995de547e648b1edc85ad36bdffa9b8c2edfbec61289988131e8a2ccdf8c9c11061aad8481999bffbb0a5e435b0f44beb36afaf004439ca9ea65869703340e08db89e0ffd62fc953ce58969a13cfa3c01ef445f502d00fe8167fa0bfcbe98c3c6655b3c3685dce746c96d6b7fedba3e4511db4d041c05b4218e4defbbe5229ef1332baaac01139528df2f90757a4038aeda28bc306b9a9e7ce1b75dfc1aae19cc8a76ef9cf5fa461246f5782fdc3244b8d95d703fa344bcdd5f6456f5e86d5e4f0070afba1a0886125f27faa404c3122ed3df072b2c2533b2e11112ed650c92504d5f747d8d3753cc3f93c390794daa3e29bd182b6ce5f4b2edc78170dde0cbef6d7b255d6ffd1f898ff562f1fd382b9bc13f5e2eedf2d8100f619744f9ac58abd22b221cc94509c71e07251cbe6f05cb9caa63e89ffe90f3ad902797b451075bb1e48c94d608516ebf3cfd8cf0c23555ce679516c0beab00aed59c4147fa72c33236f57a083b79f50a187d7e6bcfdfb0cd7dbdbb277c1ea68c6d6410d700849a511d87efb416e0d72903f2e759dba1f53ce080c03f50fd574850475672739e459ba660d8b32b5aefc48d18e7ff7fdfc149161e34525467b4f7be7c12ebe0a82414b1157f4a2c2afed7b697c4925f4700e90385b6178d5bc6431d0e77e23cb42241072e2ad956931c31aa6f4fa98352c2607f4d034bcac23016ba5156d927df05e90850b504090d79a87650ec0c757cf979a33da6c6fb008420f4ba8ed1056032bf226d9cd0ed5c8f44367af2d8eb98e009cb72799fbcbff8fee7a8176f4fd54bf2ecd81e96b22214d17d5e4d42a5e6a90973dfaa0812ba4fa73a8b72df09b42c5ada27d1b419387769fd62225eb99437951c629751ff7011fcace29bb29d585e5ebcd795134d9ffd6a15b22551a6119a79a160c94f3602df2c15f86e8330df3a4df5dda560317db4e3dd2af73e4fbbf3868e72c603fc5c9cfcdb801fc4877a5a77d04ac2d097f2297fe946cd38e1b56fcacaae4b894c6e455321429fc0f277c7ed743528fe62647a1f7b57d52feca50baf072ced1be2a749a5dda3d3c4a94460d0d59e9c1f1e1e55dee48b13f6fbaf75b063d06024e7fd49f5171163ae8120f91f8f1c56fd4ac5cb4aa3d78d47af231834fad90fd1026a857bf86a8b14dec627815fc4f477297f518c8f0a0af6826c2ceb9c510f30fe952b107d20530d2eec62ef15d8a5ec47e552826e79183577ef2646c769cedac9916ecbd88f2afb6106d7a2e59757deaa27d0a42f20dba340de1d8f3812b3e0740a11fcf494abae87405abc032b791dbe46a9c6ee8cf8eea315fffd3fbec08f4505d557b21979258959606f92e32a9e8d169b5512f227e8022814af7270e94e3a671a53d3a5d18d9e6db2b0ae7365ceaf84c949e0d5c19d5d8f64366b9078d077848655e8ca3f24441fe6e683df5a7b384109603d03437584961dacbe7704ea9b6c0078d5c19a1f1e0d700f2b381460e3d49d093c6714ed1e23902946fcd1e48ce0596ef80c9ef414ea6182b19b2ca1bf464079bdc44864fed0687e7d8b78bd513b681e1e15cf504075a698122734045c6836ad5f2385da4ff94faa662cd6759f314bb03c15f76af524c3c464375cb77faffd19925469d2e09333d0c9c20e92e9441af87adaa0ad51d33ed30c2dce9e4883ecccbed1510edb9d0ced70b05ed77d8d639ca640185a14d510394ed49dfa9dd7acede5cbb48fe736a95fd3ff7c392765774b1c26c43bdafdb8596e590212b0ab37d609d998a1aefca0b8ad805bcb385a973a58e7aa102b0fa264eeffccd2b8589b25273d018ee8496a404218aa61d1a17fcf2cab89c3bee49cf0141107270fcef79ee5c93372e78c31f8a0eb57a81481d581e408c6d1430a363d0598d000beb8c85e3bb92a0bb1b053b0247980c6ec97ed303fff83b3411057d9a8802e2d0a08d71ecb9db910ca40c7c1795a97e9171ed35b5b57c976691682cb63a03af83a7e612bc60cf70c5974b2e7be6277d1a99f4ccc9ac8784bd839d8875f57427b379dd6ba2eb37eea5c697ba46e4d96d6a714a2381104fd2212062828c1280784f5b60a2efb56c112fdaec2d55bc824ad8754992da0fb8d82eacd304a76c080440f8ddb18eacca054b2b5a9e59079b593aa569d3ce399772c92cb1982266f736ecac0616f7e5b3e89b60283f0b267c77ce0e847a866f16ab9f95f3173c1a99bf07f8e5eabd29ce81236b72444c917d9949e99feb094aa3ffd0fb0e4356a20d016091eb88ade8b688aef69174b3acdf748aabf6c0ae8405c40693f237dff7dba4d89aa13ace44a77e887053484a161fe5dde286132f38da64aab1ad3ea4b11d1e944e0d4ca7c713a435e262d6827f4418dae26862285e343281c9f63f511cefc267483d6623a4c5bad6bcaec5db8ae23c113a29d789aa23eccd9cf9ea57c688d9a9cde8d72a08cd1707b7f78d8ceecd2d680ee3b818172e6d28e9230d3b864ea10945ffbd754a7a583fab9c6b342dcc09b3df0d526e30ba5e97e821489d53c3ce71a76f5c5931ec8afd2955c3eae49703eea6c23218b1d0afae8e490e8c9615cffc57cb7b4d309e00e17c88469d1b5f9546fb5b106b75eee98667fc8a00ff618e1cf89b4a7b0dfd2e8310492a01161a19106982468c5e4a7e66f710117e49fca8653f2b5bc303970c805b1c7054de0a1d7bb84032628a025bb1a291a43097e0f7a67285b0ad82988c34c2603f82592c30ea37868a3abe6c852c914b8dde87cc4d98e38c85795e22c9ebfcd3e09a92fd19d7d813dc1e9d1a6bd87b75845d662bf8fa5e88f588b57121c5f9d0e7053120bf67f2ccdd4cbd7d2f0bd3fd1d989d113bbad3a76ab74f33be411fc7ace131664de70c1e5af7de7835d251156d91cb8df10761f1f1a851616cba619d1407ee2e77c28b427494dcc93f87d715112889108697c54d6cb53cb0c931496d9aacc23f0e24ced0621c19ec4629cfedeaf64192214add3b19b19c6898a3bf982ae16c6413f3b5f077f2539d9f301035d4518bdfb69253628e0a11142f9e1f84bab157b8ae0defac6a3e5e2e95c56675222b52e12c2e6e033a59cc42ede840988ddb1576e2b999541ad968a8828100db18e1848d3550d8554669df1eb6e0d4f34929da774d09288b9e550495158dc405a1c2ec96e494a2c4b488f7926ae76f9f33831bd635cec6d3d72df3624040971a916c85ce9d4b1beb9d4642c1f779f5cf564a53b70f3a2904433e27b94cbb606d4fc5d51d8a99b28b68200efa17a84452260663a1e729d928cb4dc883a16ff475273cef55ce6b739e551e977b29f9c8334686200b129a6c74583cc4ef0d47ae08d37a3b7805c246a8069fa1f82a34127eadd1a87a4bab1b7d44be84cb213a8589f63af2f4f3e0e9e7c48d6699e080e406d1719f8bad288d73916d99ec7b7feb4e59f865dfc021f9ed62109bf0967af62c0af925530769359ae9a63483145c500cfe5558e7aec625a5e30d525380af6a146ec903b8787bc57924f45fa8fcc29599aa89e0b5f8927e6d13ac78d00073428f5e7053a920ea90d745658df526a263eb62a4394142e65f078824e44dcf62f8a88ea4b406481d15ebfd6707cfa2127b01ca13fb155e895a1b43877ed40cf2a95cca913c8aba7f5f54436971948de448bc47fb3a8e65efa0e76a8f1ee64559014a2eab165d5cb00034f6b66f9c05d563300b037934681fda68de0c622e0d2bd0126c46a2c1e40e11ceff29dc3bfb5748db104e913b5b36358b03979b7c4c73dc9958d473bc5aa1f4d22404e5d83254d66b9d2b797f47dbc76a2ba7905fb1904850b58c97ebab74b9f6c3e5b7a5f880d3f7395474287b13bb2a41fe0bc0a6c4a3fbc5bdae41f83c6a1fc166173dddb04a740c39ada124b13e26d918d927f22e134de73416315e4167ad89fc9a6a83949fb54a98d1d6a3b7182c01a62299ba199175f8af04a7ff309ef1d1c4f57fdc9bc8320990bc05cbb565c74c036f2efd89d63eb16aa6f038063e291782e1e2ca98d71382d9953a0d45ed14b8320f0f8bfd058ad7abd5a8ed670ebab5b6493103c8d1451c9f6703fd900e754dad8abe8efbe80c1ee39d44245fca175b177086c882ae64a5882a5b23604e25735c82aa40ebd7c5a0bc8d89114cda8a5b80b8b9b00472150375ad72953943674d4d36cc7a28666ff20d7d50c360a09235faf0d77a0ae1ed17ef5e03ee6b4fa982665fe95b87d02eb1790fc53ff15b91a33362ba2b2824a67e6c3a6f3290d102f1f278c728863b99ed48695da01d70c530058ff657db375595773a4307d108dc52c9469cc2163e5d14e005af5fb6be37f6cab842de4b51c025ce5ad60e1ffafd161217d93c624a2cff6c50d8c50d5a5c64298ec84e3216a3d8e078201d3592303a21e7d1f06983c45efd0601e6275ee3790e56b28156dc7f8f74a67c5628ef4dad12d5de2803437c77736fe1cbcb1bdc2e79f486a9d3e8bf73309b55f45de5f5e2a0c09ff96ba4b99de1d87139ce9e4c10110d1893b2ced1beb8b61f5ca398d8dee3d96aa1f9b0079b203a353e0b54ad3085744a354dbf45a64fdcde99bc8ec38e09ef225926480a1f60db1a119dfb3036035b8d314f1d177065fb989f26fb8e453904805279b1ef42b19a511736933feaf1341e37657353ed2ec83545ad9bdf2a375fbfefef3a1b1da5c0fc11ea362c98a0b46ec8fe17134cf878dcaac6590246e7a4bdb472e1720728b8f343a402745ab6191ccc47ba380a45d29d96ccd99517953eddcf9a1e9b2a239d79e2c69c76b369e814a4173a5866f3f5cc7fe8eefb41c1c09360f83bfc4e301b5e9564934fe686abe91f672cac552e53ebdca3e4680f47d1bf3397cdd503a208a893940ecff1b50652e990afcff7000461a13d9394f291865e5035de2ade24c03622660721481e6c325e8138042651aeecea2a3e2880edf125148a627fdd1e22954f2d53c901a6042f030eb05c12257a6feee0dcbcb5ad0f97e393f492dccfbabec1bd3d20321fcb926ffe529c24f373d2ad9237c8a523309a3469844a6eef778df73ff65e39dd97602bc68c04562b4df93595c5ac4b7b8cd32ef11f916cbaec7554971130b591d411f2da5eb74edbce986cabac869457d6a90079d5cb98b9238c7121dc767fc819d065cf6824fa423d040728d309b3ad4ee35acf2512b1f27d3d84032803a1f66b4d5ff2da42a7d01b56ab6e410b3669d2b8f1e300a42022fc957acb12fba91903d9b92e82de5ade424f2ba2ee3a19f2ba5644d36e9ac8ae2fe5e383656871688c7aadb08280aef16b393516a8a5af98e1f3dd268944b5460501f6c70f922074393cded0a96f07f1f02fb12b1982e17d6c62f0618fd5b8389c7f7062cd470e09a28058b5e40122d5c73252c3d1851213a29a9845e2bd7fb8c081c6295245f0f387283470f9ee2b77f641923910951fcfa0c6e19695cfd5c249d3c69dbea505dbe017e362ce8f633c17ad987897a9d30e3f70ef0d3c5999ac3e0c8f94c161e230a9ccd364a9c3980ec255503e3a538d419c6abdc353a2c6762c1d4ce7aa19a89368fee0e65bb2dbb2441777a9a0981126541dcaa0f0786a5583d59be37c37b7c6183175570f3de8c8eb2df2953710e5d5b03c7d28066d449fa4f4b02b0b8189f7864eaed316b318e9f97c994fa62e7066e3d49fa2c78ceff75535c90c3239443d86bbe135b2f4768891243bd25df0b9bce6b9ee9228fe428757e409d28251e153842b36336ffdf0b6fa487f6752ba37a75f053c5e4bffbc6553ae8685ef12995ae93e7761b48df804b4b6b0eeb4f32b9bd717bd1bb42440d898bbdcf8fd8fcd53a6512101a2a404b463774f032c7e4f2c1774eeb87c17387b850f91a7803c5138b4403dd30d51789d3689d71cc2d39601538bc9bde862a74ce72328ac92dc62569d56a2cb4f62e0c7802115f6ec1b39970d5cde35b075979b2f8b4dc0631c508d8f64e233ec2909908b052ddbc69b642833f057b695f39dc996d84e7df3e31bbc58290c4f0eed9ec8a58e47d9728801ab356da9cf2c66e32cf78d5dd8563813f94dfe9b0b0ff8515cc14d6fc0fe0521845241adead905f8b44b88f0c42d916ff5f4a45a83c8863458f06a385b7e3aa1c44cc2214e2066a414fb93c8ef1d3b14a6f2d6580fce11dcad5170792531772b82ffebde4b2ebeb5f759cebf681108440c831326d7f372f16100aed7a59619c0cf24abc979373a4713d05d441e9c1ce5ebf016208e731e7237923d2c53f083b795a6a2b6d197c319116f2adc6b9703fae1b41f87171ec63d0cead833f43e763ea83ab9ec10e286cc5dbad8e53c5044ed589279a8ae95549e98a924f3175b6a7a4c28c9bff7e3fb4299d30f1ac15d64aff4811edba840124bc634a4142ec7a8abb63b09d87ff287b97225666ab5b9f7b60a325682ce6640362d30498d6fd6c796b755a416185095c2882dd282ba1d0580f892fda688dec62a5f4d2081a8d0c578bbdaec135c4b70cd0d026276d301007b01521ce697bd067c856030da11a2aff4a5f8126d634d9fa9c52a3e013474056cdf2b06c05b0f0710096188a23adf8735005ae8751444f1617358ef2c5b2422922fdb92e2b51ae1b0a8f3edb7f227c0d8f5e0f9a0d4658a34323d0dca83f881bce54df226af35defdb213c1add5d7713fe75b835c01be325ec5819903a9db9340563d2f0fc6f0da67671c7a48ca21fb3247bbba50aec78216c5ba49dce8d9541bece6c70dd505d2f44b1ceb85e4833d80d5e139c118f75602af7603d2c85efb84c7e5d20363f03aeeca6b1ecc177484b3f918f682be59765235dea874e07d442ad84d9117d2a5eebb8d8259da3d4f42c6e776d19ad9643fea1546d4f9c06e054735f220d62f35cbc5fe79f883847046297b4290b6a7d0b88baedaab51cb7743074028464d1ea325c8f1b91f449f1401748180ad4ab748e9b25d21db42d6f0575369b2175aff58df749b228def9645a1025ab14e48a872ef8a260a307dbe2026a545ebe69918ee7440bcbdcd30423aa3e291729686f82372c17f5d11bcd171bf2901ff3578994a57d99bfa036e8f686482d2ef1073e7e700236ffb94d8bba8480a30fd7a6c4292d3e325ed68753204aebd02f8545f8d775b9012185b77a405cffe56f01f638a35df4aea1759cb569e583c650df83f8cadb3c6456d10ad0945ec1ec9b997447484efdb9547d4ed7a69d0ce0be575c87422356e6ed149c7a5dbab0af66946d0918f0c51933214f5581f4ea70c2cc48666ad6c25e71cd0915783cc8c9d9dc184ff6ad4491443753c9beb21429bc61520f1735b4df22580e92c3121324cd9af40e986c862f70c749b893a6f5911eedd1bc1ed5663d7299ff6352132d87f652cc5ef0bbce57025dee29978b55e8289b3af72e5f0be440c2f51c04c06b7186ca637d39049e7fa31500444628cb5d7075d825eebeb863a26961091b3f1032bc74bbb019f3351dbeea2d176035d03245fe5c075156d90bd1b4a69e25b54722737d6f65b169406027b025e5464e78c3abf0f54c8c12ed1a7e17016b178278ff9153f747c0b4577543f8a8da33d4d7f130e9bb5c27afa69f95f899022f905aa3b19d61e6481e7c032fe6743ae75f68ee57cfadec31c89d326c16c95e09ed1584afa80f72a7a79b96314c4ae5d39348725ff2d99632247147e73e08fa8a1ca5cd40709af5c9fb899a4c88688f643bdb963536622f5422bba0fd992bbee6cc88dfd606957e31f44f699c4a9fca96b58879375ed07ba2517522a12f18b27ec398ea9174d170e759166d63a4f8fed6bb692ac74b179e6b1a627595a925d2182965ae91c9e2f698b0159640092196553d47709263f4695f218ff24fef3e884f9383e4e477997fa3a393fde933dd8397a764823a763feb50606d6ad9868a2cd4576874e8ba2b4defb40c55abc4d9d43256cf2a7ba71fd7a88f88621dc8c13712929289a80581a91905771b5530cb4b03c7ee3eb1f820f8a2c93d6dc8c6c69c8b040894d5f0c5226bba90074f188685f55bb402419c157cb60149b9b8881d8d1dbaff979a23682f8a09f4508709bb86509e67099fa98e8782b6462c5a2b0feb6241148628056c35ef85828a49825af544d862c9d7131d602a450b76b91d63ee97ad63e43546d5b0cad631e24bc5171fd95f70fdc828b0c1232278d598e7cbe6714899bc84cc2fa2bd5fe0afcfa09e2a10e202e2fb9db749426ef528fb1ef5418a14beb28699eb3efd8ae9e0ec96e1a5e7f20ed9cd35b071f59580bfcd566b0558ceb343661b8dd0af10cd23e164f3eba35d273c20783d46280682dc2f616ae83430b042a76765744237db982b5cf1a0f946721785e3479bce2a8fa04ae968b236149e5123fa710bac947709f6ccf470ad33dc8640a979e740d494b57b41414aa36db8e3b2ecab5283551711770184be02485a3690a6e9af4995693888275ae695143c7c352aacc51e560802a599187aa969cc31267b47a56e133f532c6b18ffe5ed5100132a8869d935e534f879d555f5d1ef89bfd785c442ab3b3f8c4171cbbb438267f3facc55f81a1486a69eb0050347d5a0c9bd09aaa29b72ba2591e236f8d128e1c6d8875b13b44f6064739a56546c26b91e4997a856c6e713137ab33d9efe07cd3cc8801d573d2e765e8efebc90cd130b59d57d7afc19e338aba230b7bf60d016ff778e171ed2fbbc17faca62100dfbba7fd00d27fe692996fb5ec33f70497fc2e4ff96999402a3c5edd8245ab9e4ad7f242d3c0f3201a4502f8b2afe94678a137d32217a471cff0dccd01e40f6be5eb19dd30863b1830d2db62ef13050f3f247515eb967f6927ae4555f471a8b5457ae2bddaa9b8ab546d0cfb1bddad92b8d4795e82d67b4bbfaca122898f0e9e2e810d1a171235a1b809a723572f2ca0382d8213392371f9abba58ea20f1488fcc04a6386ae988146be31c0151dc0518eb45c18d5d58464794f3a94046633af5a63cb997a4d06992762490b68dd8fc4ca36eceb77a20d2129a51749bf23dc25117068c2ee9118b1a56d16fdbb91198e256e3ae87a9283da94c9dd87934c0bfc137f51a2d2db15921dc6b3f8b839e5172347a5db183f85e1b501bbba96647dab3901713cb9acc220e9179e6db411e8a1ef8e4187c240c0d66e53b8da77c52f3c68cbc257f98b908de735e414c62f5969a3ee48f80b9718cb42bec8eb97aa34175a14c9bfbcc2ad19a7aff561b156073af6fc90ccaec287a1e7699d226d34e7779dbb3ae72228e6efe3a0101197626eca6237fb0cae810a8163a90343f2a962972c66ddd1cdd354c578a2ba81cc044095eb1950a2e6cbc144da78ff4500e8a859f396737f8c0035e1b084d2e9be84d00ce421efd74c36e56727136cc98219c9518c987f6d730355872c942a5fe46c3395b84dc085774ba8715cfafc0d3c9781eae4be5acd31a7d989f2dc142713af9375d1500eaf3faeee3f577951fec8826e77186e5470144f2d1dba2a99636f1854db4d8d1658855d19ab95aed534f198c7b9159bf820b8bc87638e73e011cac6da81e42b968faee59f16bbe1eb5f55f1edff6d6fc5f841824bae16e5e6ea6e26f2f6e8b437396fdbf5e6f97036df39cc469f58c3cd7ee798ae6f2c17c580cabba045c875812dcd9b798d6ad6797466c7f90d7c856c15f189ab5e01ac0b8b50180665c8441a5504f9aeaadfa91a61fb3487664995b20e0e3ce8d58dd01830c465c1b90460028b400fe76c2e692ce3f6bccdb0ad11a88940f95428bf51b621e91e38a79c80c294f273df8daa99b59029276dc820131452287a33ab9991d24e55ccab24b3159c5bd90be6e36196ab25a554cc1f9e62488923ac8b4a2eb0299e77ac0ae01f5d5ce70ec5e1c2ed7c13b44e33c442285126029867951603c3763e372949f20f7dae301b7e9a6e11b6758fcb131d87ace2324c1a6e8df76e8bfac00aa0ffce84b7a46f8cc99325bacc064891e4083698944be2eaec3f7ff173a38d4dcd69093193b2df189a77f3e7b06f7e97f74a34fd9c5519089538cf142d0a5cbeb83432dad9041a41d55fbbfe79b11e6f7f66f871831eb33f93bbd0859d44c30b51c837401f040a57631413e8bf9598a494c70340f1c6245ef09ef5b23b5c4fbd52019b1bb1e107c6d2e5d72fcf0ac614a0ad1070abe9e8062741f4ac93ecee5079480052ebd62910f0f5b9b6dc3d645e0a94e8cfad832a71600edfcd793c7bd5239d1385c1f652c0ee45c6312439c2f3ab0054e25fed9b8605558e739a6666c99313d89d3b44c0c5286e6230077a2fd5cd8a3d7419dd23b3b865bb0d39974064d87f472660024394ffec55cdaf0ca21a0d44339f5fc51ca7c063a018f500cc40621c70c2705a757ad8d9b29fbc70b81714e3c358d8fa0c1ad7da1f62e68b7482570e50a19e55a55ca73686de1d7128f61d34711c8e059a761ee894cb173f58caa20c46654d7f9dc2882063f1ca7fcf1c07b4cb67549992433e65de4fc4cf8c5af29de5676a21b2032cf76356c3c34646b7f7512273d17778b7f623eb307101557f2fd3ff0394df66416e7d75075a148eb9e97313f8ae92eecc7f0381a148878f753be2e2006b514c92f16a6b2d5744b13410fdfc9aeb47c66a00c549bc2ad2e19a91117c96412f171c0d8625a5b93943aa7974df0ab4a4123c18986a709421cf7f594182781304c7a53649db3e26db5e1055731f44a64d706275eead7ff2c200ca829b8f12b20db9f3b53bee742ea55a8c09b6803c70398285d0f5976ae4bd546de94cf5cf30a7de428b8bc9666c05d7e92ee9b6fae8dcd37839a19e1d8aa1a92f6c16e651563bdf386c8274daa1b07ca6de03358fb045e7028f6ace88cf6d59a3fd706d80146ba8ab5ee22dd315aa86003a8ac26fb1aecee32590eed1e5de6c7f847f05b95d11bac7516245fd8d1694941e66d545b023c645a66c74ba772fe770b3b36472b6893a7c4067da3eccb40858c482c3eb4fbea954326cd8e5f94fa06c5d7c1adff2aa2249caca7e4cb51c18d75e048e1ceacd0d2d4ee95ce5fd3c080c65956f5c28055bf6fb256797db1eac32d14d1454172bf17d398efa30a9fd37260d8277e89225ecfd461ce5710c39a84bb775c86d9d9c5f6a8fe7932982d1bad51019c9bea0d14b1248f33a12d304528fc4e0057e4752f4c6376db04dde3a08fee64de43bb825dcad816bd2996941d3e081b55c3c12c093084ea658725118be4fccc7014fe0fd839af99897888cec0c59e45fea1dc85b1d510ce8c656a7700c34872002f0885cc8bd4259d88e09b02b8914a0a04db678b384b3795073989cf6ec9d857ba270e174d887537f612e1b43057eb75e82f3b38b808341c9af1f3750c5726e3b31ad736ae16a2249ec7cf9609c2df83fd02f6d561f339cb3e2d333e8a5c18e19663730c757b03666728d3eda1b6f05d0e5ecd869fe7df9fb9cf3796e5e609ddb7551ea0814baa3c6822c8ddca56f92d2fb06e0f111540d84a08957f2cb627b33823dddbd0d97ce7b95dcb10c9758e77ca3d01398cce78d135a83fd0b84dd19c155bd3be56158ebfb48eb6add5f4893976f6b28a3faa4ba92fae16a9a1b897565b6df57239b43b8600bafc49bbec49cfe4b6db3261d945258c3ab5e43782dc8b8dcfd062af5482a063b3bdf124c749ca9c139b746f8a4178d5848acdb6aea9b66eb44f33ed0f7acc306dbf3d08dd2c9c83cc0639669a69dc255b49624c9504b8073c6ccf569f3dbe4cc6f8e3be58266a029f6d60bfb746912cd15a7ad7f387f793ecb1fc1585d794476f089c88d9a62f9b5966e2d45df290ad9353cf68dcc04af897f0aec1514bbf1eef0fcff90ce7dc9de7cb5cdbbbeaf3ce05b8a9072093fd95435d035560d4efed4fc032ed7bd8cedf9fde50e2f4ca7c289d0b90436735f41a6afe09ec72cbab07f662be3cfe9f3d7a1f3d8d1deb4221a95e3d9702bdf363bac99f1560778b8a25dfe8b00cce516af4fa0ba59d250f5b7b5991b1964f799ff61d5124234d2ed5c16fde4c0ac1539c0390225f549eea44fe3d99635f4fab3144200f9e056b78be80ef7e1f14af10dee83c4ccf4edc4f3ed580f39ecfe00e715a2e238159fb96a079dc2312170236f6b904beb10dbc1a15a5a54199601c1c67a8f38cb4ce868cf598c19ff747d60deb1288be5e1c7b4e8eafb5800b4740a1f05ec592268d85aa63cf85d2f0fe0d72da1b3b3c4384d11393325391247c52be91e6eb264119a5dd1d2645b3c9d185d888be5d45cf64cc9c4972377209fe42a8bd180f6ad8d8f66f9fc5f335536e9cd21728221ec73e841af03b2bc4bedaca2b14e36e6faf54811fdd5cdda8e6676df8eeaf4efc6f68c4c28a4657efd1efb6463e24840a2bbc3bafdca762e7edf6486d83a5313731fb0eef40f442d00289a2437e0d2caadf743db786a01cc5611cdaecd3ad026aafdad1e7660f7cbcec00a559917b5d534e9470752180d3d281dd052c54ec2cebc20bd2d697fa8a8f50f442e9e9697a9f78d4bde2f8f9a0db305190d3627ed2cbc967211fa356292d71250e3902c1174a40c276076961e7095fb112ba24a81f056d277a65a95d5ea1dac52fecb389cfcafa310c626e83c5cd40910203f05376f0b7fdd14d6ac173778d724aa5987210bdb4ca6713da698aca1eb807ac40ce76a28ba43951d60a5b810904fed296ee6fc657bb77e93682c2cd5caaffc3ca736dc918343c32fd16ee2515ab253ce4fc562aea43fed176f129005df06a96bd578a90cf4baf308e2cab33ab57d21c8986033da5f4a6b7a661b3e757633fcc87a778ac469970597264e52ec59bad11c0d519c11c9462b1dd9cd6206027ca33c9b85395a0da6783f1b7d4f4c6db9a74e03acab7095daa20c3982a8c51174ef2ea1d88166f94a41dec9ca25c9084681d7c9b24e5b2519b93221deac87a87c8a5d94d2b464bc78a7ef165b452783721468f87d85a5f3bb7987477f8527b4352bafd3f0a03de25f89d2233e22feb44e73f485d11b9958d212b1d9d01955ee80473a15eab311fc3d79ac7b98330e4f7e6fcfba154d4924560038397b63d27a56e6adbcdaec6e440b2af577a6c6eb9fa1daabca63e99dd4c6156eabd657f31c3ef92078276d38e7a3319f7dc89222c312e9eef732444bd0544d27a4ff6c8af9f9cc1a497f5e3c551ba138f88043ce5c5b59fade9632138cb03e52770474bd0b92939a63451c37f2fecae17f81310f3aaf30d1cd4b5790c445f2dec2cfc4e668d61d0820ced601711f0beed79","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
