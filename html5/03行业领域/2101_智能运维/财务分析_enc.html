<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"24801c950d93f59114c29366b8ed910900785f9c681d4c8fa941edc659263514e27f381d008cf5bb42212ae9b14d53155d26bbcfc6a4e65d374d4cc59fca76540096be0c6b7c62326d67eb0a6c28cf369f240c024611b2bf87526e5f4f2ce2f74f58bb51d86c9fa5fcfb5ed758b10c593af5c417b6174594e316f7c7419cea960c01446d19d28c677f5fe3eb981ff98dd020bd7b6c5ad266d6592b9bc9c20195cf484876f0ccce40ad32cac54e6785e60a67b3bffd31ee7fa9151bec0410daf856b751c2a3e21c586253b245793620eb2517a1c5edf2fcaac3e9098fe12395baf623f2764b60a88d368b729218e372b10e0c359b5cb8230646ffaad50129db6fc0d30d62a97f2ee02e3b207087c335eb011b271e26672722056dde3bb7458c573d26743696d4f21e4d8c5245eaa2906ab243dbbd48af61388d7a5d7ec19301a0359c649fe9048e9dad2e064bb806026d0c33b97a8d8f1569793c1d74eb4db76c62757253dd5879fd09614d81f6fbcfd65930a080b7c4a438b33ffd80d80420fd0beda331c026b6abcce96eaeb512b52df2e31d7415c053e07eaa239adb2bf533433957f381c8239abee78c515f07e5d16de391099c0785b589f4ba63c24a8a05f31a4a3fcf3a6430f1e4d2cfdda195b4a4e2805fbf7b609596e8f623080d0684747e542571d7cb902b83f26c08d2423ec08fe77f54ab2039d125056dda5d1747f79e218b11a893827d51bf83b7377eec8d241d3a101620db904c2f4dcb9a4d7fa5970eb2d5b169c213f954b83f05f3556760c6cc2b2d52fa413ac498da42e60404f6a7f8173730171f7e73e1667363afd9fa141751b990604e9d7072fc441630ac80739bfd4255eb2a0384cff1d30f9c70812c25c600f43317fec637a1afb935b61ec0a5371294026b1e7aa0510a30350817f972849aba0cec6c85ea49f349d78dd4b26ec38d304020cdde70579abbe2a0aaeac9db2b2f1784edc24d638c9b91dea2b831f61dbfcef07750774b359a75488c3ae703543f3af65be2c3c7c0233832495aeee945cd8d4541a2106ebfb3f050406e6cedce7e3f18a3c2e6368a5ab3ec1785065f6a26d7d96f3c1fe1692c7d1c0e67c0769b1ede831c8878b32120243572554bc7a49c841597cdfe3ddbecad8e6c76f8c37c0080d0374a42ed263bad2ffd0a382e6e3c781bb6d8d11767b4dbfa9e4a7284baf2a232577596d8e539b34beb4418e21f66e7e6ff6d8e0273eb061d6af8154e67fa8b33b04a75617245d6672a1b506521cf3e6a8b2fbc1e8aed50672ae0e4aa86c7452a87ace3eb73ed12669115a93acd94df5e660c881c75f11f0eaf738c71f629076e5879c1456be78ea1a6a383b3f68a9d2db9fe849edeab1dbfe98e5db78a776b89aebf0ff3eb4089edd04202287d411769686f90f98494daf8ece0ba746d5f7ca9a321b1a0fbf66eadd5a7358356b5bb39a2f8685dc220218acbad0a7d26534dc846335925516e2e3836defe6d0cde5987c8cda10a5216af39e65245b0c8c7fed5c01e41b125065aacc42786c27fcc722bb0b332d79a60cebeba52522a8ed2de817e857419848926fec6bed6159dec214852198e1072597182755c542399cb3d2b097244099d75b44576a24aad62d73d93a5700420d4ce27b7fd5a524f50bbb72b0c2caed87b4a9ddc3e3b6aa266871faae63087982f6ca2fe377f5c5e2486cac87ccd0343af5ea45d7369e1add8adafd2f75d21eb45f2563484bbcc6a3afde08087b945fd4963371c994c91722a0bb2ec28e145e18de6fe921fc96725a1235c42dd8922d90e82b5a0e88381959dcb465f7aa163bac186f6e2a31b8e1c20ef040e3d36b40ed640b40a31093841b4b53759acfba872b0ecb7efb744222192e698e2369abb5558ff397b614c16c9efcc92a017146c6d5666312bcbfdcfd94070e7d3642a40b9c4465b6ee5443c04d7ba760b41869df12ad4b885fa8d22dab32c9be269ddb62f28b1d81eb817be28a9e9fbe0da3af52a4273508fd7e2fc73505a236859f9c6635c4c729c48533cba8a306245a7fd9bcc91b337f9a412455d06d2b6fca489dbd08c792d7e91176fcbe1722d537e484f1129ee529d6772bad2c5f2f663a966c353ff077e38c99ade0c0940df1c45cc25a4dda09293da7d7396a954186b537f3cdab79ef8a48c074457ca2dd6af6b9f89ca3669c0f7390267740a83f3891b1b9b0337a61a87dd3db0f91a59b2adf153b65327b6af56d0a3c0167b87aff86f448e48380e2d0057db98ef269b951ec7ffab69b1fbcb6bfdc44501e3167ed8ebc1e821208ae5422965fec92445c69b5137ba8248b29c7ccf43f39c561a69e593afc4fbf074f8ac7bfdbe5c92c5d29d325fb34e189f0bdc3a82775ac40abd0ef7f04a8d85574d35aa052ff3063c5eec0e4ea87ba95f7cfd5af44102e353df7462aef2de3f42c08ff67c894a06f3ed9d3ecbf8c78e942f19293fdc11d766ee76b1b9ba455a894d1f8e91de1ff069db1bbe5f37eb4947e698d0c9a215a98d741a416c69c54381ac2dda5560863a0302cbebfcafd0582e7cf1985fcd2efd291f813da49c0760443edb42906792ffc242cc248e0f01edf811b71a5deec2a5417e52678e164480ef88fa4a5d06e7f8b42ad0363ab50e58cc2c3111654328bd18cd5ab1241a868b7e6016f5bd59cc1927e3d57bca8252d2540f24025c910d6aa3add34e507db5b201700396c11aa0e0cd02eeac5c2cc9e183273ada9f95554eaa9618ec84a38b488a913b4a5d97a6865daa1e3694895a4e92b49033ea5c11301b19785838234ef3fab7cf57be7856267521ea1e82ff237ee46919db2ef830efbe9c135cebc0de289477b33a34207d92abc8efe1be484a043f2153f85a439a8d96f0c048bcb4d07776b2ae1ad55b269003c0c14cda15b73ce9547a17005d871269fd3a305e5c654103e0edea78844000e166219e7037cf4161c481ce9048fc73a91e6b068e877cf998553b00e57898095814bc0ccc95d6381dede274366aba20d8b0b7e0d4673ad1293f0b1845edf8d55102930b7c846f3c5a667046415fa6b89fc5bfcba6993569f21ba247af8878ba085ead28efd95d98712096caac9dee7d85f782447cf5f4697808a3245b060c7ef0a04532b0b7c9135eb9d7fb358cb3b96c7c52ca67c00f31fb89d0e96ee3a34cf40f2d1334213d60d090f4851c88912dbadde2683f7e0503efbfa530f893c9056de7f7dd4a692b4eff821c457d28d2dca46bfa9e1b16a800f50c3f35b2f6983d5041cbffb0c4cce1d5a535107c49d71aae0a690ed5f249db47bdc2f495710897dad26b2e252e3cd10284f184bb0d9bdda3afe2b7d3eb3c49e203e1700adadf4136b5465e98144027773f80bf45ce9926c47e74f904125e21d66377604c1e42247573bb6e1068f5412e2033056708abf054e00a4514a6d45000aee750d28cfa714ebc9006b0822d3128cb637098a116a2b1387b49fc217200d88786d338c3e7e384720e0a7283b7a24e845e0d9535d26c1bdf279664ab831fcbea398ddfc74d58a73a2728e57f7634c8561ff1a6e26778943220f855623d04dc17673d9ece1149ed426d8897f7077685216a97bdf0618da5b67e5a315cb8da8ebcd6b033f266d2eda7c31a5e684d08ea1e028238a2195150fc0dc2498fa834a0afa310f35e695ef860ec3cf92974e87b17f1109ec8ff96d02ac35d44e814f3d6462ac33f34b815800228ac30b2c67595f87cae92a00568abdd1dc897fdd8e7d1ca672f8b5e44357b988590e97d41648d7c472044640a860a7932362ee30154a6da6c4eb40a1806ed0a997dbee6fd889154f4075e75f359b0e9adc8c80e459258f5c5fb30581af61c19f310c81255d9c6758ab27381d6b781db949565d117c5b31c397f0bb1fd4d52e0ea116792e1e51bfc8b938e6018720d5fa8aaebb12adb8ff78adb3c8f0232df094b8a3504cd5d0fe5a8f1cf6f1266d1f3cd49318930cda70363a877937896ffe7a4b37be6ebb1458674fe562aa9272c3976ccbb0a76008fb510454832d2dc64de1c66d6ec31c00b82326274abbfeedfb9808df757cb63d4565c5002a1e0988908e52473cb55dfa9e24552053ef5b94304e9bf281399ee4ab9158d42d056c9eb7738d25c2770abfb16f283b4bfc94ec097db16fde742b8a0c76ccf9d08401cbcf0f40d3c979cf2bc08d25eb55ed661f939beb8b1468dbed9b485d0afcfec5d83c3c9df7c893f8b4f325e6711213a03e5681645ef7676f7d65b70358f15b275d5d95d86b18223043169b9d44d1256dedc06faff07c050d447ff2e137914dcce109f81031b70b9ca6a566e04011c67e0f5b5b416c5feca1d9a3d58345cf64b024ce01afd0d803e0d971f076cad1b3d0e8a98200ea7e6dc47c372eecf017db942cccb0471ec7ed0adf9bba3f99ec79ba33995f8fb327490444102d439b097711964a95bbe974aae9699ad0dc15860d59fb4805e6d9cb72556f39bceeadfc5e5c99c974394aec5da1bdfffc42900d0c967ed5e6cb88e0780d455f06b61d30e18e044a3420fa12f26f233cec4da2ce2ef2bab040f514c27d98d54da9c94f591b9e59d3684312c3477deaae54a0479cce4dc796886ad9c6943c45626992c0c3132875a976491bc8578126e09126742a0eb7cb63d31af0c2407b09e7e8e51b40b40b28c373a62a235fa9ca1c0f6ac912c79b8002b86f155bb5bab72f8ca121216d78bcce875aa893d7007cd7730169dadf06342d9df70522eee4c07f89cc62e33b228bd326c352b6c5c9655e05f3e8c332594076ad939042f66181e14aeaed4645c5f64f309049d84473edebb585c9f0b44011251f9761c9e879e4c1063134ff6fadb2fd6538844b7f30bdff72ebd949da66265a2ad94f00f882b1206dc92883bd43ffe4ebe9318505a3c740cf6bb76b60110aafca8594b43d6c8b8b901767f675263ea8320f8c74eac95024dd8db30ec3db8f8ac1d0875dfbe8cf3565ec2260cb0b81696e809e2947fa725df75d69e71cec828a057b2d473ab2718d201a972b61d24efd38df7ed2a080b98cd0653f157f5301d10804fe9b0a063e8732daa8bf751429eb180f1216fec38d655dd62f32f7653504729b05dff456ff0a85b2482181965a7847e8e31f75e934b7cc3a91a4fad7f3b02fb8fd12ffc0a863cacccc20c642462fed50522a20898ee68c84bcffc0ca965aa8c6496fb4e7c85647a70572c0d181c89954032beb3b421703b82c97a37c5a715b9a60aca5307459a2fc5bb99a677147463490864908b15589c741af5c86dbb17d7f5d84f7604ddaf7fdb5adafaf3e8474a30a25cfa147b027c761622fa273d0c75124d8051c7bf030d417eda0491b8a53bef3b49b0a3b8d594c168171dfe09bfebd25b67d1cf1471435368744a04f463c692e11925454ca67601d11d80ad28b659c867d515d51119056ed70e7943a3c99b68db5ee0b770597b09ffd9f0da4157b172906aaf2af615bac7745b8fab91c50edb4a082686d4ed5e18abf9ecac7c421bbcf9665c721a6c868968d8b0af8687cd85dbee87ac4dd9f1d60048f90558c97620c8ce31c05daedc1996778d033064ead37dffa07787d03224ec410ac5fbeffab2203eab611f7735249afec34a7445fd5afd1c07798e99d2f855610c8295ece01ed370b0b0e79b7c733b3a384c94977313cffe240195167bcee79f4a0b53335ecd5fdd0a3a2ef8d392fd80170d99e649e8ed70df13e1cc648d18603c4b51bd4ebb023ed0a04f70d6c2713b171ab43500abfec1e877bd784eec0fa85e17cf439634a7991ea967725414ec944a00ce83b90a3fe3dbc8b8838d44d1afe86f4d67975289783405e9056436d8272b33c99019dbea250cd38a2b5f2f2712b3350ca8afbbabfbb6a27007a187a0747061bbc51f1cb544bc32c5769734f382183088b738a8fbdd2612b86269ef1eeb4e544ef612e6403e1aa175fb3542d75d885adcf8bc1fab51e239b6110404216d91dcb52bfc564e0f1a480ba6b5b5590e420eecb26da6b01fde243131cab2fc95854fbbe70569c18021fc79a251142d41d064292189886f2363c601fae077226899dcf2365cdead8a7f8a586e1422cd59bcfaf9dabcd66c64eb258d398af5e830a0c07b99c1e0536e02f6004d94aecb29aa56cfa61820a9b179583c74fb8b03bc94bb305f1091e99f4dfdbeb1441f893f8079844e76990487754d1b4505702c2c95a954edc248ae8c2863815042f8fe88c4071939a3018e430a188d67e25381441527bbbfa74e2ba285389bc00be87f1d2c6e00ca4cffb708189d1197bed869a8f02b7e7a5111e78b3c8cbb707aea096b71e65cd057e059995610ab35b2d07a572aa5547453af792ff08e7265ca8f1548f91264e70b493454049d706af370ba8668beba3b1eea77d06e5a021c76893c6434fba64ff7ee01dd15ac93a74aa9804a4d5116a7f10f152194588c0ff6c0f66f71c9cd55941ae7d24184f5e46a9e1831661d0b590c151cbfe930d46d658f8e33974758674ef107257b72d366eacb35dc466e9bf4596af83bdbe74ab27011ff7bd89c9c2f1ace5c15dd550d6146a549c19d3fccd89a938fb504830474468c0535489e6e2cdf87d8427cf50cc971de6d9d7bcddb6763df4e7cd9a3ed463d4be8bc6dfe604d073208ffbc4bbf725a1dbfc3327fb7aee30d10c04eaedeb5386eb3f4d1d060dc910e4384e0bc839ed9ed4fd011332d202330f3eabd70f72e9159e361f0963b500e33a9093c8b4d7e026e6caca28900d7eda4b7cfbd599b4b98360846e79ee8382b4cc3837ea7c2295d2cf635e7072cdbd5a1dbf30322ec1206cae081578a5e7218dca0b0d53dad918ba00a5a749620a4e1e106eb5dc1d44308f0c57221e4093c62f86055fa09be14f6996866aaf04bf8498d9e59ea9b17a8c320f256433df457d921144229990c22f4b401113d4394831f018c26cbe03c4ca14f14e33700e40ce6efb9a66a261a0c60d86d4f42c75198fcb492463adfc48214c5aeab0f18110a71b24937b99995305e8d2c02e781739d585be43f87c06ceb59e9563a70b580d884aa7677f5b8079798e3a97175db77fe06cd0a3eb3826f44173983bd679827ac7d34a39d2a195b636a3c28d571e6f179ff0c3f1c5c6c95f53422ed2e5ad854df8cc999c7610c0d0a2e2867bcb976274c791409202c2039e59a0d22787fd983a0d5e71fc7207709fc584759d7c3e3e02a45829476a9f22a14339f5570f73210fff4018320646fc7bb89480869f59ea214e9fdaee5d5f367011be8cdb7070a6176f6d254cbe428e8bc63f9f78e0c2db142559cc890bb48c9556c5e74c22c91101ed97f35d91fa08b5a60b925c484022d17660b2e9175a867317ec8457e69e9e748d10880035b3b2d753b4eddeedc11e4df8dd4c16ffbdb50f51c8e590b84b3db6f8bec7f347a74a66638200e3bd42bd579884ddb21ff41f6063f890caa54fbcf83d0fdf854523c2c4734b844a335e92b4ed260617e1291b7cb2426447f02c3b3f663f85732fff9f70c71080556ba4d765de835f738cbf9d27ab7c6e348056daaf40125e4db671d465b06d11715f58aa7353e1251500932ba73a69c679004a3dd433a01e98648db926469eb6d6aa4f4116d1ed99f52888c907e6b0d8262163967258feadae6374fb53d4aeaf0de74b0462ca902aaac308bba24fdbf32fa65303be50330b0938a1bda2919e5683cc5acdea5b960846a14079ccb26b6ef001530c72aebd8a36839473c3e9edf726ff537487df0599f33562dc06cd98c8e14b8ac81b2e814195420bf6b0db51dd94344db0cb7ca5cd2ca544259ef824e1d427a6ca25100000e9dd1eadcd90424a903e33f1fde0a9d2a284bc8aaf6e59bdb9586db2a39d03366ba554e760835b1dc0af8111c6d2e285b38ed4396783644f88859c5bdcf5c59ff994cf145a8a06d3e79ba34f9588dde3cfd9ba7310abfa5700ab0c59b9248e46beb27aa9b1e6f24a79eba8d5e9fbc432aa0e3d448465843b9776cc44b67f46eec9220e4d6e93ab7e2b36d5cf3639035f69239b4ec1b0f5e3a3b9610d20fcec907f28c89d44401954ef545476da83c3b216d8a768a7e9236635a27892355474898bfd02fd603fc241752df981b7c892f1b673f4320a3f4b2f4ae2147711f27ab1bea095b20dcb1890003cf55cc1efe5677edd0e3bbe0a143b4dceac774590de5cd62f9b7fea012d2a948b4309409f762e8ff4cb51e55f9e8dbc2197ffcc8335fbf7d50766919c17b33be4ed21465f2be7005fbd97ea6adab83beeaf8a7226a3e38a95eb05fb0d087be9aaa2e45acf9e8839aa2f372f106f5a504d8634bbf5afc10bbcb25fc853846124bf0e6ee4670f64f9277d0934b0b283c2d8295df9b1fc3e278b1d19843cb5f64c99d51166e6d870f68568c636869e1d383389c2d69419cffa8d860d85c08f5f3856f413047c45983a12e3fcb11a8ca3da639773e9d7a701aedcd1af6718e4dd71d1568ffcbd544c43cbf411ac6976af8fbe9f9b98afc85c14fde68aded01afc40d31992bdd12403fab10216ff801b3610222f8108985dfa14c607122d683c977332261e98e3241f736e1666be8b118dac7fcbc8cdfa93fddb306ee5639e878fbb940bdb361093a8b33eff5448573c85f98dbeed1b7c38144e95c0cff48e1b3ee5071e31a8d5fccc3b1c609c932308109a2329e29fa311156a42c5d14465ea369ba6bac4e7a8bbc17998c824c4e97ac0b178a083b698810f18e3324949fb06cfd300d78aff5eb331ba85378e7f2575e1efa8470caf99c462fc75a9977ba25453ff4f8341a3c105cbb186b6044fc6fa73ffb9fec995e0c10c9ff0c6d82054db1e3263e9d75b3df6f7e9cb4003133d3e832fcaf2e35b484aa34c3313eaae8a71a448a17d04612811536e61e97f9540eeae17c0efd418988879ec43d24b4e8ca6d2c483af7b09622369976b8f9b70a3f337a2ccba5aeeb3658afcfb2b596b60d2492c32f9ee13c647614922995df2faaa786be1816cb50f8c1ad0e076f2df06d64ceefa070bbb4170f7397b43296d437f8d9c413767182deccb65ee87f6252033c6800d414bf0369bd04236f3ec249036da4a3a70f018893050b49263491f753db500891da20fa7110db4a2834a9783489edcec1169d60eb023536159d1d5be2dc2818e85b87b59b07bd38b36899ab0373eb778c2f39d04087c03e5a9fbc14e9dc18fa344ff5600901e1b183498c4e054498b99847190d6962c252d6199fb9a51412ac6d25a6b36f0405ce7c518557045cd1f4285dd73b3e9d567e95a09b6f9095344ff0bd5b97abdcc68ae03ef02c692fceb1bf7ea52ff92ccad1c178fe7393b8a0023db011a16876596d4f048985d8e4acb2fbd4f77583f72eeb714b8301b546f424fe504d24531e2c1f25e404ea439cb4440a5b62e7fca74d8aa6a7fd196fd8650520208119a37eb7a4969acedd9ceffbd4a61e089b0e9432ffb2c02521211de7bf4eb5075fb7f975b087e56578405809fe4a55d083faac8197247ddba7ef5bc20f78a0cce1e5dfdf001a652fc2264bb1406f1b9db00b653c552eb66b201b3e2f712ed8d12f7378f96b34d57ecdcccf838517cd48b324c052cc85a8a69bf4419ad8501798608c4bc235d3d0762f746479f4cc5740ee7f0295ce29471ee6c56ce80a9a93fecd6cfef9d9a29f9064cca2b9d7fa23c3e7431571bfd8cc0b658451d94fc70fced491076ef7ca17d6bbbd939f94f44291f6973403616d5fe630d3427726e4a1a0a6ac57b7b7db16c0c6aaafe43b5e7ee7be1e36a0475276a62e8ff8d805b204d0642d44a122c54c03fc78eec5220c785be0c6146da7f60fd337e3aa8d7cd1d666e3181ada7d6d77b23dfc2d313cc2232c0ee6638be02e3ce6771bbe89f818871850edf9c2907a714527784537284ad94627cd7dfc131c0eb879f781e2d5f9d536ce9bdbc38e311e228dbeab6fe634437ec84da0f9dea8e3c56b256726f28e2036a70a873d69a7b62509443a9365f5ae1ce48bf57122ae0bd087f933881628b02b928854538a6cb4699d019323910217d349fc02bcc5cbae89a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
