<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"85eee1ef09e99db291fcf018902fa563be7051b39b134fd9b74a22759656e0ce5fac92057cbf12505956de35ac879a62980fbc3080dc085bbb2725393a5effe9192b64755cb7d0cf08e9edc071836b47ee3146a1b26c8e73fb9d5a66ef8b3fb23a448d1714fa28ff70696e1262168d51d557586eb51796dbdf58caadc3180a6859ef8f7eb23020b77900181014b8244abb125fcde39b74f7e7116d921915e61a1f6fc68322218eb4b5a6bd6d2ff8705e0f5101c3de0165d6eac3bb08e22d18d07df0db3ce76f3217aa4379e245f365a8024afda301987de50224d86deb8bb632d008a725c392f0bbef65919247f80d3ee564674c80eadd5fc65cca691747a7ea38932b3d11ed3eb713747288b853e2b574c7604968daea67dc4be4c9781dbb72911a581954ef72e799f3c4e14ddcd47785743caa607efa22c511d773b8d46d47a177f2116d5619fc0c5b351c5fc2f3d8f6af17eb1802aa45eb27cc6f5ef7e3f16840fdc77ee2f81b92057d557b40eff1f97d80e44453880ec23c7e3376b23c69619b0f44163430a7c4050ec3b4d3defa1023ac4a34789cc4b179ccc03a795a8eac0945a70c1e6e07926b2df099545c6890943cf8a24143c09df066ca65862bd0f65ddaa5867764981ffaef6d5f1c5b631ddb071c0a71e4c412476a0560cbfad8fbbf47cba50fb634499af806f4f88c54045488e9ba6d2b9abdc9a693559dbfb46b1dff5d8a6c2a0625a93684e8262861735d76930e89da423077abb44295c96c1bc237d88aaea683e61439baf07816a0e44fada3db05663b1ece51b4c9ee33905d89effa94f57bca92584f24c06cc363c0e4e78177cb460a97d41658462eabe2aff9a600ccdaa392bb55586856c2e1c23a1e278ab4c96d6fba960de627077d650b697af549ec46889cdd15e87f3a8472a064404a0d2cb3d9ac1a504d5961ed73445269cb542c4e33e9b8f483e2bc75f062f80f1d3d1a2abe3cc93a3e33b3ef2083381ec2d3fc4aa2b397d50bb3ef9312d8f89bcecb464d63999e85fb471dbd84faaf2272002eb9e41439bda00e8eea5264a93951dc38c7dd6904b3af39f9155bca528459833041ac0789eeb5d5061f6b9c2841af485f233ae102a680f5046fcc969f0d4cda06a205c1057e591b516a020b0da4519bddf27e61c5ec60b76a15dced8f71c519cbdaaaf6b12167b3acd012420306b4bab5a3459743e0a59c869ee74d3a2f54af4879b654b7102414e6e98ea3c075c980b0d02ffbc42ce385458c772d05169566b077725bd7c844a634ae1722188f4ab1cff3d1d3c2dde34b358405bba12f1226fa2de1dc218d633d6a77277fa479389fa6fe7f0dba569e6aadfe2eb1eb38b28212a8aa97050f760d20a91ddb64288081c99b73b366fb66ad13dbfd72d0327652b13d0c75b959ddf8816b61943fc9b2d511ba7c2738a6a991c8542eb087ebb4f970fff0f4ab5b277e859879ed0b9310eca2f36e9be6caa4e1b19fa9c09cabedee1d5c02ee002569f6c30cad770771503b2707c213354d3a3a6283aac1810549a29a723957066e563bcdcc011eafa21b7402f123578221639029d1161a28a986cf63243e3c4524cd6703285c6f4ab68a93a2dce54f0eed9582595c7e41686b20f109c9e2957070d62c775ca57955622bd695f05bf634695ca4b91be1e274a93e54ff24b3be246378526e5b24969f21c5257df0c3d93e2c575cb60d1257e7d9e98544052ea10d562a26bba2bccc56be81f080d419a5281873cf393b332dee4274ab7ff74fc49d774bb742c8a5dafdc3a288099856413aee25cfcae85a755ca5f80681264b71e78bdbdb36bad06b38c9870ea2cfac339996852f3051a7f8631fb7e9cbf619f2b3bd497d306c3dbba5f69dbdfba1be25f10e6a131200017d4efe8bec92a4cf1dd67c49b45f7c09162740f6d917107736d2b481f25f74d78816be7a71fefb55ade267e4dcf1b79c5b57d877a3696c245046a73208735ca41348230cf8ff9b27c42eaf76f2903905ccbe2fa9e30dd519ec803b23bd6e942b0ed4ff018845f8589b5e6ddda3fb83fb2234fdb7be968fd1bf9830c504bdd6368cde9571be8136d2b2ed3cc8fe350e1c416c1086aaf97b914db4332fda524c5daf6c2a74d1d984f72895eca147142b550f9c536783ab6809990d8d5fecca8a5a5a5ad77fb96489c0dd777440ed0661ee651f65ed59720f5aa233c641a76e7bea40bf266af060eb369e942700c380982db074c67a8d24e33f7bb5ffaa0cb484a160c78d5512bf7bf89f7974d264fdd42ddc670f8721f86af667e1a3de4db2b751be844e8fe63f24d938cc18b60d6ebf15898af7e45b369ea8d8a85e3e2d0eebc88b727a8f21e4ee1ae81c1d013b06c107a2da61942310c5f18029a99d86b9db2d7193648ef51eb6ac978fa69492fdeeb7cc53f7f472e09cfbff8004b9f7f3af28b0dec72cef8e8ca8b1a874af8d6f1ff1a330d36ece65f0f55ff00fce8c4b66b07b2a00a72a510ab61886ed531adeffe8a1ecdbe37776783c707d0c02569b111a246fc6ec553a132ae98ba96ed36e0c9fb72eb89a19e59176c7492b42ed4bf6e27235f77c7aaf6c10b8086ae9072f1674218eca10cbc3f1a4daa852d72af10a2939d864d719917cd5827a4314af90b49c1e41274a089b0bba4b7eae4b85cde1d38c0422a2e96f47c675324da153201a0788c410cd4065fbc40159e09e2ca4c580123c0f1d52bc78640db273e4768903d22f8f9c12b9a9b1050c5f661e8c5cc5951dcbba7f146f36c2c99749a685a82273fbc4f3a874bb4a2f7bececd3cf213d7c595308e2259cbfef86d78b545cda7f62d30d2e4e3e6ad92ad0be5623ef89c517e0c88266dc383be9a030272a40efb529a8937847878801b3625b92422c9d146807c1add80a7cf82eb0b0a213c07e2cc5fb5c1fa3ccfeb77f1f29b20ffb81409f61f70fe823d22f1fdedc904a6d81514ee261bf842de10318d57b9b597414e0f316e72abdbfd0182280c71989a4de28a90edd18bf7f793a5f9e47def9f32d3b5ea5ce961bdef91af8cd79ef549b3367fe42b62196d9430741364ce776551e6ece46267d8f65244aba9beaea70a0b5beeba29713683c76ace43b180a409e17cdbb8fe5b53b5f5e2040e550ce54a1a485d30aaee633fa6db52645e7582d08023a2776f461e28c70fd63e0a47689716733d0c1d558d13f1f65e22294624f416e1bb95dd9e7b8e9c7d7991a4412b498e4214e0e28791863ff57ad258a478a132311a9b746574463d9f9bdaeea56a5b25810581cce6ba190562ab13ae7a99714f6c892af1b17d7c6816a43ef888bb8db805b5b281a61885dd8ffd8dbca76e4b6ea568e9353a721ac459af9cb081d304b4f849a53a5f351609d2eeb186f985b1073bb8dd275fb181103b05500601920dde7db004fa54301f97870dc521e65fca47a71b8d54b790d1e9a993d56577468fe59ec139a69983fe7e9e34feb85213b678bb00c6bac4f3bab6395ea7faafca3e58c0c071e77d4f3f2eb7ae8965d5ea365bfc8ccb569ac84ca5354320a1fb64dc2b39a51d96f7c1196fae5d0efcfbc2300a915b404573e849b7a73586a965e3f5c477e3751fbb4f2d8ea8150d39097306c1a8bf5b23be2e32fc81e050b2fe3f4ecc7eeff0d86b1175402d63a846a9865938a3f367500aaf5dcdfdf2725b9d4695e456830a1d3404e80cf99ca403a144a41ebe9d4e0bc0ee04a865924231979b284ce07cf7e3e30857c0a2d5c43c047da435fae7c12823262a401b5849482bda5972dcb0b7bce36ca0a1a601a019d3be81ed160d599166faa9fe61a12821c52fd03d6405ba18cd392491f51d13ae587acdfd3833c4bd03aff2a8d943d213517610a75ac9cf0ffd54fdd1dc93ba2012aa172a010cf2751490ae486c7b7d6676c525197939b3bbf4cb35c036a04b001bd089aa2daed88c868cc0545896da55b835de73855f78b53f2e4c14052e8036310de51ee73e7d747650b82dab756ad6f9989c5043bfd04056efa689257ab656551836caa8e6a7b287aca4630778f9b7e2834ee1ae20883f1a81f267f01d2a85dfa7e1999232f4630d7ad595b1c998885bf518fda2260fb23fcfd33588e332be52459201bd04021e9ff71885e62c7cdf26774fe885fbfe814f43f07132262ba2b77532bcd304eacc6584ed54915dbe3d4f2beff2e9362bf0562c60f2fd675278de791656a973f33980abc82822e55fa1e403ab1d4e825db4b6ad74fa1344d132b34cf8f7012e9a13ad4b5a77cfd039132144c90926d62f99984f068e9016783a17b88469156b0b0aeb31b73e41e0eea7890212560e645e0474774c3e8c043f595e58df4f7cfb2d3ea1320f1d3320a1c90c524151a78dfdc73ca260b0a51966732ee83d5d42a3d9e9ae590b61c4019a44cc4877940e275a8f13849474578ccc475c6de27ea5a0ed8f77d407aae72d9831669f4119d307062592ba5da1ba5bd89c17097b71a5318c2b8ef9f12da969687f7b3cbc1d4c3dc891987b7854e06139299be05669823d452dc4e60df10c3792b3517d0bf9b40c5af06eaa4e9c0e0109275aa4c90a5af5d6dca141774103df471157c9eb0b732d0be4c44275e1619e3305c8c515549e367e15bb1be482e1e3a006df81ebdebddc8c546ee6987d91c99961d68fbdc631d7bc555192cace6a5cf82b70a925c3e7140fd2212f3d782f238633287555a56617aec2c52ee65cbdd45094c9b4b7fa0d513803738a912c876c30664dd34667722f6782430e42b3cda6befc1e10c09c29500db5d02bbc85314ad3d5ee02906bd0250eaa048a41abb5513404d2d0088b540e335a3e234fa2c2ef87556928fc7860e6c0d951f50b55f3d100aa71e7393ccddae9aa1e8e42419c4808fab9aa7a2cdd05666b8dcc74e766de39696ed06d8d41c75d07ff2f2d5adc2fd0ffbf1c6069b3ff4c37bef2f4375d5b19ed9cee88dbd3aece591d0c7e9d3f4e212498622ef3a930c4ffb3a8f8aae99147fda820df5e490658c10b114b496819426de86676e2dc13a487d4efa642a5cdf56cbf1f8e20b1068f22877e322a71f09244608242f742daf90bc9e5964f968b04ad9c5ee37b063c7f56fdc71619b2d538d55f3e1bf98328e3306122a082e449f22232815d43b911369adc1853a82a51869964fcbc2030605ff6650245a55972180970b0e618a476ede004bb1d2ca8f3c026f3e1e1eb0a26b7b1200cb0bf2c96de36453da6c71a25c0b008f74467fe5020cfdc01e1bcb0a07d47dc11701c07990f220c1c8bd81a38008d979e8d3e1f5b0fda66d0108800dd536a0c4b6eb0a4fcbf24e7d51e9306e35195d0d82596c3782d6bde39851c91030bf3c1183a1d673d25e74887f5fda0a6aea48d638727c316d9b82ca1839c6be387c4eeda414f9b5c03c8c1498c4c2d06e69f85ad06deb3c236ac94605e940138def866d2b40fcd4e20d1903d17af78d1a150f0ee8f7cbefa4e8162311f9501c3017248d005a51d27bca33b69c57e8ac1ecabfecafadddb95c93da693a86098ef326a4dda1e54613cd87f2774fc2411d992b9c4fd050be08215fffb19f60a5ee3b5eca2179efcd7c8b18f3ccd1872fc4f45a46683dd73d7b196e6c3ecd1f40ad2307f8ef371962208316d09fcf79ecc72ce4d45700d0650a7a36d7534915fc4ff3d7e69731a7f006810622e04a5f119660e65cc8de44299ad2c7ffce3b791385437ba4f6c81c041b4e972065436b099cc1d7664355799e3d739711a94034aa25b7cda1e39b17c3463b0847bbf58cb9994b34f02481a779b34abe19b1b3d1356847eb9036a2035e7d8f476dde0184e7d7b82f92f4729ba5397d87a51d5aab28078bd6d73bac5eac968c4ab602de2d2bdf5f31d59df4050fbe1569e3a4755394b9dc95782ddb3f092234fae0b064049aef37fb007a078ff1afc65d47d15a414a6c52ed9344c583079be50833343436bc1f8409a75f5c260ff5fabe27d3a852fb6d08fbde46d0e35be32c9875b59fbcc45f4b7d06d87a08754ad0e9790eb461649c6048c288096190910cd7794a317f3fa90a7274011304aec9b1a397f1b6475379e45574ff5281a8a9068c27f84917d6a8899bb54882311dd104ad80bde9f9337e3f66608e6846d537d087973718d20434c31cef5cfbcabc356aed18334b4f7f00d98b8aa8848b9c4a7928a614123130e1e537bc60e0ef098b165245754b4739ac1ae0a572b9907d506842e2d99a8f6041084020b83bbc8a16b947180c1b0e9d5a096baf2b0e8696a39cab0196298ac33088e51e6bd7074fbca24f4f8cb279f3be65a1bfbbcb000bd966d903752927b6f1a2e455d223f50ec710229458833e4cac20ebb4eeaaee0924138641b98e6370ca9227b0ee6fe7945ccbcc24c04e1a9c90d8520e280ecca4f5b1ab5112fab6373d9bbc1b7187cfae2945b672390c4ecc3b41d8c360d21814a1319613e82c75180cbc92c179ab688f13918a436f7ac2fd017eca235e29dc3ec097c66d6d3bb12cb5fec75bf652fd1eee618560daf9322d6fb78e14c0b9c43d6f11b1784fa646992c77e4033309cf3d9f650233acaba909e81143c5286dd6717ccf3db210b1c80334e43934858626bd2e7380e59935d43a9b43d97314dbb3cfbe7b35f27c57b22880b6cc0e71d49de58b2ae9213b2640659bdfa48d795a0169e2ebc5541d06c9e7fabdfd22af574544ff28e68719ee90ffdf47838ad1e1b9e8f44c75b7fa3b6f527fab4022064b57b7153127659801fb046a04d1daa7d752c921a125de094cabe0aa9a3d8eea50d060b7573d030c52d6e4e1362d678b7b6e82d6b114b8f2df18671c4fdb725aab53faeeefd2c5d5dd010f158786f0cc7dfaa093b88c946d2b2ed2d1a79f88e5b6fa327dc11ad3526a2759e9b2ae221a8a4b30a304a19d48ad7d799896d41b271861c98a087639e5c7117f2d035683f5ffcafc862d8a6709c27a106930457d8283a1b9890a71a89a6a2432e7fdc7a58d61b39e52bb3348a55e01961608ed76a25dc474d597714b2bd217e898d1045650e243526507aabcaef4cbc944cb8180a8b9805b6fa53cddc458349304260cb4fd4e3fb90b00144dab83b38c2aec91f1d52651ee6681da7913ffdb86b741a839373847088ad68e8481fbdccd74c480cb952892321bf7fc3a4c73e6c9a8954e4a541471ae7b0872296386d55c59bbad4a1ba33fc87aa0258563f764acaf614d2f5cf215a95f71b1067e4f6b6429e0d805c793295711209b103b6be65d0384f91d849fb1c644f4e291da1ab13a5804bee9c33b4f25b06e886c601a637a77e7555bb62af9310b55280ff736d92caf696d3ca3901c26b8f7044c86a68bd087bacda55ec90cf6785f99a8f96f1b89054a4cddb01e5e4acd129335854dd90dcd2b66ebf61e3496e59016e5b9cf9a8cfc9c22226e1d045773cc960c15f2e9bf56c58bbf3959e6a18ad9319f1410b320c76e37693d48b43293128658255a53f26691f12157827dc044472b492beb431365f7186368f54db93706fd08bff1e69b52535712a0a15728f9d8f749151aedb2359de76c6e0f9717a4e32a33ccbbdbab6dffb189ebdc4e79afa2da349d71cfbd4d9426f761ff80366e6412798dd449a8ae31a97a6b05320c66331eef8c7ac55881af81018c793c3f220a868551c8ad339ee8547644b069571364d092055d08e018a805ae5e074118dccc7a24ed8687bd2ef9cf7a6ffdcb0d5c64393c6084b22aa2b303a16028810a3e1ed1c3c7ff7372aaec2a8737d2f9afad34747d57777c8b6569fb65d28d92eb352bd1a517eb831a5171838c9b97a9625ce25904663c469528c17b9b2140be8debfa645f2fc46f9e33923c847412862f5af2cb832bef85a8c12f353b19fdd3fe387c2f7909b20437ee0ea35e8c5bc5cda1fee575ddcf1b866aeb9e571e1e5da4f18a9c5bdfd7a795c1dbedf7b54853dffd8e498e2c8be44c7deed7e7a8b32b05c22caf4edc2dfbbaf71c6dc80cf8b5bc56137244b835e0187dd8851f4b904710e0eb038abd35b2b5a44b142c232bd1d67f8dc45f7761d234397762a6f84113feb55cac263c456e33363bf04b7ca2f96b0fda15918469dbf0abac45db5cbb5cd60656d5b7ca74916caf77a4e7a2d44d1b4498b886232a45cf96cc0ca0e5e01a85a33893a0efc7abab91edec69303041f27f85078377a71fbf227f5ca6bf3da923322b8e611ca073ad02b28e0396005c6581ef8e721dc189dc7eec9827690edcf14d71c85a471b945c2adb637cc5382972331ec655ece4085b4098616a9476327a19df6f4b4573d0f54f0f278edb4783d7ae682a3d83f422668be63c95f3a1d4f60cfa71b5630159ab1c246a55c30291057f7b86467edc6cb60fda0e82ac7f2c79e6e051eddcec9b1d08e2e2b7b88d53b18602007b1d674663a71d2e10a1a34fc7afbe31b348dcdddcc53ee69497b92190e7243ebd92ad8dae4d3c0f6eff6b622e1cd7328e1a6054bf40877a98086050df8f77aeeb65681d1d76107a3c4b50e8890a08dda35ff40a3c93c7a58678ec108c17fe380161b6defcd98797ad7c7bdda4cd92a69776776e2b245d2beb4f878d5d23729239779e9d72772dc2d0c6ff99f20eef204161b130838851c9f5dfa0fbb4429d5a83ae9d635bb3126df7e95881f1da90eaad37246063ffd420a99da739a02cee49247c56792448200369d45fa6c03759ed60a86b9afa304a07359814ddcf7b3d19574f6a6e3de6669d3cc2449a09cafd1d279efb2a9f3f88160e3148ad6682b731a156e3ec59ab07d12ef28cd8837a692b10ac867ffdaa4f123097f761b5eceadab495f657ea4b474ca243cef49ff91444cc61b4f520791d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
