<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"47a75ce4bcd8776e3833991c8622b570f0e01c5a3a4db5088706a74706ba07b889fa097973d09b09dcf9b6577ca22a927b61609b5c3e55746edf5908ac3a302b846d5a60ebb9344c91723f1716364560ae24c279ecd09d99a5f96467352a1669167f083930ebf9e12a08b1ee9fa0b1bc0f0c0810325984696209cf0a9be413ba9ed6bd4cc77e6a49dc182ff7d8c7b7656ad64e9ab745868fb364aa4a89c04173ed45959eb1d6649d3d54c596d97c56b904f48b68ae83c25bfe7274cb9c9b9460ca07c6356d51241bcdbeecf058f9d9db9ae74fe9f9e76dd479931fed78855502bd2690e0cba25f7b80f07a628565ea8d6bbec8c8bf387f2a4fb39dcd4ca3fc281224da3001dc18ddfeb0e0c254dc0e8d1dfc57d5e7294609b36a1b3d26ff34cc77143e1943cbad9020f40045eb5c6f3da8bc2f6ee9923cfce5a1733b97ce53e1f6b890d40c98b38d59f4dcf48d156e63117f7295360ef46e300c54c1da89b84818a5d7186d53f9156df94315e1a8543693f8ab2d63df78bae1f25dc133c42ce162cd0c66a399013d11e586a5a00cd6fd02e3e88ee99541b7de4e5e1e64aa46119fc9b1dda455b438c6901cf6121d128602e613e5021badae838d2270a9d477d833d9d627c8c697fa8c6459697f6ed005947bdfc0ff190b9c5070cc2158fba190f673a36dd314a376c6a4fc4d0b866cad226d9ed7434e9ab35d8623567d315c5003074e757c75f7cae3192e524b983836b8a4eea8f676cfc6a01ef328f0fe885523bb5672d4a96413f6f5d92f94d79687ca25edb09ad14049f9be51a24853e2207c1b4a19b0c0eaa97de41791e34fec56cbeeba7b1f9ebd0a83d54dd4258b49c112dbf548015b7a98a972278417045907cd61143d33ae9e24aee2f8051244d410e11e5a0ba240468e2fff41a328fd8d6a20abf0b3ccac4ac73e22595b6b694decd284290976a29cc4ea5238a395b770fd373bcf81026da87cc315fba723dc9014eb424a76e309bbbad59b2f89e9a5b4856bad3d01afadaa787130cb848a40739eab3094df7949a777e4805b83d7db7a2986c94dae2e9eb9b54854493ee2961dfb871d40acfa321ca905bf873d25d1923826e67980c302fe4f505b9dbca59336f8b5c09983a250088409d5677d0b0572776dbdf79590850f2ad6e82ce07323edcab29eced3eb5cbc588e71712d915d35d8629d25a04887b42ac75cf924d93d2ffff48a4d71313352bceedd8c980c6e3771c7b335452ce9a08c3937ba85ca330c39e09ee555de450a8d13c8f4dbfc33a372f4ab7b3aa6d0d82a74e4595dcb729babf93dd39babc11bf3cc53699565a929635502ea60b1ed0d5a1862151da350d3dae4a26d93217c5918901660b70b99fd4cae7204bca30c76a492f076af0c6cd4a5fc1d10fbdae596d861317c660d702a1f4445fc010b10f199876dc4de9ca656bc8a5b6c6684b82f9cee8cf11171730d1cd35cfddbc12c549eb48f65803e6bc5df20a9f83e5652467c71ed8da58e489908363b5b0dbde535c122b9df9f83fa8a077da26d49ccd243d062bb51bdd39d39f783db27ad708c106620c18dda105fbcdc1154fcd72b8b0e8f53a6ded0ec0bbae72ac243e8100207d131917682240d63d385512713256216bbd328feae19879eb5f4077d91313a8afc0be4e31c8b655f9281ebb349f2a6a61daa345e01b2810203130f5079179dea4f42136e3b8b041456dc912ef0b896e0ae26fe574134dccc3e253b07642b84e2a4ea3c68ec95a950bd7e1beefeaf1eea7a740dc099f84d5048cb4136b433364ab6b4139169b96da040b24421b011461aa1f77bfa4e44ec8a1874ca2d485890b3f50ce5bc916fe7a538d0836bc6594c91d53d3f0f5f84cfa35e91717b657c5c1357949451a9a8b1d11ecee5d3af56588ceb2c5b37f6d10f9c785aa78f989d6f0eb134d64d78a52a9d42c343d98378ace7576030bce37b080f9640b921aca59e40e4a898756263678e1b1d78e50db940b978d21064998122a326944a5382d090a607e7e77a7accf646691e0d7957531a93d8f7eb41acf9e5074e2e43cf8319c1845aefd9db0caedc833428af46fe943d654b8718a5eab83ba9d66aa40e68f0a93fb10b1c684dd4234e87c093446a15a8d94131dba12f54d500bcdbf8e1c88bbb23741d3a78a633b61a57e8986237f949f51c65fb85839c2ea37a3c0f896c050e4d9b6e4f25c494bc6d216449253398426bdbc19343c4d40f0ce0bea4d9662b755580febf6df185890739c506f40c5b4aaa76005b0056b4f00a42b344927dded0d91d2eef0304ca9b0cea59df1baa224bdc1639995bb08b4be64db20bf4f335a0ff7089d71371fb570069cb108a3eff53115400888fcfa52752335203269b06758da5e5467c5e41c480f4530ce03136d49b1360dffd84c57d64c7960eaaf4e88413e9689cff7efaa9382fc6716efff85122bcfb74827ebfa3943d32d7f1d311525c601d9d04fc8404f2c68bc9f4127aa1b4bcb390b217ea0d35b4725630275733e1cd202c3e7da824f35492333953f6354acba93a550a1c75ccc8a44a2be34355b3b97dcc8a6a82b4326d3bb018edd1224aea9fdf27d3123e43dc2d8ebbd88683cdbc96057c3009615cadda6241a0a4d9253c3c71037bcaf6899ccd9dd6239ebbe85fc2829b896787465d395dfca0534f64e1651fc2b54064991196e14978e30ebe2af1194222099ba49dc49cc052cb2f4dae8f231b9a77af81f50986f52599c0098df619e028627dd94c48a75a631d4520369c4a34d20cb1b5fdd0f002a1ecadff821c2a6127adaaa117bed71412b44af3ae1fb64fbac8cad59684176589fcde9717fdc50f1b76d8a3aff029fb35ea9d55f3f1b393502dbb791b1941ab82ea1c88004c489d4a71c95789330e8d7a8b949d5e9fa91de1ae871945974ff025f3a7086c1e245056a6821eeb88461198eecad7f75a807ec257ae2a5e4da9f61d9e0e5a614a051436fa02bf829d34cd4c43b1274a13e4186cade413dfdb9afd6cbe7799ebb4d210621832b4a33b60b9a50243258239c6cdf7882c24f2b86036f49f12c79d276e5b8d47566c831c37a26a74662eec54a7c798ea3868410398fd593fcba512cf65bb705be296f547db58cd55301aa9d1bcd606f992ebb31836d78052f6fa63e7ea764e564d64340b0edac8d1d3772b76ffb46d065aab44e928d05389a87d07d512a87d91810c01d89113217f0ff984cec920f9c9b3f717331b7b28d5f581a3d3e93c7989e92838fe57a33fe8829a5761dde2cb3d7763b456cfafc6d4d87bc39694e94fea59cfd3d2fcc98b749925c720e294fb4de03cd86a6a4d1b7be253d776fde1359bd5d5a25d3aa72ef09f7adada2cf8ab3a36d3dbc21c59dcfb29e62a2d3fe83aaf733467969e3ca2b563095a90f601195654072db9b322dadd883cac415389d97c2d6219260851bfc4ab90fcc598ba5121701e554945cfead92af81a74838aae1651f08543e4af3cdcd6d566c899706323633237c6b00236363484c2dfdfae9a9a64638c67d2ae720905825551ab2747fccec4bf66a455bb23c77e251b329ce7f2e980f2dea798b33fc92c52e11bf8dc30195c9f6c1b2607828a9799ce63852d86a9dda4d56c8ebcfbfbde77767b185478c198b3d479e931da276c283a857a6fc406c7cd37f8de2e0fcd67aeb7965e29bd772cf2da0983615afaeb37eaa1166307994f645c5895290baf65954930573abf61334b8fc9f200cd02b662525838ec3ece3b0435af41838002e0020d1163d3920803d284eebb58af05c9a017385b364ea765efabab77bd30d0650402dae0a48ba59dbb80f828346b374e96a9d55e5c60bda60b75f5c6fa7be1c25afbfa3c72463f822f80a1898f3d3c96dddf3ad71ac0d90926374d713a538f528b9d59afd772a15cd02f9840b161d2f5a1c6e88f1f99bfc69c05ad0ffa745ae2ec24e46fdfa05f6c72555abead660b4423b55614506e75da5d4841d6ac7724805032f96bec53e4ce4b04191a9f4378adcefdf23268bb67bb56f56adf29d215b10b5ce5ad8c872792979a84f4acf7cc6e9c866a1cf7fd855fcd7c9604f89a6ae247f4dca6643b89508f1bbf73b3c8864dbec32e8f7f82c3cfcdfcfd9badbac7f696ff97d68cc504c862e4832932481e5c7e52ac258efabcc0d4cc75cef3709237af47154d9e374e90ef483911c37ca43a330133d5fd49d34464627eac58e947b763853cc7e470a0b83f323a84aa48fee6aeb887f34ab355f73d46d93c783ffa17fb6ddcb1baba014bd9d4abf56145a7e5bbef28696bf61074c19ccd09693f1069ddcda9e1b0629e0f61d13591511d66974b73e49e0e0e9c34fd007ebb166125d7969ceaf30073ab7f1a0beb95e537012677fd40b429b9586133e5151f4f2e37ea0b268f443e323000e2ae2d5ad6dc926f9bde2d8938697bd635b1adc2cfe322a8bf14909df369919c4ecba52958daeb84e5393e0c102769b0f596ef48b5c6085bb6dace7efc842b1d24db706141d167f5b1c4eb8bad51167be674349573e8c9c7ab1aaee3e2c6759d0106cfa9bf81545abd8a27a2f364d77881fe9676a99fe4e3be2785a689c5e0e67f2df1e8fb679d44c5550b3ff01b31281f3db948668be5bda17c8a05a88e9a0f10d4325d34e923f585c89a4a575d078bc937ea6a44cc6d704958c98eb334079988336584c709ea95e5cb4f2767b24d19021bd342220a7d75acf8e71e9114d03670eabd7bb6fc41a7fc2ff4169ea69d8073c533a65d32e44977ffc7d8f4f125c8a24881204e8c2691fa0b9cef9164928b8b4cef9191f8c72973840d81a562fc62c8338213d74c682da4f86de670243c11445ce11f5015e1b94862d78e8b695a184ac2f30ff088f7e9610b9e6b793b9ba15ac73b0101181cd287d2b31e6fa5472b60593bf979650d224abc442d4f4126e28478636f089a5d375ad1b3317e806f270666c2e4d60bbe14d21398bccdf117f90af2a10ed1532b74d94e2971bb262b0095f939e8969997d7830ffc4f00ee3c2f70bb12b3370a8aaf0a4426259121363f091fc44005f5fe19f8ba9751ffec66dae6253b626f6042f8f940cec4ea934dec8c7673edf912c84359772919c475f073bea426b785771cceb34fa02f4aff5d371d0cad93264aa4d3ff24937804460fb24e725808c1f057154eb4a949a72394c5f47df477198c149cbf8ef66e71d75d5cc16a8732a2a48425c16953ceb6256b24762b4c2b0f9b3af15be02d6057c10057c49fec78822256fd290daa647b222f275e7d7d17b207ae420af91950558800782e34766b1c68a8c446a85f2965e95b7465fd520c79e18abbbb7a2e9d05362591872c8fbdcf739a63a40e80e7a7ab01daec42e94928e2f19dd18174826ec7795196f41edf7c032154e0959f4450af57fa1ff5320666e4f6a32dbe21d9726335dbe3c909d04c76eb6aed3dd8e38742726a76bfb30a365f73eecc3d451909375ee30b29470438863b72342aa1e493763427f87e3b3842c8069b89852e9ba94544522f553db8e33e7cc8069001868bc954d50df53d5fadd865d3f1fa018fd7f5158b98438db866faa159e06749453e9109f9f1e0bb429c8a8ca6ed6633285ebdd533501ec0206447393f9be7e09db49fb24ee81ce11ea85302fd3043bad28a43e27e8350ca57ee690960db673ce6981a91f6904b5694cf8e7a82fc9ce92b8d0d303abaa3beaf9b7f40979a8da2170337b3329f8eead43358ec3c256308fc1345269b935b610c1325089bf10b76b2d823e4e2007b98d1ee9feb9188fa67d55a3b5d8f8c44e03f85a25e5fa32f5af3272d4f6d29557c7abde5e8f08812dacbed6688d78dcc0bf8109c0ae635d3024f74a7a4b66a8fbd9f54abde7c4cb66fa7e322b8266f193b79e83a00978064b7a3d841420baef47302dab6be3bb565b52b0172ca579c04f209585f9248a7f719d1516738a281356d5eae4cf94c830f9c2a56659323176d860a47a61f4524d55c9ed7a2e15d12830282d45e53120e014406ede2fb3c4faf379a0619c1d02214170f05987f0f994ee8e626f455a6e4ccd9aef7ddce12482c00486d5c03e5b552162d31c9fe8febdf26b32b11b955cb4e0bcaa780a56b67cc11afdd823b4e6d2e1f19c4b9b322b012776254955fc1d91d9fdf2e60a3aa25726e22f17621b169994f17886edff21eb98a6e44ad680638d4408bf25d72b0c255171b95b749d009121142fc5e29fb8136c204ca241178593352b70c17f825eb47d94b2d653bb05ce44d90dcfe6f17e61bc8718f7363daf567d38d1f9e0fb0de33198fda0935dfe57a939e7d49bc1531e20639e17c251a379896a21a2bc287b8c16afda7707827c1e33d12d2f74bedaf00a0174560cc9e431c3f46ce7a114196009d9fae5a5b67d17128758c3d9afba5f2f2df0c5019d65268c7952012f0f3081da9d034649bdfa6c40dc797805e60d75cec58e248d546c840d5ff70f519569cd43c00db9c4eb20ac7f2b8f0c916fd695242fa866e351530945a22ba5f7ca7e03d64f1c2b226b21a7637e0251b6d4adb4b653227f0d175f03388809acd87710f624cec814e245813ed22dd3e5d4a86b518f0f01aa671862f05230db0893cc5c7c63c99c646d3b543c1aa35f7cf7908baa1d0a7dc7538e7f363035f0810052e3e0a32d8ffcebe14497caa4d5cf06d55ccadf53b946ee0b6d782269802c400453d779ac642679c04e4030926b2374ba764ce426a1fd601cb4f4c49b34046bfd800cdbdd16dbdf9cae67911c5c35176efeec2d8f90ab895ff47aa28c55caf2150b5c3f8082afe606c310f399a5db15869f9fd172d673ab25b95586865051853d518692afb14cc4c31379a0d34e6ae739047e4a332370788b526f60febf8e6138517380d1ebbe89dcf6507ec8621f1caaa60a31ac4724c9795c11df7f5fe9f9d6a24aa3db8150dddf3e709c3d05c7800a587f53073ecc0fe6c0a1d1a5a08edb554aad5c8fcf53f7715050432c3dc6d244a43153989050558b2af4a2874069be783b4805854484e0575069724f18179f015a79b2e79f77dd0b948b9807d2da3b197222764395ee82a18c9c772e1f4eca167591a936e0e89e9806844ed887709665200079e3c615befa83905929d23683fa701de61b5087b1cd5dbbf326a464443be837a5268cfd031de6bfc645ceaa6f83869eba38867b2ed9262ae734056463e286675c23667ff7710202ecd91047f23e1a490fe64799798d6864cff28ccaa5319f75e5895403e0234c397a296b6a4815ec81aa346f6f018aa0cc4ce14ce9e394e915acd686e7069ba363ab395c750dfa91be3a6a8adcae5537dc6a3c1113509df64c7e5264820759e8ae10417d92ffa79b98240a6080c5468b61308fc3425887e38eafe27fb0fce013ec070ae852fca18866c1ef9edc4dc8b065f4dd966276acfb0906f908b4413f6b6d46f809e2e2c40db079e7ab612c7cd88560dec434ca99e722aeebeebae327f508a68dd76c6e7a8c05c2360760f14cc73bca424e16d760f3de7567d63b65c7aed13a15c7520797836e69165337514a33e56a1fd1f6b51ec497b481f2e04e3f0a07185fd0663cac93299cd38349b1299cd7b1c289c98ba37d452363f40069249d4cb3444c2d1d950131c6a454876cbd31693b2aa0cd1121ae7b9fe3146ef412ffb5d7e0b3443ac8f7637cb70fbdb77da64ab3d9f65f4e842f149ef2a70315dece144c5587d19390a2a317f09f5aec7c08357ac04dd5794f8ca1eb5b070071772c4dbe157ea0febe627ccb8d05b4e5e6de8ce1983999354ed8119a1b75310c3aafca9d93875bb46c838e9bb9636e6c945d21b1c9939e5e47419d17c864de154cf732d9b3bf88e38e9a34e416d322151b23915fca8c82b2ae45f799f0925f1f9bd8cc65b7b404b3c84263f1552f67c6f52a93cb6bffc451d77ffce8c26645a934b9cea7f1d2f66981ade9647371bf465c5487ce1da0f26a16ab6ff463bcdfd05f6418dffc1dbd0706909431099053a641f85f805cad64cbf4863d3c503056abfc428c4ee0e8f23b9c880a3feafb46db0ec4eee7b77a9da1b71d5238f6d2e2b84f068601a405ae7715a27b2fee64a3e7a0ac430da1478c316213d851d23cd65dd9d0c585888d8d39e65b7785ab04a0c37e6201619756a0f76acf5ef2d648ec719d652947c2441c8ed197e5425eb04338e9af7463df449682e4b616797998e62a72add6dd847c319219ccbaccfa13cf2c25201d92a227174bb41582e25494572db1e89f7847d1c311a8499b666e8e06355aaad6c4d2b4d91ecc01fcefe5ea2b16a1f6b53ca3539f343545f9fa286eb7a8644d8da29c8b457de2e98368220a8233b1ca4e6fb137569713b0e37e7c595346a725b0ef256a20b8af2d3d4a32bb6ab22ebd7b9ab04eaca84c4b563acffd5a2441de85dffe5974389fd8917c52742a5fcaa25d2552740e2b6f6ccf75b2509c2b469e04ba73bc63514f0f469fd8e86ae93254502320e2f09b0eac70a89cf63740d2698eb057bdabbfe2e8850169f9c2de0953b44e2c22ac0d18d8175bc24fea147329a114a9807c2604a514acc03a79e6c2b20e82db914a167b81a9b3d28b95f2bc7df145d5c6764d48f39699b8b0db2053320c0e2ca2eadadbdc7da4b11c68ccf6d857cc8349ec0f39a392e6e13a3490ef79f037f732fcc4add7b7be28d0d548c0e5b7d88da354e39f2bab80ace8e0e4d95b421d56c53839f8057085fd2cbc7a6fea903106e0e3187639ebb128009238a14c39f17c436d120216d0c45c67ce78f47d3e0d893d172871a88bb4db4f4b5e37600760e0abcd27071c6384d0619713df8131508aa10e31f9eb5652981d248aa761a0486293dded0b4f5a6412066a71cdd7375a66afb347a386c05f9d5261eeaef9e81438c099888b124cc747153f7d7a9da88f14e5d5d064397e1729ccf4967b08b7298cbafa20f000e9ce7c825285254dc3ec4bddc607c76153757e9e13d7f2a1e7ab45281f5dc5c02c6ced038ffc56a138f55b1846505a270fad6e00561a0e155ee9a9b3ca7091e0c3bff998a0857dfc0fc5535a5db605b037bee32e81dfc5dedd620883cdc3f9d92515167f15c068fefa3e29dabaae470c25aeb90bcf1d0824a47074af63ad93005e804853931c2938f59b113c03a283294062eaf1baa25dc86229e60f87ef26d58cc845e21c02c577492a9d8a472f701f4ef01953daaf2ffc8441f2ad46bc2db4e8de0d240d75f6bce8e2d3ef872ed81b7b335f910489b9770885f901e062a8c9c359503c2030eacb97869754e5450a7d792b9c9a9fc6c45761669b3f9de3a872f1cb3cb500055681947e865e19e2d70714e2106d6766fbe1ffba48f0d2d2089c70c8411d616660e0d4c66c9421b7ea38c6f6694617d2b12643eece9d1b7b0eae0009b4fd182668bc487fb40e9e37a6db10eefd4c8ea0030d686c35b80d1ca30feb8b0e4040eb1aa2825e6ef8eebf3b24270c2f9d2b853844fc2c5b0f318ecde3df1aeab5d28263c84c16654e2cd72d21fcbb4c249e5ea07b8c81e99d38ff2efb91585dca4d30b6b4258ea553a28cc92ae848cf2a49d4dce5fe994c2645e0c5cb80d37ad5b9b6d2b1b5a4a194131a98c1f72a45defdf54c98783a8ef16944030350ae693c4d7f77eff9557cf8cbc361a2ec36b74834c555c866a903626ccac93907a296d3ece9e76b21c7acb0f0080373a0024362e763a9d48c7b0b3493df1c5e2afeee1d55b5195d7062bd9e15d70c21c3b0230c5d880d4b267d61ed0fb26108004c004d1af02694e48682d04cb2bb3e4b24452d18131a0f1b9918d8a332ce33fc2416248a002d27746466536f9ad8c63c2f958aa094a204c23fb56c34a75811e67cbe5100ecab762ceb428328a0ec8e7c635ba94c8b68e808f8edec25d9755938e0ba52607e77258ce800853190216aa89ec4b734290945ee07ac902ad5fa3bad53cac9ee2d65aa939bfee3cc8c98bd6fd8028c7eb4d6de3718062e1f081d39ddca3a0048927fea8923bf28e7c0f28456a24b3c87683f283436129e4cbd710fca12fc91a4749be67f5cdc16b9dca13b1de7fc4246759b8ee12d64f577240e0a3437fede17faf89c0253eb04d2559cca83edd949b1941a6509d89937e93aabfe7b8699cf37b3f1042d019f9847a244188677dd858ca620991bd6cd4235d8a0ca1799624b4849c5523d926d25355673ac4c28c11616f5c66c7b6962236394478676878319c0b5fcb1f8ba4becb066009449d1f453521c99933541bcb9cd39e889869100f083a2474caafe8d33fa3c187b88eac9655b62f760f51888d95bc858365ba1a6d62fcf4dc7429daecf01916a416dbfed1614e0f58f27b83f041e227fe0533d85a2561b3a454b784a73776701bf7c45214b6b9ab5436c660b0216a61bde8f39baf635de4e8afccde88efba7756ee6a789ca6f044e590962f31f7ef1adc73a376a8768fb4d725355974f06cf7b0932879f9e1a11dc211824497abff2858da04584377cbb716d96e5b3f1f8bbe8bd4d5f8954f5563f460324ac24fb5a7cb04a804d50ce6b27a34a1e09cee4a139f07e37e17a372678c10e2537354ea2661884d0d9aa40b9d5b5adddc48393d215f043dd0792026540028358fd84cf87c0ef284a14bdf98c5ed742bd94a97329d65edcd28865c52637bbcc1dacefc38571c3cbd71f4314c223c996093683bf1c98b6e24ca5e6c01590289ba91200fd1e5c3454c0dfd7f616fc5620e893898891716442fea42bf8b2d83d648f64fe6d0fab62dac3193d478668cc5670555c5c9cab099eb5c483888c7779e94d50ec587a1166a17c164b1fc015cfce9928ca418649fc8602a27749571ea5f4c83c8e092b17b7aa50885322338fef0a9925f10f2d7dad2de2eee37b80e0e6cb73b08777cf34a12444bc3077d2df0e6047178ecb80d712d85c71a2b4f938bc26b564e0b7a44c8cc94e9ba3ca5cbbf32c738d2f85f805a9381d277937bb18d71bff4c60aebad7991eb2ad7130a1fda1b4e7d2fca1ae34e57c8a511dbce8d95e72045d01a99cb050a96178aa9297dddc10e32b0206c9ccbbf75ae985c6884edf0047298b8129a488a463f7e2c3e89fcadb1ecd7d1bc8c84c1a868ffc876d2f380c76cff913a2e503485f471cd117610c9bb3c0a9ca6f42a58b9192b08b66f91782e08f305e78133c410a1c92e9ac5f1c02964dca0c97524f132d3293bb3833bd37abae78e885b2b0db952ae5451bd66fd56c91ec85be1a161bcb165ac350cf1016d8e864ac6979e6f197a6569f79c911d6245ce17c95c21633e6e136d5cedfe76dcc6eea825c2e28896ea9ebc3f0d42bb7ead54ab09d90d25dea4af920c372c484474f48c8e6c3d6e6817f8f113dc77a24b54615a5a6f5f7d939ba61adf5e56bbd373618b053e1e9059227712af1e594d414013ff9350b0b9e387832597074ef8dbd1cf4b702a23158302e01f798ee285e4d3bb43ace23edd8c53fedb4ca2a4d5dee003e893d63ac75cbce61eb5327008c9550de31d7c1e2bb2869c68386a44fc278fcbc301a0d5118fd56d3467fd47419a24e5552599c95c12b93633d2772399c2b694f6a9a7789984d78c4b65e5f1365a53eaaf64c2d1368a18666e7e7b1afea8ab36dcf5a5df6ff34c36afa2b69e42cfa0f03ec9aae881b9f36fe78f5afa4bf3f620d68899d32b04d1d78b5cf93e29a95c3bf2ae4e39c2d23722b05991f264707224e9e2fd43b5fd134d985dc9ad9f5aae541a9caddfa78cee20d7b8a50fdd855f258b0814a6abe4fc43aa51b70af80142e4585f7b7cf22cea0eac55646ca1cc6426d6a8c349289dbf9083387bc30d8da8463b92c7169e69e8b61e0d6af736edee28d8139e0f08656a7d0e63aa109f9938b2ed708245dc774129b876c2271aa35f2e0857bfa7e13ccb31995b581b53b9750d7658c678d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
