<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"afd71a53d619534caf73981b1868a97c379ffd307db361495629b80f747c9ea61d6a2cddb90a9270d2099d84c354600aa8b4b21ac561b186e8e917d823a504e516645eae78106a5683094b9a01835ad1b7c858b9b3a1d11c72bcc2a3dd9a7acfeb22773762407fc4998b2bd584ed9bb4ade64cdc58f5b540ad8381b355411580ab436867c5ff995ad9756a0fbf2e6a21286efc69293aae7fff246360b94ad854ae2758f8c1500e3d44d5186f7f5acf6056058e3ac83bba1fd5ef78e11ede3b53733546e27d7d66779cae47d37304bb27d1ef22589385437089486b4ecdf8ac112fd8abe4ef1b9ef89833ed116d6d17057dd74f9594f4c0706a684a11d54168e3223d2f8b3993f286faa57f1a3b9a79559bb87c3b59dae8594ae70cd2e685258ca833aa5270094018e7b3e853b83d1d5de28e12876b3a022fc987cfef4b5d4bd1bb87fb2e4c3d3ecc6bd63299ac1a9bb39cdd9a8ddf0a9b08d3e58ffbdc291efc141136d56b801085d0baa81d2c1a861faea6e2cf7021e677da1d40f6290ecf4815a2be54be3d13c0a32480a239fc0337b05d865ce3a95c8cb0eb109bd4107f7d37b355962039aed693b1afd907b7131beb0e70e39037999433887ca3c253e42b5e31b995b8ccb73ba9b80aa69093737dc4970554579e2ab7318477dc1abb90b28ca10e5b924d60db95e963e19b8667ab9788a1bdcd3472fa6290503c5b505a649f7efb9cc6e4c8dcb958daf02e3190c2544db2656c1f975eb6f9163c1aed3aae016c0be090fe7122367e765bd55e5069fbd08fcf79800351ae8a1134e4e1b2f7c69158b4c676ad2ea7cd9f4218d1ca11259d4360b3b4f35e7dbb5b3b2d57be510de1e637c33c0067118ab92bd45fbad5ac2340790cc2676be8d1950bd296d1d7d829fa3b6476ad0b0781bcc1bada3bd2b394835208eba22546ee42c61d7bdec7041b60038d15d60f3a74d7bfbe63952196c453272b0f6be2930fc4d8fdad89371f79ddc286f115110a80199273e189c28dde17ff0e862ef2530496432dee99bf5dbc9e45ee4a4f931e7a2c42231cf41cd54ff062a85c5c5059ed4643d09867ca05aa849b36259d13be037bc6ac0685795a49265d00a8e4ecd73f5cca5fe29dcb7025b028c48b3a6df47ed459e55a7f9c69703fe4dccad5455e0990b607a9e035fa5f5c53a871efd3d74ce4c84077a6cbfed43aeba50967221c7fe0eaecc53f1d5db81f5fd54c99039264aac69cb0ee3dfd8210ae2f630e9ebfc0dcaea1db01bcf0e30e81dd8f4626ea7fd99660650f0efa139778563280403918ab6421e78dacb5a85f2c5007184e5920f2ddcc9043f9e36b9338aaacb841fa5d5fcd34112a38720606e8996fae8ed87f9367b2e944bd8590b4ea03475f2923e421528f9e61c07875a3adbe7dab388ea7530f4eabf98d244ed76bca48f560de599f249c310c775a680306f6aa6f07b21bca2fa2e0b2313fdccbf0593455bf596af564b9d4699a2629fd64646394b3247cb6bf58756b94a5b58c88e0d6b7a0fcf87fc5c0877b4a252787c2881856923fe2c0645998b137f1e595619741a1e460947d32ef63e98a9c468647ddaa3e6ab545ee79d4a7b20920df3978573d20dd5bc92a4f5efece491cc7d67b96c8e6bc22ad07eb9f1f2435cc81d92ac1a72c79127228fcb543389c477695d4125c3b73ce5c0032e1f42b556a022c242eb7503f5396403544e7e3b539e7bf6d86753abf4ea02e36acdc5ab8ca87e4783394e56ef0aa56f8b76a64bf816df6644adf8225a63089fa658b4e0420d44b30f8462bc348ae2eb7baa59f62ee6bf0836057a027dae1e2884a292178ebb10744852eb89720da04a8154f156837cd5ac51f10411a606157093bbb36a43c3780d297f1a867e38b8c599cc1c6a1a054f73f265d10f6fb2e64583f9558a78b8d8079831e140aa7ba0d5563a0b31ba810206504ca469d387e5416e06294fc1f9a6966d94bf58193686e8dc89f1f391b027a813f6d8a68542181ec4496312ce362c57d073079b33a87d009deb8feac863a80aff84c5231dfa3f27e849c4ccbbf5cb0acac5779866c17a8fe1597fc52b9e42adb62e4ee69ce2b388e008bc8b88e18e7229d4cc752e4d7b71896294564bf5db316b3b13531cb1985e41972a381147d4442c10293a04826b9a71e17a15e710fcce8dbbf3fc90d905a36963d2f3d739d00ce2b11f0c0602a36fbce5ce2eedfca215f213ae37d33f276ef8a499a4aac5f36eab9c4b8a4c97a821c5e003813f42bb36cdc5e8efa1ab37f159c9952a5aec5ea73e502f477eb3931e7483978c86faf65e9b5071ef4e497a344ddd07710f61d5c1130cebd82ce433ca62bfc62463849df6b44b06058d3453ac17ad8f633d5d17951b6f7d8710aaa9c750af0aed7219745ec3bc16d65756171943fb505474498c91f685e1219ed383b6195ef0ccf964e309f932885d0308fb62e7baba9b6d565322d2a40e9ce97fd4927e7cbc221c3d42dd76d4578ef33b06e27edfd4f194c1f6afd0dccd28b641dbafa29968f53b730db19ccc46e9842c8b543e6b40a59c9b997839d026395a67e6c93e3eec3c6877443e5345ba740415b00bb19f79ca7b280c1e76a7baf7c8664b096ca9bdf3e6806d95e3e76b45206ea61b2131f244d000457a3ffaa934d86ecb5e75d375898a6429513eeadcf39036a995f06e2691d0dc8f0bc2da95685afb6d415780fad93cbc43207e30dbaabd8a16c18529876c4fcb3ce007a200a3c5a5bc6ba79e6c50dee4c2efffd0501849307963f0e0d5c54bf7a6342506b71549425777ce3e363f4b05e09ea20d733e30456f7ed045913f34a337d40e723bf18912bddff600cc65e7b7bda709578ea1a58767043f4a32ee5b9216b7ad20e2771c3a8c36c88bfe7006562986431f3f9bf5ab8af02d91d93e5abfee30a4a0ac0f6a5b48d68c6cce9db7a595837dc57cb932df2b4e3c5f5cf13678a50db297e49a58196ecbb141ae2f4ef98c026bd9ba1d92076577b6d5a41cc973b5b145dbee107fb8cb02cc0c36e2940763db11c7f60a442d76bcb89bc733b9eccac1a2bb41c21a92140cb60b8df52029521d9417620215d015222840b2d215afba1038c3e717ceb3b8bbf6a9d2548cfed314a6b147f0560419a6a771dde9257f2ed434c504dcd133b18858c663209ea9878f4c27420da985b756f1e3f98a4260efc735621ce80fba3ad6d4bd8de12c5daedf9a11792e21ff048d7a5fd3e6d2f714e8bc765b1a68880d615483d9707b830fadeb90276fdb0c873c61d568c98ad3ee623b042cdddbedce813ea237abee51539128904dbc47058c036a64d1d6f9087ffc6933507b82abcadfb57da1dc9bd02ec76b967bdb164cd4c9953c8bb70eedabbc4078f900a697af80f9f87cae626c672dd454fe7eff98b26fae16ccea13bc0235059ab78a22d56fbdd1b49856700767efa40382a31e2ac39cca996f4dad0326d13834739b4fb44138a55efc4a9d6c1017c2c40b3f80a1c175ec2be5c44dbc054c0875e261442a3e1e76405878a80a8c8c01402dd255c950e4ed12405572a3b88a6491be6a538f515a283f08f32b54c9bdc4e5d8cc940f831e7af662a77fbd10bed79d3ef5ffb15e357b446af1a59ae4af94327eff5c4d56fd82954ab45fa384b6d25c2e082624d6fc1b167f9f4ea7e8ee77b3b4a23586525e9181432e4e9d214c3ce429045d042775e99d608f24d9fc3e0cc4c6cb9a25f9bd4e63e1565c64a33101406a410139571634a0cc1af3588920c3246b0176c6ba5cb315a6580e5cad00143e192437b79411fccfaa09794740392b9257e7703a73edd232072fec03c43284e58c41c55cd0cdb1d6550a96a406ffdc2f744020ee86cb215e019e42ab5d916234b71c0308bc84e78b07257c57c46ad76959e3eeccf2044ba5b436ca919a5ae4ab550bb2d10089d6a366beb68f4e90cc61b297511251ac411ba450997da84cf8544e1215d01a18a273332e552a1faa270fc5ff7b63ca0ffc85f4e87bb74261ecaaf64f53777a96765826dbedd4d7379ade3c653a0dd50932f4291ea3ed58c13203f47c9c08c73b0081a93886d4a246bf5ea589e0249353a65609cdae5c38aea1dcb9f5542322e7b7e2b24308e07227608c069c3496a5f3c5841b90ff7bc946c76027f316ca2a8e4255b4f83bc68605e159e80f6f0828a2f7afe864a3a06793f76808712c899605b78424d6e017a1f4f24afaa94444e69890e3f9fd5eaf48c0cb35478a2eb4351df7b596ff0e3bb87a7aec696b2866821d1d8c81445def24f4743eed8e1025c4187ea5b139e194cdda7853a252ecd6f39dad299cde209e5751cd929c413c210543f406571406da407bb32149eba00f7b715f5fc11a71038fc79fa9fd9d87a6e9e0e7b080f24ff7f10b0299ec53f4e7a2a2f00d2095071287c08c2cadb0b70e7c1ae3ac487f720d4c5ac7ea0b41cf3c5ea2dba29650193a415d39a66f564657bf79be711ebff841a864aeae9f5a6f3aadecf3e020fa33673b32e582392d1ad612f02ecdde95597aa6e0b939320b1c64d36599d123e72cca5d1df1e14ec873e6793e4c19613615ee80ad720b54cf14a86d4dc4789435448d23ea1b1bb7d9fc70272dcdd2a5215b7c154f86347cfd38fdf8191201c18b6cf373dfb539c7150635eb96d5f8b08ec291181598527fd70a97f6b27edba2f8b43f63c184c302af6d383a6dc00e4754858740b883a532f30361586a3db7362063e346496fe60115062b3e4518c7be7147aae1ec0c1f975d2aee721cae98e87d9c29839fb4db7a688b7f48af6c59788e502aadb36ef483ff7f89b2db86516ad5b56176e37b79795593ca37be3360095ab21097b7422135103802168d371f63da9483a2ffee61928602030b7f87e72c2a60759964aba5a957b29a7c8f944b38d25fe802fb22deb30283ddf4b4eb81fc51b08a588d60981c1ce382bc09313d527ac4acad30e75ee88e91c5625db74d19c480fe5e9c07db16714713704e977ab42e7cb57d235e00940e3e0db6600f74691267f3b9f441c08176bbff4448f277c038c927c1f725329ca829593e821fa906cc760b3ec3f5ab786866ca874814fd98c07a8010fc0c43117e2af0c5f1dfc20448b03bc8da9063810a0af36085fff29074d912fd92b3ebae48cfc501bd22761ca6c902fb0caaad5b7a1e9206c0ff3d6bd8fb8498f137571027327b21a8aa4adba445174f310617b7ce8e33ede73d266d4fbb4f884866e9222407dcd745c20b76fa0f9e5b140e3fa24e6fd7e3750f9ac079cca82c66ec27bc32c2438e7839bf4d7e2d74f0009dd42ac64030d4366b330eeb7858b3515a5b0e02eafbfb9d1bdb877d65c335e1ff9062cc7fa91f8b0752f85db2be5bc48561ddc33b82c369d7acae074e188b30b23e9a819800b8b850dd14b06e21cbb758b0e5d2dc54cc73d5c7f006c026383c2551f259eb7d3440cb29277814e79b38e202e3b61acd667e0138c9e0d7064d3056dbd872289caf208c24ed0874d687b887459de7f9c2828a50ea520c35b93c354fa6fe40293daa40ae7af1366181f79cb0bf04c8a75318ed2cf4aef0c49fc8c8e69224caece3ce800c95a6da66041f759799e76c68359774ba3a180469f3570297fa7d070814d11e177ee39ade567ad721461df47d9065ef53f82c747c88678866d183e56b33d1c512c37a53b249c71e411167afe25699b939bc1e29a485e940d6d469a9513d5bac24024ff9fed19c295cc5d714471951ccad90e8472d9947180b5ddb16d90383cfe76f0e5541fb2ca880e3484c37b4e18fc7509e1fe33a7dbd1d9cd5f7db589c67a60d9941767205b61541cbd3bcdd92c2e7ba476b0997dbd8b63a6e34433f59db1c918ced7b76d2fe8d8cddd5fa59a1da5bf3dde3b21156ed6c58e30602ebbf47ca65f138d44cdcd31286fec602caebe6d3ef675edfe775b9bc69dd66f53d2b4a89786f6ee5b713c2561698005ee448685c9590378da33c02a187e9610dcf5cfdf4262863956541488352aa25f30383d000cfbcdb20323d10d0f9b216ea9e883a0242f082ac9a92562d485253fcd5e820688b2922135a6fdb49ca47b47856bd1b90bccbe49098ce2d07371cb10d985625157907b4f2b57904aacd5944d40011a14446158932ccee4dae0248cabc66af6e8d52a5cce927f0a6ec1d7b4c5fbd152a4837d7ba4973a3679f37eee05da9ccf7032ccf84d863de0568b51edd72421d73e02c5564bc7197f511926cc40947d68e8060dcb665d897b100e9460a09b7fdf570c672ad498d54e589049109a17c178751aa3a1cd9fcca7903a39b35252dcfff5c837b98fd567f99e7e7eb94919d797d654b97def34fc94541d5a5a1860af58d8b98fd3fe2bf410c47bcacc2e7ed624c4b4bddcb85753f9228b7e38eb1c5f7674eb091833294d38cfbbb477ba35a47af75753113a5eb5a58411e978dd0ca242b1823136a5405437d5cc5eacfd8929ce7291e5f8f41e3ef693eac2dfb8fc55c7fd3570b295b1aac33b59c42d57cbdd5d0527d804914dc26c7e870dde446e4a3eaacf66ff38269eaf422f69f461dcae4e8b2ea1f17d429f7616c2871beb66f856dc283dff0b6ab9aa0faf18d8d20eae27c85ee4bcef12f0feac4b16c9c41f213819bbf58c20ff458e4a70bebaf3ad80c0036ad5837b089a65fee1cdc2ac541cca72dfcf5cb5b0667249a5723f031b08bdb851d4aeee01638fdb1b9e20c2138bc90c6f27832722faab52a8249c62900ab4b3984945ff74aaf37fb4c6e2061d1dd073565b9bb8ec75a459b59110e565763022160d4fe2556f4b3b1110905de69962aa53582ef0482a72d83f6373c7817ea9225e0d83c2f273ee6a9b3f8ff95705740ac7cc6228862fcef7521402e9336a51ff1f597729214e3bb6ee7d9905591b8ed70e836c2363a9939065a6dd6a311be922e5a0877314d65ed3cf30e8d58da10fa0f571d3d9fd1d7c808dc08be1e406e8b0cdc25e39f96f8d46126eb9bbfa29bb22ba6dde37096aeb4da97759299397168c62bb6b044ed3c7fbe7affb57b93c98eb26eb8e37d0cc0d825bc0cdd98d6825eca9856074","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
