<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ef82e5206cc2dfb57c8bf07c30efb29af08232ac39547d6c1f1a795d4cc3394111657b60da9688783f9898c4cbf571f82e29af98957e624090a78104e8e0d94f9b5beb96333331318b0c948af7b4dc6ae17f84448659312b0da359b68e9712f80871247639aef8f0a1533766f2f7b8db45ede50cd5ccb7759d38a86e489a15eb741dc6bb01200479aa24e18fb9bf20afaa7820b657ed34ef54cea5e55fc2637f14076314faab23e2cde69a742b152733ec9092323c37eac6ceff1e59a3ebb9d9f0dc45dbafad59cc96fc0dce046ede016d3934fc1a08c2f5a741e9df596ea82c0f2a86d86425e9bd684194580dfed651e9ca31c90d0e32cb63a3e9392801ee6c4a627464d75e6b139a55cec445689a0d14a324fcae4605f990adc51a1219f395031d1afd0ca84d72194c0353fc9070d2d2c63d03f50b9e1cedb430ea6d0cc87843111ce8ac874546ae9319b417f34e873917e39a86b93cc8b7ff762e407fda69d3c3403179755b680c3dad646af76daa1edbbb2abd939866d0d15e35415f2c3a7ae9ac96af3d8b8108490dc52f5b820d3ceb9a60b480814eb77350cfc8b9ab3faa9d5e9cd818a04858cbb5a2802863eb8c0bb125cbd800f0d7af5aa5956ea28ceedabcf9e0e284a3002ed5234c85e1022133a990dfffc56a20bb4e04632c903da88eae629e8fb0429c0ef67288dfb261b94acaee59bd09d5dc9e5f42fa974ac720ea316b373ebb0ac0979f69633d882655782292ee630e8b16a810eaa76bbf8faf87d753f94d57a60f2a8c39d8d31cf4d5cf8815d5e16d816e86a38e3d84012dc16059acbe02f2a6b7c1e97e85997bca78d02a018341c52e530dd2e2b0b9049e24163d0798962139bd1f5fb40912a40a64dff1bdb2cc37ec2a2332284a693afe00602055e355030c04b1323be95197dfec1d6034bd75dcda79ad12d4d26d27c4d1534075b9103365b67722148753d76351e94faa73ee5014ef6b564b3e24ddc4f8e21b1f29bb8fdb6cb215a7c33f2041a7638a8858a075f476fd9ee6542b09ed8b5554e8a4304b9fc4f1ae34a2218c2fa40db0ccd78df5962ccf510cdab36f89ceddaea1d94938c0955f4c2840688f598eacd90d59e6c8bb2aa5ce38d54d3c77781ffcc98dfd52411492251c1ddd218b410e0eed3b6c671f1bb12058609809950cae955af843af26bed811447c7eee9e81ce0318f88cc944199367a3c0d1b83aa7f64e3cd1b40d01704424192bd8f9d0afd8f55d93c3631eee734242fa7a478096b7cbce827ffaefb429de6345c4be27f9d48851ecdc4b159de4279e4b8626a1585bf3af283e8f728e7c18d3ccc64a71e699282ff505982e37f0d0fbfe619ad072a441dd3ff125f1f628bfcd04949188923fe7e5cd1395036c5504638c99e246060804f2d73e7bced4589d23acba175cf38880f42be0ff48a9f23a4225e0027e68aba6db498d2bbc46ac716998272e4d81cc595dcfc189edf3538974be0d3b30430cf07dabd0c4fd11e53f02b08676615e5f6d580652e27d2f175b3f399079307f94479c46c33c58097cb5a845752fa53a27488eb400842bf90761e08ddbe6b7758d073ffda4c434bdbab7b7c0ace4154a6c9f03aaf0aa58eebf1ce7af322c74145c0c2a5518aa04bb428479436500f1eed6087d79642ee5dc1612d598769f280bf7dfa1363f193bac7bda55b116ec6155d0a64135f2ae3b089a995fc4e5b52ba8cfc7744a9fcc3ba91d6f2f2f64b7bac0ede9749e5d527aabf471a970f10890fb7e783a0379a541f7f5f77d678b04a0bc11a183a21818f6256863a14756b4dfb6a957fe5b5ed4b705eee31dd38f91f425112c6aceadc8ab55c23f16b72237e9f6d110b443c00665f7f843fe36ff75ecf92a65b07ab2b95a95fdfd5541fd412cfd0b5d2493d068fc53826774db262320812ce90df664c4fc1591283ff6cbbc378c8acc9dd3ba4ef11b2a0784ba0961220910b547ae72f9ebb0288f698a45e7b3a67ab21527226044945c987049b39add757e447353b5fcc7b57716f107688d6050597878ee6ce4c70b1629750fff160a1edfbcd37d6691319037c8b9ea018fd7468102374540782d09ada6fea07b8f131072d132b5e7a00a7b1c26e81c2d9628ec3086767d4ba15b339b7f080ada520a1cd7f37cea214460c49ee156ec343b60d741b04dfcf72954a7ffd8c7946412ec13a5a5a6e20bc28b8d2577bc2c4c3215ffbfb8edcbe72b9989f1e602b2f6c466a7067988a8902191e801b2f9530443dfe4ebd5f01c8eeceb473e6cbdbf4f2c9af81011ce3762fd39ad8659a077669833b76cc06f5631622bb7ae9fdad21de5355dd542c82d5811256cd71c13e6282e0d227a602a0752f79a7f79883303307dc36592850bd7372c908f04474b29aeb253bf791fc4f6a0d784ad0d454d88cc5b9afbb18b6df92b2c8e4e7f266fd7d7b3fa33c972786c4ac394dc7068dc9c2a5fd44d992a9c26db440af82e8217661c9eadd2460f5325d8cb965f28e6945e396d1b3b968567e08b5b855117efad9439f1ca0bc50a30ba1ce453bbc2ad92ba35874491f2b0573949c031303735bf1d27200533580ce2c6993ae38f485f846a97a22821fc325d3cf8bf7e2c4b3cad7f28589dc199740d42f00e80925cc8798571152a3edb0ed39c88c9216e19ebfbeb8b927a59271d96b882a3b56e9422b5881ab6a0613a1a3148aa463c5b759e70871c91e449d1627d49f6c45dac6f198f52857417385b3466cba7ca94edd8abe48e42a62d1940b52adb551405abbf29c81c71e8b95ce320dbdf977780651d2a73f551d445d83b5a11f43426b2f73b2c7d36418c471ba34c7bbad9bd56105a26f9254f27b692b8e5c43a94c9aa0cf0e870a4d93dfd8f3e1dd6522be11cdbfefb49047a622958e9f759d5618cba087de0edce57f083dd0fd0bfd3cbdb65c27ddd66f2690b55b296bfa942e88dd9bd11afc72b00cb52f4c4ea22747aed9daf984b797113bd60c1731df215a16eedfd46bd466d1c1c401ceaf6d87ccc97a784640ab47aa4baaf1c1cec7984319fbd8cff734b4592522282f24ac769101b191f70c3f7fc9d596db2c6272f2be06164c4a2281d863852481d306b367befb4b77cb269ba97c349cba4d8a542473f550aca142b2bbecaffc156129c75b43b1f406e8499cea056b0fa0fc1ad0226edd1fbede14a0ee5b113ab48a96575f2a0318e22504fe8c74b6de19f32e7ebd3d4e6f5f343a8227244db3a670fcc6ca0d96248408b6aced9e161b94d9fcb04dadf3abe2e8e380064f774963a91bdb145c59787fa5f9c8e1df04cfe9dfc1928de0637e3bbb5085fdec5b1a57abb8161f8a1db9de4107aee300c44cc5f08161e1cf0e183ad4c31756b97f2c8a54d80823c366e815a6176fabc1b270ef24c1eac363bcd174261555383bcb4bd19bdfb159854b5d4ea3698e608e13ff48f7fc0672f6fb9313830d77f742b7c0bd1be9a3b74241cfb5adf2e2df2f62cccad08274d0ffc341edc7928785dccfaa1b8082eeefa2ffafd545651ec6bbccaf96397220b56c0b2f84e81fb3fb7c84f94d0e3f3190b276971bc3e359dcedd6253ebbf0e042e9415afcf6b7fa91df46496c828ab5d1eefee5385e3d83bd94c85395dd67d11526e481681b7f435e1034023279f53d39a0945279b2e49011a5b5d4c4ee3d4b3bd483d24e7a4807aaa4fde26744cb2a3d214fec51e76ddc5052a5c3a591beecdb713c5b8c90a13308e6ac3676ed71c2bd4f4d59a51d1555a4db03c87cb4867a83a8835bfbe1b88097078fe3959f4a8bd842b687776de7b7dc29103e8214f642a9e8bd158c3ca9ecbc9cc2544b301071a4350f31cad9576cc01a51df275c0ba02895124ee35cbe7b9491f458d5d0b0283b1f1401af7e13bebc04d909c479e71015f1721a96bb23941cb14a5d5744245e83293beaebb2a8229cfae187d8f264a06d76e28e0a11b33ab1ed88e3f2804b02d7cf9f40aaf4e659a5176dad7dcb3d04c0ea4de617bc896b9e7ddf841b364e934847946d1e57dd4be94f2005c798401a08d878789e9a4f64c88909cb28abaaa6bb8dec0d7e7f38d801271d9c9fd5a52e8f42a9eaf25d945e633f71d8e6199b05319978c7d34a864b083038df8459367e7cff33bca59b10b05a02b7c3f89d6b4331622fc9938578523a37761edb3c1db49e8599b70049a0772d0991f8180b23842085a8b00bf5a8e7932bc00e5f087b69059d4b6f2271f49e2d500c061b02b8d8266ffee187a7663ec07ea663c128b48c4e55fda6c066179cadaf9c8fea133b7321d4267435885bdd31feb26a0cdc8aa21b327bc769d610a2dbfb0c50a0adc844f04fba3577224f12b3f01594b7d504a0466fcc4d4f86d4232f1245a7c87c070f975768c2b2bcd49f94b20b2e5478060c09f1dbaf4f5f492fa651e35f867dfb67e9a1ac97725a819653b2150acb01824272a0695ada38c36208532b8e7d337167f875c20626cfeb0e5be39914d6f32f05b258f05cca6e8f18b3fd9a8f42fae001f273407aef950d1a7116c25f0f2a81ea89e7cdb3f7400a39c730906059777991f0ed572eff621f84f262739705b6b1b7f04f83e69bd2fb6394729bdc0a3424bcaa1a450a6c6fe0698abb57327e47d4d704f4151a2f91ebc5090dfcb5db96c0899be9c64bf3deb408b3c367f85136cafbdd6311ffc710b93271b396eb2ba5ff24fedda421c903be64b48e2ebdae6302dadbae5a559f819679da132f5cb60a8a035cc2acf0580cc9b297a7e8c297656ae8265df3ac3cc72f54d71a1d5be3f314f62bd2fd65a968b86a17a0f2d5e8274dcd9aeb1d865a54688605390ad7daad786edeaa5bac920e0b776e5d7e8bba2aa694498da2fde405968f0ae23ae4da9f0dc311bea37ce8b5b84906aacdf1c90b5dd9ba38a8f4256f3586ad62cf350841f31444830981b148f128719c8b02e2d27f281925f0c8458b61212d5d4ee0bf9a88b9eed8966140aa65ab8e24833f78040893b672aad3e73e2de2195cff9f4ef768589621a7cc5e98551241f4e88943ad7f392246de2c45df5e85d498551f4463a1395226e41b81bc8b64934fc3f639097f20821f0e14eec9bf89782af33209d1a6ed59d78e0075cf785c53b6396ebdd6a25ae93a481459037e0db3ebe5c1a45bb68762f6f60a95ee9e7a44cc262c752d194ec4c398ac553b100a90303c1f7f4428f387bc44e7e90db7043ac2a72d2b22b400956301a7eafd5d5e074a3f649d36273bc9d6ece11f9b7ad83f5dc951e115436abce495fb512d47b91c30af95f280a07ff6b16b1f870a213791df931f781ce4fa1183dcfca4a9ec23a38201e45d796ac4dc95fad252e3a92ec7af7702a07f8d1e7647cbedab8c4209299d7281b7504851a36df5bb95c3983b22af0b1c43994aa0b5abfed7dd03049f8a4fd6903eeacb0a1b9d95f086c346e3ea012c8790656545f0b8681e14dd3308b532885d9152916b0304ca5612b7b26d60134978787db7aa03a38281c6d018097b6e515048f3ad54d9c91645f3f62070ee473da19b8844950815175242d1868622d091ad3f2560cc17d7e0b5c67a25d1d2e8eec969b598171da033754a4fcc176f7b2c50da42e13ef5d12fae579f5c30282b8135eeac0647b9d24b900bb34f8a34122d86266633d434b93d51d5fa77503f3977b015702259eddbec36192acb4e6da91ce86ca68a8bda9524568bce3af9b0e7fd77a4ec2bc9bcae0d3482d58e05232c1c726ac21e60c0e53e02617cc1e090d083157cfab6fef793c0839652260f7ff57c2001282ce625e937de481e0057a25af54ebc81d4af07be3f7b0d4bd4c751782d680cf4a1593c3b5f5494c4caf7092fa85b9a6736198d6ab619379febbdcd7a25c3755dc23b61bd2676547aaaebf3bad339ae3a099ad84a4b738edc78fc28f9d00b26ffc489ee1689c955370ffc44b644f81289c77676454db1cd41434d5c7c2aa0b370f2219ebdae39c274b61e2d6f4feb39d9b9bf7ff86eab70b26c43005d6a99e6b7de6d32615b3c5a6352843ca20a9aa244ddb4c87d060cd0be7ce32d92995ecf8168938b374c167601778cfca9ac555207e264edccc37af17caeb98e3e5479f6e39fe1dc5dd1db9c44f5feabc40aa78d1948937af56dfa7d7d42b2c1ff67166e56776bf5d73c5ae0dbf7126d5700a8de249839fcf9fc374b2139ce40f2fca4ba38e031e03beae6076cf070052e4e17be6f3853c788661bf1bfbf38c50c88f2e6032e83a37d15a4943621a22fc8e3fa7b2570671a845874fe48a9af2b6da8c0ca8acd1e2a395f40269e99e5d515f3c550afedaae681969b7326df770dd31711cac6f44012df9712b717fa63d1ae82adc9d249104f748faba1bcba1a29faaa9d088e8e87ac2f8da795537fc10dec475660011f0b331472cd13abbe5bf7c80dd05835ec5418301cdb550f9a109766b28e61487bba6dbd121ed0fcb3504773ecc1b00456a197f2cd5d0893d92de5ee00ad3c2b5d94a25a4472993dbbe21488da8be88544fb066ca7dfbc3b9cf14e60e4218f2de5520526250ba50b400c7b825da459e630edebe9e86be43e1bcf1d805c45fa36a1eb3308178712164049957c12f42250ee5da9610a978b800b76d65fefb2f852b6c061e67a27e76b83a6f01e4cd2bbc42a8b6254d6866a08bc4a76922501f34489e16ba9e70821685067ce1f9efd06ffd783be4722b4fd57321aba7aabb57308393fd88b526da78323e5831e7e1668f6bcb1abecf31cade43f2a8ce75e33ab406742773dd3a995cd99569226c8c205e700eb93bb7634c42e4a176e99cb28a0ef1f93be268e28921c9f9696ceff82699f0f8414b2d1e9c4f582c28315e799b019f2b7d3b36212eaf00ba2c966265aff3290d0f7398288db0f8d5192d4d91c58fad8fbb282d993be37fe740607849002add3e0c3436cc022bcfc22763aaf10178045e7d8d715d1516496f256e37617cef65e258e5121b0c59563f655cf5ce256cbc7b6ba5f6fe210fe5a62209b6b67b61f082b9f1a8b5cb45c06e52c4a79bb5b74bb752f6e0993c9a6d639b56abb73fb1fbbe8b6e3b9ba105df9c8c7d53dfe66293fa40fc33938ccf3cd3eeec492b529e8f173d6280ada8f27da6caeb54065597916717d9f0984330765f077dc140607bf1cf2e8417a61340308d9f18dcbf0e58343fae73f1648b0fb3fda2b236df818137305bd75659b1c9937f720b37330ef568b8bea6dece4c191fc1342e6a30a6d6a555704179c0f931d738b44760849990eb1eb94e3aa28d6b60a97ea132a2c9c5a24962a3b77b0f192b9403706963223b23a9a3b495a58562f30549e991dfe7eec7602ad8c2be903024e745a1ad1a8bba0640423877f75710879f868c557b58b143e7aeb6c789dde8eaf628c51b10687c654fb5e5ad31f4c0cc369154e9575c4aec3fa28d60a6a959d68c36283b09e580b1414736a2a26415d2a5dc71040bfd03c394ea015e2a401b4e42fef99541cdce6ac01acb467a2692b7642c13e728cc3bd79952fd6591e3e2c29fe0094fa8bc7381289ec6a2a05a688c86443cc370a79c0e8a90faeaa9bef7bb8fbb2ef72ffa95c771bd78d20c32895d06798f5c070bc854e5d7e300be33732c231a22104d044b25493272bd59a473edf5157d7f10c9a74ea95f8120e29b7368c98bde8fd797516c658c2b64994aa9e10e77a3b6f6b6c95bc9f0c65fe5b9424742f67335ea4f483f096d565769394a015689db10bff4dc7edaf3a099b5170abcc5155c40cedd192b500964218fc470bd4eda561ec30aa7d9d3929e85846b6b93af5b44f60e7cb2b6e057c709d34afd5d73c74ff61435ae45c8daeb38628dcee518f6cc97e0a70f193ccca06afb54cb5639ae365fde55da8a2cb54eff05e42e13ab02729626ba161130c1f8710cf2f13721bd32f3876796afb2c6b8842b2ccf9a737f15209d88c7bff280d3fa95fcdcd9a1474ff2979320809a0af2dea096576a6fd696d4ea375b8f8f24ad9f6b8ecd9c6c1ea34f1e588c21e94112a8bc825f4264a70cb046df6ea5adb2c9d93a5c3de4a5ddf0df62fcedacda05f8e3531bab385febef25716c15edcae4aada749a1e8cc9025961aac7f35ed0d0b3cc2c79c4515bf73c9fcf8f7a9fbbeb5227f56aa169da1960e82bdf6424abf911392f954118260a8790e9dbe5848ea21a8a2616b4b30ece3024c21d59a02e5cfc7f9eecb894d9dcb08de8a881cacbff926cd0b3e0e7fbcd5a66f74e7d43518e1ea9dec9cfac7f0e7820283d9263521f5a902e7d32a42a92934135975e3e439042fe569f7ab6cd86eaff40a1719c0c745c832f50cd1bb39ab18e1536de419ebd50e889ac33ac40826a93f74c8e508d642c886b5486465b7dcce0014893de49d3c36d7436d2cd8b0b019e2fbc12730267bfa84add32f49a0d15274bbd6455da486855fcb1a5cbb62285f688de0e65723cdf9b230e6e6dff0c7c48b327522ba98bfae9020ce73758f0adfb7fcf6820718df4d7c97b9da64ffa28e4c7450970a69ffc2500178e3f2e8dbfc6b34e034ea0dfcaf0221eb62de920b7c92048ca92dc0e20909010c02f0cfa1bdf4d324939367fbf4321885be46f4ebafe7d0ee23a38e02772b4c8ea20df47a0136e10abcf841cf222cec07581178787d4a2d21ec508e0f062266abac410595395d6fe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
