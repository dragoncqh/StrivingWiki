<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"204b70e38e2e97a5343db10d311dadbc1c568c7bcb86a15d49a80a39267faa50819f3aac9987bb341774279b6c478ed6736b440cfb034233adc8ae7a8c7d208d7d602374d278a57b5be4afb64e2adecdc5ef9c18da5b7576858f77a7fb0357237ffbf2f935ad88a0f0e614e3f8eb0e3212ff4a76be7a62a35e307db88a679ccda33e4fcddca1905075db75733dda372d72e18cd61d34a1e2a19a8a726f200ea7fd24f557479d610e1f21fd039b5ead5edabfe1cee96b144e5263e2ff1d5ec5a893e72a75c1e46cb928d482b39b90ab559e5d59a80643ccc2c95408bf7e41e11b6048396b2a2e82cf3f288380fe753db82289d21c961e879b4b657e799ddbc734ef09ff590ee27e7349cc0268cfb02d8b5bf72f6c76a6e3ae487b40927e1df8d0ffcb2f72a87820d6b6c9e80b3ea3f181727ab87a1b70ca67e2c8c277d8f9e0e5e1711daabd022b337f4b8cf22c83d3af0779ef6b5f1fa65fbbf1c7b326226d68ed91acc960188cea59af256cb42ab978a66c4040501798d4fa926dcaa2658d4d9085e0064cb6af8818c62966c32a95fb708a21717043ecc7dd5aa50468d6980ed2a2e1b0074671fbbecf9922d0c31bd9fd57b2c57b63216a87d0af630bdc387a3111e539109ff4386c5b9b8f70a0633a307148761f4d80aeaf86c5eeb1a2fd2a072551a40d5f4d16513bf7776793d7a45654781db32a5c3ca61eaad7a422c6856ac5e88c8413765d27f143a417e3afdd8b3cd35634f2c08186608822712d3a50096d3eab64b10cbd0cd262a406403f145c66912e0ffdd5a3b9c6f308895f433af0f3233105dc0edba942579fe48cea2f3b505d3931c5eeaa7ec47f5547b2bca7a208bd9734876a0a155a2f1f4eed3b73004497aaf7bb217907b1b548e71b893d4b9b17d665afab69d91fd1a02f83b4594991cc8f06f8a121ad28ea021873eb9c09ba197d4d38924838eee1da80452717834e9edc04ec4939f4985e6d658d95e44022696f398a533aaaf37cc185498d40054d05916ba13fab87c3318fea3ee3434ac83a437558fab012dadc5a2c8aba7b0ccee8b7db2faaa77a0cebaa42added91280600300040128a7f7bec93c951c9c07fd014a03bdca9b57b4bca161acc3f705d7fd8aa3e4fb5e30720827c7d019b415f203bb61904e5b862b69d623a12cfa43c389dcd931074ac43bfe6f0908cd4fde089d98d1bfe25667f48ae4a8b581e8ec50af72cf779468e72af380486006117aedd7a9dd54e98af421901e5dbec99e587738d189ecbb357c89978b43cb3801327572a49d92f78c5c5fa45dba2a1f786d40d0cd473903401b3620485940440b5d313d0468a41b4e2b7aea98f5b4d1de6423b9d6a7a9c630430b3cb1281cfa2cdd820319d61dc430385f77e1ca7e04d342aa3be8b9b21dedaa27bdba9623beb44f4ed11a487b8a7608a11ce66c2f5748d20650182c40681a7d8033eaab9665caf95df608bbfb39999a56037da6d2e19a56a830944d3d766826498ab96f777b4c320538818f8eb24b8a2cfb12ec40e7ed8371f3ec3db19fa01b64033553d799d852fc13fdca93c77fd49fa95bb850d3440bdf850140ad1356e38d141c0aa2926beb17e2c7d3e80105b83352eee8cb18efa0eb589c9552437ecc85b684eaaea6d6518db982fad312dc89ae2be030d5cb569b980ccacbd89890e311844a1c234c415eaa04f11a8950978866551959c19316b489a3aacbde29545c5cb60f2f0249c1670124ea17f1404c2b83a7ec9b07a709234692f67fdb3de8fd8da2b73c4e42839b63426edbc0db4af9a99a55b2e7314b3672ea630c1ed2f8744dd8cf94ebcd361fbd51e8109d9c136abfe4b362ebb9226cc344e5bc8760af7f1091c5bffae3ff8444b38805c66f7b70bd63f696faf6f2b97ba2dbee820f976405e3cc97c85e845584509ad3f43eed2a407c3731349ac535c1f76be0e7aa629ad9d16bc97e2a92ebff0746740111bfdca7a3d309b373e1a494c675945eb90818819acf4142ee43cf907c5896e2a28c433d12c6e26b9a8405783c35c8a4422466b7450f6152e7b3afe18b505a7cdcf14a06e762e2d617678655cf171a20fa85e5ca2b0f828ac0f49a2a5dccbcc313a530f5a3e72661cc93e53cada23da5e3042ff04f9d78e98ef077fe75fe6331fbba003e046d7a9a5d9aa5b2b67b3261f61945fd5a5967371f656861617b51eb43e1aa1124ddc14595ee4dec3b39b6e7701e468246ea231ab22c49a1e8ce0ed9fabe499f7ed1f9abd2add40c50c1492dae613403295dd9fa2cd50e620bddbae9573912a985200db007b7bd0b93e234ba2f4e7b1bd0144080e49112b6d4dac325de6949c79435b01216b3cc793a18485087ffea9c24a4fad7e2f8a136372b38a7d347cc41bf7b20561133298410d2c75f3b4eea7ad764ca8e9e4189286e114dceb43557faa5300e0405ba35d0bf456a2e41120efce81daf63c6a928d67c9946f24daca9e1a00d8edae79e30ee4ce9892b0258f40bcf247395c6492e0f8e19f9ece09a51cf13929af2074231a910653c820c87f4c91596050bf8582c22d4fdcb0d94eca24d9ab029ce62d0eb93d0d7c4cd2fe97da391fd2aff69379a585d24f1a2abaf751bfa6e761ec63dd4ae9f73397d7ffe3b4b132554c7808de92135aecdc420e2b14ea085b07241926ee8ee3db0ba774bef237cfcdb704af975a2c276ff1d19cd7ea5b486068421151782d2dbeb8914c5bd59154f63dfad0b2509758304d1210ad0c2e293bcf83aba6a22b5ddedcfe5803b9f46c3e3cddd6bdbc8026fdea65d24b0c3afae678eeaf414f47b1c65cb487f7706204071bfd416a13a6c1434c7cdfce6d9b546741fa2749e6e81694dfefdd340b2dde3d1e687a4855a59e3d5a79776fb8529f486af6c7fe2c07f53e18e762eae8dda28af201d8b816aa2ce60b16f40a0a8b46eb235aae61dc7961068a6d769a324d711923b81d7c750671c1bbb99c0a101b5ecf0a6fc9ac91823b3af2f1798d0c24573114aa15b9cda44440b541c7add27d0f0517fe38c17e943f29716ede3d3dd76ff7b0f5c7157b270cf85c0d897cec7e3462164a8d1d49a040fb0d97ffaad265c6ffcd5020cd75f80deab71f8ea96418a0ae7e31279b171310d8234db0a15c2ad48176da1b91e32758f64ae294e798ca06211ce09a25afdb06f3b71d95d5fc4f0594b1794ef1ab440aec935f0401443a10e96cd1b809bbf4345cdfc21f4d37a6ca466fb044adffc1be51909e057f8c57c6a8873bbab35759cf256efa5c5eca201850d2a87fe33ce86b1cb08d61351586fbae797bf0f166a1632c7ddc2e4b5acc49501a6f262d22aaebaac4c26e60ca9966227c864298c6babfd72b035fd1780c0e36c0e86f1b9c7694a2f9e00238b067d91ac9524949dc0bb878178fd0d80ad8f528db299a8c6db319fdbb394ee89f6dd63d0d80da01575bf769e476aec995851889553110c937cb82ee81a275ba6e00340cdd67bbf954179438ebbc14cc074fa0006bab43b3a08a01975ac0ff7f6efcddc5ba3e60aee181d6ccc8492cd73e0ce34f2130bcd2efa9c5d9258da489ec693c60661c093a9f6c388a3662d2fe012e726c1e7bb66e739272a1c6a0e42f627f4573281a0c813d7df7672c821a14bea750948a27290a53875e5b1251f69c362b0ff9b4c440824391f6070d529ac53cd444d46c61f21163cb025a40e21899f84e275d809f0d9de5b61899f1dd98274de5e2c4f69afefa825f98aab383a945e50597116f03054b737085a4454d2b9e9837ef8e4e922c4db67c6ee96fbb47fb1a7dfb6fa43d583d44cd4fadeb9f4c8c1bc90d540a1e842773e2c37919ff3b0ab7eabc7b6deadfbbf1437acc1671095c8ade00348469581643207a625ba1fbf1db86a2d0a45fc41597e7e39555661f3ff9e3659fb96d6f3a217d9239cce3e30943d37aeea6b278a9e0dbd0093b2eb4b6fe0420fcebcb3c1cc89508c7206d9e0a9513c5593c7e4500e0005750497364fe44b053d2bee8fc392dd50c82d50a7d3793c1583b0a316555859be981d38ca797ad6757ad17c439db943e471368b909abf5919f8c3088aaa99dc420448a0bf98e831a0d4c02bc52c4a4f085965061496c5a0178de68a1de6dde59898ddffca82507e1c99e8341c1fc648c84465752f7ea1f553b18ad23a43db9e26af9637169cab7242c4e974804d64e1e704da9dc8f2b6f889b6622f96fffa3ff9ef230b980cfb03864e7936d8b3b538ac84717e2d58a01eb6fa37bfbf0955322e397ff99a5d78fc586b34c0824716cf49470dd57e55a5cc253aa7c5b4e52ce337ae3f15d2cc41fc945a3e65de24203b37e5b25e0bdc1ddc861433f62facc797952d4f56f0b1e605f71173832649fb63918a9183711177cc703c810598c4dcb6f72600edf5de9f81b1a9afb11104a79f29a6aeeea535b957c58a1c0643009522f2e70dbf0ed621ac737f2b332fa3006fd21f314bc42c61397037791af9172366f5e350f4ee05be2d0fa6bf54dacc13a58f36b1962ec81ab497797bec1bfc27866360b84155d77fb1c274f064d312ccae0732171663835be0f1b78c8e2710b83596ad6f309f9c800332d23be59782cc52b0f5fbe51c3e8b06d6c2692266c24a4375417c86692c468b618781b0a056de511cad4a1504d1bfe4b349dd85c7d444a7dc6f6c55b019717b412a6a0fc4bcec1b855971c76b4623058841e3bc1f217917b468423b8a5010728a46a0dfbae356751b0d9139d488e25166b2282ce1b13e79f42817c948b19d3a17fb8d0bbeeb69e7f152ab9f63d215c676db37d44208658f75e0831c88f0412820bbeee268bd9ee99343a7a88b41f042b61fe8dc009e18b5de8e2e0c48b5077ba182536f4e32056c48e9f48f86528bf79c3a84215ead7b448307640c3d291ac65d236e96bef034596e9c1e98dcb505d4eec1a5d2bbbeed18e3d1ab94df08863dc6d0ac445dca80b5f8fe58183a2e7ddf68431c733c2e518e5fbb26b4fc3ff290272f47cc7c355d2b7e996fc8cf3f64d7b8e1036418f75130e97d2a5a09b1f743fa7b93a1ef251e97d847efed41e201b823215ea7b8b295c56e71acc01ab7bfe42ba6f4864142f63922534da29f7b0878c062a42fe2fc97ec700d18e8836af1c69fa4be887fe0a24a97e01dbd88ce408494c4a251d238ba6c4261f6f6bf754bfb4a504e60f0c083ce145205cef3dda16d1836aac47734a6385264180b594fc3aeca249a311d41613dbb563f59520b76b88f029b372d5b933c11a2b26d412568ffd1bb50c2c150459f5ebb27297a7c5231badee4a42459b90845b880aac72baf5cd7576bd81908a7559da205191c0cfae199504ebff6e977c4137128921a0e8959519d134c740bbc84b18b00d68fadad0d7be54ee749bbf47c27af0fc468f4edfaeafc07912831532b26966a1fdf3d0afdc153d7547c3e9dcf4184e447b6a5d0dea306b54b43a7a2166ee1c3d1df95e6281278d7f51855d8729e828d9c7266be8814b8bc0c20a68419cf2b6f177d3ae09d2cdc7fce45416c1659b0ad8f81a5bd4b2382c7ef78931293813f0044750f091b9eb5a3281009746f655a44bf93ec34bc925a48f50819162fd96d93a1d577e9cfcaee43a7e4b4375427187741b26765874e06af110492e8b51ad7dacb3b01fc9e4b130f9c496649b55c804dce1eb72ff3a7b4e7b6644680447ff351c378457756dcac7212920fd9338fb46d882875bfa0384e90a39c68d693857214c4139754329c3b0f77273be4d2ddfd7597d8deb282996a658e0dc7d7f181aeb2414fdfb040f027894901060c883a8febbd9736eebf0cdd77833902a104919b07095ca3ea4a91885d9fd14c1637e50bc2f0a102bc6ef0ad8d4244989649b18145f636d43bc70848b93713eea84cb9cbb2093db4e4284770ed2cd4ea9df3adc6a0f03948e25a980091a65a10ef2f71d6f0624f495b59434b3996fb6bc1bf79a68de0242fc16d139ffbc92ffbed0bd25d941489184ab825059a121d3b8e72e3f45f2b95353c52606a403ad8fcf724e2afe5dfac20d58627938a3a3dfb663b2da5210efe3ad1b577b3cef087d21000a587045f6d1ae97730d52a38dd5cd1dea3254ec44acc5fcc1b6dea49dab702bdddbada0eb35d6a742c7e753dd786a6a518e6410a03b1fffcaff14dc4e4d537d6f441fa88a9462f17e149d6ee56d988a08309ad6b9b1ee449de9314bed463899fcfb958310ad0c35b72ef5a3f7d93bb62529e3033bc34bdf85c1a4b0e8f8c51ba4382d12eff31c9c563551e78873fb48d8bbfc9cdeaf7fa0681254b01f2f45b953714b73dd1f0178cb434c63270a569eeb8a6711b76418989ee01dd6a90f7edaedcfcde527f7b4e6a59b7ffafe2e64cea8e11f54499d4d0e9d3d0f6ecb2733b92afa33c0e4b9ced43f384a087a8fdef7464133367130db5fc115f77e6ceafc9e61aa4ca88d2db04108eca376837888759e973ffeb10d558703977f49cac27dd137b1424872c142d72649c0da745f3449167518fa4000271aef5b6b20fedf8baff3396b898ec12e207259fc068786afe4bbd2c369a53055f5b21ba1fe9b766fd060575fe92fc4439f254371a2af8d710840909fdbd44ea8185af86c29494ffeea5adb4511c6be3bb37e5497d4f20d32cc69b8cafceb9c4789153ec0b84a0ab79ad1a58439570413c8ee9ba389933dfcc522d74bb6e11a8be2d95e22e957fb408c99eccb7472de801e7d4d4eba4bfca1d66e46b25e36745e19fcdd25b850f30aab74acb6e224c5f5490e5b9b10d66b1f34b02bceff30a5f575bd47e08a93cff189d79ae10858f6219e1dbcc47940c9acce424bc33a974738b6083bc2d4070cd4c602ead74aecaea3cd1f7cd01918be10b6ba3ae868267ce0399af26d490aded673d4669c82b3d073655e3757ad065cf1c85aff90338fd27505a184ca306cbb30984b28fe3958bdecb129ec83c5023e5a22e409324d7b8e905292fbbab205efc92c9f624eb4cf1a192516dcb9bebfa8e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
