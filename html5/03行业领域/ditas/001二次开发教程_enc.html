<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c1ebf3f1023ecc2e8f7474bc7d3f4bea58476d8535ade1ebf2feee5e150a2a62a48958cb1351993b1b480efb438593d70e3d310913a4a99d829d9fd1a9b6ad83f54aec356a527fa1ed5a0d9fe340cc63981ec1180bbcfda3157ba0f65b67de796469e0d24a4f9afa68170d541cbd00858d5d5cbb9552e081f42ab9599b91656ea2bd6cfdb74fbcbe96fbf8e0bf1d5d4e0d0a152e74d77753b4a829c5445d73f8ef90672dc6acfc70f704e82f72edc77f55dfd93b9da5a7fcf01d6c46d68c0301acb05bde04358f71856c74324735a30a348ff1070a85ffc0cc755244b61b0602ee1f24f6766a8c47eb2b6fa0e6dd4578440d32708f3fe60c2fccf01b55cff9d9b349d5995d144bd9e3895372f89ebbe4411bdaa732692b052188db026b26fc109cbda558de0d5a1f9b48dde6be998befdf8b72dee5d78a4541f963bfd91b597f70f6de2fd891ceee18eae1e955b10e0ce90f5fd83e1f7b148e3f50743e2f4df0c7875a3f7f4f9d5f76c233c507554560e1cfa81a12451d68ea3da3806799b1647bdefd49c5addd8c90bc198329ad548bd078062ceb8a5c99be29e21e5542d180fb2b13f62c504e0ceabeee1c4528f4d997ecc2acbe99081aed3a5434b96adcff5164b8fc8e1e883fde621c76a366fdb967c83ae11d31cff5f04f4ca684444f36d2ed1006b683203fc1d1c9763ee670da4f949ac4e49f167c970982497a110d07ad9430adb0b1bfcff94885f9b88ac0c079b005635e803d139a830a13e84c7a82aaa68e5d702d8f9a0ca3e5e5a0afb60c4727a9ac12c7da8a7ebf3051a751f7c9a0a034904cbfb43b59e764d200121bf1bd1ee6f704386a5910b6874988bd4bd337ca8ed8d014f90f0e7bb53749d1e009db8a2372fbabf09d724be248419b5df90bbd422a2ae0f97adf330b2d901c0d3080be348918c663f0071e7e1eca70746456995ec9f94141c7be31d294ab0f37c148a953a1c0b7f69afae02fc6db4f53dcc24fb38c8cb6f4d3f4473dc80e11d87115af0c6360e10003465c017dbdf45b6d5490dc04282bbc4e90449245fee8ecd973b1087e9b858bf4a52d3e24e014709a84d4c6cd9732b3f84c778b849084c2d8ca7c6a607e2166e0d665d0d2e56f3d9ea15daf6ab2e10708516c5207b05729344cc53ab6cd3e03b0a45e729e4eb1cb72369ddb4b30694946e37fd8e43bb95a74447f03fa56c456a1baff24b2a854e16ec7dca32b47bf61de571c0e242351f0fdcd841b29f35695f7cc83aa711c3a8149354f7adc61c34b9a6f14d87e64019596e9335fb67aec89fdfe6ac777c6fa1aed747d830d6262ee8d8e4675f0f95e86233392a1378d88647f40f6bdd0efcc2b74c904f203a1e299a1fc88af9799017310d3447081048cd7394928446a6b23ef49cbe91166ba6721939148dc923da9930e7af052db4cdd68d5b8322a4cca41d64abf8388464920a11c37a900b03f0e479c002a46a32088c708c9f37bc7621d5335c0f164b3a113c19052782a30b8ba3b609ad4fcf908ab9e02d81edd01095da9eb729eefb49be516f0e9c6592f66c8a383bca7357a596cba2ea9f3911bbceac86a8fdded9cc9482b6cab51028d5a64177b661138135771277aa9b03a098bbeabeeaf9889683f4cd32e4fca52ac3e5cf9b5f9c97f810b07498f7f7a25ca1da47abaa7128343b6deeb394af73c4289fb3e3c2a883312795da367e0a4e634d2920a0520230a7eabbd821f7baf2762f8cfb1ed88aa04872f5e27d587b700668ef6ecc781412ed3b3f6b9299f3972dcfdc8b0c7cc19b11d2eba99a31959ebe92423cde308b6fa3a1cfe5322b0f5ae6bd33169e033252f5273b483ec9ffdab21fc949733fc54fb71e889beb3107b91651d74df7d54c8eb9d3f4cd90231c21045e481869b61f5c6c5312eed29e67dbebc39726b0bda06dc9ba13e09b9c65c37090edfe8efe333d72ed08d268f53eaa878cf372b082b99bcb0ec51318afa228d2a84819c4a6284dfcede25c268b5184adaf3b3df99d322f863ee3b7015151ec0eb7d87d454b2156ec3c2ed42e2d6850e5ea25d468726387921ee08597bb41cbf65857fb78b9b891c88c6f0c655d39c81b902d63f9696524f57f74336380e3ca831e98a2d1b3468b94283765c2f60489e81e91927e73ea4c2e44081e7e57a9eb85fe1039345b13a705530afd870620cfc0e684a0fcabaed67ed43b30c7b3552f857ed7adbeefc55018a586ac6d88bc1128e98a1d92bf2b6d4ed437bc30c6c9de017e3ee574410b725daed25b612b08ae0b5941d0fb3f8acaea4ef5a6e4143bc1d1c3a4044511d859bc5c3b4c38cb8f049b1edc530a018c9344cc5e44ff1842f1999407b38ba946c8301730eaacf265ff55c23ba1c2916ec944b8aef8c3b845174b919da5d081ffa57d7840b7d6fb759bf1fe726be6aa3ebf88f1904f92a4962acfff5c502526f87c8c756e5c05b42ecd3d3369f8f060a9dfeaaad094b5e80cb92b87277e26241b55787851a4e6fb0f1d0f1621eff4ee00dcbefb9c5462692e46b41da5161c307873d02e37ac4b9605086757b7afbd8f15fe556e722d86c6c5994cc0b7917f0a44cebad7c3a8816cc975b4b519b0eccf0f6fe8dd771b9f3d38883ac1978bdd24b237f072ddcd03325d1b2ef863efba704442efe8f7211e72885f2dff8c91ba0d39dd322a76009837242504e8ffa73f57d35926ead75130256ed8f0d31c269a11a9663413321b38710e650627b00eeb249aa5b918986df553e1d89913fd2924c4ff6f9b0948f6c77eb18c00721e753a45075de643d81aa85e781257692f33a219982c7c722047d8276394e9ab8e9ea999161418a07bd2c735c4e2031b2fc69697ab8ba265dbbc1dc804a8f9e72180af4dc1dc9e3b49be0948b4d6ad482aeaa3e0cc0da7442ad78bba079da8e5f2bcd76daec502d67255d6da0c431f928aef3af7cf36089d984aeae51fcd7e0d399cc238c287475439fe4f55342532784ee3f60bd0b0f183f452f2c8ac3495534eb9eddada8aa68fb4d839b9bfef47a140b2e76edd3f72af62e039b95a422ac5f399f9c13824c5dcb4db1a9d8833144871a2d1862fdc81359f67994f425b07a24c9f88bdadd9b70d3122f61e9faa5447d798402ef77cba3b19f54de40aba11e6e92195468a0eb3599717c59d7628e7b2e4caae09855ad1c2e74bcf6077ace3f01944db6ec727891274157a4a936ed23e9cd2b7a85858fb20667abb404011298251c69712ff0ed24a29b4ee82f014f33b0c98c7d0baa8b9c951227ab073571734157dbd2ff9b30669223508dc72dabc92cac16bd7415e715281601cf7a52584067d8a585185214f3dba31c6b5b2d0edd4457e84de9566914a90132735c82cf7138f1bd12e5fe76e1be85703bffef18abb25c8b420b102b1c15dec1ac2f36be333449cc8b6fd1acbb6d1af99c8b09d962578d7946215925d1f314087fae48e9c5e6c829c70eae1218e8ce3f40da89429868144e8e8d8c9ba661233dc8b6899c7f91a3b09ec17ec1f68bfc589bf0e8f704f9b7b692e18b9201e109cf583f10bda62e121a9485df2350f455f0905c94aea63996d06591c47dc1a9df3d09a8f81286567ecbe5e0f9c6181867d117a65e596d18d882c2efaf287855fcc052c7696515137585f806900a0fc693e42e1cfa7672954847e427fe50474deca385aa517d0a4e1ad9aa4191bf490af03f0ad8f69e2cfa2f8cfc8878719a9cd355d5026b02d100645912dd0406274a76dd85cf817612820b173abbe673c3ff809bade3b19ea11bb1ff897d1dc09f7d2994daeb005806043b51c1603785d8b0472b22336e1f846efc2327835888e56afae498f7a5ab641303ac4c48a573053fb8d3ce0912b0e1a07cb5758f9fb301cd3d0cb852e63c4ea1ab3d6b47d05f4bcc410c34372b90f4be61ee1ea8b33a6c5aa8c812f79331f9012b3d1e485dd1fb01abc01deafa9a073f86b93396d24aa9e22aa52dd25db84d9febc4180a894c08097381d62648ddd637940a156bdf56722baeb2fa0a15fec067d6869bfe984b4d562fcebba01bcbd40bc7fd57606fb423b9b10f1806d4b6bee3f53af5e676415653753390d143846a7d14a03996066a0d37fad7a154a2a95a0b37096f07c05b79cac7865362180f3b94a9acbc18648c8e9dee45975098dcc3a74d9d0d8d672c07f38c1db3be0e2f08d95a07b5337ca50284d69876f0d53136bdfc2395a4de52c20b14e6ae0bbfe68e5a5d184f0387ea3ac2b5817d4d5170e1bc91fdc3bbe14eca4cf7c372b5a8c1c868153185adf8b5ec384ef08f0c23646da9271912dcbc6053b8aebc470ed40ed2fca3a0803be14df4980ffa3bd24637dacdc38e853ebbd840a5a28b56908e1e6b054784162fed07d218158609ec08261e90020e40daf0a3b3c5fdf192c79e4c26559435de93bf55df5033d6a480a13993006273c31156cbfe0bfaf833bd74f2da9bf322c67c31ab5cd2f97a9eef7f757763dfa1bd8388eb025103d107af050e2c9610c4844f8898a4ede499c3425be5c1101c46ac70aa5c7accde54cc0c98b0e40263ace40cc47a4f5def3e964cc77b2b4397192037c032ff3a8fb77570f8ea2d16625a62d7f933e42fb0fb131cc6a8400d4e71a9c833d47b0f4d1a1f38939b432b6509a57e17898490851a9072741745cd9b0db113f87f8d96e615647f556f6cc9a89e6c6437f7cf1f30947f36768060d01a89f5d35bdd95513e65903fa403ee61419e592f4cc04d7f1f6b6b6cb12b50d8ed7873a8cf77fe3470f74cf592a046a44d72511bc35d43c9c98a68caac7c9295d2b1fe9e7d6eee3e9b01d14fb35834f9297f480cff12c28049d9c8b7384b90ced75bcbb1bebedd31beb9581c73cf550aac7f68174b0b491053ae42675484d706eb38990343e227a3880d0b2b43d95422144cd87c813780c66fbf1cec1cbbe916189332e43f2805272b0ec1f8cf59bf5b64bc616a595e0eab62eac3783b17d397293092e75e17054fe23186cefec3a70cad283dc256d17b1d9df819b667dce5c0f51e8238d2afa5330af287388fb5d5884dbffac021ce92ae1a40410c2a35740fed2acb37275304895ec056641a1b07acd6adfde343b18d113b157cdf53ad6d7d9d0ddce56a147347f833f455146181c6f9b2a244980e1448e6cc92400103f1cf23d4b980f1fc35bf3b93bbe8b611e792274c22f44c91126bb2b72e779832419b0115d09c91f3ec8e8b942e007192c99a506a16ca9cb81874e05c44af89926cc54938d801fecb82a5f5dbcc2ee65ed2de300589da5c6f812b5f777fffc6a23d9b93e5bafe1e1b1af50f03ef4a011c0af41a289e99060de3b675452590bb94e5deee2e9fad3ae417a38fb20ef719dd2793a1b1dcccbf500d3a588062b3ea7e0cb1e5e6b8cef58856ed894bdafc41920db4fd6c99368a3c626cfee6380f192f3c185274aebbfe9af3cb5edbbc4dd01d6c4aed49933e2b08e74bf80b29ecc197f8ea2f5158d13be59054f8d4819b0e1d0b2b3c457ce8901f2baecc182be95dc0c9811bfaffd267f35e028340889f3d76a1456e1f29f2a0b2031867c11c8ce040ef3e1ace8341bf3450edab53eb576b9af773d3fda805a0cfc0839b2563f90dbf2e858863796dc93061df75aa7753b804ea1e9023ebda1a4bfe71489108e849a7b723ae4bf629cfe2ab9719d6c163daa68e50d1629a47439278f603c87cf30347ea0bda9cbc2ea6e9b3f87252a7a34b1dde862e64a7a7c38a82bb47994c84ab43f694a04c044b4fc85d14e367286ccd8637fdcd4a8817740402df3b49d95a8bc66d3fc54e0303bd5760212e05b285ee19e07fad8bc65603fe7a109ed54ce4b70ac3e3f401430ebe2300eebd882bdc5be2327b67684febe9a08c241bf05f42a025a7171900b4764bd6a3008a9f634d9eb3d69378323b4f54378c2c78dd72aca68c9a86eeb667fcb6014e852a26c0ae27e5cfee7fa1feda6557456bd1ee782d9f232672e7a984f189e6a3b2b0bd577c9c610453ca49ee88c5131f9652f060d66a3a42ecc4e19caa2a0816cae09b0f62bdc68d5b2bb5594f0f31dc97330455db838eb266004f5da39e4e4c26e1eeeaf16465330dadc28e252cf72cc9fb7933bf1c623d9aeadc466ee02d7155d34e5c2aacfbd4dc0d40375caae799e8740dd5a99ef041e1eb07dc721b7a3578626329a9aad7b12824519058ea01d8a25d4d63e427b0f2c1c9bae1ac7c3d824a9a36b7d6e822df58b4e972af7bc87747dc0dfa94a9047733cc77b36e730b7ad4dd28ddbff44ca479dde7116e63f7ff042bf91bd6f63b6e358b5f3c725a60d1a468d71f7d8bf8209577863d76c7a17f6328b379d6f79e4de5efbe4cff731ef0e41478a56136103cbe774e8245e81db8f96121ecafdc221ffebcbe9400f49943fa6988922cadcea06dfd594ff7cf25af45ee5bd9c5bba269a2799c9cd3bb2a9bba2c99da1b91fcf1716f2e56826792f21fa4f662ea5fe48085f0aa4164dcf0094083791249423126127b8caab165e77dd4d28c1b93feefd2ceda9d297a77badeeb2b528ea812cfaaca1960232a50fa0b6ef32ee991bca166ddb6f3e9d54fe5b7bb2e2e7081c20fa2b5943539669ea5a32e0177f66894df6a8d829b4543b016e17b1399189b75234fbf49f0792ac41c63230423876207c1e2e07855c73569d37e13884349f06b6166df9ccb88dd08e5e68eb9ed6de645df92d6aefb16dcef8ef1e15044801ac2ba013e5d90647fccfc3560ab8fb0e501b64853859a3561366ca01fa3c615ff876f4557777385eb5a868cd7530de3f77048524c58e25b5eb96ab6cf34544c0be4e3f0887dd5dd44111081dda0fc714dae2c06653403a759bdf01555dc35808ec7188f5bdfd6330b9d85e8ede337fc66b2b56eabff395aa47316fe64478dff316cb65fa597e9f04d0e19d8c6f183eda1dceda3e7f59c52c41db3d64efee0ccbf6f679fd5f338e8fdf2502715634c576bce5209c1a9935349815f09bdd1db5b0d9e50378b4b7cdedb009950cd2995bcc49dc6645c228e36cca55b2b7199764b3ceee7910fa301353e40e1bed9d9bbc830c4e000b44bb017c85b6e30300b7e42fe961f0fd82a900dc56cc942882d05d0d175b001562e0d836a55e71faf8127f76d019325798f66d2dc9cd0ac2edfa015d078ffdc446545f2dbb58c5d81e3c8f9535d6c05cf8a7b837c080d1c16aa3bada1de78a269ec51c0b86dcf086f458cf4dade7a688f642cfa98bf09aa41a01dda7cd556e091ff31935be1b58b61a06135da8e7b1a1c2b445129baf64d2be1b46aff164d97fb8cbf2a47980f7eba67de22fc72ed676ddb1fafc80b54db8638fc31034f485e6746c3d34fed061f32fb377f1db086c6d8c520150004ec127a49cf285adce8a0108a9a3aa35befa14dbdd25f3416594417a5f5031a460d171e3ed2c1239d15b9e24814e04549cb4f5e05a3bb4fa95c858d9cbb7f97c81a8d8b0cd88b7f5550110928bd2a3984bcebc1bfd961ab5662258e170216b1e48a9ae4275386ef3e5cdd29f6a4d11991333c2d599143563fff468922215f0a9f12e37392b4bdf64dbe7f7a5762656611cb49832bbf2a5b2a65190cf429e411a6208ab947ec4d92c6a2e264e5e04ab0fd34e14e7375d6aa361c06c9789c2fd72b2b605e581a8a4b6713640853eb96013f25fc55f6fbb9e9022a1fca019c4d5b26478f9218cc7df8810964e3be0ec709d3b31d6739d8e8e9eaebe2f1dd6de3294e674c7a1001954171920a0ff6b2770a887fb24c43a1efb2a29044af430bb2eb1e93e649bde176e5bd55e81b99555272aece539d5640f984c670845e35b550bfe36a216bd24f75e15d7d9ddc5fe5fbde729be438f99d3ac806cf4cb697ff7cd81bb657e114ff70fa74a5109fdda70e394e89c2590df644f4811f2427a5e380824f24ddd27de908725ae1455ffdc661e7fcf7b1529719683c7d3b5a1a639ca723223800aaa7deadca9da052dd954dca5dd784be9efbd75975eb812abc991739288b7393e19baee58284bf2cc28f11bfce7373bafdac482245222b47c976d7b5150fe9c63c21e4c0ed7d45152bd47ac455f223d2f3103216b8243b44e98307ac70a0955983f6f54fad4c00faf487e108fdda70f657214902e669865c8af39bbf3134b4075be93194007bc02303bbb3d6a845a03ce989813bdb9da30b4de022bbaa0c6da7417d80c3315caf899bcb48f6ece4d975f4be35d979fd22627919e5d84553f1bfa18a1a2bd9ca88c7fd56515e649f0096151ff315bb0d277c169ea462de74cec509b33f4e96f05dd63912cb937da65e0b8b54c992352c55e681410733b4ee2d13098780521cdeff219187334e0bc7b8d35c31c8616ddc1d21df63ba34be335a7630f82748d2d62c7bf79f13fbccdb8e7f62f17885a5c3cb0918a8e9e63c61f1f295355d3cf0b57efee9a71282ff341a337b54c701f3f20d91c39e9d792bda45feb37184aa52362efb28cbd550e28d753da9a446bbfb75bde78ba0502670aaacbab0d8fcdc504887751b5e9ad46fd4e6ed75dea06c1c252d0da7a3f654ee424280beaa24f6ffbeabc70bf19650f6e0606cd05c38a62f9e404addc03efe9826fc991b344cec9ea41546140edb3f3ab60d7abdae684c63c0b2e9a811cfb06cde3d06fd60e44689de360f1d4f55fd4eeddc0ac1fc5963b63f886a08cc9ba83ddc34948033bdc62aff3e3adf3ca7f47f042e394e3b6eaacd1714c44df15765cd394388409b2e5621c0da9d37f8231768dcac87b4074301bf2de8959e21c62a002d0ddde837dc63c494d48ba73fb0bdfe56c63def1166624444ba71ff4929ea34e1d9d7f360ee879b1364e95c0fdd43692c59fefa758ad1898c3f45851039de8231a331c850dc489b505f896106fa6582d359b3f4ce86123e37e6c964908352ba291ba2f967b604e1f68ad0fd1ad64a01d384599f59e40640e2f338a4a3ae6a6da27f4568ea3612eb7d5268494b87c6d2edba8a520b9888b73c5b755ee3e7acab6a8f408998d1812155deb9c053ce24730e102fc8a32bd565c14abcf7d47354afdf18f0c852bf65155c16ca63ac30b906094572ef657ce1f2062a4a0b4af07363384f7722793003fecd873d3498c12b5ab30dca37b5a2e69705e9c85d568637f673baf4e07473c03154efa7354274231ac6a1d707af8c0a3d704df8bc6f184c31325a467f3244a691a35807e82e4ed8d9114cddded428e5b9d5e5d8e6e4a7ad28f0b41deb238dcd8250b328b1e29b100a5ec9c3cd3ed3ef94c6eb784eb896fdb680f4496e48d0606ea4c01c9d69cc2b21674722de6e2329d5dba5ae95a29c24ebb771aea90794da2e8c002de1af3eedd8caa8f9a746a66aa64482a145d81a7e2904f7223f6146b9a99af9087b9ed3d11ea13f737dfa8d7e53096664261479a919eb8653b9f5ba4c8e06dad82458d3f3621fac465373a303481c92d8fa1b7550e93c5fdd02eb24331a27194141d0f9d2e96bafa1230a0773e6ffa6a5b0d085ab705957a156f1ae30cec39c6716a220d0dd1f753a6eb75afe08ca4e80c64dd2b283ab05a69e9a11fc8e249f4df4bbde91156001f1569dca76ea1215287d51097b2f99302d6cdd4bd0dce13ee3851359d5ad934515a9fa118035b2585ac7fa03eab0d9ded812d44f572cf10fe343fd4d266f489fcbb26130b218553ba2838836243179f45efa25549c852b79260acee2cc012dbe2cbd36a59f580f049a1a06b0b2fff170ea770081079950e7e58d96f3e70b2f97d7fcbcd1addd3f8532e23f8880eeccfcd1c700a27ca25ea4174e825f06c3060367c47964364ef606882c0d8363b63d5846dbe0c2cacea7b79dc72ea28aef07e153046df0f64866a26d46bcf7d70304c764e851a273399c90f6d83747e831bf6caee4c9dac5dd23f98eeff954639d149d5ee147e38755456d45f1303ca8c35f253cb68edd6ac8a9f959ed19862d4bc4b513914f6fdd99d9dabc672c1bce0f4b9cd10c6647e8f12fe7727cec83dfa93c8b187aad0a8d9a10bb1a8b591ff9c99dcabf2fdf849c335959d923962437e7491a6274fd834aa0fb62b264273bee8fcbc8542e7d6ef5ce31d6b4bead9d1f5e3540064b0678de8bb0b162385d99c2dcec7ca283c6f74b37f1e93b07aa4d8950d569b858bf1a64f07085168bc023f1c1ffb16434e4609ce83fcb3f81b846bfabc50c2c7f4d9f3b0faefcd7289ed70d7c442c820a23ac431363a60d8524afd6e9924634bd2560a77ceee882d22a21ff74662195cbc59acdee0f47132f90aa980b4134c768cb60d9038e22202c5135348aa29067ff913b2a8c1453ebeb8b0dfee10cce73e20e0edf3300e750c470d790843125a1166706c501cb24986b027c33142b3f43bf5889917b58b3da103fff13b78db339e0a6b58528fe8c39cda06379beb8b49b7437e36ea106edc0c8818988324c443d4224832128074228de3658ef9fc64d4f12c3bb8faeef83c8b4212cc43fb0fc799ca4ab3cc4d92f8e855d64b155f13426a228be5b2548d2bcc2f89f55569413bad24e8bb77fd08952b5a59e3b13305a4fbf5a63e73fb677fc0d2157592af1944ad860263d4316d4e673bbc188f6dbd018745068bfc03da5f38aaaa4bf3bf178f6926f7d2119e974557af53726f8d8630215056dde0fe2e69adf2c16e50e6aedb85bf9e70cb371be516c5d6147e2bc4734d7b8b0517dc2d214f5147fa8bbd7562d7051d008866a65e1ed070be7aee2cc26900c4a1485bacaf6217fca963ff403df2c43107e2867988e7162e31e8f1f8962390ef5fae6a9351d53cc82e0cc69d01db3660b8ad80dca777d575869c84369e63f9367bf312fb2bd810fdf283976af5781c9d40cfdf70665159cd9b1b1b32aa741a190e8b6e4016978f85a16346a38dbc5759a20ed83a1270f3eb2ea47f8101eff15da13912ec4c0112490ee2a0e26014e94e5c39544250ed11a73738c43006710bcbb67e257d499ae9ca35246e759b99bf405439a6c99f2ce9d95616f0b3fb522264b0138dfd3436136229b8acd12ffeac4682dc21c60a217b013102e76688fea46570c7f74c08957aa3cdc11ca0ca736134cdf95b439e5ab78849f12d1dc2f0a8fa9982167b837c24483b03ad4066f6ffbbd4bdf680a1349545cd3f85fb4f4c133280f000a875892054b17d5f8e8f6ef2a01de59dff96ca9ef889478eb8d4b59c2f04065ca825bfab81d07e025435297589b503251528fab56ae6b35fb5ebe75b24ccbc620ae245856c42d1b17db8ad9267f17bf2e643469a3e711c8875964792c3ceead4a36aaa4c35e9ee3e1cb904f96678f8bfdda6ff4b4f6e716ab82d38d3b1d9bb00eac8d2c26dd8ea0332fa536d641803a005f900fc61a48afa2529e222e9bf094244856c3bacdb31694b2c85eb346301418bbe9adb1259a649e92a82b70ac6d83bc2a7610f67cbb821cd7b212b34f64ac291f2856b1ca099041d12a1f66aeb8a84664e8d3aedc356a21fa445908b10b48f2ed6c1df523b6fead598eb281cbde63f6c1ff6e7e882ea22ddce1d27ad35c2ad06489220e281b77eb7584b9dc48364e98530f9f6782fac29ade99fa21763341508c5623cca1b795c616b7beff43f746d356c0c24ef2f808970e3f009d55c677ef680266394091f0a8829787ed59eba9568c074f7af066cd2e2faa6b98890b987666befeff8439ced73f94da5f8d04fa8d948c78505d1926eb36fb37122f9a2d996ea12cac946c62a322850bb79477ffc06ae7d0b9d799b5372a88d0f1febc965b5815277ccd9e278d1ede71b86af3d2409760424f67ae67ef545e5dbc360fec89af1ea75e80bdf743a83f560ccb17f3ed3296584e09c5044eb66d4ff3ce8026fe77e59ceccb395475c1c09064e7763ccde7107cdf55e2447c6f5b0349155dd5f1f26cb7a098a8d0120a12418a0ab8d9f7d536a29715a084ac84db3826a2f4d058adef926ab1b44eb4597282f49d2a345c674a3505ade6ce813c41dca23447cc4b2fbd617d90db685191d7858cede090707e77c7f382465300934c0914eed3d07780b9430f00ec4895f108433881fa01e796b95877d06de1f8f9e90089bd4beb5f34bd0c04bb8983d34b4bce0a3e9b97dff214748f0c95c7b3f6f20959e54a513d0d48a3c1250964f8f5ba3206d04e67d76d8d6465565a35081ab3b5894955dfaef6f314b5d23fc47bc3498f3e98be57630b3c6ebdf3910be6a8113a3d7457a3732035afe26846ec09c23f0a2b2cd2cf2841e55dc10342b61ec71312a459b3a7117cc80bf107dc8c174f1ae282f64c20f6abaec2c39424ef26fa71bb2b46f5b28bfb9f3937206c1477077d9a371b8ea999189f68c277b05a0c30ec6859af7fe7c15e4cb2137292aa836114ca53a1a53c641a6a3be67a368f2da2753262c699cb530dca425cdf6a7d7b234fb47d2abfac1904f50d8a1896a9eac1224c97dc72e530ac5a767cbdd89137f33b49fbf80618e374a57c2774394943d12a5448596835b926bceb8518c7bcb1599f533ebf375a2467de53d39f65a55c5a65834b61c9d8e9b3c0d25c8b674a3a3e7e3c2c4f2821aed82edcc4bc3d159925eb80fb24e43f91920d6ce39fd896fe964457e46db853ae29ea77161da64214786b16c880948fa6a5ac00e9b7aeedfbf028e5c34191f14a8383ed1ca97e78f519fce4a66496be32fa1967ea075156b16e39058f25d1c3b3929c7d248882b7c40710129de12ee5a5cdc56e072196dbacf7778711817b959a87eb473459cde425ca0ec5216f3fbbd3aba6df71937e6f2baabbc66030989d0f2ed4b196da213411f8759115c129fecb4a90b7da50fdce2df9177710fb370ceef6beed9ced0d76de7a32bd23c8d4a921065ecbdbf076d3e0950b2b525bb0dd24abbf22cce55cdad2af76ea24f13cddebedbf2b4cd9480eb71ecc9718324c5d4efa2d56d33bf04de0f9200ec0c42a0e37b1e32f22a38999fe8cb636963f677c2f1f5b11988f9ab6cef217433d64e19f6ea7ebb3b35c2cf33a2fd94064a234ddf9bec0bd94c1332ec300a2703e0ee5df2093eba7f999406a73eda6bb5fdc1293d26de4cf97136b09bcf27c0109b5e3be967110c16c7f770df4f533e2e6c829fb9da77edc9578804861019040b42db3c636b8b1f3e32b8eae807456a7b78b9ece4222d4b677858a3e7d257287e154c1cf5b491b56a3655bf234788ff01bbd193fbeca4607468c3e1146027ac1a9c9db6577db1e6b3be5df5b1a8dc46aa369427e8880052dbfee418e85ee1eb9961fefb86735badc78669acb71ee17bd69941d0c26a96946dc975780bfd8fb44afb85022030e1dca2e357753759cbe59f1b9fc489f5cb22ea634c40de7f45c1095e0c8111495395189dbd5571e9d50ac6204d34541b80241e15ca3c8ce8efd13e539ac0317e78a52e98e13a8a3626b74843f1e45f6b02df4387fdbd4f9bc0f211d92481c8d20238de36a39bcf8a2ec138165bc7f8ad0b126e2130653efa58a044ba7045ce7e5e6805d93624acbcc6f81ce95bc154028aa103ba65a129b7db435cee033be130f80311034501da4688361495b8f3ccd767a2132f9436e1d34111f20a38419b5f86cd13c7086daa6f99e9552403c2198007bad1703de95aabe8633c8e9eda6a6aaa28528299db97fb829f03e1e61fd3bd71da648e507bdb7fdfca33847c5b0a122d05d33cc432967b0aa041184f14ea36af1cda55d97d49679ece8f01fcb782e0e77e7c0f109fb57cef2e25b68e4e384d5a0b64fb622a75cab285413e2ff2ee16ad4ef69eb546c4d63ef562f9948e141eb1f16487478e2bcc4977410a84f88ccee77511e6e60d8ec8e91ae8e440da8d3e5ebb05a1b587a1c9df202a282cec57a378863fce77461099cace01d2d16761ab248f64877c55d88db9156bcba22cbe4efeacb4f394212e24e633856e636d6adc058f01f06bb71ead5cdfb7847ddb0e51980718fb379342c57479b5142f5d2a4c3cd969f62eb92937de8883c296b4e535333443ed344a24f24023f31944eae6da27c88b25f6ea8521d13c79129f63b9eed1dbafb9466470318878440315f79f9962bb3c8048919070a3ded6e7f67d43ac65569eb5f946436ac8bc0a84cd258bf8c90c516d5b0635dd5e05d1d651e7afc7e199a08a102d26b62e82cd41bfcf7bd7c3fbe976e473f9e8579e5af86adaa639742c41a38a8c466a70a54fc215af3a1ca009eb0ac412c6995a259a2fd775a985c3a3a8708f32f43641161986eaccf8beef5bdc762a8485ec1099e77cc09a6117de084f0ae5fe4a7e8034b10afbc7028fa8fefb6263e4f9e8fe05ff1e98b63962e518bacd71543a1ca7b0f61017a5442cf59553cfe1845b49b89e8db8f0466e9b091fe2f93ec136bfad71a4ea866fdbf5235282a6887fabea3d43c3135f3171189181c47d72597d7120ec9796db5f0b00da6f8c933d14814a70b56ae336b62f7ca9f8d78f80b2ac5e32e1d10099aa5ff332daf982eca6709fbe9df008ba868fb93ed61a21a904aa11fbea5f7416322782da91852600bb8d6c5107e4a56fb3f4d1a7b8be3a81d9e8e5aa99f659c1c1b91f08edcc049ac10d37350464d9d1957d9539b147ac217f914bed88f9481635e16f2a97139e65d5d6df85058f74683ba92b27dd1ff79813789452dea9924b684a492fbe33e50ea335b5eeb9efd34c4d5ffa5634b16f9ec6f3685f0abad99a07d8b9e7e02ddd9c355cd436223277fb0995680d34ffb06c049a5ed3f32d0a9528ac4ba858bfc7e727daa2d86089eaa5cd451f6373fb68eaf029cff2867ddf2ee2a614f9e07afef851e6217fa553b968ab0b6a797dc1dfebbe0578dd0adc9e6a358d6ca93176e39e07125a4ab51fd2b8605a9ed3f90890df8872ba4f9702438f8fe339145e1eb36e4747ef0a41cbc46aa93be3b9d506060089c48087ae3fc9994a2a5f767ed20e59fd8f97f022c72a66847759fd86f69a8227a0644f980d849c8cc722b00424f8e4955b10c1ed0b038a901457d77ea805c682d907a40ff41f7a962fad71b78bf5dc4d88d7078d532b03f2f9fef1c98eff9165219b4a256ac7ff1fabe34ddc4df42a6a803372ed3e5ec1013fc069b497b1030078a67bc84a6d6d61eece26fcac0967cec2f60fb0cac1307706018183444c960b40b44b2dfd54972dec252a878cada1263fc5bc2d84af1097f5ee5bff6aeef6c4670de6a25e15dd267cf0de47cc9e8d25b5c90b7e151565ba673656eb7ed804d42de05a7bdb8b467617c8c056d74aa880860622f6d69c308b4d6ac3d98459e6a84f82ac91fde0db7cf8d30448d6096f075160cd9cbd4a74fcc039f7d1cc484645b1d06f828c5d129de4aba518b0f7e0f3310b3cefc4e923e37c4875a5f8db6340aa345d8df2f041eaf11bbfb77d108557c426e9342e4071904d05801d1d136b6b01f78e563fc9b2936af24ae4837c911504a1bd7f95c13eba69c001ba0ca2e78166760f8649ad026de60a9c65d1e69e7f85bafb3e5d6fe01fa7edc9251a398a24a9449a4a753b9a99db707ec05ca02a2ec84224f95759e5ce01f55e470437d8d9d75b3cee41bdfe1b3312f445888ac0e79e29671ac7cd95b340304d678441f2f5c72f5ef22d01b78ab139156a3cbb343015a6af474342d491a673a2d88b7bee0ae9fa77647a12a8f0ef2de4ef398914b0749de239c3a662936e1dadc446dd4daebb12d1ed8b7d9fffb4056c5d0cfa7b0a133e0dd1396ff4b8dcdcd0489d2c630b2955750e2ea614854812b90e072a7498967c442bac7f756728b79a7e50d6729ccaf565fbc8bcf7e31f7f6246d89414e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
