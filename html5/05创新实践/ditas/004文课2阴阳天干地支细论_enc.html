<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e9278becfce1139cd23aef1b4908583c3e511db9faaac3e5dbee3c675e3ec1f37eb7f0d6f9212253ed06375794fb09f67ff0e37a083c173ce6e5f2848dca2d0ccc6673403f92954579f70336c50d2a866c3ee038461b1377a7e258dff3ea48152ca01acd787ce7474cc88eb1c051e7d74925e84b04f76b502258b06aafdab1eadf7da634455b39b1657dfc16bbea7eb5c98991f0bb54f138339ab9e499f05c9cc9f014946fc549d19bdd717db8a984df46c0ea1f1384a46fd376c1dab04844ef930720ec7d2660870d86d35b834eb782514528c3baa705f4f17b0dc124d4142a6351a97abaef01d7548e70147781652f6646f198d6e604db4e112ed29c94b8772649ff79fd59fa95923cdb6ba1a0303dd0e7b5b62d27a38b7c7bce19b2e57830e2863bc280d7e2c7cf9b4f6fe7f31d073956f471edf2ca9316cdd427313ecb68513536fde9c4a16e5db410cfc70007c767642b0f88ac3cebdd91ff9187e6a71bb1dc03bacdcc21ab84bc0b1806014fe33c0371c6031c505eb34a613b98df4d9334e4adf49aac76bdbd775dfb041f71eca131ef82b6e39538b9b6569d271895ad137b4468b888ffa0218037b7ddf3e8400755603685ce411a69d07e070ca0139dd4d436dea068d8a5fb321c2bd3e5b1bf8cbe7e6fa758f843b8c25e5ee681c5e37be7762fb0e6ce50afd5c47ffdbfe6e914a2fbd5ce85a87d65e5abd6bc63efcf889ddf7a58fd5368b3a1d52d70c1e89cf35504e650b8c5f0a5e856668e508a48841a90c8e46fa2fd0e8f009c6d875824cc348e3a10fa99515e9d1d52818fbd5ead320c3fd7b67945834b7768d3a8f0ac09ea62e34b5a73edf6367576746bcd7432c9c783d0f3e587356c827fd284909fe2baa90cf7da4960ef6ddef986c089d7c6b12b90e44f83e67da3e919be53a8255eb069209343640d7d4ab660e9a42185cd73e7ba595bceb988936a8edf15d3de61aca871c1dfd7915ba8916ecb2daca3ec251e3cf00ca9edf398823e66f681682240e3cb5a051ed74cd993aedf3f57a553af598ae1a10c5073e2984d8cb295ef5323460e93eb5eed9936750a04f126f0608b78cc6dc71b870e46c1b4ec679357121fbe746cfdd53b66bbc1d58cb6f26a36ad017474f84b4870439ebb45581262189bae81ef36e791a18bf217799f985f862c9253bfcfe7c9d78dbf8a20096d0efd6497ca3129b50c6818f3aee9b37151a38853a37b4d7084255b5b29c6226aa6219d2bfb295bf08bff3cd9ad82400012788b2739a3dd10878f6bf5c95cb7d24e7d1dd4735d3ea070dc664520e2deace237238a830c36705517ed3d4aad48042b17ade6db75119901431e74f3ce1dcff8ef874a726ad3b9302dbb08396d3f751795fac4e82282bae5e3e55ffe4a790c4f70e0d5497a9319e9d96136a57335bd8b715368a4809b6a43a2980b62b906ade258ac223c8578d53cc24662e468c298bcbf1cbc3024395ebfa67c2a59a8de1dcd5b0d50b1f5d4ce39728effeddc7d5ea85e4c1a1d678db44d79dd9a1fcb8de53b1caa1924901a7bd9a4f937da6ed319a5dbc57bfb81dd20d08892f6b10947455f03c3a5d88bd011cb7585d80cfd681a94e26b4e03c3dbe9950e542817e51096bc13a7d95034e2fb572942a68353b11dc7bd249103e5fc8a50a7233de77f24fe172ba792e3f57340ca774452afde87dbfdc13d1ce93b0b5cf4e403af3cfe890c9802b4460b478db5ccadb36905ab7acae61d5cf08fb050f6210116bf1c1e75c459ba837b56bb2cdbebdb865b98b7c3eb8444689b2a02dbece27b441d76a23c64a72ad55e2b1a0822572ab9fce25b2d4c001c076d636e36c2962d0f7fb808989d085f812123393b540cdc524bdd0a869fc14427721c8d75a7e991bd26810446127af90b8566979d80e020e381246f39fa54fc48bb8ffc2173f5ba16b19648ee137d174618fa382f19e63021b1c5d179ab8db14bea56fa39f63e27df219b75bc2d59e8cc24666813355bc1380ec285b7734d8f7cd3b97793c5676e05ade76980f3edd594425842515a68fff1d3fe229d8a558c54ad0c91526c550c817e56bf82de63d812218666325318c3b55673c81abb1f1fb63c5f5631bfd39a686f1e7b3b9bac12e391592e0ed809ddb4076a692ff300ace54a9483bf56a40c5e24ff7c09d77254160daa36a654f3292e27b327f808b7a2e93df16eee9f63557736d2c84d6601dd5bb75d50afa0f92bd13cec74f7286552e5132d11eccdf73a0d0834380b558768e3ae41da64a5f511d9021302cade6eefb997251974f4766a4ce090c273de680528f58618750905fc1049ff3d6b11270f01c8e126b9a77624ed2dde5ce3fe9b7ed8f9d9d59c110ae6a447e516e96b619585088b546f6948866ddb2b061369f984d436470a9f57960a5fb9ebf0acb5e3d7023e7e7da9d4514647f9e2882ad611cc3af4c61cfe4cc1fed851a7721da21c8301bd4e5ff7184924f2a485ff3367bf205d16651aa4c08475f39dda97bc7a5da81b0a0e320544e36ae25b28047d4666127f35542ef8b9acb7fed1e865e72545957c54a5a4bebbc125e4f05b634254d92239f83b03d6a205763148737c5327332777057b6f8e8b2c081a47fca57d8e6e14510ae24d620437a862a3a6dbbe70cd071a84db220f91e6c1e4269ee85285f05eda5c26d44e81fe11a85505708554a87e0578b046e643416d3605afbeaf7afd374e00e0e69764cdd94547b3d33e90a694c42e7c3fd06f03397bdb1bd14ee6ebd931fd333296420afe082533b81157c68f5c485f3a780c197c6cf8befa17a87ecae91a830fef9f9f54d734292e568ccfddbead521b87426a0e882e648a5aaa76545020c844930201fa5142e91169bae3edc4578ee06dc65f9b589a9b297ef1abdea1eb9fab603a37626b82154174781055b364fcf132bbfee7180b11183cbf875acc76cb79e924dfcf38bb48139487de3481226e0b0a91ae5c0545ba000be0fbdd1078e03b85ed4d4c5770c6de1d4c6e0aaf79b7f567f217ce32b1888e6674c63288b6994d21900533ceac2636d5161772c4c39d4cb7876e41e237a3e587f06202db637954be363020cd3fe53a1097d65ea5d8a7f3888750638748805ea14c7903b319bb5f66eb4e87e453e87c5c40d2f078ecbc31ff58f9d0ac2712ff270496116779ab68709786a182ebdfb5d1bd434ef295b60bdcd77be6a3f86216f89c5103798aeeb170036da906bfb8bf768964adca86a646f178728d987bef5c56932f480636e10b421c66dfdd0ef79708cb2c1f304dbd182cd2a128acf637e75649ca95b5fd17f496d316cfcaacea9045ee1669e47dd88d397a7d186e74a6f20a9487e08aac850d783117654b1e7cea91637d8dccecb632ed22d6d0295d233f3a6ef0f73588a3f73da8b51d7b74454cc6ba67ff5bde76253f7d80ae409923e4825313f725cf6d0e9c170d337e6c4ca88b2bd7a8a0d0e0737d6496f0303873eabf11ac2bce6f5421e4787239e5c13b944a103b01a1379c2f1af240cab65e44faeb65091e1b90179bb03df152b473deea6c12d8d9a1a73d1e67f551ee12090eae442c4a1a0c48cc3b457e9d73d5a06d8b9e673cd6b87bcf90e6fefcb6d4859ccf52083e19f7a310346039f14269830e75c89fe48f5bf8982f24d782f931503e6bf5083a2d7dfb5e57794a859eab12fd69b127c7d6af7d6a1511bbb00d5ef10947434faaeb31229cc42af1dd581fdc29303e6668a24647069bcc5f9bba328e2d255c46ae662f7be1ce97ffefd6f917fe2f689275eb87668b670c8cbaa7a21425affb9c9389bda3fe249a8f38c11d1c505958f97e1c7392a4be5ebae8418eb22d53a570d0f42e276a5cd85853710f5e55a5bb664dee887cfdff95d2fb395c9980282be1e5cd1926e8824b32b2c4a4e248ca870f220f225713b3d6b4163867d1ecf00fe2826da2d9444e6473108649b7950ab7ca7f47b77c70908dafa03f63a22e0fcc36cb79cbcbc8799d92de605ae244ef66b5e658061c27852350fc15adb443a6034d8cd4012c4d3f380d33972d25a98ad9c6c330e7c9b4e159640e6571caef6e7cf4d562bd3986537fcb022ac86c9cf51fc633beb7819bdaf9d978fc031b7f23ec0157550096bc5456e7e7d4d2e5ae9e35c1907ed00bd7364d9872d33e6b2b31833946447ef7932f4ccb1a87b5918bb17ca0868f38fb1346e54801f5b6381365a07060db8796484f9a62c3a0e6b2b4079cacffe24e93fa70960c5f2f0c52dd3fcd646c5b255961dd6648c6c9d21439097ef81ae5352dc00f1c6891d7cd438a2f43040631b2c3bb93193041f382b4b256eba097abfb1cf355b10273c2bdfffb7a8a4e9a0e055641367df041f24f54117090bfe0053a0fab36485e6559ee9edc2b717f44c29f04dd40b2ab7b51412fd97251ca4b23e6e9d85959625925a2a62a9a5c67e58e5bcdf3bf1aaf8343f37d4d75ca8538025ad5fd8b9ea019a7c5ceea4ed04e1a3dfc624c22624ed6e89bb55e1f7efd457f0131bb12253ab1a8531179b2bdc5954b5d6cd4826e2ae4d9792b3df7adf2e42a59300b022f8b4a6806b1450d95c00dc90d8c9da72e11a6ae46c552dbaa71b2937d88c189472d7d22ccb4d8c9ca706f84de8576ad623927d2a854b9e70f443b8cd1fd676f7a7570a0dc7088ef9a4281e881c8adaa8d1b92cb661c3edfc69405d90372ef242c9cbc9db8dd7531c896e5d30d66e92a0e4f9b6b1bbc49a9ea1afeab32597f7910a89496d3bbda3db02e382e948aa5db72892afb065bce06f743e31f822879d0ee89668a64973f7362f02997e86a386aaadfd85b6e09df121d61ef161dd3f636fc3e95c033436d0b3248fab23fcc69979e208cd0bebb04eae30860ccabfca750e2888c414e58608b915f0cb718ff7d2bd12979305368620bf3054f199a0209005aa6135786d6659c1aaa91c19a5ed3d6fdea08e89329add9eadf24604918a5dea6b44fe2ca0d927a7ea0361e24ff36f21a2dc61a548c21fca833e8e05bc21592e180e4fb02a976bbd8a3f5b9466f74241d433f3e1bf4f7f6baafd65cd5ba1892255a78b539df82018bfc66729334b4e2b3b8e6b1a3f8dde13e148ca3de4a41baff5eb32159ddc04a0bfe3ec96db68a031e480568ddb2f1676048b171154bcf8da2c1b83a2e4cfed6442ce625d2aef86958b86b2e575882dbc5a290499f6a0678f209f123554e8c7994781ecc2435165a481c1cc6cd4488a3fe754258b10f1f7d175c57a56bf3ea558c102d05de6e0874b19b4bbcbf34ff61c8eb82ab7f9d809492f3c665274ccb6b1111608c70d1c33e21c4ac419e995653f285666b1a0e3ea69ef4a6f9f9ecee45a8fdf9058accce99fb3aea4af6d389edc2631d5617d01c30ef054ad159f750ea9f6a893aaad21414bc648363d92f096847205ad2691bc2b0fb87f9de5c043af08e164a953cf0e43104e88cbc1452cfaf1782cfe5a1834db7f13146bb09737827a143b8e68bcd6dc4f7acbd181e3df9e228298e5a48c3f9e9e51e3ae35570b8d753b1bffd377dfdd210400b360c24a5e45a612cbe85f35eb31708520dd8689b08c9a40129e36f132a32f48443f92e9e2689f5b5cbbfad590e1e63d41c26dff7e3f521ddf970eb43dbd45037055bf4b76bc02fb6d565f8c49cb9f3e28d888608c69222e316e8db969d056bea3ab9f9b89fb35e9ed636a6b5739df89cf03b34e6754427020d3a12b4970b002646739fbbdf9a8b7f6a4bcb061127cd3419cb739860718b1064d55794cad0050299ca55309668464a17cd5bf6af3b5eaa3fbd12dc91d7b803a01b49a43f59bd7d6956bfc75f2744ba232f2a921fba9ed40c0793e9fa1fe9c5d0821117219c477b8fd7327c7496a5bed1280fa93601afdcac280ce65fe9fb83238ffb7fe0d487707f91351fa202351fdc92fd5b9b50048a1ee892e6189cf98f0209668cea1ab23449e4ada6e48cdbed3a36269ecb9115c3b189f1b860bd64cb6535224aa7beead316be4c0c3a5100ec3731f8bad8d8749afd2141c583658ded7a905daecbd2732d0088d261b38bafa4aa5275ad5c12f016760804fa5cd8e85ed16fa4d3b2c90709f1a3eeafb567f5d7670f9006b092d70e6f87363bc938abe93ff69f96fb5da2f18d7ecf3916c2bc28e4c7ab1d1ca0cf4869e8821dc8caee07620d6744d55ed969085abe3d269632270632c4c065122436b7112fca671c5faca8bdf6e04870f8849bc90d4f145fa5f1587413d2670ae9654cd573bec85d0384a46937c31ca10c2598fc0c1803ad5683ebc9b5cb0efc76bcc49f7a06d8b6528b27cba35e360c1707e363f5267e24e6b0de40bc655f822bf675de0b84520c6ee4aa59d539d074cc96b32888c8afc20b228caa079f1a989736f0fcfaa41a70f14e7d1c990107641f9552c2ddfcb51613e2a490494e7042954200fbf09e3912f1fb0c48b5ea780b3d27cbf32604f598c8db067afc2792da8e11143df79625733e05d822c9e38c5630d2c6b0560cedf514068b1ee54ed72f2010be03d9ff0f954a414499919bf9bfc7c7a1a105b3f814b0993c5fa1175a3333547b6ac9a1b50a3b5477e8e7bea9e581249a8b90418aa8539eab49effc69456f8baab437de0e39a150018de82cf3758cfd436de5bb9c021ac4fb51a39cbd483c3bd09dcebe7683cffe4bb97d598c9da69c34eb73a5b52e8e27cc6b06819ab1f7cc6fd2bb6792cc6a1f4a80e6ec61bc5ec5833da37ef870874b8001ce46dc75443b4d67e0c75435e0fc318942ddf9c10532084cf79dacfe87a28c9c41df00a142991959599eff7c60a30146a2ce6e2086fab7744221da936b691df5cee94883b1630be341ad017dee43e61c09996b79f09d948e11e74f57774c13ff7e21eb94ebd41d959889e65faa444838d52911594820e23c91cfb4066b05a0eb05e3ad8d189d64863de1fbd06cb4b3a3370abb2b7b2a87624b9aebcec0a62ce869ae747771f00bda8ac5f3c32f5ddda0922f82c14c1fdb09689fdde3ee46691c7d463cd0299cf4303e9b4720cec3e0317f512f6b14ddc66d9a46d4192b4358c48a4174980d68bf305ec44f59bbb7bbd3e61893c72e74b9934a309125786cfdb529caeb00e0b6e9281d87072adcdf8b2a9fee11dc7b43f51724ec59eab00ccfefc8b1b9ff847c91d986e84b8e960e23f5c85c2dd80516e0d431760fc8224386b967b612c4df140bdd2c8516b66743953a87fe32b4d58878553ffc011276c528c3179356c6edc9e83951b55ad2c10c6817c2cfc934f6be17f802c1ca008cc213aab882d10676baeb8dc9830e68f8d93366492fb2042a1152eb5356a95f9fa210a0368720102e4db8d1bafdf8f901afd864bfa8006aecf55c8a4fe3153871712a56533b7befd18afab6f85b392748c048493ef57f0d2b586227e7c693774846a95dcad7e2f5f5b31b8c1e908d232ce522e41d0e23bea52cc32091eb3c26587cbb7ada63fce81202772ee429645e7cd58fc5dbcc04db650867ec27dd6290c9a5780939096676fb8d42249a3b9dd90c07e85c91dbd51b6e53d1d83b78b78702b700c8740f2346e409fec483024b0dc0029444304002b800ac2e746f10b7e34ed7254a5a54b09c05c1f709da85529412d10089f8c5cb62818d3da04bdf44c225aa8451a2aefa6533989317aee8b148484d6d484142d73c1aa10e8269427fab80a9190b06a3ccd69f6fb15df860030d1269c09bea4840e7353bcec28bcac70693f691e9137826c2387ecb034edb9883d344f6fcc21872c06ce2d80d84e59e9c7e5479e2b4c46a75241598c394b7c35ba85d4d787f9c8768c8d2187bfdbc9ebaa166081c9560de8c8c93f37b1ff6d7545ce03f7306f4cf59ddc0ce8d55e16713311c6930ef52f0dcc20c8e034d74b813928177853ee3aa2c278ca92f022387e85b7671eb39d46206e59f7334c945eba0876e2e66a8bed3c68d13526203424465ba939c1fb04b0b4f71be7189ae5698731d9f96d49487ffaf1dd3f4b6734144c0d1e8750307a9c9c863bbb55c33617b212eb3fad21e2d309bac012d24ca3c00585fd5a9564f2879e7a3ae27aae09a6ac65b8ac17217bff28bb2d3a57ddb4c3191764980f3c6b5d0da4444197c06fc19a5d18194de2e273d45ee12c9042e9efe64656d810c769e41824cde9fafff965ebb45f661140181bbfc976b486025eaf3ccd986faf2475672f4b2337bd53bc904dd36cebb933c01beaa5c780ff4ca54aecfbecc3c86e602a2a52311c8bb4574e3c81f9e48866091a759224cc7666fa302471cb31bd55b35f949f95d1e1bddd9057480961321edaf5d35fc0e4f99293dce9f86ad7befec5c94d438e73ad0587d157998ecbaa2d6018120ba2c264a674dd5389967a6f168b760d2fe37dbd4eeabd0ac86c14a4aa4e5e23a551d4dd8588a8bf7e760d7af84c83f2225ec2ab6b9893b84dfae206532f4363431487a4364db5c613f9083d8306b230a2d32a613705f93eb7dfacc1b7e138cbec13ad5e02e754c5a8bf68703f27c97773acbbc324c628db8f4fa910c62a76c82394eed1767ad183d599557291aecd9bc75de8aa70c068801fd4f90b755be5b74d69d4fd2d33917af47c37adb5ec844a6139db1f35f8160f34f494a30b34407fad4ae723f816bfa6ef0c082cd24df15c13d45da3740100accfbbc83b8cb6d514c4c7d5f69c18523f168bc5c30437626775ec4a63069a14d0fd4ba536087d3fdfb3c0437c4c5640333584581904dc87036d6e17ca3c9a90755539170e43fa3b1ec77b85f3581585a46befb24c10db50ee63f3f756e604931f25677a4c0410cf348953b8d7e5a201d2b57ca3b1ab09ddac69fad6a18bbe0c9691b6e04c90f0be5bcf10f50141a8dc4fb993e7944c11662ab7f83dcb09c3970e97bf80315b904102cb4b9cae02734b3d8d8d406d89a7f0efa0474b9871b58085695576447f91e07c48e70fb00174eef807234407086b00a131fd87930a6799a5dc3fab568960ab7a3bf78f100c01104f25f5bd811e492c9e8a617505f23dbce8f7ecb08a9759c0c3417a1a96f581a7897effbabcf33a43bf2d4812071f7076a17456fdf259755e1e2dad7d455163082e027963345591be952e340690d4d11d947d71ecfa499ab2e386eb7470c2f4c10666b1a214072ecdc9d54b5eadcdc15c4dff6a72fb0e7ebd1f4054d83eedaefa7edfb5041d2ba5bb112b72bcbd3e80192385611471815d048f92066a1e69116af163559a6b94ca85dae4ee25f2e86ac5746f80c765c46ef07c088ae7d224b27df9ff831ae6e02f2dbcc6ec43c49678de07f5aadb1ecf6b92fe87aa288dbaad4c09129b6a51d7939df8844edf99dd7887c7d8ca101b1dbf17f5cefa64888d12668bd8f000a60693a5c2cab6a0e3639c16ba267b9b81a035e3afd5860fa5651492496faace120a050e44fb3f377fc75ffb778d284904f53146bc198f4c9ffc3f46a5021c6a7ab8d7fb790a0e4b9ce12500890ee42918dfee69cbf2e279aa3ca0acc76063fab6f4e011031108c0ae3eacf355f83cf90b3bbf97dc366847bfb6d55432221e761acdeb7b4f2bcbcee1a1a7090a23b68509282995122d65d9919a410f6d92161f6b867ef3f064c9bede034d1a5951c2ed33314d63a0776048b6e2fa3a920b6d4df9d68054c78c3f4565cf3b0c8d2d6666f191353264313a4b0b36907d6a6705bcd1d9df60db9188f765c55f1a566a07fd5daccc09dcec690c252ef42c8b53e727e7ef3f67ddb0185f3b1f2ce606d689ab117c8e9bff394739a8e5f07662d7ac9e155b08b9dda47c5d88444f41cdfd15a86ecc33072f072c290ae2541c39fb544dc8b17045fa47ff5619c70fbcb4c12e490065464634defa02766fb7cd1609ba8fa9258dfd724ecd8edbe8d4cd1ff3136bc9415604aec5a6e0b1c6b7242e0c6831ea97287cb79edeadfe18a552fe8d6a245ae7808d65013a3f3bfbac4ce3f866fd34433951ba17cbe579c022670f25b9c3c5865dcb1902cbc7a13bae6b668db2fa6a74274edbd5094b73ae836f5e069e5df52e534de9e05444ebd1c0ef55165c7a01692cedcad862a696a72762e07ab986d0768deaa71332c5bdbfd6cb5369de8b5885c5c9ae648c8ee6d14c08b60e3274ae999d59a8326e6d343d63efae231232bc2a64ca39c4b49c53f67d7d22be9fa3012ab1c06cb5d9b920f2b4244f24729c750c3938c4dc3dfbf3b186937cf10bc336a515676b9fa75fcf57c7e0a56a5998355150eafe4c277611efffa60bb23d42b4367bddf1ac4d8825ded08cb90a20682464310957df5f745561b213cb6fecb6e763eea361bb83ecfc8ff980136fba778799b44b5f795d7a14809d1b1430bb5e3d16fbadc42e8620a762a16f9691849d63f5085e1dbf0cc3107706e180f47f24a827ec94a3c66df3cdebbccf1e59135439889b168e61f8ac7218e6e9d1830e932a9ed787fd2b60e6bea1728911bdf29ac8083c4baf4e25b6a1065d7845e3779d9999cb9a14ae0d72dc679c9dd9039cae0387f0ee1013ad332cf83402687d90b1911ba1ce41ac76e704701227ba5cba47a9ff9221f5ffa888a1603d25768051d5728b4a5b020064eb3b098e2f3c349c1bf7d433831b63e197ea26ee0b286b486233a5c9e73eff6cb852d591a6631b4ff6256dade146a878d178ba930c3ab8a617a6a7d06b529a1bb2427a28b4302116a0d883d5f1af8257a153fc8277b10b4ff55cb97a0eff51969a74df83b6c3e79db7bd5133002a6170cffc651c0f5594d37c70cb406275f5ae01d186a7dc43febbcd54839ddf93d3dfce325ca6bbeb77505caf99e8f505f470b199a371d93596e801e7d04d3278140e037750c328c5350a1b4c97fc69866692e1cc6b5fddf4e29e008da4d79fcdca94c54c297e7f02cb355f3605043e0a2230b0a195a7e810a928d86fa9966519f0a2e30d4e7fcee0fc60f5bcca6fe8a2d6915ede5d63329ff62bd47b04e316043d38e9d7b343a9ffd08c6015318ab542ea2cf1a0afa397d998d42e7e43fc054eae6a1b0bee2b00c034c4529a6a14a157f4bd1a5e9ce46f800bbef3ac23b69367faced04605c2e1beadfad311624376d58a1d09ca8c5796cd3ed656902027a336775d4ad944b0bf7ac119555da8fdfe519e044f63ef6063c5a55ba11b65f872055bf6a29d7b48c5aac016a3ca05eefe726620e742a95a8ffbcd0d0c173b85c68d1dc742239c9ff55e94116a01597082d7d9b2c3fb9b00197dd836a6327edf9468e974c01ca6e5538a534ab1a3965d0a20bfba22f828cfe702ffaebd0d9a0760c77ebca1d72a241ae5f2593c46eee3e25378c98b48835fde360d697ef9ec95021944e79509899866626afa211855b4371f4c56c50489201ffe381d199316032e0b46818996f8f1803e678522aa265ef07696c9b3003b63f44dd5b7bcc7f20f469080ace4889cb587ac3d7b5bcce74338e1a44fe7450f569a3aff5a053d9e8f461005b48811c1601f38d69008ed9cbe2605ca97d061a33c684921990e60f4c30f02c3e781acc7243100ca392a8ea2789314aa30727c30f028146c9c8663fb272d45bdf9cfe2e5899824f11dec4ec83ab4e46b745a67681291c934d0f607096bef11165e7e8833135378637bb9a3479e4178f4ed4ea91d2c8f1e50f29be0d5364093a6b6c74049b3b90dd36912ebe1e0b1bc01f328f6f311da1184d15520ca20bfd1ed2ec3fe1783ee136d24552059cec713aa84f54e23fd3cb0ac6082a21ab11c2b9ab0f07bde80ad741bb7f885ca82e13a14c72ffd9bdd32257fe76d74edf1ebaec79ea1fff3393468ca1eaec3ac23e7278c6765ab50bb548f067fad886eae509cfe5e43b913b9e736abeb513da45238168d06c5c017a566816d7d68e49751b58eacd4e40e0c70f7279924a8797857846888a6d52f4389d447d97a679d9604aeb9d85a0cf6a7f3871c8a4efc1ca89184009a7722e4f4337ab5a519d970762b10c44490c68135591c2fc5c806c6d87cbab70f78cbfd5821246cd2bb92de4e8e9dc176a61b6d803ad6d88c15411ad9b9f52d2b2721f84338d10f1f71f81044157b55f1487d694ac9a2350c7f17844f7abcaf8e57d78f0d18707ec858bb8f1b77e56ba64495e90f0436e2869aab48b10c9e803d3de0e28ea9a2178f92326d79932a5aff6636ffaa26965765f0f3f4e9afa081e7c78c2ce8971d06ab71447d12aa664ae9685ab17b13484d3a37629e7e40f6e2369716ef49a85a8d90f0c542e8601b687d8d45d6e845aefccf8502e70fb6ff25436cceb439d66ce625eee6224eaf9a54c5464987dcef3b034945166653e04047a3ca44599f6f7e26150683d1f316b4b8c13b28278a6b2639b7d463004500e6ef2f657cf6c31f2047464c29a2a9b628dfc3220b9354ae6819a38c3762c8909421fa7406b6dfae96fd557059ad85413d5f890347832192bbb6a4df9cb58b49a9baa6471570cecff5607e246f443ec7b662583cc5998f06ea374f99d8b92436a67029b4005ed4e80e3c976b83735bd6474c224c476cca71fb27e588dee5dd2ddef924ea19bfba4a252e9d7458f52b081f193da242bb8b7dc61684813bd106f4b6837c5873cd36bc0674bef874b3f3af25b753e58df698e55cf76192c295cc9aacbf3d90370635c3f2af7c602ba7573ee62e716908dbddb025dd07044254ad9ef419035284cb27254741d59c518891d7a4704e3eaa96d4bad97b46f6570bcaf4dc121165db37340be76772479463b6358322eee241d31b235411405dba91703a5487d5f8b36ce9625ef61ee111deafcfbfb50cb7a94dc9fa85ed2d7189ac84d5505808e2281d7b81d54e7de00b247259110d64b9b3f3dd52b3d51f06dfcde4c7b0dc8c1fdb1277b433512cc9929fa6f2a0c1afe50b2052a68b36c8e2d2bd39401fdd18270df333797019491192ad690bcc75816d3f9fe41c5f5f2d521fee950eaeb1d233833144b22256ceb03f305e6b1c34a5929226d9b3f9353774be1fc5dfa4c3ea4ce60f3265f4bb4d86ada1ff9d8de4b432ddc393f7dff9587bacf5d7a84616966e41a2b29f0fb2082ce4a75286e5703bb74cbca37d75d49fbd3302bca93a60ba08beb7e77afc096c42761ec2cdaf79473e4cebd427e0705ede4a87238e178eff68d2803b35ddedb220645c22f4545be25e7060c1d5c0ba6d11e8afc5782e263da1bc8ece25ebe50b87058e316762bd7d6e4a151300f9484af4e55e50f666ad16151ffbfab4bb34ffc8c56b778de491e7cd45c005e66697c97284246f4c4013af07de355bbbd073a050a0fddef9fab9548178f66743299f3cd054bb7528fe65d3091e564fe9880f1900e7420e063bf4924b8e96f333bacaf38bee994c305499aa5e025b82c4d4adceb10e8a5d216cd09876d9c3679740afa36c45c1082a99be7808c3db4df96d299b4f3ee3b097141cece5a8df7313f0a0b48d0b5b632495484a721539a5cccae64459a09872f62f7e14d5cd6567c039f69d7d347e2d2e32702ff760535936cde6f3557f07fcf595b56c0586572081cc615002da5e24ddeab3822000d08c7f6a311df189f276f8f25cc29ee314b457f640cc30fa8fe15f0b4c325b7e83424968b4bf5d9ace73aa676627edf32205e016e953b876376ed539dab9fe3b56c12f1749ebf42df21b2d3cd27d7617301c0fbe4500fbf2c90c5416d51f6b054cdf853f16c052aa01dc0911e358cd53cce536c426339522a2c342fbb8efbfd3273d9b666b9d7b5c487bfb00611d48cfdf54f2ea45940096a0eb9d6c57ae474524a00a8987ccba930019e8ab137cd42f10abc35c742344a00bd61e840bbb9b7dfdbeb56b3c241730f24877800b30f775303a014e921aa6479d39a1d89b3b862a862418d0576e431af8a94bdaa01d33ca99061f587db5bc01593556ffb825b5ff8d88a58c330a629124f2dd6706101af4601518b168292991ec8ae2f9130d018d4bd5a57911af36dff78f7bc3bc6b356c94cf54dc5fe6a4e6a50090c0e641376063c62809818881cc1ec5a6a21c0157c96668d792966f50da0ca8c4586bb401e6ea73f526ca9804970d7aa169fbb19daa8934c6e99ee80e3a9de5688160441704a9c85e86674dfad565de10f5189edf50101bc566d901c01ac3dd7adb7a9191c75bd7020ee4f432661747a257e6b3c5f36a5f68827b62bd3456e024efa9f7af2333a0c90bcddc108634b843d1385c3be46032512ad9e3c7fbc20b304a9f6b66b3aceaa50e12b33e190731337d6659bb3b4a428ba6d56951431657a1cdf00698c318b447874b3907e0a69c7e7226001f65884949acf42f4bbe33ed0aef0a769aa8792bae5a0501cc81b32e50863a651273862dcfa560f825250d8d31713aa6b6ff3260eeddd69ef4b605c934f7cb832643c345ba5eaf19da7a0f1c126ad68b9c7e3fd292fb9a60b0843d4596dcd9a0a1a0c67485e941aabb59f8e89ecca21675ce7e4f25d935f76fdb8e8cbf1c2554d94f4cbe24db598a8d1e8cdb3225bc1ce801a6fc33da313e0d565b7cbb4b51d8a10e25a0822c76696241fd810f0d958ecb7f3f79462ba8c13c1e4db7a767f616a8fe02ff9a9811c94cbdacc9c1e1519190d119a1bbc1f8cfe6bcb9fdbd2b602d748f0703808b6ce44694ae1ef55bad8e6373f313c00c028520f0f97eee06dcb3eaaa7afbfbf0ddfb0adc9c03fb44717a01d9d67602ccf857738de38f3832d0f40ca927665522535c71dd908e179bdfbccf5b707d769605e1c331d519a1084186002a00b307c3e3a57cfd4b57b9d6462796b58052f115767059ac918377056171b49eb6fe8948adb11d1bbbbdc5413225b2ab7e0e62d546d6f3624cd072e9354ee6608ba04fc6e5d377bbc3741585d15b9bb5adc6813b5ac80f68b8785667c37e01c77686cc5dd23cccc0e595095af583cad240b918a80f653c61fbef3bf484752c7fe1c95c13e17e6d1d68caa28485fc20423aacc1d631e7c168f0fd497dacaac336d8f5aa13a18fd1e3869d003b0f8ccf7adccbbfb732730645c4a0b5d11075e5b8be61ebb4e95434794969d0ba0fd8744a030b44f07c9ca8e8202ae82ed561054ca84c01578911834b4382c11703f9a73a8702eb8d7c266af0a40dfb207756b1b33aa470bf8fdf39b33f35a0886e06f7f76659aa63e4f70d3f9b5f8d2d98be97b11dac3a507d30e94fd254f8ba5d0f13b4bd781b076370fe9a3fcc6f4e227f2ca30192088571882909a0ba8c90c79478ac0071a0e57994ed083dea8c999241bf76504b45f0fa0e52bae3976ff9cc4f1ac3efab848a2d478768ff64a681549a6c7653b2537c63701977e626db36e7038f764a16e73278a8ee2aa33448ed114fe717c58fe5af4e079d66db69cc02859082ee85e82c364712766bda3e0ce5956a1274acd2be826870c9b09f22dd707c41d42de1cc49ab66e498cbbb96f1238acc130e85b146049f2d491e674d5f1a1aea2add1327287c9e417eea61ad3e02efedaed9361888d4b2e04f9c89c554e3d61948123f8987a348c3b095cfb3b8d62aa86ecf1549201c1da2c4654e9c294713e75da0d3b87c7b9f59e75511e60aaa92e2726f11a2f8e24ea21c6e5c201ae625ca0bc03d02922b01c0d695f1326096050de1e285431315cf1bc53b83e62ae57b22c5d6759ec7c00268fccf445acf6faf3566314d10a3fd16bf1d47f387e6cb762efd309cfc2f1a53729308254d2ef960ba20c3e38c300b3496c8359b24d7ab9e3c8e7d424f908c062b6b98e284fa88e3f7a5bf55a1922d71b5596edba79f54a733f78d7f4fb70427b0101a9df8f706b2238f9101370ecc6eb185a532ff72a78fc5c078897054d5decebf5e6bab51d7ec09470f741dd7a5cd0f4a8b9953bf9b3bf8b2481ee0847baa3fa65a675e634301aacebc1f1a8326543f1e10c2b49e1a2aa8499f4888e52d1364f88f49e9ee15f1ad6a2782c23b62cb01a822861a7e6d8fba424e283dd60b5cc432392281fe49d5d4ebc68b16f3231869b63cc2da4ad71d1ca07279675ef64aee838fe846cf4566552ad9479bc9277891c664ea580505fffaf4c5201b8bd601fb474c551e69633782f8a77361b217eab5fbe91ff6152ba528d8daeb5e08b739ec4ca5f3da9213c171b81372b57d7b5699db88c9a8cd5fcfb2ee0ff738c9957acf92d336987110b348ee4df769d99c22af1066f052d15206945b63d3a02bab3bd91efde8ab140a218f70e51bac88c68b9cf645ffac1c433e8220d45171a2c87858928327b366740882551ca09fb385e49d91ac0bbd30f3c74a117b4552174e3f4bfc9afbb102aa8927239cb15acb31593a00ee43b582d9d1ebd263b2e0ea9267f8606d80f7cca7570dd757ac5010b0192090ce7cb0126a63b963169190c9add4a2a19b76fc040b5a75f7f77a6d49737b42d0e9904b7057db61e0f3edb5fae759f264289436c470070799d8853b11a504d6ac80b2cdb44d9ae69a9a1e61525d3519c3a6bd84dd8a4356becc858bc0bd7f4d386f60d393b43fa2877a6e353c0463e7916c2be08a32886b25065efd1b9314ae22110adcb6e6005d573bfb1ad76d1ed3c49b40218fd94e6b936b174ab6ff3f6a32e9122a4187e196fd0a2b8b0a1f2129e057188e32f79254be548b59a7533ae85a2d797ec6152c0f4c984358f420ddc7d27d401e98d836e57701d2f04276d230d665b4bfa104d9def31b4ee7fdad46cdc043d6077f5d6e4843273905e5248952214ecb8d3f821295610eb57fcc32a797566fbe874f3b9a19b87485a52cfa80716670d61a362337d771a025fdadf039a5847ccbd6f9135d45a9ae0825534aa77eb6f4d3304fa57e4d4284181f5c0284087cc735f05120db6088dcb850e894fe01ae8c317abf0af3f51786ddc756e5322f9adae5bda001e9a1126ff9ec68fd59ab7fba4e15d8f591130f2feef70d78c6d8ad2da26d1556d60c45ea6c295e32180cdf5009adea5511d82b537d3ae9ca9c0ec12dcdde7d296ec25bb10e1ab66954fb9739e93e318ba8aaec281ecffcf142465eece09f082c20fa6091898dae7d3ce2b82941896be167006a7834dcb12a96e24798da81785ec072902ade2f0efd1586aa16a1ad691e56710380aa2b82c02d54334487f9cffa090572aa81de5751ac40750bf84a61c222fa6659866430c95e80f6c6a837526fb553b1f1f6e81c1568eb115a0f111f36bebe0994fcf61169cc36729b5274c4515a67e8d61135f9bf40f410e18aa0682468feeb01f58f01130097b5ee34b9409ca3440af0cd8c3392ebfcfa4f83713733f2a49aa7f44916d8e8cb8c24606c7d8f2a6fa8d05250afb9577ceb524f6f62cf5b62ffa9926efe48e46be0521ca96926b2db7d4a459ed94853b99c2650df9c826f4bea4261bc484fd1a08aa3472c54b59375dc02b0bee7e9aaef141a3112fc58fbd8292776ace981b445a6d92285690c3a9ab3f5b78ef9c7e3d4eaff19daeb47670d68c1e89c525e3bd00c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
