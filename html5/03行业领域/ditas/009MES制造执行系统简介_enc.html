<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d560e6fae388f0f46883bfb3badc67c017dc445a861f3e3b05ebfea615666f9408c00c0d0dbeaaaabdf5ee7e30fa7e3a6e1ef29b9ff241b8c3634388f93512c36c3e3103a3d34f4dfbffd983651af72a54f6eb76c09f95405925148520f3a008d9d4f91cd7a99c266d840996d2113f5aa3c14f003744af0b2470bd34c1aa0d60c63d06e34fcc8dbf37ad311cc5ebda901290c72c889ea78251f5a25b1c9c68acfc7b5763f69cc4199669dac7235be9f623d6a6a9929d112b88188ba5cedf6044066fb7976e1181b97738b876baadb81daaa9c5174a7e4fe9c684a5428b9a9c08b65c75d86459a396985a1b7d5c7d912a4abca32efcc8e179976ea06084ee15d441c92597c6e52bc5e79e6ec484eeffb4bef4f29efe5cbb12f18f49bca35aaefa5d3258f006ab5d0559b7f6b6f9a6eedb324a1f5a661b241e63e9f7d291816df4c409b4c979ec9267290539b6ac46a57f241245dd498b72878f747f632dc0189cecd7755daa817c9d9d122873f8bea740dccce63ed9053cd20fce81942178fc82e8a0de8776b4e21f28fc961269495c4cad0a21262f94914d5a28806109b3e5aa2ccb8addb12cde23af15cd819b14123c15a5fdf6b12568d20e7018ae6310f898fc48caaf3b5e1236ff0ea5710b9b2505b28c0a8bd08398b9235da8aaa548730afb59035241471f432d8f7ef5f19ab42c67e7671ff8c39865e3d5d1ec00ae0045f091e7963f4d0277bc2ef1c5cb304c8b6ed3169ef14940a001956f8ee4ef44430505189d0728dd0e7ad8323315d5dc5aaa307f82b8e7daa4b7bf924f8127e1f4ec00887e4e5c35647525c556ad3b7ce84486cf8756dcc8eb59a8685e42ffda67f38d06c55b1d42fbd2ca9c6edad6427268b32fe77ba3717b09b03f21e31ec283e2fe7e3073dd600854e05759a891009dfb44cbc25436bdc3f97312cc8eeeeb20a18f695c029b85671a30f2d72a293af230a877927c2d9959c6bfad682652adcc0be2e13f804abcfa8928a3f132981fac990289571823cfec2d7c9f10f27184223093d90b4122effc48930f1792c28d0d78139bb78b55d0103a1436e995479a0b53e241b5591c03f65d5b21f15295200ddd4bef0c6a5d439820a45cf97ee77614bc2274fa62fa0b555fb31c214e83b0c9553a81e5e8e499408cbd71e299cdaf4078c9311b3267f341b734e2fd821fd3acd6b8729b5eddbb87a64dc7b24bf7bf0741d6bc7de857e9b2d5416e82c273da1e7c09958f8b9e6f114bf4a7cffdd4e2fa3090488aa7d3329b797004976e323a9c8c3582f90ba06456927216c59697fe3c1d48df30f10cb589bb41b36d47dd76d7d5e94a2418734ab31ec740a03555b69fa3f6a8f89cd96178be5bb0a5fed29afd430b9e642f7e265849cd092aa77c68ced033585a71973742cd1c2e532be755c169cbbe327b03e2570a81ff911fbd37436a9cec17d224c9e22344af276e68cd85274bed1d4bffc22f49de0b2242fc15ce9afbdc8172b068c867e56f16d11fefdc95012921ebae1d2721a2f5faa44e1f57022406dc987e4c2512695ff6199cda9da88de02404791590072397e69d7e80a03f77fb123799b0bb2f9c810a517471a22dcbec9965c5fbad8cd74d1e010586579e7ab14c0c271a968351eb0ec475e9f6a4448d45713f82cde6edbcdcd757e9e312d9fd8530d49c7e0d5758306c0b8dcbb88ec07cc56c6cc6649ccad0a5a3d6837eb8a516b6240043072dd78aa8599e295ab8eb4a981906c04820df83a7fda3ac86876926b0c297fa99d0258d1822e0ca0cd7d845d6e36a105798c94f7500679964da44111ec225d78b1de01810fcba01e014a1197841394dd96c6bf6d68080905f0442a161787f5c7b33756895c65034e5fa3ed1c1d2d40d9bcce4cbec56720a6c726a6e920a8593c2b6cbdbb8a14ce439df064fdb6b059f5d36a190dffa83b459b9c43e67ec8046a9b57c7dfc72f3d15531c922826caf9cbba73227c26999b4ffbc0dce6a29a74e253738782907e2a7977e4f1a8fae54ddf6fdc310b19e5a6ded1b7cd9a75cb34ffcebc014d3a5546c35667479dc6d74de79f011a7c851051794f0aa97c759e44cb41475a90358d671ce647b446762058a7bd0222d83b57b1ab101cdce5f347d4cd5c7dcdcbcd531ac96ed683eec713ba6aa70e2c5832f5b76316234efa9db272a6944002fb7b9c7f78ff7cffaa06d922a51e0153c5fcdf7b361167ef4025664fb7af0bca222e3b9f38c8092569c52b89722ee2675d6d86fa72b23988a979471b64f9976a75fce18b7a07dfe00be4dfbd48c7aa772db597e4494f830e6ef04f1a54e66218c564a66b76ee87f1364463ac7569482b6418fb839653fd9d0aac81c57a02b7351ce1302b2b1f0514b460efa423873d68292df26a415a079c60e1b8516d3133d07be93788e53ed5c2e6997d9675c6d12a2c5e84c738e9372bf8493f93cdfda823f854b41acc59a06f74a94d8d2b3d79a93adca1455860dea0f0fa3425a247835ce338bc7441cb3218a67cbcbe6f95dabce43e58b256c0b776c45d69d727f31fc7b8d6006b4b48d99f2914d221ecda3fe470e6d5303d8c8d29282a32e343d002eb2afdc8425de24da857d3294331417b14bc5d77362a5e30ae860a158d3f0482f8d96257fb9d178fc1bc176ef52061a7f88dabbd216976b2003a21763e12bab8366c03c4b8b53edcac7ed6400ffdf7ea06968aff4d28821c4ffa2010edeedd3c3656efbdeac92138dfb404a13ba4049f4a4bba283d97803283db5b8b78461411ea8662012589dcfe9d084601da88c13ad73b5b17dce19c9e825fada5e8a0ee732a5d92f0f25853fa54282d6564d2a579f76e8b5a484de0a70a4231b550c37a1a772a453171fb161e1b0357d4b6317aa09f74226f2ee5d4eebd292ffdcb8003f679ba3d4c544dd54e31782f1da9f45804b1c26a950d0dc546602f2a945f9a5b1fb670a6239d97f88e95f17458d29260c05da28491086126cd3649b49b2a4ab709fd9780793a25a75f4c4329efde3e31a31dd4dbdbcbfb226b013a73a09a4cd27bcc8fb480dd1c76d3ed522a48e442451eab5703fe35f3a7ddaf3e9095774148367bfd69da995839fc825afffbd293b09e24db580f9bfb0c530a6ea9a34d07ccfee1dd2fae2cc226c303787483929ef185eee66ed17760d7cf87a252f0f59dba2049fba11a77657bb756c7b1a7ecbce8f0e225fe1f114e6c3fe890a9456b67f5db5c19a1cc11aa69871b52a3372beaee34dfeba3986fc8bc7fdf9361967377b8b2663efc1519ea0750d697be686bbc1672a18a437d4cdf7d84b7fc194c97ec9da7508af99d9eef9dc5375a008765b6b3f791ec7698b9ecc056e39725cc3434bd571b3cbf5fd69bc49fd0dd6ccd9badcf819f6b1ec66951b430566498986ae87087907813a3c198c2be9b5455c48063840330e38c87ae729281604d5a1f70dd3bc533c18edba8014f8ef5e3d6d4606746d37bcf6b2e39f2ff1cb9f821b23d9d51b531a3c905080802fab54cc9599208b575e09b4999e2326e1ff8b029e176dadac2416b31b28d380f6f910cc8c6d4e76f7c083f4a4c24ddf98101857aa4217a60ab1680722a1115015e9470f4a38d067468cac94f07b07c772ee9f9435e7f7cf230e0f1dd32f16665855ae582faeeed93aed19373c6a8f8bff982c26694eaf6359d7a5064c69fad765a61921bb5c440f90f36f941c383449c0ca2bb226741263e7279edf6eedcdbe67a187964a2805196455bd394938fa61674c09909a16c692c52bdd241a9b5691618c16c77f23130d97fe4072a783245d674bff4bdb6318af6fedbc3f066506a024f4d8ba60cb3a361bcdac0196f4132f4528e73e3eaf8870e9aeb88f350e35cb7433150904b491e2d5516f0a25e7126ed259f02ea989524f9db4d587e854e11c8c4d55aaff948a952d8a122f2f6c44b52586fa1c1681516066cc005357b4fb51b9bc2768772d53fb1e45a06cfb26457499ac18e574a6a42fd7527fb1fe7c6da4f6d04141d7c1d3309a4c9d71c809fa1266c2cde9cfd6c531fbfd61d98de8bd7df3ab2dea92e57abf1df78871b693b85fc5f56dba13a2c00490a3d379df4e58f1b0cab9b87e5186e4b3b5c9ab9783f50584850fdb4a74a88d0daf1857f898098fee2d7e345a392c73548ff7a1ea9859c3b21b2c5c4bef6fecaeb793fe189f26ed68bdee67cde58dcf5626dc2b8effda450e29e43437e9cb9ed9e7a1cbdcbc99500f39e8febf0ad5111093858271ba687c3d52d18fb8ce448b4e68b0080ee0620ee91c821b210e98870569b663594413ab6b15889bbbcc03c2b104089cff9fd4e9cde022e0232d0369c83a748bb144585fa10682177837d33f1c945bf4cb868a1af95fb5708edec9483004a052efeb165adde76ce66603943f4c969f86b59b0d342f45316521975af2b1434f70892dd7a6b8cdf2c41627b47e2b3846e183fcf69bac13c135af029ec368ee1634fab0aa80c55550074ab9ad2ca829b874db29838b97bfd32cef7c4bfe30f206f41503a1326e18ae965a1eb5b249f03bba280546d66127025e7eb5421bd14b1ff918972860b1b309e8e47537278db766ff21429fda0e16ee1c037574a78001b34aae2493f6f2b6e79902cbb07bc63a2edeaae5b92bdeafaeccf113aac6798469be176df1a6679dde8dab3cd2a1a1e1e9343c714e3cda878f39054d1fec4b448342b851b43d2132e285c84b5f0a0d593576564650ca5b7c800e491ffd6172cfea094fae2268b0c644cac75e8bc792f5152e5f721f6a62e19cff8d90ca90d1807d93c3a1564e9909f45fbacc869fba24ab864e1f0042c2f473f16ab38d6802c31089c761b796f9caaf6c1c1bede34d60fa773034c107800cc0bb65ca710f2e57074469ea1b36d389d62a617cefe9f87079d48e7c5693b2ef09542beea27260e781c1e3910d9b66823a1b3644f488b70b4e2c3e5f8d186f85e7944d4a89cb5ac7a9380df2686e63fa7bb04c3e0b9e6b0b9721e5a80a5804f5e81cebdd8025d2d5bda6bc3f211f987211fa5e6ca147246885583e389d2cde8bc7fe671c37ab114267493a96efe0bf14a6fb59df6cb094896af5b65a985366a15d4cd0edaa5ff20246bdd623e0895169325527c073bb1e9002d67a832f3a08bb9433fd377814bb3770f9d87a02e8c767d45ab5e0b3e88627d1fbfb6161034b7298ca5c55bdae9cfba0c5df3a0b439642988fcbcec556bf4bb19316eba980f978a661012f763f6999fb2132e7a44b9eb51b16d0bd67001f3078811982e2c02259366692ae0c8d510e4678a51c55b0edfde42bb044f3f3f113ddd8bc373817289dce5aaff00c0c6ef289b1ea78f318138430985d13d5f1091212d8cd89590d94d8084b1a8000cd4b24fba5ff06ad5298b99bf733056012647e3c9c99abe2975b9d405668c1b1546dbe5b5a5a842075bda8f29ff79bd1dd8bca06999291a916efb2c8ddcd28d10609550af035c539a21f786ea34980b542d9e18ec4717b1fc7780362bd67d6eb6036e8892108bbac8929d3302296411d928a306005f5ea52cdca809aafa9dbe7e2d42a4197b83fabf915ad5b5835e0cb4e11bacb8474a6a28e03f0d890be8cb83035ba1fef7f611c0c8b0692c12587eb195cb1a97b5b7dfda262d6e626c28b566fe34f84cfbdbcf6c412cb4994ee525f749f5b7dd4e0bbf74793229f2ee5a3e416ab80e3b8a11d0d5ffb044e023e5de3b78508ecf5012fe75ae8f51d9f2b3df73824ebb7f30de46ec93ec250cc65fb4c42d3669d40c1d4a840bf202d771548e15dc014b585161b58b40334900e58818bd12601b54b5f7989f56cf03b3cfeae68926b1d2e321cc6dee9251385a0e5101045b23fcca49549e4282498bcdaa0d584d44495e9c52f38dfb3537e4a9936edfb10fe40e880de6f10c971484a91036ceb20c3b1b3559b1fd1c4b87025cc9ef8aea23bda34a60bd733eafa9e1291f29fa05799a4e23433cd2f93b5a2b369891711e03faefbe1c3b7b4029bedb6720db0c6fbefa06e140a974ae1aab2104ed34dffdda9e119de3f2cb3d60bdca0db7127f242a1663a99d44230fd9959cb81ef4c1ac363047fcf79bb13406621ab61b2587265dddd291c9eaf33235a537739041a3965adb60f7ddab08d9c9ebf9b998c52842a159d6a398d3542f396c17224b1774bda3afbf09497a5ff59967a25c28823c2bbe38c3616a10b5d983d7b5fbdff48e339d4115702101525e9632b462c27296df17905b39d48e9b2459c332ebe613b57d043a6f912e7db251f720b4ffb991e19146ec44a5edf0dac029b5ffe78f451a2889770249c86b611e5c00bead65c671509fd52558dc313903a531756acc2246be475b20664c3a763a7e14d3e2e27b182072815f99ca85181ef3bd821632df2c518bd248c2591b39437a1aa3d593afe2cfeca4f3baacf5fe9891e36f3c15ba2fb749ef1655c83833e83c2d51b42fec751410de3455ac600bad978e595783d0aacd038302fbf479a76db3dcf7c2899ed26de3297517ee8203c4c267980c94460419b1a37e1f547b3c835821ed86cb98fae52b124e889a499b68511b703b6009bb461e659a0a1b7dbffb4cd08def19aec059c6209260eda922da22a3cc68b7fe04cea8a3cf5d7786cd3639478ca571eec32ecde2a654bfb73533a84eaa93837c74949eccb9bfd7ff977c12278ae001fee5fbce402175798283572074bc7f9c7ce8c3c69f44290f4c0a16318b9e149b2dfa5902c5222f1a487f361582c061160aceb71a414ff660db10f26a5f9b0cca672926b64ff927a51fff933986841a6cd350ebe94fab31afc8612de99831aa9c0b54e694c25f07c1f0d2d5e673f8b8bd91e5f681dd06cbaf67d637686037809e308ed1a0b4f89db2bb1f59f6244dbb79e35ff6c08ad329d624c32aa1baeb800376a46d742d51905358898890b233130722281191c6fece968d62d9a860b2e4b8f3ea58f3f1ba7df3a526c2bbc69f979007861060f9f857f91e00a6339aad890bbb81153e3ac39707b21d8be059d608db7dfac63d331a8b8e2cb878cfbda09d53feaa99d319aeeb1b437a2e5f690eb48483095df3bd2937bfc34c9bf02dde3c939c10b98fa208547b15509a7fe6ff8281703cdb44ad6a95a7a90c300634b746f223cf0132b55eadf6446ced13d66a92a3f78459841735de614f903d9921ffbaff64f40c6aef1d31e1fa93444829189129103e91b3fa75de079c8b98587f52901f4d5f93f73cc781e0c49b2d02e4951cc409a6240b5cd2b37d5b7e6c59b9d1e111c111850dca4415da6beb9c8fa4c601a00a02bbb2d7213d3e7d84211e39585c07b5300193f37f1d98c46814ca54727566862482dde160fec8c885fa8f528775af5f02521ae844b51f267cb5de6a76e8dd6992367d99f55df8f9d8313f853612c6ca76ba3dc4ca56f3db18ac069789dac873bcfb6ba62aecc32fdeacc89755d1fda3add4210ddf5bd283168cb34c35d4bcaee6424797287f0075c4849b3d21a9e7b2e56f7e6d431c869923418bd9b5e89ad4449c9cb41e2beb10bf70cb9b5e7d6cedcdea53e3b543c5ed316924b3935b2460a39168f66b10803acf590c627f0bc298315c83bd23d7c0e4f1b843f90a3316bf644355e2a606f8015922cc6c96f4b6494083510c11bf7903c94732c902b1a48ccc9da97b890830b3603f80ad5b74512c60eef880782f379bac201e9b1306928f688ede18e5cd8e1e48c950fa3a2f776c4e9e2a5744e2e5af4e515169187ef2b2d640ce5b22786a055176722094dca12dc4672ca69bf79108b5d82e959c8a1aa3b3a0965ce9eaf84ca6c0fcec549bc88844bb6a273f109ef2190b1da1db0a21768fe03c4ad9561606ba2b18fc6f8716458db8144eeb79a80389ad8770ace421349430aa11c11d5c8f7499fef74c2aa7cef087e6bd5905a4ac32f8e69a9b176ae6ccd6e7bf7dcbe2d173f4a3c9c9c7c472ba7673a5730582db6d5ea57c9f20be5ce4e109fbfe7a4224f49598be57a363c371b38dc979a92575270658537df54d99c2e8a3310dd31c71228fd5d03477510e306a7f82b4bd0b276124d83749d5855e5fbae757a680c1a4d46fdeb34d825967f99376f45a9f42d52a56c37d9b337b12796fa9d34a7a2931c751b232970bc8e21f8d535c434051830eaa88eb4b2f946dc909d95e8c45ca681cdb642e7f1255250074a2b260b418f58bd32792b2f4d372c25ff37a8e433d18ffac96864e0ebf776c5e14ac15877dae3f7610ae27f639f30109e3e59d8cdf1fb57f275f9427d658b7e37c03c6e4d9ef3fddbbcb310348c78a571e321b9117bbbe27e78d2835ce5d0c9580d1bdf92d09fd0233e26cc4ff7c344892b2385b45f90c4177a0cfe49420e31fee979420628ba9c7e498016469290362aa4ee249a7b4f380493b8cbaf3ce718cfe26a3c6baa6ae9a1579600664127cc940e9fb601ba5c7510d9845dae6913f76276c09bf277ef8f6b77a0041869b48a67167d4b7e6c91d6fcf96604042fcf17fc7b528ccf9104a224c747defa06fe0ca2a4c8d20bd3ac024d0d0a94d7231139fc0b3f9d2e5fe9dff0fced00bdb84bcedeabf2160d701cf031158fe09c50c87c06bbadc63cea620e5bc6542c964df119983f96e59cbb65e89bdefcb9ad38a893b51fe76626b474120aea037c453a49d8add7c7bdca89de81f9fcb6bbdca2f4a64d98cea511a0a11ece23682b55e7ddc33f2a79bdfa0d006c74aef596891556706ddadb5e6ba7bc5445be4f8aee9b1fb6b4aa6a9b41f5d1451cd73181c5f6cae1e794ccac23acb6095a69e40d81b18c0a06c0718b8d5a61f95215378efaa4a64e8ea1decee2189f01d92a8f028ecaa4aab5f62506c96b4cd53d09119451048e209495fe8eefcd56eb095a67751ee68b3ba3e68d49c7eedd04cea77a4b9f6481393752ba747d01a909bb61bd1e708e665801ffa4fbc6abbc5f9af727e497b752a11997cc86f1bd6989b3a0940441f1e2c27f81385a52687e88e6aa2022f6fc1ebd40e095fa2a9d065569050baebc2effae26a67c36e337992525aaa201c2618a75d2bfd2c32be0ae7b66a4e7c885db4aa31e9420957765cccf8e04ed8114e997379373304b857f7b8a49c6594443f4bfe64be0ffa65c5a1033204dc10725f54c1ff34447f4d16401781d270300faf29c3745fa76bbc4cb53f33215274d04f78653cbebaabd4e77f7b502f13b2a2758aa71223c469012c83a7eca7e0b47af092de97eebd30befb4101695b7c8c68a3e13c03705f93de36d39424c58846f4778a44f6e81ac7e550e27036fcbddc27b5bd58ab150736543cb31fa55ef1bb4e9f0e97d3afd0c5e82476806e29ed5c9375d6faf6c824b35908234f723b8dd93da3328099152fab74de836c771b3752ddbce25f6f605beed7e595f0437d345e651d18f36e96f8585aeb7ce8bb5bd6880d402c87a8cc776acfa51a6b771c67d019e3b1065abfc10394ede5e525902634dce096e488b65910af0a7549d44b2901d7051a7e4344959ba3652ec3281a36f5f79648491fb5ddac721f5112278e641d83b75b077db2583b0aa761850766f917f202753dad76dc105f884998a7ee46d314fd3ec604c55d17dee956f5535e37d9c2e8e263d0cd35ab188ff49fa0f73a5515a2e741d7ae406a9531df470331367cba512c921f6a38b0ac760ee933d71907808e919fc004d337097dd121df3c5d3acb31e489d9a7f582281832ab6d404dfe3e05cc5f2cb500162d3835ffa83ac894c0f818f0b22c9cc1666f90a06ff1a15fcfcf9fa2232fd4cfd0bce64a9ae625bbc0d00c31bdcc909265f65a7d100105a9798628469cb7252c04792362b66c8c125290ef5f906cfe6610ffe3a01545e1652709725a469a49131c008e95870915909ed3f6ca1799dec310ea40ba6b8b61faf419634ce75e74415a2925f03292d6102818a039796ebb0e5b3e740bc330360e2bf5f77534ee59edb4f88888da066ccfc384cc6a7a8638829da629e510efb77e22c71e691925be483b0211e44efe437f9de527f31984ff68af8c70ad344d32bb42e04c14e092393572544bc7c68a7547b20c2757c683c2aac4bee256ad23224f541800667b560ec3f7fe49a993d4482152790b9e8ad65ada0611d5f86c92d8475c927b4bf62806a0b5dfd29b31852e7ad53e121c845505e2e5c51b8404430519196e2ecf92ccf207a2e8327152218712186af751d9de4f67101a886a3501dd6e956b1f9c189192b85b6edf47cfc6fac6c8cdaf02730d00ccee749126b9235089fe0831d43c0ae2af7c0ad91b23b61d9fc1420f6535486aa199f934a68df61b78e5e1c4cc0316e6c5001d366d4bf2a37e970ed533f19c7654e7825ecf49382d8b621eddb723e0a3c890c4870aa9e7fa03157f38df0d733d020c2e0e5a4636b82079251e344135c47f084e7f31c79b80607322dc296668a7f9ff7265fcfe02d71ddc355caf0f95c527b754a9ce68f4755ba235b46356546be499e72dbbab85350f91b902796f27c62e8f3140bf1f065af8b22bf6cf1bdbe34abb9297a502b105d6699d3891dfd93247fcea8cbcf4fbe588fdc41c9e322638dca28c771e29b3e61d2bf4d2bd3d44fd175e4b5302dbc45ed9fcf041344d1776985c960b5b5eb711a04e3b10b586936deb4f0c9457125d662698d3110f6296682b0d00312e4cff72879cd3cab7a30f5160eb420fddc3e5820295a754d2c2b59667c6a94ed3ce0f4e91dbae54f822fb738767e5f92e9915abc75eea0aa3f08f8c3d6fffaef78f141b8a64f00c71a7e3ecbaf805319db2e502d4fc71f68a982aabb73b5819c9d8300e1da39c17a6ff3a64106ba7a9b53619b692b6c4d7fc3e79ad791e76bfea9488335cbee8095051a47d49ad41607f06c3ea4d56dac2af71105519a6c0ff8f73bb3b3fff34bc148c3fb66d6392cc0d24f95be30018947c70099bddc1b10594bb354e5335e05ee65022410c4f36a085eabe41cb3665d6c1d05ab129e8eb97bbef66143f0b3e0fa41ce962e1dd3d2e79d8e0b4bcd0e926d8bbbede0e0ec7f6788cdc2b4c6a060379fbaf8e948304253ac52d9fccecefb00039ccd27ffa2493d4472d5a7a69fe655e37efef1aa8808020e0543fb79be52a67b2d4ec4e3677c3e02e82d2a32d26e44abbbed3090706d5be3aee7e00b880d402b045b6b09b8a99333b881028502ac06e7712d78c8b81a2fdd43aaa65a1b90b93ac063e91d68a6db7ef7d8ada54eac8ef04c0c586e91681c5f31a2bcb48005a518107aa0e400e16ade3ce8d619eb463332e42a014d9d186f172d0ad68b25460db93d32010e36f36f47b54d1661dfcbc63a24993dd7c3b8550fa8f1e04bc8da975e90dfc0a4e2bc1c964d43c1a9ee1fc25227245e1107696224c0b8f1a8faa12fd25e13d9138eccbef304a27f35ee924592852fbe8227aee7d1972f1493ddc849456c4c56ee34db1607450b92cf60201213b701ee7db226ecb011823266bbcf5fe613c0e73efc9c8cfbc6da5923eb88891a69869755d86d2af5f7a261c4d9b445fd614e5887f241a3295891f14a4f80c3d7529ca96e7772603275df7dd1c22b467c12ac737434581a3acbc3f4f72edca256992f5ef082863c7831baae945529694dfe33ad6e57dd1203fd5ab7f196e6aa3b765bed91e4053b6791a192d4a97f0bce878da42578b97f9204cd4ff449bd607c6fd0bc45f6b80241662dcd4be9efb32a25ffee46fd7a99ec2e535248d624b7d1caeda99a5ad3375b5ae5435b8dfb4e604176f3cfd25b61f02155d6649984b765cff557a4ee50ce682d1e3b73bad1330d3748671447d200357022f5a9d7c319025a9c1c2a3530484d9e94cc13d1ef46b159c5ae301c6368cb6a1508a723a5b0013bf3699d72003bb4a5c4dc5bd54a81de3d585370e8d3d6538c9c1baca79300c0ddabd4932d71f85ee8f609b28d20dcb65d53e186abea1aba49baf1130eb759029709ff92f0008fe9ce280a96f1f276b8e2f2866692d22f203634d9c554164fbae3b181fc293c65d6be4cc494627827f279e084593425b3d9aad6972c68df2e796caeeb7b4d14a750a458f38e290413e2effdaca2cfefaf910c7a6a748db4be991820cb5d26fa913dcad832c5ec2d38708abbfb3d96ffa62dd36059ebcb52e77fd3991cd6efd0cd05f0fe29a42faa20e64ec6686e515f08202f6b68dd34359f9b6c98850d2a99147a55f04f8ac461ddbb0b87bc9246de81f7159defc3cf9518ecebe656690fbc150223d08f9b004a05688a3ad73ec6c56dfe1bfd8919ce08c99c9e7b012819fcb1f720ffb4849a4e318a78e831a959f1a3ef6c121f05143770b5d6f30734e98bd88da40680762f6cb68be8f24b7406eb1ac8d825467b5580b5ab78f89de4863d71d836e7c6d5a1bb26d3b184208547259b25cf115a55fd3d5340def35180e0ffec3ecd9f5cdc1bd5b663fdfde1f6da88356674e443ff71b2885f2f73d92840e155a0baf889af39973968f3527b5be347bba5726fdef18e4c385ffeab8205b1dc9be96090aeb65756d8ddab9de804d53762fbf7b1242099ae0bfaaf38875706628d185bc755016a7fdb548f90a483903b99cef6383654556126eca7cf792dbf7fb98552ed833faf92c96977646de9455ff5cd34b31b6215255e1d7f59cea75727a599269f007f47933ef69831cd621cb44cdb03354c869d89f78bbf21323898f965842089f770efa228135bd8d49116fd94c1d77e8165fb11821c544575903973978b6af6130265bba9c75dae83b2e3e787935b5355b738faccfa7c762c5c913d5f1cde3188472914a93ebf9a9a627ba9ce675bda64e5d7a82fbf70d3b5b8cf0ae4ced9bd979857d65f1aa0d42025bbc539f5f14cb8cff54b061cd09f414f9ee98e6f9432dd3239b72f394dbfdfde6a049176c4b259f8a1de76d2bfacaf842b8967c4066e0fd18b825f1858d78633ed8bcb27f4e8b80e939035446f650dfd62cbd2500bbcae18f6393ada03163d76ecf32e359880670bd8a2254fa89ceafa4542a1b600b008e71100152f51028203c37739a1bdfff07d395cffb1cbea4ca76a6068b95a0d189d6b8525a7fcc471001e5485aa865293eb0f131b5d0ed81474e33517c4c5f933253f2df7dc80d44d51bf23b1e178719d07bef663d2604d85cd91e7a8713c4252f32106d8eeb2000fae5bf20628ec68c80255312f97f901cad8d1e269c61dbd706aaa9aceab4a7cbe4efe418853de57a2fcf78a91e3c7a0c4cc3cff63cdc570ae5cb7f802c60a6855e0228582777de0505c4ca56536450a8566d6d42da993cb80310e487de3660ec3f171c073e0ff7f4ea60e38d82d8a2486d229dac96a18c610edf83f88ebb9e8ea8d18a75ca39f908e27f0e514525e37351c8144e4063cf2f77cf1c0c5b63cc5d01ab15826393719ed22d35b223e803d00d4d3c658804bcb47c84b35d3a217a9e4caeffeee568a759a32b7c811b03345387a3b129f785cf1dd225ed14b504a810e0e2cdd0c5c1034b2aea9edc14b2d8c7c947ae332ba86efa241fb2d42684a4b3eb9e0128b055e1e59c5225e8498cac97257eb43232b3dcd85c434dc4f326f55c64ca064145faaf9ab8f099deddc835d68472652a60ea8adca1ff86b8b801be52a601ae529b0e17b7ad95ee789501988e0a95e61261298ce9bd80ae841ba09bb807f61d7bf948960b138d65548e9442f2c150fa2904f72688324f9f6c69d82761922d416f360cfd491db3188314bc06a62153e56c5752b3a1c3f44f08fda6c024a181d478357513c8603a152785b8b716b454c4b4ceddc8e4c12232381e57493b34847c9a40582d354e3066b94def9bb7fdc0b480daa2810bf3f459dd9855dd5d3fd5cbd3f3e3a2d1ac790e737e0f03fbec5842b124788a57097c2fcd23647246d8159270992e650dcb0d03d9687b8dfc2fb506e0f16805ae84e7f970ea69b72b3dd5f21e272a148798a2db3aea8ce3567b1d5224d348536851e74504e05f3c41a63cb3476c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
