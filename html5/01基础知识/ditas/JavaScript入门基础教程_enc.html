<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e6c34f68cdfe7e718b070a4b38ac7badfb4275ae68e1815d1354cd7412d1acb55c3923c1a5b4c6951de8f1ca6f10a5c2a567028a1044aded8b70db908864171ded751ecb3472789c536e7a7b10a42aa33510ffd610a65a4c5528989e0fd1618f6cc32128e5d307ae907b96f281c309639b355764bfa554605b95e5b4ea7085babbfc676b69af3d039ada45d8a8d53e92d69945f2266dbf09d453b1754779218cb4344aab37693fe6e1eb9d3a01e067f148ac25cc46b4ce684ed78e84152a20640ff821cef34a398aecb884d91012b5cc11d41b2012e35de552304cf310f262656c06406b6d7350b44c72f8e621d2adc1537364f1b192a0477fc11e9ffb3ed63e9466fc3805bb49bb5ec2607f29fa8cc679d649b81ba60e9f99a6927249248cbe5c969dcf5a2c2b8fd30deaa95c2766ee9ec8649260e3d30253ce0634d1be6dc18c6ae4cf61f05652aeb50ea2c14764f912594976faf2708645b6cd1bb10d9816df2bd25d3dd801613208702970ac0e31255fc46931bb80d7acf4ba86764b62a05a27f071be12182edc46ab9e619c8f40d2f8701696e6d389e1537cddca893d399ddd81de8cd206ad8820680705dc6e7a4f5aea23f3cfaa00b97f0ec07febe91a5298b6829e54095f64c919b1fe8713825e0d09dd9c81a697b8c8b7695604d91e444ce075a1121e879d468dbeaa4262890d05c164c7c03f0014b6f213fbaa358f791bf552b848d3f7967d4913d9e316b2f8844fc59e898db6d52fd49d8fcb2f21f1c7fbfc5b55274c0270058d0489ee1725a26a31d2ad9c1629fa8c52e0e1ab62b204013851d18ac1e6f4e715a81f6ee63c9f3998468b78c9addcd7567c9203e1185b7840a805c9dbd84e45eba81575c03aa9b99544ce213f6293b07f39c15036e25b272e1948dac1b2dabeadf7b1eaf1af652a406986fe2c04db948949e0f6c7391b7088ef60da59a6b6c5d4a4abe1b04bbf294f8425c625c602a3d340123979abfda37534596e32355306719f291a74cf87dff56ec03e2cf39affc25592e6b1a871e62b421ca8033ff3cb3ef4c64a370f1f65ae08e8b7aefba4aac46538ee06c8d6eef6e83faf75f2c259ab28d8a96e867e4e1d7c421237d5d1c9c53ac6f3bdfb265da8d8327f4c27e133021a12f65af0209602bc37d6b1afe055523a76a74c69ba3281b09356b82e0fda328defdaa1b86a794dc7a749b55dcaa35b4d762eca9b77f418cc0463b136a2cd5f51347bde8fdaf854196e5b61cb58f8835da8e222e27e8c91b6cb59e836cc5dd03f18aa6e71a4fbdea31a55cebb3658eb227e7ce0eb90c9f6496cd2c008f619dbf4e0486856a42c4bfe6a62f3756c0092c41536b3c5c01e2adcf6bb599b9b8ecdc707bfc90567a02a59b29cd769f65ae35f20ce2200794ab699a756576cf71c78ea5f7320a545c7cdaee87eb4bb4c2fe9755842072b22543645480d91142100044e2c6e7621ac946ff24b4eabda8c67d01cc672573435635446fd35cfcee77a596e7edb64894e86c40abe93e36a38e0db7638f84994cf480ad9fa715ff7e7c103795d8eda0e3ae2d87dd41245f36d44d778489c68d12a56082e9e6c4edc707326b8c565d93b75ba0c7b4365afa5876a7b5f36545a9c52e6cb8cbb37ad46113b6fa4747c253b06cb014483e766c454915f408e8d57374d3667fedcb9089d8b9364445c559a05182fde8e72bf784f85989674deba11968b7b046bf1758b6bcf36b99bac9a9984354f61c1c3fceb66789c7d5d7a871f3ccfb4ea1fd44e7c624fbe8d9c7d13171b7acc0ba312017314b95117b1879b3da9b8b0e77ba997a2093cdb4a2e9d35175a88d8fcefd1bbd4a4d0fcb3745c09966ae3dddb95cdff4f92f13a8d1dcd37ae6f688ca55b1277bc6145cf2096ca1273887b1e81a8b94e190d964b70723a9ced4e3f61d42b271827037ffd4ddb02dd2a73d18e9e365fbf1b169948990ce0278ce3c0f733da523bd2d04040b7dbe1b53111c79e9cb420776c8ed872c97b7fd6728a6b9a4114f3797906c13a087e1090544616e3ef36122aea27fcd951532a6f9a546760071fe930682acf83ce91a88d2d1b3112aab6dda4c2dc1c539a802f2c7b7c65ecddd0a7aa8b83b83bbe6a031c0b917102919027a7f8cea415e9731842254efb8453b937716080fbede7f94e84bf47c7ef3c061bce1154b5e6f616235990dae5b7094e061f63e5db0eb48d5116dee9868a739199575a0a5ebab3ebca2e3101d9e13d68a11d3d9274cb559942ca004adb1320fc153453a50fdfa95c7972dbb4ed67b9e8a4dcad25745ac52ec5f7a3a27b31c0de374577847b0c54d7399854e73a940f2e326a2903b256e3c01d8c2e7a67a9f749798a5bf6305b55e60030be026abc3563141f81a43513a3014738bf7318911ecd91a64849d670c297ca6d88bec7056f2aac4d69efc428225ceb4d034f09bac07d4df860545fca00c695078694d1691892ab75b805c7462f02983e2b87988d362f477839408892ce6b19e5004246301cee8d73a015c38f7b18caa8e971b961056884de7193959675243c4962333f196a6df193b367f91ce4b2212224af34cac959459dd090b951aadc20ffb191e18491ecacfccb507a08c964bad791237588d7aff5a041d261d8918e4f9a6f0bb5833e0d0a46c90070bce8372377fdaa3355e7d008b215cad01bae3126ccfda225a67edba878ecc4b37b328b1fa6ba3075ea89253717fe7e19c565bf1daf7fd167ae376cf27a2e36dd96fb27c92964a88b4dc5d338627463af352f118c31dfad59eadbf02de24fda624ca2252e44b23aa4e9796da5cdcbe91642cb693b23277eeaadec73ca179f55671e8d4309d8ae2d8275559e07bd3d292e24e2fe89749a15b97041fa76453416606ce2706932baa4131cd0fe971c8f341129adc03e96bceb434900c3495aa31d6d22cc9868640a1e2b7845f5b16cdf65bf7b82f615f66de38922c8e818c02f4a69bb80e4f2127f8734c7a1874dc487d24ac16d17ea96cfca965a868fac804d48b258d4bda1bb55b361f3ec9033577b12b021f01c20fb46ecf31ec1f4f778a4f8c0ec249bb833049be079dd615570a29864431cc495ab64789dd0ee2d07b95003ad5c0bc0ce68ecbb6c4f3a9599d63c1642f31c372a6c3669c500698730093e86a84f07431635636ee290154978045adbb0cf4246bad737612874155045c98bbbb6083093efa3dec083577139673b69e7994193dabd526caa2a9bf458561223287356f563b28ae4687344947ca87367f7735c01ca6acb14c648114d528082b397d1f316454f33708c615e3fc590b6750391fb67a4f82f020db2574d79f1211935bed2f1f91ecde8415c24d54be27ae77fc58843dcb90c177980457c34255e375e8dbea2cad0ccf929a9a12ce621c64842a1c1fad8877a818185a4e06f00520366b37b17ace15488870149be6b9a068c6be0051f959efe54b59275fbcf872d0ba17337d8ef6bbebc518af4191cfebcdbced030a64ebfc5b86dfbd7bbe482b6b3834711817db1a0c3abadcc23596c36b73fb25176bb74093f643e76fb5273788726bfaa80eb652b95f5ffe5209262e2f3d93028003d551888113ab39e5d3a41df8d0e5000d9db341a2933e7dd15e3a445c485f54bff509c0b9623e5b658f1821c087a3cbfdc00e34e0b1f9c0ea5fde6d902632aa0569be4552fefa637f81c6de89348ab5dd3ab3fd054d93a32828bde506433d3ecb1a888b9b64e748f89c0fea206c22a9237e57629f87dee260237b900f1a51dc30f2d846b01869a18480ed58fb70475bd01191c9ddbb6550d9bbf5eff9a1ebb576abd690162d92a56d02e9969fad6a580d6de1c93f8ae29bd0af218b3bc03450c8341b73e6b7f514dbd5152f4863c54e858ebe0d16e51d658f832d5631bc5a4b1022b0645e0719d586e5781ee40fa7c8c69c22efe9e5799645d073ba820ae87b0849c5bc8bca6696394655e8295a1d9ff723bb8db37fc13d29f4c09d65cb70576d78bb8799db9ec7c4c78e5c45cdb03240af1d588d22120827a883d5899cafc6998604aedbf61df15bf3ce42785ebf72b76992d150eac1f39ac7cb7235b1e7b2e7238ea9c4d80eda0b70a733e6d71c59d1f38537ed0e28dccee97df6e36f1064bdd24fa373a36a300a7ab9eed22911832118252809b2e8642e696175e183eda011ef606f3a0113b158f60bb4c98dcb6dbdf6b323acfd687502ca7d6bfd68d5f61cd0fd03dfc2138b9d2742917270916ded9e22b01ec0ead0320eb4bed2eeecac43c378b98a2241c3604f89ae9265d2e99c610505aa3b187e575af56488e03503394d0916240877ac0ac306e24810686a0ebf7db652bb93736d8261067dffaddf2ced2864adbb628b26ad045b7f8b1b2472518594b6fcf8109eea0393cf5f613a99410bb925df4b62aee8986b8f04aab18382a0949cd5a49f657781a4f1895206f04a6d1be380cec2f03754e86dc6d6a64db2fe189d324cb5feecb4764f0585fd7b1273808ee364f4381271d574fb69dfcb7a510946716afb682184e30d9da517885ccd65fbcf5741c6248aecd5a228d417777bb573eb071184a29506861c23605983b5a05751be3b57631b9e0846d1f1386b99bcad240665f31b40413a8d6b5d24b44dbb7ae4dc623e89d467331634bdc998574b706112a2205cace0c1312ae161ea02c2a62e4e419792bc7dce7c771eb340c5592e0f904725c4b9e62c45a2806c35e17fec102fec692f693616a28def68583f6355ba13ec7e1f1d9aa2506a9e9bf4b790099445e8f733716fc0c5f3ddda3711e116ec7b6f05b20d299a3d36c89511bd029b5bbf2848dff30c629bcc8a922bfbd83d3df80d4143e101d683075e571f2caaf0dedf2e979c943121dd321f1ebf1394f6e122b36c1b9ca04e8ff77bfde0bec552d5e6905e2766f4cee7e8d2aea15a3dfc265d2f3ac308a6f888d047ae272b191deb5b287a6f0adc0e68e139fce3e19a8100b9c126b8bd1b542786fae56febbaeb85e007a44b0a4ca0195b07c49557e0c2ecab15625b6f081de2e08e14578f487354db33f18bde19eea1e913a0b3bf73120642b47d29ff870e0126abde752ff7a7cd03fe6d0cf0725fff8409ea958a97fa46d6842e925c320567b428ad16dca57eadb43eecb721492ea7eb4b859616c0dfad7ce21502f412accd47f00e0c569db7f8044d2a34f6e8aba9bf52a33b70300181664cefddb28d60f84a7e15a8737faca9c366ef1a82ed936b1a13296f232e66c47f631a7bb7619d6577dac50bc49e2762077d8b3853bd66341681c215d999689e082ad2499481c3faf8ffe5fbe75e1ee7ede1ba14e9ddb217af0fc193858ce7c09e3955b9fa4e01059030479aa92a1fddef23ac098f136a2bf6ec3a89a37d86ea4d31397d3ef8fb59cbff4ff8f3ab0d3400589958dc5e6fb737d1a68483c73f1a8be31619ce86a2c3ef1191aa48ffecaf6915610f814425cebfff5be34c411a49b9ca55fb48b3ad9b0c225975c21b89a35186fa0cfeb64d4b1f442d8b314e63da39ffe8b8a821bc88cfb1f39546e387fe136baf67a7c86e5f8d487e717bfaf7624eb6af761db2dcd92d1c49f5b091881d3e3c380441911c26c1583219a455f0c62e395732ab39d072b3499294b0010551f77fbb6e9c3876edbf8a4ae66a1b0c05336015728be36436beae2e444eacb4efba294f7218b8d543088ac2667459cd4d2136ed4375737c05d248f50787b8e4b8ce6cf7b9bf71c57ce9997125710b3f574cbc569a7e61f66555324f16c5beef7cd7178571febc19fdbdd5b3cf16d17cf1906b9461d91ea92d86eeb1e20dadf29c7c475a2bd2a84e0ad1e49483187f1c8136700d696625170e8766ecc8fda56b1d269f47b122b25a6a0c6d46438257d061556af1a76041efb8aa1c061062a8207140c4465f959921851aee02c3ac9506845bf3dd179e99439e0127d52908dfdd8e4f241a95e84895a6cbb286d94da1f4720cee0914acb865ad54f2e5a41bdd4a2d057dbaf6e1e63bc28fee47bd703bcecefd45b4b130085cb6490eea7cd4fef12f576b66f77d42a61708e0a02adee067253357c02e2644adc9f8532bf9745372b0b24459edb250796dbc24c1fc9b4a0c79f657d2ca9d2f4022eca5a42bd119f03f94017ec3a80adf3a40140f4e1ac2d4571b4549ff998ef311603bb22298293626b52802b951b850ac6836ec9038198e648e620ffa266f7aec5ce1b888b53e9707da872f2e0b035c50fba40752ff7ca01cd06c58b2beb55013e40a13045060f2280b73f3f25a8ed80cb44b8c2cff50b934b9cf0393b126e73a4fb019d199f4f6281614ee621ee8354c2c8fa5d95f9826fcf6100f52b58134714a0582796f4f9e1cacf80650649d60dad6e36f9f50146fae44b719b0796c41296eb201393123d4625a3f2989317727b0862a9607b5cbe582be0ad93a9c86e50e5afbd80ffb5b07fd922c289dbfa7914ef335b8c540f7d802cb5d7d50bb9e6283d3dd890bd705c84f9334ae2c000aba423f6ae8dd39e023654e09433c73c68b827550dc599fa915139104d65581f0749cb5069b1bac327e6ddd23cbff1b9a45bc0029bc2d439dfdbda2e11cbfbabc19c7bbc61c6fa171fac606c2a8adf4836805ec5dafc7a3e5da4be282ceb7a847d8bac5870694cd4f5ea8b05860f817f6d566be9cb822857c9c67eb15c3df9d71c89decdb9dadbf4f63e75fadc34890ed23f7d2add2de0002d6523b590090591fa144a49ad27c6013e5e7e96ee74fcf7a59ea998421c13e727e1c752e72afe0c4f236fb8798d16fdded844531555349780a61dd5928fb16ccf0382f5cb9a72d5ede4013ba0f96c2af94ae4fc7f29d1ffd59cb3ea8fc68cab5af7d7faa4243b6bd96021b2709f59312c1afe9ab95e021420bc98dccb428c396f2bc784fc7208dc8e307e387a8542b529466dacfa0d066231976c0dbb90d60e0030c7cf839fdbad9a0bcf10fc87be06eae94bbaf819cd668c1085cecf90aa3bfb7a2f2a17fe0c2f2c28e59a4d791beaf30c1f8452a3206708d9a3a68aaa66047d35528769849a9052f4054b35e4d985935e0a9eea3e8e423b52c47a04df4ae0bc613f4c22dc3b59b0ddfe2230e8f5e5432d07ea42a7b71e69212b7694cb2912248f3d68f68c237589adc274f9d76e88491905359f8c0ecf33746be02fd99523de7bb823f0b599fba15736564dd051da20d71f54cfc10f6bb2e1e3a87ff1c598af20f607fe196bfdf4abb4c55f2a9a603dcd83ec4ceac8c41a274ed527763b9de569ea9b7ea24b1f3abd1f547d50637484fb887f0869497847efaaa23ebff7a8713fb5bd748c583e78ef9671fd47e3a9052d397e43973f365c40e3273514bc89d903f5be958587ad799905cdf1d3d3f4084fb781a6afaac033978c0a1c954448dd96e491cfbb6577bb21a1934e2ad251bedb31b3a02dceb990b6502094cd1e97defccfe7bc3c4354233330f9f6da9e6b3eb8746398d99f35fc6112385c64cee73da7f6f7caf424434578729a9ec4e21c19366f48fc65687369424af8e2243df352ce88fc86839d251572bb05eb5dc891464425018ac9279287b0891ba0bf4dad07390d35cb02e178d36754f65f7bae0a4891a40183d5451b2b658b8983b3f07abec0e95a41c03abed8a0952e9b2d2969d38184918ccaa96414ff4bb25d12394734c5ee68588289ae3e27fc50a4eaeb92907e425f106777bf09fdf528989a0c050bb0c51774130c73bb892017483a5074b1adc02ffe7648faa80ad68ea7dc67b7b2854247b05e01c6e4b2d36fc8d2aa76885d3181a29075c51750f331e6541c1055bc6db882d167f7a34c37cc7061dd83b4ba9be2cd496460b253f39dc186ec26b22766b12b6ba071d07d7baf20ef6c56f87094f9271b32b314e52a10b0bc2e0062f7acec209a61fa4840d223ff0511b0fc3117d0403ca9fd787f60c6635b9a5510e1168a696fb1f4a7064062c25edb0f1469ac54373ec96607c48f852af53b4b222355cd512bd6a7f1cd2a9e17e8600463b1d588b1ed17b495e486bd85ea22cf47b060bc886ce40bc405d73227eb62d612f3949f4b5b1305303f3866c479eff2bd606a579e58e2f2ad754441915dd1f5302146c496d5bdc653e0d24cd39534f2c8924b1c7f2600569179d541bd878b4f6d6af2288dcb7bc68460fec7fa71bbaa1276e74a6a0acf5a6eea0bddec0b31032c1ec18226a6aac2ddc088452c6a73479dbe32fd8fd0cac1444f0d73fe80729225ad3dbb0924051f77886aea0bcdef76f6a6f6c627ed97cb1aab945e9ebd43797db7b64e620492d969cb49d7b13006b67a2a688ce6e89c5c883b7f4c0a81bb18a03c2370ad2a5643c977324fedaefe389cb7c1abbca5a9f91f1d252ef0b47b28f5c2dd08ed305f6602c9c54e762589109f39eba60b79b0e6c45c350bcc424d080aeae35eb2083dfc354bff0f40497caecc6e8c0130bea6c9698ee1a7e926b212e59df427152635c7c9ff4499e8765a8bc82b41d69ec150a78571ec960d173f665b43dc673d317600aa9bff2dd099a6a7882cdd6aa2b29482970b8efdff0a62cd42ebd79596fc86c834d5093d801b3dcbabb27b1d55a6d111f7ab661a5dfc120f618ee1f3868eac94e23cc07b48cb8b9a7715b5cfe8e94689327ad6d7754529db4891c9a8317460f7d41340d3228182caf95ca9e7ceb14296cd0aa671dd8abb35aae7695d31662bf6939980430f9ce98d566e8c3b385063569f5c023b70c78e7297032882f169944bb2d44886a481e90dbb132d89fd12307abdae5c6fffab05a3a187dfde981f7a7575d8f98be21e84544e8e7325ac009c256b480ecb9443f521da3f46dc9045e4f11f6186da592455cdbd4f45ca40a46d05eafb8894b8bc50341ce3188cbe6c33e830c2af247264f724d71978d22d2b91fb6432e679917de9a30f4d84951b1e7d1b01e0381fe83192bf45f2bdfaa836374dab676e9ddcf2b21140822ff57bb110dee957098d6bc1e0d02e114fe94ab838f232dc0159f7c06a54636c0659bdf57789e8ce2898baf5079125b96e32eed59773e947741f38a3fda39b033301c0bbce5f727e240041c04db7ecd6dfb187b57e002370a19557cf63e8b0fcbb27a206764c3480a3c62fbb79d1a6601cb1ed40b27993469d0300b7ecdc86003390e73a27e7b467f6e04788efd74c0437b664608ed5416bb9c340f4db859aec97a2ddb22f906d4ba634220e492d670a0bd68964c3f1d940f30aa636ab525c054089251b5b3be0dd82ccbae717bceb5bc14ca332f3df8cfdd9e1e3e4d70101896c476bc33a3e6900090c97b20023b45c7bb627111d0eef34971a26cae97e42fc0af36344d45264f9f9a075e838230f4fef611796abdc97a14a532869ffa51560bdd12ba4d1960ccc14ec921f9aa7ddbd36c56729d0118c59d5e7c14e2251a916893e1ffa1e0efef38f1fd5c1a7086e62a4f328395e5aa6dd724b6269576aa1797c3d71b6c08e0050dc09c343b0f4ff973240a7590c793dc8cbbe1c5476b588830d26cd7ac4fb9fe5f5a63d24c3da23b49487f55252e54cbc4a460b941cc758002750d4052acf85cbe28b437efb527cbee283422f44012dd71e50797ceb93acb8be70c7827c70a7ab41247b2224481816bfe30366013359edc698fa4b87ad37c56b8be8ee28828a4c0c84afb702a229b8c7987fee8ef0396b4f733930187f1b27bdebd70599213096ce511b6da040dde362a6f65bdacf49c11db963bb4f04c407f91d205e8c7ce1f6acfa43455495c4a6537b728b73046d52c79473e094aa01809fffc3c683ddf1ab01c3f012cd1868c962caeef94104098fccdd68ae4ffd659ab1bb3c998fe4142b30f9699064c81c83180213629cec0fa11347269752f6256d00ce6044cbd572fb86f750e488a4df3e445e030c2598cb1027b260040e40b75fb452d66e69f35001e554891e5f8da88b3864de359d44c69335ab652bb68746c9642c9ab83339988551e5fc7ded3b39108a00e2d9ed4ce611d455a7f3bd1c166a333f1fa8b2bb70c0920e1771b5094f5e80c8d5ca3e81de977fceb19f9cde7d5b4be7508d4e8854a1ff0f95f8377e8e75b5f97e3a3d0d2a1b59ceaaa0b686429b699cc190e560c97df8a5937d553fe5ad8db0db729211642366ac013576cb41c523946113642ac7e43a4dc7ce43ccdb9c601d62498dc1766b58227756b5b8734aa0782b216cadda282037257059f1015e5fe4f46b66e848405b693642ffe04063cb1dc249b72c802e118ec11792dac12185bf808095738e059ca176e91194fb2867a9c910d9a556ffe856a5455940aac95f78531661fcd100fc708f4d986ad7d35bd88b53a09abedc4c77191b82030ce9d694792b0c0aac886905b32a1889fb051c695999e2a7c86b9c32f4e99315d682964a5ce29c66694eb1883ee4c3ffaa876cf8af5a10548601c8dd320048fff01624b720c97f3199ed60491d45372fb4053e7191b22eee2eba267097fef98d9bcadfd0353da181568ba9d55d7b32d4db23d4f5ad9c9c0d9547a93baea70fee4456b15b17b8946a34f0d8d742e8f0da47bfe10092b8bb26370ce547a00e602550ffb73610a5fd3d9d5cad8201f20096b6210fd592eea61ec963659619a624f0a15402ce28cdf146d36dcd6a3d064a0862f30ccfefc55606de594937f711f61a3530bb652b47c9fa04dc845955f1b11c47ecd1fd33a661b2c5632d4d7a7e573fa558b73c43f96904ccbde5f937336be9523b486cb933bde7ab6d34704a86e4e4608fa2194d35f69f95fb157089844533d38a98227f8bfa8a5ce464e1bb8ab2fe505d4db3ede518e05abce90fade13699f36b3be407db43b4cd3284e5292604d489f48f973412a71323463a9a1c0cc488c1348a0afca4053834c3e6bb3a471883b0839539a2776c0e7d6130c026d023145d2d7b1635ed7bd706fab72db76b2461267a5a5fbce4711f6c631f0d319c58c6652d42b6078f8bdbb813067d97efe9e414ac13071cf809685b3bbb6af2a710f8c85cde3625167d714888b779e41598d205bbd741d6021ea7772a91a2992abf5c57e50379e977d3b294d59c86bc667de98df31cf9b81810b5217ed65cbd51abdfbc4cb42042dfd2192a43c8404c835e67b544cf90308f3c1c5727d74e94b7d09f354f8bf3f757ad955b21afc2f7fe99db923f730f80ab93205d0643973fe8edede6c54a73866c454cd6a1f4bd3f836b8b33336016ef2cb7dbd5896b0065630b91c932cff4f95e8692dc03a6b506c391d4baee7e3461889d3164ae999cd79812e71a25b822e847ad5afe7037a5dd361ba9ef4f50a99494b720ee335bc941754d321bc25837ef604653fdbfc6ea56d10be75c53802ebe3c9060ca5e8d80822dbeeb351d7aebc1fd28786bf5e199abb9e828c94bbfd7fd72a5dd999e30bdb57289b6af4267120a0fe71a6799a74fd24b1ec7c55fac6cffb52cbbdd2adb423470f37ed5566c24f45288f3d3a7e8f4e2b272063ca36b3612e01823eec30926384c9d7f70a8946ea2f463484c6471747828fa6ead6ca0f26722bd01a6f65b8e63f9729018c9dd514786f99b851fd8e8c86575e3271f7e789adfd5527d8c5dd7dbe44d9ade787280734eb2d37162eb1e0d58ec4b72e306c45413aa5629b3721e625ee84047322df8581514e2b10ba87b8901d83ca4e394ea8452539b6f8a819bead6a2e8db649e2aa1802a37f2bfeffe14fb53fd758db8992ce8f8a497fa26e35a8c4a6a4ccffcea49c46dcfcf04ffee2c0dece669c00c025b88b9c8cf1f18d5c6bad19d52c84ab78a52b6f91f64cbf3dd4311e84bf91bc3aa06dfbfa957fdd6dfb97d3971cfd341c4050fb114489f2a37fadeda5d100d8afef992cba2395a5eb18c60ac355ee18d5471b102263cd548da65f23cf85983837cd18fd7b272bbf8cf98d62a564b1283d3a783c3477db180974ec9aca6105cb44e925f46d63b3e66b5b1fc371ae80e71959c8482b44718f118323d1d1d7c0a165246420e42b7e3eb85a1a88d06d63adf977eeeb91fe643d4c3038b06a35794ca6d72e10d5a92216953eb94a6fa4be4e7bb916e0fc9d4eeb20e592db87e88597f4004819763eec61492eece0876bac8ed6541166df37d00285034a2d5cbf1da8d603df10c476c2535863730cf27fbca1d5af29c65b9662bf0202832b515aaf0a91cc94eccd930cf7591f77c57e3c4b408223801e833196256cf0aeb8fcc8776cc1498fd4cd4926c06727f652173bf34e658f3d8b8ed53e1664f5afe86e3cb6384ef5f6eee12c4c7f62d0b1c092144e3ee50701e353965b82ce82aaf688727bdba1e978729f87f735270d9a21d3a382c025457912030f43b37c2d32d8946971b9030dfb864b771cc7ca105f0ef58be5e8833234405c06a6bd50d5c8ec99b11ef548dbb0edabb7536ac2632da01586afdfb6f948ed5d003dcdb51af569c9d5e1adac0828c58bb16f48bd6098d34ed16604b8b72eb75757287544426e3a72051c8c0c51b6688c09f27ac5cd933d71d897b241af80f877255464ef44234032aae269d5e33d49b1efa9b3a78bc14b0993eea1f7338be1d6ed00d2121fc99eeb18bbbaceea4b788e3e537a82db2ca6d5ce7897b8e7afe2187d04a60f27af4fb7de34e5c530b8acecd4aa0a0f50c4a42b41e95da9f0d539043394e766cc8cb61d8c72910a7b9665aaf9e1d2b59c41180879ebdb804bdb2010a4d0b8fcb3ba41a2c00ce1450ff9279da523bd930c9f16144f25f36314471552177cc88f61b0699261f2725dab4705fbbf3051bb7a68716d2f2567e237c7358637d30a27e2c078bf5f9e6dbeac3d653d40211adb2b7bda6706269e831ccb50d994cc2d8b7d764b432a1f175ade87de691354a0d0be3b9c604af47fe710ee1b767069c9ea7a9ebf3a4db784bd92d17dda7184bb85df44b3a838d946476c05f81cac316db817bff1d353a6f4cd8b02575a09340b573296472a45cdaed8e68ddf0df0b2969058cc8a758939095452b4b7fe860401c093f214ce6fdf6bff08890584e7934f8b4b83e051d75abfa8b70c1f085b7cc882388bd60b9189f42478aa60b4b42621da195dad11b6a0db2f1d30214fcc274fabd245fa25fa9f04185252827ec36de07093b3b3f9c834a2a118ed6f9f8720e82a4465d403e6ca697d79c06f0db524a47eaf33d01a33b75c9805a4db373df55c1b3218cbcfd28b54b2468d9530076f6cc97e8366dcfeea04c582efd03b63d9463ea21b3df7a7294f4a480347888c65274cbd75f77a4d7d8d49607d73af9d45f14bade869861277c7f6b26d68f9abec76f78fb243319ad4b7322a695142feed43b8455227f1664657090fb8c8bf6f493c56698dd6705fcfc618bcd3f12d2da4edd7570056635caac34fda636a05b77f63e102322c8fe6faf0721efe24cbc0af0b501bf6991021f69170d96f7108a8c771ab47ef13a9d3e4c654236a9557d67f9a9ab8ddda7afe56ced9e65989351278e4f2e2f6a0bc3d2bc7572c581ed03c01836f0ce313ac6f025f42b01fdddaf50526f6c1fed1ee5b49239f94122aeb14d006c045b7aec9bbdc2d28d2ea527655d6c683ddcae49132606349aa6aa7a0aa1b42f2d73e7afd1907d0830a6245141f0908f762171e34b7f97a85e53df6b141b022acfaacd67a137d409ad54836dbb2d1b3120a35a0cd324641a69e17c56d23376ec3733f5a8c6a02613cf1e15032993fc82ef372c04d95d6dd596d5397059ef2b7080e7100f46ca9c3812ae892a70f1d2bd85080887fc62fb7ad176ef6586843fa5c87ad48ab9662c60d496a55b9d81fa0d38ab66a5dfa4d3b045b01bd4a886e88402f7f1be5cd2b88fc7d019c14b4b33d499a93b208dd9f4314595cad92785b6ea927d04d9f90fa084858b68e1bddf02c017c4698f1e2e2e6c09015de4f817c1d4d6c68edf2e8b3268ff30dceea49c440df133de1c4cd8a0f31f5a7a1a1669c30d7223338d89f478340ebc849956c13d0589527226b3b446d2d35aab59ce4dedc983d9eeda4206396de2226243af9955f892c93b93190d112f37f9f53ed95953de28790e647d929d1b1791697185fde3ec36136b1c78dd6cb5fb73ce1aa3085cdb07c6e338eea0100ac4668828b62ec3d9ba7ab5a43e82a458e2f9eb92463e75ee5c1c869b7dc9dc28a7c758e2d597de41bdccb5e5b0c009ffb302078264da0945f20bb72fa31620a86816179e454d9c6bc9e12ddba42898899bb861ff7bf6f58d7e3bfa1d36ae66c0ef45e43a07de131416d46b1ae2462e0a3a7f0ab3900f16c3680ce5fa3ac892ec363c59151488613e6c406dd105b5f98c5bfd6985eb77357315460b486bbc5f26ac87a2b077b074eba94b8dd096fbc02fc64bdf0efdb5117ae0ae9be9477626264fec27407c785c7a5f0f9fffea766000b7069398275976dfdeec110792660d8d4fca2834a2c9b0ffe96c1ac1bf2f68817f440d11e6941dc3b446285c0884b140845be2c849837377ef7ee2e00deac797d1b3c30e9824894d0715a2b1c74f429d30e90c21612359fc77e7d2fc6e14158763925226a99db2353d7c352ca3312e15c6c33221a7354b33f2bdfeb2ef0594e1bbeb548142a5f88a832718eb51049fb3b5422b74f9294c26c15b5adbe96652c55f901ec9814de7564c608f193549f57f2cdd6774de8c177c36d6f93ac3849c538e81929ae9e55f1cc3bb426a09ccdf999de171c5157bd39cce01f19a35964fa3f574d5613795c9f4ad4d74d42b9e77cd37910731ad4a93262a28de86a7521c37aa689d007790f08e5816b3c5f772ba4a14953ef9c233ec9808aab605e4d05d3bcb72e1e3d53f2b47b302c424bcc12a36ccf3fa8f72e41259aed6dd03951ac815b352f2d35d25ee2aad4552b177634eabc504fa3f7af0f6cfd4ace22306259ddac04a6127c6e4e6c20cbd0b073183e74032a634b8000b7317d785eb8b318fd539ecf2b1620961586702af4b3211efa2db480f405e2649b5441f4ac99b6ff0b71e084d1bae1d46a59334edc6337846693dd7ff3d86cf1014f2da92f8723f0d8c21f7ee49af7d660462c994edbde7a9d3c3d5e863722372ab14fd12bbbe754188b4b5fbecb3c054c6fe4a0b6b37f6934291d3080e050640e256819fbedfdfe83376ff2c96fab3b2a5322b54f2f34ca85c1387ed811d1fb348123a19284311b8fd1dcfd075d46ca8c929fe6255d059839f4c95ac31bbfdaca528f708eeb81a6ea94c3372970a7e5acb57b2eb4c0049d7f5bd4a107dfe7effb6045d57b35f5e7d92202d2e2ca1bfa9ba97a0976d08eed22bc06b9dc1a9f043ec57239ebd70921f37df75b705943471a9664f3fd8d4e079a3f2473c8839ac3008fc9cbd1673e53ff28e2f66287f549c3edc7dd3ebb6e065cf7c6bbcd6af55b0ed849e20860597a4112c92cfa87b88d49e5cd424efbe447384263cfa2bad87fdd6225d71247d137fe4731e1fcb7b84de042b1ab9ff27dbda482804aea08292886d3807ad1c1ddfe7f210e543d4178215cdfa0dd5f9aa7400d1f6646b8a220a36eb50ba7a1885369a5accf74b7c61de0b13cc1fcefb369fb2b61ec8b149fbbb46017a226cf34ce929d576461b3df8e869052616694561b901addfff02998bfd43cf5e791e21f263b4f381ebd9f98a141cbb9df9c6d53511180fcecd7f717c06ddfeaaa62643fd77e0b40abb7500b99f3bd145cee31ee30f6bc2707f0735e1ccd110926691e23901beb3f8703cc79595422811b80713b956a0913fbf17d0b3545e454538812c3a7968911a3c85f4ace8527807dc8e69f1c57cb0fbbec3fb8884c357764cfaed4aafd4eba7028b66b11b8af9c5c307cf08d3d68fffc57cf212f706fcbbb541f228901eba953f4a8d60d488a3e23bf23d7bf7df01a9f189a991ac381550a96225d485d92b69b72e405de33c11086294000afc8d62402a00c5bfb09d2e8856f21c2f05de1a0841ace9d062bb79a94a90b2ced6cd2c072c44af20b7219ffaa7e600bf41ce3c033541083435240245dd1ee3764dea33d6faf2b6fda4fa2a786b0a80c34b1b1c27c88dec5c98673f68ebcd071d2fbe7c20a0f1c2abc4a45375fcea211a487bcad0e1994f4fe72d1a25e6299c343fcd62890e6809272ad3b6a490f804080fec2b27810289c2013a314360ef856e8ec88072f37692671535081e5b0d8cc6033017d0c647ab14c33d55c55c7e6319b8b63d56ee4bb2b81d95d230f6b52af8da28fc4575f2c1592779c96e4d1213f2702b30ecd64a78618de95c764d8a9c04e6da337309a8e5d2dba82a63c6fcb4b580d424d89aa38fdf9e944496b943ca7aef969a34aec6094e3bc6e16b817ec4374b9216ec5b37f9f98836686fd303e9c69a19bdf805298845309cf2ab923c37301123d8b051c8b180723105e56deba7e63f9f576798014e9820029ee0ed739a7ec27a3771a038af7f49eda3fd211e17573aa689bf48e6099e27c68ebe8a1cbd3fcc46f30939acae5ee616baba56c9c293f47521e38845f78978681878162603a6b2ed8756575bfc026ab8a1f7c6b85d5641fe2bea550e09f1af2f441dd7ce68d49dbc64e6b6e04a1d2683852f3dbea873edd46136b96e9f3614fbe99eeb787835d512f58f09a715a05a55644e038b8c5fc4aefd7d6384b8716066710d63375611217754a335fc631aa81b70877f0c4adb74224d235df4bef1f5a1335740373c1b278098e3f3b43d34294b0a2b455869075f904937f1287b076a93d501e26093b89dc2e8234a2fa39ac7febe47626d1c8b7bbfb29b7fb64b13bb4180473c1fa7685b1e1c958d77a8d90e21ee2e7b45bda5dbd00d48aa028ea869fd35788141627dd8d4a56eeb42917837b387b6137c7fac002faf9f3d2ced2e260a18aee4b08b55c5b21fa3ef65fed8ed9ebcc7dd7e0b6c460d16db517fad582e71fa633f52de85617cf203da135fe5bcc7504d5a471075681df81efb55df09aead5f0450d9b9eed83d32fb0b4d6e54535f1822692cda248575cb914e3e5264b9a538277f457d559b6d4cbece6a5c45af6097583ebdc3b10b8746e02d9ac905ef3c3cc78253c11e15f748750832639a6f9d3ec5c2b6f0c732ac1d5abcb17a483585864e023464508c0f598caf2d6856931bbdb4467d62a4e30fa9765635749ce7f6af3f6b5ab432c5436eb7f6911833b6eb4fae12014800f1e470d5f7fa4916c205a8d81e5a06b9a9a96aff215dfa6c83c72e27ebc74092fd5f24290c211fe10e49c36388b1d06263f1a76b6a8e8d5be862b4462455a421617d8a0e227a4194f037ec616cf863310be27632efb8e7da04632240094213838957abfffb17e4594c8b38a32c374c1d80af3213bf144b38a24e7f5183671f13d81a9bded8b0a825756c613fa0903ef36ebcd317ef19a3eaff30c001092db2b1b45bea1b889c83250342873e9122ccc62b87a3329327a241a2b7219a3d1b38f8da962490e00055f6056ffd5ca49b7e9480c747b270ba676f640106fbb5697b1e48ceec368b44ff9e80aed9cbc3615466b2264538e8f75c909a6ba024394bf7e90d521080e1e643d00fff6d3231da9cf5a1fe439f623cf32bebdcb76700088e63a6a1b975149d620c346960db0b8554ecc50ccabd2c6a34fc84c1ff51e98673eda29fa0e1f701bec1bdc42db2edb07308f0a2abcc87fd23d8485e54c3ae8eead4718b6743aa186072e8336d6261b7ba8e03255e1c3e1d00eddf9d965139ac8d314d1fcc018d0f5034a7f41a09d9e589690671b8c3835d508e937cd1e13bfce547c25990d8954afd0eebec9462709947b0ddde447883f131ad42bd90319ad5f7158890afcc4f06639d57492ed4a3f31b487b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
