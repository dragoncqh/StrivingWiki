<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c9ec5e2b5953842619628c723728f5769b087334abb61d463fcbfccaa4d9ace6a1d0c4c098ac0654f0ad10934c04d26c2272e671ab67b27be4af7acb676c64d8d0ca45dd3198a8e8cafc1adbf4937656404fa5588cf91a0a5eb3636b0bd4e1f324d7cbf33133a2a822d4e3304f9c58cd7ff4111823d5472a730187fc6edc29dd1d38e2c541d446731fd7d08cc01478814bf2c91cfbb45d7ccfd9e0da5e640a17632c059d946052d1f5b30e34873983728396ceb1ec1d7a844cbff64bc4bd0d35a03fae789862c4a7ea514fe1901062821d81722fca42f68f78cf32ec7adab9d56f4cd5d505f825f00b8b9a368f2bff4fd660bd77078250f6ad3d301ba66454e7e9b444bc631761984a2914070e0865349af68b586c5e005c1d086c14fbff5f5acb0d80aeaac3c62b7962ba3ea45898bcbefdb94a183d43acfeefa59e25f2a21c65a2e926f6152ab72233ab57f9ef14c477912c45ac6d238f26e28aae2b534c797bd1c3797df432c397b9f4a9ab29017e64251728e1d11e49ab5627f12791e07bc7c667c41c27e116ce5819e86b6f2d02a889c8190fad0be06da1bff5b560636b642fbe9d42262161b626539c5716c0cb31546345017c2736a04fc1d85f603caedef56eaf349d75744b123fdc61a6dcce13ac44db41919171fcdf36a3a6d30fce0d5ce16d1dffc4cada2a80cbfb0cb96cfcca13770e212bf1e9f3b2908cf5f9907cd8d24ab5c22a01b8a7d4e6bd903c0b6addd62d899ca93bba8bbaf15827e18177295c71cac2b70fdfe25b8c26dea1353f4ac034ffc7ee481313808b819dd378659c56ce788af9d8619508d72ee39761487833bbe3b970204b9397fe4adcc040dffd309a053eaef1103d01a6d7f536ff7cc7543cd72206639310377d5af506f5f9758f54335e472c3c2d7d6fc369c07fdc929d8079364cdd66a8f664b3535338d0e4c9e9322c0a2c55de4ef45450bc46518fd2e9cdd4a0a3343126136504850a71c6644afee5c49f6df9f851a4777b2643b6c552929baa70627e2ba2f1392430c70e4edbcdac796503785a7e29dddd8112add32fbcc1f09a2e0b8f7ba1e3ec31af746861c4fd0fc6d95d7708f7202205abcd771454567fb137e9b6a10c5cc86a1fec9ba4ea8792e3db8d7d604184eb1f791a1c4d4b3c1e282717c9d2b86bc0fe699afc99ad7ee0211de537f2bba92a7dde264dbb68591b184091ace6cebb81c16a52282e9ab575b2410479144ee1b6fd1fee626d1b27fb9b10cf00d8124726e41cd08311fcb3a610b9e568f9af2effcad2eaad8a7a4e22ecf8367f98aabf5febdba42293a218342ba0548a4633cc148982a042f3c04df4d1cda432089904335adfe64c63edccd3262a9823a017e7d8b3320c4f919e33936993524ffce2cfbf7bb18b19dae0a9fc90230428ba60e119cb61f60991083e315f34ef53ec1b1670148995ed05cd6700a4882f588fa6cf7da3797bbc06b3179fb14908250fd772362f403d2e98b2185df1ee5260ddcc61def5d792570a3cb7f7f8a6d005832246314fe8d5f1ed319e694e5cbf29dab05f96fc717f07ed2845a9f14670e8c698a1ddb165fc0bb42467721331f4b072148e9793c887081391c774973d279d816f1c6db4db6f2679758839dd265baa45e995d748cd8143d75714020ef665b67e88341ed5b42c264f7956ddbeef9d78dad39764404c447d52935cd1763c85f2a824bc71a01a5082a520c46b967a2fa15550858332004c27c1daf92ed0aed07feac4e758b14debb9d74dff4cc480e8ee1c8f56a166de3f251dd30113089175aacb5ae794736a15335102285f7dd534fb94f43e89fc8c7b4107ae32acd087a07a14f67d5e5f2bcbf1f16d57706b05ec5bd62ac25e09d782e0b55ab780d4b8c8171e62ace43aa2c557cd45114e206e962dac0d60004efe69ca8c7f8159eb297ced1fc80fbe5f7b3f48dbd10e6b8e774bf815646f427c002f8e949d614444f953f895501dd370d6f20bde70353208e581f87301551023563302e3543953c7a5a8ef9d904065c42a1a9cfa2efcd24e49c10b5865d7944304d5d7b4eaab40f52705c3bc2cec44e21c54f716d6109789d277e1ad8517e30f9af6a18d54a14e5ceeca10bf27fa429345bc543b69c2ec9f086a85a39eaf8d045bb11f0127ad72b417dfaffbbed0ddc376ddecaaaa42a4bb01fb32526610b0028e890d7c163e935e08f5700c1d3e5668b357bf46ead05c59e7247a840b2ddb9ef344a67fc8f6fe328f29a285769ac7ea2d95e8587430c026d4aebafee2ffabdbcbb73dd78e9f07d9ace83afe8739d591d7e485be866575335c43aa2c0a888319b89136ad952fd72a2efa50951b1c583716063d3dd6c26b681bf1f87daf9601644d04b48673cede1a8f953efe01991f75fa7c84cddb042d586bb210e3d289a08bab5eba78f42fbc68faab983da30e17eb285a19c9de219cee518258f2e04261ae444126e737090a99ab81183a47cde9927342883cf9a1f07d820b0311b6c93daecc15af5a8aa38b6ff2fd517788417ab91eeea6f55c788583934dc6c37af5aed856dfba3c6fef9c4c9c5fe1ac2b2d5e00acc50d14e52f911bbe90052315438d079e9663b9ff8888d45942c509c197ac9c2aa69499c97eec1f0a4224c6e8da0d708660d50f9a7e94f8aa7129c8e77c5f8e9d20773b8f2bff2653edd5990643aa8fa5218773e0de6cb136637a43c723d2cc762822ea95fb43f7875040e01c5790a992ddfe8243e1b49a08ad0dd247ba0f644cf0569beebb3ded6aed67ca55c77422ef5cb18d9acee30258eca7ff639e431f453b1903b0b167fe8ece4ae2ee5082f34a181750bff8f0b0e3b7ad5a0651575afb376826c2c64a64eb4292d75515f16d29eb3430cad81df55d793445508e9d33285f4698c931a0443e2ecdca09a0a96e337fbd6f6d0534b6f96289de5b2cbb38a23030220db2f6b2981ce51ed91af7a849520a21471a095aa32c57a12e1da49b9ed7fb3d8c53f609c5ebd7d60ed4598ac71196306927d552c44b8bb19f20053196d1ba4e00e13ef1efad8cdc78f193f3d216c8bf5ae94627d4e55eb9f012268ded4cff1aca7a92d5410a4a5c4c828efe81fc930a6fc30511d4c77f6c4409dd867908588c9af858904513228d2a3b7c70c0a263edc54d14a9bf8e9ce43922607d4981b657942629f99b8b44745e80ed211f685560d28a5df21f9af74247c3d1a68a90157f26d474bb58d56df5fba79a28cb545f120f7f113ecbd9acc05041ff2dad74544423ec8dd8948e14452a805ddecfe6c7b72329f2cde2e54e54486687e63a0c44962bb093a56e8251aa1544ed0c6e6a3953d43d1a04781a2d809703893acd1c5980add66cd02c7bc4a923ccf043c3fa3f386726aea5eba09d93c3dbeb7ab7ba19d7f934ad84690bab3cbce13c2a99775d2a32f2f7878f1040a6830c9e124bd2896c1a67bd76d311837cd07b61c58ffe2b745fee3209a9772f6a53dbf941f7f09f509ad6d75af1cfa079ac0bbb1a2d1a2b9add87dae4779a27156beffdeb4ec3fd2f7ab56a03ff26f9e5dfdb0e56a76c27842ae0423272ead2a0b6d77d3286c76a528b7e09f0d84e98cd95099f6a80967938ef52f6e4844d2b0eaa8bd95d742a40643934d082cbb34814133ee48386c2b992f6a8da09260ad11be5ba3daf276104dcebaaf48c2d1737de7626c849f390afbdbabe4383e087a4bdb449386431bc37ddc5ad45f4ff22a1873742e49a9192619c20a6f9f893bd27907532438b01bcd4ea7c82fd76aa9664faab38341b12dc62f7e0a6337e4a271dc830ca1d75e9bf6cfdf8212ed8a6a4ab75e4a49ef78f725b79c6dc8a4a56a9e67a8718b55efe09478e517c0c7545372322e7ce85d71ac3e5254766cc5a60154ac822615f07ab5b3baaf0b38fe7a1b1e1bf34f62fc24adcb9ce1d849c80b0f784510fb0cd5dc1800887d8b81b0d854b4c8ecc622eefdb93a209a4446bf75900823c759dea89724f2ccc5607a9833531461a601573640c1abce2e2aee6419ffdbf31e881888fdd088561155e73bea286a965b95a4a18980b22b4b26fd9214036ea1b78b9c904f6590b96f9cbd1b93a618674810fcb31db545cee62dbba0a7a98aae1d5dc2852e56b2a899f2f3a9a454fb440390dac44e936744a7ca7d82db2b577d31a36cfe0f6b91d56bbec91a8fa73ce7707f7b2bfc15d2d7171fe2d40f8e1b21fab2ccebf5a3a1a9d46e4b51c22e2f318fa31a3cbc156254ed18fbd17a424163e98eba70e50b8b85bf6d044bbb27fdb91c925861bfe7f9057ca378f8e69aba9a474ad42a196bdcc991572a401c1a92fb8e0b7e5ae6f36689b6591732bd68e75852ec5e52d8232ca73fde7091ad24a159a1618d1507f35d00b66916be62a83ba8e4172253fb5190f7f4a470c5320a15b5338712f42191441fed0c7c7748315b81355c467f2d21ba952da1c0b8461a08551cd39cf6e62d8f0da9294fd164a2145292825009780d6f63a4364206582fbde9f97358549ef9a5bcad4df431740ff5dcdb8b3e9779701440e428c6e1a1e278eafc25dd99eabef55d809477eed9500be549e145fa96d897510ca90f19e40ec83711da3606005b0013f31e74c440f0708195614cae9032f4244b762b8e785573889e4b8dfabc2732efabf8a4051e2771a516fc5fb0264ef31bdc7621166a694baaa8ec029881ae0de575c3fed7c28667cd7d81d7b679ef7079cd646592ee97547dc9ce6c8ec86dddfda7dc242a8b700601f9d59f1c94cf078cdf3785ef29a1d0fef705f145f346b2b0c4b6d48d2928385b185d92b7ca7951bc9847752fa8349fafe99a0e052965c16d007761aee223581967c67cef91702c72cd3981fee9efd14140b5deb1c7708ec57908533b1108ec77bce760d1b3ce0dde90477a3b9c95a18cdd3705fc656992c66d474ff16cb0ff4d01972c9e00805af920344ffdcd557d863caae06b303552036fcd17873d2b79a141cbc9cc3f71d5e6834cc233864d2dd4b6db06fffbcdea0915924a22cfd2cbd3df752bf6e34587e43e93f45c5ac4720706e2389ea6264c4e7ee53cc7ccaf4eb29c7bc9bbcd2e6c59b74a538cc0d8f162785c9f381cad9c4596c69ab53b72234febe2217da9abe0837bd4affab700bc3aaaf2a643837ad29ab5629e52db62a024e8cf438e30514f724e37a1f2e2c97b0f398f99476c0193bdd607a307e8fb41f0b5f2f0349e08870f8912ba58ccbd6922533c4cb3b443961ee896b1037c57fd3060dc4a8d68a775e9461fde0ebd172c04d5d7ac924cba7e6fa97627845061bf0a11a38ce656c3452175d31cd424ccbe4c80b7faa80cf9f17e0b75e4f8e2ca39391a1d6ff98663a73fd87f787bf2b75304ca4b7e27c690b0d9d461410f1e5361796bf9f6e26c97a91d3e0d17760661343a8a88a018abf9c40b4b8bdf9b7af366635647140f2e9857893424b6b5b691c7da6b0e2326a7dfae890477f7fc020cc6d5e5affa49607d8d0191c95e10c2671db1c6417def2272efbcdbc621d4dac83947c5df18214a79f6abd706f04cec1b67bab958a062e66a74b55314219f797925c04618a280f67b97dbbb662e231d11e6d357e0eac473317c2c1978377fffba354ad533b57cbae00e82c9d66fb09686acdfc6da3f033ed24efceb1e7475fc2df98bc092c3226ff1d30cdbeefc10621374312c923dc5502f928f34d840a764b470620be32429a4df78e5af8c11e8f406f74c9acefd8074b8bd0b6e89bd28574296e1b1290c792c2312fc826d47b62517a8c040f50c4114f53b464c782134678f5e26c49415af00621a334bee6137f4d21ee957b0e7de310fc53950f3e613efcc3fc8861f445b64b93e0d118d7ce2b99435f92b49b318011908411121e2d464d322c16a201b3cbfd31ac70dc847a07be11a6a3872dadd59a17cb6d2c0993e91c2fc40ea509a2bb66488ca7b22e005a6ec57ea42cc8de64d3bb6e31f0336b6c2509ae1a9aa181fb67d6f6fe39d4455fcb7fb981a4264414ba55d235ac05120552622c29961e52bab2d2d60bd9296902ccf83cd0afccb89d765b2e0e325502b31229b3bdc5533eec6c7980217d25c786ed82633dad660ec70a506c64071426283b66e61a865e1ce8c43ea14d7ffab9bbacbf34bee89ddaf7d69f22b15e8487781c0c94cecbe312019b8c464e81a9baf4ce3f46ba452753217eaadaa5b32486e5c761e065eced04f9c4764c5b2f730734d497c69640027d09a21ed3b2fb6963b9ce3622ba8e6e730da9b479357ba37ed2f8a7878b404440bf79c62151d7e9aaf130be1637deb588a33944d2d851670f69a9297c6a0d44b06c82e5f31d14a78e3be70c0a73479d93f7790e530310b395c07932e5ff4130f521187808bc66c74525ed5b1e4b94d603b6f912cfe8823eb735b1808558ad4677246af5cbe1d056752e3a94628251570f4720ffec5e7df069ed3fe4db038568687190270347cfd87ce0934c2296b91a104af12846549f181e792b1f758aa6740bc1fe7ab4d96dee1ec36ed8baeed01618ec992a03d7600cb5b024d373752f2b877793f63581fb19eee9937186fc8275d8ac10417e1b27c4282ef912fc85de8f236fe9a9d06c0fe7befa64ae18aff61e622293013e5dfe27bc82bac314893c0f48edf6a1e1b59272d53cda147334e5cc024b89bbe85d2a16384bd767f5127299982687762953cf158beb83ae07487901f3dac88e12acbe880a4e4b94f757ca440d6f6ac6cc323894a83c0bc1627fa50510095048743fad4bfd21495dfcae6a3ed4a4c6d02947c507961f8d8f22847415994407053aadf175f08b38f10c6e8a832e942ac3cdeb52984f8cbb9eae7b9f1f83f6774cbf127e82ed582737d7cbaf9f8bf79fd7e2989adb80f53569a4e8ebfc7561233a839fabff0c29fd480878f95f00b45a32ca7c02d40f09341c66cbb0266e4483d9608cba0dbe87653b0632363433c1b26d55a46b7f1b768c52dc5d43d6bae36c7864377b637d77d29007dad54c12a9c7abb9e85ebff9beba2d62209c651c73763ee2bdb21e20b8d5f42f6bff18892eb09e1547cde427dc6c580f77109a7e871295fa4e7e571762f1bd12850a43a0412c004a05c53c31a5eb5696bd2f9a79567f8ba28127d09a1a2509fec956361634783d3afec0b89d91bda8bfd444bff4c799eefe2eb1aab0653a97c9b7f88b30deb0ddc9896ba5e2ebac1442275e7de2a7341ace415901811cede4a73c6769ae0c78b5917f24f7649e35b4f4271f4c430f358ec59c68f281182800466cc7539d142dfd8c8f77517a29da1f0816bce501e5ed836abab138d947678a3d817ce2b36181dd5416146717c23dfecc000089c3857b2bdb9ff0625a3ede90afb2ad3605677d7236ed9d5e86334279d8653a33693b1beae503a586bf9a671690c5b5eb03da85ac59aaf59373020879c180d836107f20696287afd9a32b92966ea9e7fa399d3247035b666cd7191076f0d0610d9945b770f13449265cdd88b93ec6ba49ae2154d0a85a94176e48bb02aa14ba107f37d7feaf5401655bb8cc664fd36af2c1e07234c5eb93a2342e2402a9476c025ff0fe1282493f70a8a09a3875080d706b00ee5826468853eb48ecd11e33c3a8030d93e3ba9f947ede3cb3c75608b97acad071b80a47f918c223981ff35cbd3be76f401588a2448e6de5cb8a7b80cbe816f4ae51abeaf42ac8fd0ec966296201f4f60f084fe7eec079f1ca9679b81e6b46f412aeeb8715c97f2d7d3ec559de90828a8d40d571d0ab209544bbf57091777d1a21bd3af61127c513e728417717ef2128f619539893ddf38d97fa8870bb1f861407d86220d7468bf8038dabaf59189c2fddd48a3800fdd3806dd56187ae88abed531da9775f26396eb902bf5b2943c11387cd2a65a38d0a5a80dd12157109a68b53cbb4ff5374c5ce1aac9304f585782b963ebf5c119ac2257e73b78723a792103367213b0b75859cb5c4619acdf9dcd849a2782f02038edad254dd9090a6b8bc163ff060b2c9b817d7541948c3f5cf8f747537e4fe011c5d06ba70837229cc70cbdebedb836faec91bae3784a4516f98aaaf303dd530fddcf057bdadbab43445449107f2178ce0734e781c0be658072d61583030b9ec2a780e58b65e41a81c6e5d137eb1b58f50ed3cfdab7c4d838b790dcd69ad5d25cd5a59ecf605f065add1886ed43591955ab0467df936b6e5d7e659cd5a55efb2157fd9530cd47f7b438f0f6335f70e892b766e4b07c1700ccfd5aef5948738e8ff5d7e700d218c37d068bbbd2d6a2ef95afc5fbb5be2fe47b3801b476c884823aee4137afbf9c11372ee7bb87ec17644022e13e20c21f1e6df07d2e51cb151bec8364a844d339b0d9c19b39e26ae858344c6aca9369f81701817e3b3b59bc03f0de253449c57047a9915db641a64ffdd8633ac942d0fd8af35a5e6532da147ce5eaed8b707a853fc9e510077f4478d3898ed22a568a85f3246af7492cbcb4a4c7a41c3dc1d95946c48b4eb375686f1286b9f5fd657c87e7d17e21e4142ecb82cb17e70c8431985960485c88062bc7909e2db1fa1589a919293d4a68c99ee53f2f1d0a863c00f7efec801f74dc8b9b7d5262c46acb572b63e699887de43859483d04c7cad9f84065b4248d6df068f835f557f742f3b26fe51803708e6dd44018b72585730c58cd403cfb6e3b7f15b0904c5e74f20d4fda50854fa54372a4f0078e9d584ad24292e302d76641c8fc673d02a74c91c224e7c4fbe129ac6ca7bceda53806618068ccda3d7e4c7ea2f346178ca9909f72da22cc0c0aeb4d82502c5d90b8b7f1490665211cd06e58f325d96f9d779fca0ff58af396bc6a5fce2eb60b64ce18e5f49e59cc9143c7ccd8b3eb8856796e53856f2d665e7e4adec956c56d8712fbbb5bf5b648051cee997d79f9845a08b8d8c83bd789edbf2c37fd4b10cf648c2c7df2df36e63d1c8a35d56531f4b23836c60e0f3db555a3808d2b0a524a95886dc8c2a5c6006ee4a7b8f4aa6c112cb97a6570594736431fd8b224c848863ec97f975ae27a1af638891b93f066a6295179519934ebcffb06e2a98130fc1e1ea4c30c81bf196f9bf0a6c60f83295c5c539d196ffd885356c9350ecb8bc9755bc14295333d9e895ef2c442bc70a6630b6b2216fe630c959ca96e4ec4a9e1bb5a1314440470eeb946ff0a43e127d5d095304dca03ca0f376ab0f4156182c7d7af7d4bf532000bba12702296cdc6c31ccd221f1dcd598fc3f08a6618054fcd648a6aa02708c065ee99c28e28e6f8484c609f77dd10e6db9cbb9ac4e3a88dcc6a2ad9cd65bbf04a4c0b76ed70e0379db5b4aee8c61020e66a59dfc8f6c8f72e5670eb84c6d28afe7c18a61e796643ec3501d4edeeedc04f54a850d2bd741999fd23700efa73874448c0199ac88f08819763785db5a65b8497ed7eed2b58a5024ec4f3c27452a3edf2c44d30ef118e2a2a536468762fc2631b8d8fedfc68c4227f913bba512f554e5434724d8d04b9e9c9668c19aad53b80cb57d978d8ca37202f15fa47fb7ba6201efa90de3d21892feb0331d4dc331bd3fb72a8a78b42c20637830039ead6b450dc34f52a53aa90148196ac3852e794f89c57498ea8a109e505f0b723eb054fa7ad6c8458e6aad460c7b4bd1c30c69b29a27b9a33e36e7f5cf05d80c44dc35e38469ecfddc4e3144ceccf26d0ebdea7804a62c4f430e37b956eab3ab128136d07f7621eb27819126c2597fe50e2ba3bde2d915d6bd33473a793c202d3ee965239134fbe97c6d2a05f9c27e20e75048be53592b29147b85f65befba54a1a5f5c8f5b617e86a59a778551012600189bba620070f3167b0bb4555ee22425a950b5d43e3884feba0d2e0c701cb791210b51af5c285761f7d6c5b2888c15585c745cd17fe82d4c483dd66518c1233a75fd5548d2c0b75ac64848907ec2c68f6813b0f32dc428815b1b02a58406033ac1ef34c2df3b74aab3dbd868a9124e55f09b737cebe10c73847300d2c44dc16bf6818801d2d28d51e7b8598c9aae6826db39cd1db489a279649219df16553c11d7cfffeb36be20d342838804cd7289951aeb56e14cb4e3f380793f738b31d23526d9878424195bc7c71eff8a42fe1f0e5540a7fbd613b6a1d7de843a896a8720965c35ef5c8286ca5495755a51b741c8e59600b7af1346b369a05c4e6944a241dc8b08b132dd255a86258c3fdad9456280bbdf06c8f3fadc3220e9837dee183bd0dd8db22da49da4996f290b26bcda535d0787be9e13f91096e8be6d184a6e7d4228fa6a1542c970d38299154bf4ae3ef8f296cae63a368935dd2077ffdf45802249f8e1cbb91b44394b23019f774d98fcaec8b5d3ea1804e1f649122b7d65aafe70ccff51fe5cb9b2185b13f28dd3c49df1418a121fe48fe0c7ef5f2dd03b350b7478c0379db345699a3562cfb22daadaff01c386eca026b7fa8881be975467e0bf79933d54627adf6330417e5c9fb31430319c4a3377ba6a93eaabf01ac138020e69b41821b8581b14758558e233646660eb90fb738f0ca577b2c30414a6c7956bf1e1f76d9461edfd0376e14951ed999c54fd13f4fdc76182e8669e95c491aa9f039d0beab6d906a905785dfbef177ef982b4c717ec687e722c558a0e58884446ef1298ce587e107ca8e87ed89070543c23347983476942dc86d76c30d31567c692c92bf654f0d4ea812e473b1df6c520cf37d868752d9f03844213313cf4cd9a53edc02f2ec038e8ef72cf3677d9bff29d026c0501c32538f7e1389673177c61a7f413d9612fd00b1a5d46f3682598a455f9c06d0068746bfb51d16e61c63dfe2537a58d6efd74e593cc0522e483defbdadee1e355f6b09240760131bbc37c2ce3b36d20401e2e2696ffc440f7051c748149e2c210d767f53649d1785b6183304c9d82ccd361493a981d37667d8a062ff39f30c8116b628cd112e34f7bcd14c5af3df5fbace4bb846ff27e648eaecda3933d980f5156f824f54a9f89dfadf0826c38e60aaf74598b5b3dc6dc18d2fdf4f6b00bac177ee0938c8cb37647d1a7f7edd4affcff8afcd40df1176b167742581906b0cfb12867cd9bae6aa3f62858179501dd23dd95ddb1b3f4b845817094755cfa80474475c5f5813dc44ef42289b259f1336e3d7411b1879fa75b19dd13068ffb08c114160a51463e240e764a7e6cba560d611ba175a843694dd11b10cc54d2988e0cd9de189233515280f1b19fa16311783a402fc049e8bf0f851658797fd9e7fa50205d80ab4574f751dd173b299c685217149fdf1cdac60ff0f73c1e2dfe937097dd4ab17aa12d98d76aeb9eb5e9a29d32cdbe21493d290b537efd69af387a0a3b0d8852e3a5e12377b2b044faf0d3ae2ac773f4f14ec9efbacbc148fc6d72457af6bf60ca0d750cb034211ec860fbb167a7e3c164593312611e6926e5d42d3eae210c4c335e422b32fb4b54de091c3285815e47f1b3896ae4577f7d6fb68d6be45bf6a4674d5e1ca026b8ddb2acd75de79a7e0ff2d2a3cdfda6934e25cf87b416b6c69571d99f2af277c585d6aeb0f980c03","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
