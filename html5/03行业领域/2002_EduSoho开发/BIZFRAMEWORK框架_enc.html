<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"809245eeed1072695a6794beec94f9f34099844ac175ad3c9e8dbdc929f834783510c88382cd33d5b4bd820c062771554f390bbea6c449f2e4051fb1445d989c11615bdadacd0bf046a71b1487aeae1bdc1ec8385c8b371598a730dca56e33c75890b4d73d8beb62d0d4fa54a8e31a1353764e212a518bcb52b2caf95bc11165db48e6702ac3521fae13fdf61be57b4639eb99d3c522d3c5fdf35bbe091fb5adf8644cb24911ab71a8db37ed3eb9b3ec8be82835a958203a79d79098b62b11f707c03fb20dd0a767d46b11eff5874cc8514b7fe47ce79977bc09bef2e24319ebd638e783f2a7577632ee7c8e0e1451dd115d35806a38a47e2193abd3d7fc72d163b803dfe9a3d357bbd735bf06fefbfd19e5a0654408637f61c943fefd3a8e7d776c9eeb680e01c55b2c6704129c2047aa471c8ae4a349baa1f736940bbe6786ded59bc0b39d045292f5499c3dfd16cf7782be0b6a7088fa9bfe60f5e77ceaccec752ac96c46b855dc2d1e4b2dc0f2f818c970a8b8a228f488f314d72f3abcb7301539fb199b5b220a932a359252c5f1e493dfd2476f56d67b4b428073f83e85101ea1b43535c335dda934fe52af3ffd50974db0c4c2022cfca79319d51c90708be3779d164339d34167940288445cce2680a7e85285ee1dd783f15c2951dfdff8fb5afebb5d9e1d1da6566258e98213cc5f39100c1a075ce7c42460a090d11bbb4bae8078cf119135728bd0098b85fe09926f02dd36fef9e348f1706950b82d5be9b8abf366fb98adef7941743658dc622e9c730daf118080d4bf928f61e4396d8001223486263d5c618061223812f712e8dc29cdd3c6f167c0244bea6e84e03a30293c5ea2cc25a488bfdccdfd57c0240d25294ee318e60eb2abd0fc13ff7a829be425b22b63bc77356ecb49d13793a80c3ffe4c0bbf5a96aee27bc0813aa4bbe3f11f451bb48238e13a6bfc09505e5d1ac4b442e42f921d83a580e50c88dfc4b1e356698caf98fcc93a4631e8b02138c0928ae0e5685b8dcf5f54b5682631c43aa26ee39db3a88ac17e38e694dc8448a54c77b9eaf9dc07803a9d23cc9eb5eae0fa185faecd9bfef4e4a0951bf13d413b457cec46c7ee6b8b709c34f402af5384da66050d49d17893f447b81ca1c8807ece461ca58734b9f2bcbdc9203160f417366ea02ffc40b02a854004cda29887752e1164788e0a140b9a7f1392606f664b0c46340a9bb68daf723e2902faeb0a148c52d897c7af4a34f984118455dd9a3ca76ab484452826c9b8415608a084d04ed9069ba8a28104dae028214ee1b5eae3954b14ebdfe98af038e3b992d77d7ce6c4036b11f09ea51d5b98e300beb2d01ffae463b39c4eb1b49cd78e096d706a3a97e789a0fe3302f30879ed2a9f5071471149bc9779253e31809dd9254c1aa6fcf82b52fb8df93490beabee7f998507e10da7b30e2cf0e49c5216111df8f8f21b85f1bd52ae87359b2ed114fdc6ff1655879b1a83d1387315ef8640f4cce92c73e570c070eac4518b7a417077f2d797951ff6e92653a6849d00ee04e6683f2e3225b0934e2fc7a8c69cc2f51f7f2315a600cea93ea1d51b2bc4f8ea2dbc82d4b24b2ea9cff6c72737b354357f033b685995479ad4a4c1956e26c89c058b6a2cc0f762754f6a62636abb365e6e341017d1591c5b2b74e76c2c02631f31005ba1b7cc2652e80d67b1dc415cb8765cfc0d039933646fafa9c50d99ecb0ef0b8c52040f2e79f6ac3bc976815ce85aed964b0d95b1ab5af1481c649a5e8952d9cd3b1850e7682f4fbe35c7106e5bfded4e9d3e16aebfe31399944c4a8b3704b20732d33e8c1e45c091f9a75af413f2d622e5b7296db5c3691dec72b1d33581bb28bcf56dca35ea134e4f8ab270d79dcdb10170e3254e5fb23537c53f7808e0d9dcc1d7bca4dfc809dd82789422c8926accda3e1ef4ad5b3a3f44a82cbdfe6e136748362865b67147feadba2f6b91ed735b96046a6d5bf9d47e595fb3aaa4c66a14a00431c93892ea518b11fbc7a1d4cce2cd254a2b00ff464704c76e7263ae1f3c24682f90b61d79e710c90976a26a9cea064cc4f2c0cf92ad9416e833376168b2d94247404197f5b552369f9246acbee702937c9b8b8c82299cb5cc62ac6827327d3a661c807a072a820f0795698b47e8aebd3424df3c1c2035a55330437bfb50349320bbe81fade245c1545a635218f6804e8fcefb08fe46b17c3f0a2a160846dc85a08e477bdbd028cb62fd233300080245aa141507b376f00dc3681e5cde890dc2abca8ba92fe60217596adf75618792fee652e0cbb359119b0f3156e47468ef13d94663a59e6ffcd5bf2a4daec61035bf1f32f8667639f4aa9aba7adc9a0abeb856413efd7b391de191e2419bb3696266023a67c7483e677426c9de1613691adb2f1fb6c1d03334b959c1b474ddd0cb1e95b46ebd6e539ac3c5777c2ccada63f4a0568069669e113f94d37b2bcbe6019277e0542296c1fbfb5192358133484ef8e7f8553c4600b9b75593ca18e3bf4b2692628ac8d1c33b29cd697e589486656a9808f859253e4973b7da345b4fc51c80eacf1b659a132418e96dbfe7be89db4aa7b88685c17429bedf0ba09a76fc2d0ca163ecfdffbf16925d6822399ab64414cd266a3745897efbd6f396d1f6caef980ea6c3f37f495090d5e07802a193c33b216aba1cb32e53a549bd8604ac7f1ef0d493d437262535ff537ecc6e986a3d0a49cfdfa65f4bea55cdd0d623b08389278db4acd104d588db52e0fdb244291eab3924d64a2c25851d3acf5849d9cf6ca736dadb0eb7d034f71ccd7b6ff2ff0c4165cb1a5205b7c8d56596ff282a3f4018ac0b976906d917430f879953416552c2efbd3c37f2598a2433d7ec546376681789814fb689f187ffc9c59e14e13dbed7a74f67799215e0be7b952e0d72d04b4c9b4c0112810918ad8399a9062793010770a651166cd282452f6aa4129146ccaa352fed0e44e717e642002f1c79e639222d6d59f7dc79c725164f056648dbf13756805e5911030ddce191f5e78781d0983b0548da668d55d9d08902c5d75652908f6865ddf6449e8e6f16603c1773b24a304d00ed80f6ed0a176cb520e1228486b5d654d7b7bbccfec9b3d3f77a394c807f9640a63826dc29f171dc348d55fc2d58dae39b01171789b27f0d2d5fa8569cfb567693edda7207ccebbe85f5c5bafcafe9a411b3d5a4fd746bd9f7e0a58334d8a67bb46be93d8dfe733c8f1bb52266d7a2c91ac98d4cfea84dede7e06b11f199f0d09433d894754ceb4eb1ee12c74d7adfe80525e1bbdb47a7fb2537ff50ec24f2a0ea1c6a415e465b007c138fa2eaabe36e098c2861c36a7d31a43406a0114b6cf2c56de912a6faeb68ee0f22df3a82d90def55128e87efce548ea031d53a2a59a675b1f57ab407929bc7ecec22103a69e2ee9c3f7d2a0ea4e367ef22228b97fa36f1d5815a3a45dc50a2fb5a1dd390e931e4ca273696c3611c5eef548c736c57f12f5f1799794f435f1b0209dd641a98e41b91bb697d0d92d0a567ad246158eba5d0ea958eb0487ad3a9f5bc9a20ffc67e1fb2bdebadb4ba7dd632e9a80a5187f8a44edc0d53284d9890c34abb17b62d1fac01934c5537a7c62683e4c6a51ba656f8116f4658a5857795b76dc991a3904ff4c2277124721dec79e2e0a13f572ba48d70102751477f06c637d4be0021e7cd24ae051876bfa300fc656ea036f39127e8e5e0aaa9a756ed22606921347c1f51a4d10da68f7d3ca1fe84c60420899fb3a556e64709e6d938b2379ab7c27f790bfa80faa68e27ce8a45cf8ad07823467678f771fa7e0a20130bcfbec381740387903af9f624073f5afa5afb390935ffcb1c126932163fcef012a68282766c2a15ad60d85a4db24521005aa1ad33a5c9f6fbe3ee69c742b26e163a35be22657a3a4e68bddee5a7495917db79d30c2b15dbe24567b25ed38db1cc7efc9790735b8510c18539d07404403beebea240368cc2ed1584c8f720834740819f8be3d7fcf8b433dc05bbf8d747d877bf6fd23048f1199635478585c7c38d10ad6dd512c043a27aa4306458cfe69e163338a8c0886ef045dee8a682549139f9ee02ea78d9a7bbdefa5926e8defd2ce4dc52fc090c42a090f36caf46fb80d75e39e8ec6447f4fa3b0ccf55bcf028a1b9d56d5b01e15ea40f08306e5072b99605523e9621038b6ea74561839d649eb8cc1932ff1560918a29251d2c2c7238e14e0d75447dfd74069872918d7a04115949237b2988b957a9632ac6977915b92c1a06330964a86cea7287fe003b6903efe8b54e0f69cd74c1bbc0932da690ef0bb8dd5a1edf58848e3bbaa0933310bc34913c2f0adb2e5d6b8fa7e2c72ef23b4c19413e03cb3c5310b0e8812cf65dad22e832f3f4cdba932753a2dfdf3b87c242ed1533ea9f051037b2e0ea8a04de9b4d9dd30f7737ac0ad3b4e8c2899c37a6f6f42dc66428f6da277d402e00f88eae587af40fbdf130a08eeb31231040db3d7ccb987ee557552564e2545291abaa7d69d928c06448cf3317e29f67f5904bd4e69cfea86cabcae2a64789c347023d6835fe8b62eda77513a46c1e1047ce89e733e6cca707e0256ba15a10b71ce15bb7c367a53291665c9036b31d0e98391fa4e08e04cecc914396d581bfb0770c346c3bc671c6dca8506cdb61e64a1b8fd8bf464dfd0807074616adaba8cee040ab7d2b0351aaa738f9dec4feac5a4f6d1a7d67c33d8b84540d00966ecd6ca17fb6851738bf4a031c5651d969623212fd7734f722f798f841e20ee9733378781816a064554b0ba45ae6a28b2cad9e1f84e6589abd1615015647cda95e9d6e6778d41cbed66af6bfa15e24314a8113e08fe7d604ab3d52cbb43f834c76adfa1f4227f957ffb36827b4eaf97fc1727f3827a15b46ad270b43f99a1f0e596deeeb6b506e85eb1f666657359d00941a07606d99da4d74ce3d169c5a7b9d4be58980d37920b6dcc6d5f0b4c56f85ad1765113a542a07dbe7f4b0769869cf2d5f6d627e8a5721b6855b2eb3aeab2a13f28b02ea47e70d57d765b29090e789ede3699de78a60700539198262b6117fb026025e3c8e6657e8d06e737ffbd80d91e5f796721b4d1afb7de6f9c5e9a6c539f76ee761f4c44c752a43805759ba3ffbaad50330c8cf10da49f8c6b908eecb32e2edf223fc6e0f37f742605f938248f8a97056f34794991be26da8f372f96de1e1c8633c6845a51a33443847b299b85fb0e306ef2376900605ab26208e066fb6ca81b668e9faa699b3ce9e97162dc540be5a267af2a50ce28c49f8584b4387d53198053b73ca4378db91e48e7b068192afaf56545fb1316c7d7ed19ba1d494e459662deedb5d7c23e53e33be48c1f1c6121f5bb108d823bb4d4040a430a66e19f3cb4a805f83ca43ffcfd5c63a5d25b78f64687302bcf76b05b7fbd18b700e24eb957ed451fbe873707044c198f334d58822e07362ce30832000f6d8c93bb5cb2f3e2cd58a899851542b379ee77efd67798ee162f0a3973caaf51c72ad0d4549ef922236de4e1ac802694c1c500e1cb16411f979e8a82997fb050a49a6dd78a21101db33a26c7cf74a3a3771418716adf395157d1114f3a460facedbd0057cd2ea5abacba0debb7a4f8d9d001f4547ecf4236cb60d274f5c295e1a8a525ca9fe856d6715be21ec31b460e3d4731ba6703c9a8a1f5099af35b172652bf8b86c31159e60efc1c54689011e6a90534ab266ee4701d72f922d82c6cf824543f86b9e10957df911ca01ef7408b3215f589b27f3b7eb1eaabf36efd3835b75d28d2a3540350693ba4989d1068402f798027b6f2f06b4baca190a5fecc18ea84dda6858017c55367a238a3812c7c11fdc8e502cda237fa9e1214b5e5dab9f78f624ad7a21751374737da1202abd409dcfd039a76c04ef694fb700c86469c4b4be69c5ebd4c9edb9f81433c240b220fc62e39cd3d05a0deb975488c4fb365722cc6d163137736d36b9fba7be3b8ff84ab9fcb2bbc2452099f9d475686be0acaf689390d1276401d3309a9e534fa42ccf0c9612eabec3c667a4a590dcd8776f2ecf9296db1750316549aeb381ba13a3decd60311fa5841e20a1769599422a4b627d5c13952350d8596b85b8cde41f55526f0401724390ffa2e48912091d1d1518f9078a01f2aa70bdc7c11046fb1194e3f17fe0efb54a5189be7b7fa82c74f3983fd6591cf8bb79ab87cfba321778e5174ebc7ca7a4b0c7e33c094ca5e434d0e355d6925374473e94714f8a69d944c16f93ef729ee1c5a71fad64b2c4feb2b28b4abf730aed1c070452b405e1a0339f131ad5c75f896a94014913243a16e0b3b8eedd76d21f060ed4ef13ff6c244244b8b371ac364f727ff6ff7a48a995bccd54ce6812bbd0497ab93cf6b7778667fbb69e72e14ba56197768d85a8a924f3de6df2a5ea48a92161e2b8af6d7213798d1db8f859d58a86610ccc72c8dfd1d8e682a328e36bcba72076768882ebbcd58f0109a28c17e6e88fdceb9cddbbf4a0eee35acd2048aaf6d519a21615f10bbdb863615c650b46f235069f49e1c56da67468efae122c3af6b9e7cb0416c1728f02e0d8a2d68210170a6d6e80ba59501c22d9c4f4732e78a2390da990a499ec82e4b4da413effb111ae57c9b44448eae0f3cbe7c56d22b8218a73913e3a134a0d7c2f396f7c6bc8ff46d3ae80ae9ee1ecf9a142f03374de659449360bd262883b4a950243093f49a97a8f49e03d7f259b83e4710ecf485ddfd700bef63f074df42dedd22afdaae5ce3c41e935b4ba46f37b1f5a712496226397ec4c451b147f8724d35247716c527d6054042bccdde0b3ca419e850a18e0989840a4782400b7d9f5ac3812f804b2a9709c75830b1a2dab0d8465c3c0a43e972db6ebbe48dab16b6a262302c82229ca29ea716ffba2f991705987990a9c189b65297fa35fd44d77ebf247f4549e30e30adb3cd8494000b06c8d9ae74d1c54166053615bb6846f9916f1dac7a2ad3d37ca206bb1e310e2f8220657dba8f3881ec6e6bc20fed61a78649e6d9fb232d7fb06f4e0def3dbc56cc8c94961b97626c1710d43a629ccdf1b0fa88b4207a1ce23428f1f390e2a7a68a4982d0ec80fd9fe3dab214e7fc78548dc875ad3ca9a0dfc99cf581465121e5c008d1cecce2c43e53665cdb000374c5fa66bb9e4d1c286844368250fdcf1198387d25c8493b83c4dbc7bf4f39d8d06ea73e1ed3e0df792ac99db478194a16fe2867f5bee8bfd768f2b439615b8054f8b834b9598df875df7acd0bc4082be6120d3fbce485a59c8a38d6ff998d8d4822345a9010918b6f899b6531b963df1285583af4cbeb03d013ffcfe373582eced226a864a1fc5d7e65a238094f78093f6d91e11b51a3b8fadb94eb0067415a18faeae28948b732284a9393c0c0c81ada1ae634f7f9db15f932266dacae9c99957b6891b4c77efcfb8b5dea0734d279321ad83ea4b21a981f8bd4fa5457e53e4904dc06b72a2fa7b3a4a699a935a98b25371720a57e749c98ad67ab352c0920ee9d133bb54cdc60fbd90ac6208a9421a26d4041ea697d4d3277034ec6bd3ff6ae1f2bce8c239a43490018bbcd18ed8ec90f33bfd281674ef02d91d090ba466ef859efe03252440365606b806c1552e7f6d1aec19825a4297c591319b33da91e4d6c3ceba8372ce1e5172a500d78034da63f9ca3278402d9f7592360e1a3ed0f6f2ca117291a6ae228c494a8fb648fac6168ad89bdf745fae26eb9d0f8ef1def875d0c5840274aa3e0833bb20664a494016b5136acef2439675f6647084161aa09eecade61116424f69755a207062973c5cb2ed7f8e9fe0666b75a008e6232080af5b95f5a4adf775f38468ca3a9a0b4bb76026171f7471d8e17a4719aa9b83e80c07287fbbdeccdcb0fd3c201cd6fae322bc24946b003eba172f55834774802385bdd51067130919a67ceff3d5328a8467e2689d56c94ba4600f091076422d1613d59e9c19177b0b4ceeec7cb5045b57200badb4c6c864a667e4534bda6603ec068616add192c83e65e97c6b90e842cc056b1ac5e2f65f99f08157a92240538c3fc7cba85ce49be503b9ce6ead48b3ddd96951582738df98f9433d7925b24ba6af26a51eb2ec1bc9e5e25c9fd02c7dcf7467da06b8460a55ab7abcb4d6d8df43aa8bcca6f686b3894545ebc581a688c882741a03e1e9c9cf2a53234a203b44e81c2f0e3138c13a8d573386b30557df2135cf013dd70f8a886d5693b06510471648aa4e871d0f0db9749b87381f2e642fddc5dac39a73001755b9e5f0e83354d6ecd6b6f989d6fadb45c5cbf566e30bab282470e138dadf8327b4af0996a9f5ce90e31d44dac0267f65f35bebd8895d9ada37fae4d2a1774234c4b2f6c15815bca75a7ae0a5eed68ebe05e2bbfe509dbe8c79955392afe3d133810fb181213e1d13ecf80450415b046ee5a3808ae0be98bf0eb2d18fe7785c32c4bf9754c8153bbaaa819f567f627e3630743d6e8efb28b7a2112605d543803e0f50061ee6da11868b11bae91309f46f879654d8fee00cbd71aac0c15b8d70f7d2d28a9fca5d642151bf4c3fe5697fe32c53b3f1709748d1430ec46f95c634d2f824e2ea072866bdf78bdc49c8c87169de0456f867bd68af31e47a67f5856b7edd08e81a1aa500ee9428e35993059e1dc418af90edce9e79adb52f2c7aa4f1776fa1692c48e8621750a00ad729bd501c35802b4b9a32a270b226e100a142bca13c387945fad0ad50645d8937e429204ee319190cdfd3f7062c20f9c8f7c056d8d97488a30b5917abbbb5b97a980fe0b0fb3473c41dd5fe3addd5a5fb14034e0e6640cce9cab9799c8595706c6ab6a79cdf4fb78ad3c41378b3f7c1a12c235ace946bec08d8490930ce11ffb2c5e87177d836ceb70e94ae31a262a7978f02b7a6f6aad4745e9210c1519fe18dffb4efc3a99eca9ec4c4bb666dc9d13e8ac1999d82125a8a2d49f868aa158acf99f4f403da3b3c89b7ac00cd727ebdd9b2bcd9c1a7b622a0a242064f70f50a748fe4fc41946cf38d910b82e7fe3bdbd0ad4749227a23ce79af0b9e9cb8b93ce109584f3d16c42d71968ffcfbddd6ee969059cafa9e7e9ea939fd62ad9af46db0c5937a0b1ddb60da29819335ff78eabb301441f0285184a76986ee052ea30f4fc54047df913b9c3e4577bd06af139db47102cf22dc99011ec216f9dc02f669a4f6f178a70a6f531e1bd8e9e986a571b64f98e273a129cbdaf048866db18a03785121ac3b00a387ac94fa4035b8d7ab0dd6e8b302495751f0ea6fe4599f4cf4b4912f4fa7d187ae0c1337f99b682ab426d81b8f4eddea0667a2d1784e35161db803001ea1ff8b5c25b06ffe3750b4a349089bea2735403f8ac5be8425c681750a6afcc2ed4fcffe020087d66afab3b0c11a941b9d37e605f286a1044d58bfc0c671dc7ef89e84f81384094a4213a3fb69273e95f67ca04f2d4c092a0a2feea25905b09439795bf384c332fd0a6b9dbe759f45471d7bde5541f6eb6f0f52dff8c03d736b9ff942f02f4737d8f3d81f52029162be431bb068cd9c0c202768dd6d562602059e5bdca0100420efc60a4992e209ab0525b86643a047ca54f42a37b76371548bd444d963924763d2c53488493ad133552faa31c8bcce1d1b54a3953bd3e05f6658afe4b48a5c4257c8f75584319c19582dc982a8c19a1932e82d066201707e86ceaf438548d0f1306af85a893119a8cac86d5c52b419e403398107bd9275cd3a59f08248c05c8223951f91b8e430ddf622f8c921633214013435b2fb5f0bdf40c3376b98c0c12ab29edc848e1e898fe6176b30a87b99f92917af48489ffa1d63b2fcbead9315407d97df8ff254ac6ec9fcb1d825218c848f9437a79b6b42af515e851d308e166c8d68d63c47cf4f0a56ed51291cd0ea28a612ba6ddb12bf6566474deb5c55d0f1b9166f81a546b8bf5831e9a233153ed70791a39e12685b86c4afe73459d04e5238a4de5ec44a5b2c75439b113600fe61613ba60b9f9105b5026f2496218cf99c931a5c0b2aa2c8172ea302f6b21c83d1e98dd7ee2218fa460fb92a9b4dcb25c7f2037d74a5bdd1d8813a522ad9287ad84c5ce854c844ff16782e07cefd82c1fe61a9f5d66149ab1092732f2904e3ed238048cc9f9699d071312a811597f62a449763b5c51ea59f4f5ab5ca24f60a7a250007016a1c9c10e7e35dff64095a64599dc13119689f6ab7b93606917acecff648abfb95cefb758cbf09736c88dbbd5f67994331a6b0b7e586d5dcac8646c51a8e656b1b8cac1b1cd621b1d8066661b94b7ec9833ff193e588e2339a345906bb2ee888ad0f8b9a2094ee905513ab114e3255dd23b8d662fb2394259519210692c6ea3b692d18a57d6e3a8c44db38a4a186d3942f7f830ee56a3fe8b7ce38ff699189a85285a0c078cd8071aff53df42f5c93e930968ada38c72c8281ff6d3ac5343d72ff60ae2fd25362cc2347e84b2387abfd1906ceb8ed5bb16d7eb32b32a3887e815158ce13b4a148e13491dbb11240bee5c23307285436cfab1ba9947e604171eb622e12994357dc2e26f6bbc4c775a97e8d5929c29dd9f112947f53319bf807f70ca39c81e0eab1571072e4c8f54802d903d137f48d3feb221b21ccfc1b7b5274bfe8fa8721128dedf7af71f9c524e519ed949f74dc836e16718c771c548fc8a16aa2bf7fd3b0b85fcc06cf837bddef1c1f8ae0eeb24f71136e3ae12b8084c5e121bf02fdebffcaff4596a70c6e62e791840e274fde1e15b9333e52e6f0dde043e122c27dcb336e3419e34063aeb1f2b507e2230a83feb49ce44d3fa7761f40db9a6ea84090553a0fc279274e5df80e79f115446e7b8aea1a5ae110bfb2410b65e9014bccd19bb39d2639fa024de9b558c71ba0e05b81410ba7ad8e50c2f659446b9c93e05c6a9ab8a0215524e672a02c601101b27e5b02da9f30650148d368810d07e0adf56fcae41059bbdc87be1a3b32adb3068574728a68406b9b4ababdf769709c872636909aebb23846ff191ca473bb609aaa8853f4d093ca4fa4d61a3392444877b9df3b2d00476ced491b78eeccea00f4ce86a4541579791234cae8227a74bc48af154cbe1c5c93e8d498281b00134f69fdffd5a05df0bff9b9b8cd7bf739efb9d8a6d2d75ad13a77f765b9d67f3863e31e6ad8ed976ca0e5131c51e6f602086e801e0c4c07209529b635f078024f7cb1ca77de66447f77ab1f2c3bf5aae187fa486436e1c54f1ddd2ac5ce9e59a5e5b0a377b947bca06d81285f9cc38c1e3126350a32c96a12a6c7d12204f041d4cf5a163e6abfbed7dd2100aed3c36f19b8b09b5b82394118cc711966d642d4d7be65ce2a7f28a0c119b2192ac5620c410ed20924db7f25891122f9ba445b6e3ebfc316a416d61337b6ba0a83ac4ae5f6e92e7da823c2a23489f91f12c72feb287ecf53f4ef8240e753342d7853adc010d5a63d64398d5c8cf093b1c2d48111c4e425252c8b6a71ade50f6cd29a370d0cf93640045f9596ad6b0f9eee1a38245bdd7650feab3c6b9b7b66563d9732dfb54cadb84270de7f7690ad2a2879895b7347f406d62588c0aff4b2bf05623d485cfa72d395ec0edce45407baf1c0d7f5360e8a3a9a1fb37819e7bbc8b80cdedb4215ccb638d0970fe9754d06f18031cbb6cb2410a45eb997f5fbfc79cd060914b89b3f531d2f94028a1463c011c0055cddd09df41f6e05060a17f52ddbf4b8f45149982be00d1b44b183dab31e2ba27195d00d6309d3e2572ddd206b97dc2e94538f17fbb29034dda4196e1ea7b7c9608dcadc309c2173b6ae30d6bb3219f7e0bfaa78cf188678da4c39f0536b69d203628beb6b41513d43c269097298a44d6c5f7b4e726326d82153950fbd18632950b3e00c43138cf5e2bd12871def60da3ca21c81ce4f4a8bbcd60d654fd376c0505250a69cccc7de2faba73b2cebda6d787a32aee459bec81d52b0c66eea24b1e7cdc36215d74ea1a432f050e76dc1ef6a3f24292d59bb9a96ca3527aa8a3123ed09328ee750e2c60136ed3488e452caf5ac8eb95a8ea4a9c70d53e0c734cdb3b914a9fa3a2fbe1aff4342c0f351d0ca2f4fa0ee6a4bb788bf66f859c045bda40736dea0f0ad1a21be64ba7ba0c73af713f16580eff3ff28961433d2d08da00d58388df186fb9f43b29616069c605e033958b11d6e8f3317db673c3e4321fe7d7a7ea6469cac406a47b34a65e89e5ac00d0b5b1f76dab0911032697befdaaf0de20a9e00b633c507aeaf339d22f0fe2e76159978afd12dcd4c59191dc730c3a11b2ae9e6900def79e83dd2d7b012c939db84116a2014ff51c6f5ecad894a480ac2e016136b019cb7058e7fac9399a938b12d090402cb3aac57eac1534e5c009b5b3a94e072940d99ece76384d5fe0eefdb3183fc3b41e127ce52d19648926a36812cddd972390d62ec25b348dc199988d0ae413980ee79ffe631315eb3c1679b000200c3f043caf086851afc89c1576cca9f65d200604a6e969d94e93974c7660a31c31667c49e85c1a7b1e921672e1ed82b2a241572eb94a67cadac4e5844ae61f64c8bdcfdfec6694d61420d955e1d1893429d3659abab78a0a0a77b1783aeaf9758e407ec338dfd0ef61e0f9bd91ae8183e8145120029c27232a2f55828659162ab22e878d90b0444e50d7d4774bb0594dabf7a8388cfea608d55631e135e9f3ac928d05c08fd5ba44fdf8c5c435c12b0b582f1cc2113d0a52af1fb0993c38e68a54c2713d721185b1ced6967af81c6899f869584d5b33d1f18962619e1bcd236f77c979ee2a87bf5ee389b4de63f01535a065c21671f969e173dd805278db71414ca061cea76aaf3a21647398a290ee4a6fc9803887b97045e2fe511391e933871721138c9d4084e431fc9a3c3cc2d9a0eb9843f45b2a07fdd72db6ef02188595589e9ccc13e2d749f03a041f0021ecdaa539d7ba5342fd403f2715f5fc83596431c52289cd7c2d5fa78f2a98573efb6df79884948ccdd0934e7c8faad60d6aeb38ec01c4aaea6680e3324d977f3e1c4a9be7ee4418fd40efad6dc641a30eee17c41cdc31d0fe5696b95bd06eb31e769e3c93f703a36ae7df259c549119a673214d9ef44326b0c6c287fe4cec0a3c593694892af3df364ba1d00b3c20bf8cac28d99ab03271952540cca5b2545223e6031b071fe2914c7347f3d5e9a160757cb93c0e2ac10548e741cfe725bb18feb9ce0b6b9e702d351b2e98986f085b8762c5cd14691663c3b4d5c7c73efc8f90992198bfa03c25be4d6074146288db841e3a3da32f15c75d4a2e4a478ce1a8aefe1cad754d0f19446c189993230d2cf21c66a56e654135dd88e6980b6ed1209ee5ccd25583d6babf52dfd57eb3cccaf3c6f4f76cff92a88b1d02a4017fad55d2b9bc4ad1dee24687aa99d661bcd48693c2e0377b08991be8789f052ecbfe755091c63b35a3a4db903780e5678354c3e3ee33bbcd3c1cb86750550a0c098951fcd86d7f4ce414fc55e8f64280e70d55afb3740a5aeebd5e099fd10e3291dd35852603bb9a8c3e617afb7982d90c790eab77355691fe5979db2d51d15c5019e0df3615e18a9d91281a2c177e1c97816d8e416262adcb36e70f783facd843364a00f2e27bcca11108554ee5876b67170d29eefcbf83e7054aff2fbd6223622822ecb351a2829bd2b16b7da456553a67c9169ee0c79de79f99a85f41e4a2e81fbe7ca9b5698d0417d7abc2203c5483eb87aa60949bfe550599de32f8e37cee1ff802a41ec5456cc39a6b2d891efc77b26940daa030d988ef5f5115e4693d009b9eb519f681bfd154312eb44386ae4835cfade6b469b228fe2346bd7c7839bbe9debc1b01b45350df8bdba37b078668b084ac8fdf809a7dc696bf85ed4887ed79ce8318ce4979a2374116a25cd5afcbb49483e2f742205617af55aa355d59d53831393c9fa369998df3a8f4ca95d3196c4771f7ca69c87c1e803de3986e168aa77836c845c008e7fc2f9bfd494f3ffbc9e125353a330ad621ddb22c34a4fc8b8682671f84f39e559dc9c6e2b1f8e53a70174812ca3957386c2153f997b2035cda04590ff1e28d54cb26afd5277367bfcf39c2e58ab1843a3d989fcc79e0eb375b7d39f5ed5d39ddb5e6a7a5ac0d820ec0b67f1c6d92b80d9c2d18579c36654efb066a4e64cb6a4aa5fa8a1186b5a2f531b18614ff06add07d830aea68c0a0df7dcecc904ecff026775bbdc5428eb6bdce611252e51dc1ec71813e68be3fd878df212df996583fff594e967b06fd2498c6ebe67c89831736e73f1d5b9fd441cfba38446b2d427d79712ebf6140412fea3d97638a3689ccd6459efaeaffe46d9ee9895f183585879f315b0b3286d0d689d3cc84453aee48288db0ed1eb2520405bd8bc67bcfac16ee78d6c9076ab13499f8e0a10fcb1ad8d707716eccdd831cc60f767685582448b5b320e4bbc4b6cec72ccbfb74b5efff399126b987f829f17120a4cc90b731de006207e828739d2d4a0cfc70d9c534021126e090922e1482e7162d5424b3fea5e794800ebc65408cc3d6cf600a331fad5621947071f46014e9c66d93208be1650bfc93785bf24d00ac5e26ceece4e05eb91e94e1fb4312672ea1776ffb785ae94eb2ee3c70507fe68e5914bbcd14334754272fe9686d74865b3b55c98377b28bf7dc6819de1aa62d96edd38af08b9e5ab3b0db1f74b64d050fb1af9ce7e1f64033b1d41da3d04fef37bee71454091a05272b83c5ce6f4ee7d11a580531b84cd67c08b0bf4ce6df9629e47cb0daf4e4d51320cc40e7884652d34500069c3414613b859b792b7e95aab8a9bf4f1731f605522072a80107ac581dcbaed672546272e742b7b661d012b8eaf213a47065bf70a71f8b525264f44a283a67a7aa522ef05d96499e7c8e8aebe2351c604e1a30b77ae147433b75e86f14470b9fd57a457c6c3a75606af39f4ed111f7ae4028a658047c430caf0aeefc7fd7ea903303474a7154e2f8e80f7361d896297cb7e7216368e9b7e5b480e4956b66840ba31373ea134fb2c34946d638e64bbbc0c5d5e35d214b29d11a1d78b9c0098c0bf8a5d3f3c1a9b83d0ff0c510f0ca996dc7711c959033f326073bbfe6c9f2fd3d399fcd8b09adf52200352c844bb8e2ca694b541b662dcc70a33e172fa6befd1e8649a6da2b9e68fb16a81f3b1c240","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
