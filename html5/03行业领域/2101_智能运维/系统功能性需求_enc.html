<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f359c2c50451f32980c5e464485bac0b19463f24f4385c3ae81269cf24038fed999c116c5bf22c2c01292eefc2a118f1fdd7caab6c78ea451fb0866f6edfeb2aa53e23663b67090f487b7e5bc34f3f38648508713b13f793b5d259a2ae9e8ec2ef1aae44e32ee0fa63316776027040167caaaa38bb92a4f2178fa6ce2175e6268bf61e0691be08c528d027e497a80a168babce12c7f075cb93cce3bb55598539bf4c4a531e6febfd101ab128af90df2bb41c3127ab9b48cdc3e8f649a938fc0ce94e583ae2ac0037c1e44c63a2868237dae140ac2ae886026af77fb61535e895dcdd33d428841a2f3747eaa833e446f47cea2dfaaf4a9f00e75193e3b8346030ace5c9f8ad89bac4ee56f5d19968887f651b67a5b69b4c5d4143754126dab10b8e11ea57ac633932f949bb70df656e20adf309acb56271c64fd7e24d2d83948bbe37eaf87b431da36d88259b78ffe5882f30e7b206d92b255214bb4b9f714a3b918a6e1b13a352ecca19a003c0b8296392c008e0fb3c1ce0957e1960ab2236d85ff8cd02578c870ca0c7ffecd21a273e766978490bf8893abee50c684a2789010572e4c7916ef9c3e81a85d52d49269fa07dfdca5a264609e3f189dfa98e042260ffe8d78bb527a5477a0ac2543efba8a38694eb04fe973bfcd5b0e5c1bee7932517f46a40fdb5342479c6b3bb3d566dc4a0f3c052e22a1c8e1e6af41414f56e29d09e33c5e6cbf400306e76537e92fb4d3cdef4f400d4dbebaf209c8dca20b26e36f62174bd14fe009dfae4650171280b2424a9a5b2d4d5a9c9c6d2778b10ccc3d3bd112c380cc72058562ef08e25f673ec3f01ea96fbc3b3f700e250436ca265b958dc94b174d6b47553ee0fec766ef53744aa928ed2284532e0c023d68fda3dafc0e743996fe40ab667cdabcda46c79fda9955044f79b1d143c5d92e51de6dc2206785461c1fa59c1d70e6947b25b42d31eaf53158e70b89b5ce291d9cfd41722a32295edb173df805b711e162c9a8105ed64a156ab805f6418c485e534e6fe769743dfb5dc2463f5e7c8a9bdcebcc346fd0ae71066e4143fd30c5fa7d34070b58c588ed6780ad5a6ab345e9f5f4665bd11993d1beefcdeb8529ea91187902ba77e9aab5ef20ff8ea9a5ce23ce2ff7ed46e95033a2ad8efab9e7d745980becf22c6f6ba51ce6fa365274d02ea372ae394e6a2a335c5a521191f41e1e7a38de2065f4004def730935cd33ebb5c19eafad432d5904c391e5db2a4396e238372d2a915a92cb8b20ecdb93a4c65248c667ccc32e23ade61a87acaf4a7193c115f18a8b841f5336c86150702e0026df82a1013a728aef21a07866422091aa19d7018f5c8203705840b4c86ddde3b8f45974e15f5389b6039735b7d3d4a3833ef707a04e2070276c94e27b715bcbefbf22b6b6c739038282977d0546ef11168657c279b414ba82a9661d308e0cd417cc8f4a6a9b9e20cff1221dcc9b488da1737cd45ebdba183bae678831dfc3141ca05776ddb96facce97b43bbafe1ef339c641abea6f7808011614ed554c3cbf9906e83bb24da4f39ea0f1463513b9382cfe79f70be6f214b93a980eef64fd9bf94ffa24fa584ee3b2b186a250df358f824d04d55fe902e8777f6c7366385c9a0883b61c46cef7806432c55c4dc26dfc391dc8f3dc569abb994c201b80ed3eec575a78548a06093a497c3887094de878e2df7cb98c0d0f2b6655e089089e420327ca635c153f9ba8f4245e227e58e3f8b3c87cf2aa2e99e3398b3858e0852942ed398350171b50e2027b0b7eba943e87659c83b358845966b71b37dac36120ba4e64655c43c467f9e7d43845805158d6ac1d1f1409d4d84c54885baf197a24220b874cee7ac2416a3c3f75050e216063086e4d7920274e9fd52b0a927fbb74c27db8326ebb591959d5223e093648cbf85a23567ea3bf5dbaec6d672e699d09411417f75586df9e2f1dfcc9be7820300345ca0c148add85a5530d2e323d5fff51a5ed70e83d6525090ee45e3cdb27f4b11a22e4cc6f7d9e77f8be408d66a120bf82c4aa621f065735e06ede1902eee264f96e67429e9b478712be742ca78a91e7f32fa8b58da801dc71df06de8c49c25f2215f6d411b2a03b74f5f281d95da9e7c3699484a185bd0d437cd548bc6e98ddb313e7fa6941c72cce3ec0c1e32576f9986d441259b5bbb6d988c495533937f50eb44120c2aa5ba681598a5c99b2ab84eb70ca592f5d8a5468458b70a51dea96b6961c873ed1d9d2eb27f080a1ec98d7416797e5eccf7286893f5b203a9a44bb7ce1333c2bfb6e72faeb3fc00ff8a3469d70cdf25d3e3eb630bd878712afded7e867635316ea65f2a9109295d59891d7dc6fc68a146e3f0d731f58c8641f769905134fe63510c23eceab1599b02325eb55b1d7cf8da04bf4f4ca7b0d1c082481ed2e953f706769046670b1785273dbb2bf14b0afa0210280a99588c0983dcfe314acc5885ecc2034cb50ddedf8fe8f687ac6d3ac342eb377415b8c3dd39d87b11030f5dd9411f535c211181d9a3273ef3e860270591ea4effe5ede6224184a3fb4e564e3937e499e64ebe7d0a31490a23a5d2bd31cec0c5f3e7a75ea4521305c0c8b02bb9de0bcff5639f8e8acfc0a270cdec30fa0be2b25a47bf065407cf9b8f04d76f07301016ebe0d650d52f15867e49b87def57fbdc229c330162c2d6c9f8b6425fb631ef93ccc63d8b43e67c78340981695fd564c1ce478b7d8a1b3a517a2c0780321707742c993413bbe5bf5564a4b518e2584162f0409ab52dbf31b4f8d2f61773f9590249020b74f0862ea1252152e7c69b5421f9f30f8a585c4f0b8bc5d1e6b33357fc0ffbb2e719ce240e4c807ce35b0b6022ec85d54048868bf833c71f0c65992aec170a79b17b0648ad648487f6aa6ffcbf081cb112e9f59d0412725981e3e7f98c62d0f60c1b4a80f0621d9fd63dd54974d5f0b2b36bf44cc3f7964d312eeaa5d84c3b5dc6011813af1102c4d551a2a7019918eaa027acd71b5f209dab4b6779227053093b1fba4dbcb7579b5f795dd5dace2bd5469bf478dcda55ca9772b725ed7a7a79e3ef709ef0fd21d8dc81b932d0b14dfc041519c4f2265e1131158497f38768775302b5c5f489a67cc7146e553c5145cb21912aa01e3b3b1be730311d7e5a40e51b277cd83bed6287e2fcc135cc5e55ea4b1c0f44f4b11a1cb7f198bb37e6d353e7f95b1a894647cd445f4f9bf4c2a832e1d605508f4c0fa3fc2e9c932e88e1ab6b1c91018e62182e8d9fe05ce65a3139b2e74094f7910b16f780f3763b61d58edcc53061d347f47cefd96dbf2f47520e33b2e8002dbccae347f42749fbebfce920c4ead509986dd9a87707429f3eee2a5d337fc89e081f6aa856af4594787cb22ae1f1b569a15e27d03017ce1fc272355fb513cc8bd98a62958f1fb3b5f216a8d044ea71577c4100896a7cb69034da225a7906649d6559d9632c1991c1b56a6eef969a07c901f46cc26f61222222341887440b5101f498629f1bf2b8baf4e613735614765c3e5c04931e3f57fbbe835b660a1615260c8b8efe4b94a7ff59b4d376c3f6ca591d3e7ae01ea713e6867cc8943cacb3a93c1d160b8d7182103456dc8a5a38bfdde8e25ad7c50ab919dd85720c8c7fb1b533ca4a1588e3b1d6667085e71a27aa8881a704f449e2001c243cb073d8042bd27247027c24e9815277ce540fded466703f1573468421ae1cda1464b56c79cbff35bed3b145c3e27e7bc21845305e9e4c3fcfb2c85ab99ead6157d865a158a3407a40f0075f26bf6d4b0c84cd201b190efbed11999558bda0610fa0f1d159cc24f2daa7d6449a2da1d9700fd94d542b8dad081f348cb20a02233acafadb54fb0a489e2d4dbe8da9a60200495ee6bc855d2e50ad0a0948ae26b3534cf2d0a9db63065b689df06d43d1500318014f23614f6d62dd85399979bc8667b592a3db9b137bc49b8d109909dfeb938c041b7ffaec79697d926db3b50dc326603c79303af1c588302133c4c320db13720f0861871b77ba2cbfad72d35132f8d1b5b87b70106784ac6157da71ec5bd34240e03b885efa0da98d7280d9e0b897304ef0c74a04b96f32c73251ad07b384ae742c2bed11024735c55d1710f6e9ec66de061d05d79a82c9d2704d2348b83d963a2118376871d924bcba9dccafdcfa2ad6aa8c3102b9e416fa054ab75495d95b43b9df3bdc8ee7aafc34f24d96bf70fdc75272dbb8461657125fe2baa817c230b34ebc22e881aa1a7f14fda3c70e8a4fff27c4f5cb23d0efa18b873f9a003ea9f5093519efdcc9fc316f130f098d49e8f39f37696e471d4bdddc5988350b4ae14c727fa576e9ef9d14976c682e45ec59b72ee0de211f2ff4ef92393d1918f119d679e2d4c00581e7589d04e4fb94fd80011b97ef86664a0512207dddcf5e074a5e3a230225b64560a0f12c49e0ef7820fdce61fc63e56e5e2dedb4003d0a2a7f644c9cc5620295b5ede9fd2c89860d8970114706f3c7b1dede700f13937ba759692bc8c5c41a2f55ea54ae8b0d1e9b07adf8913d2ca22e211d67373ce528b2acbab7c76b22aa6a85c0df7de0dcb07e0c0fd308abdb6dc9f309125e128c396c4eb8afe2a01e00417b65caeb5989da11f804ea39a51ca2eaa4360e65d1169af3b99de308d35257b4f43afa3891b610bfd5f902b7610055ebec5704a68c1d93a8beebd872e1c9a31d3b3cd865af09ccd0f0fa2b06d3c067a1d974ee53d8a4626f546df53d435146817c9d7f5e77b330f6c740b8b8cdefef00e467ee8ec468c78282e3d6794d2210bea0414006a3054078d6e07eec6d2d8f6dd8cd2b61c29d648b3e8b88d5e407a1a5d3d100f291c4f48bb37faf2c6e992737784b6379ab859737591ab507d7ea8ab62b810cd7aa3881e4665dd37de9c91b6ac9ea0769eb60b7d40d39dceca342fc24956c0b0fdaac6467746e1e3dcef1e7b5ad3c9f126c62dfb3bb41fb7009df5625cda57cc34f75eb7e6fba7e7255a0222707bf0492964eebf5862ec164c113647cd5a1f18d829a70be5ad5aba5001ee95d0d3054f6f592a95f89834d7685f3ecd367a65b5ed0b247aa91e11e3e7b589cf3ab447a229eb944eecd32e4cf8d4ba7120c8b2ad3d8340a2546a02c65c87869184defc40caead60d3ee4601a82d358791df9511589a96da9f274b1468b9e035619c0daac9b2d1c1eaa4914ad63d9c1cf75d082fac6b4bc145f5b91fbfb8dccfcbe1e0dded2adeca4aa6d2707ebaed6c34f5e9bd310dbfb398631ab7bde4d2fd02ddd442b34f27f08a24870b066d4a984b171b03bf4a5bf7302ad4e390147cb822f2d41d94a478cb1eaf033378c0cf6bb6453ff76229354d43e7d545ebbf80a0c5201b084bb478b1f6e1b451c2af9296fffe55fedf0b1251da3bc648ee1ff91ba93216c8327711a52d6d9709ed8d4940089c254dea65200ee4f928774229b040328dcf1e462eda9f9aa0ffcd0eda1c78ef8470479d4ce9145edbfb9a499d3ae152d0017bf39afa5268f042d3fa0c6d7534463754d7f36d4111454818bc46d6ce702b4d51531560dbd51f59c1c07b048ee63b97773a5a3b44011de99f3985b8384bd8b2e0d6a99bbe9cffac036bd55509e879971f0b76a546369cc3d0dcfd0c7e40071ce80d835b74a6a9c8c69f5ec732162ba7f7878329c473d7d80a34f8623aa3d739f690dfc3db3bdc2eef0f8a33210dafb1b512e1d30f14a66a718d10937a382a497bb6dce333c233a2d70f90b212dc1d570cb4cf1e6d7aa72a2b211674c37d493b6bf8ec23d6091158f1d9b148a14f15745ef3ea14b7ade6927be401b45698094dbcaab5a8ca1b2aba087435f9d3b7b13f49c66192df54796aaf540c96920c80da7faee7d3f7c41e1e5d892a047adb30c727540cff6f74892a6ed6dbf45b5247318fcdb9bb49d6a278f9dd4a7489796c004e0718aa0f3b50dd8a8fe84ffbc220daa72a5281125003db765e434718f0af7a1c5fab91b5c04ad34a127a54a7f52b52abfeb13f4a710afd185963ec2c3f9ee11ae6b01f84f93deeb907d97e8056a4712baa141381ccb8a48c0eb0ead6be7120ba561dc90b5e280b44ec2a40c00838d0b16dc1e4360c557ab3abda649f51e0b5e13a3bd7ec6629f9d9e0d21d00408b88119b3153fde251c673f7f917d2cf5072cddafde92ee9eabc16b1843d9302333c303cdb1c9f90ebbde18a110929f90efd2b71e0e76a32e533b09ad7180e0e52b4a79d8ddc83e24635d7f5a8ff90cedbc648724ebfc168e5349fb59ff5d116bdf0bd6ac8769ee9b7e4fd2fbc6ec0507bbc17321a890d23d3b2d990e832cb6c897218cc3503eaf802c6154eb96f68bd890aaa59a783e3e44a4d88c25bf490692373aea7bf85a8a7b47fa1e7e80e0c8e0a745f9f6ef2d7f3fac87b8d0117b1a00c5939fbab1693019ac5d837c34179fdc92b541fb8901faf70eaff292c3f2d31cf2a76d3a4ee06cd66dca5d84a33a6ab57e6d868c2a977971e3be21a65efd06ff46ed42ec1eb20c2f754c684c91bca23631d724a6f15ed3d6eb6794ecacccf82a20159d9099b07e96d424e33156868de7f2686dbd71c2e34f5e1fbbb96e0edd17c6fdae44560dbb2dca42b02cf8e3c20b95615b5f7c29ff2e40931adc7d3debee460c30b839175efea57b7fe773c947e9114e8d8e62e7251cd759525884936df05f37444156d6e5decaee814bbaa6b069df1a8b8496db8ed9fac6a5fb40e874de34e582b2535423f389667d3b750afcb914557344923416400bed8470eb2104f9a47d1daa2be592ec8fd2ee05dc2adcc7bd313014691c9538166c764bb964212b68027122773d14a139f6ff2d5f430ca9b18f75a6bd7859fc7477dbf86893aa4614a8e081c7b1189ba96d4cd517bfe9b661818acc5139a2baaae14493afe80cdad202dca04473238a53b0717775f5e0893c2629a9be3943e8ba0f0e0d5907b789282860abf601c7e9004158b30cf5f6b03077ffc2282ffa2033396311e7d9ba2c9f00df13d851c0cbd4cd18c9097751620e349b7ca76dd4d262c82ef3eb5cd4fef6639933a7329dd8d0a10ff0811aceeecb29a7f64d65150a58946ccfb24c6861d5f6c9adfd7c8e0bc145db1790a1429529515a2c20105aab25a2bd52d3ea618c043a83f19cbc980eed1d068a0a24dd3948c7091f5cf04c657ef635285bd6a2dc1d02d17dd49aaeca02f151a8b9c002908d1a7895b6bd60deb8c4270800c634cbc522325156e4a8f69e663572d9e4eaba5872c2e6d7476cd43556c40e55d1aaa3e0db05d6b0976553fb6e1fd1d3590286b09df3f3cee00940e2437da0b5a688aae8b60cd092e7d2b3a6dcec9e92f1c690beea7dbdd83514df1348be67720c81cd8a275587ec7ae6a21131f589616fce088394b249d5f4943ee077a0a455d55ac1d66b597d7365c6a03a99775e8d99579a13c5cc80120c80d7cbeeffe6ccb43314d7782fcf253dbdd07ba62ddac59de6df10c3cd9729dd6c099a16dae7176f7b80b51a5b4beb14eb9255f11ed24da6e65db502f55bb9ab087ed8e916c1bf16f30efb8845866663498d5b6259e8627130ce3f39361b06bb0c9d6aee422fa975249ea00deb25d50bb9b3c62062d528473dd359eba635c950184f72dab1b4e3297893dd4ca30ad8a20e22a0a70856ada620ca138b6656eb1cd4473ead310b053a78f5c7a0b85233128129cc3d7eac27ffcfea8e4a08569ddb39d99634d8143332f212ded8712fd78320f6141158b76bc15149476af91f18d6663a5a45f047e5e9909feb3accd491a8908d3c9ba5a01e23b7b5978c88ac3d4af2bb420154a9ed13be2d6b6f37c389c77680f7c17102a661cec99393d70ca8e1efdf8672aa4e86bbf8b5373274ff508d28485ce1ccd1427b028e8a4c7d9f002a2d396457e79ffa53f66b8ed66f3cc9afea36cbb2523e53409f557904986c79c1315632f95bd5fec07d3c47132f0a7d15ee250dcc9d075e0327109e9e03c298fbaadb3b74fa7593e5fa929ec9a6b216e6566e4d21bc804e2f3aa7bc2ff0b2c1534463179589aeeab4a790a69eb7fd63ee530b4031e61855a40f4b4125e8ee5cd9a68bf49fc31ebf0468a63062fc234ca871356dd3ce3a61f50e51070f00f8ac2d6b899dec2803bf658d458532fd149f3c3274691d7f2b10bd6a95e7c5e9b4b0226cafb5d7a7ae426f5bb7f88f7d4e806916ac0f7f797a4b154dc757d641a150454a4957951745f5fa0e24e5e07a9ec22536e1b70516bbfbb333a7c51dc4fba27c99ae7cc93f0e06334cbdff92c1803a56b7390b1f67cfd4d4e43a5d37eecc7627ca1908a6d461ca75e25eca8d4042f16b2009084e7f18fc353c4f248473dde725f511e29ebcfb3057c4a5cd8439d6d978a0ba452e6434762c03941210d5f4d715577dff9be7177da5f6006362b982a5c74d3a47e02ff9975c8377b606a5d0597513d8a918f9347412eb25f63850e8a1d1394dc38d6f46f63f7fd687a1c09df7fb2dd025e953ef815b74d283282f4b4dfed886394c0d0ca133868cc359df48942cf81663121aeba6ec7a9204699dfcb5744a9f845d7e5beee2210d8708fd682dd9cdd2645436258d8d33bdfbf19b9e0d135f65ca716e2845671ffc0931afb040c6eb17532637e33fc603a1ec97f0c94d18b9aa142d10dd5c7731c148e9050411d359741acc5d459fd07817a50f45aca1d66df8bf49755cff990278d50a531b71f9a13b95a9dca246599c8e8632d8bb43576c8385fd396f63c58cbf6266f6ed80cc6ee8b93fc516b5cddca8cb8194b8baf60ec53cec5240478e28cba790c5012fe2ac47171a61555fd00041bb653e453b0caf6db9ca3df2f18c4a4ca6241ffdf2c8d0969137ff88c016cd4e1e4b02d64efdbf3abc44aa2bdea43d451f2e9648f32c0ff84e13f37c0ee3d795c2b0d852aed779bf39b18fca87bdf60878b682fb18bd3ed9e58bf6ca6aad0ab2442541c3f76b3137a8dde84d34ccfc758da0bd5e3a07fa0bc90b9acec2a56201c9296f25f74f7a9c945092d2488bcd7e3ddf72c79862d96eb27be0b8c189b75f3793c54e8c114869f0e5abe2bfbaceb9e8c85655ea104bffc6e9b9af014ab45a5b70e5a460a8233742491964340b060d59c2c922b2723f8c93a3d2e3127dd5c676acd87321a370a41dec6d0e508452d97a2e449bbb1b3029aad868ae6d8517b0cd992120d75a31ef26f9a3ff5bbd1ecdddd2050531eb7c254b2efbb3e4f5a42f7d3ae3aa2647bfc8c0929b0718ab130c5468df80e3823b325c1b95c9674ae074263ef6ed3db227ffb383101b46f50ef496c994ca31e4d00592f1dba5fdb14a17fbe81447f42d397813f413cff44ab81ca95baf2d4116bcf46fec47630cfcc737d909cc36b0a9d559c6ca2f57240c7c8317e1d49523b3f73bc98679167bd21ef97cc311d87d2459d20277823ca877fa5521a60c5a379a6cc5e15282d7a93604add1dce73d57a17395f412885ebce69207754ff1603c132bab011ab835d24513fba7be2d4e196acddcc4d79480444c05bb2b8df27ebecf4ab5fc1a5b7fd8b83928b87ccaf5b9dd09ac98bb418f7df8c5bc6646e4b9af01e47d6565f2e1c20ae4664ec9036e3d11d3155fec495da71a06f17900d446a249e122ee2a8eaa9d5018d17ad60564cfa45d1d6ffdc1f33293278359420f8d5f42d91ad5f94ef59a8dc20024471a9f8fae03ca916ea7f80c4b281cefbdbc61dd4ba61e831c18b6e6f9dc66516438fd7cce07e7436992342f4a45202736732441a1607d3ff06866c667970f094ab4209c54aadd1a00f1b156df06f3c01c5e0a80591ece61f2e6f5f106d980bb8b7ce23456c1e3d87dbbfb5de2b4394850c157b8170a7d587af42b2a8049122109b5939eed099cec49a9f50fa30145504d586b15f48e859292fce1bbdc986b87a1b5711c4ba939b13ca9e8e2754f0beaf4c2f19bfd1b4d889e73ce97d778c016dcf672ecfa8b3aa5400acb13f3d05892aeec16312f7f1501efc237d7128e2d7a935f16e827338142b39ad972f2bd8529b779987bcb588a599e943b62b703f31fcdd94a7ef40fd597d663d0f60ac209a25d4d6e60c163d73cf379ff2a4f0a41fb4269fe4441b9d92dcf7dacc039b8a32a29b060380c24816598ef683f1a1a7a6ff42e77f6737c0602168e5c98b0e5535cc6cc154bc6fd7d30ed7d4cff27080cf4a66982597fc91b3be24c3d87b3a467e62115bb9e651b4af429f19058b777755f68f29c5e7da73aba1d602ba0583e74d7fbb4d1d3e480918fb8c1a1e5b27bbbf405eeeb1172140ca9f6974ffbe4314556e08455d398371493da33521c71a97b9ebb7a2333571521b1ce37f44956c07e6857817e818ae7b9d219d032c98a2bef304ac03112474051acdd17b53f866c1386e188c13106a60189500950ddc565c0eb12cdeae2749ac3814f430d6732b1af49de9f99577a22ecc55fa22d319edb84489006158d9b169c6686d92e839c1017137eb27166e5cd71cc05486df09874430066b36dd804cbb14bec9d47406e65083454bd6ae7597ff3778ca97e07d2ad00e0ea288d71337a5e11ef3a2ae6467d9e65443a320b847d1693b01465b241229e003e86dbe572091c4418a79df5c67f83f04199bc78a63182d263a0b010a9b8227bfe78503d5ba2c617e4a55fc7be3ffcefec045de02ff60e0ab087e08efc15a674275c6087bf98357ff0888c1aabdf5fd62a6cc6b06106537eb3df67e396e1e75d78a5508919f91efcfac1d1134950b20dc856ac676cd9aec2483451c1723131f78ec8fe7d010c4e4cc77de12a3dc43705c25de827d13b891a0267c10c35a1ee8dd5be9facc89cce199a7639b53e6beccd410958e092fcc3969c221ff681ef47ece4c1e0359dc1ea1629b97ef95d719398dfd31bb19a656e8fb231d9d346a18f8ac196bc27dd2ea6a276f6c8ceb9c977c3c959d788c946e9c27468e40ce601160d89e43636aee61828e95f3cad28c64d668e82ed7374dc4e8859c3784d550e4ab61bbae0bfe10484cf52ee91fed2eaded92f70a84cd735598bfd6ce1ff284101a17dae48d9353260889a5eb0961d1741b82475f19abe1f3e6f805a319618cb0ca466c2a352718e2c6a3e3dcb577966faa53f2fc292f67da6a4e7508c2039b4a659909eb1e39fbf368687802145dc2b00be4c4a335a4ac1a05bc55c74975c680bda2d9c65058baaaa82ac6eb450e9dd04fbb42432b8c1f91b5a825ee0423d3375052d2563cbe733cbaf4f8185abc235361c262d749200d2abce96ae67c746ca258fbe36ab1f36bc2e7bc65f697d49ff66adf424a7e63e2e56b186808aeddb814d572f552d93166a69837363dba9dbaefad1f54531a047c270bf9c5d932053fb2c91b275ec20e05d1dbdeb5adf43a1524982d17aa154801cee343bb67e6f8d8700fb85475d59678b61372ee67cfd1ba2b39f755ecbc4d95644a7f864a27b6600b82f3d3f59115e7fab165e9670166885b34f4a73a1166980cf2f97038087070331351126aaadd13e24de4d51d924cc1ff20dab69d267f9d9ccf9f658363cd754fb147ece7638312eaf8b45641a92bf7b586eecfcd15d717023db93160c960ed06c8d6975c3bce23df65d736ac65927662aabd434974091d36d64cc6565887af49f59e56107b770a0de61ca31cc990c784476c6fbe09210d860a0241675cb2b6d0e609ac27bf6bf7f165ed0af856188a2d024c87914ddba48a5889fa68a94822a19e7c9424c482dd00133fd590dec1cb53489b248841a72b66ffc2b569ba45ea52f434d36427aead2fa53ef687fa21797e686f6e3bfc795ad996159a797f0e501bbe13c1de1d59011623866cd3c06362815fd5d8f9e6d3a7baa1981cf27d9b1c7ac79fed11c79478f99413c048c269d490cc60204f875103adad3a9bb95e3d96dff06c0984591425919b7e9a39fc6cf879f41021911973bea0957f6a04e7f429ec9c22a08b8d95622b91006e850f8fffa7286876e3ca82c491f1bbd9962e6b5e066ffa38662ce37735a93e52da62b73fcfdd1490913dacb125ca9bc4aab11000e31771e77cdf53709797356a8d39448daf9978dde2c929e3c14ff928e3e3ab4f9f37f982aa10a8c1f0a35d7262a5866bcc22f0aa0bf7838f84037ce3db952d66454c0ab51508dcea05e9aebd94d4c1f45bd512d2a3a8a52e53fed09aac3d7fabec919be19e83e7f0713f14572f77c6a5f86e68fd9d085f314d779426ba4e07d97bf5d45976dce34dbac738648f0e14a1608e4dab15192fe57836a6b6cd00a2cd3d92200dabbc1b4fa1687153f5b4ff3b4f59cac0185d12d55eaa9b68819ca26cf098490b9100a39a8cf21f3d8e1c0977b3cc8797e11c38e9f9f64c95e12bc7ac5925ca19677191d72f5646dbbe3edc0ce366e0294264dbb97813868fb4eb36d298b8b9bc78fd6ec2afea1a36d16403c90ea913bf1d3e29ff8f1d89111e6f6063bb5888f83a52c6cee6120f3dafaa72ffc718f84d2d079400108eca269bac49123f4c88a5f95a7f3a7bcc2b14511a37af090cb8847e39b67b6fc056d5b0c5a4bb0bc4562cd54eb73a9a7ed4982a3f11f964637822bb5924fc650ea350dec454f7e14df240e019b1645ba7adcbb3b0c55f8e7b40eb4f3962f71728c4cf83b1e37c1bc46cbd3de75f36dc0e2f2348f003ee513c5794538e6352853f16f0efb3f18eb6271dea120f16b9f2edc2a1920665b4912d0e1d8cea960b007e79e031e3657f967f6de0ae8300b24d5697cd3c06e44a1f05ae3416076eddd7beec0d0d1a6962829d6c80ac0d22d1d02de6578d75fe502f83bd33a1a8c86a647e4343a006116479b149c2a14537fe71b49db5d8567488da03481b15dcb9ebe497547ad2d81b3eeddaf09ccbb295904079a0219ca82cf2092250c6dceb1f76667b8e779cf6f2cecc29434856a18bdf4369ca096147bf65eb715706b3bf5ba6cdeff39a94a68fac49110fe52f3a67fb2f966996c75942a66718b930a80180b290669cb79c81ddf9a450eb8f952f4d1ff87bd4e946c654bf7c7418f48d68a04f60e9fb6bdfbc7368f43934f1df38efc550e8ae999b0e485de580d29eb9bd2afe3c2ebafbb64740e3e460c02e94544b7908345189a2c9899dc67c68d0741064b453b6a914325796b7e8594ee7ac2ad6509249df8ff930bb8c2b7da9df63f3ad09ab868fcd2c76b57fd7c08134d7dc0d39321747c920478f5385598db1317eb586b378ffb71c66b11d8ee5c2261bc3f6d0e62390d1cdb9a01477f79394ddc16d346bdb21c8fae615e3176e6f5404f1281104167f64c79da0cb4c4bf828e7be1f84b67b63a246d51e46a8fa6122d84db2839b089a0d0d072afe699a357e3346d4e86881b3dc2f02d5ad3a753730ec3b841b514acc2d3e5377787f394548f610bf5477c43afef9697220a0331670a01e23cac796bdb1f9fc1b4ffe6a2b31681dba122d0615a8519fd0f589d7fdf95172c7a64e5d898865e2c918f09d6f6ee7d9b1605a97261c1f943492de3c3eafd8d9cd412a6b1492cf50137f446e4539077b6b467cbe87eae8db03622264e36e72e97f76c24ac08cc4ee81dafc4b2fcae5189dec01a41ef79ba4d2da7b352b416a33cbcef36ca7c49f6a257de8ace0985d0b377bd6ef85de849d89c3a7819c3b5cb4aa0e8e892296fbe559b86013d1de5a63671b162ca4ae0644397047421ce023c96e092fdb19a4895095a985b4e1d5701ee3fb7c233c44f5e6f096ac3866480bfc61a01eb5a1d37c91a3225fde22b309ea77781da0f98c677cf1d935c2d21a49744328774eaf12532058e5db230cb4fb6570d03a76223df6874bad205a82a7fbd13f26409b32aabc511c38b330f53ebba21e4ae2391b6979e3790ee5419f0b4bf7279af55dbe870dc22e850be9a3b01000c3ab0998b341accc1ee3cb656877fe356aa310955d5345c95f9fb85f8b32b0f5c00a6a6a7f6834d0a777f4fe724bab4980e2aeaa1b9803d1293c4564a4040421c4dd3534f75c738800dd4593c4009194bb29565c1ce44831582795e610547c709795caf0ae5a3da43a74beb1d03edda3785c0e21355e4d64e167fcc3761999f5f3191350a82f7e24d05dcb0bfa598804f7ec3981c40add51a567576683d705971428dc265e362a4defe05ab8d375ddaf7c6388f038106bd300da855b05589febd352086fd15cd393750dfc8f75fe139a50b09b85cadb169b34fa828b554277a66ff3a12bc75fd7eb833e9b15374596450123d71d131dbe735bb1fc870b07f4ae32f7d842df206fed42bfed26e7c64c4a21c60541fa55c400ba6b53f16e0a89f899cc5308e0f3c3388f572f27f05993fdc4d6884d2987c20b3e5310f665fad24a5c31a472505bcc77077afd298836bdd75489f688cf264321b3186dd7b8d8524b9b989fa741beb9550db2153d08bda91fe47f51f585bc54fc21bcbdbdaaec39cb943701f78535d2c4f6b650390f6ca5586c43dd71171d375d59f9729c00beda34cc6c3fcacd8c229cf67afa01186db74eab33a3d98836ba69f76a479abfe3147e22268ee7af81f104c9808b77b22fe0c42be65d0d77a490d0b540761889bed46341c204baacc1ce19be0602b3cb91dd46547c979f62c8d7fc1ba27998e54b5906400f90fd4f2be9f95424cecb8a4e663a8a0289a7a0bbdabfb248acbc22c8a6e8ecee2ee6bb7701290ad96b8fdd7122073355933f9c34d0c4458ce4c49aac28efc574a6537b508f4e43fbf89c7de439de4ba047059f4ae170334f541900493736c0f0fe2f9eae64dfb493671861cc04181a356fe54b8fb6138361500123ba55c0e8a38db7d0a9f0854dc85592452ec89c0f55f1e0b095dbf5dfef79140908bf97e036bee2d4ac77bd4306561bec716142bc50f123e5d95efc99933256eab986d2730c3354ea2be3ca1e7413cc09ef4546d589ef3c278f0e2ec7ea3fa17eb3548fece99cd2b5382daeae51bff02ae6316c7a7c3ece48ec68bf219b4e13ab474732a9572d0fb14f7fef04d43f009c4ba832a13c55854d764eacbb79baae978f8d731334b9f5ac9fd609cca71e919e2305724bd3367dd96690b960711a47fc8dcab179e5e6ac2b287a08b3910dd738e7ac8b844ba454025e1b6ccc4a1df6d701582c27ddf2300025a31e536ac1452cb63fb9c069671ee7aab9cb5efe98b4dc7d0716fa3f914f2ed46d82d671fbac00aaaa6b6ce51d0c7230bd1c1e4cd5fdcc7e3c8425ccaa71aaff45222559d5101207747d64d27c6129f47b789fcf74892355ea2e36339fbb4462303a71a73d5a37052dfa5420fbe45460955921a0410b7b25c509ce65e3ca569d97f64776759f4dbfd22dee38b2d3031771a59cf0b118a6c9f13fff619cb0d8ebf8878e0ce7c2b6332092b403c07b1556b9859097daa4c16c8dbb0d8cda8062922400ca9e55ca8fa6123e7f46ff79d381fd99c475c2440f6af50b2057cd630303fa6a05776dd988ca98dbb47f730e4763a3b473bbce5b1cb859bd5333a89149375dc5413702f1e9a7e324df44c58f214bf89dbc96052e16d16efe4b54a9af7a4f2b4d19a2148c4b6b53cdc723fc9c98670fb0cd4fa715149440d9c4b93b81a07815f45355dbc2eda292bed7efa2a001be2e356774d2debd2bf08657a1e0806a5411bbeddcd8d4924ed037585070352119f6268906c89c5e7c48ae929f55a5ffe46d8c27c4b6f2defee55e30b7619dbda32dc842c47fe9eee7bf2c73728d1fb69aeecfb917f4389ca3d4801d13c4ee20b7289b1834470c370d82ff7986a6be79147326b9d98a7b5d868e635df06a88a551d86d37ed0a2394b5ee52c03e93fce548f064ef659828db30ae2df43f105ff5a630f528d8bf579ec5e4ce48e04efb1b07aae083854dd9fd4d56d3d3fed9b33b0acd94acef3c677b6ab8aea2cdd4ad661e517a0d55f4cd7ad7d23295371d199f1c31cf3f6d4d1a38fe28e7ef7de79a26e8aec1af9ce441c7c5924bd57b0e08b645dfa6510c314f1ed018aaa215479b21bd9b7f17b379db436ea8032c1a98daeae87fdc422ad02ee85d5737847471ec35ca2633603af908989956f7eacf8f5bb3bf82d62272e447767f1d268730b3dae5f71bbcb3f57d72157d3ee96a83240c435df80085bfdda0ea6d79bb45156cd0893576ef9760d704085246b66527567ee1e1db63dd66cc3ef57e4cd780af47036a80834a3490da6bad3815ef80c69dd13ec8919e64201ca69696c24528d85e47b9ef253e299c924054c9f8e18cf2707e401d74d75569f89183f846d2ee0caf4ec141bcbf73bbe2b8b7bf582367a61cf3a3b835ff6adae360a27360bbc739928920b3c32af8eba8d8072431d0773646daaa78dc4ad9eb97d7d67176831143f29cb3af19e4f8dbc87ab19eca1c7f1bf42c02481cd6334ee60d895125e202b33d559279b1e170f5ec7f44110828cff486395ce19eb6fa72b175050e1486b1296081847296ed5396969286095b9b36762df8c1f97c02320b26a65a26260a3b7f744b7747e6419487d27b85e5412d07957893b03fcc38f3a9471938dec055fa12655d85a078e6512be1bb26700356d2df04a516bbf2646b8932d544638eddee50e2ab0297519310374030cc9f703d6062496f6967b433940062d2589e01f50e3378f37c95daf49251d9aa18d77dfbc8c49e9bfd98065300ff2ed9af2f7bf0a6f513dd58608c165af63c7af8a16d0c928dc7d5ff96f172e8593e49ea9f38e0bcf8f95d06b8a60adf8e6e386bc50bf3f32edfa69adb6bf2146579532341f93273e71c5c33b50f919e776caddc2daa3eb205d1b6ecb2740ca57289e068b109acf9d57aa56511a645be446d62768844a11f8632c0230fc950b7a1beb4444eb235b806d1fc094748af0641a4d01312099dfa09859dbe943ac211bff191f0eb795f9644f5640e5c7165e52d6f1f35079bc925d8ab283d51f53d6c6c3b99917495c1934a01c3b8f8c7bb7d7c526f3e714c0d4e416cfc31ece5d77b7d5fb48a28bf6d0ebf83ce856e16abd50dfe31e4f07d6b37c865b2e7e829d27c3f2e419c2a007b7cb2e5ee365b4f9a155055122d5e86763a8faad6fe7489b158394ecee1573a4c6f66aa7bdf621fb3f0c9f5375b45c30b4770afb3f02c678faaa4e77ed8d6b40669b2077076edf900ce683a131583fc67ac34299f514bdced75f1dd57b94c6e329e3f99399b5d90c084b1a5841e1098bcffdaeba9fd27f68812998ef97a149dce6a34c2ef530bf201b0528a129cfbb109f5849fff3e7e2fe03aa82d522dcd5af7efc3a1643ade9721d2db1959a143224b3a9c3d1f020d417e4e080e604527876d741911c0cbed09f92aa830a35a56690a5ad7d3d22af41d5b243c247ef4eaf46edba031810f4168f091d6118be74e07ffe208eb40bd48a0a571bf80565867bb60bdb9dc97e6ec5426c5e836b780ad4fa102f29f5759a269c407af8566084f8c428af365fa5def33413857060920b1a1f3baebb55004eac38fbcb9357e6ca1a7442ac809917d9b04533798dea60c621658a46cd671a7a8af8a1c5277860fca6f328e0276e442ecc3c94287dcb2ccd949ff1385c207dbcbb8a6de6daf16f3872b98a0e6d06cdf92b9e6bd86e8de7b5ac15cb355285b12e4c1c581fc4f2eafbf5ca7ded7f2f66e9b075f64b8bf992a2a4a4c202ead555b3b043bb129a56dfa463a085d93c5bed4058724d417eff11c07cb66777a9dacd1852f2ff7fa326b787daf91c45c728bc954465c003b635eb0c179e881d15bfe29276a4e7d7a44f4f032e8466a62bbcf8a72847866dc8c1a4f3ea6106f0931d29089c4ff1350337fb2f2642220a1c73c77902c61915bde2264d1ff75275005b6bed0fde18af726cf159854aa628daba8a4fd82ad4b86d9599ff9f9cfbabc64fb337f193388775744f7ab773a5c6fc635bc87848c00f668d80c754ba26943e75d69dc2e8a1b9520766d6111cbeb18a6a87d3c04135d2be9bae62227f70480ec8071b1ef437974b322ebb20253f2227dac0817e63e5c5864d636f0a538194846b4a6e4f7e96d3132262283351cb98b7b7036addf301dfe3f54e38cee4cbce25e3596af51e3db9828f9f7f1769a529bd1c2debc062489d5bb0cf99672c53b8574a085b2fa781378314adcca99bfc70eab3b0a7d32806b0b50d7e7f3efd7913c45c269e4ddf2824d243686e41acf385bba6925ffd05554a149a924ee6852ff3cc5f38a99d5b9eeba99343c821265632b5d94ef69ffd3416735856e1b01ed3dbdca93cf72585bca760a236c3ad7bb4d9238bfdb9d827d0876a1240cd841c53e48f32dbcb8b34b514888a6d5a6d624672f40e3a844acaf573dae91ecd206c79550626a4770e5be6dd8b09cbc547e2f0900d6891ea209942ca0e30cc178f6ff16cee487c998659139b1bbfa70cc4061afa270cffead41818338222e4d277bfd9ccfb553a35af064f3def8ecca4f78780a880b0a8cfa2ed8331207a068147f67d7f0e5d7623da3c521dbe09749ae9412e5615a46a53b38178c6d2ecf96b4c4bab1d413388d429e817d9343ba5612e8548ef96d06333362367eda1889e26151e861c5e7d26243b7b1822712870036604d8502eb77d9a925fc55a51bbe789ace5ec4b833c2ae684d4e71f07a70373acd25e5d09b0286127abe5c621ce6dbd34fdfdc72c879ebaef72ea69e859b906ed468881de6a108d32e2245bc7a55066a2809c4d070329407eb83b4c923cc941d567adc18a35c146375f1c350296402c10dedc9483155a73d0c757f4e2834f804358ec37978b8d945631d4fea1c728cbcb73849b23b43fb8cfc44ca6d874ec7b4caa5e560c9287b1b764114a0cd76252e3540fad3dfb2849cfb4af868fdee9acbba6daaa63a4f740876c5a670149674e195f9d8c6ae5f0f956536d5a42d4e6b3b573ab923126577b5266f29ccf9b968d4e7e83a4e39de051344f9e32958511f02272f58847b9cd9f6c1ccc4a5ce1d764c07e96783d8add28de2e63e507b6ba00dfe3f7492b02f0e5272f35f24c3e3d8deb4b7ca090ddfd36e1edd70144058c8e552c0682c3954dcccd00e01bc93d5f0cfe90d4c15ee939d570c061b524100cf1ffd641640d4b8b82efd767f58d99c99563ae4849ab032dabc4648b409ce6e1a38a376bd3480444a87cc3cdf8025493519a876cae69070b15b5679abfebb44850b20bcc579e1341e0453ac36a8cf6b722a8887414d892a623dcfbff5157c3423f4bddba75fa9de0015195118de8b1a87568431dfe76c202ae7c4f5e85ed9cd888a069018ab829e97de405325217fe2d924444458c2fc956fdf5da7261a0a592aec4af230040396bc1e64b08b0126c1761cb372aa113a28ad0d3e646937f06c732de8d77ca0261b104c47df00baf9e04a304447ef5b1b3ee4be060eaa6d48163905594f61b575dda45756a4a22fc11d62b4428e11b44a121764fccff0f10e01702e84d608dda9782ce010bdf24e8e7b2633e18ff9e971192c5745543eb54e643c8a93560984bbbe183995b4226853d9d6c187501ca2c3a7737276fe7eacf4d10dbde4e5d286f72b420d9ae417ab2aab5ed99e7d39b553d2dc9582c22480971b8d4cbf760c77cd63cb4b6cc30c1f0dfe72c28ecd6d57aa936bb11b377db0893f41107530b7b9cc699dde3502a589e891d44651c37d48bc15e00eebae66afb1ebd4a4cea8e2212aa44198f61456238703eb00d736722793ed4ef346ae20246474f12c9a7d5e5e1d752984bd4484311293bf6113dde6819ad5c1a8f629f33888d95ca4b329167e2f7829d80bc75e8b56551016fe80c11aab28c24a6564175b7fe09f2f78dc5001ae30c83314a7088c18e6b842beb56819ca58eb14bdaf2adb22e1a8393e282dbaadc30d0b1266b32ae0ca7a75b5e6322a9b326040b1da7b161aef4615a2f0d2232fec746b894071351ae7ed3822aba13e5c7607e04894710e23fcba3dcc6d03d0ca77ec944045a9be6ad426c63cd97e1b6f570bf8274899638c59a045c2eaad835c37df63192ef4e466449a8d3b406ef5e31dd9a51bd4816bf6158c0b21f073f78d6f4d534d203fb5ecd833142edd13d320dab83507c781edf875708e24407a743ef9a4deaf8a284c70ed5bd75bd1d2a0842faf08e99d5946eac9f8bea1b30e06294d193d4eda7ec97b6be60dd04196eb1cf8e76d8f62d770aeb6edba3615a97f85a94085c4e74e1e4765bc60c9dec018029268ec9fc58d55e8b1dbe618980f7176a108ab80942de6cc7f541db3f768b7e648c25516b66d7ada9f924436f15761d0eadbff576c563acb27e151a24852e4f1093012e6b9ecd4f699e8b99309e02619da321b418ce7f14f619bb57ff2f12185b635b570b452888636ac5e751717cbe31af9fbff2178dffbcbecec6a863521eb802361b6ead90ff1f3669ddcd68ae06725f4deaa9aa22d2cb1bbfdef2d3dfc8570eb50d43b7a9d51c8649888e8673bf8715e01ce6b340ddc82a0444bc02d95617d18027e2def6ff6438c2e4f8675a6649e9031ad219720894d739b1c01dac154e5de9c751191dc7f4a364e522e1f82271a5afdad7999a809ec167e4517b9c508470525e2868d43eb058fba78e7664e1f58739b1d1cc009253f6067c27d55d40b8da8dd8bec62dc4cce1919b2550d3ad555fd875b5f94f3fc0408db1d469af0883215ab894c567de7f9f944b10888311de43301b2108c2c35c288c3bec3feb9978b84e566102af472e67e2fd27af79c5428d2604fabf824ddbfdfabfc9bb97b82fc0295fc21cef921689a4c7fe4ea9002a2a6417021a49768bdc98bbc9417cfa2bd473666bec3eab828f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
