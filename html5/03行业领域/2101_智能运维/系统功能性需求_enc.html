<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2821a1e09f6f7137bb123c6a7aa535df1c1caeff01b65e35df607c7fee4399247a208573fb7cb6ad6033bb1d84a6d632e12a60860cbcd847c88eba08beeb6d1057edb8814845e54512ce0998885691ce2888a25194256ee08615e2dbc04d053bf9908f94c561bbd5081b9d4d874d901d37c250662036f18d83b716fdab99dfad8692d5d289fdd0855fb42ef06b8b6f17e59bafcae1496360b67289d6e9fbd9d032d6dbce1034d3f34cb30dc22e4b7b3d87ecd792f6e2b79c187db558baff527d9a4d41168332aaea1ff9adcc9d4670233bbef7a113d5a9e92c5f14142887401f6f42832d445f59f97b967f0bf1b86f0c03b83b7adddc2249f5e4317c0773041b05ba270f119e23df3338ae4a0ca0b3a2f611e31a51f6afd07f39f3f2b70c8d1d6a3312b2bbd3085bd4bccbd222fcb83973785602636331805348dfca8e74e0f20efbd3704e1abca55c7d1ba93b060e4e3747efc54a604756f504a4fbc14babb9bb30993fcad9697350b9f3f854810857a3b208e4b18a050f3606fd4426a055a1fcfac56ce23aeb6e54cf02a40f59fac4876a22539aca7d7022d5bf990e6057db8be8f149e1be6c74334f58151b7070e66b65847d1a8c23b801ed21ec9795f9a1c3da55ec439e421ad9887c93d2565f1d98f3bd1d06d9f4b59fc5f1721c0e92240ee9311f903e0755c0738c49319a1e2a41d644d4704c40e9deb21aec47f1dba71733e567282b787699b6286bb9bfbf1bc6bdaa79337ac0f995ad57323395da1efb7656247d244e9e6f80d566445b1d5a6d07e22c1931bcf48236287105a0acdc2cc6883313c139d50f0e7d1ee2a783d51d05b469824ec748ee68f9722095c163a849c6b2be0567502d23b11ef09d8ec35e55fa72e4eddefea883e0b8501cd773e7a483114ec20f9f22bfe9bccefb95db5152ce942a543844445d07698e7bc71b171d84dedf3ae5832102df46db5ea298e73a0a71fb07f95c2917e71ba165e960a1d5e88ba61b5caca1a4c0fefdc157ed1314131dfd293669ef6ad3353f5ffb7f62209642f1936db0fc1793c43adec88e14e186290d3eec89534f98cf167618c2d43107671e1ec5df339a754c9dd575b97e80e50d352915119c721fefed2c439620354d9545ea060cec58529e16c9aa0fcc576e2f2134f37f7417207622cc8f9e36a31acfdad5f72e0f1b7576162f5beb809f692e82218f75b743511efe9c4bf309cd28013d305684bceaf69d1bf0fc4961e4f6a90b1d0dba83e58cf88a01189fe3edb521d08973422a07ecc9afa7221a0223cacfa594dbd56aa42ad07c8d705081a75d06a4114e30896c39d977606093c779dbab55c6917a145558ee4e41595b054d65ffddbed7da2f73585b8dcac3c54b5588b9098f26ecbb09fbe8f029baad87746439e2f1fd15f9c398a7fbd97273c87b4d985ca99c5161c8ab80c2ddbe5e0f953d99cf4944af7daa9e24c3b69115fbb7eaa17339d72b66d0dddc3cc107232808caa38c4dede5273e974ac4731fc451faebf33a93a6bdcdb3e4e4fc8c58c36c4def3236ebc99d667e0ae1e829934ffefce904db5bda69f7394ef5578c4c10c61122d86b3f9fb53eca70188b7c409227c5a14aec2e994f92ec36d16f90baa4072b300fb600f2fd163b65ccb60d7fca7f8914a78bfe7adbffbbeec42201967df4bd8d7f635098980f7ee2dbe6b545f08c581cb9b4782223f18bb1902879dee7a5c2ae499270ed7c115d990c5add91d674db9aa94d286e39fdbe588299bfe641994c89ebe236eaca49a8878271d5b00c0870b1c5b92f52b544a131722a3ea0e20c013f169387a163c06caa1966d08fb069db2c9ee63647ef5f56dc57fa93982a489bf640f9b8b47c9958a2b96bd020496a2de5863e890f85ea95dc0e72c13bfff0231fa47cc1408c30293e0e635ba9786d7ff14ec552c0b5343fd93a22d8d0203cef875b5a91236b69b827cb5cdd92a4c7d7023510a2d9348673e100712f6927e8d3a923fafef07c34d9121bb8d6b89908f8c81994e022b13aaf6f771717b5ccd0362e75e8665c65b4f4cf95d5f33356a47790c19e80959f68d663ba915bce2480e9f0afe76fc017bbf7a80e17df3802ffdfb1269e1acd3d595e4063106675dc50fc27058562378463894c890afd46d79d2f9c8435a6e2f6b8e48bf12cea26e1c6d36312c2e94c3d7c5aeb05e7a98e42353cc0279ef66014668d9b0429dcacc9413907989c1e2bb4b8263ecc0dc416967917c10aafef0f07e88d60c99ff77a0658534a2f3fa064c47f0ffb4fab1cd817bdf4394d504f7a928262c5c2465bed346ad50a73e0fd808f0012dbc8c6e10005225b8221d5f08c1866f1b40aafd3c103ff31fb3c868c05eef685e4acd982a7509fe700fa5b54a886557a7b48cb2c13cd920e4ab2639800606099913a46b647fef8dbb38d0a52efcc6c4ca6a53d2162d6e2a656510d860124006fb489b57eee9ba3975d5a24a33c3e368f505d378dd135833264c684a80635443dba02d4db4161bdb1d67acbb27bc2cc59522a76e5019b8afa072b0428c420ce15846fafa16e7b46ca71d2809f43e3901b6bba80b8f9a9263c7ce144617e4dff31719b57cf16fd6bd4d587b2c58448c2218020877f9a32ae04f7a02b2cd2e3212b34650956e14d61e3b546959e0c0fc01dec15251af2ae46ff5ec3fd4b06068db06b297368713502488d02df461f8ffd6546697d90fdf4642e5b611b18a281d409be9655be212eb4d5a06d3b5dd355155d72e092c48529fb3af0c6c7d854cd4d8430de8dfe3eb4b8954b252f6d2e9a5028c12e0a1fce3c9f380da08fdda1f746ae63f5262fe1c021732cf5ede82d66fd72d24315968956d3bf83a6f24d51a554221210b4d5d48171f1053ce51ea9d99997166b9cc9ae6fe561966dca526ff79e621483365cd542421fc9f03bac73fbb9acb9508468147b7d31fd72acfab1089c37018bee26ec85b6f58c4f1c71816321a94782b644bc66dbecf517199d0982aaa2141f7fda8fda5aa03eabfde2bb861c40e67c4438366edc37cd0a2c899bfe7cafe6245bdf4c33732cacb76c1109fadad6863c8d052fff5a85e9ac39980ea0ca6bb4e07081bc39ea958c6296c6f62d16815a20eac9c3df00b8c238709d165872c3e04c0cc77cca84fcc9bbe9859dc6ec782bacbe7b1af43db58e086bf590e90ba0ec285bd8e05a56c0eb25806493484e5a362c8bbe4d322920af6c590f260784d859c93a0cbb6f75f0f93d5897cac8f197dd4b2625110b82e56b62650f2dfe2a5440c6fd93f4867b72b471774822e47afc3c9eaa243f3d5f1f8cea3f8bb74713234c01c9770e35d83af75f00bc9ef7f08691f196b196d0752792074a638739592de44de7dc9c6aa30645eeff322d9ad3ed817f1587628c34891f5b5a9b494e3e09e14c52d6c80a72b3e888b41f5c551f0707bed9801534c8a30fbcfe8be38c303baeb51e4dba1a0fc1a4e14c5b776eac82aa6b764b164cb421c52b52402936d6b13244cdd1bba787d81188340a3b550f960ecca9ee9b1eb38f738b6abc62c15d6ebf104e0b1ad18fdf7ede1d15cd57b2a48f9bcc3cf65b35f0b47bc44142b5ae98dd1ac21af85b34c86e68c52d5eecd1bb8f26554bbe37b5949337433f8caf4b9a36216c34abe8609157152ee1c2cf86509af3cf6f317e1886acccdec176db923f3d09f7f99d3c7238b4986bdc607c37a400f12b0a5385e0764d937f10ebfd93da0136c6d467188341f904b448e2d224c003aa8411a66088b46d21415340eeeb6f4bdfdb926e44dbd4b8d1688395665ddfaa827c23497e60953517b67484ab16ee6bde7df89c5028e8ed4b6e828e5ed599833dcade727d42334fa2664ed15880eb65b1d153c29b3475e02bcc816e33d8c489ef57e47f94a217137b550bfc8b86dd4ef24d0678f88de3efc6c81a0ba5cdab5b40773864a47bcc061c9180a502447f2482e48870af0e33b10b4d1abb3cb37d953e46c6781696c4873333bbe32e03eb66b504d4547c3a5af6b9c3f57a0ba372b81f1c76994731ec34fdc92a5354df37947cbe510fb735bc5a148fa694604c1e76a9309abe94989edeb27f7e0895d662223e562fa7d9383a46245ed868a2c65189efa6557e0c81cf389c9ecd7e8cc536ef61f6dee269f9c663d3eb381ff1716a10284381204396d3c45b9452ae4fa146e6c4c81b1079de72bb3cf2ef5e90cf04ef2a10b8ac37d41cb45efa6ae7c0685af5a5c438362563a3c31f4b2d8d184d35edac63b3e7b292f616bc94ccfeb68c3d3c69adce50bba46290f5ff8b75e83890cbcef1d2b2dadd4e358eb12a4c9c3cce271264590f064191b6222b3d4eb2986176e5d605c7a38de006552d894e905b6f110dba321c019e37d6670338cdd01aca67eb8942d44f76fbec8ad311bfbbec3ec6e598c810613c62893c53b074dbc98847870ffebe0b33cfb71285da51df34a84f6e58e64cd68e7db058c81b3a9b7ee713a58f3d143da22edd70408b94b900133948848d5739c0787581ce7cf3c75808aac2051d27b233999ed492bc7a2a22604725abf76785c7d245738c955096fbc13454b94df1905d5e6279d6bfa8dfd1c99e49d754568e376e5c7b390805da15506f0e5d00d13b78b4c58f7f6ded8c83ff3560e95712545d0436a0b784ea0db3dbeb8064e841734ff2be414e8f0ead7bb2662b0c4b4b3feddd501940785f2c78bd66bd59d4f329e4218a363ae83531b28a1f38dba1a8aabd7e6a89d9528d882439a8786f901ea768104d588012de1da81c43d4fc14ea6c4d6a3e4392184111a247fb3e03cded86b2e6ecb4ee4e00c39da0a8480aa0d34cf11311634e9eef09fce94f9f9930106a0046892365676142660c78f0990ec9575eb90af13a77c6f0ded8cccdc639bcaa657b2dd2e6f795bb7ecf86a9cae2ecc9e19437a02bdf2ccb2e8d0117f53138552cd8c532469a8f9e76ddfac3c89316f0092b29b94d754ec75c41b771def9b7ceb28b61d30b57070e8cae4fd5c9ee159ed53101c3619910529ca9b6f68cb432ad38c77f9a3b4a24b465b4bdc576a8131a1a18938d036f8107e8d06214099a7b6635ca405653be6af65b2d76462b57ac02a62330f650e6ede38a82c22b456926e6efa3ca2576ea2f5ab2aa5e408184ca63740be430c5e1a0af32fd9560112113bd77921b63dbe393ddde12bbdcd69d0987fd58582089ad30a4df45feb0a93b81b6bb3a04969c614a4d7f3ac80343931059a55646e0e998fc4d83cfb3427ad1510709f29bc6518c5c491e3f14e74c35fda4a6dfb679a9de4891e9421bd31e03972020ca7c4d4552e31b427572e732ef2931867063d3084bdaeb6f178bd8c92ad1817ea28441c478dfee81e0dc36ed4fe77b664d732bd97880b4a1843d9483153d8e564fbce707c2efbd4f72b32498fe6f6a6ba38418ccfe2ae9ea1c9df74cb5244b3b8445262a24b3662414da0b57deaf70c7a988884382240231cdb48917124b61524d5f454a391a73f30cd8c5f7c3a6e6452ac2a702a69caf69e41d8025e24fd3615fdc7e92d467b7c86e2c9418b9e44eded2f1ff22568248478ede9746e4d4d6ea1662a55e02f195e1f51e1aacc63ee014f5992e0d9aab5155d89d6096d1026b3affe13d6f1b36232506e35e27abddaefbf78e05e66cf24d529739e406ea3d244f95f2971e60b29e148ac9b1362fc2b28202d5c3adcd2d072a332fccd95cc9b5e527ca044fa04c1adf9a7f00bb3b79362c497abff566c884be13c6bc8d26d7348f059fd9981232f1537fcede3d58941879519cd35549c98ab9ec246a9de45f333b8513aeba20b8b47276d7724f24c798e7a014329189af281373b790b350da1644b68b411cb94315bf4a2bc22379da7b8017564146f14fec278bbfb70b9db0bb98d413cd345c82277d8e003ecbeeb5697986d267854321d17a67727b6c850f3bbfeab154ac12ef8fa569826624229d382862927bf9b4c5cadb0503892fa7cda4c40a66b0f9d3a0724d930e2204982c8259eb9ccfc6bfb76323c884869d0414ed8ebd995b055a428173ec7c05e739871f7085589fae6b5cf7d8b14f2af4879a361f5582446da5653a7ddc95dd16ea112feb04d930a2b0f872fc0346fb4e28bb9907228de0970b2d1a893fe27aa429b8ac63c6f19e562a5a5fce9773fb7c9be9d32fd72f8a4fed725141daa16062647f6d0e70f399aef0f73354242f892f7c907a03625e3306fcc43ac93e1cc4895509a62d1661ca145f5ced7eb7f115b1dbe9708a162194dd3d2324d5c318b8cf4512513f14dd5733e6a423f0de8fa63387eb6040cdbf4b2bb802043b8248777411bb2558f37758690ea7e202c8a9ff260deab6afb32818a2064342cc1c42e7f63283e3a03189af8279d3034936ee32f85b881c223c190926e113e895dd24b43d96a615aa8f3e6726d2675ebedaa652dc457bb7bbe8f30219859881dfc94599943904f94d1b30794c277b7dbbd19ac938174a9addca1b936518dd7d091cb5c6a88cc340ae559d025fa9ea5bdd8ea53a6b5ecbb7bdd036b0ae781972808197758f7376e89d1b2a964da3c6169a34783f2471f3dcf0b0101e60938f2c71acef79cf6f4c3383ab522d3fc10650cc5a17a000993cf9e75cefd620d0484250d8a26500d81fa18314b87941bc4131288f0bec46217c1dc0693d52d55e637271bd0660f999090afb9c4e3741c446fbf97d3f6c8e0645e9b493aa715ac0bf295b74b24556bdd2ec68ec98fd9e01f4af953b4c3c892c2315363dbfc39427a3e9bfb51b4282011db1daccaa48cadf27b190cf4b869a1525bc9634267214f21d46ea093fc101e93ec16f3f9a63b749e2d1e747040af610ced4812a48b87d02757d4deac29e4783719a978a475a27f06595e7e9e3089d213559fd0660aa51df99dc36dd861335635974de7e700bdd850a8b90d22cb8b25b3b5f7359a2a6dd83a9fd0b5877bc0c6d491216f47231bd5fe0bc18af0c59dd0b43ef74de005008d3dc4f3dddb263090cf150619a04ceb5fd9a6ba9fae5a0b2faf0c76d75f39d20771cbf0b895f72bf1d476fe167a4079cdaca6b7e630ea4f9c70f50a62920ee7bf6900c267b73e22cb25c8403242397136b1b9e1f98a1b300636b9b9c42bb8f9eaf1d0c405b72004b71f86a8f99f1953c37717bc682e825974935024a34b98c371d01cc57a04474fe6602851bcc7a652db03939f177927769b7c46f00dd57ab85893711e64874bd3f85b64f65f8ca66890719068950045d71663ca7d33c5b619b127066c907db35f882b1a7ae89b9dc822950edd94cf4efc0a1f70bc923d85bd9b987a8e69c7297872410b2483519e86331d4893c74f72c5c7e16724e3ff3cfdbefedca4993292b5dee5b1c7c2675051ea9879ade732d55fb5f2cf011d90c6b74472cb199ef6f2e85a1393357aa0dd8ffd81f9c1d7770f0ff5494d89dc50412850ce9404028525345ff3a29839a7375c6858c82c54b51d581a330dcd4b7e394dba5aa17bdad1a45d45af6c25e1a746d7342da6777316764527406c0de3082a9d9876ce0164e06157699f2ad8d21fcb48736504d92752f51bdb2bc01d45b4a900a344f1c6da9dfe386ede091f0f03b6984a89d2aca589d757d606da2a622e7288e1e1eec122f0f7aed35430795fff9b68ac9879e78cdcafb5c894fbeafb7618587e2ee94baa52b673f7e23c21ca0bed957c0b7e4d576a86e62e194a7618bf0ec8da82f3bcfad134eac129e70ed0977144f326d1e5d8881cb240f9bc5d8f78bdb572ae024d1319b6e69a4a5fa2d7dbe859c4dede5b87590793d928486d3152e186d9e988330ad2d882dc2ae2c99a346c58657c12e190986c7e5300221166f8bb4fb054947933558f56a68d50218e70d68d7e5f48682efcdc933844c49ce6aa8166313f88c29f6f9cd00bc95e72f928b733f81da34355cd80aa7f01fc27ece01055e833a918f0f04d2b60897863f8c7c115192ed29ed3078f62c3dd7db74c68d38e74df98995b1316352367f573f5cb0e677060d55e424f0db0b555055d58b704902d56ac5b72ab439e05c5a0dc49069356397ca2e84d69a5df591620582602ce7f536a93b4ded8e7eb463ca55a34d81f61aa83d013cdd52d94d53624804fa09b1df41429910e8c3b5e047c45906842c9a8c03890e5f7987a979429bcbf8361317e1b85ac63d111faeb42bf2be67daaeb738ec89fee2dfdee5f915288c6b0abd41328d6f34834e30ee982a364ecf8a5e0366fda1e8242fc15a6949c3f34cb57eadf57bb5bf28f8a29f8ed57ba7f65f46db4b4836bf1527bd777c9504047711391cb5d913be71bf8ed4ff9d02593891a5e260cc7d7d41ab8d7b1b19775709a584fb0b5582b66d6bc0df16c878c1310624a856fa40a23ce5a7064468892bfbc62c448f5817cf807ae11600d257b66fb9c6a3368309849411ad94d02b931253c709eb6dbb694bad8129e1713e9a58c5e8f765f6b8b55f49f9055f72dd8e11fbab82802fbf58702015405503bd565a037401192983e0ed8175b646f08203ed2bf83c1977bb055a7838f2bc22df6a5e017d67957778ede384a7f949e8be908ec891a3c01021f6d2ef3f9101de611d20b298bdf388bd6421dc9e0c28d8d99ac06159503116bde932199ccadba925d8a94b9c02aa27a369307a3923bb52670ed56cefca6c000a12e30677920e62098b1540ab1daecf0fbb619029097e3e2a89d5c2af6ca1c785d77a10db6e5ead4e78b5769984a1c207e8dddfa339bf097c610de88d8f22f8c7851f9f54350248251c00e6a5f4a11adb6f80ef6a317cdc27b221e9598caf391fa963702ed1d1e4e572b896cf00fa35554d6067f56cc12642d9f42090ed6a3e696c952a9a0e6cd6ef34cb877416bf51bb5631c76d57fc04f961c753fc07fdc4da6ef728922c0348d2fd2b63299ee31fd0b37ba18b0f750e4a0450d597f5aee25039e22c23a9b49aedf939059800faf83598c677361a96cafe7882bc69f8bdd9f712fa1b91ac04c95dc16ecb07929eb6d1dbcc5a39d5665a591652438c45c15d8b1bf3d15a52df2d50660102789057b7533ecbe3eaceeda643e9347e46258b46ca0dd62b1faa6f5a5465d3bc95ddbb18ba7772af16f550dd040463a6bc128abe32da05bf3990e4e682391e00af2f402280f165db9284ee680e5656d499a56328f90c7a181cd79227d36e8281bf8af3eb575144f57bcd75e448d97646beb6fc354876a9ba06e2594da8834a5882d3aab1146e789732f8c1365d2d53977133b83b84ed7d7ad6b0e4ab72e100b9db869b75b50563876b70b082acf97972089ccbfa897b5a6e6e54cc453577b1ab911c411a1601fcf369a089ebfe9724c344637b1ad361cb7b4b8cf9de8497c5dad21087c3696746277b86658717c8df6c59fdf05353bb50c221cfd71123e5617d8ea0b6f7449ee9b82a06a34ad3433391ff1fa11ecebded76763bafc4d52512c6deedf6935186b0936b3697e82a0bcb6ce592434431fb165ba229aa052700baacef2429c9c7aa9961fc312a4a15f4d8cfc2a79e45d8910c8528432aa0da40be495de8da29809d3afa4823d44f466680a1dc534a2772481f0515f356908fdd07dad8da5e014d0db222f7305238bb10d54e59a93d941c4a4b7daa7bce3e85f90225a75e75f15d86dfd2bdc36399e9505c8ce1fabffa6e071da285a2f93dd702bd8c6220ecb27cbf083302ea3d8bf849c8019b53796847d1c28096298be5dfaa620b800aa755ff4f25266e37154b6645425f057506bae8eadcb68eabdfd61b8bedcfb910ecb1656f097efdf5a735e9a97414d6fa1fb23ed9f30fbf56e7ab8d0f22570d151029699bbb43d7155755c71d19b75f89fced814aa5ab1ffcfa7965628aa3b9f78348d6eff27b01d0fba35f41505c2f540b50cd641310d46378b7a835ee0155dcb3d89b7967ca74da0565a0494a36176a6599cf4b599cef69dfc5912a3136e6322211f297b7cd1e6312766c57c3d04f07436bffeb5a1d6d06dcd9b891d124020d9eda8fcc2daed2e613c3008e4413121c338a1083a7d2eb841c4916af8017c6f574eb2905d4682a9aca8a947866f9ca7cdc26844b0f4bac1eb013e70844996988f883c5a04a9158a5d9184c89736b2fbca0bab1ff668418d13b34da814cc612a716d0d9e73f4d29f12e05a715504b0ce80605dd46dccb7a12d8f7425890022c272d3cfb69d796d7fb278b0b9744a488017c0094173d521e1225b3baefaae7eaf5a380030555d3009d22108a800bf66a26ea3a0a6080adbec47bb889cd2830c79e33c5015eb8e9e0d1d095d1761a8266f9ad476ae7633e52894b2093add6b1bb65f31b969ee91170b1a2dad840e802d486a4cd4d6dfaced97b547f1e87e9237cb181f1490655c8a5f2a45766c6f3cac992d48ddce97910848e537b951477eabddceb5c40ab2a374f29ad26ffd7b0b433bbd4a8e7761b93099206f3839b339cfb2677f0538239ee28e68a7ca48bb3973ff6258f40d7a0c6e390f26107b60b77208ade11b10f78cc69f12ae2a555192a138d180433d69c5725a06cfa91728ed3937a9d289cbe989ed47bfa1361f8ef3bdebb77702bb840be0bd7d5fbb04aaea31de4b7f805ed9196b097955b0f40c386b347b81b24a60ca4f9e5cd4e7af62dda492920b81f7a508f19115dc62a675dfc0750dcb73f7216b4da116208c1d372abb8ffd20047745dde942ac11a09143c0f6a1489563760a8824d955d80929c1f727ce529d13a9c933e8fab3a365acdc16d16d5d889536fa29d05d5ba4d0675f3511b48b419c48e8305a6c208fe972f3daf6ec7645b27554a1f41a3d7d68b8bb41fe0fb0e51f628018b3e9250c8864bcf8f2b04f2c6b66ab3c36cd6a82b80760a079238c4b9534b2755da184617b9e425a74b6cebae4311b16ac1b663855a350576a4994e90831c3ba74b0786e921fac634bd0dc820b2bb9fd736a0c5c0bf125ce6ebb2300a4154f02177dbe94875dafb30bcdc485116c094946a8c6c475a6071baf9dd2a6178554241e560a0205fcc5b66e6621d22d1a18f169d047748e8d957befa09882cb7f66e0730ce73eb326d90a3701ac176408640768a298ad181a8f916c7c5198b3b9e3b950455461355d495dc3a35e8888823c57e5d3aab7e1c20271c38ad211bf72ac5f00f40defb90fd61b3913c07ce91adc620f034f665f62471a9192af5878eb8ea5eab01b9e08cced3da3bf4c886e2c3b521c88f7c56d23961f376fa20d824a7a42cc4aadd12b9262cf7304e670ffe2322ab628aa2bdc826ef50b76afbe22119443fb5541816bd2bba74c8d9294b56a78fc1730d1bc900e4c5b5afd48c7c03fdd94252a4f29334746e83ee5d910ca077693314f6016db7873a9928b5096f5f5ce57867d45bce473a0d49d7e4c99784ef9c707dcacac1628a6b137e7e22099a78ff6a41a8c5337d7198b8d5dc0f5cbe1a3a66cb4df583aff22b15290bd04171571d24d037dfa3732886a4e92b35238d7a0d2f952b304959a4a940b7c0e9d15e5d22d0a619f0cace767fda366c1c85909911ecc289bb793e918ba96c73525f808e76a6055e2dddc06391d253ba995ca9d0638e3bbb481cea23ffdbb3f5d8b2258964f1b5f80e4899f9d5d7ab8ff5cfe32b100604946abc7374e90d46788e5cd03b6ddc7f1785defbf960ff023afef5c2bce3344d9370dade65e5a5caeda64c6eb8037eb34802cb8bc96ad3e4f021f4f5549d42be9293f000543012c83869ee07182b90ddd7dcd69b202699f94485f2688f8cefcce2bdff74d4fb0300781b0efcb0f4f9ad10b9777b1f4ed422ee8107dd9d843203226a788139806cea58ccc1afa46e89ec05fc52c3a61d83c337a995d71467ee76aeff62cdfb7f592f658599b82d952517c2e8e6488559f84de3b7d8bf14acd1c3eb412007433940742bbf5c2c5f1c5cc9a345529f8bc0b393b50359ff72c69ffc30f424a1b388bef855381cd9ed153f679fc727c3411b389c75ed70e3134547ecf8c6f27f592e8ee3169de56751a5c7aaba66d538d2d14dc57bc3d29d2786d60976a84c7ad07a41671ef76a85e5d9ef0ba4bf50f92f29225c910c78562f0ba966554b353e2c54d01459a8c1f79f3238892f02ebce0937552b4281fd18e3fdb6875c501e71c04d601efaf1d27664cc6fd42c39c991fc0b8a619bd7318d44a4d624fd79812ec1b7342b689e37408592c1a5b8bf3dddc22843e5b77f0c2f7a51ae4a5611e3f3de2ad2a7d1cc7c40f9d1227dafa1423168a75c3e86ba4464b3492764c09c1a5864001cbfea34a881cac2151f22e1029c21997d8deadf02d304aed2dd95f7012517bdcc50255ea12c09f0e16e8caaa6a881074536ec0451632b51750bda418689787ac8de2966145505bce8ad81a267a631003e226bc08d3c250a02e97a2a22adb13fffdb5eb573ea0ff78c4f490eda5ea4a8d25109de9f085fb5d7d2e28e0fab153bfb4d911e7a7e852527467a542780588828b1ad896deb9ee2464ac83d394ff407bb6020316634a2b8992df575528d558ebc670370572d88a13806c598b130bc332e75652761615750045e5f127e65788a067d4d01d3c64b74c1b5619aaf78faf90e820b349843e18838a8eb6894d21f48106e2a42adc21d63115873e31fd1865a2dc2804c13e298b5000919a6828d4e40f4625a98e2dc408cadc6ff1a7a437923644bb35f816a558358e13c9512588ea595b55bc7fbb44795ea694bb1a71ba0afb63794c49cf365cb1e4a31ad41fbe98f2fe417242eee970533d1e3918270f7a80029dab4034fb5afba346f8cc8eae18f5e99503679ce96958f5c3b3e3cdd0b4e420d67f6344e7d90e67e4dfb30b40532a90a6c2e268d4de990c5ec65badf64c741de5ab7930ddee353207a9540789745a5746468d8dec2fe5f07ff4291bc64027f8b872afb758b80257f64d4770ba82f4bfe64cf63b346163638130b095248731c7a13f0d442a92cacedcabd65a4b0d0f5811437af948380dc07a3b00aa7a163716edcdf947d94322990392115dca402d3bbbf59c5aa7ed1c1dcd3fb34b9a37dcd84db2689540526af3c12256cae19b5eb9dba0f341067bd7e80187d7408d2bc262dc98bf16d70476baf11b8b7480766a7606b5e04c287626fd0227d1b80a207979cc7d9b39bb644e32128d8725ad87b9228199ae66fa9fbb6166daee0ae424d2d5edfab519c7bda2acd343b549a55210826c9df01524509799756dd1292c16ba1c95c78352099c00987ee41268af467418f0dd44e8888d7467dd13d6437bd3da10fd78bbf924f1118646a8f1e7a5ac52110c46f7470aed22bced610211df8cc4e1e8f5b5d6386f85b060bbe3c982c38ef5e3b77bf63512ea344d17e0cd20dd7d25e5080677bfc986497579a3eebdb1d088ffc40e2ff6efff78b30f15b0450bfda8cbbc7ef02dfa75f942221cfaa96148ffc16e8d265db182e16157e489edddc27b5898f0550ea066ebd78cab588587401e787c305946be94ee2dbc34aa9e07ff6c4ae7ab993f79349bf69cbf68c7fe45abb6cfbbae0791a0adce86782e491cc7286d81771ad980206733e05baee382592c5161c407403b6ee1caf6893e1a33bb85556f7c7be7aa84f47f6e19d7962c2e4043f132a020bc70f3c6a0089aa3f2b65fbe852c528d30d14ba598e4f28b37c8b089987f4ec225a0e67e664beafd27bbef9b8258376a494979b622838db586dee0f079cc41cc072d853bd9e7ff748dbc83a7fc9861fa8bd2413cde8ac95166f2444fb912b52159ad5d89982d6d562a34116436d0f8608ab174bce5c3ef1211f32c3a2d4d6a1ed2a8c9c6e55777e9b1458dc61d7fbe5d84587cc48fe08d22136adbdc06981833d51632cc41049c34f4bf49408624e3b1bfa2c19829aa3a40b4063a320fa01298ddc402711083b4bea0e754b09ed51472a467c1b7a73a1e7829cb03a937fb379e5fd0a4510e81637c5b5999d7c63219b11db295e0a268a86a01719f6ff084ce0a306c0846e959baaf00738c69faf0b5b1765d5d34d5c61f620d9e81fc96335b4808ec7e496820ee378f5a0f338343bc7051060178073e8804943feee943b7ed9cbf153f4775846284de6166751af265e7f910afe2d43c53928597014c15dcd5a24f98b223a90ca12253aae88f258c4fc8bb2c2c43100b515c8474193a917aba03040e1c948ab01731e1017b135fb62c17ae17fe0e7a22c394c40fa20aba071443906213c7939738e0df2d2e0166c0a72c9277284023734d51a4a0e86cb7d92eb829b3b92ca3740f2145399c36932a1c3dcef9c4dfd9802519275833a9c6caffe59bdba8ee7e35a0044f8a3cb8eecbf598c4184db2298ab6cf2d3087ab91bd21450e306c24b1aa4d80c932cdcd9fe4ec3608990ee7e719d35c93cbd01fa1ce349f981cf3fcb9729753f955bfe27732b1b54cfb772f7707b516ddaa34f055625270b5a264709c2c845bf3824866318049aef0e130faa1221a3265243414354a774773431b0ab05e6dd387cd436736fde717bd542c823aa6fb072bb652a7a47873dace52941c58a50e0f5b32e23afce320a4aa5206324358151b16e7c4a83f3b99b590d120029e7b35bf4ac8335af72ec44090ab5cd4eaa756fa87bfe9abd39c0e1ab96867a7908fba0847dc23340dc7ef5e15cfe1a61bdd479edb2d9f2e0eaf6c33c1c6656ab44220c6c4865347dc5132c00c16e92c23d04e7673388fd6b33b2ba25fd77d8b76e594e39730c64ae1e46e1e102bd5adda5300b9236dbc0999acf461a8937881ad23d1d73ec42fd26a5c5f45672fd589c78cac40cfe505625fd25fe366d8a79aa27baf9c9de9fdd08e63e48fdcc3a81b2bdd6de316bed4dca1da792f2bc14af562868fa439b4d48d39d9b2da769064389a3d690b18de28bc13c4e0079d652d4aa7220d871030aab7b243b240b00369b5afa36c808dc6dc74d2b4928084a56f57d2ddcf4e4cf762ecd581cee4d745079eba57cbc87454983385799509ca8cb34097c071d56a486f2d4085b9641d6729a95b019790d52568835172105db2a00c4183a5d0a6107a5c69ca67ed68d79cbfc9758d683f4d2789f7f0c452ce39d72ab0526a5c05e36bf0ddf0d57904516575d5bfc2db99b0513a18f6c00ad5864d90e936c56b8d852895c5722b2daea5918b0dae12c13126ec49fb87a034a9e3470642ae46744ca2c8bf3832f6ebc0a0adbedc9affce730dd6f2d4c2cb539333bfa27e6a1ada758ea39c791afd1c23ef23c88349e90658d3badc89b043bf78329c06704e65c992422e96c30ce68176be0a659a7bd584dd0cde4304467e28469607c58e8a664efc52ddb2a2804e15bb9af994cddcc2a0d39585c0df6e51f1bf58158d8cdaf7e3d21e147f58248ab69c843a6335dd905edf147fa2ed314ef979d8ab62b6688424e37b6c1c5e001c90626d1a1c929a5ee0de0dc4ee7a35b940637e8594a51374d9b1e51f054f38660f53a686aa82e77f8a369395966dd124dcf5ff46c84e59167920e7ec0d7368beced8c7832032ee63adbf3eb3e7f528f9c02b0b0980140acd856094d06dacb4321fcade4dfacb4f1aeb1a288ec4a112ca32a3bf23a830518b984f0cb2bdb8ffb579878c0e021c114d2d32adc02cc1573079fa4953536f8d0f42d19b7e5ca3908a6ffbab1d0c3fa96bf7893e9deee2eb119606c200bf30cb966271ebf8a8108ee719cd2fdcbd069452f8acaba5afc173130d25fac7cb0d04fba550cddb58a4fff0ea3b3bf377ececd50f6a0e51784c6121590197cdfd7d1aca473c0deaf1bc28de9b0e60dbd3459029242dfb995bd595e1b4d7f9666ef69811e9851f7ac25cdaa21a7a888694fba26a42686ab05e4d75ce9795dfbe5b12c65d6bbcd45ac4b8b80820ec25c1b763cb1f8b71fda930a2dbdd1ed6a629319d79c23bb99a96d42b2a6158fd92208c3481e74b824168c2a968762b5a562bcdbeb5c56d50adb7b11baa5a935544c62ee592d4ccb64c8c3e346212bfa6f10ebf4810f33acb3f5cf9ba8046bf7e814bcc7c22b6f6fcb76683fac0f5c4f501d74183a1c9606ae8d3340c72d67d5764713b5080b24a939acb55107a8caff27fd679f1f04874f0f2432facb58489b08aca98db0558db1dccffe5bbe92f06f7f43704b8b7ba96705e468a859f54dffa37beb2859de1a894312e5d099d310b8318810cd592dccb7fb115ff100384c8a02fd84663797941aaa2a53708e85d6230399f2c83ca7df48dab8d34cf1c9379629a85e69c4998cd1edabe49489df5de86286193b3f8e3c1ba2b200a4ca5e6a6a04d86adc029cc3d6983444efaf26024d47394fd2cabafc97217200df806e9aec590e6e2593551274e77cf4ec32e8bb897079e71908b96dd09c7a2faa75fb0321a61f1bec6c949e9dc8033a103c8365c89a1682c50337d1a97bd8cee469ab0127b336b2a81d023c7b13ee25c94d88300aac66fcd47f6d399eb0251393d7a9999dbe53ff87eb1425adb1be024814e187b755e2aabe57bc1830159aa9ffc3c6d77262de5ad66d83785b3a4cd29c33b3ff877f02db7386f224a531ed37cb761ebe591ae8c00c184f3463282ca9cd42637967273ce6479c288d2373bb92d7615203770062dd8ee5ee1794ac532eb6c9784db527f40811677f64d2f0d9c7d6dfd3b8f4d438b0b525c122fab2f0eb749ed9528a05e352fdcc9c291865392222b0140eb043d0e05f065c186ca803b7f716288eea2c7964caadbd5464aa58dee63f0fc44055606690a69c6cb9670d76feba47589710bd5c7af9fcf463595e268c65ff0c1c63f0978f306c15761dac0c1fcf9148ef5fdf649b0121e83b43636d60a0f61c382633e9be01d5f7bdd9d5a793e75a03b4fb2e2fec20966fd6132f8ce563aba983dd2a6e330da8ff53c467b6fe2726d69f0c9d80235204ebe70da310ef2476cebacb8993acd470ca6507109ff2414092e6fedbe4c2af3e94b6301e0cad7b261a8b9ad0e2ec31b63db769072ffbf416b2854ffecfccf3294a21383451926ed3f3b843ff4821b97ad7bec1b893bfec2685e165d627f0260d2b442f7af211b05104a92d13e60219d8ab56fd4fe04788a55467f128eab8764aa19e288d9273a6103fd4616d2416ac63a920c3a39bde50c649ce10f6bb1f687f03b7fb0f4b9755cd6dca327298a2101f5960f19fe45570aec0d1fbfb87fa9425f492a1ef54c4c895c169b86fb80561a9fb0fd488618df969cd5578a7d507fcd1c24397336a71f8c4e57ddcee5f67ea19d74e6036ddaf66c26c6af0e46f48921fe2b3579f4d8041bb8f5e0d5444784acd67c9b6a6d92ae3267703f5856e1c66a1c8e5382d1a2380c64dc92e18523cf535c2e1ae0cc6047a0d8842657f307b316dbffa792baa9aa31ccccfe8bddce325d4a3b51d1e72a73389b2cbfc01de9448e3aabd1c0590b91a4de79b8b5512c53df9b1884c5f626ea01495a53029ab76abe83c1763c78dd65daa9eb7df2bb10c2a0874392cf61598ef294be17fd1e60c6347822ae8313e8cfef8156290796bbc151fb9e222b4f7489dd73b4ffa7d2adac65111e2c2fb3c43f4f536cc5bead85d4386e36c66b08bf11c8b4371eface1104af42084e2ebf74eec7a7d2982566586c9d26917605e852a75b3a74c60ab3d35e66adb5a3488df74c9a85af234e47cbc0d8ce20f1102ddb8a7cd687f39ac4f49eec495b4bb070ef06e32a7df201eabc24a42b1f1042708b6dea7a0630a112c79cfcf7c1dbac08c40bfdae5b1b0a36437b37a292da0ece6927e9489b84869d0871d3bf798581d36cc8b126af3dc9c9fe5bf3ae3269ad39cefb2c21315fcd0c5ed332d2dd1e44fd8432a2badc06f669c3be04d734a5325d816506bdb51600f2be598cb9c15d5920a4e83a95e4362545c507372a176572dd5bc1caa8d9d97ec87effc26682ab008d77234be0375645349491945c612d1d7489541829e64542ee9e50337aee0e3e22c742afe5b5abdf90a65ad367283006a84091c692db37568138bb791e0108bc675051e88653d05d03c55d741bd2fcc3a3b376484e7747761f18a5373c25743763a3d2fc0ff09e2174edb8238e5cf05fbd749896c3a7f95d4a9108518576023390765c5fbd0f90a2f38fcab72d6ad95667b7b7d284894a6f2288893df724d67ea74d2d4addf46496241f9ab2e6c9658811463a7e58c22d40c4331de78c1bdd7026fdec511721998b3506f9f495a8681a9754a8542c586efeb5dbb4da40f48f926b68f736998c6b84b85d54fd0d0bd30b32055889e1e93b1a74a6ce23e88e7d108de0e4e5941c878b809b598672fda3caa3f9fad1d12df47ef52639f5db371fb1a41b90328b4699b7d1229f7503164850ac5a3970253536af2c00f50df42d278b6c8228ade6397ffc90b04205efb5fc8713b911c8b335bbaa6ede0603a0ff13f1e177c0d0ae2030c8d3aff5c17828b066bd7df0a7978b0c668c526b271006c515f15cbec37c6426af2863927bcbd39d50ed6199959cd45684bba4226f372bd96001e2a3b2c969bf955c0aca379d3618c15dafe4e8f5478a609ef8bf9900e917c334cd1175a8f517b412d211edfe2e35fe032e876326d9e06bdfa126fd6f5b84fe8b29d63b7739ef19660cc2c697723712aaf51b77fa8ac48afd08b175e992b3fa0df9ba57d37b5d9c5a2b179d99aa7baf5e6a0e493ce2cf0df7c0baaabc92551378bea8dd829a45745cea96b0b204b296efcbf3e111ae95f30d3be7fd134a2a465ba2cb9a91e49841213ede86bd6fa67341780ea20703b67cc20d4c8054008a71abbc69c0e6531592ec585d1fcbb1bfc731a8db1aa3e9f2b48bdae14facd99cb65f70f2b8abd47a4b56896422e7f59f5747593d1f10bae404f83c0690ba4017dc0afdfef5945e45e34bf9d5a325c4e740d7c55f28eebd2445588cddfc1fcfeea03e4611258553ed88c485ce26203113c4d1279a5f1cd1b48f236deb1de954b340b24ff8c8426093d2704d9965f5f5c231c68edcba5d8a9a1ce3c72c79fd9299c49d3714e79c00a63a9dcba81ddec83d4914859b53eeac2508987c03d7a736fcd6634be977713fd3b3dd1c6e922b24c5dd3ffe94450c63e0f052669d665c4f18f550be7f6f9b68b111a9c3e2816cc09d9d9f990c5feb4e53dd214dc294e1a35a037dc49a226e3108e3336132dc6c6e8c95210366ba0caa49a18cb00bc578e8108152c10eedf00ecbdc406e1aa770dedfb6c543dcf82f628b7be5b85a6c975319d0f33762f7a95eaa5105dc676953300752a5f84db83d92e568f1e65a014d1a1bdc58eb93ab83c0b7af2a7235c78e33afacc18656c4a3ea00c5fb7b74f2fb3f9fabdf2f40bc9c685e3a893093324f0bb16706879689730f46be0a64512c82e88c238bac37689aa2244883644e04047fc6ac8f3dc51c5d771ab80c5cf11014435ad32b1973488ba3f4bf3505bed48f2b3387729b435cb771d5609660b73f27388cd3c5a78494cc2d28d2cce798c65365fb02d5fda0357fb4262f752b6dc738b4e77be126395e3086a4960746243adc6aa5a65dd95fcf313b1bbbc954edb7b441d17672b3adab99def690941ee54292bbadcbe1d1504a8b501af1abe6828b3d4955f3407f19a7ec9fc630f0f48f314c02d753fd056107a7a024b5edff2d65593e0cf98821a7123f10e9d83296ddd5924c2ab4e4ee3bfe290466683056818d2616e885516c69eb2f505155ab76baccfb6631f12a9d2be6be30a08619e9b98b552046d300af922294e2b3e30432d8e76b514b8abc5ef34dfa034a2ec92c0a7f518736184c0ba9a52a6e0db48c911ec641045d5926cb21cf97811956bdfc990d39447afb2a10da83f3b2caf3d3931d99793544ce2d1dd018ef53623bf6babc152cb75d2d539c6a344c7028d1e1e579e43a7dd0e3e85b930cea090664620f792a4b3ad3f1df71972cba2eeb4048ecf6a1ca815a758afbf24def52ffae93a2d0cfad98cc8782ee3164be84e81f8e89420d8e7848ecc2e5f46bf2a56b012d5b1669aa7b433def625733ba028b19f62209b1ee3a89fe23ee5c6a87f722ba4df63acfd388f9cc8068eef80570ea7ce5ffd91599512a48767de4990bde1ddabdea7c625a7246ac20eb8293edad8d67327c8188ac31a50229b38f4f9339a40f1cbcbba4ae97dfcf1b37bf2b55d9526529d98f028b0382a7190470a29086fdd98ffd6101a1b9838072d68f152115f7194a38ca0b2cbc0e0156a9570adf2c193751ae093d7dd2cd091176c5d08b67c3d8b8b05edc1b3af5ee40043d1837555121a8280a5961f0a6365eaf5013fa2a8984371ad0710b898e447b6dfa237509c1d591b96cd7c81a1bcf7a1228c72ec6a3c2d5e580e15468c3235c3842559be0738c6b46d45723ca4b4c3d441a9052b8583138c1fa0a2f448875814e127d954a0a16e7ecc8d36a8959ab3236de2b27142c386cdcc7ffcd37a4681e2854685c35d854d9cbd902f969585c1235cc63695076223065192bca93bdf05ab3fec1c36e6e3f025464fab3ec941c03fe72e2ee115c23f5c81eae86dce391e51162fdb73c68a538698aedf002e51434481210f3976f40e4f45a76339c5df3b53ebbf3fdda71f61d2f770da44541812c26a411f21d0181c910b87bca8d156629b314a5a3f2dc4ecb426b9b6825acf838de4446d5f2d35dd89cce47b1c5a99d8a777978e61e57ba1f9e3bd9d0ed8e57bd0add08c969f52a66c95c772367292cb2057bb0fbfa04324d07c4d633f77aef596951fa8f11656ee596c18f4856bf983e55d4c598344f9993fe89a79eda249851471a1c2e2ac4c6274ceb425293862128b201cfc8d56ca9717748684b1f9468b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
