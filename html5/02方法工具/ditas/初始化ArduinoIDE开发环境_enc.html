<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"956ed109c5ad928d41b8c81923631a1140ffafc205eadc656b39a8a1b17adeac8b42db918bc311e483c67f52541d89f693537a5b89197ad9bdc7c6e01492eacc4a75ac11c0e52cdf04cbe322cd9eb4d8b1f8dee8ef6cc53f742be5261c31d987cf4e4ba13b51adc0a11920254319c07c8c9acd18952908cb15a6dbef958ff01301d0685d6779bc174dca7ff59655b0a222388077248d4af0e494e4212ca51907d53ffbf567cf8b7f6360dc4be0d67fda0e9e3193364ce3ea71b3b55cfc4562b740b47e2a1aacdbeca8e9719f9e577e098df72f4aaae9391a297affd6dd8d1bc0a3064c3d1bc2f857a71c13f515f49aa18b7a9a94ddd6515d1cb2f252c2d678076b405246a163bf7837e9e6f7362f42ae86b36cc3c9a6cd3faf9f721adb5ba2256cdddbb2bf8688d5098c81f9deb1fa6fcb71616978b1ac23dafeb2911948fd3dd9c289bc48bb7024e30a745bc16d15f5aac568534d5ab2c6c3e66d3dd018afa9984c2da210870fb8ddc87b5a43fa429d5422921dff933f8128e1aac49c1644d1ce28e992ed9f64591064dff5cf40c53845f417b13d0e6dcaa5caeff70bbd8f84f4cfdf8efe6491566917cee39222a65be58a1d35684eeb5b1fb9a39c5e62317da54a733049ca8a78d12cb255f87cc1a813a26c6a5f6e836c069bc724edb3e05c44e074b567dfe284d6ed52de547b3661423b26a15ad461b5ddfb7a4180a5359e1b7848c290ac0c3986ad0dbced8e1469a5953e033dd157558b9cb0383333252c2df1eb3f1fe3055a20cd0c5c4b0a013099a794900a329ec55cf6a71a0147fc9648c708094de6576aecfcb2e9e457b898ba8ffb8414debe1e8f542921f89f84bdf2c6d4dcb6e96bf6aa36ca8f8e722901cdf32de1a27a5a22eeff06fadfe2ec689b382d6ab428da7030e0507e68c15542c8a6f2bf5c1ec5442dcd05e47e6c366f2a56363211420666eced78f02afeefbe3318d9abecdc049f041db7a6eace6c7207c0fef58d1b4733e470f5a2d9be695c8d915cacd26bfa12ff8504c56fce8d1e4a2b83d4052930646103aad40aadea269a2e3a11d267e8ec4a9bb1b459a4bbb33358fc187834045571fe0ad0f5ba40d5cf4cff0aef052aa2138236f98d7d1379f897c7430ef55ae77e60958f9a146cc3616cc038dc380b4372a05171702c5fd19e9532adfc509fc50985006e8ac199f9dc77b1ef523785fa3a14a2252805adec8d6f264e90016a95b433d646f36625cd21bb84cd46342eee28309b13141c486d987aca0dba490d2a74262694413dc5a8f6c14b34357874ab447bab4b997945f15d1e14d3750aab1ddbb3ed3eaf185ae555be89b29d6a2cf37bc31dd68cf9a77a6658134a3eaecfefcae6237f880abe993a02bfe789d03f00d26230d4c290d35cd2f8bc0cb13753708fd5533b4e3ffc4f80d5d48cad1d9245b60fcde0a7673a362660ce94bb26e1495753f79a94e2c839fee3f30ef8205366a57e7573c755bf79ef8b191b29d7d160b0cf88da8292609ae104526a3df6b154311827814d8c42ab758d40424b44f0b209d84d6200d2a5467f25d1319a758aefdf25d1db871663c8ee98e513fdb6396f63dc355cb1de2eb8fdb21a564f20e1c6bcd1dbab3e5b3635ad5e7e7944cf193936aaff7c10daced966bf1ab6fa18ff1b83110edb4c0f5c00bd58bbe54d0eb51fc072d4dcb79fc03e99d86a379b3e67cf31acf48a1c11d7d90d8d0c0d6f02e4f00e408912f54f51d9307a091e42a1c8f57c22286224759bd40db4344f0dd766dab2bfc394f66d7623154f3f5f69df32ba2f5b37d5217cdb721c784b4a14cb86420fb854e06e89e36fe0bdebcc4b90f0088ffa3fde7d385f9a81aa5d338647980dd008a94466122295140e9a7cf3cc05cdc21b573306432299e601fb0165281280440360b2f858027c1500b840822a2321e47ea28ca9e749065e77952d96acc21f22ff3882e28a388debde0cad4064bb8c9afb30fb5e4144a317a093daeb8c625bf5bce6088e8875fdec09bb1530dd5ce451ee20a80efa1cc4c2bb9633d56114b54e4ff0f54574957caa7e8f2604bba31c3da50c7e60507f23f1e69591edf75ad0c8441782a29470ca2d4314f70e0e34941db812a2270f896ade7c8d9e29979769dafaa6b4d24b164a83aa7f057388db36730733b2974ea9acf852a916693a5bc31ab4fa549d3df052d3bd4a8c82557c208610a10dd8de53ba2007f0eff3c6f5c56b734f1ca7af3c90f7966958540344af4a5970fba3d5cf3ac603f4e8e6b8b784bafec6c705f19cdad866fb73a1243f0174090a99d7ca2eff008259d094678500318f7b78bc7c88fd240af070c6651dd8253d917ad308418ff8ca2d4fb0365c818e5e59787fc022046c39ac196b13966680f26b3550fec199b7f01d7b6e524fcef047fe7621d18fa32d6d8c97265ae58b2c830622686078e1c813afc9c12b6c4cda548193d4e86d91d61f23a80cb2c4fb379581422fd26c3386c7ae0590fffe94ab975a4598462d9287f5a8b58994b76bca693b2097b50d699c27822dc82ae3e775a93b4cd691e9fc03a7402d7caa289aad044b4efe458e4cf437886582bf815a13c85e1764a64f00bb9fa83760feec49c52ca37a9a903eb5f8d00d1dc1cfbac79c20dd701be3947d7ab524cf4809ccfecd9401f0ac89f396e69f5e1bf6208dfa10c61545abc1dbdbbed7906a099144b74ed1b86b6209728c5bc15dfa7fde9bd1a42c615f9955c9d4f75a5b7066f4d25c6df518fa8fa01d974c25ea278e7b82311754cbca3b32f4566c80fd68dd6b2a8dda9048c4f775ae36e15ee74e49fbd0039b2c3be7ea3702de9fab9886803af8f00c7ad5eb64aef746c0247b04d6c793df3542b5a7510f75c3e8fe15c2c7b0d04728f59af392d6be8e46ad11dadd18d4037e2ad40e24bd075a579909e0cc1c52dde0e6b5daa6de9709f49ef8ba631ca99f930f98105e37c8e1186d39f9c3bdbac609dc627902fad2140c856f20eb66d7eb313ad27a32d586105300d138ec04a6628276a5caacfd1181791f213c4495570675c65a564ebcc85aca251ce4de96b20395b41bc547cb027ace8571cae9ba1c747a81df640ff98991521e174b49507828eed13e8e8ef236bfaef924fab3a0d2dba1478d7a391cda14a70868dbed479c127dd8b6d23a26323e83f00f1ad1a02a16051d5a8d9277655e23e283002beae2cbf757a20bbc36bf5a01d9106e0307532c80cf483e8d0c3e2f8d6dcb44d5ea3976fafa7df85bbf9d83da0ea26c561bee48e026adf192d49cfde9acc960717b9aceed3b3bc44258735735f4dc429fae570e4b8be50a8483a8870f69360a50b57db3223976865b8026e7040f147c25d758a5523827ba3e9aae5f3083ec06a608a6271fe4aca6d162e1c3235627ab1107bc01ec69bc3ac79e4978f8d206b34e3f32a17c191b0d011dba1059cb5123401e3006344e0a8a1e0d8d83ab863b14123335e6aa7a6b62bec3d2ae3526923816a9e30fe3a163895898109bb62d5db65a525fefdd85ab8caf47cc35e82bfd3ec6a490f98928d6a62a9e4e93a6af502d1522ee1ed930e7e5d2a926ac29c8c99d77908cf27a6f6c6f359e5c210a9fdc2ea97454165f8c32a52292e7b782352d7d7dc398d5e0a771c274964f22f3da234a249af01c1146f5ec95163d83e4eadd89a22bc22f55e39fcc3cf9017973f8860e007800f134a1dccd6ffeb9fee29a2a723a0cb4df6ed0e5481ba1ec345cc9c8c73443ba591b3cc6200a06a75fa0a05e3c0071e3e633b5464ce385b3d30e456c3c2cd56722e6f2ed747b5aceb93557a3b0ec6b813c48ba57014c9a5901e0cea1560d6176d66121a5eac5b3e55df355510baab2559d2c591e471fd7bbb5c1f47482b0ece011752145c35878f505687eed1308b3ffb1fac804a4dcb0498744c0e9406f19dfecca2e846bfff66b4cbdee0df893d80e66a5b87f5b8556663f321791e5a06c3039f7b03b2e495e87935ee19768f482ac513cb3e4292b07772bf078bfac4f1a5870af058286be020fa1a22db84cc56413d86596c9b5a1a5b43545d120d954422524e292d5d7e347280bf14448eb22ee95197873edb24bc7351ec29fb0d2fbe774fda8d71356d51de82b0d9e57727ac7d989019fc1ba9b7d58f89cf882c690b78ddea2ac647cb3009737a16a048fc384545de867e419697ded38071b4476b78a9a341692dd1f738f483d759896a1bbc46ba963a0a8f036d4b8d43ce5a0489bd00981a933613ddba0f652cbd5d22db2e38544ed1e0d848f42d11c0181e5e8a5c32c01a8b89272a023fa4e5feab65b220d6a562068925f86cfb75fec87d910bf6287e53943225060c44c96b3afb19d956e9dc14371a9014601b7cf73a3073014472b1a49754ed2b90ba29eb151cca5742f169d5d899b9619b3924fbe7b5f19d5e5a2e32a0b6e2b7a45ae7a0bb4fa7d34786fd4a804890b2af21155c2efb0ec9553bb34f0a055e106b45ffa87d0178f251cc4478dabd90952dcaf5083042ce81232acd413f0c9b2c751f2e984a129e929d46fbb2e5f456160d9f10f88d765535f3babaae269dc56023fef9ed44af113310a8e58da89ebe4bd6d25a85f2152f74d13e1b6cdb9b43f5ee5cae7f66a3090d6ce8095aba4d03fb86ea096961830af7fe997c49c7e8bcb932d876dc5036b834fb2a67882e476e43caee8d0958db4e31428d76a5902cc4c13723ef57d259fcf88587933b72c993e5e6a64a5619cbc01de23f68c0cfeb710055cfab55bf9d553fe2df9b713142ec1b15df7c7cb67045af2ae990f19df5be92dcf96408c57f1f3bf585e31c8b98c235e04e0fcd980f0ba8028067bdd3cec0c2995fd3aaa1ea647a9632431bded984dbe7a9c1b517412e1f221f2c06e16cdff5ae9235bc20c3498d614bae8c39ce47e6ca8cf217d64536292ee0d37cdcd695014117d20930767720fb3bc96f9f123151f50749ed3ed8f9f74c80cb4a671a473a7a70e6c7d4e533c18e421d28f175b592d0d299b61b2c92be98d20605f542cef5cf41117ed5e8ecc5e770c7b7747b69eaa55700d760edf4074b68666d676a009f4491dfbae2fe5523cd173ece258df48ec89a3a13eb74080a1de1bcfbf3f3b2278facfd36e210a22d5d9995bc6c523bc34be9610a212e3429a74861007b93dd052a7d9d0378c5d5e443c00d14ead0ebf5cf8cf60790f4ea5f02bc9e0ba4bac7f38074edee05c3874d7379dff2cff5b1d0da42127394598e34118e3f2936f52911cab5f96476ef79387824f8bb517a1cfde9dfcf89fa71f11ef56fed0fb16950f2129895e00d0818f1e7b1017c984ecd4ce6a046d46b9c4b77fc5c2d1f93d0f009b6cd6dc5e035b50489ebe24a048dd7e421bb776a70802ed5b976d3f1a9f81a46a53cfe00c868582aae974503404089ff55041dff572631aa7947851706a7d0c1071f59833b06066b8b4a028a05de9bf2914c949e27519fe70da044d479eaadc42050fa0e196ffee819cd1a1ff3dcc5ed35858cd74eeddb60fae24629a750dc764973b899b50d1445e7e191081f83da8ca175012cec0bfb8a93d9352fcc743fdeee71538bd3f5db4a83f81ab5f83f1f5c1699ba0a41350ad665a8a7361700ec0ea59397fe709f96e84743b46e41cf9a5f012ec02fa0932e0d66c75fd4cd1debe93f24ecc4b22c942318a64e4db8dd77f5dbc6bdf5e8f1bb31910b3567ac602a271dd22ff5c2652397f6ff37059e9be3c3c844cfc2b8bc65fd88883471f4267bd1f71c5d723414d0fcaeb7c4e38091525e0a0152331b76dce3fa5d1a88099b5cbf1192e59f093565c0f56efbd9e8759ea4e9834359c4753ee1a03bd5484865432dbad1a3b07bd9915cb51b86430f701aed4fee5d22cf6b3e78a771f95eeaa80f4f5a224a5e40f194af583f243fbf0dbfccad3bcd7ce8814f12f4c7d86bc14cdba85e38b63b44d9dd215a2aa7dd292a17e18d9c34eaf1cb4e3af421952a2148363b923cd3342e0c5e57acbf2a6b57fa25a3c32bf377131f07560aa7382b8a6271b636d460a96b47eec40e307b058028b471d4acd71d56319d52ba296da757769cb33dd8fd3bea547a0b0c3f9094fefbdf52970d8588bce4ddb4cf4bc7807368038ea685f884a04aac735c507afe940740989ba4e14eb9d5975a9c65162604c53c07282eed8b097bbc1742df6a81da818406d62f30a0e3ef539c8c3bc49c917a3f61be21d8843b1cebd840afa8d7fbe7106cb7093b54be75328cfb14c252f9a2accd1e4cf495b007c50a7459b9ff648765219f3f02123e468507f81cd6b6d5611e6aacab0e619cf9177cb1b54c5e00520443e7e5d57ec463a659ff42324b5f73393c05e16f255f2df9579047d1fd81f2c3f5f53373ecec36608d4a3d1a8c060232f665937971ea544b190b88ec88a768645718f551be9c9842e603ace6778877a62cbf6e2daab15a2729e11568779c0da22d37b14f031c9839e3fd99f5c5adcb6a8887e28adcf396a5a10ab7f8201fc1118402560ddb78922801ef726fc4cbdb12ad7e47ceed416b0d64e52ce32a590b38e0080dd94ad9d63175a5193a29d6bd6421a5e0e704df18e3cde31871a7b6fb38640d2e1a48791374de01880ecb4838a639b1df7661e98aa8415ae5a67ba39d785c8553169b7fddf0f666331a00b2e2d8f8e2b272d45bdf11b077d50232bb0daef17094a57c0bac7f0793bcaa59130db5b8a4ba702a2d4bd57e555c8db103292c02f1b939b4ae274e226cc633a2df0c4b186d49df51e0d92911fb12919a5d765f3ab7bf87aef006e788adf6d0d2585768e9cc143fdebfa3c45c2489243d10fa6e6184c0c5a3f0e35d423ab4bb256b2986c9ea89879ab9f19b2ccc0ad7b5693b2aa7257362958b8029064bb7f967d25c2b029bf87dc65deff997b3069d87120aff57cfa17f7549bea94f03d9b23606ee346dbad24a7ae3b2246eefc1d0848839488efc8f7a306c10fabc852e03f577cf2a1a723cdb724c47ee553d2860566b0d7ada5a21e13b6d3d9e0243d90b95513307eb95c03375ba8907dbaaa27bf33471207458dd2606aa7ff1196bc0cab0a25ca38378c3d8ee0a3aa2e43fb0e1fe9be2ee69e85e6b34e18a370e0c7f94ebbdd327b3ece2fa8172f45a86855574d8b20e4fc606807f2ecf985d9137fb86a62ef9b0183c11f8d739efd940e1b690fab3743e7e5aca1567a81ee559a81890619c9ffd577ea1d0cf98965e76c7fd8c7aea95a3342ad43577e0f901a86db1ed5c466e942574e6770585b2bddc59b35bdd3cf3fe739070f64b29b72b9fd10fab4bce37f6b3981c5b79d42c5d9d20a880ab2a11d4ce32e83576131d212d60f6c5ea44bd0cf2a474ad2a8a6b2fcec8276adf83d16fa94259d4789f4b8bca1482a464b84fa50ddb6be0e5d295fc08c43e3e908ab64bb2c76bb03110b1d850c199bde0a6a2405d8589e822c6314cde6c41d0255a75aebe0d7655e84eec730c038da093ac2bdf57ea7162a2afb9d81e680e9ee3525f3e3338d865b00f2af1bcda9de3d0c5859eade3a030e5532d943a140836b7c48d423b90d7f0bba8190df7a0ec4b80627ad14e251d9ddca533ceef823c60feae0c444cd53e0b074ef6a316db231d37453414b274106bf544cc7584dc104005b018b028bb108d8d264cf692d787b2b432d7f7a98be117b3056d539aac9c8a2d405b004c64ce42c46d47e427cec246fa4d67f22733c7bd0a06636af221ebcb66fafab45d1db4718a8b83fd0642bb6523f49e591689a9d529cc173430c3a987f0a94197d083831f97a55353f5adfa69d58e69bc5d888f4366c13418abe1639a096fee9085640f55ef03c73a4f3a0e9f5896307c5ada38ecb2a868ed43448b6e1d19f6e0d4a1160695c6e96f08c2cd0edebf20dc5bca6ff2d78e1f2afc6cfe4727774888c782dc53349827c550bf6a4d2dc9ce68da35f71e9ec8788837b458f4880c0183a526f61b1cff06ab43476ea3590fe9577817c1951f02011631cee516fab0fea925a8fe5f3a10a620c82f7f6ce1f892b892cca5d74836ee93291a6fccd4ceed29530010e775962b20dc720fe01b9f3accd878447947a01ceec617135f1044ba980c315f6df27b1f5e9faa2dfb57db403e027bbf2fca1cf1833a6e953bca22eb8a0d837f67fa2c2f108d5569916fb0433a956a4ee989a8e6e3ad2094dd7aca368caeae3212cb7a8896f704fcf61e86cbd099d86d8236575a5382b5516669a18d4b9472d7e9a44dcbc2f96fc3b011346eeee4455df5444bfc59b7764430e70949668451c099619236a07f1830370c114347cff249c0d36c2dc2f4311e1a41f87e2150e7d010af2f9bc0741815f97152ef15e4a0dae63a95f4187d6f2ceea5c2a8fd3ab4d415f3a2c3b324dd6b77f60ab49bfd7bae8f4f3771a5d2f2de308492706f635647ce3f5fe074acd7a82ec13ddb12327ff397f2cea65a0782418ff5ed9f8f78c7da74bfacc7edc5376e54d7dcfc73934b3716375a14d026a253bd7f916fe4b7a34d192d6fab7513a9659d6e31a21f3004f1bf1b8d847780ade8b1578e27e8574b04eff2a9051274586552fc751b12e1a7b8aa68226322992f1b6cdcbc4ce3daa09a24c4f44082b02fe1b43967012be10d82e3973aa9bff55092bee20301dfff1f83dc6f004dc575dc70eea562924a5c1f87c60305af8e32a049bc365889db890d42c1e857b4881c760e5c6b2e787bb4a7b674c5ebb662715ba4a0eefd8f06075b510003c363474663423a6fe357a1e41197a6f61a19b3c17d0450c173395469aba7f93a8378ea0a5f55a8bd3c9512994c18eb9d00673e3766abf6029e76580e415d5e97aa2914062e9e72826688f9544f26e9635c2431f5c4ab7b326bc5e9bd55aec57020a4845d32f68c468b3deee84f5c26c9e4c033a05ff24c4452adcaf9d3ebd57efedd454ac8c5fe1d19de06c74cc915acd6edec311c9465dd3d3f6d8cd7030eeb7abbc316af253944221dd2d10719e1404abd6ef0b11f69fc2e80fe7850a6e3c158f753a11b292dec6c8d4dc7c2d88a5adfe47aba2bde99994418512fcd9bc03719a4280cfa812af747c8a05a7c86aac96fac3cb8f147ff7f8f9af7c87ba63f57b4016f66a8bd3e0cab05d9967d77f9839ec8103f38977ff91ad51ba94b0a8eac05f38e2639a0657e83a856c9f92cc9ebc52e8021cf01eb0019377984a74212568ab84e71c0942fdf123a01bd9fcb721f1c51480109d2b87c9cf125bc34491ff33957ab247a645499c7827ec38c31a4de0ddbdcee9229ee62a19cfc37ce47db87e85b773717bc4e2bbb9ef2bac04eef7973117368f9d127c5f67cf267ef73a331088221309b6b905c59450dcadda310c18c3fb76c1f902de6b556fcc55909d3d1a82bb17ee15adfc1ec329b5847158ecd714a016540ca12e625c74bbaf72628a12ba71147c99bcbc1e010a569728260a66d70792609c66dc0345492c19b9224acd0a36eda91be3c6c615e00539ecfb70188594863774b745ee19c720e4fd868d7549abf87c3f82621fbccedbdee638632f1720c140d54a1831528525b90e525320bc684d409b250ce8a3aeb80c13caa8de2ddc472ed360c6f651d5848f57805a3d21ea7da1e136d37aae39603c4621e060d07d8bc646301326056b290bb527d40dee4c9815e63b9afb9bf2f6bfee26bc6111fbb2ced8f31077debdb19b6c649fe3830e698ebb14d0cbd5782ea2bf5af6d1f6650b934a0c905a349de066df005c7013ec5c2b9b0676da3f64bfd5225e937a01de2aefb7797b786d3598b32b9d1b57ffbbcbef93a118c97a6b0263288cb4e3547baf56e4aebdb825fa039985731244ac4f767c87c41cb03de9084381f44b5bed0049d70f8aa9d4e96fded00af94b4eca66a381a500684cca87d6defd9b23ae70bc4ea867fcdbc484fc0c08fd18c70437269abb23b9a934e42e069f03bc224ab8b6a5f9ea9dd09f4a11f592ce85d9ec3750d726669771099af446130a4632956c118701f9110740b37ca2ac4a7cd303fa57a4d3b437183fa49df4223fa19726bd5d406570755f7e2c498a7db7ff2a6c624599d424f1ce71e2bd971e2a0c01c7dc2f64075747640d8d5729392f59dc8e5b2d2d6f9a5e0efa2adeb55244372467486bbdb1da0dff93b7f7fccd6f7cb98901ddc076061dd35f7fc80e681f93689eee04de4fb33d9d3624c06e0905653c7ab385b29a80b6bb845ef48333a506ad4c24f5976d0d762550bc99f965aefae41c036cab4553ad12bbe1abe82d400032a6cae389a8c84d317e2fbea88b844429187fa2ed9ee5c091ea8f6500e25be32e39e9ea073f0531a4bb2c5ea4e7b295187a5ceb88d8d9cb480b8b96c9fd2d7259d63560568d252a530e276ebcd52f1a53e97af06a0c3874a255d79f7c31ab43755a692846b117a4083b374597136734a85e097b4d0fbbced4d7023d44b29b3fdbab367ff4116f6b02c99085829a0e2080527dd96ef40d2027446a3540ad8917e5fdd902e0770bdcf0d6c4761c60ef24cc8331e56001e6dddac9147aab4c5de5158ddf81563ed028402307eda93333664ffd1670cdbc90c37e23fcbc11bcb44374fda8a10abc9adae0560af3dbbd1f64f19bc8f91483fbfe82caeee6c224151c197c5f4f08b5623293fb30e74523ddaef21ef4a873f8f1cb86c1e2e7696962b8ff096e77adc3d1f6b59bf318898a2040443e8fc6c1bc14ca0bc28ae272f7bfe22387deadfcec1b27f0e937068e63a2c35f5a663c87cf3347fc96d0392ed801a50eb67766c38dbf4d99f889a7241dd16aff09577d40b1d07d6f31498946205b917dd0596a3ec7d3776c07970c62cf7c057d73743dc079b98e3ca1960ed9419acaf797efd01951da6e359f8dc88f5bb1dfb1b37b7b6ea262c5efdfba9ff3298b9095dee82434e40376430f21f18f777008a2404501d4e64013f18fa781860666f7861e717fb681225f043d125aaa2b94062d050dbe003f690d38f2089e034eeef83aaf36b07fd0c4f0e46e2c9820fe20cb85fd75dd2f5f9a11df2145b4b4cc27e5e405337e4145b8ef0cd740792e7b40bf864b017e9698be8dd3d28a5599b501348532d2847a5f45fe09297c0722c84b6f128f8eaf41bcf76d0e52c98650ec3e519a7ebe88cfb71ad6bee90e8f95036c75e534ed1cfd89905120bb79b5f7fd66a0cde78dc994a21c387cfb51177a6d3e913157dc3995e2bde2f3c08590aa1f39882a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
