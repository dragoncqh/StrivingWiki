<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7f8424e5f89d8950ac91a3871aca530495d10451a2452d065db50cf5b45e96597e9ea9b3673529776c1d3be79cef7101088d0049b66ca805dc4f70726cc6f1c2f9ae20379e71f404927eb9fe59aaa945ad3b97bef4ef5e637d113bfebe7eb687dfe9fc7d3c4318d90c22ae6b529c97ba00a25b77e05819530855ab536aaa6c5b663d5b080f31869a448e37225155e54f6cf574dc88f364f5d8c07e329128596c7790b97a3279b99bc952fbf13c25380cdfa70984a2d6615906adab91b26a28e47eed7a10ba092a92c0ce363feb3e374571c70e37988a83d027538447cc0688125769af301af6345725825656b50aa0550417811ff4bfae1218566a7756a079ea0b039fc28a23fc398883528d973c86b4d25f43629f2d3e0bb40a267bee271c54a25fa2f0134b09ba5d78edc9c7144de0ab06dd766a6185578c548eb10083bcf01e7e801b57e5f253343391dc54d5330b2d0253057248556e34bb6f5056ec251613ecfa3c630f7548f66e84c8cc5cd3206a9749b519f7ef5b5df23a3e16e309f1667f0a4a10ba5134a11938efe1c672e86e813da30371cb146997e9ac1ae1b799bdec1a999b9cb737cc68f5b8a4082fc135545a37ca3147f21194568bec8ef71f90bc86ae55460f9814e579f48953a60e59f2df2d66485a5eb52fb91148165b7627045ee78d2962985e4a873684a81ae0240f1e4ae35d183c93e5a02f4d699ea2939c25404bcf2de4eaf95f9e12db0074a96412ba2700a9fb812216ac3e1b1aa8be95ca0944787f9175ee33829aa2d4680d6fe2e6239927496c8f57ec9d6a032afe509676fdcdd7441cb459453caed0eb1980188358aa31afc53357d3eb6c481acf865cad4d01c83b638bc31ead39447cb5eb9cb9464140b306fe6dd28ae6669770f50988a87e1e180ca6dcdec11e3955a972baecb13ad982f673d45b8ffe53996bdd446708ef1ffd7e8206be58fcfa14e1dfe37ec1b91c1227a485940ac729bb8e81f1cc5f12f3617c38ee731cc3814750b4d0df0a4aec55888ea738a694f6e007a0754bd827e2a3d568864736024b527552e227e35a6d90b2d6a76d983f50e6d19971c88bc52d41ec60a4c56933fbf5f28dee1be7d91b27cf9880ff279f07af098bab246b3b13496dd595af84b4a416e648d4859218d79ca045343bade4a23f5d6c740f37218414349813c5b5038cb27b30941859ebf27becf3760476d7f7ccd46812cc56adcd0351f9775f1018834d70de27b3f48b30df848cfb8b50e426f75567ed7a570371488485f54b0acce752a31103aa659ec3395db39409aa7b699eccfb49d459b3f0627ca81a8bfb94d169c357aecb813242ad6aec1b15a3324d797a8598efaeb39eb7fc5ce8e53bccdc862f552f93e21484778dd2d425159f96199b11d2d36b009b2ef8434ff6505d5a516cbea717d1f92c78b4d6ed768210f1a7418874f24cf65b57a3c5be6606e54fda95dcda7c1ff35d488cb03ecae236b21b6ed4a66bf70f6eaca022af8c19c47a322fe51834ff0a4f836b2e436d772b2bc8488a23bd1f327e02408b43c44ddca41f054c5d79e8d44de2d8af43de44156940d9590917608ae51e3b009856ce0529ed267ede8d9568eb4d4efa19ada4d3702af4bf1dec7b10f4b6991f13464ac909958201c05c7e201c6eacf8d3d651401b49bef4b329b2dd24605b5bac73193ad513a078e0c6f30fa778586cf60201dabe81d18c9767ca19daf62d0b30017858daa46c7d6a4e94647dfffaa453adfe4121f9a5dee2a3ba461c396fd22d85cfd46063634311585b98414fc5095e316c2a7f66f3102f52ba06860781955d30ec2ee704457d70024d7dc10b8710a7c01e80547c91d660f2c63f8f6bfa4f5f3bc7f084151685230e4a97bde6bed329dc2e6da94fd01843ff428dfb383c0780f84f6a507b23e6edf3e61eb0523d2d6df5374d729ef8f3058cdc906b4bb310d0e1c633de1f4e475320a71b310b707744954305445f91fa8a68471959843bc4fc69c45f29abf2f0ac768cd6cc90075652463465f5dde1396e183a93398ca50a0830e1176df59157f99ff2eeaef07367b5227df00871abf8c244193e8e9117738c6d08f9630c527c4898e02ff28e9283f49e9ef28c0e17ce234c65fa0e8db545b387469fb9943a203ee90c426d9c712f52551a5db13b3f93a5bed092eee7866cb7a5283e5085762d0d7c6125cc3b51bebd4ee96b9d31ee551d43118a0c5606025c64e56b8d263ed045426abfec83172c1d4fea581a055e9c3d42cd871a096ebb1d2027051f0910482c6fff77c7b2f6031ee3581a4c118dec072ff492a9edf2101894ba47bb26f4bcbe9944a4fc7829cc1944567062973b1eab19c32caac2976f4e5960d74eeb0c69e6849190b0e7086537adc9ebc024ecb457982a92b12cb697b7f9ee851e4a06a76747013dab8633bd5f562fea07f4e4f93fca5360e99d5d2328fa8f168b16a9b4fcec74e325f794b59c7825b9b60e610dc304a2cea2b2c8420db33263228deef076b5c58cb58643ab50822ec2bd7304770342eafcc08615abb287000c4bc5197672fb2f8afac2a56781997d9706098e99391f3bd5c8ee8bff4d4a812e945839c6aee5516ef56daf5e7f21227b2502e6527814982b0fd919702781da7b8bea8e37a1d27e98ca6c98a1a23149074e5765d3d3fc9c42d203c4b9cdf4f69cac3ada223e3571f9f6938e42cc23a304899b3687c52e33655044ffb1417f68a14860d268d71f4510705a1cfcdbc72c71193a3aa24da20dcd5da40cf079c71e8d8a2372f442a9801dd70204e27e6498cc45c7939bb43a46b5b2da55a00beb1871da25a6b281d9a10caabf7817d3162a7ef9c0a9db4b2567a104d7c070ff73f3ff7d4be65456bb6fbbacc47ff486c7dce8aeb1ed26f459060a668d1e7c57d2801496822d38ca28b24a4db4143452f1db8a616bc95d676001787fc0eac2451e6e2df127c6bb5e5198356a8eb013fe8ad292fb95ec871d19a891d7653571cc5cd5f5589797c8647633615f6cadbecd01753b1af3a9ba98b27c896959052b9db5db20d61cb9f05ce83bf45a83c450fe10cb2574190aa17c0f67965bada38e3bdfab56fe4a56995065c79593543b9bc1453d10069c2b09cd5798157a22def842081b447e14085820309f1b756fe8bae0283b7b71a3aeb992b581870e2fa798becd5c52a28c080e122b24fb509fa6cd16959b27cea7839ae588c6a55cd7e2092e7beaf88ee725b55d4e5c7aa0998c5494817d4cbe5f8080884ed9c52da9fb445ab18f965d75e1ba7532fc7784370e90768c7363385e43a9c1c9c285f2be7b44902d6a79393cf30491f9174a4d30196a6ce96a3afeefb8e1f5b6b123c59e4a3e3b2d9552452bdae16c121bb99ec5c41aacfc521c91e4e56f682338bd398bf3c6fc24ad00ac9c0b4c76b6979ee0107e265d8efc4b21162298130eeb710f53d4be6dcddc9c276f8bc6f26722401c8843355c79445ecc438e69b1ab2da21b1ad6399617dd880add7cc8f45329f7fb5fcd3afef8ff8c822d9378f7c815e700a020d18eb2e4b1a12cc54df2d5b5bb1be26836c73b398544ae124b5aedb43005f909b9179c528b2a3e4d0a57cf865e69c0609a05f7e2d61d42fa93ab5d94f2e60a7e505bd060c79cb67fbcd42e2922d9347bf3db0a8d5760332cd3420d2a9eab757f1a7a638301ecb121949c1bef32ea3cf672ae1eb9c94d7eebb0ac9f0e9e7bf45241fc1d9ea3beb847b977bacb228345bac4f2e42533a768df371efc6bc5e1918e4c21287ec7bcd3a5126e1786341648ce4bb920329332581d1e3c255284869d69097b40a43728358672b8b772c6b5d3b0da15ab902a818693fa6311bf4ecf78201072cd551da680504a0a312d32fa0da2f0a9c9fcc0222255e955da8ad7ba7fb0c837eda14f599fc2b0ed63cd137e30a1d0b799e1319216175383ae6e8713ebe968c4ae99d30febf226a819644012f2f04e46e3a4537c38c70fd97ffff27f5741cf5955f2e9809177ec37dccd3412b7b1f9514fc621d10822e0611d5a07c96ef0269c2f435990e3b93b7c264a6d05662f8f54ae3cfe32585f65c57c96b65176b9015b418adf1c1d51adeb4dd3db34cf302ce3d60104fca3cc9ef85d84033012e192882d3546a814ab00a11dcd44f222a6f61a0fae2a6c69be89e98b2b94902ebb231f51859d264f1ecc05189452b1b5fdac082e996ef1e5c6f26b017a3efc424bff48d453ad0820663440311f143211159dec34653908721072ba99bcb39edc24dbcc728d2866de21729dda9a44d6845edf9dbc2a49ca93272f9ade802ea2db20185335efef933ccb069c69c486814bd88fade5bdba6bd572d2f0e7a9257d6a64316c6b285158bd862bdadb755c5ae88d51aa86dc27a0e51b448a5fd41d6e678404aa64cec00575586d2a23676c58a5507180b10f5053f184f42264e55e02a91a2aa0bd833f0be74496fda160f464ce983eb4138322b61fcbff8fc19d06c3b6f61026942304f36b76009d70db07bc5e82580ccb07aa540ac0b4da45abf3cd205bcc75642946876ed2af4e91355103b2264b0dd6c947a2b1a5bcd1809b204bdecdcdc6091f0a262d8e90f74d4237d0527b2edb98832aa4221d6a2f08934e2df362378dc6e87fc5c7e0f20872fe8df02beac7dc36b29141a71d15a6368fc0c4770b66c2f5b9b83faf4213c1e74ab9f72c827858dbd3eaaf014cfeec9f3c5edadf94b3bbfdbd05103e401a69fabbda6396d89a668c94badec0513dcc881976cc2ca787587de89c83dde772a9b9eb09f7e36a47106e698c03e64af2fc37b89fb015082627c981fc4b5659e0ba25699f43e9976b30074abda19ea832955200ef824bcb28c7a6623ca22ae23138428fbd0595dba4e196eacd3ae1277914bbaf2843766cabdf1a7e6bfd6e7be264924bf613e1353c6fcd841fcf130c4371ff90bd183b3401c11c74449f9d131c1d99ca06bcaa241eabeee012d81657b2bdada91d9f120daac5a9b17bb982394b6ef38d93ffee1cf1d44a18b0dd3f1c2f5a8aabf2e475b8c4675b36f6781f73cf6fc9a8aa161c36c870951db3dbf90c560d8e63fdfffd274c2426ae6081965b27f81dda62304441ed7bf8650afccc7b87a5be9e4f00c47d99bccff4f5073ebbb7f9fd364d0e9f895959898109b14e6379d1bed06fa97a84963a9760826e51307d1484dcc892e0c122bc08014401f0c7db219e9e88e9dc1792504f4937e83d6972f77e298c47e81750b7595a14c330ba78dda2705407787f84995b48fa3185c2d2a7e30db21b820b3bf2973340220baf362a73fd3541098d5630b88d9e1890516cf1428b9606b0ffb0bb75a772e7bd05698fdfc03219e5b315ce7074ae1a9992629862e8a10361fb288b62e988092a20b05b2ebed7def212291d5dc2ed856377e11d4a2cff55f53d688071e7b0ef1f08f861b3da629d05282761cfa1a658dcdeab74d378050d6d98c86de1536d5e002b46597090569d14a7d84e529901ddf7c25d0026ed1c25353a519053d58dd3228588775d9004c3315c7a74690401e2b0b4dfd6dd517ca6f99af81789074d64892be3ccaf72898b8e9c38b218d67b1862025416992ccc83a8727344b84629e0d044583f8d771f4ca5983e75dca0fe1738882ec03a2d0d9fba3a0d26c4f8b3f22b9a7bacdf7fe9ae6519dc050fd32de8ce63f849974b62db16ae8602b55d99a00da30a1836160d8fad0bf468c9eebe80e9d7cc05b80bbe5bb98ed48cb5ae59c4da13a2acbf4490b1c8a5a2b2fb94365a5db7763b9f6af7850c937c5783dfb57232ac74f5cb55e36236dec19a19a8e8551ef9b712e67100aea701c1ea355893f04435bb415769ab09ca1ce1b34024b7aa8c99ff44dc34ed8718403b787b0907198650eb5d4e074ac73575fe125b569f28eb467f319da654aad8ccd6b2cf708eff6d761228308540808a1f002cf40ec7576e7591f7fb8d8df335de64242f798c86a9a64aa02e04a1ca876cb290f1c007480f6e4bc5f878734f361662ab5f7d1ebf400c3060006863965418c4a6c231f35ef90a0af9147e7e01c8bcbe79678d6b8b69bc466f1a194348e043500371c559caf7cb17d45d48fd18214294649fa186d0a1c14f0c0341f810f26c248cb4e84d3160ce02438e1c998b4db97e5945b1af95dc60e0c35e1d32cb9136c0776f40f314fdec1657a25b4b7bc56ce77eedf07c3ae43727658fb436775ea6c3a5a5ba30207cf15fe705408cce6cc56ee447de70950366533373c38a40f5e2b1a58b5cdb04d8eaa959966fb8ed8766e5f8dc226c6df4c958140325fd93ea56f44fa7638baa3e95287776c49639b370e34f3f464a0c1170361bdb6100e8eb7fd85d769ba544d57a61cff516e4463223d9abeb0602dfb45e9b9db6cd96d2314bce17ab8ca9d895664bac373c4258f3212f8c4ecebdf4fa9698bbf8978393c478a79bd9845afbd60141b2d4953c8db5e3f11e6021909ddeaf784b6fafcb67f6c2a8545c3ff14dc73cc025e933a1c00bef9897327f51b73c656a0b440144866930b0a5274148eb04356b88cec8f365225905dc4697e99303a28db1b12dcf60e8297c354740456a2d70223a772c7c7e08d8483df055b49f4da33e348b91d07e5ce190ae115da0c31a214c5cffe7202f7b2a3202413af24a825cf51eff077bfd57004b92b52b3377c29fec82ff58b8952ff377c3b7defe1184aa204dc328e6f5795b9a8858eccbd0c867765815cd1e6f45f7159043cf2002cefe3e03cc18645a74f653d432fb70f9cbc2beed1aa37d0d452e313ae74d6d0608e5dbda4989abe09f6041aeb1933dcf3541b91902fbcfa7824a87db2f402be20baffc3a94d0f4cc5b5148344837cbed6e0e1303fcc344fb9e8dee27bf0f857c9bf9137300e8e3b9adf4b3295e128f6318830930133fe40a82350375c594333926f908c6313ed0296c6a62c9b2ed01d5eb9c558edb43cd0ee2e23354ec3bcaeecbc19a2e56c5602aae8e7fcf1fffb627822017c7f04bc10da35e81a07882c3124866f0fc78d531b1ba3cb96c9dee282cc590c59d266acdaf107fa8b24c1d8cbf2ad082e0551cbaf3f89c55c980aebd8616fe40940c4e7f084b88f5133cb53280e30454e22dab0a6ae8231a5908d16251dd0c18b01bc1c0bb4fffff1e992bd07a236f020b84cd6b53441ad4a0d005218a71bd49d6ef6de58d10cec1b946a0122ddddb572febf61a564424255a6a4a60413c7d628519d387526267d3833cfe306b40a58647f784116322747722c2e1114bbfb48e77113ab5f3595602a1a5156e4efdcef7322d22250c9a54913e45add1b00a2c5582c4fd0bdb048ead81d8113ac817c57eb30bc2c8bcb8ada1ab5818b7e66b3cabb015278d6523f1e644ba4c5feafcb01e8d86df7ac9b315aaf385fbbcc128a76d8209323fa82da1acd4633e8dce33503c87ed1787bd7ca3455a3fd11eb02852fc35fa73cd9b7a32f420ea4a7ec527edb8e91387e19aba8a5eccc419c6060587301d9e1860264b6dc404ade6f6d03c613bd2f75ca61ccd4ffa2e8fa06ce533d0d419fdf77b5b4da39ec1142a70a5e01f3025383d09f37338979c6cf05f3ab3e7191658e1988a15e0a03c518fa841ae1bf54ab5ba93a8c5af4477de7bb9ab30df9daa1cadce5cf7eab869cf98a7a759b82611178beaee9111ba1e4ae94639bde151424a72e78c3565679f9aedccd2f4d9ba7326cf129addd4ef7b190e73917df010e6fdf61aac05559c0e60464bc9cad9d495fdabd139d4211e217d23002739e76a65f9de81b11417ba925236f4e7e41cd356866a903920eed88a82415d8a80a719944a72b6bfc670f6f20ef3b440d1cd1d41eb12bb1cd12f20060d7ca1036f99e51785a9418bec743f0826174d705b7b1d9de97bf35907423fcb192fb1568fa2dcb432fdd5543952c5fb32a5022c5a1f6d0939b0bf0543fd138de0f4e7ad180ca41f516f5f1c8abf6d8f77c41cab12b1b6d95c7a36936aa7896b5d7b243682e59982952a4bf5c8a3cdea0611e29c86942349d758fb51dbfbc63b82107f79aaacab7111fc427bf4b2b904654af790e17fa71707844e031c4335a4781e754ed70ae0ec02e5dafa4f2cc0e967b1d59119a589135f0021ab853c94d3ce86a8c71ab78349f5e8a9d4b48f2957295bc94c38a9d2cf9b52111679cfe0c0ff497324b2d5cf272b4a1af97d400e84f42dbf6212465de524eef1accd30493c9f48ba866bb3c3b6a929c781df8acadfa6cfb6a0ea16d476ef775a7e158320d8f9ce9253b6dfac3fd487be8ba2d337ad5e5082c1b606de7ae98929e9eb010bb18f4b8dcf9f055ca250b705c2abaa773c31b17c25f39edde635408852bad00eb8bd485ed1adef5dbd873db022d75bcf4236c2f8886930db01fced32c580859ecb40dba3b66c1f8ae25df0189dfa9b029947295beb4887e16097b46b3e2acd0ff8880988a5b6b3875a0cb859b812de6e59ff73119093fab5ee830388d003ee1bc177e80eb32d14990b6a15a4ea15b3598b98f6f681c064010b5a33832bc0b5a4c0a91e3aaa9025cd651d0a8c2ffe10c8d28657a022ec2b6b51683b3e0f550a789b5a06f1d10e9b178720b442a335a2eea6498c4509dbe20cbd980c39eb782eda2cdb6cae8b0374f0fa341f5975b0e784b4d968c8e3f368314b1e97b958eeafa673bd3a3a0f818b7a0f3f0045bedce19e5199c3c0efed0761fe9c304257e1a6fb3f08ca6fcd14049615bb158bb1b25262fdc8e3442c47502e710e52ba1c7e846d515f37d8f2d10898a6c848ca46c3a4350e2ae4e6d7294308f4267b9cbbc6fa2cfbb5e313d685add55e79f13df4afb6f79c7e80f31693e2b035aa854cb34d7c546d0f0c7d7492ad4a51fce9b83b1aa649081e11b1460e17a6016d39c54fa61bef2dcc10664fd3b200677562d974135041f0f1fc173c301a0457418f6ec1a6f9864cb20017cc5065a928ee5aa7008b26f3a83e9277f70241bb800501a506d9594b4ad7fad362af3902d4f382cdf88b4fe7dca5fb96706f34f6c17f4f660fab0eb44a2d07910dc040c62065e1e926221230948e4393a1cc4a8f9e25037522135358858efde714068bf519cef8f768241ba299b33f9c4b37469c77defd9d7ef7d5c3b7a8e5a133ccab250c80d95ebef7ba11c3236c62ea8e85513c26fe446bcad58d21ee6359d02abbb74714f1c020c998bea6c7107d8d45e09cbb21e9c40e7fc4c3147fbc9c6cb99d5b0689893f3b708235b19a7c497326e4ea0ce58d69427592a5649ae3111adb5ca8fe4f6604a89329c6a84e329f82a6c805d61ae6decbe8bc57e758e23c76f67ff2bc4265a08e7332b9c43622ce4c1fd595fc1276c492cc1bcabaed8ba5d62aa6ee977bb47b81cb1e97dd7d7958fb0d1ac3defbf1e3ba24c10310f327f69a2e2604c53d2c5ef10aeef30877e2a1afd2b8a979f46214048316c0ecc36ba765fb16abe9bb05abf51dc485ef62b9b1d1cc85c91d334dd449e4c7b60e07078adb81f3487389e0a270cd73ef32e64b52d2713557c2fc82741db21e59c5002adb08334017c62a95f3e4be95c9e13c34a5bb8abcaa64857571f5590fad5ebb1b5bb28a9f70312a2d5bfedac2080a5bbb34eca60aa55b722f26454fcf10db59fea6248c30305cf26e64cb39994d92200cfc5f8c11e5e0e873137e29b05b616cc765bac3d330b7a5132b5672facec51d7e8ff0c86a9f33a88e47662f089a2164a4ed548b5883252a9bd20a7459edd0a1675fa797aa2ce6f21968dc45d9cdaa4567701d162eef48d5970cf8fd00497aeaf1bc4044a62e65036a021333f48a453589c426e210094906a2732ee180cba5372ea602917926b6e5ebc74ecef092e569e86d8b64142c3ae6b536e5b53c63f128cf9f2eef7e35c0ca19c1c9f4b40d68b39920c4f915c7fc4004f935c68eceacca529b84269286a52bd80669415aab84763aa69f53f61192b0d797c46211b9107ec937a597caaaf60c8a235d11febb5553e50b12570d00fe1f3c558510d7a923b5d75104c4034e496161a141621a4b09c132a27dbc257603488096733862f8a1b3f61291159be2be61a0169e4ee6b0acf4ac0507fb10340c5542452d9f72bf3e79eeb84543090f6ddacc974ed94087e774e51a5a995e41264e6af79a8db4277291d40f5fbebe5c6bff1c8af113a43a1eb798e1a6bc4f11d4ae7bc0c6ae0ca0a4fd68d66f08294ae24d5c5746d20801cecd4db59d203c781e000c1241488d741fe803525d3afa552bb1fc0a7c5b717b046b4e30289174eb5203e2728644dd34130bb222941c5841aff0efb04d487b0d9cb2b363cf1d1989d738bacd6c2bdbd219ff19f581dc5d8300d5df0ec15c8bc9b6bbb9d85a2d4bd0e7a2e0e148c29e198d3be29762363bceded7a3bfb9d28d0a55861568b1092ecf5c6ac16b80c61446daf1c312503229d4c2e186148189bb0909204e68be9dcb2622a79e875bc73eda7be4851be520bb51631096ac5f7f8dbcccfc98d73063fae2d2b5bda1b5cf019ce2e4711884c40e59a585c4197651ea686d48b2be797bfcafdfab484c8ec147e8c9814f83c481562bff86034b818d831b2426d4de767f4c37237c8999634b4ae8564f757b4a19b68211a1237d4b4c666a851ee62f72b98303013a42c1251dc169c2eec040c8bba449880ca951544324bd2ba6eb26d99ace608348c60e073d4d7ec3c79421b6c25ff852b2dbbf4d9549e4904c7891c6345e9aa9d57fbda58dc00560e557e72faa9fabde8f3da616e4e8a249915c493f40d3d78d35dc7c2f6b433cc02cf44f3f711f97e48453af50c4b3aac94004d3c5d9fc03b456d49a945e5ea599dc369c771a8a17d5f0b9fe2c9fb70d9d0226754a0fa3dba66679970f5cb2b6bfffea6d9bd9efa42559f699e57af501b6980d5e0d0bf646269b11819b1f3408730e9e301453067c78dbe0bf22fc4856a6371d113ff7d949210f1d4a7b1aa1360a909f30a0aa7480a288024b7ffd2ad770056247dd9fb64e24354299b7e306782834e25800b2dd1185ec20a92da59a2b76200c34fe2d30c3747159366785fd91a173a397121279d2e08f9b65051b971adbab2955bb51967f0e0fec316dc3b51aebf12380be4a414905dbfb135e07280f8fb1a302d5ff3e7aa424b473a47d800efa13fad5594ab4fee62943e861b529abeb8bf00054252b700a61d18f099f857825c5d1b56b57f321ef21ffb9b56246a02d3af8bbbcf47456ac7a11ced1377471427a31645f018ab6c47802b752503c7a0e377d1ca2685e6fd2116498bb16ade2d81827d9e92b11f6257ff689be80cb6b1db408d7205d30226485f45246c52f4e6c2fb13d4ec70cb62b6e1b04aa40928abb424c517d8cdb6e8c9f26c2a57a3a25a1282ad0c27c03153ce8200d3831d65627c67da3b8c44a585b056db9e95ec51081516642885f2a46c606c135e999bf780208b25d63c897e9d7c00676c0a619c4a430614a3c42615464f9367d5cd6ab0eedb78872bb80763f949dfaf0b430b21a6a60b851c8a8fd530350265f74aced7d55359f62e3c98a3b19b088868ae8d575ecb5ad29c221255f015fd55fa32c4c69bc37278b5c2713c8a1b0ae0c2ffbb45a1cd83d4e67829be507abe3a20ec0e789b76289c5566b3cf817179d06e969dff428b3de8fb3245da5d5968a713ecdfba38172f5311a95df0cb944bfea0b46670d72f2d4eb8728a8566e3e28831055ea820f7d85ebafbaf249fb403672aa476d586f39d0bdbff81e669984c0fb67c3fc6b8ddfef27f262dfe33dafe2e93fd466016cfd4bc5591b217704b9c4b34a78931d312303c3f83d2161ab2a88cc7cf69b5a5f62bc76ea64279fa83b46787d9b3402c9ce1ecd72c2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
