<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"72517a4ef14fc0b8bde85592518c5f31aa94ee103c174ae34e1f7906786abd7720079c94af4ca0297b2ba3ca99174dc148a856a16e376074280463d85ad9abcefae431216ab6d712a7d1eb9287ea82d8a65e44e8bb7bab42c1407237622c6652013fdfd0cfe4718499ae2ddf0a065f88e69f7acffee8f61d44a3f453e7a7a8c0de58cb1b18124912f1cb487c1cf19abe3a2c209367dfdd828bbe842c1151c2f45e64e71b79746839adc3476c6e7a5d1b7f0c062f3563e9236dcc0ad8c25f5f02e82a0a7e41f433d92a46d9103ddd731e189888571514c91fb1f0af62b21f2db86b406a03d424bbec88ba3e68a0f7c895c631b2b8db6523e6b538b3903298518f71dbd69524bf444a376786c6e0c87980214cbb138055e5e7d6246a3ce6b71d88379913ee04690c47e67b3d8bd4587926eb84d0d754fd4ae6361586941b5e7f9268051b642218552de54b9249e360c6ad873ddca82ba4afcfcf6ec124647ac3fbea01a284e54f9121e345e1c76efb94793d59f9cd1436463454318f4491851cb0310551f7e786fd8430bbb68ea82cbe245237ce58a9503554784076e27e90cf16ec826241563b4d47a0c8dd9b868389143e6821045570be28592bc76f55fd6cbe9d1628d1b524d6f9b48436fbae1a2708788fb14138a72423ffc6ed9907f9c3e2f08eb36e6a4594c37f94cb95edb5dfd3a74d92454d6ba389b722eed8125d7b94fa83ec3db63ed8c904a8e9c500515b8bc0dc438fafac83e7e03df5531114be7ce09c98d76a6b031607ef1dd1286ef28b80ce14eac61aa28087cc1bd517544ae4643b1c200b3ca80f6a941c7369c56b8dce03dc1d37e3be01f043ee7c7feaeb403c0ce594adcec9d50c5c5db025fbc30b53199509d00f2fc40b3c1165e1e18ebc3e8404a707779fc33edba786e79c8de77ed16bc924d157fdb528e27952fd4fa8f579a2b5c967c2a7aff4d5579e61a32d0c0f7e1f267e2bdbfe302b495a745f7705424b5012f999a9d1b3eb2c5825bdb7e905711c17ad7aba8d0239c00596bbfa87047cc5c4ebb5bb6e11f1ed67ce0fcd74ddb8496f5e738a4538cda7bfc6bd34026547e4f318b51bdb7fd325350836d584c2269d0ce9fee2e8fccb87c28a7267600fb2b7430439542587f682d2a4366d1d42e1d7a2e9ff0afe07fa6db440484e6879469c308384c34dc3305d34e43a612c5b52ca512daedf0857f8b0b037668cfa469c1d367149b2d1c00d6a63858e308e7a09437c406b0a3e6239df3783f002da3b68027bf7afc8f2bdc390263ba34ae3fb6050daf41ae9f48c2a7e287976b54dfd4729f9c9c5a4543d745312c1c62081afc5b8a8fa650d3a27619d288ca3c81b6facdbceffaf3c589c339e36ad08eb3c64d7773d6d64ab03d0621c1bf9af5a640cdb865c48a861366936744d95f5b871f14c65b197aba4be2d090af1de479c0d75136bd7e976b6fd8e56826a071da8707d65cf9f8596a2f7a633dde349e4c60773770910b396c8cda8b52bf950890befee66d0c8e6c9bb2e4e40f91763ae73a64081847f5463eef3931e1f4529840e2a4d294525448f1e43517c8b49c605566ed49cde286b4e781ac830d45405fcfc28dcfbce9209a4685334dab62fe4be6f0f5eec4ec4d64cba174c0e0963d8b600d9974602ba251becb5aa04cf2ffb49bd3498cca8da4eabf91971b8dc2749fb0fdc73c59e33017dae96c420dbe0971196cac25e034a79810a8e00cf2a73ad3e0ac38f6e28ba4cc6d93389059be196b1f8e0c3ad8981792bd12c67675c0e077f26e534b487418c368ab93ca3f66877b17f8179270eed918ff195e5fe481ee97a7c9fefd4926e089fd62cfe18bf93929cd04e04182f9fbc0e68eb30fe08fe029a88600320b6e1cac77f63e4b1b57e7ccb0f1c0f533ae7c046c42b17610f7364a6ec6b51b923c2eafa7415327aac99c3ef5974e08119c226b8af890bf63d5a71c7a25143457573f597e275d52f49b7249e744e53a78420d90be8384fc19e5bad0d23426193152fb2f6e0d1824d3a0b3c8584265dd8320f9eb91216f8dd6e5fc8803bed41157dd565940aaf8423bcbfe0fb07684cc3f3cdafea28554bcaabad5b49f332a8897f4510512c50b4aa597e1a4c3ef7af87de3bc8322139784e5235db549700040210ac39e2062572d53b68134bede7e7bc0f549b3d572d248f497ce64e46b0dc441f4184f47b8fb48e342ec22affa704a9849db563754fdcfe55438e781d74e190e61314de46537f16e62ad0ad046bee9a343f4f5690b2252effc3998070cbaa433c14c000333ca4bca88d6cca6f979b1d066ef664060a237e47a5a593e739f412455a0df276b474df54943543f78f156fcdcc023f5147e6bd25578bea99e71be2699de019f834766765c776ab679d0b7b9dabb3d178d3d0fbaa8256bfba564bf82eed6503e4e850f1ad722725749d348bc066dc2a109d2eae7c378e1268b5e57fb9e7e25e7b2e4232776f0897e401b84f5708f38d703465028fb84211bd4732c6045d9e5586414ec7f60db89b73aca74cf29c7f0c10061f13e1211366134f65bd68901c08c67349470ddf731fdcb48e84a14990f92ed7110f1319bda49da6a341496b0650e209b7b0f64f620e59194e90d7c60a273a633e7ae5dfd8a571d48d9823b5a5cdad5e824691d529d8faaeab75ea9895c70dde4ad490483e41e8382d8d757c7da5d5629cf5c0775daf5127d3be4995ab00a66bad60f06d197c1136a723a8ba4194b6b5ba5a07761c91814294ab970d7889e904e06d512d318d733da49e0ee437e62719e6e0a16f7f86ee94ff932d7a7f832ff5a58d788f7b5ef72d6352a4a81d35635dbb5df51f41148dc13f929fa45c7e73c24bcb5b65d708fd2c0a374405bda80778ab933fc3832d403d2bf6784bfae1ee665855c4b7885a216ba2486c8bcec03560f185f4499d592e31e65fa2ad3739380fdd7152d586c16293ca00596973443c564e896dfcafeb08c3f20dac4d7e1deff1048c5f7d4410de665c3b53cd4503820493ac2c21b5084eba0f42a450649dbb048b077ae042e96999a08f1721261ab814b4f9f6bba20b7e8635d58e443d0705878fc52c90026b4bef11a326cab4ab38b71fed2809e2f40d1f880f0fd07e234e0b70b06c58f013da4389c8f6fd77c2d38695ae9c202903eb92f9b5ecc2a03ab3efb5db52ef5afce63d8beab6cb8f8f1a8c974610984a926e5e5b59e1956e5590e368c734348b72c8f973e4fa56743acceefccd214e755941ad197c9185fc816844a0c77e61e4396b05f4f2f1cd9106a0b88bb3d6b1ca96e569ed2b5767aa59ef9f95692807634e2fddbc3f267e215dec153d5a98efadd847aeac4c74de5fad362a39b73f849b6e49da6780c6784ec043a01c801a8d68193d1928da83da6cfbfd8fdd386e197c1accf64daaaf70fd6e77715e7d34c993249ddc68c78048e370a26bca5417a3e41cfb4593766cace384c1522a4f3fe311cce5aed9b2f6ab516fa368e37f9634f1577bc96298e917abb7154d63e3eead5ab50ed5ddc208679c20b8461d12820f1e4ce05f77bc1082fc44b82458401aad47fd7788bf49ecde65c8126a28b1068b4fab313b609b1990b99d253e372c6ac8699a3fe03e758dc2355d38f4d5c2d21da5880bcfa3fa18303e2cd6a7bd7527e7fca3c8a98b7df6a3c63218ba2a6e5bda6c61f2ed949585773628d6f80bbfca797af237df41aebcd2640ae1a5edeb02b1cd46830b184f9dc758a37f372c85bd8d5364a8d3718d06444bd28422496879ba69885c2e65019de88f1136f555efab1797dc290aa2d68b4c3f64e449282913f222a1777377cb906cb9ba825aa12b5e641757392e2afb96af05b15a49ec304f10ca15b492c1e36926158fe87fc0f69d2ad61f5fdc0cab04fe7899e0e92f6acfc1b4116bfc183c0b6b386238dd41d253d58406f960ae17ddf0073c1bec29cc16b2487ad86bd7ffbc59c614b500b5388cc8778ddce300b2307db52a959a9fbdbe5cb2ae2963fc345009158751ca1620fdd557e740745f39274c2e21e288746348cb2ad7afc3ae1c356c99c6f2a716818174f2eee571437291f16c01cfd589933d85a26abaa60b2417960ef39f99893b7143b0e5ac073ea919f2d83fcf7c5891d3d74ba7277a6fd29ab61948fb656486a3886b7f67195b16f93be663b6c9a49e3fffb732f99f4ba620ade00cf3a3dbf8fc951f31d70338b3975f8fe303b8d9755fd0a178523e04506fbb04716b8c86c97b4f519357e6727c13f0b85c7d94176299f4ba7a3558753ada2945661ac74b1dabccbb065df72662f4c2d1e46a451b9ee8994af8a06b6141271dda81a83bdd7ce92d3a43adea08ad04314038bc5094f1350f6bf797e3cf0bba7ead1226b8ec33994ceea8a6d61eee1f97e022714af525c0f008b88000ca20c467451b45be0fb0387414d73c7244d9ee6998ae42a1be239f3df93d1cbaae24fe11f71643533ffeaedaa62edeed12fd125a1fe37547f6b7ad861221255475ffbad6cc3e9f645d7c52eecdfab9152d143e9f46f5f170b8fd1c03d8aefc3a8dd2665c4ef8ce22ae254d2375fae2af665b4064a4e87f62c66c77537cf4481232812d83b50e956093acfca750c9fa3538ebd6a33acf370f5e868fc858cdf4cd92d15fd4933cac325dcabe86d508d531282294d414c571918a7a536f772c9521a4a2b39f3be879bdcdeeb10463cb4aac21f33dc7e5b38eb5e94f52dca4065e613cb8358c35804dfd0b7b3a3a758e72a674d5c49ddb80615ac6807d172da35b3d043f09a95946dfa9eec845e14c7761c72db539dc8280b72a215b3c251ef2c3d5c4cd2a6ab56d6da1bc21274f58f27bfe7c24683aeb12af9bd318862493e75d10d8bd5575d2daa88fcf1501c955e0e90cab1aaec4e96a2e19a45e3b768a39fcdcbc544a4a8353103986ef3d4622555f0983dab633582de80d350b5ae411c3e91ebc2bb26e269613723512c0871afc66c560767f9e5dafcc0c5935801fa4de6bf0287494e3a731c815ea17c77a3a45aa31cd720d477e43d4f68f4310a28cc57b0572fb48d0000cdc0b0f4a73f316f09d41eb40f9bfeff36858a99de9abc47acee43d12b64e667209a3be254c42506eb5d05fff428fc8859bd97fe01139c2ebe6ffad0931a0eb93dfa72dc65b041c5bb4e9b7f859a6ab87062b12a4772991b7134f9209d462c5537a75c918f6f96966bcd10411e52f02c15377b40735256b1ec058246def76eb5ec47a70d4a0cfd7940e67bea95f6ecdebe3fdd182506eaea832e2d42d9f6001a947dde5b03f740f079b017518d23b5774018e066631ac54d8b46a39ae40c3fa79335239d9e56eed6ef41b61a4806d63ec8d1a8dd78f321164437bd141a13478cd4743df5d07ca6439d424d0c56cf56b66fa0281a4bdf7c3b0acd57e6a91ec16c576515628a92ba2972e0a4be982de2118c5cd2c25a2dc25a7cfbf966f97e4dbd65f9423540181a66fe1b9d804f876dd7d0292e3f9a58e6917155a1ae8922704c06dd2d8e51eee02c80496fae026acf6783b91c77939594f7f5fbb16ea84885ba8783bfbc6fa6891ec16dd41f35eecbd37cd10fc1a823ddb202950b4fad00cab5ebdea4d71089330fd7b8e8af6b9528374f527d4ff757c8ac9abf015b22401e78314e148ed8c6daa97a4a9090b7b3f9292926226416246cfab7c756e955d6215666efab9558cf10b1acefe176f0f5956de14f8c76f3b596053f7ac7d8c0f5357919eab34d378b6bcdf8b9f9db1880af803636a55a6c336f93ca0358d48b9e6731a1377fbf9643f8f8dd3f3329adbc6b03bf949db89f53a33af73db2e2d5df23bc2240538028f6a78c75fdf605d17154156015ff393693cfd23aea5ad6e2258acce6a7dcdef5e866a7213ce6926ca359b20887b8148662efec9b83bbd9327ddc16a7cc7a48ca0a53900eca7713784be02f58c6ac633f94a3a48f1b55a05c419ec94288152ef6c753bf926b3046ad47b8120d6f7484434fc5d8b6eac79f7f692818cb5b5f28f7abcbc9e95832cd3ee3a5138dff2e739a245ed92b98f9971bf9674537afae443f8d0356baa6454177b83d5538007f0859a4d7d70a5ab76e0490ee97dae3908724679bfe6014f748674204c3a00a2e95d692f099f2495b27e04aefdd4c03ee2650d4eee601580caada13e03eb5c726e418faa49839087e4280df39b00ff36ef175862614e5d19f1382821f3bcf116f5f9ce76fdbc0697192ff109a9cb7573adfd65aee26b8a52ce6d67070e9e1a3db283e6bf9f188c0fa0f33ae13e91e121c4b8ba07fd8addf3bb496fee4ba0b52bce0ec4e6a9071d8213baeb7dfe80c05e45b45b119c08a6f45110d44f7482cb3ebef741d46de2b484b36e9488f4f1e3214f25bbc10fe7f386a6d52e8a9a8cfef4a45bcdf4c8ea30819fb7708a6afac019968409e7f3849b7709623d60c09a55663ba38c58d7d7de5f53ff897f9cf01da6d17500107e8e6b8e2bc302f236c6f2bd387396136a5d6df308d07d5aedf46eda5b88c21f1d391674c8101b1abdeb0380fba7a6dde4d2c0b1e44fc0ec49d3e0da097dff40963a20b03d79c84273db8e0606226402ae21958ced3c4a7aadb46156fc4859fff5b3a0bd351e490855a425e9a237a5e045d650c6af52ba24cdcfbf1cee87c9419c5fdb79d52f8d2147de4bb724d09dd941c66eea7b64ea2b58967b42394be291aaca76c32684c4757fdafd4b53d8dc7c0c396e5dec5ef025cf573f340106ef8e64cd6579d44b7dde089e051fc05aef132ab8be94b3a3455fa048aaad8e537c847b085e54c7e17037a699c9342d239b43e897facff839b7f75a25e5638183b61038b724378747564ad3b9578a783f5c1b9007377421482c55198014bf2dc6939513e61cbe930b301c0d5cc9867836aed3f7a480bc4c2d7f86cd0202ec42235bd3c066138323592196d9ab689f92afa96d470a001261fb43d9aa248087148b07ebdbef1054cac7674eab02856c5ec3482bfa483e442c687b78ebcd0b8897adc67d1b2cd70877b480d54d7973ddf670063961819fe78b30729a05b2682c2977b6eb6361c9426768eb437ba803bdb687447643deca3d264f6cfd1b8bced3a87732a24d27f49fa559af040b1e125556ed18243815988039f3b24f05babb57da2578914a9d3fc590fa4920c416626eb9e84e4d175dcf03a15fb6fe19a3fa23b495514cd455962c7af008ddee5b6ed115903f4284b1faf8d0e60a12a089c8daf136e585440934720c492874d0134e94fc2684f439365f244f9866060bdd693666bf77c271bf2c15f558d58a7de747eec02478bd8735b11e8cf54260ef896e467e0a3185957b0cd8347f7d86a943604d6055833abce91d380de6bbfc7a647baeb25b0ef9a2879f0c496c831e7d96a4c5938bc0786058d5d1bf16e92488452079e93523bddd6a2bbae09b411a66f2d33817c31b398814921158587e434bd4f69a25ee913c32f3f21fe207d4dcb7dec0a9e393597b681718db95422eae8acc0bd30e89bfc7252c653a9272dff6c83042e3c712d0506c1ab7523a05b3317292234e2951de0d0775ca6ffa0bb24a88f8296e8da8d3438a700eda39065ea2e798ee9d8dd870bda599136ce19c5e517d817f64345bb825d5cd5bf1b38921c661dd83724366aa30bffdee4f2bfe687127f17b6856323fa3384579e4c992a6f8eb6da98b0757ddbc6ac2947fa6c5f03b0d694f02475939c648c8b988068ed99c16cb02e2a503b7dedb51bc9a1a7fa12fbcb39318e85b439eae2f2b8e3f0f7ed2880324fcde941163ad9535f7cc7e742cf3be953d732bf7f7d3a4e37ac6774f552d8b744fca236a6e2de3406a269929217d713eb1816df31b174c51f8aa3b596703f657b45af96f4df1b8e15dccc4303d10d03dab9093c4b4efbe1d179577d350462303960b6a855cc1136d44183d2b935ff715020a2fe65b536edc754e4f738937dadb8577536a3846c6729b45352d7d9995aaba8af2b6169659059d4f75eddb42cac12236bc197ee99daa6790c47eaa4eea644a71ed20f4b60775b4736f0725e40476b8cc102ade8e17f272aa7977753b8db605b8e2529e9851e57691299a6e35c4d776deeb1c71b3c8b462e81e6b6864e6ee8a39bbb5034cd4f07462b0c2638507f5ea8a238ccc444a6c8697079b4a0fc175a360157c9855cc6add55f12ea09bd51ee52db940650f52c44634ecb8616992787d22364a73ff551476190eef0b7d2c98b045077cada9518dce455b5f80b241f19d4f58643958418b5293e393697bcb8ff7577974ff618bb4de00119db6c0be2c290093ddb0eb97001b4997356cc66dbe2299bda6cfee75ddae709198b779d57eb2147f218f5b637bcce5975fa182c2fb5c9a7be72a474b5a93c7ca067a3dd1f6c18a1e62719b7d6ffe13d2065b359b956bf19b91e1d18078fb7a8c214688fee56cd91fccdf1da132bf4e1e952a0a503be5f18765982d91c1a6f84447ca2c31110a31d4166fa3c7eb5468468dea8abc3fc8fd261b2f919a3bb12a659a689c41337f20f62ab856b8ebfd2fcb985004342ab507cc0e5d68ecef16b96adcfb8f97a0e4f357ce61500d11113fcdf10bcfb980342c49f7fe7600ebfefa053f2a5cc41f0ecbfeb32c26f699f41a2e4254ff833adaf8ce5135af982dce8610e50b99eb3cc70263cc91507da04d0509932f76759baec7f8725e17b4d4dc8da850a6ffe49f0df1afe62dc2ad43ff2e57364e01f911cb1a5e7ebef0b7a5c8c4c49c859962afa526663aa7e76e2ecce180c483acab876b5efbf5a86fedc339c88978c08cc40cbe87d6fe4415f3ad25dabfb3ae14e5b784fc5825723a185c58e0e32208ffb7b89fee585e0422e0840cf0f0eab78f37236e6148206674be07aaed49704ddcd819d0f6d45a6b6d873579dc61523bb8670abd45fa6703aa8179aa2c9fe3016f2b4c65bf662601454717866869aa36e8874b0ea1bf0eecf604563bb0f986c7a9e063269b5e739c64f1d16eecdde76bdda40072e8ad76c41103d46384af5c293547fe8d1fb6e5f3e141f83ba226b401343643f010f870df11326835b785c85445692a320fddb2db56f35f288454d9a44b07f6674370b17ed4013456d0cd642bbf85c4c40b975738df3d776c17b2e45319d24d4b05245f9b7afb7c1924632715b71e6267a929c754da9478f1a732fb0c9f17add7c29b22bf1dbfb414fa4ece4fe62778fce8ce37351c3f179e93e8050bb71014444788ac05463a428dae4a0e584989af883efcdeed9bd959071f8364f7dcd3b123d26fffa7d2e58265f8c53d0cb898090148b120abde76b272141a35397ce44824b7d66764de9168788203508af1368e467cd01d2d0cb511a32f3b101cbe6930e6155f310564fea73968684a4571fc8aa444483d03fb70e06e741d9fe8deda5339c2d227ed3c34bba925f9ff1841690cc26ba3aee53e3c872cc92d3eae969517d9fdb371074a0aecf5162f6539af7311f1be09bf7d38065677e8ed8aae863e89f7174cabe391261247ed987696d30aef131f89b53e4e9e3300d3b6dd17956576805b04eeb19b3707a2ca899d9e1f54048504d5c3d4e73716a8f4e847449aab215bf6cb556d3d2c65a6516622ffaf1a5bd6fc54fd3d9b783869791aff538f279af01466566f785d09e26fd9d821e13a7a3a94cf4c36c9f1f2093aa48b120822cd7a5ef207146a613b2a15f3c219d4d5ca82a0e849550cfb76b5d1fff1386b4ac34acb33dad1b4c1e0a4d67c3e0846bbb81f9468f83258d49c90c7cebff909039b2c47fef1ac55e848d8a7ab2bcf05f6f470cd7310d318b31be2f6ce12f2966fa59b8796dfb0655d55976a48e869807f6a6142525f8237717484bef8c6ceadcc88bdb88996a5af0a3a5f569fd2ee052ff3bb0cce25fb2865c35eb965f4a643a22a168e532884ac893372af207f2afd2b9d0514c36a7fe7d6c3ca0ddd2b2085b426ee4c34ca632b96415766cce5b7b27c1337cfb779f2f6647bb041207b6eeaebb5b127dc552d80714277087dc2104108f64c501aa6803845ad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
