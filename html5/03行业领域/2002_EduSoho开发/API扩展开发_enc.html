<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"631b23e190beef283fec8d15439c6fa7d8cb99e5b0510faeabf1f48787b9cbab3090b43af46f6251e45e7968ffd3a98316ff5d6c91ad1574eb7fd05cdcd56d43254b0561f37bdf09bc5fce6d48bb4d51053e077c6313924d972a4b78f4a941dd2bbd79ed8929a55aa5112af87ded81b673015c5168efc14794826638cdf3f16d214e55957a06cb8d2e94f2bf8f9bc9272edebe25971d89cd8380b1355c132bc02450ba4c0c87a90d6c46dcdcda194b72db7a8bf19708d732ca0afed2c27ad236f49d10b0e446f07008883b50000ffd3ea95a1336d0afa30fe3902272a736c6311b9682f57aa8e6d9b020a3cb017fa48d7f662b60ee4ee3d0d1f391e60db50c49d5dc951afe7ec53205f94364a3baf2153ceead7a1ce7e4583c62fbe3d7ba64ba048ff76ceb5a7ed1f528a9ca9c15063d0236c5dd0b7bdf2f07c5ebd5bb4f0cee0694731a5ecc554f801eab55aad7de53abc103c18a49bf7fa4dc5f7a30fb204db0c0827af167450a3056ac19eb16b19ad65dd8ce7f19f972d936368b4934c791ba1fc173e9e9a9ab45d91d8fc586814d3f941dad190b10063fd1cae8b73230be28fc826f12f219e75b7dbca9a699fa2192103939c14aef28145650fed29e34e31aaaa56861bb114fdfab4db2bce958f130980a1532b6966c1c4f4fb2447138ef4f3bfe47fb52dabdd11f79239cfaf4444242fbfe2f5e6f2d7e3c3ee03e3541c71607ba6d52ded2ceff08d150bd3d5ab3a35f6745ffaf7749cdcbcbc5ba598dd5b91cb8ca25691d11ee4792be5cd18cd9896162b68c85e096472a0d9ba9587103c8497160070b96aa3c23a29451379d02c2d42354184b35926ecbdc487bb6f46f94712eadb7cbcdf5ced399e936ee93b7b45b9aa704f7f8dccc4478b41acda64cdca3377fb782f0878904f515bbd47aafd6689d06737252e69712c38dd90adcee267aabbf43a71f3c32cc0bd1ecc8bd54493afa412f62a27a905a24a2d3cf1bc553b158a03f1ce1ba1a0a9aa5723739edac377ee0a34741ed5aa9e900ae1d3a4cdd3454fa97aea713cf0ea64f4cc131dcd81e84e081e5576761fe9132652e8e337c01127174b440843ae6e70ae09772c4e0cab1ce38c77f71cb87b1d374848bd4c1258a5ea861712f35615c405ccd1415fce95a1bee7861f396d3cd134a58b29a10c7828dae3f1967c28d7d6c4b31626cef4e7f49c752a67cdf4d75d1626edd96fcbd76e76c6aaf55dff83c05f17caa06eebbd9bff042be8e1f0f65b6b685c151bf606baadf41b81a67e46eca36a4fc402341b23cdaa34858836c6edb7a3f74a0816eaa777079a3ed4e6519644bfe8b48465cce258b40f7d152ae564eb0338eee9589c2af902f8e5094a1b947cbd410b295ecba71a22b0950a5dc558b867c07e0bb350265345be588278edb8e0793048b07e247e03aa37822192c2fafd7e56f4b4a78bcbf5b8f65620c7e315d6b9685db6561a7a0f65becdccc3193cddfd1e4f2441541b3f5f21ab1ba2236dc023c3ac2ab7f23bbb8b191266c5677eda3365c23a9b6cb3654e6e49b10c2cd63774ff1c76a49cead5306cd9dc4953f848b2dcbd3f5245882e2c3eb1649bd4b9faa403a223e2630f76f67d496f1696204686aeafc49f56bc6a0785baf0e6de7a2219113f07776af8a11c0b1d8565aaed18dec199a001846898f51160d328527abe6e9f3d5dc7161b8a07bcc72a0370316e31d12651ad206eb11b9ae0e57ae0440161c751b3771b0f3ecbaf0171b919c5275e656daaa23ff85e87c2ec4cb438c4ea164168817d2a4f3adc2c7a28d1fa97364684407cc79037adaeaeb1e6c55b12b17cded21e8289769cc4e0f42cf3e6afc478dfa56626857276a70d38edb4e74c5c9bdfcc4b1388b23b8c40666e4b7e81af8648a14a98b0873ed7a72bc57b4473769f0bb1f5b8b0afd8e56b6cdd52fb2d6fe4e16d19137e456f982ff908436edac5594e2ec36c4d80c12c0f6e96a2abd69cc6717a498761ea7beeb9a61f75e8892bf4852320794ad44d3f54e3c0f1faada48f4613be407ee5497b784d0727210b6334ac3b87aeafc9cb12b2b5ce7aa0e2191c6d6851c4c4547951592fffd08fdeeded28535fbd18991d855c27e4db1e2506d9d96fe91d39bc25a36b5ba7f86e441b4f4d06cf201eeee317683686eda81c1779a5cd7b061880b2028a41c2b7e0be2094a0c1797efbb1bbda3f23c5098dd19c0379e0271ce66991750ce8ad4880f01e790bea60f58260a6dfb02dadf0d91734cea1b1ad4d77c2dc53f35819bd3b4912497e1399cec44cda63377c66cead54ea848de0e3bf82ae8dbc08521934db30c8dbbdae3e8971c5e1b5e27d16f797a262dea9455aa47ce5cc613fa0084790372bc1038f8063013cc018850330e71812643924d7ae986a2a19267bafcaa0a10f642ab8c785ca4bf7be41f0da57ed458563074ccb993e95e0f1ede69e01b4e35babfd7bfebf0bd6d295be325ae6f51bcaefe4c1c4ba1578cc4b3e710d12ed456cb5afdc368dfd6ed21cbda3aad55a5c4f444118f4c69f63dbfc9e8e32019c56b6478b0aad94756edfc2d5215435000d4ecddd7ff33ff09bd61176abc6d068d0a88ca3cf63a1bb98b3584d7346465d5a2381c656bb87ec9d0f541a52af0a8c23489be20f4b37a772bea3092b6691d4c9bc186e94ee93ecbf693c38a8d088cde6cdb203db1aa668a190064563c615e77022a43245f88fba79ac26af143506f2a2936565e0efab61b70b2b178929488ddd8185c6958748bef32e4eddfd42a7391f6671e3890ab4764ebeca7a645d315226890261c14a7a8458fabb7c2bd3782525d0de68b59550980c07936d0cee166f40ead7542f4159b6530b288f1ff95e31cfefcec11d51745cf494c6c2f62711c049fa0523ee454488776064ff92762b03319d43047f5b19fbdde79e011f6b8c02efa8db07d9e63380ed53636e540cccace80e0bb97442666881c1999a3666f7b2dd65c8d76db79e01ace17c801a5305f8157f1ab9caf244ca16c7ff82288d1a1f1d9c8f841b44fec442d7de3b84bc8a58df8a0478edcc18b3ca1357d7b43283072831e7db4de8af19ce384966cacbd1c6029546153419c28dd6b7f5a3f7315be0619eed431b04ea73204c089b958a50d7f7f252b382d38fed76755a80dacd74e3a11dd15bde3c051416447ba0772352795d82731b6dd90d0dac5bb68ec7b933d2b9543a58169cdf7a524eb2dcb704f67d65dee8e0bf1117f5ba64245bc6b394f6dbb7e3473a36cf078b818be891179d6de1413fece603f4b739483001cad3557dbb16ce6fd425947752da418a10deb1cee98779a4c1c0f9492569939ea29872267b6ab9d121ccec611f1f9070909a7ae36bf81b260dea805f880ceedcbe603e33c3c812c9384c762548a3ecc22cedae5c7a0303c1217a359333df6497749bb2a8eb60a570ba10c5e834cd196f7e4109cdd6582dc25567911c020b9c2d3e007d854da8f9321ad658e4165e6445e89700bcf7ffadf66b82a7aee884de5400d7cdb4740a50ce58a76de0109259f8877b201cbb4daafef4dbdcbc1e2fc5996888f793f26ae0606c1620230ec4f44dbaa46b990d833961e6022e990d9dc0fc237646a5e9c3fd7bc556497f0023017b037a5a467d75401e5628d2df7f7fb0c70ed592edbb059b6adbf881a478b70e6ebe6c1b4b401b5eb286b6cc135bad4066f9dc7f696094063216350273b7d7dbd553f718d45d1215a4bb2ed60324ea59fda0b75d0dfcd48419424088a5430ba6d3fbff1eea8c40a16e5d916743120a6eeeafa86ef3fbe16a9cea5304042d94c288a3d9b40b91056ad22de796d3e4e72cf6a799eb1bbe8c7a0809c254e6e2ec80872828867806fc57febd5a66c98619cfab633b4d83bf0850ccf936a70e2a242b6588e103671524b489c38c103c8f819656a5554b958db7eabfae26afe605cbf5d35b81f035ead952a7ec34057734d6d5f623bf9c5595efc6aa50d39092dfa4b7aff698b73035f955c44d396213582595641aa499f834cadd8bad9b86e95eddbb4c45ed35d3ab245c46f40c1852e41e8515d05ba0342fd1515cc308cee2cba4a41375cd485d3b59b8e08cfc06b1dbc6aab4785d95b5d1f94a49a88e9f0dca3482948f7f13d9fc5471a2a9d282f0713314e1ddf08db20d0d063a976ae2e394667c41d8a093c7213df6ceb3e783d0bb140e56ea1d0702e804d17fa5d70502a12c14a26d11d9dd40df8fa56896ebed073f35f36e016f968514a67f6628944c398ee24addf89ea07b5a181999f397ec006de0b8fcdcef59ffd33eb63ee7f731c8b71019ccb5647b789d0a0f04408ac9a4300cd8b9814bfe747a266ff1756f52cb21dbed50c6dd4051921df1123b2f66fa2d6505f7b5fcc5c4a59f9c0e40db581c564463b28ea8c7569adb2efb4029ff32efd2cea529a7866462fc85e2a8b3d34fcaf8c26c54f6ee12e610db419c8c90294490314ba7d5762124e3bf8413873a4ec8634b3971883c1295698e0f7d03ddb88f6b03513e4db487a1486b071b30e8ad429a6cd5a6172998637369be96e2d585037e8d83c3e407683b556d90d9fa74c80e30d7737f811712c9cf9e396258029e890863faa715aef66829075740ec657c691d3853859f8eaba7ca935f43d26513a232486d0db7c8618a0eb996542cebe3fa7f57a420d932da157b478c2a23b5f1b759a6b11e5713aa515c24ebcaa50189cfb9fbdf8826c4922295451b0ba799a20ce0876634994a520438af09ccf381601530d51b666775e17bb58052b2d0b7fb78c9fa5a44ffdbb01572dc87d49b1f4c6fde1e0d40b038ea58cff683dc6f3437184dddae7283ac17345c19d1e7c2e9f93c8193bb60075588118cce1c331bbb37f121c2112025dd2c29bc85b43ee7c27867d80a45c4eefa54ada3e1a37b41ffd0af2d3393b973a412037aaf19477711a25866af13a7c63ad56971d71c43819845fb267d1c2a9afef637f1801e4b8b7bcba08b2ad8dd71202ef6e0c1be9f190aaa63f76c53dc612f80a36a585b1e2dde1188d1d1658635a65e1c691184f17509dcb240ea762394b90022b217ba73629d5589a9d1cba157224964365b0ae9e6a445ad6a3b6cc4ccfd9bc8ddcab88f029ec5ea9fecdf1e6504203ce14fcdb87905260f62080571249e80a47154a2d25864e8e0248714b904f12af6af6452778b2c198a95d7867e800d4d455733f60b1dcee3ad657e45f6d673c06f229430bda5dd2f7babd647e6ec18b13413157db7b8daa96679336320f40c1398b59434042e2172ff6ae2fcec9c5c0d90ca8470ae9b59bada778119f086506343f11cb16a42717912ad7c14b1867c15a4cbc788ba7be0cbafe40264c344bd9dee55346b205c6b68121ffbdcde007c45a1bdf69c5a10650226ca030e3b26b897f9ced34f87775b9c8995cf6a92e8301b6e53f56633f7860685ee16fa74bc0b1b6adbe801e662069cf618ff3d5780177ec1984cafa41b29131e7bb33c8ed4093ceaba59bc8fa6d779c31417bd6b4c00027f37cefded5c9d1de3e1f892c56437ce6c477d5b0df02d99bea52602f3421eaff81270ba944c7096333386bee3137d13aa0fbc4d1bddbb0c406d31a205cba01ee13e135013f2de2043dba1a9dbdc1cf2d208d632d0d2e8f48516930369037445989818d582d58e94db3626d626d901971b7aff188e80a2128e1dd620dc5896e97bb2e3fee34acc3bfa5f017b352a2f0ffb7fc0b5fbbf18abff7833bdb635db0a62f132c61b3fcbb1d88090f4161ab0894a2c32102af99077642bfecc1923e6cf99cda9f97ea5d7d12c3c071c2884dc771d6dff7618b161c7e6dd7098d33725fb469d034e707b116f95e4fc7e55fc3201d515b73f44be4df7030f989b00105fe702c914cfc75ec30d4f36ad1371ff67f7c9470a7e93753068e0c6250f55b080f4c4d61b2a835eea9e4be8591bf0123028b2cb17a87a10303df8a1a18a40f4a4f4a69c96979ff99290c9065f0cb5d5dfb5fae9d956d2c99e26138957ae99662236160a25c98f1dbf8a7dd60b28f34e0271547b02805031a7fffc726a04ed9ecdd7293c870f7c62060f2254f4b234b18a3f001b30dba55289c20ffe3254af01a537c3baee899dd242f9ae3ef1a2849b9d2b3eb5c796e4bcc3c78b5040392e63ecc7e8b0d84c3d0b6343596bbeef09d6f3616db99e3093d0fe046bc6327b951d12547eb9f00926ed2003c517dff90baae2396b61fac0f4f11047ea4c4118e7f650adead0dcdbd9d79756ae4d2be1ecb63bc648bbb5a8a4df7f83f99a83a3f26717ec0d912779c0c19a41b2871ce8fc95c28c08f54884e34b32a25e1bc9587b4c66c1bc89a7542d517be0f478b3f44a7352c594572cfc9fc2c7d1b3f80cb334b07dcb446792b1e5d8276bc7fbb2605994199e884795d90fe0aa72099d295ada7bf536facf6eb62d21621d8fad64857e93eb20895d6eb3cbeefac73acc4576b1f2ab02c9bce83e86a1163520b3a4bc8ca26dc7c8d0bddd1ba11a223256198a090740a4207475037a5edde4c91a8eb81089e634f4ee518a06ce6f5e40379793a5422eaa89d8a545f9af0612af134eff2cda9fc2ca3ad7cb7cf8ff0f5bf8b82b7a33a4a775980cf04738e441e9796161dc5eab71a64ebc1ad6071f49bb7c95b7b20a936bb4371a6468a6e94384d08b9d3572be0d2ccd77c1cae39a493a78373edfbb6996f3a5f68d90adb8e29f5d431de2e6de258505ec3eb154ed46184743adb7fc8b6146ee71e87ef57bf1e037c4e6eba0c8abb355ef7f4fa469e699e748b07ec3d6d2839ce576c06e6e37e9014ab84f020f19c678b3a0357db32e60544dab3470d3602be9a588e619ebce3774f5f4637e617eb98871d7398f69d7593d841971314585083e5cf400734686ae93c981f8b06e21b12a2f258741564619598808351a9f94e34d0531c2804f755612f87161af2eb0dd9af11b45f5c19ad04d54a5311438231c0ff51e437e8e0aee8fe6e165fbadd6cf7f9c5c628bedcadc9a8dd45d22e5d46f88a65cfdcbefb124912e433682080382a214015e1ce821589a0b943843108af0029cb9c0661d674a1bad7c99be2c55d889e3338f8a07ee00e29eea381668d66764fb888903cfe52d1aab27f17e65d367ed3a5913dd9cc0c3ffec6f1aec01e31cdd1d23a7135d9c7449eb6e6d9dd3c911bb349b62a5e356639a75eae2b259b62bb26318cabdbcebafc96e8fd0e7f5a4b3c2569df7e62d22a4d9af47b618cf9122947ba0ec45d5a8cef64cb4efdda9516a5c3fce922b9a146b0822a789c2ad3026a8b739388924e85e4bf8b0e25308dc35c6fd2c651c054b0f6eb76d024a808472011d3abe591ac7ec2656c260242062baac62c3779cc9fef3fdd9cf5b3ca4577a3e925ce1c221a2fb13e1c4469238cb2806c8403dc538b1db619b08e07ddccbeedca280451ecbcb096c6597c3e7b684173635649b402ad8fb643876fd42787ddde6a58cb581c08c5086fa8d2ef88e139bcb351724a685ccfedb66cc31e687d7b14ffbed71f8e100d3efbbe410d4ea62fb47463a813eb750b1d1f546ee5b5a03dd37c9b93f8af770d2a9e9de4e406ccf9841936e178a5c0ba224d99fe94c6dd204ada0cfa5282399135c226d74ee5625cd1827af9229ba4a2c7b07119808bdf77d1e3e2b5439b670800865adb0c062d3f35daf10bd54b57d4c4bc20485d85f36cc903816f04ff561ff98c3ed8e8d46d55b507589085558fa1f4321ad45ff551d5180d73f174aaad731f4edf3684dc937d03600c079061d674f148d4d05b72cb67496225c7c3e6bc1468b5cb2b6cf65ac8fdac0c15b91c0985ccc28d7061efbafeb8b29487d6154dffaca1761c21cecab43e9df410cfe4b602671abef40653338c5a9e36f94c5f7968fc0a49811a1c7642c11b3d2380f898d87266fa957d25e6f0b24bec04b7932dc72b5d5c318a6c8abac325df758c654adec0b019767e307662ff77f6ec4299f347fedc4551baa6d2d2502a04506ce7d8488d499027c36060104c976582816867e4b85e1520f32b7c74f684b06a229b635611f77383dfd21c91511a8ce0c31ee9597c5a16cb7e2d18e29c5babe5cc328571c8eea207de840f7378ef5a9a7fd221e9ce3d0d9c5686c6986c96d7cd12f673ab666554a15762deb2326f1c7f1f640802b69a1aaf98881ac0c1e4b7999c6ede7b48a9db36d94e9fa50d7d2bb9b6e2c162a29e9d79a962601485715b072e90fa03b07497824d19aae1d8b9052870d8a4b624a4ad8d705d2f1a9540c061bb86242abc8aa3402b676ae3c286745cdaf8dffcf0d53a228a2b0974a73f3bfaaaf0c3e769181ee670252036a1adc6a374b97e77e0a1a4b740b9d44df05986604d3bb83ac786821469a3f26d65758b4b396ee2ee83480824496f826120bd7ea7f527933765341fe0b52d2127a51ac987144b481c8d16787553f169a165b0e90fc2e3e116b6060285b46c9555e11aa570ebdacc0819cb4df40f366ccc0b0e3d52b9ed70607082699ac19fe6229554de085df62b94f744847ac565eae826fd1c7a7a1d5bebedeeb187ae97db2c24b1cfd21f0753faea41dab5b7642e881e7a9db657979b294980af8aae8e35020b93c660a76968a68fc43eeca23b047247e5c185499b9867c85cef56cc1c9c3a51364934f9bb58e72fa5323c4d0aa2cca79be44f11729b9109230fd39043fbe041e8e47bed9453b480bcfbe4e785ac9606675c178887f76f62d48b4f3a1b1e40ce0dc0dc344fb68b3fefc26527c89eba6885da7358d7643fff38856f93fa4107949490695df388c55128e9f59cdb6530ff1b2592043c061e53f5b328d6456f1411e31aabed94d2d05488cfd49d24f58fdc3ca1f4d3076e01b9e273dd3cac73781c621e279966f6f88c820e37b30724f7a4cad7d6559ab8a252348df9733358c7a4d90bee7f1fd15483d1efeb20c6440a61ee1c1bcf683cad305a1e990d93b1dcfc49ab36e31128266b9cb010499e6d8fa7720fd10f5f3c219b7d13a17b1ad27f3f794659656d07ae46672b61e60adadfe83ea5f5d705e59af8204ddd06a3192fddc3ece0702617830cd9a7f587e6559e97b4fe0e5c34e095c93e9f1aa85e682ada58163a281b6436ba340ddacd7357c1ceb9b285b191a3628d7c5a52a9a90f22d4de5a31100dec539c7eea223b2e1c91ce96536bb413c922dc6be7f619125001a300c558d2866504d706ee91d639e33926cc900f54c9d2990cc7448a7c81a40772baabab86f0e8a762c57334a6d61256064db38eec3b12eae0b8448d2f54ef107e9b00cad5ffa2115f587975358dddb8774187cda9f21fd44cfcdc71c9b6f6fd539d951f79e2143e17d98c9c6e650e5cfd19bf4a6236b97375488176dab6779f581d6eb646b97001229f4071217d735c73c10eddb5a4072e278c0de9014a90781335659e8dc8ce8362af4999109621a90ba99713f4466e28ee3651b2a013e184b14e559ff70344723b3ea60475dbd26fc2115d52b8d724e533582fba1e1bcb30bc6bba0f65ff308311f6fe49c069a8368eee4fe45b9a6fee835752b3aae162d461fce92663034a0e63c2b145ad775e169fa59d58337ecf8d3cfe61ce5b71bde4de1a2908229524ed1e6f6cdd88716b8d812344b32aced5aff9a62d802a54b7d0b96ee491a7195a7b158d7ebb4c71241a340c4842df53a6a692b8e21fc667a73ea73bd25c4b19f7ceeb1e9bac8817870d92540b073c776ff995f0bee530238bd5b3bacda65fe1c44420661a25b888d610d9fa822d9e51304c88c40a72ad083fd7865aa8714c53b967c3b0a98b587a00ba73a5e7530e6eea479039e26b3cda940790d782f5476ef998e87c176574bc67892dd361cf448936ed734b07e0bd48088532d281a6e4802e6d743ec0b27859dbccec6357a168e5ea0aed1e5589d7b31e009391957ce08890e0f02e574f33ec1aab5dc6ab078cf43a3be452b25660bba218febdd32e86302f2ac8e5ef14d3c49f7cde50d46cc81bd1328d54de44ca35f264eba463bd8564c137a6ac837737d497667df97fecbdc654c8e3482e4205d5d7a53a90f381007dcb8e35838d46465022a4af5485346977d793c026dca1d417e214679e3e2603fc34f1207201f8ebd16fc4c42fa0455a4bbcf53f4b187f6656297672822aba98c52608c737fd097445097c76c458aa41163b95ed08ae8e749e17c84c443aebf77d7c83d65b562f7615b4f8fc465ed473664cbfba949411ff235ac6d0d0b3e56bca95f5ddd9a7c3f2b5f8114df27657db9362397d96a9a3d92f2253f7634a2f599fdace6d732f59e190d6de548f29f819507b57a5b207a66d85921876516c0de379fc232acf09a62734490fa7930ab3815a5e0781217631f31c320c8f67813c12a67120962fed3db898bced39d81417061793f2ee81a5d5feeee1579ebf04883f29cae8bb3d9a140983599c555dde6b76baa53865c2aa619a02e7e65480dcd8f1f7f72400cbfed931c2b798a9bea64fbe1abd5b727cc240a11e1766006399bbe70569a37d5d80b0d5e71b27f21f84d0bba72276b290365f934cc51ff8e43600f11b41e041453733b3b1d5e486a03ae12bf2ba26c233d809e32d81bd228b3774a86ab3bb6d7d2445a3d6376065da42464655247b6777f6c8afb44ccde109662f37e05aa82ffc60d2c382c8598fce46e94250a38aafa75a1537e8a6429f3a0437b4f0c8de75c595149575bbc7b7a10a10409652f0973db95c7852a2693ba939ad0f29049d763b601cf2a4509ca6d166772069fdb6ef9f1f89a3d09a8a3950423927d627909275a6c3a5a686123535cc5f2305c17048de4fdffaadda52eb5beb4f3d21507340a025ec902fbbb88920a7e495ddc785eaf34702186091dee53adc97adb5730656f3b2e4827efcce06e0c2d31648ca0f3cab0c7a584f1993c447bc3247b4273f28c28f5fe417f3546201af635450efa2243dcafb3642346ab33052c326c037ab1e534a48d2d97fdd0770fdbc539249634f265a6ba3801476c74c112378b01359e8fd19a5e4a88d887b9f3ac177d51a79fd3cc40f4f3806fd0fca634f7e159379566f28dab856c99a702df8b6371b28667c28bf72cf12f0b0e3634f910f06130d45cf323cb2f8e9a1af3608d9756fd70a9f1e78f4d662a17b2be47bd762314bf80bd33c337ba3e3fc5191205364024b37957b3b5ca3263c3f6811a34076b17be27f7e1117877f8d0e3994aacad62ccaf394835da32afaf2df7c998ca7c0511a6e9fc468a7d4e6f77cae46e00c718b9a09e71c4db6e62c926377eae80191cf6f20869150775422bac068ac1942225a80306f245a6dcf010367e0627aea85f13b37a65f467be257ffad616526080c57db7d5b33d845689a82e6009e139e04cdeef19149eb3a4696d0cb77400c0255651f448ddbbfa2124fc9e093ecba259e9b347e033f7d3b38f45101b1b98644db3b1b80e8309421a51cbf5166739761159d9973f0fa29c880d10432551f10cd2b3a27605c7aa428bab7ca297e1f7d1b3ce3f621ec5d06429daec228cf126f18df042b8f4093655f33890fdb1008ab65120bf8f79be60bd4056235ea69e84867e0f552fe459fbcf8a539ee0fa4b73146092f6362ed57bb8638de6d3a35e7035742d43c9c84ac06a7d87887b9ed2b04f2c1e68736d01b318b030c28919ca57b38cfb80cd1db02cf105830f143829ce7b942cf5bd4af1ac99f674c7a5a37a5e6696ba71514aabb3532767b57b8a6592ae994b05dfb16cd47a8e3ffac6e7f850599a3e6e3b8af941ae0a857c9f0a8b1a4585dc0302a785d16e4b5007d0fadc33ffcab5ce0ee07921d6ff007d10acd797d873775dc0942f00cec02ef39cd23f7096312fbdc77da7d01f8caa8956e132e522de07c1c3d94f7dd3577f09c7ccb7c9f9a883d25d05642564c624a73da1786978e12631c0857877a4572c236e2c5f2e5dc4783049fefefb739b72a2ccbbbf3f5464e2e4eb6ff7eecb5dc75b3811aa59792c7d12c5a2b36f483f600dc4e54a44b6c9bbc1eebd97a63b89b9f571b4a4855e4f6e51ff6a41479f1cc6d2b57d58ccc882db622ec79db863b0a8ad558b04e813329208f7ab977df141762ea750dc906685a289989310b7e881a7b5485190509c86bae536946cf8b29f32c1ae250f1962ddad49cee2f9b7ed4d8bfb5ea0deb8072923b85bd53784ebf53b3450e75e244c4ac03d3472f5fc69b32d42fd0926f34900e4982d0b312b116997d091210765237ad8e59a5bad379fd2a5199773f7669b470daae37d69a1da4826144a18f658a18949b0382ea46a99dfdf60ff75b3509ef9759ee47d5dcc191e93dc3a68ff7bc5ea4716b1d2e5e0397185b948df1f504f58cbe5fd6b2dd29ee404b2bc3ece92572b3a380c3fbd5a0837759a4f6457c7154d4cd487f5e8ff8d69d14ab0c8897da19485477201d1060cd0dfa93fb58b3d7912a4b550752706123138bacd08f4c9e49850e23acfa4a1b0046e6c8d2c05e0b4a3546f2d7a8f845cde3ed9b2b479fa2133e65241ebdcec6cb7b9f17656c91c06d79db30c17eb66732407e66c4ff34b8073d79c37d06b18eebb1b139eb76fcbabf924653e5fa785ce4f9e55d886aaaa9b7bbcf2a698c3f356442942809b8c50018e5c076579e7310f81fb94a7d9fb6fc3804b26446ffceec5bfca4f59a1b6b77b2be4f20b158c30af8ffc65eb1b82d9a4289eb028c9ea2863d8f602b2b4f30d75f7c802bc5f62405a3b0c28c1987f959b4d52882e63b0352c322878056390746bfce77659620085273331ae4a45cc6228420bc409b71ab9ae02db455f619626bde777e47586a57feb66680ab011e67c4a3fb1e32272d8f0e45fcedc63eac3b8e7617fad93ac6b74b5dc9ceceb209fc7db68cf6d65f2d669cc23e2cfcae512faeb3e7bafd236041dbfebd29658fc39c0700e0943c38ee7a20c243f73eedfce18b95e0e6b09c925bce5ffda4579ff9ecfd1e8da8a6404c390e8ae0b2be6f7a6580c246e182d911c92c998cf9e4b9a6e89841b72667e1606de01e0a287f023edf9dbe6f96ebf037e8c28df6ed4a44b183bbf12afd16ae0d7ceff8024a5e21c6e6c31783","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
