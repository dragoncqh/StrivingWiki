<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8460c0782009a6ed4428aad6f593ffbd8a70e306b041fa459cebe328faf227f494bad9e624feb162fa80adb86a045f0514f487f7e78bc009827d616bba70c03ab59e3d448ec476329f23dc4b7059a4b77a152e59cfce4a5b0d26a1b260c6b6f24612e72a28e2c0fce1488ffdde32fa07af60b4684452c53f5ab8f7968279efa1ee2ebe16d03fe421d65a7c4e4aeb121ba754f4460355372333259c3af0027e705d887e636472c4b1c1b7aac9af3ae14a9437315a7f69f68bc3897c67ac9b9e94d5a1cf16fced81e8b7b0039a2ebcff9141dc0819058812b732e97f70646a9d899458ab9e1bc352a8c9713df8ef881015ac96eb881bd6a8265f16ce2f31e7bc92a70038d5c18cc4fb475a1d899e1824bf7b5326eeac39c66fddfe14d36673c3c5cd0103e59736fa449e8e34904e991828953e32954139584f846399d536109978dca1d2ab4dd6c52aa9fbdf9984dc9e0a253c0332be63871242e10ae6dfe316b9e0105f010d9a00c3c2fc0f1be070e333dbb0e61f0aaf981a3da7a7fa60e8c8f58542f709e5966e92f1f81376129e927e91a9a2e320194789c7ef12319d9449b5036cc8a691f8a7fdfa68b1683980dcf13f5847d07d11d4a73841415dadb77140511595b4aa1973a76497dabb83b767cb2f9dd0b993d81538fda9af4bbff731a51e9d1173cf3bb11f0c13edfc7baac0c9a9e1ed1b12d2b601477d317512588fef4bd1731ae196a77e355db1541e999b0ca1f7675826043ae93adbe72349db48d274f3da72a325f611f059246f86d712f44fd20f6dbcafe656d3255d9ff0c6efaf55f97a85847452135e50ec3e75a74b090bc8e171b3e5bcefcde6b00fccd2bbd7209e1a5a152862414fd6aa88e871582ed5373e0c962539be1807b1a75a8bc1679c332087a2971cad229c7ea607e750aeb798d2bfd1b7cf1c5fc8271983d06506a514c65799bbb343044e691c5a9fd8730d99b9d4c4758f650b666c64cb56b5fdd39b4cf62de8f9bb63dbef40df32a66dcfc2f0bdd31dfcb0495c934aac7467b2b1e61f2be6c814c836e770d4d219a0e24a72b0f45ed5ee94e4b7114cd4adbe9287aa375d130437d7dfc9387bb1e9bafc37ba1ceb5d031d82ac5dec71b361d6d6ff430a7ef55bbb5695a8b33833b9c69ec5cc54486db044b8e46b7d5e5d6ea7e8761977c25a84d370f7094ff99589fc5e555bc3d7c88102d74118ed6ddb5850dba2935865a5dc1abc17780b66cd879255381f79b4bb1106bc15f022ffe35d35db7da426210dddf4a343fb8e526a74710bf09b751cce509f47d9d2c01d00f2b9b79f63bb56edd76e6b039df7374909dd982b1e5a23ce0f4bb0ef2cfab3ad9786fe5617cf40a61aa5d7d410d6e67f1f841372f7ddf612d92ddf9d82e2a4086361276159f9d2a25f5333cb9d29fe9de607caad89aa8091c3e6a37c04704a59e985e850a8ac4e02b449b083f9c0c20a15b62b1a3ef2d29e11ac25c703fd09fbaf8ab2d2b946ba8e01f21ecbafbca029ed56a3efeb079fbd2ada3f63a692d088963b1e805f07daae87008636e313da3dbd7eda4e9d67e1ba4cba635b183459be963bb5decdd9dca2d45a416ae924275354170bf1cb8943b78645bf39f232debcd176f364923563cc9d90e21b95f71a40af5007cfb19cf4204c94f0fa0563bfdbf03f490784cd74d14d31d80676364c686a3cdb56b8e46a628d450ef8e17a71d4ca73dcb513caf90c6f5616bff1add5843202d58c2579309d989e44a220af126a272e522bc91c76e43123eb7a9e2a7d0348d65c922dfa4e2f108579a0c892de84021ae725d0aeb0db37d27c6450dc321e38f07dfb0fee09a379d6cbcb99d69bfafeff6ee80f8d7d28e04997b9343e45537b7cb7bf297210278c3bb6794d8a53a86e4fa7b7a1014d66dec4764d2917a5ddf5cae09059255ef23a6c0284bc7cde9a5c0512cf397bca3d3e3405c3816319c396a74cd980dd329f1cefab318424c8ef3fef7a2398c965600aae7d6bb8caca6e888994be3b0dc8f5c677297bd7fed0e27adb9c22bfb44b9d989329f1cd0ae5d6ee0df22b551aa8825f74a98a56b7e5f6a9e17133130b685d898da5b5d00de5e83a01c6ca25162908b4805644fc60f8d99c7aeac7fd8b5fba1e73a26b253aa8bb97065988e94e09bba48b7dd391ec93f4c190d41ce03015fcb85cab68251acbb1dab2ef95f71ecfe7982a21ec0308c2be312cea53a3689444ac33eba8eae0359edcf388f97babd9274dccd1715b0c6a53269cc25c054f41d12b55ba72d53ff946e079b365dd2fd70bb04635aec38a741360a7ab4a850cb5fe9c54dd9ca65fef500005e7bdc07ec8c51d57dfffeff1771ece29911d4d4cfb84e9b055a954629acc661dfa873eac5dc9e25dfc55089a3a62a2d0a5b75905fea172454d3546abad6b3c8f0be77009a236cd5d2112c3b36ba691eca80830da56467d6b973a708cc8092ca7c95170ef299e6d0cbf0a2847a77cad9dcf2d8237b90b7732bbc630acbefc49d4504bed2874cd5097b736530981e92b2429cb0ddefa3e7cab31d1f5f869dbd271afc6dea6f85086cc1ce94b4ea9b859413f203cc2cab05653d5a61324e4a2bc0115ce0f68b7347c1947d7813fe07bfd2898018cc3471cc994a5063e3958911b0114a23ed8be58bf652ffa70944936da8f7335e53890b1fb30ff36a08c23b74cb21909fd066f7315c6c66e3f3e196dc855c2c3b1b20f65310bfd535e3bf12970a57e3d89b9756c7fd32e92357294c13e10765193d598781685879a025e7da42876399a0a7080293c24677f9965fa6d2e77e4c7e1d05d31884fb2abf72657edc04059162477f9d5e3705e175819ffeefb5633bcb6b660866e001a6c435df23b00f93262e89ab71b3f878387d3ab4992844fd72474953185e5b71168b89e967b54a45636042df0be0480b9d1aad4da1b1b54afdb0d75f1f7c5f8591c3faf109f46aa0c367056a12d07a67c79d88f7997e25cbe2809d6a37558417fcca022435ec72191357d4cdbf31365db04598452e539dc866358abc45ec223c8a40abb4053ac4b253b0a78557876f6ae7dac294dcbf77fba4abb2419f710261bbb393ba065424cb69523edc1f9c3d40fd7c3304307d7530984ee020d2ca228744d129fc4c4bd7c44555d20099b2f62f1373092f42ca1f07669518da4784128bbba0703139afe3b03457e6f27c5044e9c83a5fae8a7c5c7b15b8815798241cb03c8ab73d39717d8cc4f52745bf69253547d7c87e6b7a7d856a4509dbcba2ed909cb2327e5e4abce18c885636e39d5d88c7ab7460c7db1c456a7cfba4dc4d78bc59055cd04bdc6387fd7ada96f9fbdd78dcc6e339bdbea21363b93c58df2752a6e9846845110439d2480ee9c9a60fb232e904ab50be5eed865d744ce7d5f14b1f5b6c1f509eab571406575d9b8e266e3899587b66e358f6b5a9f00be2fb3963ffdcb29cda9a37a93e69bb3a45a890c86161be72b3785d202bdeee31fb5c3bb3076f3567a5c911847042e72db2b3308591afe5b6d190d7c1b3c1fa75aefa7af6f5e8766e1a5e4cfb18640e242480f1221e35e1972fe7ad292b374b15e1c3c20fd5b1f0f72f087765b7c656106881a342412cab88f2512e1f2d06764f56de58183900c3e29b88df167f21d6d3b9348c0d1b8a1c6e6998ecc6b77b7e0a86cfc897182c516e6fb9e88fe27b226bce285e0f627d69103fbfaf22840e16ebc7af326300a4354630ca787adf6dc18305ad74e72953f70b6b397ea57db9da5174f89836e344d606f994228a0782651cbbfe8a4e8d0aa3cde38d98544928c200f59634ff1fc0c872fd7b472ac63690382870162c8f30857a0d06e1d7e7bea3e168611f1bc0df130d0d8b88b3c5a188b1d40705674a572eb796cd497833e7e62affa39d7259ef280639b9583fec9dd4ae1e44bab7fd5aa06bf8e20f8bc26c7cdcdeacc13c9518ac4a5dd28e1d6db9a08663c523b3b76c8a1a77c83dd9e4b953cbcedecd0fbb0b39ecc2543f21daf62c5bc36ea11d86721b66367260a1c7701c101aa89dce0e2adb92e792ededaae788ee76725dd6a2404cec9e4dd9d6528fa655750f02b1de9da24baab497e5b1a98109ae2a3679f0981bb881aff2c1bdda4cdc1c8dc2f62ee0ab728e74065b0cb2989afc7f545dadb47a30c2e8948112baf5f07dc00cf6cb83c0c0f3ec7d5c16bb45cb41c74e2c5dd5df94a1987e4cd38c1feb2e33011f401649e4a81ae34d6510e5d9d885b4c1e47af0aac20781ae55cae1a5c3e2e4b9827a4c0e692b1f51308fabbe4c68ee5df4dddf8c7f94b61e1e0a60670c01d03c07a90c99d25184c8fc8c5acd6d859ddcec49dc044baa8c7a2fdf7e07c997d05d732368a553ac593de85cab17a67805a05dfeb93246e25930c755b0e19864b7ee99edc9f3f3147b16ea7a19d89351b9d88f87266f63ab613c1dd585f98c028e68b2297f1cf2a245237c978443eb39ca62b403b44d3e7533aa18b9b952d33c470098a336ca620fcf226b5703f7961753b5f7d7ca6896bf6ae933bd6831823927e13473c650a72d197ba6d2b49e0134f079d0ccad056d7dcc64d040132612314199ecbce94814893ae03394d95970ea504012118268ecef038d24d4fb66dac785f89043876e8d08db90efb7fa0969dd8ed061268fea0b34f3e280f20eb33238327594d3fa2d6f772b2384f801a431e4d7e83709bb7544b27b647135ed97da2e2000872b24310b0ca4d450e876d4985486fe0380d92b07db82ea621310f490b7b22bca27b092e219e2756f1e21bc5933fae1db9d936ff460c3e68b8f71880440593b927dc6962870ef2dd332946abe021fa8abb2f9728286c09b98d38a34ec785202b2e61de032c7247ab4a124e6f2ca53bd046fa88ed3f1dca118ba3255627c2aa0aae95d50c19ce42499867114dfcdfa0de97da094e95df32095020be68ea3da0ac780844d18df45bb1cea6f69771b38334ac3d92ce0b26655fae83479e0cef5f1f8c414e745199dbb9fbd486fdaf8a5d14d91f11c03ea3bb3487578d5db78fa1658eb41ca1826ebf5f9cf3fdd8166378928592b738f925e170e8211acd2582ccfc354ad85685711e54eaf3aa68d677f11bd3275e0838225adcd9d1a89ac5ad5b0525ce339138146c9492aff819b99c2586af36deeac6b9df970c0b4b5235532b0949b5f5b2e55a677699d4c926e0317b7c81f6be074a6a8692840616142dd27e9da778d252877e9cd63cc4045c60b91387366af5e378724ed27987a49645f68c968e960335cec4ef496c45616a3be4816975fa095b085ab552a3153468dad557435bd4a0912c4f9dc868a019beb7b4f73f9ce2c75a50d0c656e8bb160fa91192ccfb87de401b0a7f5c5db20e37aef79e8b7c958fb481e41725e6a69751a32dc8c3053a663627ef4afaa2e0fb18d021ad5295040f0f8f537cf758b565c3a4422e08f86dfb76f6fc0d048d0df18f2db826d13a3a13d5e8d9cd5635a9292a170943771078a903f0dd9b3537de61ec20e6a4915b800077cdd986d56b81b2487da45b2cce6fd5844b72fa6bf1c96579d9a1cf8da159fb3ab9c6704845874a63bea8ba33d1982c74140d19eab6eab2154c7e68c6db0265bf1de33c62d1d26553a5ac63faef948c583dc84b91576688a67e6430cff25284fc05725507b81e57cded8db100ae415c9633e53661a48dc7f50f9171391ae5bd672efc622260f8eeae1ae5abfa04eb621251c7e4c119f47a0e16014b92e95280ab5af6e89dee2157d72da2f4516ba50f34fdcb3728f04721075460c0128fc33d63fb499a4b590d5fc218b96c383418e78059e9aabcb0b4999ac5bd65ac677d18dfc7ed0f2e69f18a23674376a32fae4441483e5b4ad1736ffca5d390dcb4377c272c54a7e7eb53d2c8c1ec1a6c1913d935895dcaa5010d26b15c5e7d40489edfa730e08fb027693657b1b5f725ad3aa885a7269c7db35d38e02532a71df84b9dee111420065b8257af61dfac3f7aa3394275a408e70f4c2c68f8bd7f820ec845c0a882b98e51cd3d21e49bdafebabbc7ee099cbd6958ff0f9caf99b3bd91785901b6c267c0999ec8b29f035bf834658281698bfb154265a2cdfdf6a81d2d1f49cacbb7cdb0dc34c3910fefd07aa05cd6222fec495795b6b980722722e131f333fe1e4a32edc41292381d41f8695a12575c9333f7e9e0ce0d47855d86a2a01abd3514740c4421e12bc55259dc6227fc397c77699e10d2d7f990d50885fc862def96fcfa380e6a594471b74bb7136c54f1c4a1ca8d73b04b736666dccb4d2feda49491ec1b11f81950ed766839c40842739e987fe58599870ac0885f34079c4d35b118bcf7f8d49851b9bb2da4f0cee3984ad161e7ae4d1a8d3d74b1376931eec746c8192665b1ba36e6e2e23239fdc09bbc1faa660a0b77f8634182a69273fc1b5ea28043c031895acc7eca5638a193ee2c2e77b67616e4b7ba960a8bd8ce6a1f6ba0423c44eb794b6cf6a12f0191c907db3a62ddd265f269695cc432758c52a0ed07c82098ba7fa9b0fa36253dd9adac437c30e5e91e9fbba9daa892b83f1557b6bf20c48d5e111a1d928af7c52d0dc109a4810a4e25a7b363cd4db997e34804bd8d187d2e9f1b7b39bd385b3997eb8781a151b2dad89aca6545c4481863cbead7f6efe2df4cb79a0daa65bb5d1be5f39b8d0c3b87fb537995fe24a443a56548af311b6308c340b996ea37f9e32b245abe7c2aac8a3feaed9f15506ce20e59694794424d8d62293e8095d2f539d449ea88d0dbd6e02e94371de3efcad0add98601e5dbd3ac4a8c0461de7e01879a80353de9f2c04fdbf339f28ca96a3ff960a81f7a0255f7635aa5e8ff0e1f702f47dc7fab29ec682f75cbcdb800e3d5bcc0c03205e30f8245779c63c36750b604f593d3aaa30a84994b41993c1f2273c6913e22b93dd87605ff697feda142e6d471d57897a0e1013f9dbdb282109964d3ac6e86b3daaa834117e67ba173c21c54c31a1588a9ffe6426b0fb5ea83881aa9f6ad510da0361ac660426ba697b8e0de509b0ea448a2f223b458b7789c0358ec087668f5c5899399b125731f02b31e8a9a1e4e23290ba69f60e6b26e98d4baf7f75cb6584273ced96667c9a4eff7890bf56250fb7e7224970e30325deaf4fb983c0000fb1eb0e50631e15f8356476855fa893f0aae6871a557244ef3c041836c07239ac20bc9579cf36735da34ec3f0f6042523165faa8da5be5dd0f23748d823e58a0c60b40dd139818e15a64346e457de8517b91b6fb0f1b51b67bde7904cb2ee4a01a30e09daf824b7abdb395ce094e1631f9db26ef996876e54631dba9e6b7ff2c28768b3666b9a2aad0ae940cbc93709471d7c93415964f727651094ec9a3e4d279ffc9c0dfd7caf9329fd3e3739e3fddca74283c68dbed1e12ee5e66f67b3c20cb3db8d4d7794148236c4815ec2a1edce79ec2608067e3ef24bba0f7d826a9c730e994f87857a37a515066df3f718d2f5fc71d8c4f148637e20c5dfee98cf43a07bb6dedf4f100947c2680b82d71ca1ddc96e076077ce16747aa9d0470465fe07044430ec2b720fc55787954ccf08c72c189b24457ed9366f12b2763ce0d9f6f8f2b21969082866284b494961ffa997f4add811f534a7dd413c43b4174906a4c0b47ae992ece64e460779a2906022f23aeb1f0f83a700372152e1f4e6b9110eef89a612f98a5bfd244ea6d631fe2c919ea6fd68106367b40096b2a220201b51392ade0b988ba6b9ebc3b7a2a1b1b48dbbaa03063f5f54f4659398fe971be727bf5ea4c66e0a86600483f6ac24908f3e382ee053de7a2717b21b2d0e18cc72146ed8b8cb3f4c16993e263faad06bda15fd8e53aff4c687933d7ddf26a75432a1e3fdb46da745bb0dbdf8c20f8baac578e38fa85a9b08ee9c1f6ec9823119174e41d5ad3ea31ab59adde4a2092d471a24a6f0af681b66b08641c48dc26739fa68bbd6481e419149228bc8edb73f5488b87a18b1516895dd5558bfcfa8e17cd43d3fe7d970b75e1eea7322ef374f1d4319d477bec6163cac556ecbf177399eff0a5bc079ab7fbf1b928b7e9ad8b7a5ff924217ba332b8a6b947372d26c80d5fba27d8a8b2239172298fb927dddec47685a67d605279ab4c4fe0a76714424cb86ab0579ac499c25a65b1e9beb0659403dd3017f1ff79505f844a574322e131ec5e19b081bd7851847f24379cdb3931cbb8356a7c0f27e21736d38a7c9c61b78b5678cc695f923d48e25fabd0c53f99c83baf0169b115682e12009f048639289827cc33e779ab87789f2cbb0c73592645385c2782d8df5e8275b44c4731b6d99c4047b9b167416f9d017148999d0d32d49844f03528920e7b4af40f6809d526be68c20f582acbedfa65d6493890259e0b617259695f19ee898fa0206cf632284c80e065e4dfc43cc6f4b77cc3b56ec55553e6162a5fa7d1ca18c53f71c1b0b4b9d5309ed56bf40308184cf35686070b175a01c10f1a60e9f499e4825c6571f461cce9e15304b5b639aa797e164c367b62024d6fe85f91c541b37c2ed6a887a0488b2dbe43cc588d070793ab3a847b15f2b274b8e955871bf720c644a823041a0084d8d54ff2bb9d6a3712892a39801730185483ce6f365d7c16b0a1bc5f514d0691a64d477c6cbff129cd94456a1c36263b69825acad9465fca06ed846d8038fa5572e41f769a9df17290271d750341cd87d5c17db06e986b676532ae0629f1fd63b139a6b350021035c445229a660a764f8b4176a23afb86871553162a6aaf3864677439a31cae5809323e66af159eb3a3f1ca75a73eb7ff63ae82247856597b40fdd7d3b1cfe9485c2d0d0a58bc32bb6dfbc4b61e699da20f37e23bb69552dcb282cfdbb75104731d6b889c2eedddc256cb70c1eb5bfd6ab2901a0dcdb2317be2386e56fcfb12d4f3bd0e55b43621434f92d8124c4a7249162e8eb9613d70cd30b3379803f7a3eebe9198d821c8ed61e06a2f3af5dc9efff2722d0fa5f1ba6b315bffc20d69ed61e9b613fae5c8d73126703703eeba77ab831da51b1d29c8a040d48f2125ef3d84b548a683aa8e63427f9c2755d44e2a2e05304226e723cea840135145567416c39d5b13cb855c5546127c83b06ae2200ddf2156b555f858fef10aed8c5024fd23c55d48075fa9ada0815f303135a5fed942d87fdba439edc3440419fd263919153354fbaad0df0ba7e50f45d1033f39d5a39452286b2427b311253e39c132635cac5b06da7d432294fba7b615911ce9ceb54596c3d2c0d570b6dd933bc0be325efb72f778bc8f19e14b481f35d881965ce377450150e7d830703aced0bc3c468d5d4e709d032c1220f3e93b52c672db1dc5cc76b028eb27c5542cb122f02230ed643fdecda15334ecbf61b7da207915622cf2c7ea314de33c3477d3b3e2873e63e3963031c2e84480c87b35880e17bdcf0613faaea8d31f17931274c2ec8bde49f8c1b50d2706be219e5cdac1e1615e2a92ab3ac631f981d15049733ab468a2cf1d80f6d1a154c78494a4f291ab9918ee1c16334fe6633d9cc407d12f9b13be5e976c386079af11d8838f43d19d909b0ab0e0a71326b92c406594ebd3f9d9c1b10a7e94ccb802ebb04ef2bef7d0ac80e0be6a839b7ae990858879a661a7bf686ad351534a6257b8be2c72d9325c2cc5d6b812d4597e30d2d0a3cce3f1ba088b0991597016b8cbc17b638fb3522002f4e36bf17acf09142c9e6c7fc2c228e5819213782ca7aa27cbae490e0aa09737ba5ab5e588ab9de0f519620378766af2cae121ea47a2ef08f8658040d9672a0ab5c7b0c2a29ef43a18e31acfefa31897cca9a2a9cf778d0e7af5b9d8ca15451c6142e9e286b58e6a0193b0e4ce9ea3e4303da229399ffb58f66a0637317c6a24e30d46a9c130f386fd93fcfe48499a5427756d4628ecada5a3fb15ff6851722f00ecf2ba62368bdf98a59c8a4018b3197cc7a30d1df4b3682550e2e2ae9567ebff0a01665019761a5893de1cf71c628db6c670ce2cd05ee23302879ca4a9d74e45ea4e12825ab833fc1d896032ebcaf2302a311276145cbaf099f374d5eb7c7b80af792b106688077b20476ef6623aa75250c937394e23a7e30b615c21ec7664102aca409148d1854acf88cd59590596d0a8f2b28fbb675c667abc0f60633fe919caadbfeb91c4a14ea0c51645c7627c6c960c95cadc02e77f992077f0a265fab57f8b92ab4c87847b626cf6c9b9decb2ca44777fd80ce0de0a85efbeb4f323ebfce5e49a131b4e218c2876a110689c8b9c70e5a54c18780c2fcad0c0b6a71baa5f40ff1977a02a7e467a14b2d64a457f8d6b8afcb8591afbc2dadb62287eaf97475fca086f7d5861d69603a62c8f58010e2d318bd791328aba783732e7d7946b3cc7934a326e1b5d25451b663ff634f3c4e38318cb341b6155e4e2189f6775cf1a4f50924efe64c735c1a18c594e7240e38f1340de31026ef5cc8e823d55fe5cb9e0f20bdbaa213994d4656ad9bf7f7201ab3cc34b8dc6e49ab63b5b70fe5a94c0ad9f76db6e02270bfd38f1f36c99dcbd3f4ebcdb64a7ef36a0b3f4254960a9001fb839ccf19459983deaa282e61eb53e2aee3449f1c5c374dd768845d0319bf3798ef82c78ed539d5606423eaacb4d711f694dd67a026cb94fa7f0240ce57f550f0e5e0dc3036efc6fc8cd424d60e8a4cc2c83817a9896779da51360be8bf57957fa9071fc32782561af9a53554fe2cdfecb151121b6134d25a0be5ba47faedb16e7ef8a665d3ba83bdc7dab15998445a5209eb1d99039bc9d23ff517a9b203bb69ec2110c65b338814442e864432f5b0dd1534d783551f844f17928b03a02e1ec796c3776f0f3f890dd3b9e52e62de61c5a5e7de10e30f08a8c181ff55c4b8043eb976c486e98741fe1568cebbcd2d7c0e74dd2ff9f66c53d17b6300ba7488120b9f1606d606de3d5e8035701f4c15063eee8ef7e78f1c599c42adbf398ee9cab6b44baabdc6fd7b14f7f5adc7452fa41e5d7a8a5fb039a5a6cb11b19c25d05c248c17b324e0d0c5bc95fbe877d0f4d467c7e1f2741bf9ef33a525670d64ac717051ba57ec7d7ab7fc03940b037f397795bcc4705e6e577efabd949ac0bb5efabd5420f97e2b0c76998b39489fd44272e1280bf4ab92ce9b830207a564f9c92177e6782d1a4d983a4b18990a45f35b8bdb9f4e7085224100218729047b960cbe3bf7d35560d41ddcb010a6af4fe239936b54fe759274a430160d81bc0cb75720860a532f26d32ddf5db7b2f1689daa8254ecce822178e2d3e8f547ca0ee4e44d61035064c6845e3b64386ebf7cd18ba12b51d633e68dc6d00bea6ea8f77316906a6199208fdf203e884be7065803d461cf09acc02bbd1fdb6d621bfae73b6ae0b50774802e5af24501fcded7db993216c94cf4e4a44265bbcfd1fd84ef1b8bb27157ea5e8d4484998bb6f928749eea5fc8842a979c008e0d174342b91bb81217b70144590d37c20f633e9ecc642dab63b7cd69eeade0624435b48848c0e19d880425291e6b483c94ebe9132fd7fed2f9251f7336a1162d4f11406eea092aff1b322041e5ffeafd59655d404676eac8c59cc7847252ffd923b4ec93c8601f83378756e32c05a250fa95a064672f17c3f3292ed8ac8f72d8c228f07a36cf8e74555d9214a311f612e4c4e1f80e5157bd8478bc89ed7b497e12a21b3b9704ca3959187bcfcfc1fb87909261e7a736f161036ca3cdc343cba110f8ebe082af5527d59069b468123948ddef1c57b12edfab853d104361868a685cf22cc8f4b5cfdc56a908c9dd32059cd662d752c46ffb82758cd370e74e79e61a2fa53e05e40743066114fa25ddf9352b9c83706b7414c8f41520ce055d6d1da5e85c204785769f6082bdece5d46b2e351d96e7d36fd55ffe635f39e95f9388ce7b874a1bafe2d0bbb0872d630dc3c9cb8ba50d0265d92b6432d81f09e1b368e59c386043b0b5df20963dd45aa76f8d408323baaa2aa90af46aa462e59e0d7d31280be5cafa653fdf2fb6cf4b955cb3a35efeef49154bfd2fb29002030b021d44fae522086c94fe7bfb9eb14d5f5b5a9fad57fb1799a501006d77b23f2b815f0c34e895a6a193c5cc2002f8f79089cb0cf7a16adc3ef5c93a1335f7265822dfff00c866866404ec89e004e543722bc1bf67e1a1f0077066f5ceac5ef9b08f2b4d1544084294eee0238e24d2b1093e2776a8a526b0d255e632cf3913c9f03f109ea8b5ccca0660dd6363194bc3a520d6ad596290fab651eac7d3ea26006c3d1b023a56e18515ae590c2ebd2cc87f0ee37e9d6e5f3f1fe45ac3dc51dd52ad8c69c1a6b52235e4c97a084c434da4f0b6ae413ac1cdee566595f81a9c4580a3e0799ca74b00bac946e66c591970ab74886815de3657b5e3aa14e985c2d2789ae0ae51e6158705a89b2a55f048c2c771a57d4240746a06ff0b023e32ecbf9016fb1f6d5fc3f8e3dbda07ebea5ea1588488b403ab3e8ed3a4a2f55ce4a7a8906ae985dc11947dc0899f7b83982d1e01112e4e05ce2ff2bee2811a743d2b8a1d85623a5eff990de885859f65281b367970970f567669877f8f7a0b8d7ce6703a6981217b259493365d8ba8c9d84b551ddb797348646e0edc92d5ccd44c8790ed68cfb85adda2cdde0abe779b8cd006a33b9933e6d76be6e8d82d354fb91405af3c9edf02d22ae414ebd0cc7505277927cdad6abb997847ab4d65d59f8e348c9e87ae1d7b7d9117c4d36c058db973ce430f091e7ccecba3a175faad00ee649563717f9a373e88508e3d9393e3985c13ab172d187d0c56b7392f51350f66b15e5c98fa3455bd687322eb8b4c166c05239f8838c54b831912be4872db275d95a9bcd8e9fe016a0aaf2b95f3071ac56b75000fdadfd0e323fe8580ef03de21c732247f0cfce7a70aede93cffd24b12b73b5ab4bc44f19806feb4dd476de0d77f37b3eeac4e0babaae61df33dc2ba099219be7f23f8c8d92a77cda4e83593f2173e5346fba043db2836c921f230dff1f121e625d10d68b31592e909051f01adea241c01f44a9840ee2915716f2d699c30e0590497309ba712d6dce4b83c1fd2ff2ee5cf6b862125a69cac8225df50970e48a30b34cef6a555f5a3cbcb775cccad755b587f15455b3c4306ee3f801eff35e29d02683a537929f60ffef3e510618e829c9ef7cf313e4edabbeb7e14083e178755002a9d3ac1478113fc129d48cdbf5c9fca7b2dbf4aa7a5b55942fa2a30d92444dc693493c829cd210ebb49fb5adf150cc343896daa4f5dba9ccfd24c149a31669db63fca8438402517ee9705bcae3f0c49c57dd848a9c2106bef0614d554151ab469ec86998be85dc31e1dfa6bad83ecd5d5688c76b0438b8f1689ce7f097b21d557cdab6a6acdbb4b87b35d3c362ba06ad6d65c159224c71c6fc1ea68808286d76090ffd7cecbcf299b307688776bb312b20ad1bf233c46b3cffec64d1cd1ae38b9452b18f908412be1f255d5ba62193620da26bd27cbb21ea130626d574588ff9961e4d569dbd7cfc93e065816753ab9ba0266887286a7996537095cf42447db2a38b7b9335eb8c72028614b1113a3b06f56e788748f9c74aac4e76fa7dc8cb5efe68361416b2d073c92f7246dfbc0ffdf0d49dbf2ef7b99d2f563cbb15ec68ef677fbe74c5018d8d43b4989729ea3667e3d9f719f6af981e009f98ea360bdd2d5e74a0e852686f3e65d5c094403d2bcef18a1f63b627ad3b3161bb44e96a4104e21131dd1bc7e2437ff8cbf2e37723c43a08617567cfc58cf02e060228066491f20ffc986670717a8cb82bf90fe895fd4da2a93020ab2f3fadb59c6229a56a8ef49749d20d44866346e8698f92518bb99f7ecb647cc7214b060b94581ff73a040c98bc439ae00e251c95614075370cb16b292eb6a3c9d9e8bf275ba77949861be8a4c210c56b67f9391cf1f1a6db4e603afd4ad923a9d14d307c74fb8e2b0b1ccc3a574b2cfce599f23715691ccc39d9b07bffcbbbfd738dd3e145a771fa1a76ce370a54a57349e32fddbbec87639f3a0e58ee34766743eef131b260033429a307ad4a9d27224e3db2a3c554fdc28a89fcae55377790de410862446006a0bd7e9a96feead61652f89412372a60d5262297008a9757334cd6249fa3b98dfa010cfb0ad8feccf896d34ab6ae2335476a3c2ecee1555e502dab4701084b7aca7aacaf8889bde0b487e75239649289507a8028106ca6bea80485a9afaf57ce2b419ca41397d28094ab65b915fb8af87151ea3027287966d3c7044941134ddd219f0170d7d60b5584a9903f8bd809142be537ff28c00f6789f7bf3c2256b30b9c410b000640b9890ba46c54c9b4e47f9a1ec1e0d63f13f107d49fe92a14d0a3465dc11a9fa972c5649f493ab7cde6626e43eacd18b8c9aa560ab4a860b36f4378650b6b1b724cbb7cde632ecfef2a37e3b09c3f7e3d86b51e61894ba70e1d4ae1b807cb145396648b5244afcae43b7f170f2504438ca2ee51fee9fe40d65e378df20233b9ca9a3b8f606b962e49326c1aefe3e4d9c36083883131023160d6bfaa466e08ef8e4f7e707d3b5c95eba139c3bf558e95a038a2d91731d3333f36ad5e9ae2fafc99c8cb1f4da5561fa27087df03c5034078bcc52fedb616ddd04bc9ff0d5832580be3997d62062db6522f9501240ebfe9bf08053764f0ace2c0811a3fb285e075c3bacfc49bd5f2e7828db74e5515a60f8d67ec4c751c4b43f4c13e14b4569fde391e7759548308eb76ed4f095d27ac60c8542357708442f8bac34594da4f6ab342d17ae0561b0ba4067b442bf25e079eed9fd5c6e1401ba979be83968605134568de8dca97a90e2ab4034589be7c665a152ead47dd0545599f1606ff04aa86c472f903851c080fefca1cd7fd14e676f2200988469da1c32e515036b8abbf4f394ed150b989dded5dafc06d75ec7e4d00fed682e3e4f5d2f90715a3e687687c3ba6d800f2070ed12715ba400a00ef77914066b1062437efac58ef82ddf880dd091fecde00c4b850704579e31b6fa8c4d6f08ef0f402e71b0f24450263183f6c9da79337977b590829827de4a2365f7cf226b2a701b0162a52f15e7e4e8c3b03e38b0a70fa5febd13474eefe2ff5f443446ef648ce8e8c129417c12a576250894007de210c2d8eae8644b196567904e65605156d8cb65f024454b02c6e2c0306d00f2eb9ea8f853f322a8c4a88f506d3d49168e93fae802815f0d6c423db434d0c9137ab1e7c5ec14908b58ed3510b559f1046009721b0a76","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
