<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"05840af1d5415db6f3fe3a306f006b89cfdcb655d26311a86de2e632c1f9382370a453a341dfad5391d72ed3bc2a0f41e86a109f1889a1b4609c3b49db2a3238d67ed0e137eb1cde10c581986144966139b9be68bd1824bb247fe25d59b4eb222824fdca118e12a6c53d780d94aa0ee665ec62b239fef992e20a997b5fe3a6ed7df1d4045dad9a92add6aa0b492041c8865baaa556e62acb2bd351db6493ae5dda3dc82525f893368a81adb701f4345e8b61959a9e3b719d7a3e2d5b280039c8bf35770c49bab231a20492300e5c681119547b39c0d7ebec57555194321b40fc7819300472a3417c1b3b45f10507a722299f199d22e7ef5549c267e2be34d790e0bd3e1b9a4666a449ed39b1288b48b84aa8aab160e4be8b246b76a0f8f6526fcf928a36b9ce08b636040fadf74a3343699b54da2472003f8dcf4977d2e0d97f3314e6243392817d4ce598853456359aab3c8b0030c364e97e9778d7ba738795d2b4ffec15a12053d61aceb2e690d4beeec8aa5a5e87d06a7dfc9c3d51e5a69b955fd004d02f44c68c1c880312a40569f7fa92105c4153b2cfdf46eb55b2082af0d234920cd7739ac22a4ab8b8b125ddc9dee56b7a20ece4602b8438b6b520c5e1c0051b36878a43d842c59f55f0622f67a2db9cfdf285547b98718b39b2d14906d0850945fea28fe9a4fceb982b7e25c4f01421774ceb087c772b121d46d7f35dd6b42712bee410555927910899f4a4427e8ba156899fbaf0a13fd9e97d25c4cde514d788ab8a7d8237fc12dedf893f8df20177bf219ee1255c6c6a9fd2fe0ca98fb8e01b0cbe44dbea4e60c178dab4ef2181690a6bd493312df02247077b3f1d536ec1c8c428f68fbcbc19ecb66c40ba97d4f35ba1ba82225aa73be44c537a2b7b54f8761bb9633bd09bbfb676cc799eaf3aefaf814e7fc08f590bbbae7a9de4f5921d63d47f8c2b2d68a832d971df40526c7355fc107f334a5762b0811f12081e4b9227e24117ec93784b0ddce4e4a7b36b81616bfa0e9fe14887c7ff51534b4665d31a974376a3e4a9be0223f0bfa925e915ec5f125be52ed4c4ecb3526c8dd4afdce6f019162e692de7241f40c78e2b843934d87b202442f36a3914cfd1de665c3df901d041f4ed8aa62899df4f1a020edb9072837c4f61f50b2a1e8641f7c21eb02a7eb2ba5f01f3ddc87a2a133b378a70dc56d0b7c5aa219b24020d7352c1865bfd40f5d2744537ac8fdf6c0fddb22cfdd9579a7218203a0579deaf5f5dfbe23e2aafd6cd0be8ccb89d999c6e961d3eb7403bef27644b91c1babb7167b9a641658ce56c547d6a326af9b80ce0bc1d8c16d07ae9600f51d256962805929fe31340ffa48c59ffc88b666116e9f76baa4d9ab54d994e2f2262b3db18a4b01754f0b20ebad9ca2e8658203ef274ae9042445faea2efc3079c20db42a3041c8f81636438314c5c80fac02ff06a1132078f82369699dd434d6840787ac465b40ba39a3b090d1fbbc34581b63f4d1b54f5cfb9a132f674e64873c1ed7ccd25a29ef7e29a1b83a20b704bd26062d57838ffffedd4bf05a20aebaf715ef273cc96679eced9552f1d2209d1cd8832da71741c4374ca3abf96888e791181c88620623858b438144185129df38735b5ef76aa551eec6ee76f8a5367c5fc2176332ad2fd41fe744c83f5a955baa068d0ea5d5ca845c8f2a31dea2cb5c6bbbeb9bbb6aa53dbc67b70210f0b7c25e3861e775e65c6d53e5fbb7f21044c39ae0c98431cda8cc17fa718c5dfb92c4f8e668ebe2266300c86d1564a352a49b6fab3993c25f81657886b15e0242beac3a6a40b47b112f4d4d0bed2c9076edaabe1973c8fe558d90783581729d8f68f1eb4e22ed25213013e6891233cb8eaea081805422318cc8733ec57b7514625b451a3d5499faffc07e3685c5e74943dc7206f79d6c7718f88f7d0204848fe65ecfef6a164e90941e72ddfb1f6912ce232fd687c0be7e3db610700dcaffaa0bb2dce7533fa9215fa0a6fe0ae48184f6281dee1fb5b9dc1e528fc3919369cde6b04134f9d0d7cc92e4008ddcb26295f489090187796f421d6b7f2f688afcaa934dc8568ff3ee2aa15e804614152c0ab41e3a424300aa9bfa6b3c9dbe69c315636f3a17ace7f1d33464168be692740b02f41ac43101f194af3a61cd2ea6ba19314354128cd2d6360d7b79905dbcdef81a376f23f9022e0e35c98ac1c6bc5bed57ad0dfcda661b419c64f6479e2d418026a7ace6167b590a9174109c384512d4c59d126f80433aff390e92c8db304a641bd6c64c52bef2f9aafdedb76d9789812a4fb41ff14528432d1c2d74669067134120492203abb328f428ae43532fc4dfa6f53e4da53a785f39d9d73c344a08ec257966d982f7621f174174653bde14f4360e20ae91eb4bf9219227fb9830763e24f8e4addbf6ce8a83356d7430c5730e9bdc57bc07e96a6f3d21b9538cc65f62d850bc670bc040e26bc399934c0ba4e5a3b0dcf72ffeed40d35ae3f221ed6ccd97852f002349412089244cb61ed3b3000e9690eda4433f2b0b5b0446f9ed9e3b8961ad95f8b0b10328ac70de8ee28c33411e52db179c13ba4a1d1dc5796480747e3d868699cebfdd84c5a689b11f2ce750bd73f26bc715ee42584cabadce8ae77f63a27c53995c807871783e49629294d52b20db89f7e18df46cad95cb6e342c96b858f254a140703565033fc93c98319dd910e9313313063c1470c0b176e192ee3225d541369cf4a2ce34b18382851494eb112931308a9a00f9298e220d8794ae28eb14ece149e31038bf5049b7409b3590157f4841bd657211d5a9ed899f449b1ba28dcae2813887bbf71d120178333e19c47f6399f90e7a5140290d699cd541184228eaa556fd5056debe84ff4d318b7d1469fa1608f6d447ea2c421f4e5d61f653349aa74e79d4bd8ca80aa28d9895ca3ddd6a7d44a40065b0154bc69f4f459ae68a9db21d2409bae0ef6faf6fcd1b8a3f8711e90f82c8baf7d1640a1a35fc8f0b4f7f1a872a0b51af23ce5d6b5cc39774375338166403dd1dc8862664e5ddd8ca64c58e0e96cf57ed06c3f3a23d15062c4c2bd55ed94d392a821b4b7b916591aace2e191d7692a20107f570379a87e98d9902bde8981b9be3838261e73ff90c05ecf94e199eb8eef98c9dd368db3093f6cd42f36d95aad09baf82645b751a27b09e9f6361a8cb3e8fc998929a8ad4882a5e17042022c6ac4406250837e4bb44a9487fa9519031347b78127e066e7db1956191fa42a88a12c59ea2858678b727b04e4870bdeb1cf7daf271fde95bb85504dd994dbc93903e23961416350b6cc780fb56c1978137edee873150b17e50007eadda0678f4a4d9176dc5461e48b65025cc1442fa2c14ee1d10a12df9650114014ef09403fa0d27f2d6dd648c91d32556501ccee5bbe0bbfa5323208e8d5c2b454757127f24f0e0bd274814ceb4734a04aa78fd706a9932f9577b76e6e6ff68894d37953534a81380a1fee7c5e546303893a8f32e31d9021370cfba732dcb3b3d04e4f551cde24e080f43c7db34d294528fd1b2f4bdba7efa401df1a8c78377a7934ae8c0077aa4305ff52d1c3586efb70ef2757c0d80792c26630f59ca300752a0cd03e57c1a20950784d11cb75b6700f537140125370639d78bcf48567e9bcdf63cc347d9d0e5300d99630deb7cadd53f1a398f9a196dcddaa9193ce8eea862b7550a8b07db6bdaa2755a4ea7979b0ae7852d2e7045b9ed17fc38999216c664cfca92fa88f0075f5f38a2e2c601d22436be1ff373789f91a05197ccd9291f75d623d5ce0902a232b4d1b1dc21200e37f51d5a7a86633b195c62e28cf7f1c13b40aa74819281f56bb01e53fe701054a96aa8c4455f98289619812bba1af927cccb14bc2e3874961f791a7c48bd39310f33a0fa4e1426a3859688c8cb7ad96a21c1b4d67413371ca80d7ac88ffa3609e6e4fa9f0606ef7d792b992d310aee061d25bde609c9f8170bbcf9e9ae30774d25d16ec2baa15dc0f9e023bf7ff614bb2d51a56a9c1a4b981407a096dea550f4a197440c739111517f05796fbbacd2daf8a315198955a5177c8b5ee1c09abfb3a3ca49c32dd5abacc850e42a60776dd863aa3c387758687f8ca8a5daa8393c157035bef3250f2c0f13e20485e6987f218f3c9cea345e253c099a6db8e7881baef8697dedacb66bdb7202352aa3ba357fa0724dbebff7110bb7f691cf8949da007b8d58618e58135456bc4e8f5eff9b865bad9ee32cbef0caa196a41b257a90d62b4d7d970cf33c7a1a9857e28d724ad89944e052f38f53565c860b1c298bb22df136ae382d15bdce5280438056e82ce593d3e1698382d114b9fb254eea423cabf9eb4509e9bf9a4281b442441c84fbcfbb8b125b42361ce2eb8a8f3901eb5323856c1630611faf87fe33581108dd0ae7140ee72e2cef20b62a45ca8cecb36f628568c9d3e223f9daea0a130aa0ae98c23c9c5e1a312303825baa1057709b658886540624144856af7d97bc8c6fcc95ac55ecc14b573b0e1d85716e4eb45b9621132f2cec0c8587e3a8532d75f6ca1e7004958243169cffb99c62ec24d6fdb7bf2b12be76bb8ac4c8e3bf042c330dd83136a2527525c2be46e3605cb67772d52c9977261d081eb8f3b116b367c79990846570da7aa9e9c032a12d1b8b8852c6690aaf5e5461d998208c1430449b157cc4c63cf7883896f0932a13113baf66126017113c777aab12146161694b79127b1cc03ce2c10a9049fa01880f9e8dfa8c9b2b6c4fe72261778c6d9b2f2a91d0de32287e2898362b627bb7c9a8719b3bf5e897a666e2513a5219cc1b0c5c4e07f475976068669f1f541f8982a64c9156208a82b914e08e6796b1f3ed591b5d37076480d83d885430959155df6e222b4202a9320df1c087088672cccc98e702765306e6d04b2305570541d8bcd23f4da7faacafee86b2588d0974426cfc63f44c1d9343590658141f8d9341e7d131ec315bc2043d8ccf044529bbf4e784a0f406b284acfb9a0ef15f5023bb16e354bed94d06063377df4b5200e8189563317fd5f2a9c631d402388969363cc4d1c5f34f65148e1881da4ccf6c07780e3872e7b2a722c6112f23de0c401f7d9358cda3b307bb282322003afdcb1666dd3f74f60d749e93d459bc410c338d6b71f07029576217a561d8726c50022c5fee92da3f92277637c4362231e68f03bc48ff3219d1f2f978ab012fe4c89d406f6adbc834aca229f62f2c9ebbca9f0d3782655f16f6907d4770103276108f4d86482d29622266e07fce0eed419347761b0fd35508b52e75de20858200face761a0031a172ff7d07934771b0aaaed6c119d08428cbc5769cba870289b6c71a28b297b504629ab872446e5b8c42a315d1838ff4e98cc0d7d7a5b66094cf817a7d61a63c780689e887c481e34025328ddd7a42daf9d83bbc543e7c3132532eea99c332f4b7ca4489212387f7820712a99c0b07f779319fb22193c673571193d3cccc5b537342ac8ab60892b3f2e98d03559846f684ab8227e82c16bdec7a768ba85f90cbbd3c637c587003c93beb6c9f645a612090cb89d3d23e3fdc76554f4e301bbb30b36e0f2484bf8a017ccbf9a73cb3cd13a81e0317ca8b8cfa36b55078355890d6116931348aae6fc0debe735573483646c5e12b8b8dc177f3f7667d68520953acef92bc575fd9632ee2c26efed9407e226f02ef733b32598cb760ca1ba03a41c0bcfc97e8bc3553e4fb5e9424baa6492d8c2b799213e04ceebb0ffc40ec7e712712a714ad6980725a119219a07a281f7147eaf82f3da99998227ede6d3f452b60aab39b9e682010086ec1c2e72e3e9b5cdd4d4c3821698f5e5209294269280d1baca1323777e5fb61763ce45fe4d159ee86abbf2883c8435787fc72764ab93e5ae3df4005010a7773edf3e0768cb11063463ab3838c43e36fb3667d8e2ac40d2002b6d053d837d50a0f1100703030f966a2eb0a03e0c6b1093f852c01e9796af34dfe917fcc7dfa7b8a88aca3076a5258b03419f11287bf70553037553b48288c12079648f46d1b25befd4b151407d08517fae0a8072a4708027cc5845e48da6a34ca2f3bc5fc29d8bfeffd56581b3e7a9e87aa9a8b6f9e9b8896d6f94d3226cfe07e0bcfc7c202e122368186519a718458c3c8c94780acc95ab2fb616199d2a0349d92fd439769c36ca335df61c7a297960bea2cf96c3ebedf7f03bd54b7af1107bad516a6032dff5fa656661ca12f8e7fef670d587cbc802e0b6e4761940e3b34232f60ecaf54554d23f8692267b97eec0f3bff9eeee73ff34de35d6d5ad6c843e69c9a5ba821c1d13fe6d06a36c242e297a9f629ffc4c1c4b8ab2cac4cb35113ae507341641ba933b2e008d1c76605b96f8a5d8502b530e3aa9ff1372896ca9551eb88c30f43a7b14f5bb8efb8031cf46a0c91dfe68a6b814fa9491e41c0aaa642e4b06d5ada633922d6cf15f4b8e1e09a4a40e300fcb363a57018427abf49f57fea5ca37c1e76d3870e3c8d37c4a42e2d2ff08575cd5be243e0e5ba5218107d2a6b17a5235c48dd6da0dbc180e6fc86522a510a852505506928b936270eaa00f91202ac9bba6a69d38d4255197cec70fca17c1e0b771c516b61d4f3a17b8e7c36d1eeb480142aaa9da2fce130864477e673317b10a5370278143d582a5ecc0e8fb186dc2d91a3afda2ead46eed6ffe19f7746392877ae993a1cbea5fd5b2c9b3e6cad408c7a816b56efc8603a0aa38bccc46bb8d9ef7de108663e624af8343b12d65822f4794030105a8b8b2dc5f56e53502b23e39f46d262956de0aeeac8bf2206cd4990a8ec2061f3979c2218806dd0ed996e7f3792208ffffea9c02e672f14fb6b934d5835d6025f0a6fbce577d0429740c97b609b116bbf4e819ee6d2f1166f24b7a4094733933baabfcaa0cd27dd7a25e6a8e378af4f32ad317aa3779e0a11e902393808e5aaabcfdfa4acfa681eed0fd7e169be7c9ba704d83855b19aeb21bdb439b18b63bbe8e4f8d3ffd5153e9017c093efc663f378cb636ad79f48fc64b874598b40f106165815a8efb770b3d7a444ba543436e3bcb3d1c01b65d23df37583abf8c65f998a9f90ad95ca03d99dee179ddda4caf6ced08dc29eac0f2db509bad28329855791b096f734924a6eb6d4ccda42184b6cfd4901a1b767d37d9a7856b634600d9119ea8cab582fc26698ab1e4a7ec8e5693a2e0634ce480f8a0996f01d00ae7c3a34f79eab6db1d0e378ecdfb176cc6a3f39b6edea52fadff4a10af34127da051d4746ee266c30b3533e7f1495b7cacbc430f1162cad64294ee29b6c0b021588171ece8646e185154b0caf75d55847d7d08acb71f3819d30a134a785281db7fb4f3c31899f521e2a32639d33626bfb99f18d09283fc404a54399fab4ea5c36b4f96a299856486b1eb260472fdced159f442d74b33ff3739716f1c788df3f0ebe45212681cc667d516a81f7e895bc5517b61092932be66aa1f17fdcce9f4a1e957a714113874499e43396950740a3b67b58aabcf5374bf67cda7a51614626c7aae753382e55be84791809f6a9bbe3eecb6296e1e35889387888f5ef7f909d533fa7bd931e289b9e65ebc699dec195dc17fda667dc82a9f9eccecf2a5ec1e5c2eeec571027639b9325d806a487b81acba371d05766b55ca68d7e3263b2d36d86e0708aa7738cee315f0b345edac8f0e15c1f19066ef07c5a4564eba9bc107f5e4cbe0cbf8c940a75e4b04c6044f10d7eb1ad45d7cf2e5a0f33b3101c9fc2474182b76bd3e46a0541aca3e3c4ed7a1148e44df42ec33fcce2b1bbc6b279dd2973dae638ce19275bdeff14f9d7fda401a2bd710abdff69f75a722e3ba00d625c62df7b849b5c0a674ac242c3f54a32753aa3eb50f4490a55b6bf7bb168d3191dd2fcf447f65c7475d88faa3f358ca76f3b691ef3c65121131625d8478d4c29c3b85651250e193f0b844b05b1326d720694adb241bf2d3af6de75e3350fcebc8c53f6ffa235131c00ef8fd5c9c84b64ecde4790c2047ee9afaaf73ac62a36f1a0f563a722148f9a4014e4bb04d27258de764f0be9b9f3acbd3e68c15d75d4c6abb0e89bc3874d9203d733c10a3a7a6b761b61916e1515f731a966740aa7c5d60382975eaf25360e419714d4b8cd14f4770011dad501f533cf1717c855a23cf0e6fa6a647d548094747aa6172f5260b828035543a39c1ae7a92c00787aaf5007a8be1a7bbe870292b713471cb728d0a9b4d8c0d18919f94e5cab82ac83ee7dc675a14693ce0ecb019ffcae03fa36be544f4975acc71047d54ff2e95377debbd6aae187a7905bc61c3ebad9d54790c159995023a5990a1a85c78707f00bc780d7c6471618aec12251c37cc8ce7443e32ee74dca4a82fc201e690e1f15ce040be8b67b5fc8fb4cc9dd9223cb66a36ed99837f8870def60c131c8818a550b78503f789531c174c5f3baae893bf51fc234366b84b735a6aed2b41fcd1509d4f64b6a095206a830c4e0c75642f166d283c764f88bdb656c3dc0b8ec01e45dfe770e81e8d45fe7ae73bcedd3c8544dbbb58c0b3a2d5026ab587baa7b2b9b67f7da67fdf0b1d3fc082b29f54a821d6e615bafe57971623df6937a05cb23dee8a608ca7a4f28eec974097dabfe963966468afc2dbeb5b24efd83ccec2a1ed19c1bbf4d659beb7462a35e31df4cce389ec0d9bca30f238997bcc344dd2cc9437d7186ad2ee3a60b3ba32970e734b05f3d9a49267fd509a362cf4863d88bad8b7dfe05e225ddbd3221557c049e5cbc92e65f468b7b82dfd01edbeda07d679f7feaf91c91e4c993a0a1996613099ddbaf14b0598cb56f76dcee9569bc7153d94fd0598753322774b4f3baaac25105c0dfeafe51d670d0b1b3aa7e46d7f8c150016a11f8217c651e928ed7faf604a4d3d98c00e00214d5ad24d156c81c01aced5e87246bc62f18642582fc50a8ef156f2a4f1f2d880921c699afd18bd73c7920d4a6e2eedc0fac85bad31912924b906970ca4a6e00ba2773bfb1f82ef2cac6054e91561bc1752191485209266bf298bd48f2d2446e330d1ee64c8cf67958025dc560230943f1b6ea2573ad754887e99165ff1744f72f2877f323bf1d2ed98bbde6b287a450e924ba51566c7f13605719cbed6d2e47deeabd21e8c50cee37f29bb7f171fc0c68f41102c3ac84cf0eab51e301e809d0a490840b4cb91d528844868b2d02bf410beb9c1b2e4a37e208baba7725722a09ac395576c2ad6a28ce3d7a1aeaf4cda5797e4f183454f0b0a4a8c578b9cee59c747630ce5d39c9ace6b73e759e5ed3e909c5fbf02d4ef112259e723ecd0b0c11ef0cf9804c7c102348720d4c0fb9b6414a6095134c719129a8746d86d2eb3d786fffb4c8ee2a3796a0995ba5d1375658dc9aa95bac5a608944f0748d6985740f0e931d6f21081a9ffcf6b436a5c79c33e9714ab7daeb6d739eaa612807212f1a88b8d62a2e2cba1bb88432f7c725e4890ed81719d00539ab0617878fe9fc1378dbbaf40ebe472836fdf7dd69b344f4c63e73a66fcce7b177f85661c08ef1eb45a0ee3961443a50af1415c23e91f90c020c13beba5604bcc3c959bdd6b288ebfff484b09a7616116a220cd83e30da39071bc3ffef9222240e9d2ac71bfe1fe6b45a153a1cc979636e7d81705a93c549e3a0324da41ac6cb1696432adf64deffda8f912062a9e79778a267be624307d3f38b109b6f63a9782f82b8bcb5d19dd5b3dcc92ce4638a5d064f4010eff199f729f658920b84d7c7afed2d0151f08cfce3935df180879b524732ca8d7acda3a7bb7b8694a181598521d62f59f8709fc07de3001d61f5a1ea7312de5a17cf4a38b7f2924a003b28bc29eb8402e1d320bc691183640db334b5b850a9cda7e4b7a9433825d7202b269c17b302ee2c4cee5ffc34f7d74dd44b267768c285db76f5a7ada6e3d0a1a71476c8763e60effc69d350861591e705ccf4f85a092ad6590ff043849ef50f8091c1ce2e4a79be627b63706289f7b2e4bc0bf277c2d011ee2f09de00032e53198efe503bbb4c93bd79063c4819968b32a9d3dcb83059bfe61b961c81492645c0bae05caf4fdc0abaebf8bd928e3386c338e3cbab871b9c771e9f34539b83c60b97fb1587c8aaf60ab78a3b951314217d1e15cf194158ade2a0663fe4611a0531923f5ed9e4e004e21da61f998ffac2d0e8e7bd25311a5513c2d9f4faf2ab58f0d548923735f048fe529de8a6822bb1a1817d9577978fa6947833264c6617e1b23ce6970c882faf0c95186a5d87d6db503352c7a01b3f0c91e2af958e6dc78973e6d70ac2fe8d7d480e64f875d4e69386c820cf9f18265b87d0c8c687750b174e34e5864452afdfd06e9f83c277fe1acda17402281a48abbebc0afee40c7bd3185a8cc54ca98ec7dc26abba0f9076fe568707ea825ebc0fe884ac7bdee283e21a5a6d2979f2e459e0a42c8c8a35fb9958995b9ac92d4f2b1137b97be20d217f33df6c41fed39c16a66a2c69bd94f7d55ef5041cc0eba603da9b0b2517ff219694c96c045ba46ce460567c0d3556ead1d129a61c66b3cba9814050e274ae2d8cbbee3a2f67e488cc10ca401abfdf59f0186aefa540b6e8d2c061ef0beb71d45d7048077cb5c885e400cc3a085ad590a90535ce96098053550eecae8e8c5d4f55dbe9616195d80e9bbe296aff0d6f989eb1568d5d0ae9385cf9eb05a887c2b8dd7264ae145c17a323c01b37a912dcda65d56e64ee8aa416dd375ca1cd7fe8c8e88872e3c3afef13aa8559e88f4d8acc161f7d1a9059aab104c5edd56d57f387933960982bb566b18bd5c020707351bbfb967aae55194d27016b1583184b79e33a5e5a99fc27045e8e6a5e93fe3ec6e44ff11a275b9c6b5ecc3b723751ece2f90af219d0251fca2edcee74ad568b513b80b54c7239f16b68eb9609941b05728dcaf54c49ddf574714959d6bfa7bc9d5de6b22f00be296c021df7905469eb3c15a49b30d4a7304d7284e7357b652642289ebf71094ee451288743d480ee7a8fd19e61d07cbebd302929b9990965237f97761975a1a059088b52059349717ca1db8a89d6cf8cf2e7d9d574926f1e983105e6936aab92d6ca8d8ed8612538566a1fb26324d2025195be3ab5d3cbacd3aeebc9a4c57a25051dad61913cbacc715c02483c941d1d43639f3cc6f2a45783422c416615a68093ca1004e19c3559c2f446e96df31ba97b4fc4246db8756b0e0705b145dc4f54dd8f1c4803fea81af4eff8649ed188edd486bc1022bc6574504e186172cc126a404482a23db9434bb67c79cd549bdd29d65d4788dbb714ee080a3ee8f59b45bc5546c45caa9ad245366625c8c9c8b328d84c80aa14e002609c0f1443d1ec6bcd4ff647ad2f39e974ac1f6a3b3348589ab11dd6205220afdb69e5e88bef2bc975c28d2a3e0d50d08eaf7e3d245698ebef32df47fdbf8bb3138c2978c1722c191108136ae8bf010c294e372ae656aaf852933789e2dea04b9973e5f96803517427fe70e8127ba5a6e14cab3345e5093383a311184e3f228dc6d64828c3abe975a2dccf691210a7e1cb3af49adbe0566250aad34a2cc612e7d765e87677fa5962b18780dfa61f27233b81d53fe89794792c19679a82447c3ae744a3e6cc7ffccfb502f7eb24281e71f10aee859015f22a28ff8bb268e672b9798671d53412aaa29758c219c4c908655113474638c702d49d4b1cecaa8d887851303f20d4a98cbfcd52c31ad019940b57ac130506a3c168cb44516cc866058e5397a23f4b9fa06c3928f742fa247212ed2d47c571b1170ab9838fb0e1962c2f22ff5fc7f8156f1fb5ab5baa573f06462d0995b14f029f8cbb34e628efe1334ca0a7d8adfc4d03ef882e43c514b0cc449dc4d15a8e78c5d6b924e0d2584a370bf507d2ef8b9ba1d9749fca8e701d45a5d255f808b3e4fe8b23fe1bea5ebb4cf8880ac070e776134a2f63e2a9153260ee73c650c239cbd993bf1fe5ab535f070ce01927c22e7b06dd4e2fa94d5678989d98652f4a8dd74135cd2197e2b8955ac739146bda5d16c45d77269f525417853b92a06f4e033b67847fd69d38450ad335f07d14b0731f73c83f7624a1d13398d215199f2185fab7e692f997f7d79041210270a6d63c3c2ef687329b97e394d39f02b27ea9c95fefb878589d28796eaf5a6654b5536afbc7c26fdefb65eef2a7d88dbc1b4aa570e887d87d2584c4bdfbc4521050bdfd910c494d2629900b46ec2654cef1dec7334ad498d34d7a5c5bff051b5d6542c1cff4ccc88607f6916ddc34514ba03ab071c1bd3824789f63484e297755fda6b142dfdea90fd160449202cc80612e5ecb5baf736c9478527cc8313a625deb1bb5d9f1d1b0603c700d40686323d8ee30533cd8c53db7216d325749ee3c2f22bd6bade61660b9c9c6f423edc5abb86bb72e8661f8a3cd9463ca681d94fa862cdb2b4c48208eff8c2d27cf41f2c1deefcfb9d3f8c12c4624a856b2f217c1353ef317f8dadca17cbd85cf20eb008c785af1ea1c2ade5f73e0e32ba2ee8e3f532ff58b28aced872f4d9e7a3f7c9f2857caec60b15082e3bc50f5aefc95dc437d255ecd4cfe73de93767199154d6e1dbbcec17fd7d2e52d0d80746551363ca89af23c4debb269f4d571264795b94b77696a204ba624586534b1d6f0fea24ee422b3cbbec7a3ae12a2493f80e35cd85f02147f638635cc387eb0bccc80e01326b426fe6e73b77cb3eb8688d472f086d7d5409274f1b4a3e53731a4d16aa2691ec0498ef1ee294d520aa63c2969470fbe3e37cae31a051257e107cac5289f82ec152832dd8661677c5618544e7081a107a7da4e871b87bf175ee63654cd6b662de65ff897d5bee4fbd09ce8eeb7492cd96f61faab4c6f7604e5d51a5e3a87cdd838c815953fe07ae9e5e218f1d1390a003be407cec93785e6147531eb0e67219bb251d84a123c965a5cfc96504d4df6a5f8a337fa624551328d2fe2c0aaddecf0aa48b82b6b3f42b5d3ccad66ede97ee939968ee8f5b4cbe4c0d487a3492bc5884b09394960a3d6a8d2a643d7519ab098910d0668919bd21c6247925d06f602c96e0b88c10fae155b6881bf5ab239faa1f6813c21b65ea02954280ef79af6e0f27f0cf7c93db14cd5b51926dea91680459088b040c42186ec2a36a116bf1e8301113bc6c4d0c50bc9dfd617da2e9df007dd67c3fab78987387665903d020e50870589ac1572910a374768c2f9f63a28862a46512a9199a6fea102293706eb6e85a327c200791c69162762843707e2cbfdfac0569b19558a3e2c42ab46d2fdacbb17c6b585eb08c511097ab79f15d061f12e7693b2cbaa3f3b2e69c4caa775a30538a360fc8c25406ac54d9933c385de9ab9a223125d356c7d1946a81fe340b00232c5347c326018a1a68c3612ddd6d0023a996a7d4541d3d1a98b152bd87977c40adc57af4d220f722b911f5bb303c51e60a273e9e651976e243cdfe97a2cebfd4b4dadec78a49690f78636197bd74a0923d9a95ba4c63f467bc864a0185c4b96b48efb574062c310fbe01c79f3a02e520e39918c36615d3980984e4a154a365efa5224455c863226bc0949c60243dc7cf4cf2815ffe32be9a3b2e62658ecdc583ae6142b4e0b26bf7a54df7ca3469312cca7ff19172915c98dd5f8e2be0193a6bdcf1008851f45f7000e3e6c4d805a5b62be1fc382cd89f1e3c7843511d51e1cdde96c69eacfbbe86588d7e01659f2ba074b42d90887bb099425a547b2a035d6ee65b78c5bf85631bfcaf53a0a40bbe2711aaa7228a322e77677c1abdc5385e035e208c6ae22e90eb843f0d7c542390828d5bfa535aed6939d2acf165d64116722fab7cf6358897ecfb8f072cca58b2a9ace618075daeed79bc9186ca58e5a8a8c227d5e78c130426d755fa03599eae675c017e231ce19e4fd1e87a10b38ebcdc5533aef06abd929c56de4c14e79bac1c85c2c8aedf7f92e4151ff019ff801d5b881bdb1509ab114372f8b5424ecbb5c9d89820d8f282af668259f03c3b90d046c80e010fc8fa5937d98c0db4111f51717b10257e1cea7e63ebe263948966f7d40d4c151106db2e1ac4e8b6506ee159404daa716607e1c8aa5fd8c227b6c61e74e4d355f93e775d48e5c42e0b3f3d4c8a0c4613fabaeaafbbf6e33eac49f158263cf249fe96d59caf5e9b12976c5181d2b8e50b27955d58038984d974331027026d5217e13c08512208f10921aa2567b323d080a8d4071d991d3c51a82ae0f50e9138b3a8dda59c13569560218adc8a86519be65f6e30e88de09ad24861173150ead4918dbe0ba7d78b6a2b1df7f7f59f8e1ea8587c5e003825c0fe11cf5d3a4c079e75920e065041e860578c1218b8f6d3d1a7ec5c1d8dfdde7acc5ce683367510c29d6a13aa6c358e2d17bd17f5fea6e30336f2b47b97e0c390678579a8a5ed54e27d1dafb0b51580fb11862a9cc9c23528c5d077f443d0799a4ce0794f480ad7f5c0bc021819977d9cff38d524efdb04bce3c414b2b1616e7b573ae8ada4e650627d86a5f4145de8d3c109229613e9a5e57ea132cfd227ef67a31d530428fc4978dabe5bca63bf057df6edf2abe69b750fb7122b22ca0c6c5a82b54398c6f081c18af23d700ee6da895989ec01bbf0ba0986862cda9a874bdf0ae35b6fe55c7e12c46abbbeeced0fadad1c559c81969c0dc2fd3b79ce5400c2d2112b0b4ca59631b3feb7afd979c222450797cc43a2533d20783644629ab2ec0e5e5a67b8d1c6881d88986cbe5148698d8aff6d9b88a9c7cef4fe9cfa13e27169de28ecd99962be96c39a1a568c785df1e479ffba1f802518af5baf06247b5ce0deb64b19b41e71fc40c2e799569cc4a9ef242519262f5bb5321f8bd8385d840597f24e2e010b3e87e347a1926f0f899c3e5fa366bcd2ba0b49ff5e0b5c838f5c44c8485ffa9c2c6a5a0f2827cb285342a3cb79a66e85b20dbc7c619f58972dd4d7f5aba1be4fa7c49f7997ffa3dd03d49e34248fc05cfce2d46e20cc62818bb3cd8409a1024396bf1926664bdb9e94596506e0facdbaa3c5ccdffbed3039ad50d4b6377d5f995c29ddf9a98b415a94340af5a55c74d07d7898e13a2fd0516643f244ceb9f199a8f8ba510c858566d6360ec2da6f5349e6f6d86b2ec82a7d8505a81768223e2020fbd17ca6dabdb561b015ecbe4517db91139cafe017db9bdb6cc0fba6a09a81f575c6792a714ef9b0cf7de98d9cdad30fc1a64f1537","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
