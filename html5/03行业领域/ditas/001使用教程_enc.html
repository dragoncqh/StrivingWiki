<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b45ebde4babb3c45749e6bcbbd69803769585bd4c59226806b9b4517352768a0e02301f017649fabf2ab08d3bddb6602e240afbf6ec9a48d5be9d91dd0fe513ea81e0c8dd8164deefbabde230a70f52f09b4bdb2065c15ecc892bfffed83a150905a392c4230063cccd897f024d76b7313c98dd5ecec62b605b9eb4679381231fc93895157024e6edaa84b4838ab0f223e16d5f3d4f9729ef07dc63010806f37cd7f487b66078738da7ff03272a5eddca85d59432c95f85dca8609bc79d6f5690ee746c537982627ae6390e7b0b94babb13a192828aadacea4dac166a1f300bf31e2535e77937d6c90cd6e058b0f5e23061f0c9f4ea844885e5e1482162a659103b326d0e1f4ba3c0e77b6e45f41a46168033d56c762a073785264a088c81de80835292272b688c7348b8c9b5e19f5f7a6d29e07e4c7340c990875c886636a2ed7b3ba87cc52d74d85f37feafe2a001427a8655af6345b7cd622bdb1298ba8e719fb1f9c2f67d458991ddb8cf5571fb64105a229d8827eb5bc7557c86a10ae8de6a3bd00647de5c9d03f8aa4f75340897aaefbe63e0e9ea42e486451318edf0116341c277c2dbf0e03d06719c53cca954997600fca9fd45425a00bdfca6847d35ebc10d8ff4e845ddcbb710676ddbaebda5ff9725ebb9e9200920a1cdb9df9f55f26d56c281b4bb20051a54e62a6c846b5edee37cd45a7268286a80faa46af5dbfb9815ddda33d04fc7c13fb58cc6a93a58125cb1ddee336391e656c5c25cd251462452900325637c1e708bb7da228cbbfa9cbbbba65595366fc47bfbfad4293ea57ad03e0ce521f0e2270ad7d6a27b676fd03923957e4a632f637c07dbf48df8486e46735331df7b4c55059dcc0678b2d7d30053dee67dcfc556185b069e9c4254988b7e2ccc0c6635cceb7110ff2b3d9e0f55da73276f974e842e284ca801d9798992fa48a3c7d0029494ea987b1d0ccdf75fb4bb783836a35a54eea3f5d5d536eb412a24bbd9a71e2948fd564751f593050017fc6c2a59ee5fadf3bbdc4b396b42f788947d23a39258f724ec315fed3f98c58eafab04691372dae2fda4a8b78c6b170c0148cf443cf4c0e6f0516f6d726a2e1563a593904c82157b3123137b7a62ae1cc36272de00f06a8af339220db773b0b105e57fbe75d6ac3c9cd16a2cf38bd6ebb67ebc2043d669235d175c0c976e4e31cb44e06310950a323484f81b96ffa58847d2d7191959b4c4ee929645c8af87f5cf073187b6ae1104de20e6680679d6176b785b0f72910430d1cf97c7ea41c65249cda2000e657fddb5e8c7fc774b2219e0a2792eea52c2b9cfe0b57f093554b1bb76b3b36ce92e70dca548d97f0a435f84266c7a2412225faf24bdbd98eab8748e7c85f3040ca520c27db949af4ecb092f9e5b80e85d951a1a9baa38dce99ad880776f64bd46a2f422157a84837abad5db4d92b4f534a8d70d7fddf39011e3ec2539887f1fb0fae25e99ebecb2fb1fe8fb25f52d527f5679f13d345f30076111b03f04e1a87cfcdc679ce7474de7464a3c74860551fd0d82e325348685241e1e19b83880c7a8049e95691596696bdd15364828eb3824f4e1a6f8beba312a31ae16702364622d858340a1ff3a05445052b5e15fca9cbc5d1554b05d7944841c2d3fc76cf90cbd2cc73e8c8a5735b6fdccda9b16ba7627a513be1fb86ff86fad354d02f79ad53161f741b54c9037286f2ad9a7422301e87964d798e82c38aea32af3f2e93dde57b471923d39b76f87b659fcd1e4febaf79d983deb6639f10ec94dd9ab505884531bf91924456e57cdd3bf8e3fcb1f5c1d97aff2412150d443c7e95da0953e607be01be46fa275def4576fbaae5aecd6e917af09f8db9a460ab732f81af02c98fea9e7564e3c57d3a4f0ae1e1c657ee7434576d763ed187b03de4964898cd539b10b2ceb993a1a412b40dccec3370f0392c70c9f9147e83f22452c3a497b3c2fedab900bd44002ea49c09005b6a9686fec83973a03d77d7606e31a6aa0e74dd19dd084048ad20a50e14343a58e9ee91c05d815e13fdaceeac5569b57ecfdcae37143486594b27068ecc66bd98f2571656f81096d776d49c4b75f3fec277c481f42ceeeee1aa03e2a2cdd877cbcc35aebb8b6cbcbadc61dcb59848cbfc9bae207a349c0f6510325013b3eac62fbd8c826844727b47a8add52eb559f7ff945ccb1392549f88272a3309854b0bf8c0bb9fb5be8215e9901a3c9f15071ef7298768d7a1db1c3b8bc03ee9da509e271352e1e6c5476ba6eaf865a8ea4a4b3bb0519559752fe7b89edbc12e2d666c05589bb17c1bdaf7f73863892c412bbe3130d359cdefdc603c74d6ec27ddcbc37d6da7b41cd087ceb4bbfb90df078e4c62158eee4b4c18e66ac5f3340b598c7453cd4b770ec9e76d65ff5632713c8ec1aa070fbff5c7793431668015518c276368a48c2c4f96827601165255378e9d6a3e60a13d38dc77036bcc4673ccece964f06d1a9a28d98e99202e2fceb0f4b27f5e7db1397e8497b4e8374d27719307e85a5cb11503f10196dd2d44f98cfbeb338dc49b361c18f1a05312227ac61de7f174fa45ace03464f0e9d76e3880825b270c8665b61fffde4dffac02dd8353b3eb9ada6a491cde2268a6aadb5d69351825ae0684293127b587719304d0e11a4237a039a5d79c4c686fb9b5ee55eab762c7e90510e7078a0103d0742f4abd4f150c627983757dabfaff9c79b594a64a9929411913c2662c1f5e1d35b2d9583e53cd8f0f3a8893fb8ac217d25f3e5db0fe726f29148da8e7f41e3d4380eed903553c71b2ec62b9cbb5d2c51dfdc99b419f166ad5f4c06ce4e0b3ae44e6c54e022ac03ed6f29133ab62ac4bb341a6570328ccb9e22aaa2fbef9d80c4b9f76fb75c6ea23bef779618f45a35a5fd903cee63acc8f0e27d342064ecb90b05d42f64a0fe29a0b8be6c5abf70821bc4118263bc33636472b4f3ed74ae1209c82923201c4505ec27aaf6af70b9b1fe0eecdf3999770e3b00b4d6fff7e454331f5770643f53bfdda9d7faadc3d5f4cdc71076aa12cb26c70360c6be82db090732d91d8c525cf5e177a6860117576aaf69d16cf41390f6c728e1d0e2e02fd23365fc51e61866e04a3dd0084e675d37b47cc78375a15eb5eba07d2f37d8dc713f421dc3a6a2df1362cae734ab29f155c84894315654812d92701d3f14daefff42e8d35a7021ec8665fb9f62d8086c8e0331562e41250401f5dd0159c54424dfcbb2d4cb8ed010bfe592b06c7a89301cdeff1b29ad73356ba2bb79ce02f33934c002ff2eb1a63890cc4877c2b1af36873fa4644a0cec3222c8879d1c42c658b012a4900bc8adf9a316b00835b051f30f10257d90f612e7b08e8b51de603774327561fc035874a6d0f80bf397ce0b93191495397ed5d47d29e59cc21b4ac1902f5e6d199f5a952b3da20ccb2ff328e5369a118320410499147c15007d4edddd369d6228e639915c45cbba20c4a6b61c7b795803e348f4db266a6ee8c8c6056622dfdcb113633c25479705e57dd8c46143963e86dde8d29d79fba076021896127932c92d7feadb61a747d321d5efcd90569cd440ee1a70e07ff498e83713aa93089e5036943382aee2ed76b7483e7888840608d2b927044c4e48f350a72addf50f76b3a4bb4d00e40561727fcb8d70223fe157ed521748d3a805c26ee27ad596f04d4fbf5be9e891b4a571040deccb3c98bdec041f419f049e2c2aa616c61683238fc627017efa970550bbc431e5c4401a1b6bd406855e1291302e655fe4abc670470498fe95b480bd20cc17dc06d3c4b8b24b033463e973d524db5cf67c9e9b3a6484743516117e29f6b9b6e0ddedbcc3a7581905d48b7b5c450fe2cef2b4ebafa3aeb7c85bd0616fa391ef27d7127ca3265713762654f87d1f65a0e5f304132cbbc7bb20c6367f1a8211907c342aff1218344aa9d5bb71e95fb3fa7d2f3a2cb0aa594abf3ceaa4d9fc2b4fedb08e45b0aa7a90b348daa5ba1ad339ba8c33f8b34ec80978a18137473bad09689f656ee03b35ab6f921e14c3f32bba05ba2dfa55d5b41152153158d674fa0528d899ffae06ab6271f079d50ed5c696f6ddda663cec78b538f479f96d3de02ce419f93fb31b23e889f2529ddf9171f1f5835670d940c5513055678faf9410bcf29630e36d6ed374bbffb37560125eb3029051b24cb0220cc64ffb8dcfafddb70abeb68de5b14810ba0737aff8025c8fb9106c8d6ee37c66a92b6e2d62f4abf7998d162efd7fb394b19df131f833838e6fe6402d4d687a4a9a3210b3993ad64aa3946936596a7990ec1c561b0f1aea5732888dd5a0bd15c671b0934e30c1475ca5a8416a0597a8710ab8e997545d6ecad34b102bc77543fd028c8b2f6a1fcc03e238dfd39d4fecc64f41d6838366e7a04a1b91ddd7a8121e0700a9b919d2885d81371641ae99d0f17a50ef712521fddef9ce7e7ecd921c00e20b06527fe021be9a427f346e0266518c7392c3f259652f5195a1ac7626a7b6f57462a452492f024084c0c07530006c1931106440231d1b2dd01b0ba9426aae86f0808b73d95967e6169b7d8a33e2ff7093edbb1de9cf1459267d478aa9aef130649c0a1fa899f73992969a4c99248a9dc84a222670931f62d67d29456b8c14defa2e3f32e27e87a3864aa493117f55380475ec8b9bc5b538ed4133851d06f859aa45f4fff071911cf95106dbb531967472063dbc1c0d224d0624e733457e966c3ed9e67b11f198d3ee429b786e387617610121e5a8840f36364b88574417470679d83ece82bcbdad886448327d06cea2123f584bcbbac7f211e11246d4ad16336794839ca32aa72a604803ea8607eb2db62b4d40d85bd506dd22389eb4733366174da720e9bf194b01fad5607a1fa8f1b3ab2875fe1a307e6a44b81617b0ea6de5e6941034404163e0246df1c38eed3c6caaa7380a873b868d014c43f866474d0054c84f4a817c67e8232c76fdcd221695892695ece266523292acd0525a78beb6820970b730ec0726da740c429553d63e042e1c40150c1f1c685ba59bfb43263c75f1bf7e032e8a0deec4f67c90660b0533a403625566f8e168feb1a9f18a474145208354ed42fb06a538867c1646bc41d21479fde0a8436cabaa79106abbe50bfb9ae2bf9e924bb4ff727a94792b70998d372f8d10a091778f6e360dd4bbc56c00a9eafa65b76d046af1399d90fc7daa8b0a0522a2353adf5d36ba22dfc2eac1fa5b6617817e0699da1135218cb03d8fe0309e023afd9a6e92ed6bc0cfbf859baaf4f84798132c2db4667acffa4486103071ec271a9f8c8131e55e7ccbd41aa3f996ea8c56ce1b1bdd618df498d97f969a5f0df206b013678266f3c4e113064e2da4f576f16444d6ab997d767023c637e352ce135c8e206137ca412d66adfd8b406c51cc0d69c2a811c8fc295f2ad202e7118fd18c69d9d26ab5524a97a8ba93301c1542a45c76013fad559a272d74929bc9767db139fec087fdc65e6b740f3a641c514f19201e85f1fee781f2ac076b1bed7b21bc20a1d2f291576bd4b556425ad1582519c3ccf547164cc9645f7c5d6cda27535d929c3e13f027bf793fa9006ebc3b55d3c68bc80bc4799516df532d9af2951f942256703be539948918bf2aea0978d43f62274db89445d40afe36c929c442bca5a24572e6e09433b5a4fde707a3511bb403933c1fb7fb61ec73192d348a46561c2da3fb01fe70543b359d85f04fc997eba2f3e08b62ff2a175c1fa847c422d2c11168ed9b0a4fe5487be3f5b271b72fbcaaed86e1414b3a93ae3c0d71fba7df59bb7baf1b12f910f58f3c35708d5c168e4ae6a76f7796d9435d3640b03d9051293231469e95cf34e04c07832e3625c9241057203344f8575d18ed8a39f37d3467404b39eb049486402c6fa601e1f4c11ae889544c89017f513fdf06df68f69b8084205cd00afb2b829cd9712bc731c1c20cc5a09317c7094ac803911f4b24c921b3f0b428b17eca1b2f025928f1985cf3e2a8cb7a6c330f2368fa35270c3ea6ab0c59004463095efea28a4e204ff3d596ad4598e9d09b55707e02846c1a20fc16de85856573aa29ca6ceda0d7ab4d9de5e3341004a3f84dff37e02640b62db5cb934fd40c9c73ab7b6f8093142d45ea4789c20c9a36244126078c7660238d9f303895bc72a7397f1d30e6461a47d41957acf476fe0feb36ea703fdc81cb2370e05165b56a01cbd092f09be3848b7d96034484babe5527ee683cb0fade10968537a2792dac81f2ce17a5c89419660d824be0f30722a373895e11d1046d2169754a1694c405e461c2d5a9d21d40f1e52b6606805b4947dbb4e04fc5a4170fa92673e025449e637488451c48a30f2fc2c3a263e21a27f5d6f0bd7fbb2df1fcc1e08b7f97365f8e0db1220176450eb2bed295f85c0469ae659692bc8e99896a4acfc5949610f60e09933849cb0a4100b5bbec6f7726147d096651b7bff3acab7dafc852f3024fe0a9ab545c078517b2ac4f028a6060511c6517ee0b456ba210959a60b77d68f551556c183b38f60d650ee9eed2e26d5399a14dbec6ecb91c21d60976c033af1d0000182c4575d7e64f4f2224cc01c179c67c16d311b3a782e3ac9612fbc669a03445c8c82b81dad109026b63aef4c8e69fd8b457fa4729acac31992f6919111de8d2dda6760f212873ce2f8fe1c92c88a25202888adbb463394645ce2fc60e0148c45bfc23c3498bfcbf64507356729306dd68be52f30cf0eae52783b2bccd7425aa27b628e51118cff8bfe40e9e572f132e56857f29baa690aa903bf214e9dfe43bad6d793a81bc374db200fb948694f9801f6fa2feee873fe9f55c6ed698f7125c8488da92ef55811d7334bfa1124deaf8f3543b18bf999afd929688cf95b07e24b23b91f85a61eac01ca3e73bf3004ce3903eff39e9476cb270ccc3480baa7961d2883a9f47d365a403790eb316cc2a53ce2a8fb7a03164c42b7c2da8b9c96e3efe658e1e2302619d5779ebfc3295a71c87a4de8cad58ba300943fef3217b284814107689c9865e3085d52b60b006f2f077b58b9a89cb5f02a6f0672c7816a2f5e66130475cec735ca164c0063ceb4eec205439ec69fcbac46439c02582bcee9db36e122c3b984957993789832dad52e61234a2a3544d465f49445903a3adfc7191a27e84ce9183b1aab756ee21790a97518ec0442bd1a9046e38fbf93009b871c8d24fa4f1a13587a0ad4ec9ec10591635639bdd8689af345cd38989a7bc617202ac5545c2363db5b658e01284d94004c36abaab8c6f2ed90eca158cfe5104778b2946da532214dc2b8bb1ffc435a29549fa1938716b1d7471c298679a8baaa5452a59a39dd89855ba6a081d84114c8827a66d4f33a934c169ebbfb69b4fa4cfff17b6141ec3e82e160927d071ccb01836458572c7d7f4efa6fc9d7b6ad8617b1cb423747965927feeca6f7f87c4ad340732329e66f7904b7d88c639aaa2f3fbbca1b118984e2aae3e4ad7a7d43553bdc07a126daea5223c71cf0d38e6398c9c3adfb0a61275acadff17960a2f7639e633610418b335cd14874f1f4c25ba0c8028c93d60ee88c5c7880d6bd3f99b2fb4a9c02f859d662ba0cd43360b89d7c0003d16a5ebfecc4de4862c5b54c89226187e55b042a2c1d8117a72f7e12f94a9b7bd60131d026007932c1acbc2bb88a242ad85d8b69909c9c587c5d0c7e047f36d51d44781e8e0acc5c46c89e476d61cafb6d9409f139711241f11773d4076069e4c725731c8609544636d472318448809701207c69feca362b80c52978d532bf13da5b4d54589590b0fd4e2f4c389981f068407af3bfebb1f337a89d3120ba8971b004ecb7e5ab230b5283e719beea056d6dca30660ccd38ab54c3afb7a7368215daf84ed5aea72a68c53754c75e4bcc225d086168b6b5012804f7593d5264e297f04b1b2fab37c3f4428e34fb11cb4d58ff2bcf379b04a8b3e93e25ed366840d451044fb2f35e213393b12bed4981ab8fe727b0a6455a79b9a97024a6c23742a559a94ae361b8dbc78cd79d07ba21d9c60ef3e81e15f39e9122e6607930220323aeb7080ae4a6b0382ec595330f2b67b02e1aa3c775f3c38cc222d9827620c9c580356d18377bcdac27642d49ffe5d63e604577011a639b75c8d0853de2e15de1d053355d1576743cfdd8543175f2a678a6a6e23db19bbda72e2194a226433b2bbb7f2140509b03a99e30fbba8cfaa75c597f7e2357eec1a98504e74cf03273e55bf9606799712a9480fcdfd0cc578dd7b4f6ea4ae6f92716e0f1dccd0f7f5cc3fdb5b05c0cceab086489e309aa1e3c61d61801a9663df66908d8596fe0dad95535b6626bfbd11e6afce0b8869027f8507741716303afe7b44748cabdb37bceba2dbfaf46b6c636981b3757362d3f9d9c230f6ff14a6f50f389048130a312c0f96842a6631e40cde525326b0abde2e6c19ccb1f04f02aa1eee03eb2d9bd74a4ecba69c1b66f9bd3b0e1e38f311bd3182a68614324655fcba7275d536189c2b52beedff06f3e214600e9a85c87ec87dd23c4a9d8161ffb03a43ff2ddc7c5f227f69b70e9115a5894e1db132699571e6335a4d31fb0acc0ef7c381afb2f4b535fb5349dfd00ba50f861f03af90070272f42259f0ac78fda6588def3a4ad713f3b222256998c9c9ccc5c971c7a1bdc57d4bd1dc21e303aea6a28340123fdc104aa92013c7db02d9ba0ba279e69c375c56be2c4c9c3e88210a9892232b306826c06631359f2d00bc6c73516e5fc5cb832817675f5e3141887334d27322e5fd6180aa2c56318f1221f141017b41d3badb3a48c70c546cee176182d2e2eb2a626ab1f74c66b19639c684420d2b0b96d22b316ef91e2696f016a83a9c7837c5c05286c277d8f17affdc5f9908d4dd5d14602f3b3ece2d6f8f31d23c1cfd8350363f94040bc065a865c2c08c52beecc35e08b49982592398a28b532351fc88e7c2313894c9b2cb52bd047e93a86fc8d6ab50dc8d9b830b2cb79975488526c1cb54736cf9e8786d2955d915df0f8bab5b3eb1c2e79866114cfb2cd51b2d0e23e4abdd9f141fee994bc857bbb1dfef61b48fbf4e15b30f23f711396b4151183061441c2945e569074434ee91f48830e5d49a8eb4097f0c0326d5fd368ffff4b6bd9b8846d5975b7bac1f8964695e9e24081b668e5666957952ae440fc79bd8addd421a5b5980fcf4fe2eca5b4c813abb4ea6a50b728735019e224bcc1936b3a0880d03f0ad2557a14f0b975d61ba9ad26637f22f0d586faaa1cfc4134821662b50904a10a306e7496106188ba7ada89ed40d0cbf20273650c0aed220294739c16720863c45d27e51ef5ba0dbc4271ec03ee06ece4466b66caf5cec62dac5b48bd045db352a5920cef75cf7c764a20be53b5cbef28283d7fec81d6f5b6826bfa93a485a260569c422e54f8817da4a7653fad5a0e9e4b2c894e44b71a950d156944ff874d1746ce61d3c1c5374ce8981644c43f51438f1fa4b478419a5bb72f9c1d883f630e5497b3457234676e1186e5206535394006d58f8a9fe3e4b5682fa4b1dcfdc09869722a7d824e382f11d54c429dc6304d876004d579982569d47dcbf43314da6ed72b03444b1ef1b12260437d1d898f0121c332e5370de844594d6ebcb8ea09ec013ddb2750c08d432ab20ef6eb842c79de86749b0d73ebeacf53000c8649fe30a615cacc2cdca0eb6f3627f5e9f8465721e583197c23b64688b3b4ecde06385340ea487dd534b024f472d353f2ffa2ee95c9f0ad169e4f9340022636360daef7af22cde5eec77e44acfe318ae37feb924912fe043126bc7e8b43c6e5b3589ce759adc5f35a6c71fe2a8751af700f20893d91e8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
