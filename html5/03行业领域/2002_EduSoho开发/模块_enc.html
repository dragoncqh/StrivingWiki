<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3e893e42272a86d410ce16a751a932fa3d2a0d319b2e73eaf3f3621c7a665ee4669b97b3c5e30b8d31d6d8d02d883ad8480995b19412fc2b6a2ede4af9cf53e434d923740929d3736543736e82b8309231de26c658b8738ce48bb95bfe0d4af4d4539c2663265dc1e223a7daa7ed68cbc4d9dcff4009a965f3a05e183ce167568f085601185a94c250280e123ff00da143970bbbb1a4a3ff924cc1a52c757727962c70b9adf377aba4ac841f9b65b200509fc526824511fae4edcac251359cdb712b744ca1dcda45c3544de6428f18bb12ab65f0c481b9a9305f1b22d57d0e642fa8f918c61ed952ada87cfd71e84e141f5842395f11dcf97c2d0536ce6cf3e8a95c0cc08036b969d364101a903c1442527a7d0de2528c58626a30f823afe74cea403c90d0c1c3ade481527e372e8513cdc4b6e5974d0c7d4378717f3976784e7f73bc469671018e1f39683cd506f403cefc1d424778c1563060e4a53efa1a47a5c424d5fd646950f697ab82eb1a2bf1c359c761b6cf662ff3de775a8be626a1c9d7c18cc281e37345743e130931bf21aaebcb9029c12929191af8b42a943af3d0cfb6ba015193a46a51c4a98a226d36e97ff57230c1ef271d60c9b026bdf0c476d9b0acf562461d4d8e62e7c632e249d9f95f42b7dc7104b738c368b293f0cba5cce06fbfda65d76f0b35d21c023e92a9e21bbc87af5eb7fecdb6469f3f02457e3ed511274bf4d28285fc993148f0969ffd53bd770e76b1a203ef33d1f7c8ba4c610ec88b05aedbe33b6d6bc0b111120eda6f94ceeb30a1d992cd949eed9f57f9d6817c07752a1cafdbc62f5b8828ceded37f0541f52618f470c8fa6ea761125d4db5d5fd9defe42690cd8987a44abb327527bf18eb91fb52b4a1ee36e4ea087704d9fb1e23eba41bcb263cbea0db2c873162ed42072477a7709eef0507158ef8f4a08472411b1b9af65e2c88907548fc82fa4ee871195a1c813d24381558ff4a50d792120b674b8c0759b52799da124782eb8d2ba7e131d0b7926a6ee0d8e5b1b081cdc0060d688ec4848d1ca72b37cee06c5c4f45e7ca641391c1b0e40a286d24d1a89519ac671375b71a6b803b347a293aa6dacaeb23318aa59f7f50acb116646a9e4e30f595f2207d18dc7de16c8f89e2909ba68f631703f045b05a1d126075eb4ae73eee3f1f8e78682d5956c8f05735c471e4743f888359bf5619ccb9408a4b9ed06a59260033c698f9c423a06e2ce492d86cc3616d72a902ed4d86133e927ae67066c051764cde0e4adedd1addd8a61e50b843dfd760302e7ce5b06cdd5bb2a91d355fd5c8d955cb94077374f4b31d2ec0a8bf111dea76c724b34d3235a8f9c02f24c9ae5db50236c0dd41fa26f77d27d258943f976230637f85f85ebb4c4e4321e6800d032d7e7ddf5fc0c8808b2a2ee27bf6265c97435a71988f1275d15eeb32f674ce507f0af509f24c6c38adf8f707972c6e05c1388282a212815b3595a452dd1fef8d44c8f02cec5947431e6213428a3ce8752186c2e6b0f104856a57868d9692e6aff7c14a6bbc5bacba103fd8b63e3c6d09b100b3d0a1e81052c24c6c38d18ee939104c219fd8bab96deb7fad371ffe4c7d6689248ce94fc90715003c8ddb1541b4e18ae7c6a69e2e224f8e8f1e36ed6990b20e56cc3648331f7ad304a773b35f91c8636df988af55f29d33790aa24d92e3bb31368e4e8bdb8160ba65c35ad499ff3592ff728816b409ca069ed882791593d2134938f31c862f35e67d1bfe994b63b65561dd79bd5e64bb3aa241606df2ff2cdd22d1aa4cd76679b37acddd09dd060c54cf58b76a6741adc1558d3875478ac9b6ec630b35aca6393e20a89978728a42bc70f9b3eed27baa46bc87c36c55c48e83bf992afed39475769c7fb5b74bb72bb29015b2442b32974900c61e5968836eac77aba4566101750c2fd3ddccea554d2d6480d6b873e109f9dbc2e6359301e4675dfe0a9744aa0b56c27a547688739b34ca5d1de3a6d94bf44ee1826647df3713e8e48dc6623ba6ba421b98175019f6db2a9e86bddac173bb3176802c261347b56f7d73aeb41b7213b4abaf7569f062ea2194df2a205f04eff03b4b2c0b864819cbf59163bd94e9746561418dcebe1cf3b8376f4ff97ca03555a7808ff6b4081b06dc2fa9646ecedc02edee6ad0fd1cf60e72a0ae8bbf2cfc65f5abb79e2a1cff8b1f6a80343feeea920e1fa62eada0af68decb93f327842fb87993606afd691f6ae642d729f5998a29474ff1bd74a7882deef391108efdffeb82d98551c648d4bff063ab6c2a07d3afcf0b0af1ffd5a53c63539a5a5feb9cd245973f41b39ddd767686e3af6af0a1f400b7e1c44c8298a99f907609045d388dd161b86d000f80737c0e33e5dd32855f566e698b3533aba752b2a5ffdbdb38eb45012a486a60219b407dcacc811612fbe38be69d4277f6a7b380b4690abbd175ae2e518d6c09bb77435cd33b2b8f1a0e95ba24b572423df2ddc391e1b5fc87cc3eefdf310b647802d3b1f5f27c26d69f771ed040b10b428805cabb2026831adf25ed33ae3c008e17579c9188752194277f99d0506a75ce0b3ad0cf9ac59c47a69a702be00409b63ccb600d941087f2ac86676a4d65ca613db917c0dd33c899ee07b0270963ff692f57ae086dd0b95ba3fcfc05ee57018172cd0e753174ee35064fc91d843f90c7976cdbab239208a74bfb1595c74319f42cacb4845aa7dc4f54978bbc4ae8ce6110e9b9a876d2948862463a6c4981af56f832181e4e4cc44e0d123862d5f9cacb85930247c649492b6af7b3141e9851782e05621993b8547f24209003b5aa64e0f83b1f20eb77b1bb614d05bc26f6124388a927090e78e13e317f66d9acb7a1153af48d5e42b76bdad7c0b478dad9a383b24d21b7c18f9f9b23d3c0b3599870c6ea4f3a350c5a3a2cfaf7ed4bbd1ae3eea0b36a18d31fb031af2ce1ff4df1dc102cab650beb0aeb0b95f8fadf6fcef7364e336ce8bf5a9eb05b200b5632e1dc5cce68a4283de8e7f9f8c85ddf6ffa8c79211c2094f3363c6d50294fc8aaaed1ff447fcf4f80aef56d2ed1f1b63b5dec2659f449cb3354940a5320fdcda9e76010034c298d913db377394df9e85e5279362c6b553f36ea783dbedd1e6abb935ea78c27427409615dd84def79a4a82146092bff898bd9fb202eb88131845719d353d3a34b6e4ef60c7f31675d8921d4d8e9dc9f49051da36a6588a246ae1d0d318d07be9060122e280df79771583c91ef0c241f2cfd78ce7f76097572eaf170c35428f0a1ad60d465b4dc0148235098762c13d42465fc19250dff21014bfd9c2488b6a7422d744a8a6b240d25d0b618ed034c8c5dd7f23454f9aedfd3fd862ec768a37b0328114e0086a6eb008b022ef0decbb33ce67d4ae3032d57c33858c24e2271f2ad753b75136f964bf44f37ff36acbafcb57f6797bad31a93e731fd4c092eed5b4676eba5a9c60588364eff7aeeab547c9c0ee9169625db283686ba2f0448a40569c9461eb2aadc86d3eff8096ef1407a494660c6f2926ec3c9d5fa5614620c10529664dfcfce213fe07db6d86c0543527629eb90f05151dfa9f8a640513bddefa8ebbab93e83148b0e9214102ab7f46a8a1bc45c1030581f7f3e7524e0b0a9ee217c153adaf991671483ff80a5c1adc04b3521dd9b1f56ee8278b0dc73dfe985349e9b0a9f61c664b030fb8f65bd3eb1eaafa98fadc350a463449aae04119bcd41bb5552f4b0108ca853e4aff41395e2fd10afefd9083558667b20fccf148e72360f5df157f04c9fcae7c595b637e937c5382dea54f862d264ebfa61a3c3fd1776aba153798e8245f6e22b05a1937d7b5b6bac2d856e46f05970e673ff2fd2d9f7748f2a372ca3584ebac3e66fc5ce3933ae6c7f41fe98f465baa62a8cfb29174bac28ac435f6557e78611a9048e7c5325798253345dd656e296c67d6dbce6a9de13240235b5ed70772ec4d5b490ff9ebf17153aa4a9876016ff5d83fe27994e95c6dcfd4d5f181405e4525eaefbf6816235ff461214b3438197e42333d24491cfc9dde56a11ba6e597bf7afbf5881a9e0ac163bd128740c67d01168ca687c7dfff339d75c07e808e67f3e97fc0c2440e01959760891a54ede803ec0a96c07804eeed33369adf699f98ac0c24acd741294b349c3cb689f2c1cee5b12decf7bdb75db80f989246073c1b58151f0df914c2356a1f55c2dbf8576dde135d6d56b0e74fa9c231098b6e2d4d3674dd652fe864dda7cf18fff6cbf29e58a90422d2bf0b87408c31e49e4469f2cff530a625de8f76d3c45ff9f6e4467a31c425d131aec7504039b267ebc8a78c208b40bfd603a05283dc78ff7b390ef26393ba654eb25198dc17c2ebf432b8d049e7bdb240c4966e0d12eb1dddc0338b7a235a1b2860493bd543df30ef76c5c46d6cb40c9682d85eb1eab2686d5ee6877ea4596e50edb53141b63b7d3ca64380184ef3b23a07650bcbda7a244c855b411bc0a95fad3c2507b7d13eae014147b15a033376d83a1589a57720c5ff5d80fa1a6ae8916319510e7292f2c20f01fdffe1dc0164a8503b00e4c805f8c93f871db007218304972ae5c9a1e5f9c3ed0c3e7034eabb5dfb237df6a444ab18a2b6d728a3be673d2e742b80dcaf7455d494eff362eed704c34500d938b3a69d23cb181de11c82c60b3099631996b09f0c15bae472df3bd7261d04e6106339cda85832d0d1aeb3c268010fba7d41a0bb21b47af6b58ea3699abf8d93acddd8491134335f7656d1d77fcfcea8488699c52b83a9fafa815e7447ae1c5bbaf1a73dd0c59b51c5ed6b53be8fc53b7a44f18907878d438a62e1d332b00eaae9f937a8ef80beccfb6e64b0e0f3205a10d5798701787f9d9f6c9420d0590926a8f857f59148a07d87a15fd253cd83c1248743981a059ad8c9243fd17f38b33ded466540322d5fad4f3c1e813cb3e4a705e9b12500c7213f467841b9cc6fbd6ed66486fbbfe980dd310ec8504987cd1f745de95696a7a2ea154e951a9ab5b6cf58fabd327258bdc050aa2934f5c4d42c0b797371d2fecafa87c59bc7faaad6e14e703f5e4fa30c8585226d65b4504318ee91e70dcd705aae8a9d9640db1b9574561b85670628901c5145f88cc925729f9cea79dc5babaa9f5ff61de912b453dac5614be919d54cfe14bd56a6e04aba87ab07cf5091252993307d4d85007dd304cf2d86a08eb7426b895ed010364c86016a52ba0c8c0a0da9d90fef6999061b68cba2aa5665c8cbade841ccfdf941b1ab00c1737eaf92d348908a6cb91672ec53b47da50d67bdcce7b4497c7c0f564581e08b153f8f80edd3b0dd793e9fa86074e307a6c77ac6fb48d0a5b665897f9919cbf90f7de14addfa201c641667dabd1d4ee85d8ba18288e54fce13a1c2ef26ac735bba7358183fce9c8b53ac630ba1971d833ca78163987a612009010f137ed0ec58d65e11db99abc1da23821d72ed42e90a3965f0670ca259a7cb0365925377e4d099b9eb999d22bcc22fe385ee9e2305f59011095c541d5527d66ee05ed47b06959f8b13d1d658db29c1364a8f26fc6c8b050681d49726e0d0f29452cf1f897da166a4f9018a131b73be57965c3016bdd6a54ff3852d9da392d23081d569679a499a742078b83235d45606b7cb6af06ade0139d5692fde6d837b9e6da0cb29835951472c5daa88e1c3812d44d8457f6bc8cc89f229fdd8b3b053c3f5aa22907970d69155205a56661dc8f9b560fdb6006c5b6af5f2a92488f25f8531a2b8e7f1d416db0976a5669cda4f82b4559030acceedcd53582d7f029cd2dcaa499901ef6e4cc4f46e130014cb15feedf1e6069a8409a86273e98a81ea09455f88fd5500741ae57bb7d9a11c988649d3ef6738a19e00b333d430e7bc0732793504ae688e33b4f03ea257374b20c4b4df614e3d539ee9ee4051f1dea8af1cf998f5278c00ea8200bfe31c05ef04dd5a456595b3173897c94ff870a55cd2c27c1e0ec10b24f473dd7d67eeb0d1ccc1b6b4d8787e8b9ef6d9ea7ff7bf76929a02f50910e93eb6e6d3b3fef929b54112ea66dc33c37039d9275e0e779aabc1b335f69d0b4c07974cb10e7f8e82aa25ca054e38a60425258025538a30fdf9e29364227b31ea2ef1608ce435de51322ac828ccfda4547ade294c4812166fe0ffbe2ca192029d0b03b43c83b89e991df062b09c586a0033d05798dbcbe21f54944719632eef1047c0527ced14323b7b53fd20037d8f1467fc7ad391b3f44594690c45a050169930d379b700af68a152ec3943619f0621a4d8e874a5f77c0c5dc5d1db3b087ef11451f51de3816c80e73edbf241368b7c29009cec3ad6b5d6a2e95511f038f66132f4216260b0d5788caa7dfddcbeb94095cf2047e3b8fa99b03a50c8661d7007857ba62028fe484831f2762ce98c1aae775e83d11567fd6216021491b130b1a5a45eb2314f2f6556162eb2894b4aab311eec9325c00e9f7bc08a4dd27e03ed451e7798ad96d65f7c16574f1e1a3697ad44d0102575b38d0a8befba1621d43b5e8b42bdae4bbe77265044b8eae3e7ebbfb1256ff4d4d38c01774acd6a45435735f70db8c935b7948a12cf9af22373a2cbbcc8643c3d96792c8a72ae2139636817be6f4827c1e23f7feed989ab38bbe9231a6e513a38716c55cf132b3f587443760caef3d41e58ccae294f6fb9ac1c692ab4de0538c1da61f34862767e4316b388b2d052de34d098ed72a6821f6121a02fee7453c7a8b51b737ccaaa122ab19e106d9c2ace5d8002ac539a8cb0d2b19a7cdfe5f1ce1cf30bb51fb894b6a4a00b403e7c33c5b5153765d2443e1cbaa866a2d6ea71c35078789a076241ad43fa29f160541e95bb423f25df50da4a250d8bb5306939b42974512c546890cd5950184047dbe017a17e12f142e4ead08bd7ba500a125583265838a88b32f98faf64b8c73ee75b68c5b34b86be96a22f97f304207490eeffdb68471a5928ed15cbe116cbefc60e2106a6b56e6f9ee9d8b220ed131ade6339a63508795461b4b7b28b708b0b7646439eeaac6d9b4b4f6e17d578c13889f6f189a7818be306b2dd42f9ee1204374319585527d6680375ec20571858ab3e21c97a6b1ab8a7513c57dc6817ddf629d00578c7e3f3e3d3edd60a18fd642c4bd1064aa35684c38660859914dcb05228dc65744c0bee5288b898307d21c3d5d73026c70ca71f4576087163e4716d5116bdc40521c4b2e64abaacf92d49aaf1b10f72ea301427f32fdb02d9f14c1403f37e98ad4d59092fc60ca03e4e20623adb45aa08a11d67582aba50c4cbaa75a20492f8b418b85f3e5e27faebd7268ce3e951509dc7b72b085d285bb352eea17d05e6e9ef294cd52c21da32dad9c6b89c24753fddb8bef3362b4a067082d4037d02bfbb078527f1e2cf7f0b051cfab191b9acda84565622d5d1cd09057b7d66fe07609cb869b16bc20cd510f0c9bc2556fe60ddc5fff69256ab5c645e7c515e1e74be084e8c3d2fed6f9fc5ce42035e65a2c889f5829fa92839f65be18de9466983489b28179012eac75c6f1b1eee991602e07ed38b4f05a00976f1f39589cd52b19e64cf0697068d1402e25a7ca5496c9b4b7f27143044285618400f3f2d51b0f95014eb17412d4b54427999a80111b98d3296b83fe4697973eb1ac3c0aeb6d9d930813b414a9c676fb661d5055414eed13c741eda92cfcaeff1ce2aa842254cc0aa4918f5032d7e049d16db9a68554296bff884fc1f9bc50360116230a28faccb3869961670fc2708b241e4ceaca9b02c2bf76a03b8c488992dc717ba0f0b8dd86f27b5806330f5e791a2bd4e17ee8a3931f4fc789430aedbf699fcd1c311985fc09449761aa4377ea58fc305843f5116f2101ae6a35652a48ab714301a37d57d217817a25213e1bce74836657a6190a1476be108d5036fca8888b1fc11bc41be74b879d991e523f6abde65e2711dd9138bd24141bedb909aaa0ed9940e30a024cda6596ab5ae7e867999fdae91ea5cd42f1814cbfbc205c88d9b4c275afb480a590d7f964432fee1f03fd0b5c9eaf7df152a183eff279e777953975e0db86f49f157f5b76ea36229e05c3efa1d5ccd2b3863b0e18baddc4999a685c1dbf7a44bc5931f3dfd34ad295697cdb325475dd3b23e8a60ce9174043ccbbe40e63fb3c6242d1d4716d452273cbff8c26f7ba6ae56eb35dd7a6c3bbb09ff74645f22a1eda451120ad62cccdadf0ebe8ba59c6a163a1f1b644ee94c22df96770c7f28cd41357b6e9d68bf944c6f15eafc5dc4dfcb2e4f5ac7a2f6a6031dd4bfe777d7c5853e6d4a6feaa6dc77d1642602f3726a3a19199a4a6c98cf50a7ecc528159183840bd4643ce2f003eee8211dfdc9f37631cc19be41be649ceff8720cae5168194c5e5dc32e5a5c45649f7dcc4af453fc500d65510bd1cc2bbfffb111fdd5176f7604b76d7beda611bc0be4be7f9f16fcb1ba58d46439d200bca557723bcfd84db9dc1282ecd6b509ac2a8c9ec7164c05bd5508e520e681543d3eb815ee59e23bc358e134ff3e01fe7c612c3fd7e296b28694291d0dbd111cbd93b3a9bd31d5d4352d45a6ee51c517fdea0f806157abc95dbcaefb43f982708216a9e2f927ee6959f3b5be3e818092c926890bb967c1ce043d946729473764aef63c892412bc49bad784ea8b7ca9c564edbd6b1608046f305a1bf7a625a76f13ceea505e3352306ec7505d74b1b8d8d1f1caa42ff9ff45925df9064f45da7f017e37ba2f989769fd981c2ae5a5e77b8056e2bc4316b9c42ffd1e6b6a8efd3bb253ac1a5a949954a7a7ca8bf1e832a2c51e0199c65921fb672489c17e46cf4ae35b9fb5108408b342ee6a5d2ae96d56cef0c6a6e004643acfbcdda2ba2da5860b4c17c63e11264a24ec35345eeaf1af93d302ec146ea4893f37cf198aabae23a37c8afd7105e130f53c9bbef5d4e228f9f4ae5424dc0b90dbcfac87bb8aa08c62cede08a6c999c0740ceea4bb4629b3eea89159b14a0cb77798413e127ea2f4d750ae81c486ad3a83620717b2291624a9379538153d4617678b55996ad837733e923074f2385b32e8e7f376db0df5639189903e2a175cd0dd87e4fb4ec903980f1624b4c8b0202dbb282295717c808fce0e165f66bf37589a2aab0eaa9aac446b8a2aa58cb904ba2d9957b2f0223d23d4f94cdfa0abfdf38fe59c6c1a0ca23cfee8ee1151e975561ebeecf13a5d3829dc20763f4873b1ae42073dd16637d8f2f37213202c024021975d647a71e81902001fe78a9c48da2b2bd460cc5ff865a1d301836f9bbda63e3890062594eb46f5b866aeb8bbadc4f6618bde8ceab4fcc98fa7c8475e361eec63c18b21ba14dbc38b92bdea5c08f9888622e0d28cf858cda88c8697cef840e3a54a24e3a239ff461ef55f70d7580daa78722a2ea123788fee533c13b61e22239a6a2cf5588912ec6dd9afea96ffac0843263b8eb1a92bb6d4afc0a80d68eee4779765d6dfbe44a72275fad211b7bf8e44a80527b02b39218736a1421dc952856b1cd602e1804406f0b31b1b2f4df06a5b6f6d40d56b7ea531123ca9c7d64db99a9b52f885c6decb19da4e127b4894c041b5b82ddb4645b6c8dfed789cc5fddcf1ff8b185c3bec2bc3ca256bf85e70241d759d11e71deb170f734d6a9359e9320567c5078877eb260f5d66b74df422d942025040826285731ccf57ff7e6fd207b95ede3625adf6bd3e658122709f58c64e4b5fa253363fb69375594a674484bf564c744453e4ce4dcadd84ee23958d529402da558504a902997c4f95c7bb26f02b8b28d4566e4f44d214780d1e1b1d73cf1dba1543013d04be53dc9185b85d3a4a327adccd262f9dabf66b28928bf34382724c13484474503fc979b1cb9b3ea1c38eeea7cea4a788b45ae15f2e2205e3c047b52aaea5ff6b28c8f15ed31c20f48abe251255bee0245b7616e6db5e94219326cfca9977a338583998bd7b4c1695624b4bcdc79351085d1b6d2e8fbc849ec41630d4b3f88bf665f78a7f3826591246fc062d44ba65dd04f622a52d5d6164d03ed096f78a3b7c1e15497af95074c36b5de63579759a799eb98f4cc319e0619d89c97105cb7a97a3b216fe7d1222b3cbb9b606f4d7b861af56f5a9246462e3c3fc7c5ee73e59ebd4ec977eefb7a84f4a36a129a9a60ff5b43784b3eb7c4feefb4680ebe8f35c4b7c2e1dd5b899ea0edc599c9d6b7318507feae3827d93aebfbc07077221dd678c12510453e0f2cf17843252a9db5fc426b6900f391be754db40c26c0a871e0d19c2448e5b089efb5a01289056394f8a5e713038e5643404a2a9a533bdd0931bb1b34df2e39619e4849a88a84e6b1b464d307d08c0d378f5e4a616472e7fd6b53ae953dcb2cb663353744be25c852bf106e36d4aa73a85a300918dd29412aa71f35c584b8efe04f53678268f6fb9ef6c3313f769f26f91baf71013afe81a90bc485a7cd9787c230cf7ef597c915b888025a1915bc7e0a1bb893f55f57fd64daffe222383f4f4101a829ce66148e96a15a2abcba1279d090913e93592bd93ccae8361ccc1d9a3da77e7b02d452024b8ccf7cf272a2d8ddd3929fee76b2e58a502ba201ac8fe359896bd259e40cc98b94a88f632c3fcb9726fc3d27446cf1b48534d6361cb5fa9ed7433dbd6b77c501c2f13732c648fac6649c9bcb5503e31f906d646cc60c88bb8b3ea5b71ad43bcb836e524a57e5c12ca6bbc0c420ee5d3ae6ecccb07b1247da5b63a4f3eadc6bf3f11fea0e59ded408b82c4c3f6dc754e5c1df92957946606bd9106416b366454c66846b3ee3572db3488f63e2d0e1876950cd2cf3ba988a2f1dd3b766b1658b6764ca87e0878ee935f2726f6fa7907e589dbf8547e469473f559811c772cf8d7f78bfb60f22cd8ef6be2892b3625357a3e092d388752a68252b9b927353c3c7a197407b8a0748ebe179173e984e8cc005dc5ff7486e97b5371ffa98085247936f007a1dd084e8bd2c56862f885c466bc3d3e2894d7f98a60da43da6c2a291a9d98cef9413795cdfc2b887bd0ebe8153593a00962349a712f76949f97950bda0c4e15720708ab0b8182be0a3de9a108338522985282d733b89d8dabfb509e316aeb5932b5551bed9be44109edcdc901994cf233ed7e97adcdf9a3d53c45cf533ae9508f0be4f2e94a8a5d1f312d69f1c575ab8d0e263b2b15e63a16a7feb45038f2fb01785a330aa9fe754476282fada73a4bf54df128945ed04098c6fb6db1caba5d59482480ae142ec51f62ec7a5977bd8bafaaa902bf1b6686b236d428be1428bf74ede749a28cc84ea477b96b5fd8c9b193f8e5ac223afd73ff360573224203d1432c2b6f3c4432ff70939bbceb581a136ad5d00a5b90eeef15b89348d909e405bca35403f1d27a68703dbd93a1603e805e3000d3e1d9793c5d94f7c9b1d7ed094cd5e5c1f202d30716ab15ee46be9a653c75b6a223c158891314e234862defb9a59f45c3975e9a7b4e5f7f1a1c16ff7008b392e0ed93dcf89f94df5c0e656b675caf71bf9f2fa38794e6c0c6413c7f279ed9bc1d8d01d64a69ffd3286b123e296e651a08b19bdff57f1f5eda889306796fd97eb435f37e0a6651872b2b54ffc495ffe39adeaed9d4f18fb7f8f4a38529a869fe595215027e501cc10b406ee22db6ca5bd3cabe9c991ab50c8409b77fcbe5b30bdcb301a9ae34a55ffaddb3c20d793afd1670fec4ec93a5c8a5afa039fbb182f013c77cd763d8c17754e67cc9f74bf520c1cea96ff25e86da181a70dd2a892c54cba2c0c1d832b38df80bbfc7e7131877b0e0531bea6fea5485d3b1afdc9fecb6ec32d960c575dc621af42473dbc549aeeeb81af8654dd52ecd1d4c18ba84bde82406c8d35604fa39acf08107bc9b1a3b09d3b86077297f19d46a13298d59b2b7e876884371636a1d72b650190c58b5a095cf523064364e03e8d82dd2cd2ca7e342d1073cd0b9bf84d643c27db752e4cfee0b2be909aff3b747a766647a9a01a61d03f7a8fd2e4cc1258cdeb976977e19fa0b1e228e065756508573f7a99224ef5cc0e7e90739467cce5c9580fc3815c5baf58e222189b103c6b3faf25abb984656da307c9ee917b59bbe707820a666b5ae976b41262ae14ab01b292c517177b9e345ef5825f0373a20753578da3a39771a243e37d6a0ca729c278a54106f8fabc65558cfb3fe539148d6086ccd91467074d6fa2174691472727244ba21ca0b0f6f03a728e4abe0047b66fe1ce7668f8303a97c3f5aa63a3c1beb36fa4b6731a084fd814db46a740dccf2d7dc99f56174c2d37afb6f26e3689455d904f456cce3043efa2a55f4fdb54d4ddc70fee646acafca255b2495e6d999b45f018b22e228f1be106d660f565f65364a83dce3dfe4e4b4a8b2dc8aaaf8bd1a4e2b20911e1754f59efa2b80ab06131967fc7ea5bfe474112fdb26d79cdbd67eab41b082789fb082358b93a00d9b7a42b1c50fc4ada138943b9c7a802a9695a7c8c854da838942a8debf02281fb9ab3ec39851f1a2440da6bc7a5905da138e5a8fad82a09712cd946dc2cb8fae8adbda396732ae079d10533468f4a6fab705a3ec4b3cf782e03f24bf24f3cb4d0f400791f76f6b1f3761ba523ab4ad8cf649193814e71d0e4e7a6da8b8f187015ed3021131a2a41d682592188c1a39d5b8cde818d80ca1e55379943bf4aebaf7c81013e6e1386af21f3af433a59139db10ceabc71317b5a327e5ca1c8fa0438ed97cff505fefe6aa973d7b042169944d24e7c1d83cea64beaed3f307fe75323cb5555c04ba1849784452970f790e092732bac111fbd80c915cabf8cedaaee58a4f121861e30ada311718603388597f0b98eb14377db3dd16715bda0e8d74c1eeaf8e04be93c31067bc8b10ccb73b97824b108ac74f6c4c478f886d301473c176872173da121bced236e3c0e169c49b2e44de13353325178b108929345e9bd5e8b38fa10653b64f9d12b99f53cd8770c373f45ff740ad2a5d0df9397388916aef8c3993e09719a133f351efd787bb569cca040485baca6a36d0fa602fa69c273035726ea9430fe24b9183a7726f80325115b1675c3134b8611b9b439ecd03197e8916ec48cd20b8f9f2b2bac3414f351fa42cdd96a779628f1c4d9fddb6d873effbaf9552710a9fd68fbd2fa7b166d4b7ff4e2bec3895d428dc29a7cccbac2ea4420e7f53e09ca5901d7d62957cb9c20b5664f8929bd8b5fa7a019e75c0d545c849ad4c2ac07027f37bca741dd08b379b56681825a8563ab8b9bbdc31bcad35152a7005d1c6823d8ce8be533e6ac71f0fbd849ba6081a5d84d62187937c3e4f0ed16914728a6aa37b61c5f2539b866ca9c8164cd52ec012d1db9f9d3eb4c54b0d236ca0f86ffdae55124a9968d01d9b093c9ec7a16f4a16c586e95753da4bf144b4b7fd62dec1a431cdaea26a896790370977ed74e15c35be516ac7571925dfefd8079b11ffc4d1d429cb5d32251745b6d4df84b175ece66c7104b320342b41d45c16678d402dfd6eae62834448d46d8c34d553eae190730ac96aa2ea5b37b094ac8bfab0517d3ea9782732356ca545b56dcf527471f0b47852fdb2c64b0311d8f3ca2a555659f9fae6ee59d019b4dfdc3814780ef261fd63cc3a98ee31db1af215bd2dea064aadc6a0fe3c9b0331b69d26240e9a53e8e670c4fbbfbc8fb50dd6cda7998d26c71e863945b820d59cb64ddaf71f72fcce11cbc08217efab9b7ada210d661c6d93350a59146f44057c69917a15c1e8593a4cc6ea9a9e3028d1da3a9b4164d444a06bf3ca1d20b63402acde3dfdc7823193ffeaddde749b87e3e71f21d270b931e30dc2c4b96a0d8484230f71c1e63bb82b0d30cd06ba29879d8b5f06e389810ce620fdc43cd842ee1aabd6f1fc052d67ef125a42fc339c476ab2e28ed3e664fe93bef82815a755867fd1222e39889c344cab126627c4290688e7d2d480a9c03e6a0d53cc2c52b3d3ac6ea2d7eebc817eb9a4bd9d4291d3f5f021f48347c967f41299982054067440975182ea0efa1dbbf53c719affefeab26dee31e19b87c39a9fad31008929056444d752836184eb48e8b9c646c82c59799b9dc383adf6e5200cacac0e17096bf814713feac4aeb43dc76689bec72ede400850eb704a060a3138aa4e9fa8c19e3c1bf0b26c95cf4f424f9712efde7a9e15fa1590ed3ffa8a1df9cb7e094ae77260fdbc6ad91cc344691577ad07c6cfd5f22cae052ad9a06d5c08994ff8c8639dacdb21906471fd0cbbc307ba154e04bba9ca43b54ca648470cf3fae78dc507e0d3022c0be20a962a1de7de150d35bd3d70243e312cef82fdca8933a3fc1aea9bbef4d4d9287ce9699fb6eab8334109ddf681495b489e9490db6c3a33d3cd2e3670391ca5f6e70ca64040d8582b2d0e0d2260774da24b3feba56b72814531c541d2534e5360c63c98e0dd69f9d8a782c9aafeb4df3b528bab563f00ff44d5efef34542ec0f50ec73882e84b0f9b6d7e520b8e381ae2543f64934e9d117a8768f2f9b703b8ecb4b0ae519aba7a73d6fa82878e7546b2458dd6d8284e78cb49e1c148b562ad7a13befa193945bc95cb7c851f40c1f0d682ffdaf358c9ea4635ce6366b9471dc9770c0a780cc36de5ba4f5c15a0c6ac06f2f29ec171b8de48e905f02b15851d8687ebdb59c47a894f20ddcae274e3d9ff5fca53e8f62969a3c454c979c5ec26f4781e012b45355d23a3ac94f919adf46144b060c41c0199ea132b3709eed254d9713ed37b217553fc0c9dc00c661f6189e020f9f1ebd1211c4153a752d59e896a2500919ca99427e670b125d5002f3f966abcd267597d4f2438ac80e856dc9d66474bfcbf9862057a77e54ae6fe85da2020d2c902f6eb35d41185c5b4fe2780f62949cb650863f25d47ddc1823570ce0eae7f4a2bb9b5d87bd79bf291d51c8ea729385b749ba4282e7f83476bd7d736a10b7f83b0281a1c090c414005bcecd9554683e8d0ef9e1a51335ef8c2c01a7ddb4f38e2b242241838783974832922616a050274d33451ff71bde001c2ed7dac9277fb914840561a3d05ed1dfa270968cdf39ef0c9ae8d41c232e196a4c565c394ae4691840dc452c2befed2a5f7216ed46104b3281bdd112ae6412ec096a1c1aea667923dc8e3ad4acae8027b91f3d0b19b1c53f38f3b1c4199201067799ece696c01bde32cb9b589f61f018a7d7819a10ded74456e3e3130098c87aecc30fd804a1ca3aa7ae34742e41af22936da4b780370ee6dcdf568d7ba93bae361ba62c9bc924db7258cc3c7793dfae4e6ebb884110ef16dace1fafefb252eb83a080009d45e58b94de4508001be7387afb5c54017abaa9a794844e861296128bc00997b3fd12a4a14ad37454ef7ea53bf5ccff6c3839cdaf6acca56e2718772e22d1f5fde1f93cd9d757cf7e739ecd5754d47afeef853c79a7d4cb895681880f828ae75c3800396710dd223e7c09e99ba507394c4c2dfcb490e12bab6d6cc210e67cd3d51cfaab0fc88a3268ace12d14231c97d1ebfa3cc3fe1bc62940b427f3ffa80e3d7a0995dab3bc5ef2de8f1c8e3274353493ed8fedaa8fe2ded21ef930525219ecd2522e3bdb09d0cecfcf71461d294e852d525844f8d6bc18c3dd60aa17afa00df7969e2bbbd238fd3e56cb199fb9d2ec2bf30f0dfdc9fda921572d23335ca4a02374505c43d00c9301eb1ee2356c2026688acd1f13d31a141db17e5a4f48b2ef407aace32cd7b93440b773f8276ae120818f4c50e8266190c2ac85c4e3272a99d287f30797e5024870163bda4286cc8c4b9e836e9994dd93acdf31166f00f0c3bc1557cbbd5070d7bf5ba04a8aced3d0885b6c3c2b67cdc8f69953299596eda611717d52fd337153451028f0bc47bf2f3f7a25a19b37ade88487f92cdb7dea4f3da7cb9a13e9e6f5dc30501b789224ddb9054036b41256f82560970342ca6c7374705bece40be0c4efacc6f4aecb4e4b0612d9960ead94e8b54350107a645fe98a81bd47d48e5d0eb645667af220f5e581a934ca74676772e116a1171b152999b2f663369dc465452d39370888ace6ae18bf85cfea77a0d09562e382281535f12cbea159ebfd08b874e9e36ce0cf9e7a90685c3c3f333e095121a09ba143570405333f06a8f45fc4c73aeabf2d6e951af2905ed2e046c61799aead82dd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
