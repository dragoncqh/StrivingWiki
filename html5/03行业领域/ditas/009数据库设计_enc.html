<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f0fb6f5cd8a23d9b13cf45610059a722cfb0520ec98d82e004203ea9f43d5d0a2090f40fdb9b7b2d831335275ed539d15bfef0e3564fc4d802b5a7d1cbea5c89ce027516d6a3cf41fcb84c802153cab12109f162cc0bcd57ecc0f66c43e57a25d18b42a4caa6187d49d847c1c7befda072cd3810215942b637f933d01cefb44de9604110a4fa9018a833f256fd8ea81b2896803aab6536468e8c622fde89b41d44e5806a198420c04d639196dd6109a2eb94c24f85ed20105a33725c080730c44216bbcac60f48b03003b1a4c5f65b427fd621578a6cb40f0bf66e78a0df618efdc0957c16909474c56e8f477df168bb35ae5fb013a230df73b01f3d0d7c0e18a448bad305c857a5afadfcaffafd36a99ebc9df34cc681ff6221a398d8303b6763b77de85461aff4dcd73ac56fa4a6bf75dcf841eed4a17694a71d5d59da1ce6e61256b9f180d55356c25e2cc1311500b1307bdac21207fd3d12a4084dbcd15207618c1537eb1f674aa73cdd9b6195ec2524e64fd0e02c5afedd7e07bcda8d2fdf0c2ab2aa9fc53da2271c3ad46900f00cbf349b77a4f0c6defb92cb64a99966c4dd96fbb6f129cef294371d0baa8ac72c9761860df29a08aba21034e3385871a6585f1440e4703a110acd5e9e2f71f69a31c90db584cb97f5fc40824a5495dac93a10cfb9d238f44529273e0eb6f7b72d6bc9e556047b7c3e938d5459f2b455aa659d7e147e64b31b7576a00b8eae3e029f4cf8f5a629bb8a03628d45e81a036ee3a2d6d39541a591864eb4a5e1a3f579787793699613b55937db1e807ffd2d4a5f9ffab9ed0c88c46d331d560e9fa72b86d0bbcee37bbad150db63df4195a4777e4fe0a64b03f2e114d3e9eaeb52450925de8d83650d041aa275e6a503bc2e0d213054226cd03843ae904c0a48374f14eef8e71220963d22f48f68423b68e78d386f73aa4521f228844f6e4036cd25573c9295997d4176c9b135eaf14fef254bfb9b81fc04dec30348eb0caa36c05a56944ed18a0570bc58e535b01cde65632dce10142fe8c0cbcb66fa19c041c5bed752569dcce764bd9d915c704c04591a7b904796b9ba5be5ad9952f0673c51a2eabcc0feb52f9dbcb968fc978bc5aac0dd607db6798f3882172f00bf40305a08a6115e7916c5b62816c16ae8c5872674ef263ec754ad8f886d9d26bbefb9ebfb8a6cb89366853536df130aebe6493a5dcd4fb6ad3037c2e04d5703c22525b9749c173236a75d1e09412c7ceb48e9999f9045417d1537177b5ff0c5e08d0a62e5269587459f04fac792f4f09e3234b46daa67130ea01f3706513ee35d70cc444368e840b21d99f45f6e03892728ece4e48cddff5b5f8540dffb16f17b314bf7d6323745db09387a010dbc573b7885bfc2e0aa0481d27a9ed3a0a712e7a069b187a89fa4ecb608f06e60291856a4073e1127d53a9239d247b0793e1e325d9f4ca048a9007adb81a6491ba5629915171da1190f7a6f0bf4482d08ab3f0b0c4cf57305f500339b11b048b0b45fb8b61aee43cc54d961366900a11416dcf12248abb4ccd8729dba210199d38cee713c9401791c39d5a6ad5f1c5f729839314863d7b1e61d78f7bed2d156bad8bdfc5abd82daeaffb6a42d9ae0187d64b0022dcb44a016d1bedc10ced67178610a3e90d82ee69d04503dce2b0aee015c606610a066ce644cf9db800260ddf7d433d6b7980ad9fab10a228edb063adf6a7eaa148a8dc9ba3cc1fc3522a802179a7daeb4adf60f846167971bf31ee3e8e628ad4cf518c11b879df7360a2a0ce11ffc2d26376bf3d4855d2e12fabd991cd531714020e2b4586ba40b72ae1af607d1ea44b79005bb445c41783d118028ae037424183c80ea74d248738bbfcac388ce2b615d09dbd07aaaf0998b3e44626d58f77dcc335b1ffd5905e4dc60b7a8d3a3027182d14df93e67e82196259d96f00597d768349850cea2fa784ee9b745dad111dda43dbe977f99f82e56dd121e466afe2eb245b7514d84799d34f8687e660f8f1f686ddba1699b1392abaa4f86176347c73a9e2b2c8a78b880a512107800de5110201a42a83eb58248ad5553dae682911ba3b873f4db8fcb100a5a25bf3e9c705999152453c30023cc413a43f31fce4ac10de949d7c06864132a75004ff99827a6142921d061b6cd9644c28cbca7fe25dce61edc767e1b4d1166e691f5d6c35269826020b0809fc2fc874823f389e8d08a2c9c5e94026497b90f9c2958fbebadb0574f4170c26d31db6f89b7b1b1c940c6c0b38b4a0e859cd023d5cb0ce0701599689815f87daf3e1593ed976dfdf07c3adae65b956a72226cd3c4e571993b509303e07eee7fdd0c86bb73c19793528d863f5e19125c612dd97f676aa4f01271dbf9b5ff37f855464695097bf3d9512175945ed72ceb00bdf40ccb1bad1ffd6e402ed0af8d0edf516482704fef6756363594994c801eaf375382fe3d399e39b0b27c0f153539cd92d7ff61228a27d37822c44b387f3c1ba93dfcc08d06427f0db18eb15e8e5ad42d38d8f7874f945af1bb2f8403dcf67436df27f51d72f699e0d9ba3879c5c9f5ac885c012c8d5b198243d5f183b939eb85888e65d33d7bd79b70459f16b7312379a0b54ee252dceeaa957f53af558ecbd5771338f5a5aea17ba6b78b1a6b6f998e2f4ad2b90d8229ecb4af91299d2efdb9ae0a9a368a0e32fda20cae7f9881cc4ce27f4747fac18e7affea05f7f426e04aad784db9eeda0237d08d04c986b62272892d8344f25582462f23bdad8c15634741b8485f3373224463b77421b29053cccec90d1aba5b5e1c94251c25e89fdf0e0b1daf0e949948c9d01ad41150772c329b633cf929b5238d81235656ef477a66a4303be546a6f9ae768b6873a5d59b7ced25722d5ffb7291c361e02b96e44d7df1782de3887509377dcb0cdddf6279efb94de897d41b2aba88a3ac6e1b7fa5264e6ae56a454ee043194b323e1fa0189672ee33bb2aa39bfbb8aec073c0ce2e1bd2b75386d3c8c7307665bb0228df06079960757f4bd91c835ea42dc336faf16ea30f078bf0380a7bb9cd591ab4c630ba72710eba0f1eab2ee6259b9dd8bf3bc4cef99b8584d62327d957c824ef210a81c4a9a4fb9ff4b6d5062bac10858035db1c35eb822902cb1ceea6676cea97842c9cd91a8e10562e4d127e931ab36733199c4e5a30bfa97ba65b76dc1afb1a05f986b6e09e79da79a85a23667e240cf152b93da455a792d23fd9d665ce522b2bbe46aedf2981ce6adf80cb25a202deee8d6506d3ff281f09e0590aa0adc46856c949e0ab962ffbf133d200fb543fcc3cf9e5bbad5f7488c691057be953b10df75ed7d3eff04e62e8d87aeb2d98cab03bd50fcb6eb9fcc2300413c20c6120c04516e8d900be21f52ef63174916dc14c14f93dfaa89a6391aac00c4dc0d7a96059310b8ff6a8e149fa07c1d699e0a227a8bb3bc3f4e834f7a848f259b968dd6b6ef61c32d232dba3227eecf263fe35a0ab9a6f5e6d69ec3a1f61a3dd701c8030336cb42e664e3970876f6d38dc2f541a5cc3741b34d3d0ac8ec20c152304da250a8899050cb0d0ef95b98182461d570d8a0929bd30a16bd7afdda01e4fb6230bc91b099f7cf22ddd9063d303fa2c22c49b8316161791d1272616b60498412ac8481cb0e5f88dc43c40764b7fce226e086b69da8f790b9eefc3b6ac224c7c2826bdb7188cb95b904f0098d2868bcd8900c10b5a765615cf742ed26c469fe2303d16775de0286756fae58e6e7d73372dec68d431f1f9eed4873a651f7399c1210378cc1951e68296f0825401199d94a62b683ab46d06251c1fe1bee3b5e0e4c7bb014264d60b43a09b4e1fcbb0b7b31f43b56dc8c0a16d3dede528a9d4eb0272e300a4fb30a88bdb3a88cc3cfa0811dd8343820173f5b9bb63660776bfb45b4f674229be69bb481b8a8e04e688b1b7e725e15ad3e80227545b3fecfc61b39c724f45e4a2a2e67ad6892def1a9639847ef95d583c913e3e5401a03c65406bdd8a7621a9a9cc184be189e30e0ad9ffc0f48969afcefced41ff43762b4e028a3dde5639e14b0b4d0cc01ba18676c6a2444f1c5bef4ee6878c32c082a946f188424da4f761d41ba555e6e58c870d92382d065a7e48e8496ff3c75228c61346d6665e46a85cf69ef99c3f324ecd0f05bc025c9bb2b6ff7f332176cad9ca33fb31212706c51c339110b9c00f8b5553c9faa8ce59154a2da60c6df36d445e001d4ac4c86b69af7e897234279979c08425c364ce59870a327fe6c88bfaf023806874c536db0bf0e670d9be697592e31963797c86f77d69c3cda2ded9e9701b3c7190e2052f3105c43d51afc102b17c09f1e21699f99354682cbea4b609a03ee13ee74b72c59e2e23304acf550aff09c251d3420310404f08cf08fb8fe2e379c6d150a3d17a72d81b87c881c5d47a17eeaa8e6db55f78bbf1308f8b56613d64395853a56cf432a54fe5110d9476821cd0cb42d9d66815452b7bab95a6982ef06708fc5e3be757667646488ee91d0226155e42c7e048573f159bbab3f28d5e0177b2ef43910ef490bb6cf7eb345b5e373075efd8d250831c7cca9395d073551cbf12fb4187f63f7fb59d1d203128324fb9a7af00fc07fb34af4be9dc2c0512a31026fc05cfba8bf825fbf314ad75202451fcc220efd66ad90766a24963f014837a335974d04f2c6decdcc15ea95a097a31834ab01d047674a3069e5e9af8a9cf631654a16548bd7c0e458a504391bd52a3f6b70b952dc5a13af7d1f013c377a905803ffc2b6a93f62857656d889fcef21889cd379676c28963bc90196bc19e4e4786f279d60ef79be780e03f79b5a8ee7f9a2d14be3ea05df1fdef8e8dca0fdf2a9d5c00c73ccf51aa6b21289c25df6b560ca43cea86642b8f9f4bb6083e45ad2a09d2cb263b1024313d037056c3a3ff3bfb9c3355810232232359e1b407447aafca32fc8709d9e7f2b2fac9899241fef1a7b267b230c78878ac39f446f4d8e138805c02af5e6d1d098e6ce3019d0d4f21eab3367c8519f09915e0d9eb8fedc7700aaab1d6fd58948609c52622c082f901e6a3fc61440cb2d7292726ef4a560a23a98f3105df874d86f31a99964cae9c8ff84df54500b82135b66ee3fdd048c41a8c5db5d81b6cf760e32925dbc1d5328a85ed9836d65954e5b2aeb5b3b07ccfbd74562538e19c77287df8dc0814ac2fedd4e79471450bb0ed97e5ac83f0578d8e1f9935f2b07ad31206c95da9bdf1d0e13b305f2a3ef8090844ce53419510ca68d0682d6efe82070796127686d465cbaee260ed82f90fb04b56db9d48955cf2778ecebbd10164d3a0d7bea916ea9c03f1d84d06126e153e2746b2ffe6b7e84b8337c39b4ac04e50cb6b22346596e85e13284e4d2403c273a5d979ff852e286fbb7475c3e04ce1053f44b56c8172a0f373af9691ef1dde73fef16a5f6b685fee135b326352251149a690742803da5d09f5cb0989dcc4144fce004caa0648a9b4599a76266923f962c2ec4038dbebd2cf3ad93af5fd88ac585ede8657cb78242bb04c0a67ac85033c4388a226692aafaf738089e89a3ac8949d71f812e256c2f2ce63a2b976c68b830ccfcd28f1491a7486f79131833c6a5804ea7e6d644233345811ff2d0311323a5ac1d8e4b77e9c707dd4e1f64ab46cbba56dbe2896987a204e84097a0ceba51e138007b6014c8e4fd8aa2b46e50fcb0674233072650296779236a16553d86fdde10669a201e6cc86c730e62301702c60e679342347995ab10bd22f51214f6ee00f4d63b3bb56581d0026557c8371dacaba2550f33e152e0f16619a24ba4e18d1d9ea3ded2ce8da845ae4c926095dd92eb55a9e98a7909d055783348a4fc4bd2007a8e2844d79346960c0012052c735f7e62a5fd3d18aaa94af23387258122ea1d582b7c77111b236e661a3aeb6640e4f327b79d93a835769c9f4d090a75e1c78a7113fe84e8718e8645194e8addcd1bb31174bd892c5ab8e373cf994bb4a274753122cf1304def149875a1d70c7b6b043b7d409a8b1c4d4435529d635fcbe839da28ce33cbc6e824043ed1effccc2e09127fae787ef74f9c1872a94a00b9406598d1c8a3d902672b5c9fc86e5b61a595e8ca1081301936986d4cdf701352f09a55c317de96c01a0dc0cc65d54ed29da5fce10ab9953a8133b8334e5c19bae0fc17f3d02b8e9d7e7f02a32a72fc1f3a5e279f5fe2f3f97a7785e620f244c184615cb5b7995e33cdf689919c71f06aa6228b14ebe40c2b068e52a3844e6f13b58991522aabec7ff61acd4570624c8bbb80bc32b8a5fba2abe746734ac372b48b2849bb7d9463f2905ae5291ce21ac05720276231d6149875c0ac286afc4d938e7d45bc5e32af83fbab1f7e391f26ea52c901508c69118082e24199fc01378f1ab36cf78209fe047eb58f18bd6b627f9ae73bbeafb6add43967be944fcecad5c32dd6123f12feb1539704e746177655aa367cb1b85198b350511ddac87687da66c95b463b495975765530b489f148ba0452cf799db6dde320549986aea39dde26e457e3b126dce00ccc8ead2d00b838b0fc5bbeb6f8119f4ed1016ee6ca7eb17121c6e8c8cae1b867d8a8b771e48fe8a4dac5f0a1b7e819903684e109bd67e878a5f00872e77186231ae97cee6fc5b429006a0978ddcc26663466ec91a6d29f60f3eb33bc7a5aa6c0c97d209e67c2f1a91f625aa3df620f29dd699b0694128f057be35ae66c707d6b40c5f736baee162a7b8aec6be5e5977b3c448614b5ff2a112a2b34075952739fccec11de54daccd726aa52c73f39e110baa6a84b3d47169d0e376cf64dea1356bd04d9af64962e0af8047aa7790432fa0b7d9c6353b0fddb16a61607c4e2e9c16e4543efe42e829e92f7dcd0fc514c948a6e33d9a7c974bdf4d44247f37b83bf756fa1b8fad481dc43b20c8752f32fc0cd07c9489a464bc12b52da9143ed2d0ae569f26e4daf21176b61cb431ad51245211b212a19abd8c92b2e982db20bd224df6af39ecefb6d2a24214732178b486d58df508170768684c5f16d0bea78b97eb0a783902e00af4819bb02b2d72a68fbd9e4cf2de98a394074871a596a7bc3084cbb07f872745171e8ee933b656fff1ecccb3158ae1bd3259c4fe515decabe0257ccb0494d28a94dcef6cbdeb16372d56ded11dff473edea69f53d4bc794545478e6393055aa7eba9529697d5f98472cde8265d8186a9dbf738ceca9596e7c94e64f1d2869d8e9f6eabc0cebf6377b75a0cf42ff89f08cfb6d38ac91ff933f98ef84050c48ef583325c99dfbadaf250da09e64c3498104dfbfc3ce81b3569a4b72338a1df3a1a30b97d8ddaec16e476f7fff8a1fb2c07f06ac534ed566de1da21772276ce9ce4e41e6f48964b8f82f98aa07d5f41d6f1f9170a4d3370fd3e4a967e4a2f386dd59da2d7ef82a2f4ab5dd7b2ea67329157ed21e912cfd181bd40c16f4e63a0fe41537bd0c56f0b9cdec8c9733173ff2789d12bae918f973981fee434cbbe9da22e53b04e4723d62c4c62ac029db1536be62c2f665d9c08b370c539fbf093510938246fc7a4b396030b480bcc40555d182a2ac6018715ec97bbb95fedb5a1cdeffc161e2f7699423efb80b9fde4c3950eb5e21b53feb61993bcc91bd3a2b4ff736df0232825f3047dd53e6b38138df1ba2d73c8ee445fb1fa5fe79ca06b9313fd080cc783786ff080a361db1ef1b701a089c0697bbf803c44f0e007bbc0db8cdd6e049e20a40dbe4d1c5b8a15383f2c6e6eb8530030cfd510ba1e98048678d4ac9994f0567900047a1567d646fdd01e02abb827ec016af8ff00775ae7909cf3a624ac0e6cefe3bc15273f76f6b750c7ffcb2e139a13f5980fe2fd5d42b9269755b8c288128a2bfd739202a4b0d8b025d79946f976242f48f05442257091cd19602f9f7d1ddbbd2dd94f7e57a4a6f948aebb32e623860fad51f7c75dd4aece6f33442a07d2132cc1d9677ab7b14bbd7a72eda058944a5e8e67b867e44de72db1af80ccc84926483e7c647560571138243d1034480d3cfbfd1909407ecda9e4683acd1763066b8a9ac07e8d857e882ffb63bf2d2ee0e08fa3355f600cc92b8ff5c5766e6fadd8aa20da762440a7e0c2bfde5ab4facb9859adee49b43864d94eed2b436cdb841fd1926194054de82d7fbfe61865efb8f4aba029459cf3c5416a89f793d8088660f6793fd37549fe7979ee9c580143813d8747b5f5569a90a8d180c44ac9601314328958f522a3575e229a8dc4276b9502ba7de690de406c2403fbe9fd72a99b9508d2eac8f0c8b20a548345b8a30cb061d3b33af7136383e271b44d7286033f9cc28419bccaf6b59604d0ffd8a8b01c3a8a6a387206e0af269d6e7b3b27e7eb21e77d08bb66a6b1a5eefc8ce320ebd935c1638205e3845e0143fd0e28905dfa6bb18d416c48f681ce3a52bc98b030fa4ea85c01ffbad417b4b0f46ef3d84bd2f0f4f3804da52ba44b852b9d8e7413198ea1497fa0d7fbee714628ae47c3de49870e109bd3e95cbcc968b6c8776ae7e989a2c3824e1a4bba7d4be9f1ebc4236f609bb016eef4a3d049f60bc996c4d5aecdfe06bbadc01814b5eee31dfe349e8bac645ec8672a62927677bd348982a208a1fcfa485b57735fb207cc8079c641c567fd1ac41c576317780e6f6ad10d1b798b079a6fc27caa793f9ed320499c8335714dfdeb4a06af1ac2028c99d1ed37bde37ac272cdbf42f8aba7e664ea4e19caa7e760263bc7bea3890ee8de7c61b9376e67407bf483ea7b20f5ff56f0318d91d39bf5216d653ff572fbd8199cd87ebf8bc5175a3502b6bb1d79ace1fb1625e03dc4597a3b2fc018c933f901ed3dd2b139812d396915e377c575ad4cab1d1d1a7966deb6a262fdd55569602df07647f40531347242ac076fa7cc32515a45eb8aede120753ae94c64e2caecf692f0245414c5e9281ab026bab9d1cbc6305fdfd40de79537055bb7329193d8b3c99952979c7303f2b01fc1a31096810b0d23856fe8f7dc3731e8153a88d2b1433b0cac32daaad169cf8b983640eae7866461d79dd363713add0516c84ae2be999e6723dd85a12c24973043431d894593f9439ab42eb67ba1d99b839d4dece3be3879aaa962b7365aa5e69816f79458ae515bbc12a9ebe3451e9ef7cb18da04a1ed62dee58d148cff1258c78a10c29aa5d4d2efb96c3532c38fa791f36187f105373a7416c3887c7db5cebde3944ff346bf3f015b8083830ffd998cdf9139e53c01bc07ccab17439cfc8490c3527f86f361c8461f30c43b838cf36bd43861291fd0360db0a531b1a2d6bd26059f46a2344931a47a77e60000542465326672d8581e0c2e82030eb9568d014e1d03dbdb53ebbd3209390b7af11db296d2d7bdc3c0dd20a5bd724f8c868718d4d2637d6d8978920f8cbda277686bc83286f864c619a8308f8dc743cda41ae1159c0101c5254e8a9f6d9f74ef11474f4462748c06dae35d74be822aa5a7aa923ef10a2a7531fb49007a8acb8398525e65fdfd2dd077fc05750af3878f7a653e5d0e0a796095faca9b9b617b9b5e72cd285c14844bc6bd2d74f9cc36e7f8d8401ee0ed77a0e0ab1f1639a7adca23a9e967f5ddc33f9a7eef65a1ccf950d743c3e2e47a8a4a423f061d36706f57713bf217089c53f26ad0d2b0c6f894aa37b17d43162d767e73961218c674afb9d9b27b2e9777f3d7362735dabd03cf97892c1efcf1ff59d2ff276445c075e3e93731ca0cc2229fed416cee69c0e4ff115e0eda57225fea28e129a23877dafd47f0b8a942ee38be1625edd6730fb40a68d3648de49c3c89a714a8637ac79dafdb6255cc83b4ce85a439ae18e155de2928fe35d3b89464eb12558288334e8c66108144c9c8236adcf2733fd6ba88264e33ca6cf1c1c56cbeb4de4ef42560096e1e88854fcd1c16f6216874d73f648e1d631fb20585a6e34bfc9009a8509c207b431350a0876c8f574caefd9607ed9780042bfba8f4d1115705278508a696e9f86c9a4667f80f77ec96118b523930984ffa22431194522aadb4828092bddfeff8269f7c0c33ae0c0cd7f184e0fd465d16e3e73ca8ca4e10adeafa462e5764db22402f38579094b529c67a619a82e16b226a558bc6f2ca4263822184e02d488f6fdb246306f922e1a80c865226f74fb120f6687e5b506079537131113ff33fcf09b65908cfd1fd31a973b917f964a616ba7c6fe9db26784ead18be031e28b4802f29893d1ffef52530594afc45df5579616bde886eb1d223cf6d067dfe20771cebe7cbe1cae819b5d743730d6edb70f0a9820934008d707b84c29c4ceecdc3ee34a05aa95b271df0752a67d11976d8328b5b284623ad886bb882da1066c9ad675104aedf96b60227909d6a9aabb2f8a1b5336ba499e1588d55f324009498db1892aa93e98071ee8bc36eb52f52a81b37a454af8a6d489d559fbcba862e0d93870f92168465d5d8e70d2ee0967eef8a4ba18e2736fe1a5eee5f4b11db6b77c0bcf9ab0dd9968d6b7e50442896567703a468cd96cd472ca0fd58cba0e22c7c813ecb6efea1267036e6b7db4445bfebf2c657ee12a1b757ae38e1ee62eda02e2d8549308a09c049d01315a6225348c0281b8aee564459f3fd99be2ee31bd0239900393b1e55bdd9a70c43436eb454dc9ac9d54486a8eb82fd6970bc56c88c4c910879784f25540fe0fde42b81a397ffb51f26617f2cb7ed300fb9ea6d2040aab57653705c0960891cb567e78699390d8e3b5ff1a2ad56b19ce733a0f15bfc1b71ce1b88dba7a4e452ce704aa13fcb753c3cc8418f12d15bf10798e07fde0f076f112ce23b878319848bcd83cb615eea328deeae64c99f1d5ba7d05ae5f9ff831d5a8f1b07fa7412f58f479a192eea97f54984422e62263830a74ef508c159386c19c293741c256223db66c0385fd00a95b9a3f778f4534c895694e2a709f5cf68def369732dfbfa513b1efed9563c3d6a001571bca39ae685a87ab1f51be4675eeaeda534e7d9756bee8e059f0a894ede9d86ccf8b49607def7821d40ce47fc8d7eb2d14406873015ce7a811c351ed546728e516219e2b48bf5251ab76770c7c3024601440359205222f0aab7ee7cd60aa6cbfbe9ef492995db9818b38ae7a01bb692553a58e3f536ebd8bde37624916de672ea7fef2bd95a4d6028b7900038c26ae1677659cf1b577acad0b7450827cf6b9532fb4814b75312719b8efa8ef79a4f9a6f90409778d8bac2072e76bf1b66c9fb883a6bee1dbfae104a42b7d68cca63dd04da1faa9102f48182c93717a5f06d906674e696083083c0146be2dec7b0280537d1e519feeb870ad7240b5f012b1e922103d10b04ef34c3de0200eec4416b0e6318f0ef88ab21e4f487309f891d47ebc67a186b8bf805375b431f415758ad1fcd8d5bd2f45df1b42452fe4c2ba1be4e017f838d03e2f5cfd62f949f68e12bba24308aa8d5633a7f7df5b8c61c4c1c3b949f38bfa5bad86bb803fc8400a20bc083cb77265f83005e30b3e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
