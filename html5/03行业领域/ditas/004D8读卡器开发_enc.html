<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"70f163c71cfe8b1bd60d591b6981c6ef8ec4c623c433bdfe8593f391f517633354c46ae11f5011afae5424c70c4bd87e94ffe5af4c0ad8c21139517905bc7a5ddc69499a1c0f305eac009df966f44dde3219fd3c94296b412e9fba59e25ac8478853429dd3e9c4d2890a419663d1159e6d289e759a77f3800beb25ccfc8da78349bea57d7361ee2bee2b1c9b6e3cb70c942c724d498b007642d8e91a82ca96b05b80a875191fb530927d548869ddb10f1779c45c2b052db5adce9409f9dd000018b482dabd457c47686ba5d3469014559f9486f5f149f0285dc19f0d125a9bc5eb8b10261c3c297ac5f3cf143dadfab04f218b548fdbfa0283d70e6db29e66dae67b77f0f94c823fcec972f3e928a82b0cb90b85f5cf4bd9896e9a319d2bc328e58976c9e7fdbaed2ead6bf44368311c0ee150d7ad5a6e9ed36fe1f16e90ab9f73f51cd1e4ffa90a6f6524c315b5fcec7380fd5fdc7d7e43aa0135dbd01f5260e0a12c53f121d8c98602f636a4e88de6d8b7ca93dd163ed9d202e48baf3aaf7126683e7c6f3842f36e374908a2bdc38f7b7fb4ad88ec13a5a0b3b3eba8f0d54848e1c52dfe5b02af64e6bc2f5e10fe09458fa40d4047eeabc0f18b9420f0a9bde909c762bdf96141b88f993929325dfc1c6e0d16f96c33d9a55b30bcd4c50370657b8bda25836e24cc0200f50129a9da6807f742237caf1bd970b1a947e363041f1d477146759398bcdf3a6d25c2af6103200c3977df6a34a0c972ac73b8a8048c2988bd23a79b887c2bf6244f43171506fe803dd1d4a43350ed2a05d57234a7f4e19d61c4775321376c3970ad6a8178beed1524ecb6e64fb70af6d3fe5eedefd74c255d3bc3c4074a659edb1d05aa17ea29c285d338d87c3538ae4211a57d7d5ad631c8d14f57708106f790cf5de80a4665179d884f3b32f7cce0c2f46079c460022a1fdc6f510eb78b518ca385407d4fd21a982c5b02aed0f7bc847eea69d9979bb73c225031583b48fd372f921b864b1ff46a0cc85d66e56739665822f9f14486e6e75e52b86d160fcccab36007ac9ea0a159366f1ad9a611ac306b4c316594d636f39ee73131a26bd87fc3ba1cfb5576930b9e9a1b940eeb2e3e79305cd34c69223c5289ecd3201a6e8c83b5dae550b898a052581938f2edebf130c354906a2eb83e117d49a8ebe689af95b2804c3e2c3ae5f3d28fdea82aec1a9721b49a483ce0a31990c5882e342707ae3557c1ce74e7ec58492bf933842e6dbd0b8199356d2fb6aaa62c47040e98c7ef876df9cad5ac887e7de5ebcea29b8b9b9e0f173d8f217af56c9d41761e445bfb9a4424ca41f55b57a356bc8b6a02ea7da3069dace03806b8e3815764ea51ddbf1fa600cdeca5c6f1f0a39e33e457749cb1e989076dda56fc260845cb9ca2693995c40541ef3e5b714f93ca78b6c6377c115b4fffde8a355d13eebbd1da4802489ad393281d818cbcd61814f56bb9fb40a6fa501682a795110e46b680c1b3c9711ac0ad0421a16ce558d42ab516037a1c53cfe04ca1b8a44f421ee0d2aed96aac5a5b8b9f136f29230a501834e0e973d47b8359540763a798d5bf5af2e0b381526e546dc8e066b332c0382ab93818c59912e7dce37167a1837540a1cbb280aa6b97fe857fa93a76c308b474fc97a28de895fe09576515e1ad13a854f6a70cbd455a52e546aca8170fbd3466d879ea99160f8fc9d3bcd696eca415e7574b08402fa01fe09622a756a57c1b2909f2e228a0d51417397fb54f7bd2d65e8f5ee94d171238c32bd2e0a9e378cdad44bac8be3a4d2597e0ec7e98ce5bb52979b1d2f21d8eac9385847dc24359a0c69c22501db1166ffb61f5d83b58875db898cc6add8779f7f8857cb4b95ff17e13cc4e91286a574c5bb86aeca23a2995bb7f474754a5406e3ff4a2a40d385736a788279fd78ea3fd2bda0e31db01983e61abf6f4cf7a095c1669f31e772941c3cdbbc433a993acaac9141cc027162150a8b1e35eb666df02c0969cddbbc699e9bb9bd216d65fa133491b0c895705c382b20668a7e7fa9b018761f18a5d582851c7c11f87c3c682035d1c3be6f3db462943017a146aebac926cb64a28c77a72381d2de9fb0c2b882a2dc91701116beeecccdfd1b8c62c3b88942560619ce84f35f7afd2b01489fbb445e25c8d14ac79c03394b4598d0c0f80ab660409d6d8171271c32853edbee1584dc8a1625356e76c48a31c1b276b61db8cb993a6e2ee5a20a358c613e9d60f830f747387b888e702bcc92fb5a661bde3f42526961ee4998de004a88ed4a7ee7d98a514e53293d9d8204324b918dec72c0869a4cf5ff6bfe255c6476615427b6945853faa146f73ce07de2b5b4fae29947aa5104671f6957501dc16c4349d230cf29b0aa687e982bd8802f34af51d8ac887edd19b406ae34444f8231f183fb1d350cd381c86486e95d14c7fb8e6e9551882042599c3e944aaf2e1e7c487bc8458d645ffc10692ad149875f1682b5497394c69456a623ea5fe5cd7bf790ab0918270f84d389f861a0e56e2a9ca498fc93d6882d2c3e53325d936a230b76ab0f00d80d36675a7c13e36500a5bc1e8347882318777f6bb3b6cb6836d6bfc3da87c510dd00e4b722d21a1864839344adc53f8ee59dfc307f9ae884dffa738d9b4bb7d02f4d9709fcca23b10cedb653eff2228f119efaafb5d74403ab36fc74bd8faedf264956ffa763014f78f0dcdba0ecf18ded5a0d564e515c1c4758dd4e54b1a77dbd0dc50e53c0128388801ff84db3c5ee43aea8c68903aef0df4d68312e3fdf3d1b04bec000bef45a729faab67af14c9405086ba8784cf8d529fa655354d73bae941db7674b60208409a535757dca0762a3fb3a93186be7832c9d2e501548ad7d484e64f0baa8a26438c8831421624fa50660b4dba45f3aba93e5b0fa52717973a3c9ad57d31edcace9c1b10af7f1087c1048717372088caa60dfa0b614f06baefc7ea51ad17a808a130ed0e26ae7df592cfde63df3f600324235f341f064d6c7799ad70746de8e566c74648197e1162c58a4f93354547d3c75e16d9cc9d3131583ed06ab4f29e002a5afcf7c472db622d447b7a4e35ca62452e7c073b062df6509c4aa0128969896a0cba30c999f89249d6596773f80c5e0dabe5af740cf9bf67a84022b30f892677a2b4fd3ce40dfad151dcfb444d402084a920f5def7c1ffb3a3482c312ac0d3113cc7e22ff7ae1d2f39c42797b047fa8e2950a05adb3bb563a1f72c4e14ee2bc0715019d1e9f8abf4f9d7a0686dfa05c9ad37c985b4277466fec5aa2358ce228302cf2a0ea73144b488abc7f9f44124ead74444aa85d34b9e15d40082ca46523734eb922522d5ad9278c82708c7dae0eaf5a2b82afe67544dfaa2d6284b7edd012f7309afa8d321826dba01441ae7c620c8fb87c181c2867c7de0b8b45ae2faf912b36e8d9eb0603844c45cb70f6b67512c66f8103dbd4eb719002db6ff2609801721165b3f7ece6e5716f86b734762b9f445e9d798f8975167652f1521fda895c4ce2a377f48fe849f741a9e3fee69d27778c6be571b47f9bf2c01ce270278a687894055ffce0ad64582eb722e9f14704ff59db4dae8d3e2440b075acc09227c7a8927a02bce10fd5f4f18a8e23738ef9ad33e596075972eae6548c39ab16482816f005b5aca056b50d5a2aebf78f98b74598f5f0a8997b78afe4afe4ffd75b90bae6f57ef757102b953d72cdd9a55aa5072297f4ce184083b33702e1e7e0ab3df658a3171cb5199c07b13145333986084e0efec63ae703e7894bc7d4cd6233e5e561ba8930c0f889acd2bb717df0003c694b355de081831464fa76c3bedcff25dbc91f8e22d6927a64afec8059df28fd79fb7f917fbfbfbf6735e0670df2ce23181ef2d4a8b97aa4569365ce2bd6a50d548c1a6bce2f930a7be4c0d147171687eda43727fdc106fa6f318eaeb076d0b06db9b07aba5f31742d03404a995de1f3a97b321ba960495eb4cf5e1b1387c39ffe630f21073b0fe9eaf2971892bba68d0f82b779de617fba3606f5972bb9cc02b912b0b864ccb0a7d9f867564bada5ae1b03d3567ee26cee210750b9107e3cc8d8d4e8c4d378f0f8ac318236ed0f774dc3ea37dee521d7247ed06a80f04b08b389acc7e3789a0211299648baf2d60015ea72a43d25d7226381c5f59291e25649462b10b47a3a7c72e6b5af0ef1847c67b9c8d8494d359bc3aa3ffcbf9b784f0fb7d323fe449ed6be91c3d1329e48f820678f512791f607c3b46b221f28965e708948935670cd3516f1737a1d47c2df58ae3431f415e4245be559ebd4ebf11a0975d7365b62bbac5d97c2e6279da32db2dcf4db4013abf28fa4b0465839996db8a9c1b76c7e8bbaf68773db11a602b3e9658873bbd7054d47a98eacd9b461f7e362fdeb28aa41715c91b71c5e9ff2d0d15eb5fe341b9affe6978bdb98d81af6ebe2b9addff42955b841aa18992a73d0f9619f1029edd17d28880a397f01ac5c763607832e647ba46816e097d61d7a0f3855e9bc11de2ce90c48595b563e35c42e07a1063f470914bcd4757731f97ba4584e6135d76444f3b357a52b4c4f5405d52ea7c87dde777c6808517059e5ee653adbd98e448b4c6966327a5b79620d73ae04e9998ebfac2e80393b0fc294b9d109abdb9017116adba89ae0467f1c4bd14239caf3bd1f3caba8c6192b6907327d8cda7c96cf92046a689d97a7641e78f1b83492a8ce5508a8c54be282f9a62a7f02ce3dae143735b38b1128dac0508ab153293fdbc56a0944b7fe1c06462bf641b61ccce90028908880dda4613360bf0843625b9dbbe17f523b6edc633e537ea50bf416c9d31557f4fd74377298e233126ffeb90eefd6e6e3556ce30000ad1d248f70ee7e2f4e894fa579028b26d0fec4ea1120b779c748cf421e4c07afd580270a351a1ee5ecdb1a100d286d3659ca4b0bb309149624ac502929c0645e65939b0ef4059c2e9ff9bc0377255a4612612dbced6e1a33aba272cd0918481297801a7ee389276dc0eb246138e6f71a83a6e65dc88781fb59bd18a9fb64d18b4185cca3efe06d60d17bd5aad88f7d62eb33b8dd7e023b15c35ae8f94aeed814c66c7dcbdd5e06a62372169f180cae9f01460a00c816d77f79a450c01a2fba36807124db3297fc39059c76f188af6df4d0723fc8b6c4322122261b00f5562d174011f2fd543fe4a8854a33bdd50f4b5f0cabaea2c4556dcb06d7cfb4d1966669b808ab947f426fd5af671474b9b3221899d0bda3c68d629e9a9f8d9ae41baa4a70525ba9e3a9ae7f42e65ad1794ff35997d141d039ae6cb1b07e647c18eb633d0fc13cd74619ba926ca18215f1a2b04cefa412858733f0cb917a10bea51556b3353b49787da80ef631f00cb3bafed6ec7d0a08cbb8e739773afc301442b9803de2a3777047b8e862fd98929bf7bc2e50ef79f036952a4e42dfcd23714535fba3467635ebfa0cd86191902a551ca88680d99c55d32387146b34548ca55f24df1bdc9b1e086ca85f58c9601d1a7d028b38fb40c61b4dcae8df4fd9062f19996171be2611d11d48b777fb046bdaf2a8300175f5c82b80606b935d06ed1bdfa06cdabecc46ba845cd4c35c36aab8ae6a6402d8bf7487d129ec0cdb5467f69d95f5a66e38800f99a30fb5ce5f755c8d8a733f22916bbf2ab37ef039ee162f331e9f6b9635ffafcae593fa7c7625c64356e89d2dedbd4ae2c56dda9d325e6f79cec4455ebbffa38148000ec563b3c2b750d0bc1ae606d4af66278c7bfd17be1d143facf4cdcbc714b94bb839ced74f7af07d03fd7bfdbe49d14e3b2eaf793c6e98c308b1c912d904daacc3ec8d024f15fe7e76950c30419309c49b830f95df4559bf5dd809382e470a867974fa35cfef7954bf8512345654b3d6e70d552b3ec15fd8ba9d2db89c528a8952aec837f468a83fa11155023396b8a8a92f060ac387d94664270ddc63778a9999a622342f13cea8267fc5c4e12df58cb6669464924c75c7656a8cb94659f805a8ef2c82e030197aa65b51d76ddf1c1a0daba66c5a295e38667684b1fb0a9432da3e79ceaa7f2c6a1129e66e055e3853c7cbf2721b94b36fa6c67f974787540ebd0734263b9c20a93a2a47e5ea4808db4b38873d8ca3f0ace2bc69dab9f6fa8607eea1b27391368b7e7e24ccbaf7d2cbc696c96e02d31c84887bcdab256dfe8bea140f11419537e02491b8379d7b0be566ee2c8aa0e09a0f99cbdb88277d07748e90cad7ac739b9ca7421d252f8d670ef611aa5f32570dd2ef893a9d890013af9838f5e15e7b2478b7b63ebc25c674b50913b85f1ad8b4c54f22004af74ae926e415ec4b8c2301931dcd18e65377df9997e5f6ac7018fc66b6c171bae8a0cfdfe5c6d0212833d34473b2ce6f0972572df2d19cb4ed441e30264283be4b97922595ef5b7eab0460125acba57f0df6e7f539df3f16c0396f2abdfc6ba406aace17173ab63e1d7bd195d4340276c1affa17a81a657e0a7fc2322c2411c51129e633d75e3e67c5f8eccea65bce72faa4a97025fa1fb4e2cf27fcb2d3ca1e77c8e6c88105b8a9184f70ea899ae11b6dc123d50e8ee833afc23ac59bdb409676e4b26cc0c5cbfb832edde6411dfcebae2c15243fdc02e1ae402895b153cd7565e089de6c08efb401bd5dba26cc4980f3426206a69c7181a18b135d373393ffef2c7956595b904ea90acfb4bd6ea64bb67aaf96fd80e1ec0a57e8ba498319d9a5d50567b6015a94a346c6053e6c05d8c8aede634173fb7d7ff1b338bad8ce744411315dd24ac9b0eae69dd1a9235ed9fe7bb2c8964b9f90646f7ed4dff5bb7ab29c9d5e7c54f04fb095b9cd61e9e73cfac1289811b73b582fe01301791624e40a161314bca0c7f91992a319b1dc01e32242c80b31780bb01635548677df35d46c799f9dcf896faa4ad4042941aa08def7b761a379da538606c3c3f560b7307ffb1df046fe4333da0188dec70eab378b9c510e1a2383e34da7264458d005b3a55e9ed35bfd7cf33dabb973a6f73d06b1defe7fe29f4322cecd062eadf634f99d43e860c87bbf71fa0f277351e7a3d717c826591ab6eeff664efbd4953f2e3ea08dc5e080e645091153d150502aaae08b749ac04cf6e3ea9cd3433c530755d55dda26209b382e680c34a6650aaeffdb00563d26d6a78ea7c065e6eefe5d80c049df2d56c98aed506f8ed324ea1abbf3575047b359d3ba8047c69938ec6ffcaa22305648d7c1919ab573cc6dd72175fbd8dc287887ac303710083894f47626dfa08b50487c31fb43f4052597457ed99899f673dcc868db8d21c3f1abe1c745a251be7bb019834caa8b2199b9843f668fa414895e350808df326e73d67882fc13221bb10f96c43ededda57fbd3a351bb08a4a305ba93d84b143e633f28480cdbfeaf385a28dd1ce9f4a684b486163b84eed516bbb6fa1ee99c61e0b442d4931feb5c31f261479254bea549332a3b491a00a100b774c61508151e26d6c52c6a45ea430259e8c76b1cdffe2735bd8c5cd05112c9e092cd5a619dfc076a5cfab8b4312bf084a5d26d53681a6c490d67c44be40f5c9dfc0f5c6486a938862f4aa472597e9f7582abce8ff5b02cbaf269734239efd79262dc9393fe6d9ea45a1cce543c349d51c0f4f776dc0da1bca037d37858b73ef0fc234fdbfd88cbfcfafe664fae6ca2c122c879eaff85c2b8de944c038e9b822d040cc3333843a6daedf790007e49a2e29f92f060f14b89d5e9bf0ca4fd5d2009ac31a001eaea7215291a19e907c6bb21ff3457394b5448b418e342a55895e1b7772357313e82912ccce99ffe335048e09d571ba7541d6df0f69f8536c99241222db3b134b97c8d615602c5549bf32e73ba8f68283f7460d229541277a75d9cbc3d8550bd25086220183d0c48396cae3226c627c1d782619fa3ad44c7f934862de017f0babecca44a6fbb71f9bdd8c7e93ccbb5315c907424a05bdb723a1babd4ea25e6869d5caab8ef6d95809ce2c4c1055a00ec16905e0a76837ee2c7a1e6db3a86b52cc48d027e35787a93ba3a32156439f90b108caa2239711ba81c0d74988686e0b6f864267a83c584a137af7ab773e0b15ec1ffb12455f0a6f44bc786f3dd27c6c20414517be1d626a65e77fd56b0224468a007c1dc7e6cdc6c92e188df2ba05332f9416fce9e8a3d0286fe23e3d197fe9f04d7ed885295b66676d34d3aa51bc038926e59d83309d2a34cdec1a577b307447f23db89cd2eeabf8de6fe7f8d3f25ee8e063d9fdbe46b1a72ea893b473574a6e4b3299d025b9123f8590762005c0f4127d7feaf788867e202e976d60b0d699019443c1adea7a1291778d0baef0b962edbc1844f08f11843a38cd38b23a508e43213435073663770b9148bb1c8590963d403f260d3f43afcb9ac4ed19f309ae1faed40b3855562cb25e357a5e9c2240adf32dd37cd22a0c6cf8bff1f241c95172b563c401d2ed6c84e7a62f353f0e41ffbdb95901d8a2fd1cf0e38a5a4d50a2e614ee3141f6ddb313539d397c96d9c887f520172ab66e5d50fd0b5adc2ffd594b034254ecc726c922194c1f2493bbaebf67fadc004feb8ba273b233bbe507dbd028dc9b8ff3c487c21299960a3b19b60b861ce889741366c8fa31cab2880c9c58abcd32dc3a49b10e88d9d1d76abd6d9f890c3fd104da7588c0efe27b076ed6acaf44d5b553f4d698ab2eae2dc114f51d57cca3b84dda1cb870498c3ac298567b4e9586f467dc21ab07da24f0e688ee975647434f853a28f1a400209d01c8fbdab6a3f52b8a95591d92dedd7a3995b50e8ed256feecdf8a2c90a04875c6e5d9c7f5dcb6ad25cc9ee906cd3ab4eb5747fdff5d85c3a0e90e836d545081f1b6d5b40f915884d966a3df772c746542b7bd920eb6196d709c595e3f1deb084f9c08ae0c72ee8cb8558dcfa1fdad6279ae8ecdc367fcf299f69a69a1ef7f4d4f037ca1d12e4349b0012df749edf20f72b663202fa0213205814f4f26f2642ff0ad9b584f16185ebcdfd54bab54b72dc445a7aca62c548e818d45753fcf9ee1b80cfae23a1f8e690a3ad8125150d638f406b0ca8e5ea20c8cd22f69404100b488ab6f8e6200ad41fc986716e6da372413e583c91b8ae43e765aa84788cd3a5d11606eab1e7122733f5d7442db06d413e94884dcb5a7610c9a0415457ff2cce9b5a5b227eab5fe59cc60740455307ab29d9f1b0c68ff0dda22e368ac6d0a43e8315516c25dec5722088cbc158d34a3132813f6af82713cbb5f9a0e634e5e1967db8d52759bd8e81db126bc780a590844f2ca446682a5196bdb6ed700ca300649f617b533377115b2b1d154d3c7b067052ab479ce39406dc29edc183787962ccfbb7598fe788cd012c277014916b455a0fc6b847c5afb778b2b4396291b2725d93e3ee93dab3bd37a0457cbfd7dc1e538d3600c9e102822742f3d043967346264b2f1944abd8132af3e029e776373722d757757ec14b336269e12882730d4a53b099156d491b4181cf3d73aa1755f114773e4e9d5d23be97cbbf41130d5dc69c6504bb632a6381fb6223a2df1599a41abf5653994fb254fef5a7b49dc9df8c484bcdf824a4f94273f171aff5e3975093076909587b47fd634c4e08440d1222ff13874de330d5e08e900399429740f8e32e037afce7ef713dfe9c7229f84b5aa03b020a3f3e99f6f5b8246cacc92fef71dd717f4e818d57b938467c65051117fd18381ce0cc3869e1378be4947a1a62a71a0c22f98c0a2fc8322fc4fd9639a01679376897922e9807149eb815a5c967b0ad41ca18756736be807c654f946cde3aa9ba6cef984b3b52adc62a05480f387378a24b957a1475451d3eac574411774b78e85b556604e44826e49017ed95bf7dbf9d9ff85f38bee6dde695492f7db827e194127c84e52709cfcb5ee46bd323a0cfe67c97117604b46b820cdc4c8dc3ee1543912008c2cb5c6ff60a8a7f650fcec478e247706704f3d1bdedbc80e3c4a51de00744cf7e6207c4aacf003a344e1cc7be3f8ecedf624ea3b9ef3d889c27ce866c0bd252e93427fe5f57468a959a14ddf728cfbe8df0556aeada8a7d6ed200adbfec73e76b1e4db695dd861138a20034a494416bfcacdfa5b1e405a5929ac8958e9b5908ddb83a23471c953878513a7c9a3f1d669e8d5802d0495e65a6810bdb008051b090065a29bdee37872d9af9ebe1563930eda0e44cf25876cd267b99e3330dab111594ce3c4e6bb875c13491a42c2685b704d5aa7c2d4696e145391d2217b3007f5702d7ff0beff1c573f467247e6c94f1796410d944578f6caf89561db2c2255ea63eb628ecd51de494145f2c89ed136c74b109e1d5578c6374c0fe760f08c8e81f2564b9e93506da3b9a4d93b8816878ff1c6a335358a1f5d15f79ab015b3d6a3037b71dd36ea454d15ef6ec8f9109502abe7414a99bb1357661ca1eb3ed4331187bc2360d05d1b84b5f2314df33384e6297f0bc45b9f1677df504a3d6cecf857937db79aebdc05e4ff1a3dab802ce52f134b2c775e644ddc734058b57f9abbfaee6b999edb7995e8d0ac0777c36a19b42aecd85be52828513695269bfe2ea4ee57195d5dfb2b3331bf367abffb9df8bf1e55b75f417130e5c6cd31d3d003a4b9a2d5079316364acb1ee1c4d51fccc0547cf5a87d64ff2a55ee83e8f197c5f50b45d4190639633fd49fe0cd044e181cc27e03110d37c40276df5e065ec136e8d92843c4892d1acdf6e99b7f699fc16903e8de563fb5454dd50d56b950ed37252659681b14aff8cecbab457ba369f8b0c536d40f6ac66ebdfe475950c36ae2cec735658595b848eb1c3629ea7ab10a559a0a4bce686f5c807168a0fdfa406f64b7d608b4c377757f614d30f1fe33dc3fdda2ee620d804766d85b4e86cd032b8ed8ace222648400a1b90776d977b63c3bf2e0206561fcb7392e6df3f29c628d916ce88277060802ce810b6d68e9578e6680f79f306ece9e2c41ac8fc2c7385dde0fdc2dcd917e04977ceeddd00c19789f4c2a7e5b837b7714fbfddaf9f88bfc5a5506f496e730969ae08daf8a81177a2bce76104b9143d7295b2313296c82dedd3a2bff6a95821c0cef6dbc9649fb2331c1fe099f566941377e73987eb9e95460af0f299f224bf2113cdb81f474cdeba642aa18432b1df3a2d6b2f6d8cbd1313578d6e4b835d0e28a0fb86b7e937f873d788f1274034621b3076ae3b90d98803dd197b72b4a079aaa861cd25db7496c4a91b25967e46f31dc225d5bee5ed2dd85d11f33c9588b55634f781639261a2f274d5bab69b729d42d9930028c79a5a6912c500157cecebce4a76c69ed980d2a827bbff37ffd6ce6316bbf6d94990e06010c75390492bfc095ce9f898bedc7e2111f89f8c76c962ed5d7926c2b99aa2d8c9d46def1d2e1ad678626fff5896102900b0abf0d7c85e7ca10be7729f081231a58966378007e9cfc2dc5126e5e84c1c87c4ee1ca2f05fc3f816584b13296db756d8cb31dc61ac06275dffdd06b6c71aaa18c8cff3ef889093205590f3814cda76f3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
