<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff06b2163e2fdb689a202ed1209173b1ff9b53c9162dd060e69088be315e2ac371ce18fe556b92ecab5492dc6813badba58ab5922ad796fd50333fe819a0ac3156c8740a4fad0c26e1647b613e45d9faf239d016b5aec84806426f9465b908be24bd1d2bc0ed33b2049001167bd354f80e1fdac05f60ef73d456a66ef13764f6ac4d78e4f133a3e6bcb98dde5a188c9aa5ed492037fa89bc4ed5ce8a918492c719497143c83cbb28e063aff48694b05bde21e31458bc1f94b7c8aaf8a06b500986befa9900730f987dd246083bfbf4c63230e864bd384396bd569a182c0295e4bb7c79263e8f5ef0bd5b1da108a89704492119bf9f0a74e5031bc349cf63efa557995e5abdf7b722202e6d45fda3d113ab9dcf3804f92a24276b9c1da2f212d8a2947289a72436b711d829c90a6d4352b461c8925c0cc991671f542739f516497df09fb782f2384000539e01287ab46be68d9ca5dd66d5b420f3173a0cc05ce288a65b164df4fec3752ea654492456ffa99f3be5a9db57f71a8a8e96310f027d88915c7e4e611b38ea71fd572d0d4b62a1e0b5d7f6ad08c0fa42f479f46737d7a742b0461164962e800b42d8fb349cc64ae9f6cd9e98b8584183c29a57c41362cf72ddbda8bf2350a4318e689fdac1a0dcf7e02a89c90188846d107d83b20b6e3c63e83e8e874ea39954620b2a04c5aba6ee42c8ae5d3739096d0a1f5c070bfae0d9970321597763c4e7274f7c61833bdf37c7bf9d6bab5c3dee7690761d5c90fdc0531ff2d8db30664c1b6512cef5b9d762a9905286464c8199b2243e83bb3e9266bc5cee8217d66bee3c46b63f292d1d5638275c27a767b50a40274e700adf9b7ed8943278e81960ac3aeaa0e4dab955f13b184ba59919d4827ba92ee7510054c9f82c292e799dfb54c31030e0b778886e5e709e228941c1d6cc75b73069a035213c3d9eea2e0096ad5a1d629ad4c419a3ceebf6794f2aaf244e0921332ea7a87b5e72e20f01e257c49a92ec8d5d79a03d64bccc4c5dae7089f645abf38e99e14d1f1a1a71323bd52d07994aab291545e45f86a6587a12d4a0d2d6850c5bd79e3fb0ca307fe2e0caa65c47ce52ad0114b883148ea21c417f6d54c573c2fb9354a6d5032e4256f3b115aad4e02c07c96b226f7ba1e8cf77b6586669dec8ad7fb2207ec8494395f0fb5fd3ed55d0df92101d0544bc1634397c6b7f8077f7a44aace095675a11d0c8e9571b85e78b5cea8d0c59177f0c809e4ea504e4e7e88b4b8c41573bec1f2356f4e74ee49c95949bfa5b1301692bf84aa8aed0ef5e94363b78d757a5c9d291bede150cab3297cd09f367987c21f18527c5daedca5837587deb447081a25090d1dd7fbfa8b4822ea21d56406e902c88b7ec2b2a8664578f8855117524636cfe4e4f956dfe3bf3d1d2e27275f683a75d191acfefb0bc0b979c65e7675f6f50f0ca678afcc3816812d65986292d793ddad12c7c0f6b649081b03035053dd85932b4a468a7ef4df117e439ee896158f87cc156a03c8ee365df1e65cc69ffa87d50e69dc0cfb733374ea614a6d869fd628b0b63b4c12e20e093f3290d4a5f1646570e5f7651095a7705a905d60252f6f1cd5b3069d111c2fba41baf0268cbe979dff5c2cd882a5dcfc24d9d282081a685fa8db71e6ff7dc0869936159f499a0f19b7ffc05010f5bf331fabf2e95c8e9bf4490ee3bdaa903b737c7cc2f293fe8168e4b7880dfc1da3c9d138d0b5403093a7f418e616ca37cc6428df4919b18afb1ba7608905770da1852e766e73993b2836743587de57530c6e385441496c453534c5f459784d5775d6a6256c6d400ed5191ca3217c09c87c90ba9ba6e15780ad5245023b2eb28f105ccb1211d0bece4a443b828cbb6829f04bba48832e466b09bc5fc57d9257f8de6cb5d0981740d92dfaeb1ade3602c85d4784c20f1acbefa1de4b109741cccc7d2c63ce85514450d3d7c93452c6c51e3a76959fd6b5e1f3b2c7633127beee6bd692909ba6a8995e54de203e9792580618a091a34bb921e55eb19341c27232c8435e6caa586175d78893b66861640f9248d03c6783808bc48cd075541950d62c0c242540796a498d46de70099f4dd47894762d5fd432ab347c25f1e14172d5ab38f52a2624cbe9f184677fea3e28a8599849777a603b76a7e9e3f8b5dcb3b4a6ac345f14b4dcaa24f67d7cb7bf686cf33ad053c2e2327bce167bb905194790b31ee82e7f0f86f917c19f1f79fa5a4b3c33c3ffb83121b36cb0842c59f68e7c6437bb5b343b19ec1a88e3a023d6bd662e8e513b4677bc7e0aa6448bff62252280c31f6a73c033c2d7c8bd9dbf12ba913b4c3d9daa88a8f2eb3210a806d7093954db445c5b7e276389e615a543b5cd317629d52fcc3e578aefe3963c82f1b5fc99ce9abf87ffd54ea10741cfaac413108f796358a78d848be12c8d6b442644fd47e1f82cd7e447e830fa08c8f1a510f1cc488849954a601f997db4c2da7ee913e929b1d27921fd5c945e975cd255ab5ce320bf4531066b36da69289dda669f4dd21f44df6dbf069ebdd3f87d28256a6a8bb50c484165fb9d66fdfc5428c88ee7f25da9b068caaf37807947aed3bcc5dd75c34eff7de7630a6a51ec39e620d5477bc44fd2e35ac89e2ed01b9fbbfc5b3530347c6d0a3d479c10b5901addfc68618a282bce79731880dbe53a1c24e97b53708e6dd843330e699f4a1a66a6e093170542a3929bd6618c9d7dc397926d6ceecb3a637ee20a985d7c689211446f7239ceae227808ef4aafa68f6ca20a95a9338ad49ade70cd6b36c47fe90eb63d4a69cbea271483bd0a3cb6be07d7e1280e33dbb4a042d30b2c0121e133f7b9c304cd157084227dc3d6e8dfea88385bb0d43f88be166fb27a36e6722c0d37d752f2bc6a58f16cca9696ac58b07d8002d8b974f4be6260afc2d441fb3083e1500ffaecf05c1cfd609918f2be1be5358e89473c86be3169666624b0d3653093bb9ba5a8959546b0e9b7265b710547fc9a91f0533c6e9eb69f1fe0106543e11c10b10382849fa0b81589f3d97c188d97b27377d5e2ffa9ac7807227c16ca60bf81295ae973faaf21d801684719180c6dea017db6661f41e44e37f8a58b41b83d12ad01573275d4acf84fc757f49242d5b45af41a0185dbcced57ed7d05f806a4cc8dd6d977c611413bae769d11d9b903f51df5b290b01b66cb831b9f488daa22f6a883c513a8af8c46c8831a20dd773e618196c996a883114a25ed3f60d7ae1c6f3db84fbf499d1bea0b0b484f303ed0f18055d92dfcdefbe234d01014903a70f3c929f2faebd6b826e3106c442fe50c8451e49479f7f0f54cf5098dab1ab616100ea467e9d24c2722310e4a89b8b229ca0cd4ee46362d0ea2727c0f103676f73458e47ff9d4e8728560f1a41408958479fbb7801657f362f9afc3378295e8624313284f971e8be066c024ba28e5fa1835d9a417db953756dc08b199f0733ba4a7365a714aaa3f81dd369ecb54606a3f103951de433f830a3993f4aecfcd8acb61176b7d9f411ecb3cbe9276a14f49246b6bca84898b9352f4787e355b44057e9d1032e684a19fee0607ef2213bc9777ec7e488b54583537da70871b77539efce46fc70d2322b7c951dcee4a41b039052c1ca4b811309313e94c68c8bc35f9ec93191b3158d2cb89be3059422f9e5244b8a1e5f68cd77e1ebf1e09054de713be5239047e4c57c8a5d3677c85b0d345f074bb2285e52829ba3f1994cae96e664226441bc569f372ae453b4dbddac4ac6a8c232d3778b1ce0b201e0431d359ac20b6835ab967015992143e166b345e95c6d5b97b630c1581dbb9fccc074dcce34ca02d4950648931f7ed692bec6132bf433d6fab63d95a02b3c7f2f97ae080745bb3ac18e66e8625a112f73e639efce3f4877c5e3dcc5a5d037da4d45ffc9fe5ce70ead210f94d575abb7b67334cc4f8001462d2a362aed0a26ddad3e49231482fbcd856a24f3db0115d8e6f4548e61b17a476f4e5cfc04b2fe713eda470ec7f533650fa97548b149f02091a487c4fe6581cee449503d9a77445f5af4df84bb8a9c1df616b8a1d64342502fbaeaea06abfd62cc7974da3e3dabf164f8b13f9b4fdc7108c267cbb6ad9a3e4f7df944f82b75e0137e89fb75328b6d5c24c93c54e13561a4716094e77638573e2b2b6eb95b0a4eef3991545cec1c7746d48ae6bdeef3d5b1401d0c9676b9d37d54c612545d465e5b874ee8fbc43a81c0246fdd2adee8c1adb679e2d93e39607ef83f2d4f384456f1c800059031ba11cb6c4f963c92d3eac08b9bdb5e9a9ab099021e66e738891fcc05e23779487b3a5c6a2de0be7b9abf15cd685081c3e5ef52f9a61862d19c69bbf0b008875a7e3f9d095d141774ee144c70efd038b7fdc308c4d5049a58eec52d3341d9cd94922e23b421c38b785e084fb85ceb498041111e6eabc5492f9cc18ebe2126b7b7055067634dfe34a41948d40e4d7e138262b4134a8f23129cd4c030526a183ff3965aa7a13a11f40d4d702297378d2294e92005cc78e44c1063f7d14ae31808774058b8a88720114c8085fca176e2b804e5668e9cae38001e6b8774595fa63c6652441b29a1d0d13c5115a6ea909d69b75d10efd49ed5e3d94117280c40e68fce437b8a516c46313fad2455801e2d351e162354232b78ffae6f0ffb2fbd9747a6b8fa06f773ccc3750be7f9dc035e039ce1626df505765cb8f81c0e82d1ac5e3310b3c2526d9340550adbc10537be6716749689254405fa3714fc0a9c3ed6916e1ec6f9087280c2889570526b21976c4b5a61d02d83493cf751f0eff8086907f1663776c1862900edc08f41fd761d7f2dc16068d7feabf344ebf4717aba9944d80787cec3c730fac72c03a8223f1b6d3a739db062ae447656313dbbfa5517acc034f85592b44436af483465070dd86a8f9f706d835faa7a4f78fdf6b33de0a0680959f4a31806b9ecc5af6d93d24f2769012b48c7402a4fb6601583d0a497c181e06f558ff1ff5f64d4b7a8eea534e8ce6a53e54ec4dc5278ec7b63f4ec668d1f07c540ffc23b622ed64ecd2df10c36f06ed24589f1079339acf95b60a22be9d8c8f96d55dd2b334ce11849e3140f5a1e2e7b6075a26c57cd951afa1208efefc67a23f04e43bf084f8ae4a11b8c435f8147e6ea5781fb3179d91a441759a356158382479b1fb2391e8541108e5fbdf1b8fac71914b99540354933f04512a3c2bdf463c0ca7c8c7324dfa7ffec15747082458c14856ebd498c9b46b2ce04beaab0b592486adf8737de96d2f3780ddff10fbfbe7cb1dba5572c52e8321da8f96f65045da926dbf5052afc45861bb10ebc516c48d79300c097e7c001e6146599b55497e21924111a8f29c8aa5a9edd98cf403f5487db35ead6f0af432d385f99b08d81619455639afe72fe70ada6fdcd93f295ca702e5712fb1928f91c26d497a69074546078eb5aa9a2e5202a0380ed40199e9ec1853fc308511270496665d88970adb1b9449c090716e92f8f7d23a15345a43556a2c6a528b15089cb03474be4d1702f138fd6ead30ec9cb2312417b65e988309d5880cb31f09e70a80f76da7b3641771407b09a325ad8a1af652e0b0d9d99a60e9909ab9da20abd22ffded9259ba3d875f786d7a573b224f89e4d65ab10d5c9122909a3f5750bc42dcb5771a8dadbd4ae25c454a43febbadfddc473ea5d5c19ad194e44e34dd07bf075de49939d0c1ba0f740c83adfa8c1d0dd90cafa62c11a599f774b382811e837f7a2db1663f7e521764255c3808689e5358c534322af5c048c0cd362d77ba6ad8426ab7ca30f7b530770a99f6bc82b70508d8d1037ff1197f4c9a60ad4c4a1d91965690e170bd525048777005842d920d48cc76e4468b07e083d1d8bf77f485d33fae6324d9a0635ae951d9aeaa9bc843d2a8ccc3421e08800700a04c0f11fedc7e792fbcfc3e503ce37572f12e89c496e7f0d64f56610ba65756bdd7585a64d0d73ecd1c1775649afa7adf9950b323167c02445b8bfc860b06f88e5235548f9f81b334ca48c2c127fb8a3aea29f3b255606195048f1cf72438f06e9d10bc98e735551e8dd20af692d6b12794a4e03f723327ba4988b0956fe125d76d337f28d41024980e8292e162252b4dfe9e9f2060c1c17e860c508d884520da6ee4ce5478d203bacefec69b48e2d5d7370cb6fc81538e85e1aa0624135b342a5b1836fa6c7553c02ff95fd4356c23c9954d41f1958321ac71575648c3c5375102be54f755b14d0be8ed47379555b3959917cb3292f0f73c4c80e5e3d2dbe7fd2360a939f16b26b3bf02ffb76ffb228b8bb6a6b5984ca37407b2744b06368fa26fa4467f3e86cf60317b75344548b629d81a6ddfd3c37b4961d06b113870b817ba6fe5b4bc4df571a2523029379e82c458532c3935aeae0a89a43cae9463bacdef72c7021c4439b0a70d3f8550a4f6a8e2c02f3fe2bd3332165a0c1abcc5d374d05ab255a7f4fb9653a8d5b885ff81a2f03bd413dcd1279ab59ddd59a9fa778fe5a13f09eacfc580bbcf798f05a2479f3a90d3a13fe1f0b52cbf685eaef1b214c6d720f12667c85e6421cb5488e303a06f05651407f4b723881dcd0c91b3fdf323856c92aef330112e35b084d756aabb5d9bae3716b5dc27e12bb58fe1bf5ff3603fff1a364b10019eae6660330e3e4d90923d92c48aa0a9f495abbfcc29d463f500f0e2ddd59826e9339f23dfed77c7a66a5a4eae457c5857d10e66ddeef6265090ea73ffc7c34ef1fab2f8ed556cc6c379c6b7fb235322eeb31b9770bebf3fe75feade2704f919de35822af9f0e4d79482b67ea39b5983b5e5e8d2d302df526af48beb4033c6ed650bfdb17e92091147f9f55bc73fc106aa87c7b4f81596c1d35d5b6598f39881975faa617e3f8ed9dcffcdac6db98767d09a4fa870f6a86e07ff1a5bfb73616fcdc834168444b1a357c8f1b9709cf17974f44bb9eefb15d71469499d3f8c08d00a933cfa522513fbe8fa6feaa18f4675134b2e6d0bc02196e20bb377fdad855d6803de5433893ad8121c61835cca065072bd362b1c47abe285a6f1ca5d2ef9f876d0f653b7579f8e5019e95e517bc0f35105301715000933c3d8156b4414902792b498e39526a9bd7c3d6ba7be2f7d2ca790ddfa9139ede1094b93637fd96f1256cc2b5a81985747ea4d064562fd1ab910cfdd374ab6b608212aeeb427dfe3d9bcdcf03c6dc892e51b892b2340137845cb907559cd6a95a90906524e62b33bbdb2d56cd324d95d4a3f8dc0bd9b420a20e982673fa109d475e86112dd017e4f4cd6ea1d11de66eb75341f225fbfc3c1268817009ec2be4efc6a53151400eb7fcb306c117b2e68bfd6beed925e07e6e055b1d7c9337a4df10e864e9af581c6842737a48f18601272dda0375fce68f4cd171b30bbd369a2a6e07d35438e27f565e3f9767f0dce3d36e6d8f36d554a300bbf0459668c9fefa7b6b622213c3d7a835f8cc0a0f0b014bbba2f7be3d87f53281c5de73786f95a184fef7ed0d6a3d0c8c6f15bfee153b43ee4c87b7103ca4a1105a16e80ebe92c7eab0af6569bc23bf8938cee4cc05a0f6870a119ba7021bc89a1ead395f8dd98b02de418ef0311af1bff8fb23a5cdb414d0a324aefecdd7bf62de488304fa833f1ffa298a876718d72aaab36ff448563f2bd8b7c9f1b13753e0c05ad3cfba66da714f701bef270c5b4d3a4d33d8f7c75c63d19e6d29ec6728e0aed40eea3093884c1b57099ab55e86b406909111e48eebbe6ae16099390efe244143ec921215cf6a1b3bb8548aa84f9cd7b50a14fcda602989e9d8d535311ac3a4cc4db6d5958dff614c1bcda68fe1fcf269208cec594e3bf7003288261ebe70b57c3d9ff782f633c09512ea8d2a6f3f59cc0f3f0c37e1a88d78bd6a34b5b455c4ff74a5daef86ba7a3329df55bc83355d4079eab9fc9231198853b2536ecc99337edbbb8ef4ed2ec24a8bea17d3328ba5f0f558bd5975e0854087403ce799b6a75084e37addb369869ddd8d51c57df7d415f62b7a0585df53809ed4a711c5e11c43c81b6dd138c998aee27d4af75556e4da5af60d93f09ea2051512754f11772674137edc5ce9f1686d89606aac1caa548246118afbc0ef4c82673d2db61170dd705ebfcf5e80e0bbf79da39b3f76a952defbf3f509fc1cecf3eb9ab7a1fc72cdd0bcf09155e2719c95929b244d2c40612c479294cf0195b38b9ca7c9ffd3d3859bb424098ed63a2e85c5bf7e3181cb20a438a24e456ae9fbed9032d47822bcadff8f07efab78b0c96db453e81e5d440736e0855d2c967f919b2fa1e23d4cceca2850774010681507e87526094de2c7c4d5c3548ecabf546e5311d6ba1b9239a2afbfcdaa2daa6d468aa3b5847ae451a0e82b14608c77bd4f7517df0a4afb9d9a1470128a56c7ba99abdc1becf8dcac7aa89f3a4752f34edf8621c83cdef758f2c504ddc34955e752cbbb20762d18bbded46d6f13c717c782823645767c8d8ef5f5d73574658972dd5504aa7da4015f825cdd58b3596ef15b24a0fe35ac5b66b9ada22d652a2209068ab5801636e477c58aebd010f417dcb9636e056251b5b789f88f709f2b5cdcd92d6f377f706efb34b0947cbecfd70b26b6e05ff33ea18807aa1df9c496760155e25f137cfa4dfb9aeeba507ac137da50d9eb500adc37b5073dfa4e1a77bbdeeed7bbd8a8aa7db411b0b1700107c8e867bef25c8d02339d3bd4ecc00c34dac073fc285cfbb7c2cd66621ed41f379dd0dca5e420d9031cc6a5bc240147ef8fbd1fbc38dbefc2715ac65354455dd7a79427f4064d29bfea59e229504a6478a80cd5fafe4b1df007a44d0ba2ee2bca942a7b332b6c52c4cdd7aec8d881bf74cb68a9b94e995ad827a13c1cbea2e34f07c4b14ba410b7f9c41721557cf68d1b8169aaaf5fb395c230c15120be2f81ccde59a56f6245be8df45e98b3b8ca01f7be3f49e92d77f29fe363a250cbd4f40472c1eb2611ef14e92447db869f00c694071346eeb8c93b8aa1a92a1b27eda0d793ff092bc931e1dc72fd4175dec81977a5c9c1b9d785840e9f8bbf9f7a2312aa22b0884cdc2f5454a89ddf683fef8c778762c863d650f657b03bf769d3e616d89c340fb62288101e758307e877ce239d708db7f2d5b4a8bf2785227b486dfd5e3132ff7ff6c8eb7ee1151753fa1fc191dc10eac43667cfdc044e778330d7d8825cc767ec465cf4d24cda4657de7dd8c1fe6a4f4a0ed5c076bcd41ac2d76cd272885016de86fd16f0b6f3522095272ca283921cce546681737a31d25336fcdedcd757f6e143edaed4c8776e140de1c3246a3991efbbd4d85901bbd42bc5c0ae055a19377d1a92a5fce95272b8d945ae74c6c0c83f43ee745d2ed60bdda2291c173499cde4a1d88f0de0d3949e00473a0afa486788ccac1bd8691bbdb83ce2979cc93ebd63f70ec2553f3582b08955935eb5c4aca8069fff8dd3656649d9574731956ffed619c4820467b769f3221afba7ba64c71b377d17c4ca025b8f11034712ec7dc9e5bb914fcd9b1c9538aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
