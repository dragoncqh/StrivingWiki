<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"97cc93ef7272c7745fb81820b54a4f2870bf975bd707c349986a0ebe9f3208ab1eab95ff133e3727d34359014157a38b889d9641b0e474389caebd8542f080ad3f9c00cccba9ef20903dc6754a90d905e91fadbdd33203afb9ccb4e86c49d464603b7e16de4260e4bcdc35a62a18cb65456369ffc30ad59a0239683d77a5008686ff36158aa0ee058e86b44387daa3c9388b0542412f27d6eaeeabcf5fefedaa2e474ec9b31a4b2e87a397687ee858233cfb8532bece66de212118c13e7ea1f81ea31d0ec9800722d65cc76cca9bbbf8efcc56e8ab9e81b06992570f46d30f4b7886a77c2ea58f52c0aacadf1a3f5d7a902d1672e9d0acb0614f0846eb77060b1857d454e050c8150c45e9a53fe8117752bad74106d16bc59090a7a94269ffaf37a624816eee15892d5d5e685853e7bbde7a7b81a66d1dffc72df086152619249d04cbe99dbaf457abe4cdf851400bb46aebda4d48787d2fba187023709707c10f3dd1dfe71dd55d8058aaf9dac9145e111b8fc05918f63af2013ecc5c1fead5a8e1bfc25012c0624fc9bbbcec3958430951e93f8a49657bb2748b2f369bf7b905887407c23c34cfe718060ece6d08f86894e5204a740c47704ee830acde40c854e61fcd27a14df4339505c4a2dbdcfb333b19ee85d75b7d4a0c6a8aa4c948896f10f3b080a3362f0d804a235bcccdd1d115a7aefd8af1b15f021c42ed1f8f0496c7a2f39ae9175b08b5b9e07919f6d8bd313003ce97cd67ba0c2fff518eaf04c346e907d52aac0281aa2fa4a2f55ef5341911926d0b1811ea8e31b10a1c7cc3872163ee07a728fa39fba5225d6e07597289163e861fb758dd70f9edad62b2556290aa15747aa18433d13beb7df1dc9befbc5d7f26d0b7ad14bcb378720071c32a027b3fd87ba33e71e98ea222cee2524ba090d07a91b443be0d354c6080f20734b803209b1dde4792cdf2f4daf2b3494764b079594b44e14459fe453e4e513f2f75f06901524535d89f7fe361fecb737415556f27362c1162bae535fa4b15ed3cf8a6e53f56051833505fe822ed4e39b8b327b3e454392c0802ed63a8a1e103adcd41772393311e9c6953ba470ef9b65f88ab3d66f9793daf982cbda70f896be83c286cee9327b0669135e80e661ee735dc1ccccdd19b30abd286e835de7f5c25add6a36e830d6700a8d7be2319b9b0d46325a5f3b24a0a507821d46de1a6c682f29ba4aefe1f155ddc67b83c4daf9f62f5676c30e1c981c372eb449ea3d8aa983db2ee2b71a7d789fcd0f901c463788873b13d8e7efc04231108087b588db13d5f2a77f48215d616e6cd85d8b3c0e963368ac7918fdddbae5128402805c33852fe3052a4c02466a5b10b6549c588b5400bcf3f3c39f4f015f764816ca2cc27492febdf2774224cc6a28f7f08e07b501a19526a0c5a97dbe8a548f3629f243d0abe8462fc7cbd1d48e289c59d5fa60f40d39a20e45619fe18d7fa88f80c1463d34a617447782a72ea946e85666b6470dcaf97229041140e6e163557a481ab7e68ddb0720080683ef0e17da7beef3f3d76a20c1b1caeb411803c7b8f8107fec7903ce8b972315f8b487f378729fde55f4e37f784ea03e2a2cbc8d23e94ffd9bb2792c202de07bfa9fa570d59da8a2c9aee2821d63a22af570505cfe250b6d2a0f2618ce13f8f76ced8cd25cee3f6eb7f73d9d8cdb87691da5c7e700868e3416cf19d9f0a0d6c3d4c7d435c6060f69d70cdab956344131254f9e25b3ab3a2d51ad253f2b82d014440a002cfaa1708a583e00ff1b7de52d6edb5ffa55eca55f14edbc3875d0a1e58d989bb69e73ee15e59e7aac2bc5e1ba58376c1846f6adb09f9e1c7687cbbde78c5e443b0317f76e1ae9a2bc85bfcbf65c1b79e36e08f71046fcfd13739037e45fc25f70961083925ed08a003befb79c5cf56d57e9da9654b7c37cedadd9d35aabe5b155b51b3b0d354d9bb880f01c9dbeeba43ccef5923e1822b9869a67d06dde5d96df76668eb14e1d2be2fa04b2d76d03efe3cad2af628c7d115d0291c98f6345294681d70e2bdf416baab346b1b49dea3615ded549854f64b20e15e73ca24effea25da93f2eba37b5f47ab32416160722340d4f785c9bea16464a08ef9aec8763276c837dd9afb6c4d650441c39196451af8865042f1e8ab5f6d87e032b2b0ea8ec1ea39c320ed41cebe5a097f4b32a403efac6dc6696a1dce48f9f2787549a974740c7dc9069182b397474319d6ae57dbaacfdf92a98f9a4a4c7956cbc71833507df5794fbce59e4ab38adbd96f659269f169613f0dd63646f82eca3b09d1bd4266a63574ca10e32a10a3e459eb36e4e4cdbdc7d87fc1f38007eae0101e182d758bdcdd2876a14fdfb0a2f51f6f9c2702d9d3d8ba1ba6b4da527617f05b5111bb2afc424e0f84fe47697485e690d162b9e210b9068a18f9729ff1e0255c38529e833cfcee2d42393af14b5d9c77d0bf3742593403c57455c3b2a3a9c5bfb119c5eb2056d259b04f7f9f40998f6765f823799472ff62341bb9078c9c255fcd61e7f5d9968060baddcdf2f3798a8b666f673ffc8f6c067fc61ad0928a57524fab7f26cbb8e7a7a2795da7e56bbe709d9f347d20cdea511171088fc53d8a4a243d95049ae66b9ea25c68fc710941f8266002171f524d5911c7cc12657e4e364690571eb1a1a3fc1b0f91a4a72e453c104b0635f60b129bcc9b4f475fe151dce058fa3b4a0350c1097cd69bc4f95f5470de40ce08cb678ca182982c21b6bd203905bfb64c63213c87027610f76b3191c5ab3dbc0ef6b6e9ff5680a8d641d37bf3b19612669f87bd870e2628800675b1ce7fc33979aa80fe1644e956704e5fcf50efb593838820462c053d871479b4ecc7120080d8859101782c36890f9f7bdbc7c94dfb5d21dd298093b719dd5ca6967b107222cfefd475f012ff405f3ba0a3bc2127068e0f1507a1b79bc6da9a5310ce4cc6d8e48559cce6aaf282089d0d38a72aec9babe6e4fba560a6f471afd56ac232f18ce813e47f6371e600529a60ccad3e31a560aac141840bb55f022b93e73821fca755a52036ed1cc2b34d5d4257bdfc57c2b051106e9d95998cf9bdf43dcddfff16c22fd2f3c3519554e54d359690f08c442271777b8e9784c37b389e208583551db524c0ca385cd42eab4a5d176907e8ee272657ecda6269a317edab2db4e71db98864aa034d1add26fb38133307c6f6cb1b0d814e65436773c191b2b7be63a8d49c70046e4f601d8c48dd61315c5f0f24cfe2b67b9435f9adcce4212286bd33640ac956dfae6275aaf97ddd479d4e07e5be4e79e17681f4a78a6c6bebcdf479ace5ccfdffb5feb2b1a17e7f8d3dbc91ad47f7083dd4bf293c9a4f7b6b1149dce41fbafd75b01585c87484830f06d9500f634b386cab830bef845c5d45f3419ca3d2eed612729d3326704e40dbd1d276494b1e3c36fae9d538dcff5c36cdb8637dea4006f0b6260934fcd34747650c4939a68ce3dc6961b9d2e8ec900eb4910925a2c2be58f9577d0847865067f3cfcc909c443171a14dc11a1a76b73cbd0e9006c3f144766c38b6326807682d44a9789e65c1462ebfacda021b2e11e2597b79dfeb18a1a4afc579d8893fad079c6dde470391ef2fb06b07de68a70bf51db15ac410e6a1a70a34a000cdd98153a421a7ce6a13bd792fcc6a72cc41f75856a241f11a29a93319b2bd52877b5387dd80124091c251ad6ce56ca1c1e24df350416d055aadd9d5c7ca9924c730e69944957ea1d5a9452035f80f61b071495f17fb2c0eff09d89eba43595e5fc4b418d15b5377c02df4bced3b12a63d45915527a5fa3a4baa88c942ccce9654a43f782518bd68968f3e75be873d7b90ddbdd53976b3a06531bd604715ec00c4a254fcf0b5389e2a8c5ae601fdb5266d67f76cca47fdb23aa95e6f2a31b360688629f730a9731f26ede290f45e7726ab584e189ca3bb90f772fbcb74ac6dfe5b93294a56833d3e0f2e04d9f179c80ad79cab68b771300d8bf9cb809ba684ac391844c717105d8e0136f429b9fea22e100cce52ae0ab8731cf8827dcb185b41e579023c77b5e66ed51174656a80e0a7601479f36bbd8da5cc4890753de294e23857af0bb8069592d3b3f1cc72ed6e1e76667a435b180c92e07e496d3fa6002aa15c9466c044090a51b3ae0bf243822fe9421fc5fd84d9b555fbc1f2282491d954faff563c52d7218193caeef6ef4395b13c5f24e4b838bfeb24cc7271fcb73615e1586ecfa5ffae025e423bd0e07b82e9703bcddb49ee495675ab29dd0f3471e2328c9deb32c000e6a459a60054ab3d92984a7e32c9fc96ae3c5724565a4eac42c984a4b822ffff585cda8bbbd6c4fb230f0ee3b4b0c9e887d732d69632eae403057a2571c068a5eaec96822ba1e1110fa7c9401f35402658209af48ad77fe0304bdb2d2ab76d69c7998d2407d38f9cc0a7180d790effb242655ef3768d0c9478b0acef56f0d900419d12ef806a63678bb06d65a97bc4ad424296581f06664165ca39570c74d2c4dd6c91df99fe6ec3852470fbc6d88fa817701fae72d05fa0601854543b2af40a56c80578397f28477acce3b4e3b3d717d33c093aea208ed49129d0217c9b551d92fe1d065163ab47bd8b9749ec0d3eff657fb204d60579e8aeb7ba3d7eac1a2369402362e4316b2367b18567d0a2afdffb53fe931d10cb6d10ed885ceb984cb1874e2f6ba00763d0881016217a155407df0863fa1dbd69bf1a13b4c180fd99db731644f8052243f26f4b39e6973e31c8b319938512d215c49696817621658286a41d314cca45790199f616942fc47dc7e24545208752d82a8b1cafd388dcd7a28ff2c1126a9fa6978fe14b4cbf5c289e2d20fbc893357e90422f6dee40d80fc7a1901e03c83f1bb3df09105e8974000ff7572818c1f2b4216936bece5acef94f0f8ab81d426af4092a0c2b2e8178463f356afd6299fa4377f2442144dc28427d0817d7f2aecb92f43dd8e611bd0937b1ee8feb791f3ed9773cb9ebf062dd6ba2df95b17fa52b8f1e9290f54856188acc7006a6a499d00be911929a430b07c98583c1b48f260a96c06611092b6f92c3a0653a57a7087e837fb5aadb4eb1841d6a1895c7ab991d3e5ebc5b6ebe5cc8266abec26a00f33e23b9557628ac7f76cce957b728433f975da5e4c5b4ea2bf72437c5ed2a82775c232d4c41db5bb3360aabefbb522de889005d1015097727572051f8f2143781e607b882b57bb91598355698e819acb47103cf369476c021b5b438ed1a8be449c3654bb95b35033f4dd938300ee40c852fc5a6399b490d324311344b2ab896f0b412e0ba9ba0a4e16b7b55d1418d2673ddfd05c420617e7deadc09f695e433d777aaffe4dad0befe2c8ab701483a2ec50ebc67fa67d7017d9434767dd40292ab34aeb8140825894c7b99af0dedb9323f2698db0138b8c6e0e24a52bb69ed7ba69a1071ec3d9e818ad085f86b76d33441c269d9a2f2e871fcd78f8ab7cc1b6c6c22e41e9aeda5d0f38bffaf458145231ecfb5586957eed3747a000cb7b00a62edfb4c18546eff924addc3e2efd8b42a8678201de4299cf989dbef6430543bad4efbd6b319e770896d7e8c353c9d4f2dce511e0cdf8c4ea6ef38aaf41bfa082bce90b8debc51b23fc12d5dfdc2df4f1ad90917981c0519e87dc86cd4198b169280e7b00b967f0ced7b3c25582e492751f7dd40455df6e5bf6646fc60b9b6669e11a19d305e53e9afde79062c97b146662fb30ce50c709686aaa48ef14c6dccbb086e04d3704d0408f782f3515aa22441c2bd7cdce5317d7120df4b8c82f49b75efd7013ac8d2ca4d8c0f8b0d9b5dbea13df6ccafb382f8709b434e3c295347ead0a748e31201deca7fdb744da9afd9263feb6ad488c9d13fbf72f60661377ab31cca5cbca74420b362a1bad1b72da5d34b60241593a5319a2c243e2039ca4e79fe0a517f3eb901570ca7e0f13d69f0e9a5e516c48c4d5226c2812ea5ca79915814da6e549bd178671141b3939de059e08c45eaf52a40d79d2686263fc0f7b75fecdd87a5f40c04f4510fb32bd810698b85d5789951ebe4224834e0d1927bb6d2b59e9a29cdf187b7b8893682cf079b82ff0b658b5cc9c161dbc58a11e3ff99263d599ccd31b359ca2ed1a3abf686da417bb219e4c1bf812a7efc0a51a060ca335d120a20a5bcf73f705df4666cb495e89306a656a92d5110b84353a8d0c8f3400f3050e366922e26f8b27076376c600fb4ae7bc3f80ab32467456c2e3c937870e0ef9eb4bcb877072f33cd8264f2b3d80212219a490067f0e97c7baf3c60f1b38626cdcaaea8b2e6d2db1d0e3df83a0959bd0b87f79db518ddb820a4a7c24060c7d28c4803679fbf41202cc4e4b30ce248259aa8d29ac00f1764199461a40e5bb1c668cd3e5432bbce12bb807b02f4fe20bd7767823756ce527d7b001c71224c6863557ef2b1704a1b13a8b9da046ec1caed2ae15cfa877fac8876e016d5466e7d6ae73e8c717349d5120e73a3bdfd9722cf5b2bb66b230cc4e063f6125d1c8ee2ef6228bd2b3919fad410396910361b4b26df5eba774d489b238dab49d7dfdd273560887ffbacc6755b5000c88c0e1eb7ad4cfd8506283108a489d2ca0878b6eb29c40349ac0f15c28b92acbc8e08354b90720162a9dfa1f04fce7d8579e4f09f9f8a83274f14ad9868bdc1b802eba68252984cc063689089d7513f2fda648d92b7b1b78e49e2184b0b489f0332625c45ab9508dcf5e81fa7b0c54c4c8e3b86d28fa9eb98bc7770892b771a58f8c5e834be9295e84ce3cde9150d732dc932bd943a2a422c107fcf740e2489bf02757a2597e80254eebe95829db39fc7c67042394aa31b04e927dc596c802c50c58b8b0da2c21d51d9c4c0fb9ac1a4cc7656a1e5feb362257ff6c94b7ba423b54bf6453de72160f1284c8c33d1d826764cdae640249f1ad45b70dab87a85bc2d7af67d2109aa7cef1887c8c0e25ed3218118892bb0dc84c4349d2ea564b6553fa6a383a48b75bd04a5b84f3d2cb2d8a7331d01bd6d77f5b3213e606c56af22b65b8159a2c68641e99cdd0183e5550aba193d18250fe8dbe60fdb3a61d1c9731c1c1d0c86416e0d0665ccb33e98b563ce354b9ccec58dd60a10b33c419904f3c17033e161e2ebd9f314cd956f5183298bb764dee57a642b150cd7733bc9413883525db786e3778818d2455bb37a3b94137ef4ae9a514d7b0ff3a7b640ea749daf5b01edb6b275e3bbdefdc1518690c739a1bd726bd18d59397b95f3af3b1793d6aa8eff106a1e3b703fc22276602670a9740fc1796c507b269d638ba11f724333f0864e172cb314999354aa8ec8d6ecec3ec0185ba41ec308005176f5fe65c1fc406b86f046755d29ff613f8820587fc7e8940beb4e3798f6f4f7e6dcc84558f36eaea9726d8af8fccbc3518a1092e279702619f66fc9156babcb4d345dc7d3a8a890f7238429a155f72d17c0cec030a7075bbf26194c9bb9f4d82bbbdd59b79a414707db00825b211cdd2d48cb33dd67f17a6b68bedfa5d5104e70f18b3034f8b2f8eb91a213bbcafdcd3a7bb6b9536ec944bcfc1f5828db284ed1234b90e5048e0082d4133d0b3987ea80e4eea4be0046addeb874d5ac3a1897cfe0274c48807285807c82419e551678f8047c5956462334b75ca968cbe8f5c67d4acc3d3ad2e1da7dc28a20c8d56be93408ef21979fb69f88c823e5714f77571bda9560f9bf278e1e349fb36dfccc7ba28c5caac321e9762c125ade8232cf5918c25a98923138d3aee09b44874ffd8837b6f35a4e57c4d9bd0d627777f369d1c3e45c1a16d7a71cb350209dd28eb4ef1693f47baa9821f35cccf77b9bab0b81ba55bc151b4e2c14fc94bdc2dc7653ce3e413e7a97f722647b91e1333427e9731d4743d65d55d30dafe95eba6d91b94bc7086eadc9862f24cee379b006badd4c69608d36127aba99f84575fec37f3011f3499e2f73712d0b34ff1e7675fa1090802715f0b81c4bc0db5bb2814dcd9cbb56438718e7b4bd1645f53cf1004c35f8017ccf9c419eb964b9ac4d3c396ab22b3671c033404d4c54ee20aff2ae0f7fcf730db98702983db7a23ce9f89bd37268c8ef0c8d5949abcc2402ae4fe3c8ab1da425cb4d1c8a8fa045ded3d8d3b337c16fb372483dffe672df0323373405d8cb6e01de064298ab40c9ce187d4e3c173e8e4e021852c1d77c0bcad976fefb4bb44c8c0e44b9cdd7d5ff17bed82bfe686cd3d0b9158ab15db467ca19961b4270b3d0d31c6ac687ca354dff653ffb5fd87a5e3544892e321084c310c2f7c4a65a20f366150a198224575c47ceaa29ed641d10eaba5ec9a744dc120e865c01237e3c9da8a796ab90cf10478917e59ec1b9d1c7a6c9ca28c6868eee93aa5233a5312c02fe03738d4d1279c6de9eecf1321812323cfb52eb418264c033c0792fd835a42554fbfaafc7adcb9973e06d91e91a57d3edb22635da4a329af1ff8b79c16c87b28eb23ddb27b6e241e7d1bca83ff5c359e5d5f1600d911e612cfcc941ffedb5da071535473c33ec9f458789412860965afb8407ddc54036ea89fe5a8681635a5dfbab86a8ea0ca6dff57c8d8591202f7a3559cc68b7f018e195e0d58f65667f88719c001aafa0101a6f68a91c5978c54cf6e645405fec19f3e8575925fd36f18cda0e525b3e7423d0668c1c7ccc64d39b0a65c885ab988c3d6b90549e358df9ab68ef1ff203fc9e693f1957c553da058641187ed72e27556904ffb9ce35c2f85edeec03f0b1de6f961bed503a1a40f2634386dd1e22c951fb737494b46d51e23644fb3255ae1f7e386051de1f5362f7bc4c6b48a30b3c8a35f262bbe6a2ef82a81c1c586afb262ce7a8373a381bca3b799a92ba23eef6e7efe961c6b29c4e8341fc7fa5cbd48d5aff5141f8480edcd5291037dfc254299efb55225b0f1a3d861a9966f1c2f22fe24863b3393c2f86ca37e7cccd70c77298a2748f929b60250c794380eed6178173e14cfdc21f52a34313600da26a4a1f0663dec8f436af85598fccc34b807e3b8f354194140dfba4be0fb980f30b789007b24c2ff7e41e53b16ad762cda575968d3f202244cccc91f60989843bfbbf8baa5603aa1f91f36e71e68670399ae3f416b9321dc094af8289c412dd90d8db091cb4311d3cc7c9350b6536ccc045f0391c6053f9cea2e10c53e8f41738d9f098d1d80ef76d7ebc8877946c9e667e72d2598d297e96997f17443c09689686e068a4f65de7b590318a6d7a484a92deceb9936aeb5b99e125eccba75936db6a58c16e5ae3e7eff25842948b53fa0b943cdbdd05293db851aad253a70e2d86191a3cc8a35b9c1ef2a41ba7872b68dfe599507551a0ad460fb44bba45b93a79b9bdee5c99bd8fcf0a5a2c0b8fc1f342cbf8cb15e53070e9b5536b85db3d57c03248f841a6b5e297b90d04dc4e387d304cef06d4e88a60e01d054150f85bbb3bc1be79157b9b41514cf557eb213195c62b4d24b5058468cea293020e3bf05613f1771fced943325340677f672d328b8006b367840cefe6d2895b99727fe4a43807b46cc71ab88fde8ce78124511fdb90f268e35ea2646f9507a326493ff07510e5d0728233a38f526682175d4c1d7541bb001947c19e42dd47788cd2f2f345bf5f88930e6eba48a7592d9ab5b3dd1a0f1bd75bafae855d4bb3e3d37d8bbb58916a76b48cca0288f6b9faf2ea76671ad2b372e86a4ecc63f5e4b9549bcaef1b2e1df00e3489509d7f08780430f52a9515c7238a6f47b732c25884994b52a2c81a042905bb22fe75e75d7d34bea33ac1f489f0b6e3bc2dcaf8d60a81d3b5e262856907218fc3471c8dc11e001e07cfe7c9ffa3b0ebd5f82270e0307833ad80e1f973266eb072bdf874965cfbb20d8afb5bced7f90aba14c071887ebfd00d68e5ea2085c1ed7d6c48789e80385f7d949776c329a5a268b6f9072c5c728e71ef24937b65d33a11d78129750934d00df36ee6ec08c920c29b8749b253ce219c916083922db05021478504a45bf91d50c9741d76d31be04c205487d76ec1f26d349bf7e937702cfc8da7728f95431c9a0c1e1a4720f748f34aa816854710161364ac6b03309904ab401a82969d6c4d95a3b8c8cf794b2f49a09b96f452347a37532a53d6f3a0e99c9c23a02a973d3fed523ebec3e8ed19902749eb93fc27ba759a4964235f8f4d8fc20fd034c62494cd2c31e0302e6464857247e28236b4ba28782c727f8f1077bfb23d62e26bd6b3049502f7f50c9709844ee8eb26b32751bff8c101da4e62bb6eb59589aae13d1f7e00b141cac45fcf4a1b3b752b97f8ad4a427827d5f7ad7727920a340d81d23658f0cf89fd859642cb4e2a30997a447e336483d41c371896b97e324179d0ea704c710100fb1906ae0e4b0b7ea9d8760852c3f16da99430285d0b6ca4320d6c1345d848136c6bb1f51dcef11731b397fd8153e05a88ca34a6a4cb396a363a98f058430c09b2b078b5f0ee25e480c6d3e033381fc5da2a8a0b94a1812760c8aa83ca4f3f44805b15fd1530495043e9fec4296853ea7955839258c8e3cc378e636fa13135646f965f3cf21f2982cc5f3873b5e75d8d7a2ffc14feaa57d4245fedaa3b6f47fa8d31f31ce4c46707d394077d2617b9201739f0751a64d28287f4310fcccf378c4b24689d64c8bff846dac9f0164d02be5c7a502f9d2461704957fec0f454b4ed702511140c392019fa421128dc148b026302ecdd926f3ef1dd231481e3e1e44601b8be3cefc561fa26a831ce727f8ceb09543624d53aad9dedb2e211574eddcb52121583e996ecddecb0a64f6ef938f00c613e87d73f28b272582459a7f8b7baa5f337554dc13253fadb72ab17f62fa1b8d60a89518a6828e4ddf0718faf5c0d36f4224d7be81a385112ecb7fe295dd07417dfbc24dcf9dc93c19a97a07e0246201c80ed7dcb2cc6eb574ec40e8db960654f5c33483f8028a9c666b79c8f79adda8b73bb7a48adf6a78e2e1ab63a8be38160cddabdb835b0af4640395ceebaecbb141e6007410be3d2a536e4e19eb1d72a9fcace237f654005bde6f50df25fdd54fbf0e13257a5e79774a728df8bfc2d2adf1f96d3196fa20838ac13d293e782806195b70409b2e6319cad1d5d0ee317e529c95a7f2e1d837f29b1ccaf172d7a8de0402ee4a1b1632159c55d6d415adc3db381e62eb87eea720bc80dd40ff4d4cca7a1c14149f12838714fa2d003bfb427a2ef7babc3d52d4ba37e5ecf7f122d5a1a1019537d1894ad1f765e97a0d689268eecfe15fc1a3c52e8ec0e57f19363ef7322be9f66d24910219f27ad708f2c2bf9ddf3fd5e83c4b6bb51b300fa8a11d19206ca580883254e9bab72ce259f02b6ae541597de8d0778af0dab05022bcacb96b2398b6f1b6b530b4d34ba922a5122f28fb5202b9c95a3ee3a711429a3b506ca0ce518b781f08f21d80473a7e8f8f3ed289f33f01cc5a66f331f9743cb1a02e42606348c4653a6ef192517e08a6fbd71c34aef080017e23d1e8e81f26ded8d23a2dd335f7ed1424d5d8ded159f240edb821e519e94e7d7b1d80372fcc87637ac0ea7ca6e83ec7a1dceb6de38c57b8de54edc4d3530e09b7b0643b86b5879614a783d913c2229eddfae495bd915c6432aace9d6cb50e18f70e2a077937fc6934c1848b58467127c15028863de21c2414605eb238f92295f20a8ff17fdc17d15f824179f5760bec478c62bc16a5a6dc50432db41366398f1a2345d84be4c51856217b98f4bbd5f164ecca18df3afa0c51edb85b4fc432c964d8b5ab5154623463b115b58406056c039a9ed9ecaf97a6cdf6905fadbc811d8e92964defdd0eb53107a9382d5b0d72370eb239cf95644302d9e3c1ba90bb832749115d7853009058a6a161b78466be7abb1ab58e2d4a63ff0d9a9d9c383a07f5e475ed4060eb9e4244486e8c8360c8937064943f2355542b76a09cf8bc0430d1c523f9416885a365e7c699f78a55ea517a3cf8b8655c8a64b23213619382d9d75f6fa2293e7d73a9965ad3bfcdd1c76132b14da7d60c3d11d2b36294d902cc30d5c4c991030a4fa6d68cf73889504191bc9bfde171e1dc3389e6aa7eeaa2d18f15edaa25a4e5cffbeeab7ea39bc9867bd45c6eba64153f6b7934904b990bb3e094d6ac92dcbfc7aa4f7ff7ff60d7389fa08fa7c99de3b9852c8744595d4a7aaacf29330fad848999a382bcb1ff5370093d2a4d72bb0a06bee9e7dd11abc39c6967e1d5f32f2c59c0a6658cb48c625da18f34e71c643bfca721406c8a76f7946312c461eab34d9849974b36dc4d9b8ce2aef35802fd07b935ef710aa71abba14c30bb4fca63abf6a0789a042cfa3b3e509168bc195015314d8e975a395eb02164a1a3c6955eae1b34ac34c98e6dad37094ad094a822f5404122d0fc417db32a8b282c16670f493a2579b25cd13458e795e78eea46adebf3eef4fec6b051d3e64561a9fdafe2bb58f7775284c1d241919871a53afe6c2afc8bb4015d8ab994bc1e67cea833e0f4a3da2dc3666b3414fce7ba51fed1da6974fcf0c9f5bc8c89df8af3c44bf199fa046dcd43f101ecb981328c8b6d5e4be8fecdfdf416de180fc896b8534b471d03d99f591efe1727cd29684273443a953e9255a7f7ab2c41e8db309c697e0ba81a23e3da4e1edfb154ec60ed0bff6f7a4e3ddcf1576736ae535607a55cba251d44c2c0b22363a277d0700fd0fec7ec1042ee106c8f283d6606a620f40b9c4fb25af50e806fe0a1184399a1cfa993db0a025a1a21808394df169fcbd412df7d7109df09d5b71583b56db9cc5ef9114066fb185263a8014f4ee8117426cb4366e76d8276f979750e98bd736406835509d908da3f9482c1775c7301242e2dd9f66d19f2d55f0aefa5c721f77c10663565cbff408e56212773bf902f6bdac4bc594adde1a8fd4133ff80f12ab526d81b43cdf6adb5ffbfabd1b898876ed0227e68e74bb59d5f8b5808579b2bd91d07040bed70086aa94d083708e661c858d5cbcd4208f2333544bc76042c7b850258eb06140e82a1112e7448542b15a6bb43eb564a1fc966b232e7b2fd914e8da0935a5fbc8d5a1bfc1109c125da8f8d4ce4985b323ebe2e47bb8aa94575dea9e2ab12e8e553ecc512c9c83700fc75f5fc7a5b2e31feafbb29b9eca938fac91697958c991deba6c90cc4c560a655a73dbfb24c787badee6684df7b8b5a2a6829e01c65e4f891fffd2aa2f2f457e17ec51f130c41c7a6f9fd958db9c7f38cbf83c9dd6ea39c4d15826b279d9e958a06012c7355090c6f14e5204a495525bb0f12749228b8b3b21e2ca7d499c506cd94ebfcfa885a931f6fd54a804a93557cbd90d70a7076f414562132b3f286d645f33d5ccb2fe2f92c2addef3600ffb5a743d0769df80a0fc7d19efd535fab4264735c227b7c884fa6582eac73cf5fe280c5b36ad74241cb3caf3333bcd0bd16eabbefb999eddf5ecbcd07d28e1c804cfce75288596db0c4392b708886eb2a589147fa21242f00e4a4a81f16dfe0296b7975c9cb9e373fbce03aa1dab60f0826ea51966454f8f603ec3398d2e6c7a2b23463771b49d040d0ca5b1575f1ec68df469436a8eb123cd6e26c18a459fd992347d33eaa02fd8376e8c99651bb0850dd0b89cb40e4edca3d0faff1158af73f0b9223fc64e209574da67e28c4f9f5ce6ceedd1c4db90cff08821d0aeecd383ebed18571bb94a2344158fa3737bde8bc3b5c3d83e89cb83add11c4806823aee7fab913b5f3b0f4328c397fd7428dadd73f3945fdeb3405734970c874b1b49b4bd3b42cf97c1dc62c5cfb4a9320ef4a6ebfa27a7a9f46346fb425cd34381a10eb02fe87b20e6789b238d962fffbf08aa683d2f0d34abad4408cbb6e9907341c2aa72c63a5ba17839eb2033b97521500dfa51e1f5c990af930d8c64b7adf578c5a1c69b88ca51bf82796802f30c86a6749cad4e44151d61fc0673bddc5e1237aa9eea1b697da4b4c6993cdd2ac942d53a1d536012a370fc556cbda0240e49c733734c448ccebb32ae5d885477450f27d601c40e3ab5efd7f84d5414156bfbe56b696987b5fb8b6af82d0df8378a1695cfc3ea36507f3d8eef768e73cf8d84cb7cecbcd333b658d77af188cb7bef97fa1de05ab5859b831a7a3c3ec41471193f78456a8ef783a21fd2f01c62878bdd6e5e87816ac162557246c82324801504d615151ff3f33ba021afb1d59d8142bcb1287c53b2926d956090040b26cefdb4afc8a1250fb7e06ab44a3b5edfaa5674f3775dbb2c5d9c6b84e0ffaee86c4229f6a460061f55e7dfd3d98241c1a0b9833bb81490882b4ea48fc1253fbf5874307479b6f4597a14b6c12ee947451d32211f06b2a8ac5b45ce5e07f3b1ee4809a37dec245a9aa7647f719dfccac48cc259036016f7c621871c7145906825d782f872c4eace098e559cdc86789d74bf4ffacf1084a3693d33dd3cc71e8f776c7326b10a2ddf803583825901f9e79afe765c743514d77b74b7ab93fe6f73418c48f5974f78785659f22086c84236f015306b1dd56dcfe67e5311bb97d7ddd45853a4d5031091c6f5662c6845b97a0a2309dd54e1176b764755244e2cde52cf897c9dab90a143a34d8902e0cce30ca9479ed765f176344689a7fe6ef2861abdefb041bf05d7ebeb38ebb022704146f1c6d831ef73540e13ff3b5dfa6c1e63a42ebed3298a4906195ec149ba87e3df3a51eee0b477ddd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
