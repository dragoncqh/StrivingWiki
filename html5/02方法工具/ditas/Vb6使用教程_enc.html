<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"479c504428daed6e8ee3e9725f14ee3223757a08ad755588221a7e2ce90e8e9cb8d440af7cbc1595759315ba78e5e4c57ed7f7d7e92db292264bf17dbd31bde354baee045b4669770b9b48b49f0e8a1b716ed6582ecc177f44bfdb29f6ad2a13ce985428cb7e1d1674e0b93685fb9b5f7cf5d576133121395149f43724f2df7113fd335a529bb931ef088468d1168a44ee96a4b1a19a6ffaf930591e93642411931872c3809a951f3492e7fd2a5fe727f1c23218906f511b242395738bbb62d11f11569af16eb544c70e4d7ae85c4a9167104ee504c86ff01d59258aa80ed16c37aecaca047b562284ded576f81146c1548c7a17667e83db61dbfd6449cc183af9c02aad33b476a2965d0d3bcc862d79d9e2a717db27631a25e68df45a26bb5055a8a3abfb776ad09116864065bc23951bab8ce0ff85e28c1f7c67dd6d2f53ee07f6951d3c4d6646f17f1045f61d16a4ea85c30faf8235a2449d3eb0bddb95f19359af51795dd315e76a41da772bb34b290626f44d88ddfb2e88e0b1dc7102dc32abfafcf0fee3c93b17c7f08ff11bdafe5f43080f565ef2034a9e17bf754af1b3eb67a931347e7f23c916c2438d9a20035e550db18b9f4e0c19306371fd61b179e4ba31ea39e8f83348289489d3a2b71c8570e20150122ce000a0bd43d8244bdf51bcd8f5a8cdbd92eb8537b1eab662a72069860221e93bcc2cf5c48d043defbac85fdff3e37f6389c43ef88bccacc76a168879ddee29eb72da3b71bf49c8d2f3ba56b4b05a3be86213370879042c5c32669a9c13de51caefdd541d34b4a043c103088501a04ffe774295f3969f6412a6c30fa9425bba0b7157791f3b61fcad7d4eeee81a38d8ac2c097add1c7b01d08f0068aa94892b91401a5fa6a8ee3f561f4d90445df35a3973a025eb2c7f6e8d7f3a81f9620f26ca15f49975c3de41d980c56944ce1533742b25435f753b6f733bb8437861ad27a62d1acc7a3f8d0fd1a4e720bbf6686a72d8d6a761387fa9e31c16e5d2ed247526c6be60958ad87a53df1e12a0a5e23ef3821bfe1c18c7b4c02353d5bd438286b70c7e29e19cc55226f02520f3e20b72152134730ddecee2ff6049170b415545601f4ddef7a0e7658e21e29d0f83ab559d138217427a8daaa64949c00373c85155042a321cdf26babc3b161e13b991793ddb25f5d3b8af9a27a07e85f172d85cdc055be5b11768f7e0728e01b594943e715dcc7fba32859048bb82da5b568445d9caaf8bf6c75b23210052ccd1d59d1232b864099de13fca068fd4b3582444429f720e2ad6ff4b2b20be92b647125e2a2d51fe2158211ebd6fd3eb6369f8e3b9e6ff1ed16243399d7812fb291f44d1085d16d6875645d28f99a7604e213eaf917662baf2532ceb610e45aa2890d53e05d1a9bce23eb713178d22af7cd85c36127bb6e3ef603633f0db0232ecfad6d2f2dcd220b892a9b8f1484c618c31450896b3e426276901b762eef6ec390dde8d82533c96dfccf2b5b0b2477564f68cf7d4e087dacc4bb1e9424cc75bb8b64fb908c03aaa772ee2b8813a0887fc1d0f2ca3b7124acf485a5e061d2c63765a5ebbe109495332d0c2ed2a6106b1311f47224578cd6ff53455e208bcbc38e0a4fbb83de676b8056f7149db1a3beaaf2c139ca87b1ca71efd398e430d3189e2356c1cc4b3eed5b1507913bf104e6784b2a857d5087e23e0d2ba4da879133eaa6bdab20f4c4987d4fd1a91a8d7691e3a759dd05fce2c8fafec05555a9e3f26bb5a8889ec270650591a3251922f41fb2e91761e241d0064c6bdb11ec2f2e3f53ff41033a0edfc0e3d0c3df7831158602c47290d2d06c4c367520ba9ca286ad85a47a7d45a4d51f35faf60ce500e5e329bb6719c75fae9b586a29c2ab8c2b907f0139950f390bbf3cc1ae551f7c74a7fedaa645aef93ad7fae1c47202cedc232ca0111b710d4c90d55526a1619627acd03b8f1dd36e22f8e6936cf923c0852ef52b02357b796b0bafc547a661e9fd38ac0b86aaeee972db28d19a1f2315eca8728159eea0ba7deeb6cd686223a583bc42df127dedd0ed642f50cb61df7230f80bad38bba0b75ade771f6d1356d587832a29e429df4db0226695a34882ce343628a7867a3a69ed7622e1f4d11d601220951c53e435d3a7fcaad6fda5fa39d33e1c720b2b888d40f45271d98586ade984dcd932023517fd100f0593c851c11e113ce44a82afbd6e9929d08d7369413fced721b3ee49b5b5552fd0b02aa84c3b5c7a7f4a39bd15f4c77c57941a16001143b67871ef16f3dd187ea3fc585eda099f39ec0dfd92a6b4a26da5a50e1e3596525d767cd5716d82a2d2568cfaa566c790887fe6601e36db5e37cf22df9016f692232c1d14a5f351157a0ac2231fa9c5eb4d38d9e2322d3fb92486a29aed9ef8838fcb7c113f838e25a3ab0a9aa2a2eca5bd66c7d9c34fed6e0cadc0bfd81e2918847bf3f8e63616da18b33d98db52e3bc24bde7336ab48d18ab3200b0a0513e184bb6ccbb749915d37ef88e5faeb85520f9559b9ed382a794463071bfe620fecdc39f770f8b03e5a5751343ec78b145f776fef9fe8f524f699713c3e5e274d9f14f8ffd8d83fc0d46cbdeb6ee7e1e2c61381dbe8436d084e3e9a3b3f74ab71974e405c69fdc0696ec00dd5bec2756ed020457294d4f3e2b1f73588cc3abd371cbe12ec00b0188b8ab95eeb0765ebefee992f037d343e025ced948e33f63f1e7524f8dac53a8dcea918a58636aa9c334bc064061c5a01182d6e5a604460b2a2608e76fb05a542bbb2207ec61352d4c7489eaf56db4d3d87f9706482e1c8ad70e5590a4c105cab328249a707df59bdf862c033b5a6a11e41b85316eae5704ea4047684c27a5ea0788023051c42954b6f49d10212f9711547caaca69c449bf7812587848c00692863e4019333012757efc2a4bff249aaab7313a15d303808e669fb24c7ed44d68cb6cb6241bca36dacf27bd69eafc5a1aa404deefc9ba64350f1df7f12d789face54733e93ec6fce8fe49e5f4e70c8bfc82fdb7f24b7ba89a1d5dcb2f0ed2daf5cd20c0577bbdcb68ef02f8ac616c6266f891251343b51d252f2abd0cf6082748139dfb6a0b8956e7a529a4a4955c4235b844620768991ef3dc60a224cb6c34105e50d77ed21f51c6c7e5172d72a89a640e04e181dd6478df76fa8bb7ef0274c715c1ed9585aa9921e04b3260de599c0c612d17a5c7b26ea350d78b55c7c1c4d5dc97bc7c966b84c57d2e1764ad58d791ba8f808355ca6bf5e7dd140bcbd47ed42eac0d0b1e2489a1c79d9ea75b106ea868ac4c1f5860216d447b0ae954581fd3c491e2bde26a5263eabaf68b6317a8d3f668324d368986ebc3f61903d040a9cf358ab2b63d494ce11b1b5cb01af26af45bd64b9fe8417cfd29e4621de3d63a3516b33cb6f0fa4f03c7a556ea060573b351ccc6c3e3532fe9523a6059ccf7e6a5107236cf3c7ee3f79d964b7c2aa91a8c6c43126019c3b30d99d31bb91391a92fd119f59a6f230e2222009ec56dd9e6be656d77c2eca7bb1e2edbf8ec2cc5e7d922be80eab25194114567febdcece4dbf229064f73031e062b5e9d632181ff1cc187a52b47d5bda0dba483f064e625a5313f3692fb408896cb5fabc7de8a11a6e80ae5c4e660e819f1735b596632378222ab1c3e8b0331cc4c2f372c55cad8e6958b7b8f253c7fce2b39968602af5201e55ee49fc3b2cb4aa2abaa2c5c8bb4c4d4edaa33e6fffd8342fb35d1c13c6455ae96286cd0611fa5c7bc29df378a3dcb4e93664b76138e65e61a3ce2f2e345f4d2621a3ad8cdc18744c3d1db259612bc88ffd82236206e29c3639f3fa6d57e6f40cdb552e871c3b431d1d5b0c34be22e945ca5a346f01567c2bf4c0ff90ac95ded42015f48f7831cf5b386f009655aa1d8cb291e4117af4123c899b44621909630bd209468611c790fd7f4e8ff7e969e4f117568cdf860dd0fbaf8c393a197e68ca52df4091d614adea2bf39617c76383b6b597034aa8d8b1452e9428f74dc8395fae137e2a23e3de5461cef82f177fbeb8a02e5037c657d4ebe79f9e6ae22418fa534239e48baef4127b9d7f17a7ddce14d74da5c39cf1f25bfa64024002a84dc9eef716a958db7a6e164713841303127027a546f22a5cc10796499db70a425fe2dc5e757fe0b5b1fab14bae1010a11c659a7fb8b910d4a91d0c3894c034f382a8100d1fca665fccf229f0d1fbbf87bc69e805c5ce3545c211887054725d15ee59c9f020c19601b80365b153c3652b5d65a641f232a9b862bea5350e11bc6860d0f4db6a9bea5bdb94f836f80e53d6249e7c9e6087dc57a2c5bd81063634f101ea0887f6d408eefaffd2084aec9f67960a3e5d8ad423a545bbf53d8e9f6a2dd15d86fe6ce52d43f28bd9480f3014de5092ecee62e87d022349fbb906ba6e9d8f395582cb7e7d0095532a659a8b0f80df058e4a6e6d72149200e40dbcacdb32197f1995dcdbae492f14de924a6fbe0371a9b3f19759f5b670bbd1bb563c700eb746ad1cfd501522ee7ad98c8033e0cc88f5563373c847f5c818549814ca2289b3d1e4a43cb587af134390c0c223042ea1c8e22d2da74709e1dc03b012a9a83a31d3b13603a7d32a76c7abc68fe171155852b973f6e419ca1b83319de73655d68d51341381ea37cfc941b1c3cfbf9513f70f508fc2e8784ba8f1072960878174fc2b2c52d360334bfb70d2b08e3dba3eab9fb39c2382ff24fab139ff67d816a1635eb93e819303f006cb9eae853aa0e4a3f9cbad262771e1d8863db33f1ee429a9144492c6fac172cdd79cb4b03e2ec7a871c89c1fa92b017397665fb60907f57d34da951cd999c908880cca4e1e17884550da75ef0432da4706c9c117b12721d86d4b82594519b18c0292745b82ee94b750cd916f7f8a78685de96a0f4ccf117c12f063916e62104a53f2baf2fa7fea19a124350574dde12e55cbb5d1bd822302f2cb8a908543409d7e5f68a3c2a93797c23b5018acd60a86f800280b79b6daa3d79211f710863d0b724ba8fe3f22e083976effda567bfadaa6a9010ee9b4176091ad07c4c6e6a49341fa82d32c54b1ec69d1045afadff105d211491dfd079f7177f31103661b6b8536ac88a7e9f31ee775a7a47c84880a0a66b96055efd522f869dda03b1b0e88d6a62d0b87522cb4ee97b374a8fee7881184e86ba6b15fc4af1bb82d8144941581a3091adb428dfdda58e28ec46485cff5dc556747ab2ce5ed9e0f22dbd33e061751dab36b7044767cddb74d73d1c716148caa4c3bb0e249aadcc1d838a7ad6e27e1d06c213fb5e9982b80c33ae490ffbb6d9ddc4546271d1398af6be99fe6fe6f714f3c6aefcb2927a06333d28df0a44642404d0f1f222a3c464230c7d7b76a768cab757bae3644d28348d8e468efd7597405d94ef433bcbb84150a2e1930405838d1c1a065145af97833213de6e3f0b53542495fa4e9cadbea1e5b44a0a8233753d89d698193d18e52dfd2ae1f7adc42de2c9a8e5643e1117f6e56ef18baddcdb34931f4f72c0928b94777a3eb8b8ee1447ea698017d8f3990504d1e0e535b0c6f066bca033216d8eac0d400052f36e03c89a26b20eb91b090af01120e4b833ba821ca3012f3e4a972c76cc02bf215c9097cd2ee53ad403f8214a6a7f9351a241fb6d7b45ceb7f63b14359cf966eae16c96cc2b63b3f4f4159040d047ad37def08649489883f34a14088c5408be2973979464b133fe4b1b452e6ea807832a94b22f6cf25a8ad8377db81bb23e7f4adfa8c11fe0f27d95d939427ceeb24a2cd56c6c2c8c6b0ba525ce728c77a077ceae9e518a0e8e7d8472062cdffcc1d9a8992993272943deb23506767498f53a108ad202db855a2eefc0cde14858b747f81f9985f6c4397b7d4dbbd36ed457ac2e6d522983c701abeb4c8b0f5c12f7b02683d87f61fc9ce96e19059d3f683fd501d10d9aac2746c762a610c4d5c6bef49e0bc26877beac42131fcf5192edb844ef8440bb52e5b2d6f0edb2c0d008d900cc46d723a4955803965c890b88d249b380c38c06756b107088b9df896e5659a6933733a6f47c415dd467cf54975b79193c825428c4752078dd25c5dd1867f59dd909094ea73d1f1a3662db05bd2faa39803f8f065fac49ad51cbf890ddce7c564284b5922b8d07e3f9f1a9096afc80a04a80092f17642e43c111ffecad7995780b1d0e2706b9f861390b05e0ca50b2592c469bf75afdb84af42e27d3a1fd5c5a7ed3c5081a1019b68ca92fdc01ac96ad35b3ec03c8c0ef9422bb8f31b4ed98da8a7be2e877b7a69d2f1cf72d20479d1f9fd7b8520354e4207f6555b677df5d51b20d6fa432c31e281b50e60e992baf5d3239d0c39c498b09ea4f1f02d4a4c9bb7d6c339f641a537052e648b4e33953fc2c8a7ff5be5181ba2f3df3fe59f09f3277f7fc9cb5115d93b0b9359f77edede2f117da6f00ad73cd2ce828b76c97d0cba2c5fdcf74fa922a7a9e444b433dd51c1f0d4a92afdc05494e60efe0ec926b6e70e86857d61ab3049c46d17f5e448e4b4be2823a01363f234d726fa8e9f8ad6186e8733b525b6872e85791563a1cda1b863df1c5c11fd100c9b8b8746e3de736a255af1467461773e8d27e5f167f7cf13159cc129bbb425b2691bc2f53d00404a1b117a2e4d8a7f9063163289daa5537171a79ed80fddb80b23ff1b4ea8dd3c7fb085d5b60ae8e33cb6c7a5ef01e33a261c1b8a103f1b38f171068046a94935382b3c5948666a15eb77ad1f750373b5db7c2f6d70a211f0ab0f32f02a6bc5ae5803d2f3fea0be8c29b789a40a6e62e1a0f7dd7cbc60d1933dff80ef2e7d993c78f2c6517018c660fc815d58722930573aae5635d2a846649a21c487798107b69fed8838a24721225209f69ecbb9ceb3f6e8643bc46fe285a7fc57ac6dda26d1212f599471d5b91d7e0aa44489eb34401f21521a75898693e6cb4ebac4d3808d8da7380618a215efa258de73f234ff353f32b8ca1d974bf1cbade17dd9ee51a790210d7ab4d26c51b61fe026636effbf66779a47b989600d96e1fb529ce99de90cdafa75299015fe2b28f236b1516e73a64943c41c1189a4322aaf01623347b1c2d968e1525476e68244704182086af374308f62d739abb558d970e9be782300bf70e38909f174e291397045bdebe3354efa21670f646abd459f44c866a29050b668f64e7e5b7f97d93acca6235a1dab88b802ecee866e65b8e95d7277e18fcea1fbf29587673728d62ca35ea2083e7c3527a3014666c2f4c9d9eee7d4e21b49c4931d8fe28e294cf9b02f822c22da9c1212df8e9c0d0f03f2feb5324c9c5df251379c3fdee6907567e4aa1e92e18226e8bad4b626c5d5d52f65a571ab95828531c983dffcc4cfbc8aed11f6bead652a47cb6b403493ab2886357eb232842eb9331f8188e03f38a1f2a380ac61fd63d349dec5b2d37e30081e0deab485e67be11b00ac0906972a2c677fb3f619b2dcc3f93d8633d1f53983363cf8114e77e362b984e93b0d45b42f777b9be0ded33663a6457ce01d6cda004c5c30761da73d15bc29c201dc42f14def085d37a70b6d60440c08c0eaa22537c185d057209bc53ef143069dc54a28e69c22e8749cc03bb259b3bde6430d1eab84b110f596b26c7f170c801e771f6accd212eb14fd1c8b6b31a71f2431862753edea93a07d30e775736a787d97e073061d97c22b7ed67762476e7f6c76e26e2d5ce2b7f0419a1c31dbaf892b002134cdc4905b21dacbc67ae72b429dfc81ca5b40ba96df2fe506318de930e931cde85cff944d602802a792d8fa976e2d5ef5bd0a15d7a1b3a8f0acb85e90fd2566c9c38424382dc19f458d2dd02cd74907a0edd143f35b63b873dae4e0d82b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
