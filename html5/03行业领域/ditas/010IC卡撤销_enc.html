<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4337d70a5d97109c95575e753aeaba20ddb1091bb17efa1b66de0215d5d0ff51ee3ab83b3fcac09c8fce181bf7464ad3524c71b6842a8d41acc8475b8b5fb87216c231c27baa85f5fb880abf5d07460b5e80dfd0801e248a8fbc86ec3c003834ac701a826a92fcea007182437ac9885a4e75dec31d18b1ed1cd715a918e0bde9a0df6d0926cc19200624785edf1b3371a4f2453c382fe559238a2b0e2a46f5ff7eddf354aeced2e5dd4d1066d971c0c74b9ff25cbf4e683efa9655c1326337c3f7f8ac25ca6322c548a2a0f462a871703d20a7d64588ed0baf8e1b7c8cd7d0ab9e6da05b8e91d7a638d5131e351ee16cddb561490c1b73109011c6a1717d675005373dc7c2b5755b5de308a28be9ac898eba7dd9ced642b68d789ed2a0aa473ae9fb231d2987bc36c2136ecc8dd56e9e15021a29723718e5c6d75753b9611770479a43511c3b4a425042732351e3f84c22d5b2781ac8fa744e1d3bf20a952bae6cc07df282e499724d170fa20c86cadddb7868d3ac12869d1d9fcc50ff23a27f74369644ed838513b4ae5cf7b3d75d7780a75bdc98d643953fe794e93fc407347262689acb170a02a36177629bbd8b3fcbf7f2e2470aa3e274089969b374f394af18d66c07a6967f63bc7c2ba3a799221bdda263643f855beef9ed3236c642161e440f40f66d747f2ca7634260f52a262277c14c91d283a8b5a06feeee410020bdb047ce13b28aa8abec38ef0cec10998603dac02519005c9ff7d2c80ff513537c75193bc61f33006524f7ae88ba7c2ca3d9f6bc19c5013cc1326f5e8bbdc23b5c4fc791d4dc9b53904a11cefc20c6ce0586cf624c6853606385e4b7b7ec7520e9ea3ba9df0fc1fe945fa20f604c50c72e50cda10cf3147eed8bbc7f2eaa0ff7a8d9a78e07a6f5e47818fcbbe4855aa149b1b1e7a6a5099509ff19ed628b44ceda93bba8601bf758f9235c036df47200a68af0e2a5a66e02a5c68a540c724981d88902ecc21e03175cef28d6f814c4b1f0df1ef4d482de766376fa05101f0d685d3c68c2ea971083d96c48c30ce812758ba76aaa8927c37a0d9f5fe9dae351ef215a6e754ebd8cd562e19afe226a35512a4857e50634c5074815f8e88c0b4a25c3785bc6e4d62f22617bb2bce820eddb04f8fbe5bcd1c7912346e0902b82ebae45856ece78dd12df680937b5350e25f798be56bdecdad0713603c475091860d403c2c621552f216e615e8d983271618f18117aedce3a3b447fba38032ff87cf70cdfbb3e61dff7631160a22cfc92c33b1791bf0439950b27c4eaf5f3077bbd9395cafc2beb284f5b4bd5af4c3848be5d52502032b3d19a102c04bf42834f50a6ac9b0365a0385ea8a2f67ee97ee76c4bc3c95c1a988aca5d8ea7f0c5ee5403465717a38728a50e4fc50b771cbf73ad2302df3c7f3bddb2b5056b7d77b84535aa12a567ebf559a00b31072e13b09c3eed89d88ed3538775c5e88346dcf8fe25de6666b563cd54752c688226bf4bbca0b8806df26231bc52436984bec525c2ff4f9ae24d4afcbc180ca436a6b0fa74cb47a44c0eb628054e6d8b4952f203a9d5ba6296a8c6de7eedfe81089ef2047208c3ceae282f388b9f0cb9089a034de18ceb7be676563de6d6a24d28c4c685eb9857781e351aeb2ed561d2e6aa0dc4c0f03c03bf14a3546bd2a33a1854cb35fb6db471d45cbcc76a53d89e6853ef360552ce340c5c9e7715e0dcae8372acc8e688e6dc503fe93f2add57172208e38639c8c18e1a479a5555704dee29124a44537c50db2800e9a7f981c481897a986809c2927d3905c44fe65da91cdc6e688c99ed9af041be5649815b088833194aeba272871a5d778529b7136b11f48d56a5fa4423a8004c5784d29facbea228a7b70550504823b72a19aaa67f0825af93c1288cce9b63183c5679d6bcb0f50d283982229db94010b320c1037757dbcb7bdde4a56490d4b4243d99b8771e416916e34ed8949637468bd31ad119ac13c1e2841bd637cdba60ef774d48d66c73f6f8d7a809ac47aedf6237595f9732f8d565aaedd4561df788a0071cb84427c6e620e15799249dbe610e232a0e117b6a297fae3f4e7e7b4c56688b50bb0d3c1f2e3de0555009af2f0afe23b28774599cf5a90f09f1cd415a46d018ea37541e694d130f55c09ff1fb51786b3508686afb4ccc854ac095562bf634fec09c75365dfc183b4bb37e2507a3b45b4f7a55c542433caf44c93e083857716bc093573769b82a38accbc10f67bf2d02cb24748997a67fdae398d7c7411266bb22f5e24fcca660dcb372af6fcdbf5502b4070d1710d99c26bd920507abcacfadfcebd91c3146db74ac00e8981f1b3f327f3fe5292fadfd0d3ceffd362fc07cecf9d4112aa87a3ddd7a48e520f0384a7716efa4d8aa0dd2351f5a2880109a8ff9a6a35508f84f46ee4f001d01c7030359b47aacf6131b062aeab4beba807f936c9f72b861b2fef31c86ed94da63292ffd87bc3f8ae796e88563ef1c4394d8d5afc42e34e3bab0f981d22725d869d95781d618841ce2118bac0846aa7023bb46dcb181d3ad9effa9dcc40c2e67c5b945a317024fdae392a2348cf5f5057437e553caa752e673922a1f2581c6e542caed6010b1e678134254d7d605678028d1725b3847e93c0fa4c61df38abe516ace482aa4a3e2f00986552764a4418dd7a08c3de3ab10381db81edfce5d78a496cabecab4c665620cf6ad3dd61fa042cc0485481f67ee0a6fdb95b338ccff6c4b08e5c35c44af135e742cf30d11fc4c2d953fab89762642b316998cd3e667621d27a0314b12992a112f9c6a753b548bbbf42cfc9d81cc46fb6705cb2a48b4350048e9c8dceb3b65f8f9af5175548994a77720f93729169c2675a42314e1ee2ccd0a95d3893564a829fb3c032498ec7dfc67b000987a54fd951caef304eb643313186ee472f77f0cd0a6d2469e3b497663ce29c36899ac04a04b602b755d608d6f36ee1e75dbba6d518c3548bdcc1a9eda852a13fe0d2c21e9d15543d1a48d0adbc468f98eced8e6d765247a75f9dbe871f36e63ca96ce42c20d00eec3beb47f7fdee67df94950726f35f2184cc71e98838d2a672dc2616f13f3340b9f36c398f0aa16b7c2e7b0825d11d89c47d5cca8a0663ac137277a14f3b1200f978ce48d7734cc538ba740fa7207703f88ddf3ee2c6d29d6433deff9bda94b4e2c7f119a68f6d51777fa1fbf2827242280947302c010283574ab39b1a06d4b6219dd88f00b66e2f6b0cc3578dd0f31cec6f4658e8f0a5e9b2274378de486d2ab8732ebf1f19fa0c18439087635a848af16e0a67fde7649dae1bc954542dc0544d92a260a9a4dbbdeb2ee0996703891ae05f052afa437db705136feeb6a952a39b9e9cdb9dce4edc35e6723baea954a78ad7bb7ac6086f2b48f0a5b2304e03e3cef5ac09c2d308c32b12ff6710a796aaf9caaaa4fcd6e9a7116794408d41d87430b766eeafa274f7cfacfb7499063c1b04a5f7b08bd23711ac828f1bc9067109deaa95860eb52e065a340775a6e31c5a3896892f78f3aeaf93476d81a152c2f4547be8b267f45c558423262ba637372f6216f2f7b789e3febf529d0b576a3a312bcd1503dd4e18bddd03679830b7bd0a643eee76ffc05f1d3b8656b5849bc0c707b438008059f1d074825c0bad921239780ab30d6611efb98f045b9c5853582d5c3175cb37c9cbe4e2b8f4316c700534369fc80578c387a3793736d6055cda7cdf5761deec5662d285c6d0196ea5fa29274ac8c2a657df39948fc6baf8d554976adb7a0f4d84b0c118e070a1d646e73d99b092048354f527259211ceefa30d619d00ec37830d4956596fb70aa3007969e01916c3d933f13854513710b73aa4938d78d8fca1b1fda3a894d4979c485bea45428bf787a8f55909d47a578eb0199f4e6a59439087a6278b431f1d7f67cc332d5ed006d1e35e38a6d54177117c6d0535fbc57212f9dda11c839d3f4c1b34be41cc880d64b37fb89f9578636f87c876c154ea0502a72d8bb6647c9a1f3e3568fd7399e58dcf684864f719ae310bb67b884d75560fb136d885ca9edc3b06245499373c2b4f7161c282cd241cebc5c519bb48a329c1b977d3bb1f7a097e207517f50445e6e4e0ccf2943accfb51acad616d6080c207ae60a59e95d52e0d3433295b53115c56634277d00794775fe342757023c1e7460fd7d01aebe3dcedf4c0a80c25242187c89c7fda5e872edbf6896fb93a72981409d7c3bc450f0c2c24638fb53282ad1bca756bc7cbf4eda7c596a30dec471ba176bc78b7e67613121151f076331501edab6f3b7b60d335097dc66ff9a6ce9bf4a40ac5d6eba48eb1eb692a788c73dc550e8fbdf4c3d0f7937067565b0fa5ea28c4fa06ca725def6d4193243fcb59d10fff1f6b6f6e2121cbe7addc792e1285b6694e0c59503d0c50acd026222d822df67d848bc538a9ed745cdebbdaad70005026c9ec8f957017d28c1488040cb8396cbec08dc23120307192439cccef4594eb760a5b0f4978d4972edd38690c7027a649342b9159a5c83a146538901fdde1c989bd73e7811f63bca47af4bfa75248ebcbe2c6e0d76204cf2b64550911adf37cbd08e48d10fa3af0916b41c705fec574b27bcba4e97ffc62f142c7f7cab35a6d007b3c1a901d40d841495bd06f3423f3a063c1f836c26cd8d51a02415a4f179e79d60b319fa30a021a4351cf532d833840f7cb8c9a64cd457a4c04575d8c3d3d82481f28a0e7c5584b31b5f196d1d0ad9d5ae63164ae8900aedaf2f2f222b860a97ad125287a3ec366e81325392096af675e8b9e5e8b4c1da98b7c3236ce57204a20c06b3feac5e89503d4c390a2e19d95425823fd69136bc286229c59c5a3fd9950b223715d5245b6f737b09ef4b9c859ed45c2d8b66ce03adaddbe98ef03f6cbb80b81ea1f84731aa1c8583525586351ca5171ad4a156302e75393a6b53e34b191a5fa4524c661f98f99552db282eeca4e44b694ad98601c9d05996bf0a44b5939590ea2ebd08b259293176a05eb4c3fa97d14660c35f52b4569c2d743d5a652f448c43977a46b1bf04332c7a3d0b3e3b72190c1ea4b7c8ac324c611adc90d20ccd66c12a5805027c97d0710ee84fb10dac290177e20239dfbf98f14d09cfc5dc8f6746854dc5db6e2ed58568cdcbb6e32296deb24c0ddfde6485d036103847e7b571a4bc56a93397780cefdce33e8e1faf0598f23c67e7a895256b986f6288fe226a4dcc5c18a0f8360c5cae9a29a35c3410cfc1ed36f3cb2c504f7ea9f3b380eef9e891e188624c501a972dbceb7d299cca58a5b2ebd4d6577959957f93d7fe0e611632b40600ebeb03178923a28515fb16541750a97b4a979644bbfe2eea2e8a2d16f1b45f79b824efa171e39caa9553b8175189d3c08f2a85e994e123c50f10563d502897aa4c4a197ca121392cd4299259cd546c142bd832b415f9636ea88efe0e87fbdc0b304884cfcd9c594e209e35de615b6fa737723f5f55c06336ce24f9f1488f839c1098cb59530d97fb452ee3b405fcac630d6e3c6dc6bb62b714ec0038eaa2e494128762e32fd4c289272f7fa7da7c81e84fdbcef20f72f9407b3d023d25d15f5bfcd1cdb6a073a01cf9c93c1ade2c1918037a2327bcdfc9ec798d081dbfab6619794d7cce27e70d80e5107b637bfe83055f9b799de93b3fbe57d00aedad0a5c247f9884cec056b54b5c33975d2f06f69f002b5f1eead6070829a8696e1c6fcc1ddfc299a7b77f7ee4cd54c6b6c3d4ada341d6cf378011f10036de294d95e893eac25b939883ca62c9db3a372fab8ba45daa47c32ac00b6a6e3eae297ecc867cda6c91d3b49d6d72ec627ec135f8bb46dded307b8f3bf646752a66a24f89342ea59b3683533931cae9e6a25ad003eae31fd356286605b82f0af7cda3ba4c2d329f584bcf2f7f9fb2ff3580296a136cd9e761192318f62535aacfe561f2e59c1bf22adff70f385b20b3f276ba88064b7bef69b0d72b0a8f0b0697695091d4e14956f200a42f3783d87c66561cbc8865b08a6b893962a957c103ffc835fa22d0fccef54079ec5a4df26b7e2feaa5cfc6837ac61bb3616916c77ed1bd81fa295e5a9a6679a4fd6b3fab5de5336c6566f9808bc5130ef26599ecdf46c084c05841e64f17b24df3eededf2f9564b0ccf561a2cf108040587c9f46a954fc4fca7a754495c2880861ef06c240e343911e39dd138b78c3030e1c7b1534be8b3dd1bea7feeb139f272dd11225fa01ead7b4c199acf8a87b7b03ca09ee7688bdbf9afcd620c3a85573c37ef33253921d72b2909085524f95fd41d04759af7429e5c3561682cca6678700de9b148018278d46641b26cde2642e54462570f1eb88156a03446881f26f201b764667fe7dcd25c1efd41e449397acd09a356f2b6caff5464d55cb545e7aa6dfb6772024520253396d466fd4bdea2911e7f94ebaf61dd5eed4ea971c33facb10a30e72d6c6ae5a87dca6df4e8f5bf4c97356a47d6310bfcde9ec52a6f9a52873adeccd619b47e98ced7ff8e599dd711f5cca495e8e1bbbdba71b645bd125a667f787bba389c1f3f81f6881bd2c110ccafa25708b519e983d729133f21d961d79229926a3c9008840fdff3e6881a228397d2750d814b4d93cca3b324d2c369dff07eb32dad7e9bfb4b7c3375a3116fe5323f87ab1d1bd82d79fdb900463ad833646f38427f8e616452a0e8f2e9bd678896d2112ed19a4f808c79ef353f70fc76eebceee558c6b468b28bf842739829e90fc4c9f4aa74f0d34a1076a4c75d8b998adadd96faf3106e42bd4fd29a9f0167fc3fd4791cca1a4fb18542d0718337fadde86afba0068e1a667c83004f878c018f7d8bfd905041375fd84bd813d3bdff52b944323a47c9c2dc59d404bf5a28b38c398102f0b3e545160e469366e10437391f5b6a62455379826616f02d21ef25e42852ab24c7c8604e5c41878edc5bfdc0747fc7aa27ccf37d7d06c6534ff96136120ada3b102760d7d279071c7535e2d619800f5d478d5834b889e05905de86317dec416f1c9be050b29ae5220e3583c404c25761eaf9bf46dcdc5cf5f81efb15d35252edec424245d2fec12221b1f0b49f1eedcf0b53651947846981f06b3fed724d9075ae86f93bddbcdf928ffcb021f3af7057be64c8a6b86eb58e111fa469f45f4dde35e20003e771628c3336e925da118bba15c48c9661be7ca137b2489e696ac7e7dead8bdc1f0aa74f338b05f970d6383c69c59b8fc8b2466f46b05235968cf4d8d087923d06d14c0918766092839f539a5a1b26c1ef389f8e008f9e1f21cf7a10d7f596445ed31b4b19ad1632236242a6b73a1cd4c1167c5b54e570a0afa802514d3852946c9b30df2aa5d5712a174a534952e27bd8f004c57143fc9f08f8d73df1a5cdacd32b42c490fc92bb92ccc5a9c6a617cd0edfb5de7f3a0681e0b0bdace43127028d95157dc014882d9860314ca22a298ccbc92b4ad8c03bc7a4573b4f34fce444671bce358da715cff02cf48b62d25c34b10e22d39544c6307c3f6a7bbb408ea3daad5ac9092ec1e2febefc92ba3a7f40dbd8c3f9be0f8c7eca7552e5f9dbde315259a9d3a25be9f7e33efee70353a644522881393e3ce0afdf63abcc3db84475ed7a7dcd100893cd92551249068f873e6e4a79755bfddbf6684aa833e8f6f017965385e4604d7ceca1403e240de8383e9c2e8250a2653c5beff1e2523b0d0383f7621908b2fc7e83b5bf531705927f7a7e530c25d4cf3defb24fe642c2481c56056c973cf5c4012172d971af288e72844d70af18837b234f8606434a9013c13cbed85db1564d1f1cf6497eb3bb5be5ba2277b48df8b3072e845e3e60014ca842b7054a3e028ce4f904d2f18e02d5febecfca96498350f6fe1af527a73b1f82a107f6f021b0688a7f03ab302a103a8544bb8d49390177e4081ac110a8b457d1a6f7b55d7dd03863e49e6791142b95c200f1b685fab5ed03cd67a19b3e1b77f268a89e1924efbf0f91c1b6257d77335ae3643c4403b2368e39cba868b8736d012c394ca9d90a33fcac21d2f19ae32a720f27fdda1cf9c3f250650758edcd63ea05ecdf50a65e53eb3d7e9092ff036915cd3b40efa1daf1fa3724d71a771d7df5a44a7f9d86b9b5788ca6450c0c76d4dd5cf99b1d1cdbd9bc7a1ecc830e5a400c979d6e8b5581d348c5f9dc1b3a0de443d910025ecbd6107446c62e97bfc97fde378e2e9c12889246b8eab8ca201ea1ab11a64c2f8cb4b5b40fe993cac73b48f27fdb15172e8f03aec11f0f4519fe6550a96b8a46979c24870e26442fd2397c2a423222098732bca2866f0f2cd1871faf8e936f060327b4358242391b4fceb7df770f26805ba877d0869d4150c1cf0df1c8f35ca84c1c4b44d57a6993f055c4823baaa37b536f59f97b2509f9564536fb0f83da94272bd514e9ffb3a2898a31a40b5e9e51b83428d0f8adfa9abb5564eadc497cbbdfbfe55f66fa7d6be26d77b3f4e5c5cfe692df78600dd5b5c979cb05c976bff9b26b52c67213b4bffc51bb58a15831dfc0b04916510ceea2a1ba8f38859af62e6105f9f014b8ecd56746af095b248565ef224d012bdf3020d3040e1e0bfc343fd2fa6bc2e2f0820fa0a74c523965634260cf45cae9c19669687224e3e36838737c4928da33205fe3748911f176cd3ef0d95471490992c137b72aab53720850541f3f1cac4765c55dda1c6f48f79c91aaeb301344a45605076ed3a8f2ee2805518a5ec935534b460f2af652db70b128dd7ef71111fa455397627696407a923a8ad73bf33504de4669d4cddd03e4ee22fe6db819cc6e533b7711cbc49cdadffc32591bf50c108e65f506426dd1be7259cf8baaff16a8a007583edb23c26c249b9b5b26c250e65aeb3f9dc4e816509da9841635024edc0e23a73e201ef39edd3bd7ac2d23f1391b7ca13cf88b1164df6b8ee0cbb93cbd2ae6d77b44ea636ee890018d3df07b2189c6f7b13717e6328aa36cf5279daec439e633c96b0e87312911688432aedad9d2d1f0f22f151ef2828af5d1c9f3dce10da11a43474285ff98ceb0d983d9b8d4a6ab08d5f7aff85606f29443cc6256e40dfa757532fc704eb4ccf7c97ac412777965f2ca07867c92891c8b287a65302df1a33a3d734c87becb5fbcffb4cdc496f92cc5b8da7603cab96b6402bb3d1c4bbaa8875a299b60a6439d1da98d32a9ac3f3ed30b2625615254c1f0373133bbab91f0ae33c4114c2a20c7b24e1fff59c58d4eaecba04e5d5999af199264c713d41d2dc4413837da88b2929e1c4972e34e2d847877e3a43c38b8636051c9c505948fb8fda3a42b6af3f104ec018999554c55853d3982e9b05754295bae6acf680c4eccb80b19e758ee6f82b3867cd1aa232e5e9928024716640b8c6c32e1fab1f5e753df69082934ebfe38d09dde1c47af12ff0aa29858c93f93f888d06d9fc7eb54b640d6c907b7343bfa3645cd9b07285c84418e13571901044c7e59f1d0accef3e39bf4e9509243b5402d7bb981239e3710e81288aef4549b0ba08db60fa8e63efbf7ed030e155c89ff04fc5bc3b2f2769dadff1f990e9cebe36d9c64b2435af7d349f373046ffb5a15f82102bba0a46a090803b802ec0c27be1787e26a066872be63a894eb696666af5e5afa7c667f5ddb5c2df28f728875f38e309b807e5190708792f3553f912be39e13d7734914fd7eac9619274e91637f6a992c62d42b85365151a99a4f2c5a4968e6fe68ca57c8a79abbe3fc9f1edc11214ed6bf55f44d7891d7ec383d1fa1775e325b908450ae65ea6a9c3299f6b0e430f349477de94efbf0d366305e54381e40036be38a13d0a3eea7a45761cefec4271c8e498dec08869663262aa253688db9d5cdb0648e699ee97113101de9bba978db29cfba5a9a1b77e5ce46870e781a6022f8eae043ec71add64943ed3d2631cbd6c73aa61ae75722217ad06f682f770f2ecba6c8f3dc9f729fb9f51d326d8230415b3416630e8a95e31e1f0bf798c00a262f58eec40f63e1b3ff79d5ce1fa3d2dfaf3ec014d26b4889d5cecf043a4d52169cee9b45679017b02083be8e022941241f4af56498b949281f472105619cf0229c4a6a6976afe9aece0795a8bfdba03bf83c780e0c0df360a2f94c378c21a57ece2d45a1ffec64b2948fc5c2f5e7df3350ab83cc79b78719d9ba7c7b75975d5d0c863551f72d2b7299518c9479f8920e07a88aacd328d2abe39ead0ae43ff65e5ebecea9f09604c3bdf674dbd8188d3f5c0d39e9c109126af435ea553de9c8db033876e568d6c28d892a0f3db294bdbb3269959e8e2cc0c24e85493e5a89e729e63b3293913f80fc72721a06e1e6d53eb5f57923aa90dd6f87748c3a340ddb5d7c2d0bf07c33354d0ef11fc09be9a22e66b2cb428eb471ce376896fa8b8d796a398cf2925a3caf082aa5a82eac4ff6e865499453bb38d1524678e9a4cc36644031cdc5b7c701234e0e4e2232ca97bc0b6903ce674e5a1f13ec2be81c3636dd2960629cb984ccf45f9b5bc5877d46f91835d2c8161fc836fe3bc67a259f0657cbd7577518193abf3346bf90b8453e2b5f0ab1dba1a80247122077fc1d98d44fe8e7198c1dae902eaa3bf3537b2acf47cdcde5d7ee068ba2e071366c8c47f50d4aab10cb0170f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
