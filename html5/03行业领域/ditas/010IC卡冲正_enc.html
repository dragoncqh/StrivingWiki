<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d2f9d857bb670186bda2269f980d706fa7d12e50c5abea4a64348883e1a640b78eca1cd32b645890a29e8d6c6c0ee8248436c913c4ff75cdc0be40fbe13c9115711aa60337812951ffb85f0c39b82cbb32df18c6543a5574a4b63aed70ace79c6f3a67b52aad6c044a9e639dfdb7b795a4be95c1f459150ff25590239ac8d4cbbb2c63fc14fc69621c686bf446d9323f8887cf273a1a8a2726cc8bfcbcf86cf42e2d58d8bea0e2ba6b7746737bb974b7c0940d1912612f7a95864b8a7681928311b1f66788a125ac7e737382714e5cb6399cb2e625243a84f2e05205d3fe5530675336085bcd5e0e1954cf16ea1708155f2a413dece37ba452c3b63f34dfc3a8f64e904299ce57ff6b8732624f7ef90789ab84e01e5637c0ce49fffd17b8c979e3aeb2565136a2174d879b6f06da796a00c8007550095db89adfbb0b5f8ee969bd36fdf75c5ce66c46b5e189f9422ad7aea3188c57249cd56924ad9f2b24e47964fd58f76a4df6f338f74d11a843caebcf3aba6905b468ce4704d83a54af313adb72790ccd6701fb0c40fe3464f8bfa7a8a6bd6ccb755fabd7f96bcdb5ac86cc5351a5227b96e37a0587ee5f4f132de39c3befa4109331b4d424df7cc63d5dcabf69e6bbe2add0d78f49fbff42de55d57bdfad26e1b866ea1e3bb41bba5dfe3f0117e7340c12c7a2f6623dd5eec63eb76dfabed862c7a76e1cb568d08a35e779fc244533e53899c87c9bb3c7455bc354f5a77d6f88e73c07e0ec8992e335a3ef95c8311c4707f27796e4b92c0c80bc94a5577df6420906aaf492e57ead1d4a9c7fd35af8a8f2818c1cad976a7bd84ddbcdd8730781389a5a4464965e07d737e84ae60b2617ddf318cbf7e851d2d82994db2c733ea5b88c5dd0fdc91fad223febebc5ae971b761c820609690e92ac34cdc73af6d5d85219d2b48e0b1dca9be72df1fec30672c248e6ca941038fe98ad36972174f2744a0e6695633899fc68a3fbad315a8e43a3f7ec07f966a168f265adad262dba02f8057913ed8b8b51eb4e6992d0b0d3fbd7ef379a8c3d0d0ccdd42fca76c938b79c1f8c83e390b30e75e56550d34961ec4116bfd2f1185fd8a57d02da993ab4b24a6166b543e5747a0a772643e1a8f0c44751c1494b538d52754dd5da60221bf39811bf4118af670100a540d0c6612978758457e6df5fd8714d83f4310656fe993495ae9d179a5b63409ae6962dbfcbb33852aa9fa8f8111fd180583f1a0b9b54cbe854c586ba66513c0cdd6c3970870a1cf7287a01d26e85c63c393aa300b467ae53241fc062353953d69a04c0efe1d0d760b5561d56419d40a13d00493c89efb106b3dc5f8f2b0d1c6b6b732627e0816a4300560f0b0544468dafdc184e0955bc46c931932f979351f816b63ab337fb79e57c091fb0c9127d28ebc0f0ca9439bcf849ebb3ab37a013751ae81a84f2325c08a5af98c7cd23d929f202b7386ae4c45c0952e7b63168ac31f103ca1b1f9dace8ac668ae6153324cb44b734cd5ffb646c29b8250c501249b7e565892b8383da30c33a2745b0ca64c05aeba43be73c3ff6a063347f03a42e116792f0d83893759cbb39be858ed117b082b615ab6a0cff1befeac7e2862700bb9e445450a631380c88ab73d63373ec27194b2045f8ac7eee5ab7e119ac67f48401122f5aa1f2fb59eccd6c59bc507da46833a6509392c873696dba300ba5c8bbd7940c319d4627b3c4d6f8f0c149e788c3fcf07136abe09e75e0fab46af59e8645357a90e080e32ee3b7cac63077da833497a9917b9c092da51ac0f53f620ef530a196213b7faed8d62ee8204517922943e26fa7b5473c3ee4e19e08d266f9f17c6635e7397e18dce4c3d45d2541ff56337b6da618a7aaf0d33a4b7d1f41f880f6bd21e52f9643ff10c47590e6fcf3a7e9218c8b1963e3a50050cc008595d1604e53f802e387047218b6dfef33501e735b5d7b18d1edc7b0ad4b0f4c9fbef87f60becb6678febd3c2bd4d5674a7924e1bffa7110e3e693391b523f959fbe129946ef19077b54cd05a81afe0cc53e2db880b82262f67441260ddc50f293181812fcec538feb152875fa84ea94f503355f8b769e6e79f80b996bc263749c6a454af283a659fdcaaad801928ab6ee4fa6f101a03ecfad34f27590ad2a87d39aeeb787ceb537a341e24b1e8b11070c12d762766ccaa27b4d6ce416a5350635777adf7b8461e2634ca684edc4694f0edf97615fd8de8bd60d627c9b9f07a885bc70517dfc8c8c4fa7a956f8c6c4d0b629f31012943765f23d468bbe38494523260168a63f7aec5a63ef429af89f05abb65c249f71e1ec3c02ee34302f37793e1920ae16630238e0f363a741bb7cd0d46f18f7e73f53d0259158b05633841a23f1de411993b9b08801cd7b6a127f12d0ace358020ac15274191529f802ba68796f18b973a10f82f200f6f1ed9c71ca449b6de916e309db80fa33886599fb475e22538918a726f00db798ced92b908b7ff048709ada33dcecd192f60045b5dbdd5072d32f5bb34f5ef25746ac807710036e9858cc1581402f7bd6defbc6eeacbdbef01cd90bcc750a32ac7101842285235f6d1340f546f6b23c55fc5413094c8e04ee3bf1e59c0aa4762f52e85420a896ccd9a24f129f336c3d46dad0be0df2393785301b1015bed8ced441670b71ae9e98942367f3971af871a2bce44dfc6d03d2e99b1344c4241508f6f49df62ecceb03ba19ff57b63ab90c2d49b718716d71d111aca063c77a311edc1e0e80a8ba0d1e059a2f9a5d6270baf06a4e17889bd7ebd8ecfe9f0a1bae8261110584123b0f816355db9cb0abf5808fa4bf3d1efa2dbbedb840dc51d5edc2abb713f90b65c8249edb2156d0ab5939b9518c46c0641ec7aef1b33130eb21cc5c7facec1fdcc1d74edad38d91a0053a1ba992981135045f09f456f82cee8260c9f44f02ad64169c6dcd7163df838fcf010303b43fefcd01e4b25d700164da8a948fa70db79a1f92db1f0e8db5d0d5ee0906adc9ece50843d4f753c0a47dc897aade79380f2b1ca044bb0a83bdb50a53ffd3121a5784f97f8a7c3d9f2dd12d675a95b9a04ba3e0badaaec23b5690b3b3c585475946df9e3a3bf9dbac29108e0dc7b82e52e5e8bf008d059a54289155daca1ff1efd389628aeb7274cc4d740ae05c9f8fcf7b500cd4042e16945803890732aef61d9345fc92e0562559fa8583638cc95cc748f6b44b6fb65fe775ab69dcce087c7cb1448afcae9acaf0d3cfcb3bd9ca4e792fcc186c648b8435c4df740ca304a3055bfb00e59eab81ac8dd4c87f93ea9b24b804059b4d4d468807b7b41bfa046893bf0a747daa0c3de40638fcf6d1f076e6416daa1357c28b3f34e8241fcf549cb46148dd78ec862338f42fb35c0ce25263fddb4f14cc3f47ea83b926cd9e7974c3d7737c25f309ecb9a2fea9766259a4886c6cd3823338b8bb2297ee4be1587ecfdf36861b823e92513557043c4997db9c3dd02ae51661072a1b18cbcbf95e54b0f8fd5ad2c4d6557ef1d6472f5f8832c696a8fffc2e85956aa24ee271938400439be81d9cdf41fabdf4a4d7113478002b5527167b59cef284220a8565eaa885a465f8b0df61e8faa439dba0cc0ad06c97aae5c536178a973e2f39963de6e631219f17f713ba451c787490689844fb0334e4fccc02e93a974b4380b079e15b02a783a2dc85a0d08c07a2cd8d09feada872772f097610d4329b3f6ecdc61765a58d5b9d7edfc7bc0a4a3a05ef5403cf3c13afdc41457710e1e61d2d73595f4fa4f72bb3cbd14d378804b3fda5a8bff381c0097e8907a02b0991c3407dfd38417bb7da18a7c179ce9aca3a83a6ee7d4c68e4c5685f53e88652d32357bc36d8675015fb1fd5dc17b537230c7e94fce58940d4e380007075d058d75cee47332cbc661d6b71481b721e762fbd9ce077294fc77917e246fa4414221986d2a878b9ea6c615a52749e622681b80c1d1397fddf3f8900ebe5878dd50e4097d5dce788bc38ec18cc98f204ad06f586a25da39f8cf184dfe8c32ec8521f238ac2e57dc8db78b6f7e7d9d2211195abf31a8a7de34e3ebe6a3faff49b136acb04d9910826bedee71ab0c93520719377bb06322fb2698e98d6dce87e279d1acd4a2d777713ebd52771e0dd92872cd37790596f7ec2c5bf11f148e469a31076d57358869f4c92122f63e63bccc905a883ca9a013070f4847187f3ed612f1f46625c5d65111537b450f3ac3efb1fc393eaff8a2ca3f446bd163a0d4178b25468051c82b607fa2a5443878f90cfb40eb511be504b7aa039adfc50f74a00959e588ac735012df0f27ccb32f494bc28343a2940e9121fdf323ba524d3a1af5d8ea41347c83292ea863a29f98aed99bd92c7ae346bccb95dafecab750da45e8123a24f3904ad011c2c02102e9baadfc275be68e94e00cd888132c93e834c4b5e699a6d2a705ddced7bcaefe40bc7e56e77e52dde18fb91829ee80162bfc534389aa9d06488ee42b931167e8c9f0bd5957fe018f792e9596d8789c5fb9331349eb8c576e4e7d6fa2038f6a95f094b60ff23fa0b32dd0d897b0193137bdd3c5988e9554b459214627d9f43e38c7ddc1f45a83870a0a6d37391d5470d7b4162e039657c3e6003671a8d7f275e384ce71dce9a5a06a8fd737835ae6209228861c73c849c330bfbb9a25705a6b07ccd20418ff08cacac9a4e9681395aad0a349ac8a95feeb8d74d05d4fc69daa84bd4a4898d9b3e56b8c00fd08172322ff04b8e1c488e9d13a8fe796eec3d46919f5636842228aa30273b091eab471173fb1859681d447e391d7e5382dc9d55576aa4c27f652c657ab47e96965e2e5c9dc410bf8f241193566ec07173daf2f0536903236322bed2d4a5d1d74f2d2319dceb0e6c2726cbba81d37d5c362f2c909cfde6060dfda1a317cdae98ab9dd43446380502415f273821259562805ceda268ce0f4f7d0ac269608602c2b709752d005e5463da4402101b86b6e2eb42e8b0d6d09b3a56b560c49e123522073cd00c673d03772eef31aad4902098f87b7834aae99ffec62f87a2191e100173f65fdeab4289a5e39ba49cf1b2bfe1115263b5d8dc94a9a2bdc0dbca06961b00ef35c7733bc0d03801ee4b3af302621e302cf3d11c03e7d4c93d131a80ac1d2422ffbcefbfbf0793c28ce18749824d6badac7489092cb1cb6787fef39a9ec68241dd705c94c465e52f2dbac9e40aaf936803255712e7027e4b5d52e7a6da63116b0ed9983d1d827ed5a4e1b191057ef60c254f576981a79e2a8f1eedaa6dfe9de18045dd8184df769f77cd57754119e080c7be145cb0e40bc87e93273901b14821958b6bf632c11b776cdaf7f96b51140717fa7178f5dac3ab3e5dd82a8ec8daef4ae70e0eef691e61a9aa59c3b550819ed276ca23ae9d46cefe633e42f5fa070c690d3341188e2033eafd45c805f64bf4d998616fef76b0348677942405e29ab5d7e7eb700a40766f9eaab86f14a6fa01c7edf042f500f9e892b7655c160bf38bced0e1b777a2903bc5c85c26610c35249da871bd02f363008ea0d88f125492725deafefb4b2e24aff1f5b3772478f9c09b17f6acc147936a80bb0453b84d5fd4051d809731c0225b5e935dbc72320fa75d1c120b0c34ff3a7be86f22c9dccba6fb8d3a6cb01020d0d825c99dfea38571c157453b21423b1122df8d1e2d1ea6eef52c48de3bcc6fc03418eaef7e8b8e74e0b3d4e1fb29574041663a63e4ef24b9092b627d9d968cf464669bcff154e2c65274dbf6cd01888a4dbd0508981d6f5335c0eb68bcf72cd86477f240842857f746ea9ceaa8eba31d8546ffc40b4ba1e5e1f773f32c45c4f96db6635d2af26750f924f172b5697f0a6ae75323f155ee08119d85241568e4259f9d79a8134abf075ccf44c120d09a3ad25400318362033c499b46142ab5c344bd4d37f87f005fc01fa977273fc85e0295ca1e93d01c2a331194920583482e76fe5d6ebddf928f5b6ce259b394423299e40552d97f7ffa2b81feb6e7c0a0b25d4bb1986dcdafed712803ee8317eccc8c6638b8d897e3af860d3b77b03657d55b310bfab6cd80cdb6857a7b63527018199eccab6a52440766258973e8cc8cffe3ea72cea7290615aab39a33c9a04aa46a33805b0f9a4a2d78cc65a20c1b430357973002d3d3f812ba0cbb854c4f2785457dce57713b313e873ef7f2d1a9ea0b3be0d773330ef97c7a05c2f9deb18ef052ea7c4388beda1ad17ff03f53316b800bf07179934ec4e41bc745425ffe0f9eefef3eed45cdb391b6f6a101aad84d1166d773de2b9963bbf12841d4161ed8a9dd80c7690dd9e79fb10987989edc9ca2f3b1869dfaffe7b7aa1eb1932e543d57a8df36beeb6c020ebef0eee1bbc0380dc07a684a53c72b84dd6f964ceb962a20a12fc2d5af94f28a535a20a268268e929a947a79176feffcd52d9bf32dab10b34fadce5bb87f2266ee66d2fc643b4ddd60626ccf58e444eabc8fe897334c52a0b597c66b6469b9d520395d64f19e18efbc80c25f9264f4fc06e364dea711e80df4566ef484861f8d2d502bc99ccb3252d7b215073d1e6d590b4a5e784ac8a3bcaee3a5b54c25f123df73060fbc0eae49e546bdb8ec9bb812799a9f1d711ff8e76af82b18495ed3507b546c5e805f06f85877d975b3cccb750df4e76a2798c3dc65f950daf05c10cc45f143ac9fa9f12fcd2087d7f4306b691a4abef11673e36d9ac952326f70622fb07a0c7e942d4205dbbec5615424cc5494a0b2270af59f0383ae5c5fa0b252c56c95c9ab6ea483201d4e9a6235b0342b30d8663efc462579f8c9b54079a458e1b99e5f10be19ac775e7f2abc16db446d92f64398f88e9ca8bc10c1b4ef0141f192143f8680d520e36fab5e2747ee2c7e4b91122d91c49a0c597033b0a98496a66b6b134ee9e2aaeb7e90df6eefcb807ad5a03c728afb0e636f74b5d885e40f07254483532e76fd0cf494fdaf781834de0e8d64733231da037c79c9450529b3e0151da6b60b6a7e2b0e892c3f0c860da3a9b104bef2dc4d9128f6c51ebe4e6765cc61dd54d9473a828a9b6d317ad9b597e99a4ff8363a53853c80e79af4a8b7cb4da62906f5214b7b40fdf8e1e37a253575e980d163e7280c327f8ca0a69273f82b4e338d41987588419bc8e6beaf7f958aec5c4eb8fbe9b667fb41935af0212bb868f3c4f50f272982cb51ebbe0a4057db87c92cdf6647ce231767b9776e228164840e2c2ae0a10cdb7b4f2bb8519f654a171cc89a1a4e5e44e521a0cffd569e60426ada8f764f1b734861a43d3b0e39eb4b9c84ea7c7d591b723ddd138e6fb5a885ce6359c198d07122859b2a87bc9b1d19d7b04d917592a64ecccc60b67afaa2380cf795a79bc1ded1d8d25a5865b73a4a8aa7d5dc6d33b34c5f87e09e13a6ae6380aca6eb0547c9a2cd9d10dcf55d618e9b9ec2a5fb58244748eba54b0d6a78af873476a558311d002a94a05c33a67229937059ca73db286b5c7b6513301fae0c69a3c09c1c462cc2b7f00bd8d26cea87ff829aab0314378573b19ad1f9928444f45e7f9e464a3469b155008a6fab09d77bdf6eb3d003ee973f7cc58174868ec18f083c9e9b0132aa0f05e57a4b858fa0b8efe53fea67cd81644f14ed1227faaf7c4c37a9a479509974594932fd2b5dfe73820775e0eda32776ec2b1b04f23f2b434048c1c5c5bfd0f8b5d6f57e9d528543dc31a2f50a2c4bd16fa7c37b132049c74b40566e9c28c9db56b1fe68b06ceaca20b931eb0afd5ff08af9c3a5e50f03ce36457f111176989b45db5ca1ba595d25b518ecf1a655d615e72cdf56ef4600fecc72135afbf3fe6fb38ebe9331b7422ec77a7c7596c3323ac665e9e1c795fb275a11aba2018ed5c7564e082b75a4af67e83ae251b8209a5d52e1f56441335c232d60d2dea2c98563916ab1c48bacddb4366f2e87c30334c2f5773341f0999af6b2f73a484f501f7a91812a7fbfd1d23e7f0cafaeaa9499e85808dcede9456664bb1377b7d084e6e3c18e7087d2a40e3c7a4d0bcfc42b1b964d64933f172d13f775ed2ffe299ec5e37cdc41c9f39fd84f8064d7368c12c6a8398e4fccba11edc430dfdccd6f1538093f7ba768ca4fbf6ad54dac28fc060c295953f80808487d43674cdaad6bc6dafc7337931ce1785e34d37a932618734015443ab8ad6ccbcdd2fe07736c17215939a6954aaeec28213566f3715625c8bfa32c221cf472e58220ee02e8f95e03045d2bdcfd660b40b1cdd5b19a85bc52a80f50097a972c5c3772818498a391a6650648da485d7a0325e6150309bcba16088e133a60035be84b03eef99e69a53989f480d89e3377d52261c31eba9ffe2f479badcfa3f29bef22009f36106d4ad57bb8b880424c141a88197e9b9cbc6ace3f4d0ae223cd9e41cc1628dd9d6e12e3bc46545f8a53c27ceb4f26b9e2f27100de4eddfb39d5b100e3770f2fb3a191ada94b6417ebb956e03a1bb9a3b584f2e3249055e1b31c28cbfb9a88885f77aa7d5b18d07d29e264ec3dfaf4df3667265e994efc684bd8f73c8c9bc230fb6981e65bf5d97feb5849a331abb051c65372bfb586e43b763be3142168232d5283cbec8a94a5e71d3d44300994912f8efc1e912630925073ae81463386a6f4d8ca72bdf6fcc90da37a4847187b3a99aee8f2b32aa60e57a34341e61446288f3ba889485e469818437f0d5d0147f2a6df7b2510f32b437e11d6910019f0a58f51217ae9fb7ca7445e509b6d77de043a267b5c3e582cd8a95d9241c3e0369009535be84b8565c099737223f4cc741bde09dd14ee91eb24e6aedac8375c98c3da536fdb0f499724d0679abf82ed541bfd9e75e833be83e50a3e593bc1374c55865e79cbece1290dc0109f969fda4e406e6c9f7f496819b154e90c8aeb6a672a1f7dd699d7e47fd52b8094d03f1b07c1475c726e2e363f25650dcc8acddf31920d2376fd57555e77abfe7f3d57601fcb66dae3504eac661950df19e05eb257e3d57af2ebd0e1d4c2ab799ba8e755631e90c1a75867abf289422e7f7c6714a9d6c924d3ffe2c4bd49d7d8382965831290631b80634fa232690ed98310c6f66c07a2888f2612741151b4e8a374fee4c2d7736a13c69bfe0972a072319542f002a3e663a3b68aac975e2982796a2a49715e933e957db977981ebd47dfb44758ac9716e61a19bb2bece7f00e0dd7dc87572b952d7085ad4eded030bb420de352e89e3b0b20d0bcd3d0e5a5260c4f50160db7ca322145df0c6a92b2e8f8654332a23e71a3e0b79f0c97dad4e46abc455c30977194f99aea87a50ec34ac3d19d9bae65099c6829fb52d03a532dbbc89d651cb5ad05f76123fbb41ae2aaf0b298bc79daf88f51a406a3530cdbf2abf077d7b618230ac32e85e4e65188003002627b605bdb8caaa0a7176285c818a5b975e3bc491d23dfd74f9617552b5f78cd492c0bc1f9a0d33da985612ccc3132d96bec67644af320d4072da01c7f7fc8662490ce5fe781d30ba047cb429352e89c496728e8bb1499c0ab30331424a561986a961ff7065cbde9a2748febfb624d60aa037a22e30659ba396a73b5f31351fe49dc0efed9e5aff13a3718cc50b824831758be69c9b53ccc95e85d8f25fd6edeedb02dc9d51f50be23b6cb74f47d71ed0b5413f14d53876275162c43197585a09299300e2512f087daa86e2d7572ad1411f3b2a77744501028c4fb893d21e4af270cce9554db7fde4e07a7d25e6fbbe1741750f38471542d2ec1886f499822c58f4bd7a2bf0254cf4504344139cb8e18b16d2800602d9c27d538e018534b1f0a18cea4939e3d2243f45af0226a69756875a680ab237b7f11b65c32fdbd1d6ab91318f628af31b868b36136b3f5843d655a92774d3c783b514b2ec9be0cadfac966e62d832518c6c2373abf9e06496fca89ce71503a32452f9978a19b806de6303627596c053e15843102b851f8b427cc8cc5e5f0b6e53d9ebdf3fd49e922ad481d95d4ca3f97fc564bc7a5c0dc90573059608856fcc10d01544d7b39573b251d7346aa63501a2dfaf98c9cb75aa9291f76491e5da40acb94d12535cf257944e5482e32ec797deb03d492220e586329ceced658c10157500e0eb27c6882530243f41e915a8f08544b7d061bf69676233776051e57b4ca90b9af3841c85c53e189825968a3f411fb78865db4b131a17416ad3ec36d905b5d32c2503e173cd3373d33fde92993c18322bdedc573f74323d50f541acd8d0f29cc26e4f2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
