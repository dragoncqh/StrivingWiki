<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"389b648bda266b7c683b9a72f60b1bac570e6cc5caec3900b26430df3ea0fe4e6b4c8aff91103d6015e18c75d9bb3777bfc99e0602b13ea29d62264ad943704b128387f10cd981cb6bff3faa1f5da7260d71dd3fda57624653812cadc3ecca234654b1b544717ab95662473c58864586f03491184447fdb329bd9c13bd1a9ee40e9e64dd9d7391f17826d6b57de72ade5d29fdbf1a59ca5ef143c02c09eabcc45ebe0f681e8a8b6b2335f271381d593785bd5861d2d31567e565445c34587c4e1d34cd456675f822f3c2fd71a6756a5ba2771038acc40c66ceecf2f423394a8220b61e2d2cc9157d8d2559f70e9f34ed9f1ca9e62e3cfbb9a9ab8248201f9cd1932e4ac4a6d9b09c580b11feaff79c17fd83ffc87347b036b3c3341e7aa0e3d409dad61aefdb5aaa691c39ab9893c539c23a57e60f0675d5ef19f419a030feae01d0ee1e1ffaf504ccafd208fe9ed1263d1d8ca4b2b7cad1330965ba5b231823f34faf1675b70d7f980830f796494b78d6f5bbb92aa55b3854ec644ac30da279cd30985da9ee820cfdad584a9802d2d408fac4e2e9acb0aca1d0822e31d0ae7d249526457f363cee8fa606789303437e342a7cf6572dcc336957ac1196e3180ebe5251aa49c5cbe0e3793c42eedd7f0657c643fa40745dd591b90df4595f29f15816091f9b5a1b43401afbcfa5775193d6e2448852d87c4d0f91c5d75a8eba7639dddd9a1bab8628e8a8b8e14882fd353ede73feec0cdd1cc56b5de48bf94a6bbfbc820c6526899665ce0e7a64585d6a877ef28f9046b0962d4ddd9f71763e331e77e8f9abef1e9956325a6d8d46ad8754f1ffcd97c1fd3266fba2a41a6a46c64dca904215a5b9aad8de4c57db5910cd25f52a44892a890e94ccbb1b6d5f18fef6437f54857950c2fffe49c82ce2750248ec6295a0096fc5c70e0f3684de07e4f4ed681eb81f7ab43522aa4aea9264e81f42992e08c7eb12258ffa7b7d84cbe42fd0b798301237d65122ae3ee6db55c6950de8582570b66670bbf290b02d8a6457429d53fd5a71eea489cbbab326784e0270ac3dce03dab8908fb207e5d70b8308a4a83edef7d90e6c04ba472d9b3148ded21b9b17b05d08eb06a01c4b148343818394a5ae357ab369130b5a511d108c099c3d4e04c3e3a711eeb3bd4c241fd467722b12b11182b49a8f40f5bb34d4c6846358fe7714213e6759e41e8c96f77ed7c228ee49ed89b2e1b74cab7fde4fafada0fe46b796f383a6ae2143197596e14420a7d8aa1915fccbc4e233cb2bf2b8ea00478b44223f5f013dce035608238ee039322e5ff6d55598e63caceb4fff02a74a2e6abb652a4d8c13164ef633ae353266d343889a48db611c15e57a5a7bf8a90e0782940e903a24c823d4775ff49ecf444e847d346fecab554fb4765dcfb0beadcf80f8cf425d55fa64d1447228c4c94a137c38e9fa70a1c24d19ccbb53cf009a74645bb8d51ad2b4e22c685cc9a1557c01fa9535ed3993ea6cd76d5b8c0c29db36c517df0db7a474a0839932f30ca5828a0d1a2dd9b8277c5e20b73322b9d375ceea9b5253eb86c8b98744208ceb19c9080ddb0b7a88f426547dddc0732bedb176a3e222835e8928dff99d04220d34bfca20953befc60806ba5fff2333f442a96a844162efc7d4429a086bc61fed6d4a0c975ad0f86c7f3afeb677e466ff712197e6b47bc8665d439ad244c83fae57c3edf2b6a39ee97ffc09f27fc4a4a1d8ed463aab8fef1d288ff57e36db1b5dedfd1aa409a402347d8074d596c4372df639c7b7764f0c27565821cd0fb28cc04096ae75adb38595a9e1331b0727b856703b3a20f9faf19d7697a2a289d76448c7521c3a73a22a2f85ab7649150c9382e682fe66345e34c33333f4cb7cdb04e4964a237b50cfed9e919808ed2cba90bbf79fff99a0b42f15afbbdd7bd7e6f0ffbe7dc930f86335e6c385fa3b82abf489bf6bd7f2a5e735118160a6c682ae6e1c041ca5b2c9427ce5ef884cfeed80df1ebaae2f3a45d719f7b977777d7def3b3d2bfe1fc4664022e2bdb8883b17c9331ddd2cc011e58c1378126d55112d589ec5e6bd5b306bbbc49990a4f11f6f884672951030be238e7af55fc155daaeaf419cf2e4912955c19779fc4cc587991b754d379fddf0885651574f8b8bbc8f460f680a6e446dd18d15fd42a51260a6e2c7747913ed10b902fd145fc9df8adea2ae8282f6fddd5489f7693e0feb3689565d8cbf790a9327a592f9461e11789952675f2a1530f06b83cefa9a7bdab8cb7f105e08837b306740e47422c7f924c0692bef71a2a05be25cb9680739d0699099988fd6f415875607887b9fe422582e4502ba9891719d04040aa582af63ecdb5caca658b27175e490100bb7664c9432886a25378bd9ff3e2b1b8b8c9a5d69094079a5534d63561c976346fa957e47c8f17ff636e467d79384441334fd1e9c34930fead6d5ff23dfdde219157d1f23ab7dcc892de2e9ec62abb0f9cc361688fae7f9fa81beab59b581f3e0e2ca52a7c93240242efb5a6a33db0c9f18b94d9cec938c9fad8d9015d1f3a4b05544ed37def66fa9061cc1a6e4b1a99562c9e07e5d2146665487e55344ee0d1f7fc38673a15753fb3fe2af6de1b1cfeedb86cb029702ff69a9c4844a090d6ffa35b1bf6c109ad4061c0bc70e45c0e54e31363cb9b627d765cb5dc58fac02025cd467d47c7160dd2ab782043a956eb7a9720f7d7a74b7d8c92b6c7742d188e900cc38c9c7d8197c3c4f9f0599ddbaff21de3151ba1928e966ab420b313ac5245491d56e67c1809fa8ee64e9dca9f1efe29b57dd1c4dfff3e123d2764a1b9947ddc2082fdbd0824ddecb3da5d1787ae4f5f806a0c9c2d56e56889a1892e001e56b1a370914a6a3395d874cb4ef021ad3acbf7d0f5823402de4b1c28f007e7d2bf61edc51cc08885e1cde19d74d8211f08bc02946ec80dc0667b88fb38c604f27143564d715da4a40d1b64f29f382b5dd35cfa349970ea37dafe4a59b0df4e9bd8c5cf47116e34d2baf682aa2914d7cf1ef6d736b92e559a1bb35321bf5d3b83df246c101e86c2ac0e199ec119fb0cdc3992261925aea96d5a82f936d01cb6feca4bf67dacc3f5ebb83fce5b5a8ae6373b5a5fb63e3423dc2f0d4ec7e0f228f90ef564e6c7796e8e33ac96491925d145f57bb71f1a3f95c7dd0757cd7bf037bb763e383fa5d4d3179b60f3e91f85b526da823c6988cb52a746d4591f9c088ca3779d4516176c599cbe42e1a01e7da94f4c3a89705b6a5a06a20e55c1f8552c81e6d8c3b6dcc6d815bc5c0cca7dda342adb1c8d2cbffa7c4130d5da0f356b71d762f7496461ac2166cef509818ceec7e63c10efbcdf35bb6c0771319c852452b2932abbd12a2730dc4f97f8b06cc257d70a7d81e81980f7f9bd61f4b98b2c116d094dbe158a502e322cdaae94a0c0e9dd32535c4f9d11593a64d824c05018baae50cd762fd1ad10bcb491ca096277c6d135ff6f4a662574dedc8f15e77eb0f3ed40ee8b8202a7d21b17b0ca3d44e8e450ad3abb4fcb8b1c1fea210c3600c6191ec2097b8ce570bdd4fd5c1e9bc8d5461db762e8da6c5ba1e04702e214520578cdde0ba5d2ed5b64ff222a867245d535f092695325c6a0dbd1088a97279f3c6f0de5ffea77800f624712924471f52d1a860d47825f168161841a38a0aa9f7d26dadd557af521c8a387d3cb06a64b6e92c0ad3795f2c7b14eabbbb41dfe97e7d0258acb00d2ad3166581e21c5994160b186980c869e27b0e60ad93b461eee163ebcd57b6f0cc04fa8c5582445d40f2d041fdd20f720ed9f1d6da6e19228c00579df7a8e6bcd7b2a0733ff6724522d84be8ec1f40bd77a0d663f19e79c8b3aff5d265ef6fc0eeeda497cbc5c3dd7894c7af73eb040339ea04d04ac65919b296935b4a9e51004003daa98715206539b41e7350f7eaa8f231b0354ac99cacd1dc05c48b925ec4cb539c13884fb42c950ffaee7e392605993828c9304ffa21193034c6d04dc4fa4e10bc251a227a296d9e61f277f36e80098f269322c6f87185b5db63ae0324f773bd470dc9182f9af5904e225a725caa6ff9b0421c5d63cc3822dd9758abc23158ad1ac114a6b00911b793439018d8a551057a5c4057a38160f40474abe428421edbb36cece1d9260caabdf0b16f7454621827cdab0e7b1c3dfa05167d66197dcda31c7ab82027c7b67f2018109baea2e8dd587bf6cf8983dd25dd27edf96434b631c5c756a32d948dc3ba9e8cfff25b1b0804af7414e4098aa88b7b30bbb38cc40b0f64c81ebae5cc84eaffcbb789b51c39a074cac46156847d8e295ef4afb0718c5364565b625924227bab4ca496c0bc28537e85a51c40e75d700de167708aa6fc6948d515b5d541d1d4a106397bfdeb6ff91613712d435548e12ed99dee90ab96f56175b711095be5b6e39642d2d7763c202218dffb3cca7d2f0d9a19a5a3023c9a1d10a645b2bcd9badea2d4ea76c4da9fd0c79119561ab50db53881b7aabd89bf79fc774a3e1c68c055802543c05d5c2ed0cfcaabe7aad0bc3bee501a934b45a28d36e599a1a57ea7387f0c77a5a629f1fb1c43f256d32b29e80c38d08fe0fcbd73a18d86796a7155ee812b35a4def25a4f7693cf44713051a0174d95aff216ab5b6bccc95f592240d087436f824000eaf8d8cfc770f320985f492dd5943b447a9559a9e7babbd233d7ae06b524d512f1323e4432b4f90e4a02768466a4164ac195838171ff9a48d0f9952b8301df1a40b7e1be51fd7fc2032f1e686ba20a49af4c0efdd85a692d2143841ad54fb7ed18ff9e4eb598f0e16e2d99109b0328831bfb355d99549a49641a89c37f72211525553d003ac6d8f64efc24841351c4a5e0ff07810448ee3e13673065af78339290da021bb7357c8680d803613d77fa7eb43c5f6b8705fb19f6d7234e237a2ebdc0487a8dbe47dec59995babe7b6d856d755723520ccff6a75f235a9be349de32ce90de3a7491cd6b8cdcda664db072bab2d83e130768e8bd37c1131c85adef470d157083af29fd586b00b9724cd10cb28bf22664b5d0884a9a3ee97b6b0f6fac6697fd8cacd19613a271106aad8ea59ca60b9c9827ed322c2fa17741236253439b74303069b58a0ccf4bb4fdbfddc1a4f7593d89e1d66a2579acfa2eefa4f780e5eacdf5537637b25e7b239e47c3c7252a4323376e0f1bce6cfbd489edd1cc11a5e674d0a078baebb398d202e81373f5b31de4c628279dcc27e1442e923e1e695ca72a8e769c1c1f89589bb6391d293f2e46372f42ff36ce8a53d6ab639174c133cf6c94d01b44a1ff1758e335fdb06b3bba15cc6b59131983b227fadfea0a3c75884071e874af3c9ab447f5830d8abc8f1f74cace96e30aab3965eba5e2849988969e3fd30cf417fe1fbb8790fa5855a3dfe7d628d512a6422da098926af953f4a12dc9d4df0a5113e05123d9f6584502a66f69e1c4640c5528a6db1a1cdc04a54f1aed007e8801fe650568fa404e88e03c66f32c4379c1f8e72a7d55413e983373460f79e82b8613bcc2fc5f31df4e7bda8f28908b54b9c7d2c18e1af923b6b394f80dc05118bc0e6bd49c692888159e90b4132a3a4f931920fcb84785795c17867369fe70a7456e9675819e5a4549b8fb3db812ddff4b7b5af978b2a203b137549e5909cd16f31c138034ba4676b0082edcfdc0420a30fa572061eeed3271ff9678eb6f4b88c07b42cc7be9fd7048ce055e5efdad7be5f39939d535dc9599093bb8b897901f27ef8af3d32f967bb66ddf9ea59f8d6c508de5a98d252de2bb80ea5d8be3c8bf37c6a89b4c5c059f385742fba2cad50f0dcaa960d30731ac1e1c01f7f83bb9720ea08712f4cb863c2b0101ba9b23cd8adcc2c4feef9864bc4c4ee8d7aed465a58906d6210564542381144f81b89575df0a3a38aac5854db9e8e6f25a94b572e453aac0878745f2d8aa93bc0206f6e4c4e3932654060cf1e1f8792ec70f1ca7122c2275f9c5e66e5cc6991a822fbc68fdf686b29701700f24cb13a1f1459e5cd58b04f36f2ab9ea551f736f8f528bf012ed5b28de6e7303f1f00d9dcfe4cffee473476664593ff5a53ddb5bf50cac9e3d029c5802422c30dc5ed66192ebcf1ef8866d4b7bbe09084e9951105e0045c1ebc8b5d28f17cc173c1a48d049b8d10c29f86d700beefd41604ac255ce12223a11df77838fc678445c12a97ef5dc8c3ef64b259eb052ca692657140a751f8752052fceb95dc539b525056c87a84706c49e00375ff17c8a386014502b17aa336d75b69965650bedd385d6fe003f81ed2b4870f3bfda734ed36ebc7c7b2bff2dd284f124337e45ccd32fe44d4964d8b5c6354f8514da4a65896d88ac1fd72cbb06acf15eb47ace7daf3413981fce62f647d8b5893e910730a0c4df00ff3b806071af0991e06b806de90935ae0d2ec2f8f00d872970884409459e58dcc71bfd9c3b6fa066a1565007e59a731f2cb794064b885481db027fc963d93500a90891f2fc63e03d8d98124bf6fe86acbc46fdea818c2f9c85dbb0ea4e34d65cb71b0f597a18481532bf65987ce808006e471704b771e074badc3e98b54a33e6fa312f69f5e5a0fe2c9c03febf98e0876d73058c8aceba70b8b86474c3b3b10c4b2ea3a7d5f3162192db1ab1135a724700b92df421a1e1d115e530063a49fdedc905e96b7c1114c665e9a345c3f5789ac30b0880d0709ee9aa78893ac210854db3866918e59002cc58e3219b067bd00026fa5a896cda7ed0b0694d52bc51a83bc7fb0b2cf29074b73c3eb2c3294859322cc5d2d74596bf051ebcf0621abd6b918857c6df2d2b6dcbb145b8b6604a162a40a77b3cbcda74d543cdb1c256025a19c38112b8bae48b0fb1b2636ea3330c3958afe668e230667458b21b34fd3c382f22e8fafd214f0959fc8106082da0aa60fd6b942c5e803c6000c7a32b11d37c9b6361627e53b4e15dc2d3bb43c9355b3b55292acf11c3a9304558e47670a738112ce875957221ba0596633977f319d54552c6ccdfb9cfb5e344109b3a37fa18781ffc3c850c17d39eea37f4c3efe093028497110b8dfb37577f0aea1aa060e540cc68ad2ef848e00f9fb603737d750753611065b5f327c7aa1113a9598ed7ff2f1041f2b726d98d76c73334d02be6bf5fecaad0ea6ca51bb95b291e3586e8ca03c9defc5727828bf1be45dc4130cbff18aac4027a269da7e8776c0e742e44fb4c9da202f16b5a84081beb75d77f2eb306a9b8143665ecef458e93556a581391af93b7f7d9c0f755f0d1cb5259b9d0ff1d80e2d04f4075200a263ebf49ca02d4e28d6c66d7c41d1b9b77dfc8c627007fb0b456a64e2ed0ab1979775b345e76900f68969b9d6d5eee15b809d3ed7a1d031819a5d4eadad37fabb61451caacc29e548e9fa9bbc7acbb5cb91087cf3d27814f20f1abc1b830f5f43207705ea0fde02ca8229ba0a9d18aff3d62b4d45e30fcaf3a618b6ab96d06337723986c344d49df7022e84992664f1afe4b413f987ede841082c57ea359437bb7b2e233d9339940e57dfebfadfee9a8e3e90a82b4f065e9315d39050715685d1f7fb0b5b46d9702f292ef1a864a4de50397ba6f60979b859f42d8af7325e1dca9649dcded61cbf8d4658f35d8616bfa3dfb71c89f2f4806e135da9ec91d1cf9d283683d27e41d034e6590e9fa8a160508652e6d06d6ca92e0d46721ab2a96d70da74dd86b85a79b39032835dfa2d3e57f2d94eb0928140fc08f0d1c93ad9adb7a2e7415d71cad9419a660af37698726e7a95ffcb68b6d02818db7ae165b32fe21abe8ee8258fdf00c382bd757131d5e3cf4233bbd882bbaed9a9c6dbdf284d1018dcfacf655909f4c73a23667c2e5d5ce9e42979db7401efb48ed480307d18bce03fa8968208ac4a2cf502fc550e96c6e827930fcb40a0f857a393543cf027141d87131b225304d9ca5679d8234b3ddc987981c0e39c46bd4f1ea8cf0e057ccdb2e0b00fc70a72f829ce9ab13d0929c962915d3df07b7c36e4229b3a16d0b5113bc30db8dfbac1b1ead6815efd9164a45a6ac1acec5b8beead8e8377c55f3ccac1f8ca3f01487b403155ed285be39beb49ee498a154c24c47723ac8ff5d25deae86ed9471feef34209bbd95c3a6724361c62d8b9b90c182046898bb26941e474ce08bf806296b87ad85822ff43c299bd7786ef7b111dd931913008f3ed0d28106951f0d81a54e4c1153472b5502fe8f4c0c37788a00586029f9321f66720e0fb3aadbda79e1c98be822c54a080d02ada19705ad70eacebbeb8cfe770d4f66df5603f6ca62a2fc568531358821608084858ac25303c6055eb365ede59ddf77021308c82348ff339c897fb3c4bb1402ce71f527b842cc271557bdc2d4f3ae3250fd975fb60bcc648dae52803739a22dc4bcd6d5b535e7229e61ebe0a73226e89a82595711309bf0505a6cb4fd403b4490c4704e8b909d9eaf49e956d1d8ce3c1d32db25759489abb0afec10c1ccf92287bf7db024307f2baec0078d21d39ed1bbed4175c4627159ccae33d70910d3e823badc04999e20c17c6a050b65529d88abd85147018891d9f50191917f06038b16e317b35b1b0e6b26bb058f5d9e33cc304fbdcd396b09256c1675f8cb1c90dba5cfd07f20e3a3b76cd6d2cbee7273291927f34e2feeb297a8ec67b2547944459496ce27e5dffadba555f84e823d9926a91c318be91560fe7fb6d3c3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
