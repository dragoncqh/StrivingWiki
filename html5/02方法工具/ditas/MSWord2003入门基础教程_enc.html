<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a9984bf67698bec9c3e1f5d7eb26b851192765a49cc91bf7ba2cc59eb1bf92010ee9301fce1127687d100ce58ff27b9fd4cd4352973de9990fabaaed00fa45f47960663f2e004cd655f82227a9b60070de0706de7157d3046dfa5aa74ddfbd348de0486d2f79e188e100f1975c7b9909233d9bbe172e94eafd2b9d1ae29c33719ad5a5ec15b85040566f0e2eb54bf9101e6cfee73e924ac889300ba9ce19b1e556fc9e9c744b48506d2012c69feaee61624fd6176143e87131a5e2c31c894f65c2acfc29d0d7e56adc62784523b574563a3ae261b831bb132114913cf4fab9403e592c7f8f2d640020f7abde174188aacf9408140df62646b1b591811caa16970774312701881e204a127aa3fd823a583e92d93cd30ccdc086a16002a6e737f1505831eee572a4e433df4fade9a222d21aa78fb54e0ad886ef8e4dbc120ce5a97beefc09b60b7dfea865e8aea9eb58246a0f33e8c8eff29c78c0d3233dc6c693077cc6e662cc7eec76107a3688ca4df5fcc58986d46961652517b8b481d32b021433b740af8c4ba328f8a2fa7ba3bcabee81b91a1a8b61df13542b09cf62ad9e1c9b352580e4e02b371fd3945b8df6dd9fba18253a5137bf855aaa9a855cbc19cf41bc0e536efb77c09ba489d87aceeb25b857695610f27f2157cf0f40717059b014abc74b5bb3a98a71d6e4a33dcc52c283a97a5e94f80f81f614a7a248dac049d5f8cf6e2f269a3d3cf6853438a82912b73a9376d3501c1113cf696638e85a473cd0d172aec0cb36a9f48e9ae92f95aba39d8d1e13d03f8259d02ed73777d2881a43d56ea259651bc65a90bc188aeaaf8bdef92a5448a89acb81ebfcc7fd5b396ca154e39d8d00bbc98f322ba0bc83d55b07162a4a91746d55ab21b8cbe3283488dfbb620c86028d29f1675c71c0b8361be506f08559c46a22e85f225120e5945be564182d354e1692ad432c125b2896927b0ec52ed35cd83b7edaf843fa6cad25f873b7a5c04561ef8d11c03c880f80b2a83e1ad26069f94c2b9515b8c7dd9a279b84ef48e7f814002e02cecc2474547dda461443262a4fe8bb9f019554527974028e4e8c197cbe75d4885e114be34784eb6cee6795d407416f1311ba2a156d2872752029e4b40403d8b91b5c8e4eda50862953ee26308c40d8143ab54c808354acbd64d5864f8083cd9ddd638fd2b265e20dcbceefafadb3402ecf17ca664bf6e354fa6bb9b6bf5ffd82203086165235cdbeebad177886ff566599e1c6dd7d18dfe8ff0db97cd1a3068644ec2c94fa492279d378da240ba38eb12152ca8fefe1d704b5b0423cd274a8394c2ae5b0fd84a3bf7f6ac5dba4d2473a8af47fb3fe99bd4a9432b82e4d31c839edfd8cec1efc71ad7b05e068e028f3527da2e0d06d563ab06305c07ddb15f80de271278409fb8d6c4dea2e12d6b4e096ebd0220edb8ef17d479d0121afdaacf249376d0e87837079e8867e805397da0ed8e4da2c4df896d139554de1329a9bb8e50329f1cf4d568b2f6dc1232530aff36c36a73da3fe4d1a304cb0dffbd0c075a79b13218f83629773522cbc4dfa83c0b9a79538d17600424993986e31d17fbcde9d32c75b8b5a1d0cd345dbc5553e165aef5117a0a0ee3219a020a67e0db17ecffdd170c98290dcef092ce8e6c154e716dd135b44eb98e51b1c85f247e3ad85af58e6cb9dd73ad97cc0719070632cc3ab7ae64b743941f69ff5432c2a70265fb37af9bc37efa2484b399419637c094e3afe1d9b65f3e6f34f8a2952b98eeab152ec924ab00296f4b1e77d68c0c953e1b1d1f2a7f58b96c261f71b2f73a65204654a662b01737ea43f10f31ac84b8149d29124a66f6552585d677bc0bd0c5222f15c5369c798d908e7e61f3b61746575574219861376a27b087b0712dc73ca7cb710abe2f6420f01e3668005758de9109dd7066a1d84d7e4f0a8242a8d923851c0b521d03f684f345054642b91721bd9db271a159d982b17b004b7d998df1b75b58a82030888aa073c7d6e0d1d2142bd48e013446c2d0d81f33d2e69bb05d7c7b5ca15d5aa989c9d78f47f62a2824acd3f088896f3a29b118e549033e2f13bf4dde68c2199066bff93d3ad7f948ec4663afe962b3c94a9aee7c77cd5ce59753385d71d7664e2cd03d570b487a6ab5f3f7facf23a5030ee549963d4863e3e6dc4a6e71aa0fab1b373d3d408c0886568acddcb07b7a7e3388ccb9d597e0e5173dd3cbc02f43e39e677dc0201220a1b1688b13f5332b8d2eac4dc7f4c4e02e2df032105d0b29120a0860398938188d82fd6d527cbcd02ce8c4622128e6c0a10210c9f69a5eb013d14d43f1118e513a124a712eb1c6eaaf719a4e62d526c2a6dbef3a8b4f6540d3ea13044ce35319c35b6fd5fec9db6bf523b2e18087797712d75a8eb3e03eecb6a1bdf11c19beafdb1b192b6d4118f8b755e6f2878f55d7ee778f3cddd9492e8968abfc8abc7a9ed91d12807d978738a30352b580ea9be90d584b9d0532e585a1c3b1230c6144a21335634103d4cdc92808c69bc4348da16a2f38b83f8a96f988fb1efc9d2a7ee5752493d77f80df560a6e345de0c660337024540cfe404c742b328b914259a9a74350fef7cc3120a7101a1f296a8679f73f7a54f25412474692a867128eed0ac3b33cdd936022e1479339192fe135afd6f8cd814d44ae8f1976b83367249714bdf57973a2fec338ae82d2ee2a0ba5517e274bd318bafde29a5690baf94e756b3cae56c53521a7dc6df8009fef4af1a172b64a2eb11c632b630188da03e370f44757535121d1730368a135e2bfed939e6cb89dcb8cac9bca71a34f5e8da31d67f1b531da7247bd7e29bb3a97b32298dc345adba8dd1f5df1ea11b7b10aead9cc81952ae0747fc129cdd2b805883f8233388607ced0b331633c2c13112ffed33263b5c1ea7bd501ea3a90e71370e14880f5ba8f4f7dc240e77a84c8f6f246857b20e809a591147acc2f4d3b6b534e13e4524a54363068cbf5c87c4fb37c9cc12d1881b5988842afd5ac576de03c76f725f48d4504fdeb7b3947ccceb197e4f09a5ccb9f3bcaec3d00233ccb4d14fefdefd54a33c3b33c2fda3d83bd9a5ecffd7934275506eceffcc297172883609714d0260f1f4443475c3cd56dad80fd950442b78331b90fdfdc019132adda145ec217685ed722afafe740cf856fedfa668111b76710adef0708873ce43a2b3c82890e99f5611acb60316db741f76235bccdd0a6db97c8d0cc2c2bb33c102ae4831fc0b2df57abec3d2c1a5dbd197c5fd71ad5cac259c995c1646b2ab8ad4afaa53a8d13931b6129e769746d673b62cbea205541fe5f65a63f6697376e7f57a0e6b78bdac66a898dae6509c265c368934973c7d4c3ec763448c3d6b437e28330408e1fcbacf259505c59771bccfa2adc2f334741dac7e40e978c588b36b46635541bc498bd831d0930cb0be270b10308b3fd6a58d42759aabebf3d567182af6b4a62668dba28db501e0f16ea6ada8b3a63008ade1c631e8d76eb11d60ede0346432e4eb7faaea87b77ec9f7a37044c85299172413590eab147d6c8ab1580c7d955e47f99b0e97581d0d0f408038a75aa638c39ff571e011178c5f89744695ac13714eeb0da890d22492c42bd6751938bdcbb3b04ed2a68c44241be21c14955048999b1123649c83d9ad178fce6e74e43bb8124fd15d7c10762144f41f716d43d5917a66325b10cde82dba1e3b4f86edde1202a2f8fd7af37dbc5b767fd4ae5a98f6c0da926f6c6028ca7ba2d07bd8aaec0d273b7f2baf13fb97aee83fa91cec91572541000a6a12346f1e0f96dd88e5e04d94b9cbd1673f157300de09c541489a99e7a6346e7c533c1d1402958dfd3b4b626494a25323bfe8a32a263f5ef561943885a57ebf71536a4768cdfd978d5c784c992d0e234477de802740c55cf69509b52771caaa98297068d6a71056d13f9ef9844846ff625abf8a3152a368dd4d86548b5e72ebcc0092410397dba0b7d4f8f994ef6a40996ba6b92203cc6d8f8a0316634fecbf21c65e098dfda5af3e47c29a3979fc48306fde3f4e401bfc3b0eff72945bf5eb9e5db01cfc39ef4cf57a6e3085fe23d425c7f421fdde7c87de2e04a9f249a299def688a3f4785fb390f7e9e85ac2c3fefbd8052cf27e77caadf8e016be0c5ca048a26d10c6fd4d8f21873318ddea28696009befa8ab6ece54c00e002e4913b525cdf0ca8ac0e114b8bc7febfa01f425b98f7f189dcd02347539012710e2306eae41425afa2e20eb317a8a2fa27e23997efd841c562c2c90a92390c7a6cd12c6b21b4215dbb44a528cac5ba24a955181394b02dab054cd1702daa07a94c5067b4413a42ca93bcc8945900361c45f00ee45aaa9031ef87b8c594773e8f1977acee941956d5b4db8c319571368b8872601fac98b1b7660f3ec4c2176692389a749d62c42f73faf5dfe12c810367ab225b1e5b3ba526808fbf1779d6ddaeb7bb1137392577cc974ee6f5e6c6ce8ee90ccb12855b6e065aa4c1ea3e98e389dec091e2050b658f01e10ab8faa77b72309bb5c9ee410f3378d3fe734948b36373907c65777a7fd4ab7f4ed29b4984f070f68169b9f8256265be1a6bf43d5d3fbebf36759c99eb47226fb2387c6f2995b896c96cc42a0193da2233c57b467499e2adb7463acca2062bbb7f6e53f5f8b4ded1a0902b5e04c8387bd65573915710a21fa15db3725edf8bcd406c7efeccc909bd4b3d90d9d574b7d2092ee071169f9aa1434556205a07a59d460a995e9c1c8d80aa641769761251802541c8a288ae505702a69d85b2146be734c3eb91be7fd90b2e70debd191c088ccc17b6751145d05761558464da7018cd26abd57489c381f2a23a8498e6677cf184d01f04b495249dc87bb00635e8be94eafbbcde918c80cdb511920b33ce45cef6763c2def6195de9814f2963a92b8fed922ac83dcaea0e45c086a6ba4a12ff21fab05695485094bfe1d5a74d4b9d6ec572ff1f11f783bbfe0acf72a55b838f112434f21ecea7edd83b8522f16bddea06007a12ef52cb89b1a3728805a0d93bb295280c27b5f54d50d74d54f42eaf8f781ea6eede8a00290ede4011081f79841dd924d49b15d5d4ca421c6eb4bef5b9fe119c802427f02c8ce2b6a3cb8bfd6a40e68ced0feceb023400e265037707b3b880172beaffdf21c0f7aea862834433d890ebca9211bfef32ad8fe319e4f4ff6217cd9cba36fab5d4b8724451327c7e15b8b07c16e250966e82bdfb57b38adbcc68b53e7c1326ad491677e819cfaac80828db47d5f9c4e8271ef675eb7e7ead4bdd93d442760c45c80d21ad7332099be0e474b355aa87a6cbeacc46ead78db9d2085569d06e28d7efb95157e564b503250ca330e3606b2ed8f9a1e55e5beaee1b655e34e8c15c7c065032dcaf3ff36e834dbd3a484d17a6548003afa2da5c07aaf5706f8bdd7327ba74f75238cdc6a776d16e49dc0e5e28163e4046cac325bc6d3842a0fc50d68e68ad67a168ebcce686d10ada3341a284c151b9197b7a84c179eadb39f25980b714c87ca6eedb2c1cd04374e079e160def4d76ee24a53df42287815aacca3b1486042768e2be6b82c743d94f6d9c4684015f744648effa1595e41029522225d373be5a771bdb6f4a52b53b0f28d933d142824a406cf2e9c692d61c05372caa97bfd0b6bb3b3880ba47b966d27c3411baf9443188d2f6afbfe18dba8aa7d6cb0423362f7a6c8904feed62f5fd1b259560c4463a7d6793e6c4b4cc3d05b522b718d4990c1b551a3f2c30c8b2cc1d5f3c4cd14194a8eedf86ed473980be9e527bdf237526953c85e422e2106b25f3658b4e9dca63109629a1772f81f32631e2a7a502225427c1251a9f95f5dd8253c3a11384515907ba323387dffe1856fd99ad776d50f7c85dbe52447e175d4a82a23f9b3d5fbbe0ee4836f9098f5ef09cf9357f5ecd3ac7088c69fbb2f17f96b7409dc0d185b97e440492e0f511e6f350615e72a83603291f68e5c504b716244560225c33baccc9bd7fe74b7f6f06fe81ffd67f58f064ea6e058c8dae3f9f3eb211d23f29ed9fa9dbe9cdff5496ea8753ca695b9418a105659f1aca76fa7c0815d9ab881554d2405ddd8c4ea300b94569dc2c00c787514146c5c5ea6401a913ae609e33bdcf25ea6d5d5c8361ab81b6f8bf659e41a88bfa20463bead230c8d34849aff6a2b0fe20dabcd7ac91c10f25e440aaa1bc8ea885dd6f4df4b5679220a64cb946abf6bea2f08eea125914595b2803e6a29017b131c8e5ab9baeafe412e1c92ae4081a2c80da8858baea2a5037ece14f1285bfc15156b87cae9d6e708d9aaf858d9ce81d2bfc78d91c164adfd2b26b692a137b796a6e73a2a06b8c83e709cbe292a61306bf934efe57de56198bb3a08336882223db1c2165dadda566bcefbe2eb90f309dd1f05357b395733dfd61a79a774b1a77f0a90e2a90b20cc9e0a5b73da5ea0f3e159aac4df07907d2b34e3fa2ba8dbb8446e19d4128fe821d86d267c95d25e586390be0e1d94c2a513c4905e4f889505733ede27c7c364a4710fa8fcee08151e4deab6c017fb3f5a914ca10214eed01715cef1b33bf7a1b1e1dde122e0d5b3de8416f458dcbd0f93733e4b7fc5bc9dabede2a3bf96605b5f49768c1104ea888b776e84fb1071dfd2acb97229acd7bfe9bfa22cbf7bdf860b2e9019b702e7e516ac2d2166d92739986ff2f3732db612b14772c4d4a526d571f3d844edbda4b0e795a82a3585f3df7401a54177d9f8f04a552ea213f0d39d116a18410aa622be727fbc14d3453555ac3ef9e0432aa21c40a83285a8ae7b7aaf81da1dd8e6a0729f19960710a031e9fbdd373047734e655832cb9912af89122af9bd859260f5fb4f385bf6d6d611286179c0c198c87a9f7b4ab85c16eab42a36ace2af2e90ee57e4fd71586aab0aa11ae5c40a7191ce8a4aaca08ea7feb793b09860fbf8b845d1b496503388d7f4954469d02e4c7544ad5d51e32dfe3d00f896dae5ba463e97c9bbb3fc6457c2b82b64a2f2e3daabc189e3f4e4e8f04ab5e674d2038f6c8fb937f25da2d2dc312cca1b16b864d8aa6ba1a76725b5f3cfef47d12360ffd925dcab28912f4ea3c027a860cc43924f681e7ba91e87ccd80a422601478a55d91d7e50920dc47d23f74358ac2c0270597ecf179542322c00fa88406c52bb21cbff8da40a31f0ca4123c5c1b7a8f05463ac3158ba64d0342c90dbf2cc9a42a69ed2a98f70ecdf5533ad4669edd95f61e2ce4b8e8a183e622cf90c78d837853032de786793e6a6cfd99c29452203996d55d5293797da5da86367121af0c2b6e472e0085c94c7048034cbf7e29b109488a1259c942f656279f6ef25d5dce732e60d572a027dce52c1fd7fbd77afc2fcad1d5472394145b32850754ff5612fa3df82dd9e39c2fb30cd78a0e9a61e121f6b1ee8c26c2b3adc8f9bcfb420b9373c12f2610d658907163b5cec29d0a8ccf714c05f5b3392d2ce8f91f16e91eaa3696c12c0979d45b28af7603c6f2f071cf3370a6c418525e33f73aa8206cfd4e292e1b50f26a2a8063da52becf488e7412df84a4ac851144f4256b8b8cde722758c4af1653ce5abb35bab6de9a4144ac0433bdceafc136ed6bcdb4625970f5c3628a7d53776b643a69b4ea233d35e64dec4bd0a0fae8f132fcb787bdb24fdb95a0966c8184865abb9774b5b80cb886a95580c3efcdcdf14e79e2aa3bc97d5be1beac9264c64351e760b84088c6332d1bcd8795858f2c02e26b4a929a2b660eae650a7d1ef63944a5cef449b878da70d83d43fc6d25880eba7c35a72a940744770465db8df19ea5e1e5293b2d3d0c507e780bb05a532ddbc2d74ee697435777839a0f83cafb972b3e79b07968e6d1a00a18e3b7a9edaeb656a24267ff9d49f2eeb2a4f59835a9ef88025b6d948b8e6d4a6c76545f4e793b65c71bba1904f382ed441bbdde9597acf7a3d78b992002c24b61456f42dbe6c170c71c5c32bd7d1d167e3163edc89ed92496889f10650b4dcc7382e80cecaf2475fd25a431039a6e03c3427b8aac26bcec49e8907592e3821ad9c9dbbc790f8de6aae77a9ff2eb9be213d68cfaf5a4b26d1b360d67345d40d79104aa178f3933100d43e1836113768127928ea013da999bd9b36ca2728bb6b94491cee39a9c9c92e4698d4667570c262ce5240614d228eaa250bd0e7bc7070a80cf984a29c957e9f4bba85aff5d165e700efb012c5473ea2207c43fc867d841551d69ad3967ef86c2a8da640fbd8ef284e833efd7001cbd099c9163bf04b43e8032a423df52441bbc37d8ca1a24a8cbd498e41418f6e733e48c18b07568d79c440cc815e2482df843b0c4c72bf38fa94838a523fb4a376b7d3bee50ecc35a7488ef9f45ad12cff9fb2d36507f92f0481fb0d399454d16704feeaf67dea99576dee004a9a8d036b5ca7aa899504e8609c2f1ad8fc348596ad41e8fd78e7292471b0e7c868fcdcf260334402561f350dd9620dd30321b4e07430678f62867f97b0e29d8071a6d57b285e1fee3790debcd97f4fcf0abd8cf8c29d05690515ebe3ddd674136c6713047c6e07f043b410075c3d23725c65cc7421b44bd6e4c2080c7597ddb5eee81834a9cfdfc58a78aeb6ac7da864c5614d6a4b7e3c48fe03514d0a87c720ef6b7d8918769c37c58b0f0cd909875bc147c13ef3add800bccb6ff527e884408b7794c38d8520bc12aa3eba407a3f9545f22cf383e5a06258d3ecb99de9637f6c65a8fb2f9e25baa078e197dfa14872aef1b00fc699643db68f359bd30ba5badfe79ee8fe52d47f51d3d19b8c8176ad4770958790909fc9cac3c6476719be037cf70879579fb4c914ed2a43252c46469534fa24a882b7fce5d6eed9185cfb43d08b9350dd8b1a203bf309b3c203e3cf13008c77b3a1ac366312dd95c402f827786e14e6ef180416569a44d28f7bef08660f4dff2e83347e936493e49bb44e09f7e29d96c326f7bee8b84dc0fca92a7b3af7c29f31dbe4d39e7c38eae3f6b3ee3cf8b78bf07c3ce74bac50fe814bb81316103e7a7ee0b6a955ecd0026194f7d4e11916e7bd438206d8d07518a99268b23184bda496266a54ebd18d14ab9177362c1700a6f129ceb1c2ed644675969eaabcae6b4604d553eb926b3d4d20b5c2293b5367cfda50fac2cfc095d20f7e95062885ff694faed8242a980df14759828dd18f50f4f3147df26f1ca8e0d90ee6e844de29436dd94c4bb63e3a06a3991d30a9af64016183a3f9475255a90bcc7c10ee0a9c4c7025f74916aa8b0d18c393983ddcb67347f78aee9fe82e1c45c975b0af30826e1747a23f0c14d2cc4c5ed0021e89902104b87acff738656258bc76775762500d6d1fe0472907ec5d1a58e3b7eace925da97f956f38db93a850a87c46b611f932ed2ae986c07dc66c6131dcb1713425dede8583b9f9e9a4b60a52be33ab190789016020fb0be349b73f03d4f25fdf066091f41d2aa89010028391a2e918150333b480379dd008c59278260ad50f94813b72ef585072acd77d8f416f6a1ca453ba4a973356599644b667237c7056a335c931f14b5444a4979e68b55bad563bafbd01f260ade474c00bdb2f7a4272908df8fa045c2acbc0b87f9f4202ddeebc0edbb3cbb78c2c3eef956f271d0a100370d28489eccc0a7c0701cdc48b7d81205c2bc95961c5d1bd08f782d9348e8265cf620e6cda7f5dfb3198c1ed9be46b694d6649c9270d1e18f6f1aa42a3df2560146eb081052975dfb6b6b108f4d92c896c6ae519faf7dd527a50951070ecd7fffee6642268641082e4981e3929cb8eb83fa6674896bad1f959543667df2bd5322b9a286dfc713439e7fd687317a77ae696ec359c62cd84a6de0bade1c6432cbfcb85b7e39b8b010d3f9cc99ec7f1aa2242ca4ddad50065319f79137508afc62da5402b44a79d6b2a8f8d576bcefe8237c9b662d60926c33f6c620aba193e73c8ac5a83aca17d8e2eebe573549adb96bf6991a1caa9a546a28c6b4535053f7569e8f739b3338f60b309c671986bcf9ec194460e1a9e4616e39a180ed26de46378a02b4b3a27fa728b16a86521dee6257cee31538eaf6ed7eea6ea75c0a841feafe98579478bd100445ba86128999d65840b2b112f099ad20d284f745515fc6e309dfb1aaa42600107d4a6fc6ea85d24bf3826f1c7c9fa0921bf4d55b683d56bff7aa50a71a9bd491936bf85355ef99c0375ac8738b7b9648e7aab48f670ffb9ab71099b957eb0d1ac7a640de8532ef099e70e209089eb2949ebd8a84e512523cf3db5c1743e403bc9f87b69723d7d0924db072256e95d759325fd1c7c1e13b4949a324a02302ba9ee48dcc090bcdb43d19b5c323442bc34e9ace70fb3e96c8d51f28ec865df4892d62007b404a9e30e43c135ac19d0a52caaadc3ff75f96a754ec7938a3635817eaeb7620535d9040148f8b00121f05e633119d7214f1fe13bda7e053632206fba9659dc22eb632ecfe18fa3796784ad6a2dec76b5200243962168bcbe192db842466b9bdf5e53b0c996872b5f2f4017c3870012f6c16f95a1e3a4bf6dcc98828b7284f75abcb506d5f6a7dffa07b27b7b40ebb04afdbf3fceb245c71d77090012ed9b4bc2f7c5bce403d010a4fb1bd3158cf45678bca2dca42b65d079227ad940cfdb209e3d0012130ec131abc3d2dee2168c7c41c5dc55752d159f93297082d8eca182223facc94b595fc33df2bc9595a9ee86b602430e395c427acf40dbe30b31397017aa9624b3f732d3bca1d164a201aee012e2657ae5c5eb5d0f8f589e4012b19ed5599b0665449c061e446d94e49341a661fb874fa3781b90b6e46a2433f989da3920e8518993616b3f7a80172d53f012f8110198136e913f77e35c075a6978cf168bb348b1814d21df9af3d92c7a1baa1e837bcf74f66580ac356876da731453688b59709adffdca30f1df0069d7e928730a93534c12adc5409fb869a669f1fdbf8e3f0ec60e2b0c011f100bc3c61eac98d88412d90a4f11ad03b7698360f0555d928f8e1f373d124719fbc07d202edb8646b8754c3dd13a884c4f5f3957320be8ca114aebdd28ccce5fb6645f9ff1b96aa5e4ccfaf909b254dbaf93dd9e4d11e70ed91a93227a4131c7e63515f6615bf56c0f5e968a4248262f030c66c0a5452a116f9fc751f759947eacd2e50331a1433f86c8173935285e60b2cf253b9f153707c42bd551571ae28d3e1f12ec18db59108c95a71c417730fdba19eeacbda82127d2c59831ed47d29e701c3cf2026f7951c5a97aa212a73291f5f696e6f2ff0a42c7bf4884c28c93021a75fee904c712f96cdad78e6e87eac244aeaefc5e00c92944fee1e756aa68e81665da87b1152a51d878fa6d1cfda634e7b950cb18f6a26ad6d701f8360a2ab5bfb830a58ad72044ec5198bbb9a17d6f57096b9c38dd7abb67e654255a5ccf4405e36500d0572d0530124ba12962575df52840f512c5c38a503e65aa6c60f6fd2a7d2d7c62af8278b1b0f6df609a170b0fa086bf3ec011b36fb9df793609191f0b34d94bf1a63eabbebf906792ea0a1ed6ca10cc4cffeb7f75519c8ee49dea7f7aa50db6ea951b40744d29b3212c95982e16cca50a213e0d3bd08176e639a507164287228354f2cb328522c46ee20c0a122c71c809fdc339a4aca0063a22dcda3abb2ed0975c69e17aacb2b4984c1ae76ee2936935943a889ff03403a3305e99a5ff2573c70b7943945d06c531a474465b345e9e89e97c855d5c93bc0bc7b53c0eafd9f90fc4ea15b3450792f986cbf530518f14f048abc603dd354dcdafa410ef6f45d3b46eb85f2c581abb434dbed82caadf70804edcd36b1fa912e57f7a0e67cf95c43ca47545eff46ca58ba7f9cef61f5113e9b5cad0df1c05dc5409863cef95e42457b619a00a10469a1ad0c9f24f13bb6cf4446f0f1ed0dc8afd14028e83074f7ddd66ad67f28c7ac300b85583c7be4689d24503c9087e94a4197eb346f7c6c74941e55187635c746724ac6abdb5d644af9f85fa55cc041c0152101924e676b923e02f3ee321c9a3dcbe8e8512f2984267fa1211766f4bab3579ee29a82395167f281836eee587fd8456bf0abc48bf497fa02675923468f75e9f5735398530a80b6129fce2925e9ab3c23686d314c4adeac6ac558d6cd97907c1f91ad5a140f902bab5c9ed86db9cf9df1abd79a38d606dd16b1787e21004858a613fe2b89634e3775ab9fc4b338d84669ee1de0320d20a973765df309f9b0722a8412ec894196886f53199b153c8de28f2754d6d5157c8afcae285c6ee6b6455610645edd07f87cab4a72ccedf57b7ba89c23bc7e021335d59ddb033cd3680c8432bea959e06bbf1a79cd16f073e565c424758e406638ee53fdf7fb2d191d5905cca14c430f385a4facf3e2724be9782512a64293633ef87783c1a12341c0fa345f74fd225505f52eebf7ceaba905fd4d78157295c72d81f8b4cb224a58b4d7e9281e7b860ebfc7df5e801c7b1bc08b8f1b2655147ec3c8c7a00560fab503517bb94be8cb5a89853183a4ec0e688a020d32a485502f29676d9fe8e7c061e34ee3e29ba7b18c4b4137f43b3d10e920db22d3b10e87f7fbbfe86447824eeafbe714b4f13874ff8a3569cb14b5efd10f2b40431d7ef960ae64ff56b00c7221014bdcdda9692b162631e6570eb908f251551c5d068aa55bfe0b0a21a8962449df23361fff301264e69a4e10a8be24dd56f833a92ad7619867b48f11095e2579c0381bcb85df14b87d455b207dd4cff9221e8738da0080689975f672b3de6cd71a19631a85ca6f36792a35effc16e3e373e427e31cf0fcbc2f9e5b95f523b5033222fe0cf42178c0945f1e979ac6ec4e6a3881bf998e1f6955fa93b7d4600bc7a874c589cbbf9dcafd3047d2d163c28f0099ad22d9883ff55f7b0d0211ee4c8bbd4df38c6f5f4289f29e521640c1e6ce3ebf20843e73aac023ab5beb9bc2295b1266e192ae96a53c07975206a733cbb4727c5acdd29d9fb34ec26091632d027b5007e25d91c7cd21274b950805d98e1f60a8efd6d3867ecc5dccc8d7cba8f032761fd81b4f8a76b9b4b06a8eef05925f327b9690e4aca393c637d0d39e7230c4e425e8688476e6d8c1b6d465f00634a5f17ef43311121c44ada92b06d0f160218d77e76562d8c9e803e0c98901450bb83ed8279b818ce9d9a0aaef4ab1811baddf6c97abb8e6393c850ff8b4e5f9f745a98ac66a18402fb914f8c1c46c11d96cd4e51551284d22772c316f688cb6b1fa51add9f51610c4d94521489103e73d359f85b64f441dfb8b52e81bbe1f717deaef48f06dd1f0a42ab1a57e6f4ea08da3f5e876b8a5efd0c7d7cddc61ad541ab00ba0140c1737fb807e0443f165fac707b624b270d469bfac0d7bd87a42b89d7782b9d9591fb96124675cb7ee68cefbce887e5094d3225c7719a901723180bce5d006b05e6b28ee49b431fb30d58616e1886b081015feb2c133d7bdc553634843d7aa8499b32e2ee6ba1743654f0ad19ed46f17ea0700418b32ffd039fb6ef873761abbd35e990ddca80ddf166d2764600025ecf1f6446becc1220c0168acfa8f51124353ea004c84d1eda1f935e15babd4e2e52eaab2715d48f0a1d0cbeaee34cb997997c68a3cc9ff96caf2a5b7c73ac393a7bad4f53c1f7625b87fe8e0bd8b6f494af11ea7b2432e00acae76821428de51b808d7cf69b3869c78cf75a527afff0ea72cfd1b5c3513fea8a6ba198a0a91c0fe26ce568cfd8ea0f48e0704a7436ff5b0be4b9027955ff4ddd90caa3fd9827e9417d6d026a39d6f2bdf9d1c9209b351fd5ade1e2cd3615d601a32d76cc3e2c842794a8c48dfd7619b49c35003a9d47a1a9b7ff5eaa8a4f7dd4fb4eeb62e2a01d7031d06f36a7a629fe7009e406f618355752e8e054d949bdac257412a74a6b862cfaf3dd6cbcae0d81e6295de7602800b9a49294b8c5bfcd0e8fb04c3b1736a7ffe670144409ff8b997b7e430552491d25acff52b6a30b3138596e8afc299d7b2e763b2ff9852105e187f046a58e08a3fc21c8e5886a13c3bbff92f8d27c12467a0508352c69367c1dfa9d0480f398f1253c2a6a70e3171a3fc8decef4f3e59fa99d8724b7a95d44c777c96f54befa618865db3d2bdb819213980b225cc3f59a1f9034477f5856f331f9db34cd8f8191739d7110a6dff5b9a370cf169c4b5ee0bb754227a99318607f6149a5f7990e69b728c8b831bed46eb20999f99409761aa457f6e2afc14019afb842cc0e6c26af9fa29fd672d56dcc1a54deda7ae692b6df40833239dafae29bcc2b0336025ee73dcc6a8a7f3157be5e10d6ef1877a689f8e4373dc1bfa4312a525c0bf8d21b9bfb6bf127ea03574e5d35b38b55efc24425f81165754694d161696fc39675079cbfc8223490aa75e6f8398bf28cfbbf7e9032aa044f693d6693a0d9729ce45ea14abf7083ad55333e8b314e3861711746441969f3b1597e06536353a866df2b1e4cd4720cf2284e7a72c3957cb7037e7bb8d3aa1536f73bf9f0abedfdf76421fa7443611be1cd2a19321f3c623da8fb051d3e9cfb3fbeb824cfba172f717d7f39645bcd5dd7599fdbce2cd8510075fbd3e33990bb07d11089079aac77feb06b4fbe3acf5fedb6585012ba27ce873fbe6eb7110054ddf96c865ad4b94660968cbae1ee41b20e4d30fb378463a063b015f5f50f1739dbc6a4115550ecfe6dfc04b0a85f3b2ca4fdba11ffde34dba9603496d8b17c49be20beb7edb99d2686799d3177be3e0a41a718b39b7a23943c2b6ec53ac149df558b502a6d00eb9b84710ac917cb8ebaaada72c4aff17919f0e066573597f49f4a9649f43ed54a66d82da4ffede5d3cc82af90dd793a01da32bc31460acc8f73baf5053a12f89b46036f82ed85fce1019625bb53952678345b13d2fe30849569f410da624545deb518d584d7381a3aacf7ec7dd3fa3f644c264af97d101ec63e1fd349e24c41db0ca08b96101283fc5457eb483a66e636d7939c52aad2a5e0f5b5e1b4ca56a1779170d51188a9bfbe89d55ce4bd2fb02b4430e4f932825d184da9e4888de5d7379034f399ceb62cbeb9cd45d52047fe3a6dc6576187847ef06bf3b99919638f58e61d5d09ea0070a7d191b749bd9131081089584cfab9a50ba22cff5be2c517435b680f2a1d62fedef571383ce5151623153f6df1627fc5269a8aaae5cec54c851d63ce6d532b431a86ad0442df945f0008934dba07e1f27baa6b2d757958b229ea06d191fba1c481d795605f4e0ce59a50290ac9566fd8783a2b478e58452397158fa4902f6868f3b051b59e791aff0527f61c86732909b65216e203b9bf1513ea61b504673e37ed1905817860260c7c529fde755149a984107713ad9e5b828d50d576019d6c20abc0fd865ba1a4f2a942fa4e5e312284620efb88482643f98ad329653866fb869903948583070ac15c4ff79efcc1ef6fe38e9012c34e31480de10679512e7be98fcf3b70d756bd26bc970edc0d6f798fff9a092874ba893954781756e25147fe3a8571ae4696f376b704e03f1ff10246a2723266e3c82c95ba67303bd34158361753b9c02fd0acb9ac960525def778f5c31193b11c1f1ffd5d5922fd12f59f81466ada9a20847690c16829a3ae54587cc6c81982fbbc1d2e8d8430ee6169baa1b441f55e973517db64180334d3f4d37bb726b2f60f6822841e27f7c81047447d6e436286742de0304d62fa60d85a4896c662a65022681132c8311c0220afce7f3d4d0d10f6ef1b6b5948cf8c2baf516336f6cd06957b352f0b6abf3dedec06fd46dcbf90aa39af543057c41fb3c5a11878f43c74675bfcc2442bf2d6fdb5464b5915f584edbd1a4e45d803550382849397f672b825a2a91a6f524681701ce4cea88419bea97e777222cbb3feb97b02efd23d43647a8095a391cd78e86035bbfc4605cf3c7d0a74364321987f377958502c697dbc10e4399205df4feab9dc191c1627de45d9a60e8707f092b5c2b158e63f8fec66c39691643166ad529a4f11335d82ab83fe05f6ba6d9d37c77cdf5351b7224b72472e1bd2a11daedbb6e41d64734ac320631a48f2eb4ea3a30ea4b47d711935025c7e4a4db5fbf9b48123c11c9ebb61c385cdd0a5f790854ccfcb935313fb252d7f180e6763fb3b89173ba3b6e3a1c9e6bf1832cc8c15ebc1c18d7975c7b62d36c8c04f3fdd96b586b57b9bf3e792015e2624175cfde0e7d0156ab6b23909d3bf3a61d3eaef6aad0ffac38dad8f9edbcd133d959e5f7714c07f769153aee733cbac089566262a8021792cffb9a3e932814f005ed00bca49d8127fad291ffecd19b85ca50250299f1c8583c1872f0e3ddae1ecab72501433629ad19dbf2f414ed51b93865c754b901cf7dfb87e04331e0d06636ac97b1f46b7d880760d0e9d0f0fd6b0f5a1b89a3522b6b81df6d4ca9de1ff609c71eaa17a4536df5afaedc58637e3470e61199351e17be38f25123f37166c4cba752e287560aca4e55775f0f5dc1e15371eeea4256bc6b900c63687e0ac09714716a48a8f3d9c51a05de24986f5bf1256cb243e2b157ebc73896aeab14c3427d5e399f3b6eb58fb4586e31769fa7331b774c8f0fcfd8b625f734886155826d3d6d6287fddf334126366cc31a47aa0511fd82225a672bdc8120e3d1a1b0859b93241bb949b66391e321bf3a93c9e722a05e2583752fab06133a09353192ed07520294791bdd77bf70a1d2550a8afefee1df4faba3d0a5ac8cfe32bc1a099d0206066367e323f8c5f6728ad31f72cc814b1ab688319ccbeddccacacc305ea9e27d56c292aca453be91cb9fcd73154cb92c5a24a627c47c5f7ddef261dc284f92f8a6d3c5518521ddcbf5f967ade8ca1c0d8929e8652df65e1df8d8accc23ee2a3a15573ee8b6dffbb109fa226e2a89eed4aecf8bc26d0116397635d9ec7ad48ecd6ba4af671c95516835c62d6d112768ccdd9f42821028e264f90bf46efce6e55ad51ef0200a042882b98347f8e7cf94c65e7a1e42f37d20e25cd47e35ea74adb0b4c1ed9956ecf60ad0a63374c6d9c98be4ad9d8430b779d927d3669b4f53917b08e288e94a75801e2e4734aae60bdb126d8a1fd7918aad22807e0340acce04e7f615c9251e6efcc341ca9ace07e6c7bd1e7adec0141e1e2f4e83953244992ac1c45bde1a8aa804c89d0586d48a841176ff025eb48100e3db48fb9455f5a5c9b81da81e71597333718d15573e00218e03f4f3a1826046b7ab6e923718ea64a1e47bf76cd197e5fc9a853d655197f9c8f19e8f08f3dea00aa650642fa6130a5bf3491378c75b36cf494b761c834daacee890f8482906b97741bed135be2af65926c5bd2dbec581dbb54c38044f31f76a551d5487695f2ceb2c74671a7571e647ed5e29cbe6687f3fa076b395aef31bcac7f4f74cee32f34849d3f036b30695083f3c142276d13204d1bd89cb2114a4823b92822ef05c8dd3a08e60a2383f377260a1202b307dec246e115319a57f53e89c879e36682738493d2fe80492b20f850702907c621fbbabd232ff0a95d0cc77b03a80984ee8eb63f61ffcd8d3a78525911865886fa31fa4f8e2f0389844d8bc1b3e8fbc10d9ca6043fb06752c8e2c3b6b64083b8512f70f484ab6c1fb81b1a212e80c6919b0aab1781fdac34c812540b4f0dbcf28a1a72d5a691672419c733fd55c7f96d9b4a6a1aa6ef59fda12198ff4c16b8ef069c9d99fa7acf86ee3e404943a569ad909210c7a4ead769c790b426ea46df77dba6a63e281abf3a8654dc717401d0d5c96ecd6045b90dc2e8f17f3903569c3a93d3f2bf0d1815b3fa384c6909d2dd3895d52cf6f6497ceca07e15443b6c4143f9bc1d4b10be85b2706f8cc0ca3aad071c054ad17d44db570fceb3a1c13948fb6070f87c94bdf38c4451ab3a9852bd4dd25d4e3c8ee6153fa3657913fe70bb03ace69229458944da01279dec139ed7e946442b952cc3e7d1a89d484a5ae03c9528d231b3389517b61f979f26efcf8e827be4c8094a8bb881b87781d58583db066be90428900de17313b8bdfe6a54bfdfdd5ce0b5fd987c0f9d439683608f746684443b0f1bb95368764e54fb41f9171553e38a999dabee9548482322c578f01b748f0cff5229adc481975f30ae29f5507b590dc731536f9d687f8950ff67988b015ac1b05f4af7d37919e8060bb0f6464bb298e89da0094cf4839822502f4882567c50e76ff22c11a35982666fb7aff8114529c1598e7abc2d32b3a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
