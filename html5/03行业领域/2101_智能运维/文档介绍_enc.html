<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e463dd95c310e7755912e7b2b64b50bc1276e8c4b5fac6c0162801dada0a86396abe63469fef4380330f6a3efaf81317e4808656674e667eb9f02cae78db85997b41a0e245afa08466334acd353b8d59b1234c9a4a4efb18e4126b89c178500d2a867d9514799d4cf37e3f79e06b13d12676169d516d00beb7660564d5212d7b97f5ca4d9a5de2a6eeb2d3ca2c99a60cebd007eb8de9c74afb6e61c2fe2e57f452c5f9994ecdcf383b7675e40fb1c23e150b266c914a64f52d27706f0d70d228d7a5674572a16be1ac8e376f89c76f65d2113bf0f7f93700b68d90977cae572249485e0825cef773e117e512c1a460a4b9407109821dac1604956eaafaa7ad4a322f1be478a6b7569769c22e0d362f6136213ee0d3dd793ed370469d614d3f26c5d5b0c414dc42046dde4fb5780b1c6ba4e0f83783d74d04105a6bed3d17f1c19b10938f99e560071bf02259116e8b370ccb11d6afbd10612a2b33f76ea1843418dada8297aa5832d6c65100c19c8b701c6a1ff6e14943efde5317748571d344d8d210eba68930d9968b32e00674299680763318e0070ba497257ce951159b19da1d74a8368ddb6ec9bc21af50cd840853ae902eef39299921e52c017630a0a22b91d0f96e1e4a9f007a890f2d5d67e290884e29508b45da05602daf7a1825dcfdc563023bfc01c99a073d3251e3168e3a40f7bed2e6872f1369fae1746b13e331e46b6af3ec373187cd4c5197c632a87e543ec5629c1415077c6740c983e999b34d8bc428475b66ea43ce93f4e7d8dfbfe3c59c3a611726314a5493acee92b6861ee5ffca0356af91d19e3bb64445a3674351bcfbae163fd77a9f81b82d72d7999418e3ed8986c3e098bdba4c160d0a342f1c7c4e5e82920de23fb5aa2b5211b6044e8bad1235913606bf58db1f081abc4d34fc32fb4ba2a10f9f87ed4b3403a867397209c196b38123bbc291a9abf3d55015bde3d49c5c4fc1218ac6c537c790e38cfc9944f1c39ea68c1bd9650860f6e8ccde00c0fc8ff3756b256ad9c960937f9d779de91fbb09b0a6f72e7d18ff8fa16590f58382f7999e6c21eab86004cd19d5a883d1f6a891318a4a6814b513c43ed8a29608d9ed495d5b68411bef25f1109fb07bac973d258103fe4f8f84f20f42dac504a5a276c24ddf3223722d9c2fac92c75994eb3c5b7cc5f8d37b17ecef470e3819aedcd9370fd27fdd61e42b20bcfda0673172d7a8d58571b208f595ded0201611853c072971c62e6d5efac4121000587a1d80c0c6d76537d7f5575bd22aa1ed6177f6d43d696445f99c087371f1a431e9aa849ca68bdcae340d70293d98671e60df5cdd4777cddb98eca88ba85e9e050feca99f3f034d19f42e375549536a9218250d1940c471642e259c9840e4e553d7bbc40ae3a7e879015bb086bc17c6e0d4387875c8e4ad14d56c8c912f5dc3481876ac7c56a740dafea016410ee3399af6bd3aab64a028277d6080039f300d1cebb8d7815442207254415ef8e814a62f8cb2d4aa9769d8ec5b3406732a1ebccaf6821d587217aa1477d55898334a6691eb5a679b1b427ddee8c00fb4b78ef1dd837d059917f6c5a2b647775a932383f471070f6b994ea25723641cebbcb361a18f22a260e06ebeb1ba7107667ad9e58d63c5f4ca102903ac1f248bab2b6c97c7d7b01728d2aa2a7ffc4f256bc2c77c86e01cef71a5627dad97764ae30bcf41622441d601a79a9eec9d1824da08eea910d67211f5a36a22147f75c998cb9e2cd5e2ed185f841eae61da0b577f43f6a112ae4dd494bcc1a9e09623a0bae67666e2304b839060e4e3729296f01424e93b9133598d7a5e275252a5818a94e729acacca7872ae23938023ac6031e94abc4c5da0155a5d59adcf7d1a00773974af9c237f67077c6653d2c37a2fbff36e5ec9f5342657ad27622cb4d93273d5d511aabd4fc01a6bd24f3f15ed7364957b74c9dd137428201800ff2f73ba2d8c12428ba1cd5f623d1a6108daf603695cd7828dd2ebaebb967e2e64bcccd6ba06a1f3aa1050f8fad1d62ce780d4d3ea81667d5002a29e2424125c3e70f15d0697c0cdd1b50620aa9fef633fa416e3562dfe49373055a981939b95b59c3d9cb6187b35cc4fef7e4a41fc4945cbc0c0a27f6aa545f0ab24618dfed3b482abf9ae2d266bf9ec507d1dede73de55802cbd78089801c7d4cada7abcff2836c95b16ddbc642b0b5ca0ef2109f3838871405006251bbba80ee439877544192edd14a4b67dda1c95831855d4353077d0912c923657388b08d3c263898ada968553832f5fe287265795f97461038134642f13ac64d87a681ec224b95e01e45b13e2d19911c056c923d00b6829d1e6f8313f167eeaee554ff631e1425a84df3d39375b037279137313dd16de047b08e913801a82c69c18dbb19e4ebf89a616569f0dfdbf0276cc912b34a668c063e895decc61a5cdac929d45bb2347fb89ab7a28fadf35545a3ea4617e55aef26549c0844cc5442d43fef515130ae32f5ced3bb604a098ae8d58af41c7276f4cd5b8d0fa54882101ec7fe2f0cecf0d6904520e3da68cdc205d7412c22b3c2195b3ff1f36d854b9df7e6a7ca2568fbd23968fc63d72cff4efd8d04a2ae973c17fe6787f4bfe9026592276cb099319fee9a80105cf8d433cda62dcee2e255919cef562a83e6ceeb521a76d485dc58d0c601d4ac2f73d876ed451bd5b7c4ac16f096df61d1b9f317c610f6f142525ad0eafb5f912894888c5937ea031371ed8b1d4b225ad093974d9c18d1141878237a50f0debde77e11ff1ef5f13465bd4d86fb8b8bb2315737f4db01dd0580abdf7f1126a2f628bee4c60238644add3d1750803a95b35023c2f69b0f6b094713fdd80724ae2921456e3353718ed5a7b2aa977b56783f603250ebcc655c096a6070e0b47c413b9bfdcb234c718e7d9856e84ff1dae8f41af4ca54ed9fb9f7d9e7ec48b1eacc3a1823bcc863f0f975026985394015ad54228212860e7e1d37d2f699e4af9094500e791505b123b375342b9b705cab0760bbb688141c2ec5d16146247fd37cba20795bb5c9476a46392be9d142f4afc6a3108d4d55a6eb40acd3c7b16ba1d1513b0932022e6bdce45ca0340f4f75e6da7460b86d8b5ec9b5b7c58e5390d1180d9d10e315dfabd341693170bb8b4f6aaf9d4498d2011d0c59baa707fa9cbc58cead66b23151de858d8e574b16aa0c1e0e63d8a211ce525e63bd99b11893fe039cdc242f1c64de185957b64285268cfe4a7eba5a8d3075a6d74e3da9bc49cf781f4846ec1422255366355707d2fb38323fbef76a4d2a787fe19f61042b80ed8e89875be3bb50b7313c486df0ab1242df5298a4513eb7b4a8474e35ff3324b2dffaba8a5cbf574b2f69827f22ac7e3caabfc14d6ce47e553c2fbbc7db6c99acb73dccf10cce31b9dbe98c4a473348567c2546aa6d7f3da3408f083cd6bde3b92b0645b864aeb5c7604b38e08eba7a9ebfc25a8fba446bf70ff0145f8a4a4a0e3d945fc74be444a66c9daa26e3acc06cc2c1f6ade2b2b9db6b5f6791636678244e604ae96664de2dd47bf1693d9350b6a62d1001f30d764403eceb92eb10cc664ab393ffc1a5f99c6afe7467512aa6697a85fada241b9e3ae30298e1bbceabc23a5ce7fae50451b11e92a3d98b978f66ee16e413d9fa4aff8441948199e54a465bb6c47f73e7ec3492837ecb29e0e88263c30f9fb47a3781f787c3d0f3491b390fb1489d078d468d7994c024a346419a0952a24cd219089842bbb3104abbba55b3568941df424f59078993f8753800967f3d8ddc38cf529cf6c9b861146b083b19e579a0bb1055517f58d88ec633523453e902f1051bc29eb9310cfe84c5a4bdcc9719bd33da129dfb1fe3e18ac4a32dbeb48831cf8d33c76fc40048f5232c3fe7d8892186414aad34e63edfe743852800330ebc723809c7f98cdde5ae5ee8542d9aefcec0429b44ea73348695a1a5a39c080c62f1b3ef67d3105b301839560e383222c8d3a5c8478820bf52781e83692997b1c5fbc0c0f5ad24be3185f9ac242915980b07a756673f79443a615a460813a837109055ca0be2429f364e9726114c2cc45625a1b7846ab6ade164dba46b9d042b32c757d96104ee3a5c104676363a245ce1eb92908621aea0c309223aa34268f8439780d25b995e903604774b5c2ad712d9ef00de25d5cff245edfe3b12832dd02fca6bc880c9206cf71703603bfab80d01e01fe9cd6fcb9dfa4210cbfa2b19029aaa5c545c88465a6dd137377843b7d23932cd20c8bb1d56c734602c9aa8a8faad9ae78daf608839de0ac4f8d9ccf8f6c9f9c5806fc7264687dfc110839c20f0b09d281fb10d4cfac1a5cd29ddfdb5c6b2b2eb72999f1e3025e1cdc480cf2bacdf0d11483de2bfe6f14fb1c05fcb1e7f7763bef9955f4ff10cc2d597735daf01aeff1b68e6ee9f2c0cf6f09eacd8b7fbc3de6f702d6f277399ca0996b9c5fb00d759f8db0bae50c4ff428845c5e054bafe7e3aa0579ba9cd02747a2009bbbcc61002ea7c9a7e932be961ed271644f39a770917bed9fda86f776dc034b1492a68ff890500a59f86a0bab3f4bfcdf548017a1c8543044e53704201698ff52de84302b96f84fdf1806bc64ed05bde2293d8b0cfa731508101db140dbcf4c4cc8ac2ba99a236e1d2240dac77d6ec1ef2a37a1a45f91835dacec6651db7f4c2d2d3b53065471603cd39c7a2419e1c74080c854159f140c1edb20824e4421df3d7fd2c025801cf57de6184d03f62ce92973ebb81de48a422f28c75f440c706761991be395a6c4f192e77cfcb124171f416fbffd4f949266c05c3fabdf1ac157601ebf7aa71b711f0461b2882439ff13f7cc7ad0168b931a5597f56cd6d74fed794724f9db1149be4389f8877dffbb459e9102220d2aeb21b0b299d5f20a9916874e46074b002c8afa70253acbe14b242dff6cbbc221c33ae7fbcd7f97c6af31b326e428685ee6194e9470edb00d189db36a4a1656fd4f3b24253f125bba3c790ca923fa42b6d63399c10db7a2a299a5b93dea9e13fd8fe73967de4f323ae8787611b9babf1a1b0255bec27e32fc57d4f146c24474691c8d061aa294815b220302a9496c8a8aca61d51f0d637adcf2e18e8a58e5970faf15b58b2c44dbb4e57e456218cb7b003e0a0f4877c9a4c74af463ea25d997acffd9f4e86413506205090fb2fc13e8a9626135a6df2ffb9500d7d1a48a4f4588304bb5cbc0f5a9ddeca236beb18dc2787af4dfcdb9957ffaa14f11aba35e07ccff15a00d18cb0bc411d9bb5faa63e0dd1aa9aea42eb9ce4d7d27447b2f06e0322dad82c64da658e94c2b8ef3b581db9498a92997b1c52878302b0bb6f3ad2cdb36660167f405f47bdfc2006b6aaddd6400b874fecbf750afdf155d924bd8a789505bb98545ccb5dee612cd836ad71b9939ac87c7ceaeb655fe52ce46f3536ec8c8a995e15d17b1aa6fa5874488d2227fc94327a9e67306b60b124dc9f5eeea127513df9a109967237d2a6e01126c69576ffddaf95674e759b180d02c18cd1624c840b6654c857c1703231b63850d996da962ad277deb1ca574782ed4792e79fda7fd4e55c13f7d1f74317c3cc11bca22e7d21f2340e7f1b575dc4a3731876d6cd7deb1f66678073d779c165ebf10bd6b9d2c01cc5a05c4debcb33e039359738baaf8f7ae227b39a40922f04b4ab4d3a1401e5de484cd0588bc306e5e96023a2a0bfaa3c8e97330e44c5dd3352d964b0785239d320aa19a39e2c6e0f7640f14cb030f3159d7c2e64a5c427cd7fda81b64b77719057cbcbe3dee1fa45b9b7b68db7ea30ebc7d4b109f9e6217db6fd92dbe06363af75cd7d5a677f7b822aa6f8c174b4d011e1f000bff0537865bc0626de82622f220835d03c92a3fdecca91199214004015445115cc4e20f8cd34cbaf5805bc884419615b64914e6344cf1aa04dcc61c947a1afc45256d4316525c118745e20b37da0f8d3b8a2ac0143680dfbc3200c3fa35cdb767a0b0b09d7b992cab9507faad5982b4680bb685fec3029d27236836783059cf025b30e3f0f7ccd87a72e5a0c28b75457ce0fd98c4caa620f814e870db2dd1c949186933a4e47f6ee8d4a8c1186aee37090e6d6736ce95aee314c6e7c817a0cea3b5bae9d796b25d55f98fa7f5f36925f24ab20c3020f9f45185a23a4e522fa7e94c3460b1694aac6dc9f7f3e1ef58f99b56dacc868166df4c5debcd4df32a6c4b09ee11b369344ce336fec17bc52340f9bda4affe5c1c84c9b15fd901a1878e7fb48281d8d9188147b8dd5c2fce9f2d5914ba5e96d77cd8b516a8e79775f95fbdfe82540dc186fe9eafea6f6f050abeffb7d414930201f814f919f87507a812a2666fd5d71504feca0617c6a56dabbffbdeee51cb17fc6a501302022da56f92ad5513bd00e49eb61379e4566c087d92d5b906c4861214c45261bfc68ee00f6496ff7de42bff7f7ac68c57f47de4484a2a9a672e5719793108c47c73b832ff35b911db4d19e06688a039aa4884dc57d39a03196ed545fc3f647e085fb6d2f755314b84e1215c42a4eb902a6ed314130bb887fd9e1598a81d0ad3b49867573117561ab57948d4747b44772614633d88ed536bab591764b0a1ab1f28bdeb91533e8f0ee1415296e7b9c9bfd61ab921e8119944b2eb17b91e241d6ef62f8dad4a4272baf9b8b4adb229f9d249285244306573e9af1ff6792359594151eee981df223e3f660aec791f083c1b997f35f1e4160ed3d8976261b5acb8cd43242db8246755ac035e694c47c09ae2ff5be309811443187c6713f196a8852986cbf00375a1ef78a64183f5899844abec8333fe1163f9affa747fda8039fcbc471a1bad46d66b024c04805ebf0b3599cc35b1efdd0de4126ad66b7aa1cc56904d9296202d7f2ff286416280176317ca8e3dfac4fd012f1e134981c2bc2a71ba0f8cf7ac650cd0af177150958d41e26488e0b287af5155fd74523bb3c29d3af2aa78315820a0435c6f872065d75332846a1b10ff88312db40d7a046c9ef36a3f2a2c19b9bebc70facdb84c9a18ad3693b65524f8e6588b6ee5da61ba57c1e676680ccc804cc8daab260a2b434a3337078d9332ad56375864597700899d39a0a25996b7e1abe1d9267086a54375e59044c30c8194bf3e4027cb49efdcd692179577b3ec7e344499d4842404040a145c924ffdd7a5b09335223592b19be8cb4cda17af77c9878fb30b77c88703c02e1e04270877ddd750870792e12eb58c7c34d6cda48b4f71de5bccbc4872833f145398c91332eb7c6f8d0eb481319fa942c8bcbf2e974a98b7982bfe4593dd0d69462c2819074942b063a1f595868ecc6f0b090fa301e8d112aa7f2e714a3f3b811582f03d543c5bbf5aeef19deb2ec759a3cbdab14dcded0c48302b96423cce85d060744c0b4b9d416bc827047cdbc8c174a1bba36aab353084b928210a4507502e8c5be212bfbf3eb5bb4c19e4ce1ac9b0e3e8c271767f40b06c440744e35ca408724f2390df996085f9d03bf7cb604aa64ce9b95ec8f04d6a27c9e11d648ebbce71ca032c72c1e811ddfea70a9d758eff147c72d334160047bf4ff153920cdf471788505d4df3a6db313f96d4483143d8fbae14d8952c2f127c9f0998bc71d5c9dc7f887c3810f6f283aeed10286616c5d51576e1d9c67a3340dc05e2cbb1378049d0212da4cacecda7e261c539f3618fb25278c36c2000679e8e2dd53836d1036437b19ea49d1de81be21629aa42b72a0d177c7ee463d33a2a9dbe09dc1d06410eb34ada71ee7174e669c10c9a740a33a14ff7d6216f50561c88f2cd8f74771ab04166835c6ffe21da410f3a34f9886cb298e11bf4d47603868b3ffeb83638c2056225fa5b7f109b5bcab8dcffa36557dfa743e58660e97ea2698ad07f75b5e4ab0cdd6b5a4c8a23c2f5d61a896098a719cc95b02082ff8d487e20344c5274613c94428aa1db2dc050ec15991f2368e352b006d51f64599ab9ee64f6a93f1f6ad65a3ddc2dd1e67dfcbcec15be5b936e93f880966bd0f2659b68979103e19d3b040c8359ced1dda884cb7d9cd60f0dbf02f05ac118b24e6a13a62fe660692303441fdddb8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
