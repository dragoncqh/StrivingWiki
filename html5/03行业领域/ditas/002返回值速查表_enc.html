<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ed38cf3540268b406a2073ceaba1bce5a26f44d48797e45697a26b1ef57ad7049015b93632179df58078f85fe250f80c565aa503d06dccd15f3b3477ffb2b496c792cfef430b5a87e2eeb97d7690c70dc36935c5d0f437414cff3d48e4a54c26ab507d7c836da51a1fdc062b62dc2ddba95c856e803078494148f0ed5dafde5349a211059bf5a2e4e84335db6a8f0a4f7abe4ad60ffdffa70a744589b8b7641e6b8600415c9e1a8fbb7117e108fdb043ce9a40c3bbd908971d8c904ddef50926d820c87892c8e89c665868fd0400a7a95ccae9988e8b8f9f1dd9584ebacaa59a5b537435ab531f76f482cab6c635dfbba2d2acf4519b9ad60ae0379444fe020a56c7faf7b9da13ce1b2dee27b6a91791a0c239855937063bfb63b6d3a799b7bd7acf2c0020cdd9e535a3f83d3dbdaccca6c2f003d935a02a92d4ef8eb1a874d4aed2ed5db02bcf67402d66bd86cb2f3cb228f17a351852f422dbfbb8029dc3fcab28c18aa6b06316ce2585546a6f87ae888bdf86e82c236278aa33d687e1edfb71cb2e01cb271aaca47f2967fae16326bdd9166153c13bf3958d2f6ef5da738d7d107dc5fe03b0fdf5a0944bd4cd115196db4969c76766da1aec236c63477f667f8eceadf2b79b9464d85dab644b707c2b39520f0ed2f5794edd09d7b733cf7e9d90a78d015a8297252111bf65eabc89df04bc8f292dc2fd197d095ad5d7ca1bba5cb5f584cb0ab3acde93a2286a0bcd109e7f2d7044d310173aea1260aae379d483c0b4190fb1f0f73c4c61a10c4d832b8cda3ebe25a517027e3e4c1a27dd5872f6375f7c38068b87006ee263f3c3159e536c010a73bf59afef8e4dd276cd0782c737c8438f08524b30d30c53edf178aca9fddc17617efa74a984917d0267e1ab8e6ff98b2818f79965abe644646466c33a2954ed6e0c52c0c03d18c9f2626e1fb2415324e7cd6a185ba24764ed0cd5e5c4fcf601991cbeb8aa2dd0a7625bc82105f1925a0aa52b720b9f2ed4e9e2afacab6f70a9474d0c3a3a24f56ae182b1d14dd9cc60011bc0fd95b2e99ef5550aee395f57b5ff5d8baaccffae15053e5f40e141424e681f63d4639755b4e762521654efcff57bde3f4bd82861161d925fd1986203750fe3ef5999c17c9565f16c27a3b4bbebf372821ce3a55b1eff567a7c73b3560e6145ae11f8c3c118095329ec2da5194014c58c07da6c2cf8d66805c7c28d35d3c54f7c26e91f07417fab5c4ef672bbd953e1dec2551b361e38ebc112551f8e67f08d1f8c4da9f0ead837757e6bc47604ab3b4c6edce7c50c49e42f412fce7ecb9ebd9bbd3474a8c0580ebdad7c2c01b752bd5cfd283b0b843300d8511470933359cf2a1c1fff25f0ef74bbe7a9d074a9fdd8da014cc2e9aee860380663827b5ba7ef161ed8de7ede4dc993aa9e753e085b8d3a060ea331933efdd930da582fcdc9faf330ee0ee47ac335edba5abbffe99428fcbd1d575372a8cb9f2cc338823a6484c89d052865a99c8d75c6b50a3516e9fa11b969658c3a26f5cc66a29660a9df68a0dcfd18b435124fd6b82f91e93e6b5019e1e5ff8b71577ab0ac7f91e7a2fddaf205835ef27b366ac14205a63bd8dd66ebdaf68ae069989ae81a20d2c1dd72b44c6f428580d07476a0eedcce34e7188b9a3a48800350b8df7f8624707282f512fcb3470d2d952ef681fd88c8647ab8918c7a14059edb23e612dd008c6ef6a854a17b2dac1f930e480d4715f365648818779f7e27ae1ecd9626559337d217bc6dcef601ebac9ab29f07a0fa4ca24605d7c50872bf1718eab6a3f357e4a32d1c4b8c5847f4526d2cb8865065e28990c1f678f77e60ae1b17f37380cb4d357837d92c6fbc220272391eefef24250066a82676232926c5714544942f3182060df0395ec4755ec942ae9fa0c7edaa327b11be18976cb322f5a4073e406857a5eaa135665537ca18c0494bcc725d2c77b24ddd61c91777ba102f9b376247d241ae2d11fa611c179601f649ce31e9032bf6354286d1937205a11654a34933112115e7121cc091bddeb68313305a2bc87709bf25fc6915165a28ac2cecf7c8b23e80ba85fdcdc858f436e907e2b0145627a69be78fa9521e2c4cb76dfaa2da1421664675a8402bffd11e29db72c790ae62d111a1ffe30394996144f9a52212345da443384f63d84dd7e09f0a194259bcca7914cd9fd67a406b61f7d4c0f06cc10282a446da5fcd61377a365a372427e2ac559d8b31a32d11dba8d24c262cc5209c380e16de8ec0dc476d60d76c3f77a4687e6b3c7fcdd7f565862b246f0988b885ca9c11be71a897242382c1023be1e0a873a0e7997c17177ce7371bdf3548a9c9047519fb36cdd18aeb52f8c9de853708aa39867632f56307a3611b3a8fc1f7ddb157d35129d1b7441726cfd91a220f9338387f9f27bc083f5356eb0197921b140fc2f39efea42e8ec98e0ba92ec3205965ab689e5c6a80cff0e1d63b11ad46378357cc89989405dbfba6ffc5ec3572fba4e7e080e7eca39db854970e0863229a6a32d391fd60bf13fd66fbd3e0c2e16abc4c81c44e86c850a051d66d257f5e61b243c7ad83a4617a985fe54e472a59023be3bb0461a7a6a790c0bd8f3e01179e9adade85f84846f42577ef9bcd31625642b81c2573965957cbc5a4f36ed3c2251608c6e4cd5785f1420b90ab76d3bdfa4c6c8615aee036d63c689de1e8de47a892e0af4df5feafb2b97ebb9e0d21a43854461c91b1c0dea6d281ae6ccf87f93a84b961fdeed69615e9674ae590ad81814afda50a5dddea40d4bbf9e5ec4ac1d35de51121de7ab6435ce802233b13245263b9f830a26f2bd4987bc0ed96e6243653fd009434cd17f08baf90e462763c14d74544ad4bbb1d6a710ba7dce325b8893116ecb35dd9dbfb8f6a55b3836adb822e25d027f9da3e6dca3c79d353493cca4811c737ed1abe8b7fc540400cd2fbd4b8fb9e9be453de2e8fd250070249373b88bf5cb5c60f4122ad335d1869e77855093da6ff449c54670554b9d8ec8ff6abe7933476999402f2a14a8368910f104f756ef27a3ee5b4963b549797ce624c4037da1b0b6f5d700406c95a82f2df2bfb2f15ba558137a8a39a7b80792a50f885bdd52ea790d21c81966e5026691a15a99ba7185a2d828eb3b170add7f343cb8859a203c2694db508c1b34ab1a94d32d85db0135c99d1ff0b865fda4e01ff263b582fc70f274f3806d41787ecb7379a700a4605c3c476c2a1c56160554e718b440e20b6a69d3bbd0d5752a8445ac31a6391b84628793cf3292e9c782554ec42805306845b95832769ef7cce46776da0113a3ea36aaf47bf22ac9deea9f8bbdcd24f578f606fea24a040ccc7df9111d9701737cac7bb6b499002dd98288231378af6428c5bba513bb8c15786aef7e3d2de902cf253d4b1d41e11d2bebc6c999c4eaf079aac15bd5b01657e1dfa976502e92ebdb24ba35e6871ad8eefbb135099d07d1fc1064964ac83713ab648f89fe56068236f34415106949cf62d142f698ae65c947f18bc0d30a9b02b645203a2854331173ef82720f08fbf6c9af0ce2a9eccc23bad68cb841b92062507c4391bc4b64ca25c89d6ea3cad3081d291106e680c89025d664875ce726f38b504c21cef0b445581e1449ef4f18b28c4a3aa2e1bbce378903123b04748c697025d101df25cfa02954728daa9b4b66936fcced4eb6f89b0f8ed3a2dd415c5445fb9c321996a8789d31f3f45a11d5ebe4884e39437fade22714baf3fc4451a085c6dd1b0801bfb20f9af1b50373c4736ed1f07181326d7ef769d7136944716c236932b906ff4448ca35689ddc8a35c9faa408881b60c8ff7a070358a1da62e0b07f1c77ff36dc927d181adb0717ed55c9f87ca4ccc2ec85c096ff8a64fd85a9b956366d5e3a89438a6d1c09201a27043e61997447a44fd613b3ea764a9f4c92a5f29dd5c1bf9e9dc9af54c16015a2c9d3408b65cd812397365251c637756099577fb213f22b3f3cd042a0f741ac95b11c82dcac203a46a1ea7cc369c7fa3c54cfadb0306793cd5d3f5f6d7b72d544858d6e2e6e9900a8861b21277672f3f9370b1f8f07bbc5a26851a79010bea3651e016ac907395d4007082472f80ee1402d115dcdc10f63cd3f8b032c4ec5019915542e656b946f244389a20d6978702f8a41248193f5d99747fa59a6695beaddb67abc3ea96d3d4e830f1e9ee5031ed93ce2c54d5bc36b9133a51141fdd0fcd114520be04f06cddb96d8117de64d56e15ecf935ab3d1850b35fae8098206918e96a7d2211fe1cb8b2d2522b9d409c88c1423e567d2d953f7c0dc746252867c8b7154d4011f3a21c63de40f3fea613198abfe5c541fc0367cdca34032f6c95c7ed0b66cb977e4218f506d7860008587159e50101eb8332181d0f278306666386896b906ed99f249ae03ff5135ef2b87bd017a29f68bf87999c0922875ffd92925dce6519dc344c3a6165433747a89d414514b4ef3f7bc539cd2f729017777557d3905c4dbfafa03d5ac1811a5732398519ea10f85b0345913a62f09a2602df2e379bba77a513208638e7736783285843e4396ee6b4a0aef5f68b63b0d163d3b93e5bca924e477f8592fb3507eb193a26aac4b625616ad7e1373f3f2cf0a32d135a7daf8e96f0dfb29f8cd3f73cc3d9e6ff270c5b7022421094a28e29c9c0b24d882f6267e3fdd4e44e410c5857927ae8951db1bd926a89097072b5dea8ed3ae85b0f8a15be6c51637d2ebee6013fffe82a6fb5ab46de84d1eecc9f929fe113f5a794541f6c34b97f085e885d97756eecdfbcb01325fee8a6a34c3cfc3c2c20f13b46ba01d175a24faf94238c9fc60aff67377bc7834a7f3defc0704413dbfb15863db09dd879db25e3bdc3a80200cccd4158d138c27abba707f427915f756fdaef14bacf6123da0e1c6e49f54b6e5346e25022c01d368a4aa49f4fd77efeb89dfc05d6989ecf4928b4e42ef44f3a5d36f16428cd1c821b3051d37117d63f671e22e6ae6bd9d8c78a70c9408345af02b1f24f87c075d154c23472a78f5b02926496b1c9c6f26d28a9ecd7d78f6503add905a394ae41c870dc57364fca75d4cece516d28a051b482b1ef0b70e38626aa0fa5f470ab28e10cac0061d270c7ff9ac5badf5a5fe45a856c37258e05a65078c318cfb1930c9b4baa6ebd5de0f38e2a8afff876954cb2db335dbf01c0fff0e636bc21acb12b6313a1200e86a00d2091fec6b0fbaf60b1caba3ddfc0a9e0b364761ba408dc1620b808d0d3512e6ef11f6b7373e029d115a1d9e4855b65d702e4f38687b0bdf2d79e5f48165cb34d4b0310b86c448b33608c206b9eaa37efc9415149de8f7b92070f596ffbfc892213dfc0fdfc624957f98786be57eb546e35eebd426c13baeac9085904fc93aa95d2ae48ac85c575609b010f09abf9bf2ee46efe0d865371a67362a28e4efcc12ecd6c1ba892cfb3d7ebdfaf7a7a829eb15e48eeb670d9990d89011b5721fa919d8bc604b10b67c30af64a924986eca7c513033e34bdaeb5192b6bdeed2982564eab7da971894b59cec3cc37c79dfa6818f869a4cd0fe724473c0e7941765b202f0cbce83f7c13d313a6311640eef1f92c63f40b30fc76228b8548d2414dd4f72fcab56fac88f03fed472f475c09d524790dc872b34ca69303215ace75617e745863e5c659ae766351165210443d435193a7a46e6b0411703ea2efe8134afd0d9ed66c5455cb78037d5f8317d39a7c762d87163360aed56215835be63596b40fbd34eec3a8e6bdac9f893e3c6b0d441fec701d867c078ab6bdbf067a63dab088ee6a6557cab84d65d1869f5c4b5ac5aac40c7b8c26f7d937addbaa859939a60ded8adaf8bffdc46882d843b1fd515872bede8c9ff53fe1da4541da775970a9ce7218db8677fba50192b6ad64e5215965325425c0ef93b70bc28ecec08b1adeba51c8a0ab01218ef9194365fc2bbcab6643d1f9e5e2a4e270c07f9be80efea63a8f567c682cea8dc423156ecf9487facb7d6cda1e63c4c588897a7f8c721981a764ed93e17077d91c149f53bedae60406d71d4324d603d09525257f32b979dc849e4345a9342ba284320b8f9cc1742181fe7b7543bc5b4e70a4f90f53648d7e72a8fad300eada7fff314b73e5afecba3da14e23243aef3846ccb915a75e3f75d77dc14bad067ee977aa2f542ac9fbcf29f6689d9173ed4c2de19490bddab37b3430057496320ef4a5647ae44e0768b643da2d5da52b913f8c986e019fa13f4b3aaf43fd8d17bb52c08ed699005beb2084d840f0f05b90c181cb0c90bba1e7c89de0e8eec57ac2901c1651a30108bb0704cef09c0fa6f7a05d902872507b7c006cb100712956f67f24846582f5ccfa4aae0f94d3b19947c7596eee444481946447014c6917a428f1b005526d1c5f82750664a900bfd21c641a541a89ea4b1d7d02007d3b14da677ed3b20e4128b3d4132d7d90a6a456a5634cb23b36e8920e366b12b6159b913666ed50e9e4486765371848b6c38fae1cc77056a6612c284dfeaa5cf90e58ffb301ecedff7b4c9053aff5a0aadbd6bf3635e1dc7f66c516826d1671c136f98a88211be0149fa5ef8c74f092437fad7d56b1412eea134eec43fffbe283fa27d8bd0655917ae74092041e460e3b7e459de671e7e02752c2c35327d673f276192698c430f102bede67c5121d1c5fb6e85c412c8b4e070d76240d9d64561b470d64fa7cc0c2cb190cdf45ed66c06cb936a0524e26d9dd408c1852406566e985cf5fb4f886d778a4c38b730213b6bf88886c9ff4bde8afb78760add767b219817b4b1852cea556091abaa473669a5df94300f137c925738df376117b1d920b0084d1b2125176cd83572731c22b96379c7bcaef1c5354badc96e8d158a72c48db58d530b99f972f8362eb0bb2f250c952b3fd27c57be53273bcec430ec2fe8bfdc72ee3c44f4a1dcb7b75a044964f8b31ecf6eefcea2dc83d015568868054a08c572ce682d19cdb8c35e1f59240bab4de55b2768ca79fd8a13a5b85e707aefe7acdfe3fa817ea26b6e68c2a47a58e14cd4d0b28237c432998a9edcd9190212448de9fbe9db5ca04a7457e889b9a66badfa68a96cf9cfd181fce3922bdff22c7a83050bd993498d6ab52a7712b760cc59543b98466db8bfdc5cd22cb2c5f223d180f3979833b12b8dda1e36b940f2f6cc8c58ef733e0cd1e3c3ceaf39c859925cd2cae0fa619a04558713d7ba0e7563621d061c02cee17cab4d16ff71408dc1e79637b4e13f6b1ea59bf34d87692ac676506699692e3dde6e0dba5e08eb6e32b3e92bb2e6c6c8ef7e90e6d3a7ed594f90d91185c3378517a54df18f0ce39a9b2f3c90cdc354d673e43dd35c29f092693dd70cf284be2243fc55fc9e0a315b64de4200adbcc7a7402b322eaf3d22a934ce5ff6e871a9983512cc064618eb90871a390a0034b90f8434ce0521cc3e663b584295ed759c0cc21fcff62937606e8115be84fab96f17af975b4370fec35f734acc5fc46ad0e2625da413da08c4dd64f3370f1b3b4ef3a2cf08fc1db63bdb88e021fd97668c784eb8c045886c8afd7dab3594eeabe51619bce59560d2b78e11eeac8ad7171c0cbad6b0e031adf83d972902f3516d7fdd94046c1e44f78577e71a0531ca89f507e57ea163d2daf0bb35aa98b436e78f4179a9d4017cc78ded83709af46c71b745336dfd5fa13dff6c58859960881b9fc86c27783243626f4c92d7da3f725a19697ca9e6f1efb4168e253b240d44d5d3d35a1d3400bffb19a868af1ecd8675551cfcb756beca28a87524d92c2f30261a23d3f7b3411617ce2df96b1a89d0ddf32591cc45f5c632623ae188b1ccaa9c5cf587ea69d6727371283745ec8836d5a7859f54893161e6e65cd9e89a511451c33b56ef85108a880e405d1589103950cdbec2210e69528f57b4d66ab1f548007f121076d079133b39fb0ad212b6a2e533bee00a927081a2a33d7eeeabb914327f6989e9ff35fc7d1eda29ef96948faac8b91ce2093280588c061feefedc62ff1abb369c287c2f61eafb86cbbcf155d7d2e7f984ca4cb00537a569f167a7d9b088772adb0d16a82e98885549ba016bf4a4d84c806c5bcbcc5adaa3d81dc1ee677fd692729d7927ab60642941ffd3bfd0c43601297750c97b7cf7b25a0f749467d93aa8843b12ba1e0039c6b319b13498cf966f7bd574b71bb69cd737751f3860f6eaa6239dd6fff32ab1d4539f5c1f059d2a29ce5e4e45981c789c3b1e61faf2a993cf8c814603d1f93e26c558d661a14da89b779b4ba63d965ff6e87b17a634242b38f4d3c2893b0d3c5d611da9d6200df0d3674706a92f1d3258700eee38314f8e2060ae930d8a9034d9ccb4437a8577166650266b29a216671ffa768e371beff9843646c58531eb0af69f08850c8564321dc274b4948182f1d721bcb1000231f1c13feac06ef07aa8c4a2ed3637cc1edd03fe7d207ff8d2252a4c63b1c027c8932128ae1a708e267bec957aa8e7ac26ba52303ed343b37b81f4d284c1f02948c4ed8316d96f8fca28f439dcf8a1181308fc8d8b6b3c72f9357f6b754a930f5cdf18527b3d425f8ae0fb992e5956e58fe9c8f565369132a4ba81f78989f6dc6a26db4acdcc7523993837d59544c3f5fa02222633d698d7e81243968d51d1ebdf045ec8f1cce51f40c091dfa4e992cdf924f79f6610389fae67bfd5ad34c8b906474f4bcad714626e088b98e1061426023aa95a467a1e68c9a515a03e9063a519f466b18b8976544e0e252b7509341988e51960fe00927868661eaf53e403067f620c05f8490eefe46747f6fd4c1aa176f92b30ee19f1ca4586bebaf822e80c0a9249abd63093600000f3dac8634200c062c776c7fdd75fbcfdd0b9a7cfa94209f20be8a0bee057042e264af3e47fb5a4a40bbc57189b6ccaa15355192ef26f2dafa8434014c0125f11746cc0adda4d6aedddadd96f5fdb6a6789660d6aa9e870a60eaf6498646a5f6e3dddf2ac883fae0768d24393ed3a87cbc92aeae8ef34271615b766a1bc853d3d9e383f860ee07c0382293b70f633949870cde21025249d327bf69c948fcb8ddaa3791670f1b59f300216580a67f75b6627298990b2d09f4dfd31da0e58a5f39aca2b6922c7744b325f6b13d1be636c40822f1b3e7dade3e61390ff267db63f871343231bf48d421a88ec42bf64f42db96792c50e3e475a21ece536baf41b04ed913dcf4a0d84d6534e94af1df2d88d08845d50b4787ea71a00f8ff8ef20205f4d4a71451120818a7573ef9c46e642776cc3ca93ee3e5e0e153c28c380a94bee05a68c0d37cbb40528aef1a9cdc0fdc8b2b244a0af7d6ee6c346663fb87d697e623a769b5672d870b729c91a8ec5f91fd2bed83ec3e778b4e42db8b3865455a1bc0fe23e7d92bde7b22d8070fac21c378630258772f0eb1b8bfc16b8ce91ebec456061e786ddebdef0453f186d56d6cddcb0bb569a5c96db6413ed5828895000a74eebed34d2a5bc7b01b80523d25c6a086fe5946fa3fec6e3dbce0f243599ecf48601c7e997b003b326544821b084dd27a9d96f36cffb402f32a5fd1b91e6edece244439dc0016199d13cba24017b76a7e29f4ca976933fb0fdc3f0d9ba54c2aef129d57c6c6382cbec7cc01b12e3c58cd66610720b3d599136794434b9ec81d5fb440d80cd4f19dc5b353d59a83b4fe01af1b18471ece70f3e5d344044db001bc0b13e65caa28a411c3144214aac246eb8a258cc5a97f88ca02974ba96a4c3a51c414d10e867935381f34114dd6cf5d5b2b6e4962b4aae5740bda013d24279c97f35e4b003ed4f630f2722101314c964c41f70ba876a7dc883eab9d57537e14a13680eb1efa6da3bebc20d09043ebd6f450d0876bf50c56cd1ae1aeec7f17ebb9b2176dd0227a47e661e9d4526f499412b70f423a4a8cf257f3bc755985709b7886e197d4076091a27d45ee3748593da395edf25c8e852824ecd5ec0d18bdc9116b2e9b58b519ffe8d5799ff42eb106831d3a6c8b19032afdb3f5040093ddb5d0c07dd513992f178171d2bc98d9412b4959216c9de2d2f07ad76cba4f1cc04f457b16b7df0983dfd16957f0df2a3a5794bbc4dd1ff1d015defedb3eb18b3e2970d5f16c26a44897ed9b1dc23d3470942eedc5c26d16e9e91e928abec47670c365f1884a6fa3d1d1e0424f4b1f1a852889f6cc7b452a189d64ca0592b75eda06709d65d217780679ecf7c0b348075b09bee3872d88b96de141f2f4435fc8d18fdca3c2bd4786e9a642a4aaf683b63672199e67bcf2b41d77f7a8483942c78f533a9085de7cb81425975ed15c7d76dc3a1cf462236de5c331a306645eb7d10b4d276c82744f8b966d1ccf1385ccc53e10300e0b6e16c667b32fe62d91cb7ce59c80c2b1ea9b2b641722c65dd5e6998b4d06fce45fe7e9cf204fe6d96e0e8c10b67dc2883ce657b9e3e96173932211e45910b9fc1c8525050f0beff82bf19ef279176637be7e4061321fec4ed761809e3503292f7d12dedf137d5ea7b8d3c7bcf90ea1a82c3a83b319abaf82461153ac7de18360fe9eb1006ed07a65524245c0b4a88b8cc9381a219ee76f89bb8e88c2e706d4625b0c1e057aa01826ea4053a1af38c65091eb8295721db5702c566362b24cd3b06ae1e148326e7b183082a55dbc60a9729e4c31f13cbd62bb3f56f889a17ef53161817483a302d31aa482162d26bf33add6de6a07ee2aa73c5c3ab4576a17562eb1c9e8a61d534b736f76e9925c40ec9040544e39dd46801d57b770d81bb171873e1f20f8fde5d938a09b0f3999b2f9f3c4bc1a3d893ad438ecf5cf3f9e4da43202e51a7b730f6ab08f7f0889943847256ea0c0ee90e60e2cb82f20e1747aad8e406c0c76158825a46aded3ce150e36bd0f9082abe563cd27cc8c6e7ab14f86c4ecb4bafa001c17cb35a1960e8220f932802b52f885f93368ff5a22e8fd2fa1519536b4ee53f9c0999fefd0ddf3a56d2afb62ba57a79f0c935609b5c4eacf34de48fe9be53deaf1bedd1d3374d54947b2720449276a420f5d1d88fdd12f42cae5d0bd6a6ff6d90c671fe944431f2c0ff3e2e033b3110dad631a59fbc2a15e9a93ab7afdcd8f46b0bf3e76753a39f19b01ff68cfac6e978e3b501c16da7255f35671d96850c10882052d03a0ea3f64ca2fffec7deed8f82cdd9734b6cb33ecd53cd9ecacf141c6a8a7a683b990e9ea979e3e9794f5b6e8d8c9dc32aa44c7d0645308bee4b7346e8ed95892532cf464d0ce1430aa8b6a8a09d18d77428287e42bde0c907891e7e98530db4c37d37e995384c72554034293d564d42b831889635d4ddcad7e1a02e1af95e5f0625926bd2cac47552af09673cbb81a220394134ba0e14e2edaaaba9a554b46a7c7f1f7a8ce8f85bb008728ee1bd45f1163b9b1794cc77064395986f90a2469c8a0616a632cf1739ddbeb1e88a65dce0e5ff94f320cd0a1aae0a290b1dfb7488cd0232cd9085d85540b7c757c46e82568ab42c52d1b7cd083b16a11bbc9f2cd7c0068290dc7bd4bef356ca861897bf249af6bf0ade12d63f2b203f1d36c6e43f0a50166fa23541961d7b33e0d558e30856f84559802546a48f15ff2b731d66424f8e0f8277f634fa2e769506eca434682ed2039d4509e8d4f43dac68b5cd926ff105222c2fe0bb44a4a8371fb4eca4e037b646ce59229dc837d84db74e749ae07ae6c8fa7c49518db45df6a7eb176c8eda5e8a1021ed0e2c7577844bcc4f4b922d6ada49f25e2b7f27a753068060a0c2661c442268bd0ab1dcfc0e305dcc53408a92563f1c514af932d4eb43d1b3e6af2e6874732a38afcee6963eda1dd22710f0651a309a369fd1a5d0dda188a0ef286d6e61613c2624c7a36367260d9a000955be639f72c4ea34247432e15e606c91161f109e1493fe3c1eb0eb1b40ec36610a50f815cab6bb7aba9690055541cc69dab5b90fc675f2e70939ca176931ef31b3ccf352483123a3d6ebc76e25dfd49fd4456fa5ca9e520d434d2cb8c49d23cc231e640b1d3fec8fc50e10ff6e49c01ffcfcdcce22a5a577fc948e7479a0159218f7c37789929eda89b2fd444cb751113ed8446575a7825a23353bd73bbc2ab75765bedc92a1c4118bcb8a24ec2a31c02a6a4a1584e1be9836d81d5af0359ecac6b66f95701fd66bdaa3e6594e0dfbd3017f8743c67647369e81ad8d4fbb697785a29632fecc5dbf10fa38ec9d76148a1279de30047744a6c4c4d6539fa22e8845041217c44c66c040f31fe58531c62ad67a5cd469e1379aacbeec1f10dc110059408a81a20e50187259892b6ccd3905bafba0dac8157ace6233e0e513d0554ea8d5140d3e55958cc3435a68d669beb9c7d53abf0659b5ca40c9bd4a1dc00f9f99b2539cc9854c5e65f1f489d783bc0bf285371c3c4a0c978f807","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
