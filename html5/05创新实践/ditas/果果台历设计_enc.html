<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"86922f896a22a2da8511180e01b26819eedba898e205812eb6de36f98535220d38f2c6afb3b2e9208d9fa3be886b1130dc3c8d6f430ea13a682fe6a9fb2d2f38a0a07055546a4bd4d5e1aebda550614479f9f2653f5a737aeecf65dabfb3565cccb59affe6dad0ce33a2168afd0875a72d895166056b7e013ba1846e7bf8eccb05f413a30e483ff94ea60a8005c97b8a0ace4071b410cccf86bafe84de1efd1524db6ea92c5bd5e72b9b19f7d4799e242a68f9a65410f5532379e85cf28bdbf3bfc9c73b5830893393c40a6578e9e2ed56335d33f8c56443a7d711db1c3128e5bfc09e59bdf867a216d07c4b95b8cc08018e4352a1aad246f2f5b589157298118210415402bb17eed24f63856a1c68a0ef8dcbe79ccc2ac7d5e6476188025fe0c590de5c91071f3b118f18973a06df1b9999d4287b17af30f645b27021a1bb71d2984c53b849d995ba3ee8922be9e64f5f68af06e0a00816decd54aae7adae22cb3852cb2a89ab6b410ecf2a36c551fc3fb7a6903978321b19c6cb07aae3a64390511ca80107aa72c3fb5afe92071401424654702946302dd27fe477b454c78729c992302043f1e0941b5a1873b7c3b8595de1b8ac8f321a8ba0779828eb7574c82dde10319219cc3b55d8dc226e28fe53b73dcbfc4d2735f5dddad6ab45370b7a7ec4f8b1d1a057f46de4aeba32508265a77b5422364b16ca8196a4817816e1fa117ec4a07d0b37e10fbc005c5712e4ca40c232556e52272247030ae9329f534b4860f7ff27f8d1ba934cc6c9bd12700daa2516beddba19caaa0016a5f1bb61043995bbf0f16f92b2b034aabf30021709fcd00542313b391699053635fdf7e8c429b93363676dd06b005dd271815121203022188e54bcec1ce24a9b4791f644a26146bda141b7f05639761eb6b0bf146b68d2bdf652cfadc824dc05224a606786e669286d16a4995ea9116e87879fc69c5522fd9c462122d68c11e1f6278a73b15178747d55dd4ad27abd8e389bcb4a5aa1f3ec528a9263b109c2483efaa6e3e98dc8bca2575e4a85dee548fb242348b303e12d849ba2a62463e7dfad5b9e54058779b042399b6c482c5ea2042a14ef2238f73a504ba8fd59fbbc72e64d3a39d12ac78efab126b60813a7b6108f83c4c37334abbe14ccca889829fd833a38ea186e5b3b0a80bdf98b7f77c053932bd17e47f973d725f8c1570d40c59481ac397a9b1deb329c3f07a688d70d0cc123fde18194047e61c9134ba5fe086dcd56951dc5f9e39d8583b843409f76413114874d5f765797813f4ddb20aa8e12018e29eac7fdd370b009ab253991d18da76c06863f0477ad311f6bbea0c0d2717001ce8caa4ab150ed70b145fce8c82e70e3c05ea7cf44268b8a12fdc9d59339aba89c2d3752bf8d9ec3d6ca2942be44bb1993c386a1ae8e9616c4aea572481bdb07c42d86cecf7a0464f00faafe507cd88d4145879998526c1895e585bde2b79b6e47a5e62709fadc2405100d97d546699617f73b474b0c914bed35aba058d809e765ce8d7345c1c7bc183d745ca4c9c6ec21b8bfddc11eaaa0cca19c503d157f339fc5a952fa1d01b591d70de7a081d51c2100f78b37cb31260c8e426d53bbf5ead28ade9c4e6983e55c5a373d61b954061c882f182cd560953e4bca2a2b405081da989d865b18a48e9d110cf5c647f0967f610c198f0cef254ff74f268ab6e968bd2c0d2a3bedb4cff47b517b9ba7359dc5bf6a79cfe6a368413386c8346286bd83f9cc9c864acd837e8a0d53aa3203d747cd7292f82e44b40210ebc60ade725b6923fe12b21f3ab36a3f2230b4eb65d956e40261901c54e910e93830be6de14f96ecd45bf571c15c01402c48c95ac6b743d31930eb6bd462c31175b07e970ad9995e66c595bb660f4b7980258ac22aae3790e872162e62ee82e1b3df0628d9fd094081735d37a1151338ddb6db56fa5a573de2eed7fa8985795b6441a00a10fc2de96ba51189cc5ccfaf8c9249d73d5165bd310b3c46c253da4ac8f32eb7e013971cf6eda5d7d22f7c9cec0b5ea533cec7e7919ede564ca647563e2be3520efa0020a0b187397ae67ac201c3663f7c148c9493b4fad901b2912d040ad7d91a14422b659a7a47f4378595f39c259706e2092ece0f780fdc4e96cd6c1077dde955d7820823274d40ea28eeeb88b195e15ec1dff0de11bda30cbea80bcdd0f4f91dd4f6dea7d2344bf8ccc620549457cc016ffa219826d702e9ce99d4f2c93ea7feb5c6d3b69c935c76145903bfbfa3b91f077fa1565c651cf8292ae92e052f78fcdb13c092b274c5f625f07259122728898daabaf2deb0ec948f993f47ff8d1f624fef6cfd7bc8bf20fc01e7056b4fc53824bc344ef24ae2742e6e52f2dbe2aa67665df2d678eb58f0fe91e370e40a6d071ffb8abaaa254816b7f7417441a08e1f77a85fda7fe8fc253b9fdffe7bb5e19490f9642e8dc5ff101c36f6890d099f44908e05c40856a8aa099ec3112638a1657470b1a5c0d25876a49d04a50e70d891ff3db2b27d17c482279f296eb83c169f16ffdeb19f9ef91f27527510ff90e5eff379b11452fd825e4dd81c084ef0a5b5614d7dea9e17dedfbde3eb2ab84420c8ecd0fb8b083ec090197d6f43fdc42ad25fda3ebbe853f8f3bf83223c03fe2b265b11ad8952397e257c01b24467972a4d6ed2fbacc8d2cf4493a3a0f0c517ef3e83b58263331f6cdbe7cd268ad55393e9690c4f9bb02228b668800b7bb9f52326bdefc57394e4d65e01b987ff88fa47d281d3a7f6d6951c921e0a6866aba213f3247132e89384a470d70aa858c9c6a92e794afa311311d1298e2a3ab27a70cd3efc396be0d4688c5828c8790f0207405c9904d18e3a768b0a9d0d525dcd960650a187830c07021a1827e89048e283f0606d3c0b26b5695ca259ad9d4b31e67cee89cb928b20e6e2a84e3aab851509347c0ae36086d8acfce0f3a90378780ee7bed0aeabf9f40e43b9432794b6a57e527404b1e15665c155d518033a6e2588d27fdc6464873884a464338ea5c5aee796f9eee3b48a0fe0369e5eb3442b70d5e2e015ef998bcc452dbbe86b89a3766254984fd7aa756223f7af64cd7dae946d8afa5ff4b0bc94177c62bfbccc8221e530bc1bb0cf0fcd8f2ee281e48676fbd59c08b69d60904d70d774f8e08919e9b955c61da88393dacd414e1e31b92912ee6185f47c87b81d0bdc469c98265213f47f479953171c0ac77c6c47eb02bcf56de63721661bfffb2d30c5652af1f39a24a624d58c99a851f26512cbc99e1b7cd3df483cfa57c9e75d4bdfdca24fca94be8fb7a72d463a71761717bbff15c2912edff80c248f4be05613054b0be0144edd4711672289f69f1f7c27654023b9f15620a959c880048188dda12c3a9816435b733e02caf7d9dbe76484d6e78038d0d4bcec53eceb9f901416d8ca9ac58d2634cd4b94dd7429bf19b6338f6404e9bf39b7f1a8b500e6ae2531116a077f51af309902fd854bad56e0795e159a4e21c84e34e55ec6afba91b4e6666c9855f7c6df32e8523f3ad04459fc44c929873dc668c1d1b1043c0c63eb201792e5a4d015d09cceb21453aa1bf122f3273df439deb3bec9fbf3faf476adddbceb16fa30f9c71c46fa008acfca5df538f25e7f6b05fe99bbd1485010c0d811980d50efef1fe87633dbb19baf348c7a7c11ac3ece77ce6955208c4627b84b8340e4f422186860e1c8bd853ffe6155b9f013bd18010bd58bc0b4096ebac975d5e6bb28152d7f667569f21431547415413864ec7b791f41eb8462186894a661adc3c3a8f383fa950974b45040b1a9db21d6802983bbf140db9f24286b248f02d0710f7e23964556115dde42897fb12c376791739f388f2d26dd584b4bd172adc8ffdd0a6ef87ef1e9808c481e275e4aa482c956e0f07523ac62a83269a40347cfe960df1841a4dfcf7440a73575332635de82c6d8fa81d75f5f0e956db85ad6d2ec3cd3831902f27c6bc5e8e9b105f0857dba1a3b048eb172998b6b583632507e172eaad713325c50cf164e99519ed911904389353ce6ad0b7f7e7ab4eccbf57de49a2f50fc05c086101e0286bd8f77f0db313a0a17cbbbebb4d48dd964c18587f902e623ae120543f2709c7d1fd87989c746cf1557725515e47f508fdf5880bd98fbfa31076812f406cedf9696286880925413ff823eb1431a219feefa3e7cf440f3fb1a875fcbdb16e4690d5fdcb4fb5fc1d5f34d59c4cb07b5bbe3cd657f3cc4e267a37eede2a75259401c323edcd195eaa194dd362740ae6468d95d56f6560ca4211538ddaabf60e9b36beffbd51256a97d014c2fd8c79a6fee4a82ac403e9ab3eb6b991cb2e0e06979a07fe5069837c24c6af6099b05c5c5285b50eec5ba2238b86565113de52336e62cd8c1cf671df212b7fdc0ceee540aafdfa1ada0bb4ef13b938cac2a987195ff77024b116f3481c2dea64fc5fd0b68f39073a622f462a7c84f7d1ada7350893ddbb07c810b750a06c3e5cae53083e1886ede3fc61e0ae977d325d87f2144f13727229a12e10226068ddbef7bf6ff957bab927bca09effc51cbba82d8db89bee64428ffc7eabd641d41cd867839af707e9f1db0ed7ce0df01b13670e12baabb5a497428de7dcdd2131a44cd627304e33fb6a482017ba7063de3fa0bb1932b5dd5d60b777d443b6f7adeb2a61bf61136a22e4b444b4ed0491baddc9820630b73fa91d4efb1d7aad4af5f169f53ca3d0fccdfa84af288c14116f64c2162a3d69d5af789a78ead7f27c73cdfcd1583a8204cb826d914a51020a435f3955f8b8213761dcafe585d5256599e65401e800bcb62cc384218d246eb968d00cfdf310d133509a4095d9ff195363edfecb1d1a60b37c8313009565c64ec05b8cc61d96f24e3c1398e7e01880d4aa225a97ba112183f86f4f74294a32d01ad4adfebcbda564de26cf7203d2a8ee8d07452b23c1b300190facd7dc0cfe66f272e6eb0f200e40b4c011675c6a41c2bb3c9cc13a84988ffe6149ede9eac1ee3f308d60833aa60dc2a002b6b2b114a22738647ab07b63b5a102e05f20f3dd4f9a651bbb9607edc739ee240e0eeebaa46f814c90e18e87b5baa79c385e58d3ef113b829a5102a1c7f5f3648e74f693ccbc426bfc91921eb7479204206ebd08682e73bc81a035af80b70a0fc9a948b475debbe30cca18f8a9d181d6316b901008dc11d50df86344e92bcd1302519bd659b57fdeb2d091afd6712f8de9049ff39d4b36fb91ff0ff414e32c7d896f9f4ef46bcdec931ff5d589cead201335dc87441f79400431a9109e23284e6ca8cd0295bb2fe75717f44f0e25774e45eeb5872704c8dac407a374e8b340b95ee4418df2c9478f0655eb32e4e33664a1ab360e27de999fe90f3b53702baf709ce75f5cfd6e989144c346bda759048d3e58ac94521f8a993ab2cdb41e300410595230dcb8b3396d97e1bc1823e391d30333b16d45a178ab050510177110473c79be186f045c9bad8547928a8958dc938e18f0148c7d88eaad4fb8c87082ca7b535b2b70fd42a02c2cc6db4d66bf109b957f1fda90bbcbd7bdb0a1a2877d9a00336c839e67a8f503cf98e4dd90c34aeeeabdc7ee7d0b4dc76c96972eb0b0b76c5a114c68f643c86f0f5aa3d1cca7150ec47136c40c5dbee82ae8935f48ae4c51a2f3973193bb06d926b6477342e8db146dc24bc8a8aeb062eac2d192ca707ecff7ae47858100b17b4c99bc61ec99fc4171e3bd14ff77500d7c1cdc60d43e0d7aa8b0f46b09f28156a6d14a22ef48aecb6c57c2b0c4721b711ab0a6305b74251e0ac7b89483eda0ae69eee6936ea806a8d005e2633b00e76b080ec77d235a479ee27f5b610a999eab0884f2de450e0d3757788a677b364455ca166a1af393273d7f4e0a2bc91189ddaa990a3a8c6f63b4a139de88eb904c0644923ce8b38f5b9639a4460975b53c5703db5da16971f3cdf2aa2dc153542d378e901d8a367ef2efbbedd2117110155c4fa6fdfc0a37e63c60dc5ee5622d09020a359a3e10222722101749bf345c262b4723b9156290d5ddea03f054f5bb39167d5975039f2614efd8c0aa4ce7c2565b042320e48652dff9c0ed15ed4ab3c1b4cdc24272760d94083eeff8fdf4031009bdd5dac261a31d09ea547dabc723ca0b4544ea1bcfb9d4c284f0ca46075c920183ed492e7577e7a7c3352479f56991ea8a58ce1c7f7945b2aaa3b64031dd60e54bbbd497cf623219fa930c5d5d2a1f52fe952facacc2c5b495c9931793fae2d710db1a7c6899e8980e2c273aa653bc3c8fc5062a870eb9707e68c834c00575ae34f6a2e16e7f4ac8fec399d9cb43ae12bfd4fe64658ab12effbddb25c730f25a106d8a67e2e04a82ffed36d5dcb50d5d924f17b38343af596e40a360941cf9bc9ceb9ee6c8b214b8ad5a4ea39bf82bc6d7097e2077318aae350ee9c2e72614b00a83d5033680e02d79dedd945041e107a9afdf2148bad1037c32952ef1bf69e8e5362f47a2395757d4a0632c94cc8f01962fe68c9ecf9e445e082f4ab8224e7edee5e3f6585a7ccfff8bb4532a7ea3478e127c3ead5f7e29f1920017c58b43fe26993b0b4c8624fc6f856c913afe6c1e758618671cb3ded7712d5adbafcfe37d9b59177e4c1efb3c14fa6f1b21c1c92daaa4e8f75f4e1bde73f69824408405cab1a2e686b65e8114c78fc250a3fecf16d81eaab31936a9f22c5ca93efb4e614515d88d11fa8874fff43217e46f2e18a2aeaafa33d5d78741d505d7d95437b27af8c346a170f1de4370b5608fad75e761707757e961220145feb96d4d05d08a49dddc526efcf9ffd77823c599d5e3cf5bf07e965985d08d9c09418a595db9a97187b53b33c865889a56708799ab68fe74539e0bfe155c681779037243602e6b1b5ca070a05","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
