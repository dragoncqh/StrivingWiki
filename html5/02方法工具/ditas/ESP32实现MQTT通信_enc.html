<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d61112d73ef33a2b16217c3f416017dc4b4545b19ebe3350c99059e9c373ceb49d21c1ac8a2ef8b6fa10b505eb6a9c8ab83081d016c62ed938d5806e41e9823104b5a19685bc09dc0b7a58963d287346722ec408c9ecb927f9c7c7321ec37f2aea530ecb681688abc55294ac5ab142ecf9334da9f372d143e5001da126e3931e02d1e81eba86d3b9f9939c9b15d9d73b7e4797379081dfc1fdec8be8f34e044c097427f47780d14010d268975f8b414fd2627302b8a78083608e940b0a702e8b281b182826990ab6223392e70e8fa53ac48984bb0fc2eeb022051c7e141f29beebd53d29bf66313500754e948da01cb006aeedd6decf2e2c7b1a7ad770d24e752e46a43bd02a2f3c56498f78e77046043f82f83c440e9820e41c43e4517d66511b74e52f93cd7cd3ed9537e91161c16d1905a67028f90517d58cf60bc3088e02e7ca0b8741d426d2193a90199803eba3f95323eccc20be53a83e0f75efd7b662fb19467fc1c96bb5fbd0f9a6948e0ab114f949208dbba7503a3913dc16e731bbfaff202752d2f1939b50a72eb3dc322d7a9631e185467c796619de79f1343bba9db4d0b3c5a8c41fa57b2f1ecad29a72ed353d5bd1fe52f290c9df938a3fb68eb2211c3109f77b6f2d8fbabaeb8de615f8c01f8c65eef5b0db0f779e1e9a06e65269bc032058f7d5527daf3230066153a8536b1aad8e76d782a785b2c50ce472626a2d9b9f7908193cb9ddf2626352c2e0215f24272ccda07dee3db0df66551bb620a55cf2eb0cbe36d145e2ee4480555987a6b97a74f4703140738ec2b695e816ed365c512727091ec9a90c28d003df6a72790a0cdebec2c1faa3964013618971d4013c80d27d4d46b10185fa6d1ce3800e0ab1e907c83480e99ffaf3b984cd17998ded70af39d2ffb4919f409de77d9048336593d274c8ea76f5cf8abd6097e0e32f0aba9fd6483457a04d8cea0d1403ef2ed0bf4d01e162bfb30869cbaa0a735454dbb5dc8faab2ab9253cdc8f35bc5c9e1073c02e71e2738cbca22c8fed7c8c7f75923732925063e0adb856f5c7241e178354c211d245ff281d35092afb7db79e67a1377cc74c777a83ca5d3351a0415254cbbc7117a3b807dfbbf060a23b985dff8d318e6d1ea820d771cc66e1e681b3c495607949fd79dd58027be68baba6908a04526889f7d4261967242a6701652eeb1bfbe351614331695d2a34b1b1d3da37893bb31f52e1b198f326ebd76cebaa2bf2d97fa6fbb16919dc059f0565dde50d245fb75bfcc741c8cb59569a9f560fed70cb15ffc9bfac3615d95fd6c678dcef53b9d19364b42aa3bb9de6735d5e7db1a33fc5a6369ba1a269998a5436c0d7e41a2d48b7e2f8b74229b296294a8c73110af52491080d51f8cd739b4fae4a98c51b5909bb202fc9ba6923b23625659bcb77420766074b83faf377930a259c26ef3c1f6964c33fe84e6a42c2b2590d73696ec7736aa71366538c71afc6890dc9430e73cc0d40a47de90b438538475261135985c4ed01db99cdc33b236f7e19a3cea806731ce7f390d8831d92cf3624d4e9752fc75d6ac7c5faf84420770fe8fec377b49b410c3c47128cd946866365656dec8640afef14eab0facc189d70c2e53c85d09b664a669c908b500ed5c0d320a29c193a86f24747c20cd1b36d0dd20206872bc70c7be34831967d4bb6991e6fbbaa208a5fa333e99dfd73f0c7753e43cc19c6f39c04afdd6afc366f62fa3b3202c40dd040421091de5f437af11fe88023b36f6b036317b6504f8d12b1f3f0b8a02cf242dfd94cdf223741d04165912805ff49434ab126932e6a7c6aa428713fceb02187f2d1a49c056108c3e380e2dcd5676647d59502278814c35dc4f0c9e6fb0f805981517571504392e59397cc56b4474ece09ed8d446c004732053c54d49f4aaa29ee87d2aa21b56969b975b1218d2c061303e9ce2a696794cf8cdf9eca434c744084f9dc7c954a2bf760501b8c0e96ee08bee11020c01bc4600b6737ddd7b0f215c8dfbf421d0ec899dec30189695f9c6c1ed4f1b60ff43b4d59ea14ddbc938c60ce368312ec80e8ffbb404b41fc7b5c1fa794825710894c5baa177ff8eaacaf1fb19a727027647054115edcb02182f30e041ebbf66dd89d5064f11052b25bfe58f2a14980ed8ff23ad19a1f520a0c0a385b270eb9ac2e81cbd705c1b28ecbabc6d58d48f8ee328f45c4ddda729f4148935e36880b6fc26da55ad573ecc4c0fc13cd8d69131eebe0e306db1980959aa418818eb428bdf4dd74aa3c580821bc0a6e52731ee0351bcb05f886d326a4e0a2d5a2d39aa917ebc1e46d616a5e9c77a386ea0bc5b5848c39a30db3336f203f4e07ebc9b9b86b8c01c4cff5f76329675724824f015f1f551e7bb4f5b044a04f6320ca2ad8eb4df21bc7885a75ad52889955f41c321308360a067fc2efe2deabbe89f7b95da0dca904964908d3723c4284601f8972b93e360b92142a6b282ced1ef5fc684bff1ed4e03bcb0e1ddaa66ea4d42eec5b008add2dbb4e3726d40488794405c758d3096f31e5b66169e11a5d1327cef28f84825935d559c5d95ac989e1f55e70c059db554ba394155de0600b72f01500a17f3096f58c4d10d0a1e0a0d4fc104948d29a43164d999d33d0430a41fd9a3a38dffc9f822b7b27676d6a08062f544ff664ebfdbf28ac2296b24797fd0500596a1fbf850459173ec04d03f82a109791a9e0cd7c219179f5ea7c8595ead1dc59e7982a9844d2623e85edb4a10998cde7e42cf41db19fe798b961812efb4e9304adcfa40e9cf802dea01f971d7817b8283e08eeb2fc01bc56e54af6a429cb12dbf0f960d9ff83ee526cf78b53f4158b07004251059ac6730234a6a4a58f738f1887e1652b9046908a4e8b5dd34fcdf23e9665d1e9fbdb7c2265a4f75a8f69fb7fd57ec4287e87b62fe250ee015ecaa625c560940d15e4569dbed3aa8e35f5efb9a18653950737453dca3e3dc1c2dd9e79c5db0da4518266c01533dc4d4ddbb12f3a68f5a8d05d169712bb6388cd1217cdb3835d7c72735f945dd7f92cf054e2a4c65a27609adbac36a724a3a7111959601de6b1f98e341f1f746674fde7fb575ad2041a7132bbe89d519a16a44c9080d4eb677b5f42d41492023f81ebb4346237c8af2ca98a6f03f9062d9332dcadc93d7ee6b4aa72fdd97fafc09ce75f553e4d4bb00ed1270cf7e73dce9943054f5e047761278491d6a0c7c06b9962b90373d23efc091382b538aef994edff27be0c68dc05a86b5964e47c51c3c77bfa6eac3ec7e7d21b8d6903189fb3ecf6ccddf6a2be21713d479fbbb06765943c982d639e7cbf58885ffb30663f36c8e815fa5a060ed97e6577671510388440393e642c39d32dcf3fb879f0078714a285a3c1b80cc7cbf0f8b812e7039662c6a0273d2c44e79732fb8560b88ef9c12b2390824fae1a4b40ef04f17ef951ab020c036e0cb2b8c0f2ce4a470f57511e1fd57d949dfd7e1224f42edd03f5933a565b3f1f3bb6b6df607f00019f71953bc3cf5b1d3fac122bf96b8d8b212d32eb1b98a0d0a031b886ac34d46007273f032564006263ecaccd89272717b95f22283f160a1ae30255c219d537761589648e023f84e4c5b73a145f57cedb24f352541184982a210fdaf80b7268309ed82f6aceb69d7c6c85f867fa6848ff3ae590ab879425c98b56ec898a1416702004b23a69e2eddeac1c200d0c18931bd4ace3f03a65e9d94c3f3f8cbc60ff306aa7ee47cbbd396cb2bc5528a0c656658b95d9f819dceaba715eafc47f53f7cbc0f55ca4422a3086dab787d381403bd7d1db7763b717cdd339f20279a6db94dd1c43fd820125a485179b593604cff4ed7295db95bbd52b573586d06f359f40321d1fb16666e6a3615dc02aadab6e35b7d9272cf0c5dfbeb9e0e1e3e60a786f22e56e0fa17612a382b28762f68214921bfcd67e9b8c40947874ceb31214f4ca9a3844c21e9d48b95867f826494d1250f18eabf98b22ff49be03e0f86360fc343fe3ec2a8b3b86c7c6539c3a3657c86dbc3769763153bb1426753dd2e678395f7649b0a2a29450c96ab27b34796e4ecad3e2056b18ff5b794c9df382c51acb3bcba93df05595015b15e72795a8c1a357aaf0ad4abc6268a07080896013f8187738bed4e022ff6c44f4397bba50da1090a6c338de3fd3dc0d193dd4ea7f1a4eff0471e9509d94998109566174c784da2f05d3b217827d45730adb4acaf12506670794a4e7fccb484e662e10aebaafa600741b0acae71f5a45184ad194ed03635ce8c777d17033ff0733f1a9eba5d1f1206cb4f4aa18e88d013e896e176a46d3e04784a45f4bf507ab31e04556eb0639e35b699d627889fc0ea6f81185d62793d90e60492e565ede1bfd28ff41b3a4e59b006284de3e2f6e621872be2336cc3ff9d3c4a535e297422fec49c68d908d93ff4ad0a6d7e342f7cf8fec3098c329446d90196609fab31ee62598939548858f04194eaefe2565ada65e16f15c58ebe0e04162120d39a0591cb5ed67bae6a1b797eba1f050f865ca86a18672689b303cc0c0fa786df70fa11aee1f0cdb4757019defe48a9cc1b459286d666b636fe7da36fa876214cfc1c207fa6f13ed38a324fcbcc591918228c612a6ad616f7a228e411b8dbb7d787c458b94a8f964767a21d0ef1f0e487e30a79771690e9a4fc34dd5dd8613ee4df76508df5e2d526ed68f514e97796294504c1aac9db84e1767d34a2b8aabdafc28998c66f9fc810cc367af3f73ad7e5d29df4b6fa4950768b6fb733d99b76b6defa1684a0c3f07fe1598deeb0e4c0363088e899efff5aa2a72c63280522fc5f9af0e95e5527b216db8e914b7e281742611ff37db267f82deac175ab68a5ad5b126f09699122c4d2a905eeabf3cd65e728ed3641625300d247654a6cf0ebcfeaf4adafa767e8ee3904e477ce32b9e6e8c94326fef27e46d1fb31c361cdf11a9b6879a2ce73362808b94e8989c06ce07d3b40de2f15a6f84240ebe2e6cf45ab1aa6676ef652d2fccb8d1431faf5330162a23ba42bf5b6ca7d581323075a0e1adcce0ceb045e166063d72a83fa19ad2241f90f331f77159080a9b882bdd53124c1428fe447f5932d81193c3ea2c9f85c53905dee058e2a47186fefa4beb1921039e2c99ac7845f9f473317b98f3be023fd656784127f7033a02528a1f7e06c5649b8121cc609fd13a857d7e751629db7db063e51f326ac30eb7d25b82e80fe0fc19ac61119f83cbadb7f576c5875cb2ed1869343a3600fff3052d14a30c95161353342b5c956b5e2c32b76b239dc397efb1509ca0169d6cec91db0506b9671f6e9296c684b219a15021b89542969337a8fa7d003c07418b4e526c7e897e69e3f82f2dacf932d9c8bab5ec1ed4c40e0ea12d4ebb29b70b9e6aaad7690a0b08a11a50205d7b3d4e6e682e7bc1314088b1ff792a617821268f4062efe0cf735719dc857c764afd560e11dbaf12232d926c92959900fde6b42fe47c954001b84a64099d5a6aad12a394a1d1dc704e37400c32cb295e6317a1837f304cf3b87021021a5a754b32b473ccbae364307f28444a43958832254a85f2949bb8c2e47bfdcb000a59c589d4b8f8314b0734cbf019672f1d112ae6b7af5e7f9cfd8279067be67b69a80023472be0ef66cfd7a6fcf7afafb8a92e0ae6d3407fb03ecd090e4fda8d1cf08d4ef46b23f2e97abfbc08c100fdc3e346e74011a46ace0fe3f2a7ff20dd5b0c25bf42a3d0f5402de41f8134a8ab3ee85ff78c0d8aec604754dc219cbf6ec1f018e3666ab4ea05c72d24f46add178d27c196d38d69a4933a74d7df6bab8ec874322d2fee7996d50b1351df04bb4011368a9f73c00dcf7cc6e6487b5d0e6eae8cc555ed4d62da3dfffec219f02092621595e065236a5f795580465f06edf86d676dd2bd026e0118943ec9eb220da71c4d0ed74c36bcf218281a2aa247831ae8335b2944feb34460783569e2f03015a5c63371643651d530037ebb9572272236ff6cea81cbafc38bcdf715dfb05e0080e97c10419e930ebfe5fee450207e99e7225862149a000715afd000c3fef924a380ffd90da468af53d3c378f1585d38a7658d013c39887e3f48f5e7bcbce822fb2de79a9e8bef2dcba57afc1f25d8f7adb960bcf258510b25d0eb30acdbc4c47213f08df48b4f18f9e0c7f57b2f874f66e95cc56fc989b965ffab7fa6b3f3b0c9b16cc2b8d4168993e7b5cd88a9a9bc421353e4800b1e52c629af33ce4ccf776942c7d1b030e22801c1878c40ea96f092668e7e1967fb42cab0b8b0d04a8bb65b683665639b2686c973edd42d003331381e12c606ef161e3ed2280c70f437d0bd8454646e82e51de590ef7c8ec15f03d571d98524c2d980d547f09d91134ab6b771b10189435e1ea7989d534ff806f94b229ff6cb191c69fd9c484c9fd200fece1552e4fb119fafcbc10f7c43cb42248b520313712343cc8ff89f5a496b25e9c313094b5ed8fd3680b503d6e3757b8a7e65a3b9b6f9e8287ab284eb13c7206a03e4b27a190fac06745ad63a88e83219f8457cb7dcf4243c998261c5e2363985001bb821c7cee7abe1986d142d54dec738558828d006ae06c94c72c5f0d74caf3042c00ae9feef4c1837395cf2ba92c232687130a28d2bf35e95db143f4667f36ee27f7d3ca65acf74b905755dc0eb5fc6d1c1fe477a7014eb4c65696cc6afbabc0278a0c1e38d20fbb11bd75c6afdf3c45ba84c99756b1012f28a492d0596d5b94ad41b47e23c94bd8e79e1baac27bb504167d6109970f23669bf3558a7d4d29fb91cb62eaa843d55b8129f9e83c78489198320274f15980c2c2e88199f94d3d460c87a3527e8ac3af738ad63d5d5e70e02ae93e63beaadcc82ee3214e23dde1cf2cab4fd7b92cbd57cb63bb00011bfe7489826a567f7ecfc2c73b96fb3fc11f9f10e8b0c3641d22dddf14bc276d134ccf5962232744cc2529d11c586202b0ac7feef8daea46232ca251f8bd0a85bfcce5516174845083ab14a43cb302b837b0cf9bf180fa026b0ed6ed3af01643cf65eab822580e06ce7c324237c75fa49168915d1c0ef6eead7329b3edbfa84b7f54fecc652fbfdff597b6758e79926d3ec514c10a9a2fd3ab027cb9448370cbfc22b54d1ff24ff11b268e954564d82d60852f2f270c92d72fd757a17bba7054d624e9c5fbc176cb9926e7d0b2e1c04793d5204543c74ed78ef0aa0effd469289b52fc6fd1ef6c11cbf1fe32b2413fa199bf33827b8b7c889d617db6511bcd7af66fc922197ceb289fa4ac32145a11dead2222181b4220c0acc440a7db041548da7ff3671fc63739c474f3da3b0f464a6e453035e9df1e698df9ecb10cff4d9012cebc34f56fb9cadac7c0e72256f07ddc287e4516f4e2f14fa523192ce44ceda4279330d31e24fcc6e15360b367de1d8b51384b07f077130af73f41acbd725062e4e2053ebf5b25b9795b2da5303eedc382566fa2d76ce56b3ee2fe51e07b2618ac9867c924c88c10e8d378904ad6ac3d66d69e2992224052562b6296f3ca472296623948f4e76d5ca15076bbedd10aedaadeed868c6f3d88f52d28ff866309376a1db6d844234490c00238c898350ad61fee5d139321bbf1b247b8a4ca7a3ed0f99c5365c3c0d335bcbf00e0aeb1381609f2276a5f44d4e89b7d447049cf07815396231b3ca68d0cc95b95c9b114cad9ece77fbd836283f174a500dcc9f04303f753be8df4669e6fb12ac5145111e6ffabe791eaa6b4abb1ab8d9969e63109b30e5ec43fdc54c815981c480830536776225d2e1c1898b642495c4c9e2f9354747e994a5d78b8da3591d26bf9f8ae5c138834cad05d994e6eca2a95868367bae0f7eeb4ca9ab2ed6570f458c013610fba78bd504f7362638d37a8f8005160bb7421c0b94e4e649a5281f06f0ddb4f579da00b99cf1226343dde6323b3a1cc8cc3ea980349f83badc10d18bd756a0aaed1b987df06e5ccf49cc82d636ddca1d8e8445e310ffbc097e176206ce6b011a01cea9744925cebc19dc68540484ac548a5ea9c7936fd5988ded6894fd914b920013094f60524e4243e5a9e746abdc8813edd7d40f3fbcf5a9efab94208ddfd2992f312da18b0f7ae8fcd05caed2ced44cfeed5dccb058575428b40f94976d0fb6138e018fc8ecf26abf6eef4507e702651bce6d635755f450d724df7774e06b9bb449df25796a20ae681bda0a35f4f9f56026f01bd70b2df37ccbd91564910758af318cd438d56e126cbb972543ae891f17a5d60779f9a090fc6ab021c26cefad6d4b6ee78e2a16966a9993aa1bf7fb612e01e1b19cd8b809bbb49f6b1b6601aed4514b46a76e0673efd62d3586da4b3a7300f9f366eb79ce4289ade621aa95c30b50f0c4cfcae23f7a8d0f14f9a1ed4e9f309b90195f83ec58f48c1b9c79fef8d486eb2242c672542ba39acda7aa4260d9213c3c4b4533bed9554b68331fda49c99dbd8f909f83f8f15b0ef0576c79d462d9be49d3dc820c386650e26b7798288b9849e306c48404b42514c7510e51bbca021b8c3bb682a973f6f131d449affb07a86b6fe863a4a63983355d5acedce786f3d0f9d92706d6053bb41e7806e605ec07eb79300d8cab30a3c505e625e2932ae02823d89e8054925cfe2738ca39dfa4ff3deef5720c8aa2a29e50c12a1c0bebebe7f4fcb22ca6cfaaa82a75e7974b9cc7147cfb4d74d1f47ad6663f5f71671ed4944ab244a4351332169491d4fbd1ff71a287c404eee47798ee91fa3bdd70aaa1408789dbfa6f0e36f2ca25a88d18ee3236918e32f3dcaf5d645b09e0bf3d949d85ccea5892b2139a228719751b23018b1f8ff5ccc0f6da34e1faa821961c94d0f3614a2ea969ceb4b7880d02f5fd7a5c61a94caa83ffad0293aee9bf3b985971bb3cba4760077f9d438d3bb9a076d31111e47e026314481d11d3eb20fa3287391385c8ee3e06b62b8157a44ab53f68ab87a707859d9a62b8b16b3cdce91bed3b459240451db491241e66e3625f32de01249f3d3ccb3e37468be84da3b6da7e17014127b37eb5e1e4a15d6187f4e2e5d4e593bc051ba488912253778ea963807b184895b2c10f25c47550d36f1a57c9711fb039c9510ae8bb3bea95d7b8aeb159422fac88fd6af05995a8f16c6c8dcd6bef53745f201788edbb9f0f47f1b7bdc1dd25373cfee446077627f539b834baa7813bcfd256e87600c0c8f36b582811a774b313098278e67985ac3d86fe66481761bb4880918e9d36eee43514aaf9550db4e03ec194d1d8b2950b4a79c8925fbc8ded5bbc20e426a2b4c7123474661c51d9d3cdf121c7d3a600d1ebd5a437ef8ed32deacf2797ae295877acd6ce2d4facb06c5ae8df174c9ea0145ff4f06fcae23d2d9123e76304263a414c8f2e8d5e81bfe38a618770c10e0fb3737f791f5f4935a42437acbb77c193ee7260d8d13b3a4244d063cc807d4002d892d4e342a0ac0c7c416940cfe99bddc55265d247a6e1e1eb9f7a3badaa544c9e2cf0009715e1af6af932e7e6a732f01f8664d3399479b0cadfb691f9bdb6976258fe07012a609db381102c90402eb9066e521c5ede4aefbcff5bbfb915f66d93755683ec974dd2353358b3e27bedeff4650666fda9a87220a19c073d5f5dff61d446cafcec7700100ac49174240b333344fb9a73ab6b4dd224601bcf7f7104135da7035dc39796385c0c93922ef96af0dfdf78d213442d56274ebf0b962852548d0f74246076538b885e0ab624f5494f24b9d57173fe9c5dd8d45b306ed02d40bfc4bc3ab0e03fc14eb600b513433eac40cae0084f8d6689e880c0b3ddb8ef4f68200c7f72931df9aba84399607c9fbaaa9017524cc2b24fb8f0f3b21341cf608975657ca227fec5c5d6da5575fc940dc6f36adef4e27b4206f8ccfa9fc3aa8dd5681c4d7bdbbcdcb45eaa119c90e2b941467b356d48cada4e422f932a365c826d2167f3809de35880bec5a48f23f2d85def77dcec5c1c4db6b66e4d66555c059854aa8798b0e76c85e263e5934414fa253515b6bcbd05bb65ec2908f7d2c29fe82b0c912513243d03db5e700c489f1cf726c54a8ee5c097afe6fc5dd373c3550a5278f44aa9a7bee5120c29f8f735bdd8f30cd1b4197510e0a69cba275ce3c42471967c00acccac650c20f6d2668b5c659005c6370bfe0cc695d879b004c8d0c097aa963c6214194754dbe64988d5a380242a4126093ba0aa9006b60991e106dea9850367b9bf6df4140661e2f039448a31172d0afba0ff12ce28c544dae0fccab81800bf3545e64cdbe74a3d3fb3fc1f10b3d5eacfbeeeb27e4cbba64b557785ea21c37d7cb65ff83abc00e1fc9465e745aca7df7e9854bd5da4af0dfc700216bdaa89feb224730e618417812fd565ccf589e444805dbd092c8a98e632c032bb6dcda2eff00d3c78986bef203f088c8103c0f86f2511445755aa505c86fbd847ac1ed83e4e9fdaba629d0601f372bdce71a0e7475666bf442ad58cad8c3a72f5d96b76d6e2229d971b10dbf04e1d3017be96c710699db1ac11bbf297c959d6627358bce8fbe9bbd08ebbafe5b2a4ccdb0d45f6e734fd24ba502596467e642786f7839cc48c656cb3ff8522761b31ac8391346cddff9740946a58d361f44d5cc9fa546ed21e47bfdfb1b3450f13c51cd67866b31bf3a8c0806b765c006566a78b1f160141341203553505e1348d0987ebfd7921bd9e26a22bb836f72a2031e12f53b02751ca93d7bfe352cc296c2b613e5865a0f86b20c6a0ce06f4f429c5d6588068c8288dd3ca0462fc11817e9a33b14572a8739edd88f6711f63a7678dccea59d96e7099fc7ee7130a67fc476487269eaa68830babfb7aaaf104f4084663b95bbaa95566deb2b70e34340fd0ba5dd20de8845b9efc0c7e41538319ca139e67b217920d41bf0521b7254fd8ab8a55d5c5bf7207b1185e15e3ebd269aef98fe164276a1d1df4c2bd46d9b4a9a1726b4d6673bbdb4e0e94578bbcf32fee63bd15b70201ab04389a934bea2e5dea18d492c9b7f7ad73f2c3ed16dad26d18b17a4de0daddd672f3015662fc6128d75e3979e4c81666cafc49d5472c6448b03e7691570bb06ffca6505a8fbdb9e3318a8d5fa7e4fdf0034d2bf4dca6524153d36fafa8cb8b4524ec3671fe7486215702f11eefb67f5117e7afe03526276198cf049e922a162a203f4c6ce1663168cafc10cd7f5487ee6adf87b12f5d8f8d988ab914777dbb98e79bf3b69e75677d2eec7d2796c02c2b33b514e3c3a79fc7b1b1715fcbebb960776624d48b85600c279ec9959cdf13ac7f4511def2d381e088964f293430d0ee5c68dd6f257df2ff332a503131a5adeffb58798a545547525041ecbc256a30a34c657b94d2f551a7f133e0e43909c9193c5ba8622abf25949a32a50592c515edec6d45fa9c5a6e3d317d838ff4d5bafbce50bd86acb86bfcdd9218a4f8494aac7e39e935075f2962a4ea1c164191c7bd4035c6cd79505d8552fbd66c06999b353deb9ee92e3ddbd6f7666943defdac74c2cbb2e31823a59c0498da95923f9d409178db324f7658fec4c86e0034eb974b05a86cccd9ff7769190912f1ead97305a81bbbbcc5a6260c928e183b8dfc153bf67cb32a964026ae4a559d7226685988fc63ba801f104481b1d67ac7fe2b6f776cb9f6873da5ecbcf96d5526e4c564fe310be41c7fd0da0dbdb942b9d9131381454418d2bd25b7ce648f6caebc8623f60256ed075b9d021b6238f77c90c89174fe871b9db53fcbf2bdfba04e40bbf2a50c574403ebe14508bd1bcdf4b2e914a5dd179e6b2b4ddf1c927f8ac41acccbe790419cfd20b47211ad216369bf33942ee097499724c375b20087eb9725c1c5c2bf1e5e6201af0095c0df16c7ab3d3e524d6a538754347cfb964ada9bb22c19083ef064f33210525c4a234f7fc1d32e35399e66cfb977ac8a76b332e489f98e90d97fd88eff746a95b1e69f5e7ef9eb9c87de03ad5413fc6b800f0ab012c1e471205cd6ccd9568cde2904c916659f161b1f136cc3e50744cd671eb2a04c031bcb6095cb016c103f88bd1f8c4b042aa2b6c82d32b4c3ca8e8d290ecab98e1004cc0d74150fe2a08157f944722aa1a2c69efdaa085408e1b2792ca95861e19be873e7eef6c7452af11181af9c9fefabee5e349a3d2601701ca97decf5653a5aeeadd231d0c7c5e51cab47ce7934634caf398b442721272d9674ee6bef14c28e4f025a49e16ba117e25ea0522c404d912ac8baa2763c8d5601e665e9b48d0ff81f52b90315637a1d305e2d15afe6d9a36d296832aaf4748f9e28f068e977a89fed31a29a303c494da1728d98df8aa7b6a1f514036966e96debfca4c8589a5a08443cee08558a91d4bc414778e61063361c29d3326395fa0e8ff14c23c1a5aa42","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
