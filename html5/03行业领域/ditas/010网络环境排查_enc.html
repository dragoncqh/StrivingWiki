<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"99faca7a601932f428c1393c5ec77373a08448cca1b1a267201d4cb399394d5bbe57bd548660f1c18c6f256b1f3d4362681481f67c2c7bbdbc941a10526aec82bc0b9be2bbaa5261a8b4a4af2772bbfc268b59eca95013da5b92c91ed005bcf9e5110a73cbfbcd66b0f6486a7550fb629e4d1ce209d1f8212fb2a7a2444ba9da2c0558a22bf35fac9f1e62a0dbaf44b8204096f1637579bb379db7abd141a19a536b8c1706612101eb035049102f2e9bdd9db6b1de69a57b15a25ddfa421f3d2654cf9a5938d5603787edd1c1d5e52adcf739d8506391a23b41919cf5cf9253e26205171c59261012a63efa19de0ed25fad69d894143c526ed525ce8b65797bda569299b0864dffad138fadffae84ed501681b79300dedac4d2415e0fa0142ec8ac884bc312911a96c9805c9213ee09b091564c67d82a14d5a7aaaaed53bd20ace361b411693dac920d3dd02293981ec1941b89fc949133aabe1aee4f84ea48297893b0221d4aa0a12bf14f2e874621b1bde61842dd83cd1d94b44afa75c41bf9a1625b4f998fba7aff4c742a5aa22392725d67f36a6bd70c587cbf75d004c2677a4a484037957687e84344cc0b73e9cc189985b8ee13c013f7a7bd19ea8704c963a0817e5114e7cdd26dd5c89d021118ff935829d06e37688790bac6c93cf3d3f442fd75aa130d13d3113398adc3237d9bab43401c7d50e71ed7a4123f0bd06c66b41512a16217c876f176d95a32637f6e9ecef93ba32e0f9d9819c637bfd26b2662cf4a5fab7861426ccd0516eee2b3a87f9edb3daade20d946f6e0290d1b181afa09e19f0ce0f52a6c61994adf6fe006923798a39826c9847a1387034ab8a5ba4804ae06ca8d10d8bdffd44060f257f66068e0c4bfaffbe9835a28395f926f4a41a7876fabcba92daadd5abe3d69fda4eea889b88bd0ded10684f39c349eafacbb8b84834a7d0ec139e76a093268de9286819a1507a41d1e3446f20272954163652a94c73c7e30e58151ad56ee78479242c888c4dcf3621b3b1a38aa35bf94e95485a07ccefde3d962872c831384f818d13354b75eb80b849388d184b1f88ea5fbacaec8b1e267f95e6024d594eeb564aa001ec83ec3bf363cdb1db55727ba195ceaca84e4cc8862383fc8e4c1d582dcfb5456380b360a1d6e0dd63c245a1011448048decabd180497f29fd0d035647140bcff81b665e7532da7050f15b6f81601f69b9605538982418bd7ff9977846b1a457f4b0decc3b085fba3010dac4a631d50539a65ec1ef5f47c19524f9be78bdc9f94557d8b1cc24612b75a55dc5d8eea9a9485c06f56659491bef8569859972e00232e8dad466b2769d7ce1e3321508a3f80e5b1d285edee4e767d786dedf8a953e4f7da6e2fbdbcdcc0b0d7e7891c02c9d3d3302963f39920b51ed59f8243ccab2313329ebf1575b65cd42b358e605145022c04b6539c20a64248d776cdf8c1be9ba888fd84c5e1a29de1950bc375150123066d97bb32c22d55a922e7447b1ffb7119afd3bbd8fbdf8598d2644ad219e92ed6d663bbbba23b988985cd86df702b6de92b77d255b7c47038a7cb14b094e9a4e272b3b89f44870e2bb9f2d20ce8d6893a2739bc624d45ca85d3407fad21592da2b5cc31c009ff29ecfd51329f14c4162e5c5a82c7ba533b7feb28e9e4d2419c345d3ec64ecad3d1c6919da8f3c7ecccf0af1538c2615b3d678785127a6ab3572af298525a748b738309557f7f5f58ab55c0577b44a931856229528746c1495c6e2b37b10d1811b4cfc804d53e06e186e1b5765198941cb3262ca0ad21b6e11db79887d36aa5c3ffd6b8e0e00d04846cd206d2e20cd824204bb276adc69106defe0ebd8eddbf958636a1de17a25221985692295586fd0dc39e376600a6b7347a8b29c4ceb3c35b7d4b81b1101c400dd9ee3e2a4f6b262aee4b0501cde572ff57767adb44ed869da41bfa9b97f8b548b0f35ca6c28854b91c7f47f233ebf0096ca600416f4b1f6ac8e7811301308f94bfa4aff66230de3a971872b9f96f4a612de5746be2dadf32e12dc18e084ccbba4ec0eb12a2e63b2948a68dc7141b39b92597a7ccb12a247be90063685e4f7512ffaa3adb6205fa592268b06b942cc7ecbbc1f869ef6a6a0cfa9f9fc0f2c3d5a8de04cb99a5173efafb5470f32ea8af2ba1d1114deff27cf8cbd6cac64e8b95d9c0c4048b669d35ef5d1e8155eb4d525530d5926de68b6a29a1a58e5df3b6e31867db43927d7dad08f0cce6844d210456911b9a88fb54aa38b106da3f3b0ac881853677677e26f29868bcbabcc7ba34e202bd48321a9c20eb5f336a47d0586751ec49025bece5c98c2b9bc8347a9dd21994a9989fec109c995b5b2f8ee8516246fe9ba1809fadc50028bcf0235a72e294dd5aaeb849d34f0c0041c0c04e074213fb4da04c448cd43950fa1a9631469e6077656ce5ee07cb84673156b4600368b044a108fddf00b224a8cb1a5d550368c9b55fe9d475bd5b19546c3a0763fc0535bc6f3b103e991c8b0486ae901b6c9ac79b6d8e49dd4e538e38010e73539d814db99a49740c3437414f733905edd5322e2a797623e581be950a0cc3ac45d8f396c6e3f5a8c6670d9d251acc98d4f8eb5bab15675d22d2d238cf4572a39889b8b9b28a4053ca9a2c37971bf20c69bb6419c8efa4d5684edd04d291d961614e496bf6a603cc6b8106f667a973b9a0387f8f214c1145f594e03799762f25f66839f03eda0bb41d656a189328d048e2611bc92b7f6ef7b77e5032480ae5786a91806e9b57e27a899f426a540cab85c2fa5d2cade0481ac6a155d31020383c84176b88cff9739bbb5c3e08b44e9069c630e8036d47e94b1b1df417c3fc8fa084ad88b62e590fc3c5c7253b4039f0da174cd8d2c12548723c5808e6e8ad85b43bb72cc131709d996975f83dcab0d376ec65b2f449a759994b3a77a94cc7f63ff7b2d60e7a8d3529775ca82547250dc630ce7e5875ee42db600fb62526867a540531345bbef8184b98dd2b049e790427bf469cc293c082ec4fbb31b71ea1e9f0c7dcc96eb099990a1e11079decbf87f1a84b43bdba88af69704246bee92a7ea7996a26020bc724b8567ea9cbc37f97a788704c4fca6f902164d3e0840bafd0cb85bb46b2a617364a3f08057992196cdadea7a377d192d6438fa2a8315030fcf257e02d444c58162b109cb27f4f2ab4043dfb216a57e877dd745de2660511dfcb67f8ed6e0da6c53f43dae7b6bb6ba9d8556f39961f81ea23a28efbc392767c327795617bd86703e59c6e0d9974cf0a9b66dc34410b3b57de1fee8b9fdf19a0722c4d15a32490674fad459544aaf524fa13a1f18dd8d8cd6d669ba62051cdbfadaa7df1fb241a8a885d80b4604bd4acca2f43db91e010ac2fb80ceed84d65892bee507de225ced827e946079ee17bedac16e8aa65dbe636523b7d190df6fc6492de6cb776f96e82390f3feffcb6a7c396fee91a173840277d603c879b5f042b71f5ca28f4d54b04dfd4a2635c89d233541227d9cb2e8a33261962b42ad82ca23b5512c811e647b6c8e3fe37f2048b2352fbc4a16ea6d7d58dfb67f0e39874de0ba45a5dc54ee826cf7ae37d0997ccee813ad5bea7312a1be1c7f139bff3b7fb41953bb8d07bb50862b6feeb588faa639f73cacac93fe415a3e96b9fed0e784d2a7f9f8dfbfe928d48353d227a8c2bbfa284710f6321701ce0ab46a4048682e174a3edee254762f04700f6b86b753934ecdff53963990ccb530c3568d9eaf6d7a85c7e766c00ad41785decd56f878345eb5fe90a0008b09016e93e1c1207e012da660268bf44b33df1314eb1d50982c6a1b144b3bdf74226f73288111581ed4e230553689bbafc4ce6a26679c14a8ed010cc814d0e8131d20f3a673f550577a71f2d7514266bef36c48c5ef7bf313fa86ecf8f911d76d784a1282bd1d8637714f96c605b066cfa97b4c5208e1db95a8b98fb2375c62a3715811c5f27c61e0e0a8e7efffa44b36233527b083c661ada0756c624d7e4eff944548ee8e60676d636013fc62dd1d8d0da0792537c413e5383e00e7e85538219d88c49702bced173c7a18f68c50e16297d0b483a2c9b4a4fe9ee74936f21c9543586bf7f90e514f570423e0936d4f0d851158bfc066ed12b321093deb2b8d45c18ee5a9d2b32d3def9154f5f2d470592998bd6d0c0be605789126528a2d97e174715b0fa0c0312e06cc21059dd81d5e193c3317fed9f75a4f7ea6f4b7204bd438584c94ab0dd514df61ed9c11fed5984cc061c5efb4498566a2827a67fc7f0f1eff84662947abdb60935da16ee1aae70933a1a53765c3d8beb1e602fb89ca7a93b38b7514c53efbfc063b6f393f087126ef2c0def2b5916c7fe0c061148191babc65d3732176a87adbf507877d92c9e3577653758a2ad9ec30d1a67b453dc16eeeda3e2aeb762aa13afa4b5347c9cb5aedecbaee1b8c96a6ddb4c92e61df14de4a8c9d087a9dc88356304a0b57111b8992ef0874dac5efacdd9b4e499182920c57f1274bd660741349f3053f1f4cb31d47efd686b8a8a174b16a70d996c79574565de4629fa69907536b6ce2aab8e5e2bf18a676e852bcb52f7aac13726c424aa9ff443f88456c1aa5da441ce64c51628fec3d90c615fe6f0fe292bd635ca9b89af94cfc929d35fa49ba237e67fbe64a0a08ab64dae028f6c4a1b4254fe43d1dbce3710fd7c981dedb2bcafe0346a7928004ac1b0644c2c3c050d87bddbb97ce4c04218d9423fb9816eba5343a7d1ab7e4011f15677c35a5bfcea37b52c4e367d401e301ac1a9bc04059bc8c8de926c2aea134ddd9fcc9e0cf3fd113675cbb214392448fc22d2f049e9307873a588fa05f24b4429897b28a233740ee4eaee93729a620ff89872e439d9f7ab81ba2acac0ca39451d1ab03744ed567ce65505bde67e90809c3184359de572ab57e937cc33022290590932d17fc6576c7078f30f649b955ed91053ce073375e917fa3e47156bf965fec097b5094391c3ee6aa5c509b2d485d5339a80b2df8b4edd9362aaf22187cbf57603e9b92c122ed378d1bc357446e3ddc905f6a06d2a1064cde76f8f9ec6a9e490f4967dcf3dd5b94a7646bdb505c5ac7e072bfe4783c0e7df676bc2412f51f6f595bd7312d0e280a25f5c347314f124d1a5f35a42e28d94823a0cceb11b123e80f164d2d4816b552cc111f3cdb034106c8cd952acc6f58692834228de948876d93f942fdb9815c24ad85c42edbca6fa413be8da18e9fd80b7c0e428c60ece99e36677f1fb4c1f143a94becd4d061ce0447e78450dc695a18a929dce453d63f18a919168578dff1d3a30f11baa75bb201746bd951f40f15fb7983a2f1b37779983cafa66c09fe451b6b8b7e2df01693b137373423ef27bf337ec1bd333a7e2c47ee4a62869fd6671e3d319a0bbb71e07883f5bde73d5dad57d067b0ad7138227af9999fdaf8df6161e3a0003606d31542e489c8b99e3f011b46a0420831e78174ce8d320f45faae4f6cd2c2700b5766b02dd9f6bd7c9535fa68df2a15197eb4bb8eb40fecfbceb895c91208d2103443974c2a5664282aa5d6774eee985133aee471ae0fc5184bce5ffb62ae2fb5369aeec6faf26dc71c2477a671447d303c77de318e1956c306d1d5b185b01b8bcea3bb1c321893199a60e3182d654543605593f8f5af36ff23479329e4e50893db25042d817d11926633280a9bffa318f0f4e50f0082396ba10317d1bc4f6efec81782dfca563d08d8a0e6b0e7d5484aa4e0bbf01071fc9865c66dce8974a87ce4b0238e32245ae82a206565f03e2f8f5835ad41d011514e900281c3544b2a1b9c009cee56816404e85dee22c61e8e2d08f029b2cab602bb12c0003974cd6a387a396407e40cae683cfb9bc90a24ae2411c40f40322ed3cafc2103651f2222f49d33239e05e333ece919f8d7c39bc81bfbfc54421a9d60e94cb0b1e3d93c087b6f0c3b6f6490c6eaa11bad357b82b74208a7c312227200b504ddb8de626fa3b97c406f62b54a61bc722c01e4e5b8505bde1dfbe272cc6bcb10d9e5cac6089cb5edf57440387389db0484ce8a3fc975d321eb0d8007bbada4441583a9aac90f897366518aa469ac4de14ade347c9aa36fb7907956e91f0ac11532744a464f4af8d310649024a0b4f4e26393cad334f39cc9790e1df1f32e9cd1e846b132b745b2b9e8233e3f903bd2efb5bd1e1b1ad8c69f749dce5dd8ad0e6f4a68cc7911c2227ea415727d5e97bfb50d529e770594e6397487a07a36a3e935fa811a10b8e2eae4ca9eff7aa65c7803bb5707c0200bbb9cc9b627305ffb4020db1f288581d93c7344e12f0e8dd05b0ee9ffabf697acc8973943d2e07de6f3cf7f8f144a631b8767269cab5b8497ccd6fa37e3c8bd0b071cd91dfa51877eba193776f10345bb0593025e0fa6e1299ac64cba608ea1d69e19af15d3756ba60687c546e5579c66106679ca9a099e2fe746d4416cf1c0ca72b0a9fc673ae7a08832e008df7de456e3ed66fcd1ac730155850c0a7216eab1db485e36496a35e786a51187379d3c6c3a331800adc72c9c124faf83c5719ad5938c9da102a80a79d08f6a7d76be86a705670d04e85d4e4627305e4bbe55202aba7816964147b2b59fac50730c174d9cdfd3620de6321ee9869a2fbf90fb1ca18a0ad4ed21dedb591075aa5400c60f75b619f66829dbfbc05a14eab9ce56a615ab94264630186ca1d99f57e48a6278e8838054807cb211440a6ab4edf96d38c4f8b9b65146e747395dc594364144686df4aa89b2fe3ffdc7dc2f7652c467a57937aac2a4b94901cb78b99bd41ebac60374ca7c3146599dfcc652bb91eef0aacd5945ec916eef6a3c7bd245dd790d5a23c50f05d56e60d11e74fe5182f89e860ed048c37c5b32389507457461e55da1f1fc4f89ce3df6c540db9441a4b43b620b6d43ce9faf499378491c93319bf1b50703345e4d86ce309cb3430fbf12bc0856ccbba180b4c49907e04ffb369e80abf98787f7d5639e1bf4afb58eedba8f6ff3d1652042b91ba1a1ab7a81263a53a9d3945be5e1aead02b6f8989698691e0516d55dd71209952e8d76494e34a1c88c47b08ddca3b7e3f6ee49474f130ea839e78bbc2d33f71041489808b8c4504e9aec07b311809dc3b06c69ba59aa5cad14506e148991d3ea368158631f0dd14c7c46c316410a1c99ee54c0254709e7ce32a041a5085c9c7aea2bfe632f605e9b9c384698a495e71af571761342f7d108bb2ced4d4e88c9d08890a85a1ebbc4ff3ea5ca9c70b84cd9d0090fb2d75ed902faf6c2ee67f9c6511617da2005701800b3bb0698fa33a8eeaa7575d9266e87428161c6b7e53b9c992de2a116cfb636eb1962af27ad755909a3964d426d9774c2e1e383094064c7c263812e29306c403f74df721760d8377a5d1760d9ad59893361f7243b3e12d9f8de872b533b63eb35584df925b68cf954ffbaa6bca10399eec63c4d978b23bf44398d5445e4348359701aaa4714dda1c19a421e8d25ee2cceb31c8417326f7883515eb4331d58f91b273e7c8f6b7e1afffaeb1e68f84a7bec367aea61535eb14b8ff336773ba3492945c9c5a768dc85fe2b376d22cb456a346d3f824e0fee729d7713e15cd16dfdd7edd300b5d26890754440dffcab693d9e09d20a459018dc4a6ae669c99e26df611d1c8e255355c296d96f422d91243d355b9c32e388a8e65a67d230672446fad0250b8cf021b249b9e1d1b0190a9b840c1ed034ad1c340d538183c92089cf6b392233e7426ea5880177342e118b8af2fc30904674017b76b4d12891a48d4b9388c6d48f581be084ec1ec4195199a6fd8c59084f22876005e3b74c79e19b28b9164d2e3849f6d7c7aaf747072e859a2817ebd96b0422164093ee69459b458fda23be0d626aae2d007112f25b23c2170507430013e2510946a2ece68f0421d5f10524f9a210f575c0ca0a22c1ae9fc1cb37b73243e96c02c9d6f6b48ab1079021a5eaaa027620fbaf8ea41bce2fb7f22f7ce479fc085003e2483e5eed86c935347fb0314caf1138cd060abb824b64d35d1e2e01c1450a8e2b79649c07e8c1756191a5a2751d62820fb87aa6677d32f31315e9664d1d1b51b8c7ab78a9e31624eb4fa4737880b169d7fc3064f3afa96ab71258f10f39d6cb58f7102c2a6b82fda36f1121b9113605a9821a8b19fb7d664f259f15255a8d2f9a23a33fadec93a910cbff71e8ac79469d44f128a97e0e343e90368fee87780db5d77587d66216414b0f6e3c08fae22253be1065c4001b2ddb7a9ad5486f51b5af832cde64498d2e5148374dbc882caa657e88342446c24c0e36165edeeb547a0ddfb95005a31ec018aaccb087278e381e3a55bfa00f7330dc21fde765b1596116e5c49bac1ee4044c95c52f1b7d9f9565dce5281b256df0f09a7b053f82e32c93bdce2847e55ef71c37ccbedfbef6efda70ebd49ca2a496935c828a8965aa5c7873313d51a33cd4e3e996bf515a6be6075dcf21b803cc89bc64298cf79c58959bb622230de53a99c461cd9ee18f941fc2d7254a9ef9ca8b2a08accb2a0e66311791f3569f5ebedab9e8a96b6ea2583ddc263f2546c0db790f833ff25690723e64c7dfbfa927cbfe38961baf1a91ede207193ec43e279748acaf49ba897c30074bd838983082d05760625bf26c5150af09653d3196c547a9156a9faa36bd2197b63767aa3ef10e65a278f8ab41a2d94be2373fef37d4e4238354bf933b1e37627c9399caebc0fce54d0ecd0844df631f1d48964018ef5b017a13cd6be3a7038254076203e888c17e5012eb75b9a439c77387a6a6a135235fe2d1b2a8f29368fd0a084a4bfe1882e5cc24751ccbbd30a8be59dafd15bb48da9cc977b0672c46f2ff784ce70d81779e04fa17407b01674eec50d6cab7ce079bc6c6506e155c4f0c114e7310a03f36c0d165d2393f7fd99bbcc96cb4bac5f6f3ef166d6c618cc2ffc4a10b9ac83d4e1df778949b476421b2f86d66472eb3caf49da95e6602055e54d111b3818480d6d7488f14ffa789ee2fa0e3279d5c03b04783b8d8abecc7a206ff81be5708b22c9c9cf7d961a97fbb933da460188f1780adda669f2307769a271d6abaf773721a458a92bad179532c753f4bfb2d44020f3a5144ea26b469ac53136b64226f0574dbb29c1dd3e93a1459f0e7c44a48160a80fa6f30ab396b14b94e2979c39c8b3e4773ec431ce7060df74f9c965dcbc8def67cc4f45118e7d8b16afc4146e14aa6b7e6606d4a73b5f47c83d2a84beb413a6cfd331f0a6b02ab09ad9ea9e6504d1f81cdc6f2e6827541f318cca37e060e0cbc13b55b740990a85e58d00f90253190e593c8053574d166a2c5130cbcca5ea7958f9efa2264d9ccac0134a1f02caebfaade562621936d88572ab7cb5c345ffca8e317055695776e4cfb9fedcd2902b8ab40d8cab9d9a46a6adc67dc0e55c4b5144f62c207899f6b11745dc67fc07a9c7faa0a2fa0712de5786be5119127c94b37061738cad8897dcc3cc99aa322cd0801ec88b589a5ba09a3048d3dc77ce0cb86abb8d31ecd3f989faaf96c3a4e364ec79db0f808ef3652cdfe5b64e4baa688fa92c43c4d396f7ae7c408b3157abc11e1eb007b5f9d8a2e9fc6b83952de47b1ec7efe9d28bc15bfbd386d47f72b56851e92429b0a4e3bf33def1fe9aeee747fcf96136b071a6ad7721447cb6930c6b2ac4a72be49610c13c7eb6f68490d392c8473f8740b5d5c32d4b69b30538ccd8e3ef649b7b8deaa4d395d15fb30f67c66ccdf6059f3c60245a8b721515ea85b25132cd82fad66d4a79f6047d956685c60479eb717927a60f7199dbafca8c35ad8511fac410c53d6f2004c4e3111af1aa5d27810529ac3ca19adbe635fe2e1235c455ec4c1c32f5b47c2755804979f594fe6172b4697a5f71362c083494cbbeec051c4f14d7dde8c117a2127cd4f664ba200ceeda0f264d5af572992c6e679d415340db44562ac48d9a28591cc14481a7353a148ce4c130bafbab1eefba25d3a060751f80edc5b613bda6579d97252c5006ce4009100eaa9336cf587c8d3f832b5f87f6f327d16f5ed028bbcf5ec6b93fe173606fc5ae49cfa121b101a2e3f180ae1cd2698d856f5b34c24f357ffff7603ded7d502a88ef2800c79a15b1fb87ebcb0f733bd1d661d63f70b4ff156329560969128244b35de28815404fa1ba40beb620f35d8dee7e97ba5b999cc648487cbf2d7a897d310fbaac5c5972c66ecd509b21559f2f82923c7a5c1fbdd2e5dfe5ce5955b2faf173499b0a97cd2a6d802a124520edaef5898698612b7e493fc9bafe5e63ff3339c2a8260983210a505eb706ef555be0e365ce58fb2f71195141b44b4cf8adb77945faacf9d685d7fb784635c6a6c5f9dad25f2d6655a5ec979341ad809097fbf17b65abad9845038d83153e6686beb6ae673c091fb38b69d8053ebf0b611a9d89b2b0373da6372129a6ff894cabcb3f58cb9907ce2096a73251b024f157acd12d5e65a0f8f2198768dda52615feb84ea100217a357628494c3c8ce740aefb665ced3aa5af7e4ef3a236547b725a33a333c1e1450cd5eff42c430c90d2837be992da35a57c8d68c8836252f85cf0531c02d744160cb643f9f19e1b42ac19c70dcc318cb158c08971d38e47c987961b5d88550a6a40547d43427b2a6d858015629ad2343da2c42d95623ef801153eb270f94d5593fe6afd03fc2491fec5587f2cf7ba78e398e5761c373bd49d80a0ee2b3f4a48de74493b629fbe10f6ad445e742ff4b4f3b40fad3de0907dc1e24fdb763f65fa0ef75cc436f3e8b042da508be259dfe13b6e722c06eedc86c2915a49ac8ea5bf442637b875d4cccd050c04fb3b329dd08ed5531b98fa9aff5b55fd2add846ff69b8744703eca3abe437a717061325bcc9de349878d1cbdd6ea467c3beea139bcc464f774f3975bcd15d8e2869546bf6ff877289560b5d82fe35289e4df9b4e70d21d1f18b117764b1532da80a7eb3334788ca409018fe2ae6408eeb829661e9e2c65d95c583f2307b184e82247792b52e6f603849b8c27a50d3d1ff09c8a629db469c9ab47c178301fc72e70032f7a2669dff164399e4b58886f70702171061660b6d6bca8f8937b19098da97d8d4a40c24ca62440834c8f4f1bda2c504ae4f4746adbc71056435303c2ec3262213e73f2febec360c413c809bbebd57175e175e88704d9d5751c8b6b0a388db31b94d2ab61234592b15dd740120bb0f95e1fc683d24bc0a28a0f8f6dd668d7c038e9dc6dfd0d784ffc50c116534b869cf56a2cf273d87e7713b543cf4417552a1629423c279e5e27f2b9dc3a58416cb08cebe82848924569b42490a64c6575ef82b8e305ff983c17b5a1059ae16dfc6037a76f042c0093ff83f71e03262a67662cc15706afeb0332912c89c425122daa6fd8e029c3ab856c752d71c63c7f6c00e82fd8e7967dacb7b3852bfc64959bd805d87bfb75fd8086e9c890e525595dfadbd75109afce632b27f75d395c222c605a01442c5c9134e2a04473b1a305f7aaf9055a551d0868c19502","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
