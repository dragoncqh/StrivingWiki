<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4294a8cb2b0260ecf7d88753c337f85b8399a88719a2ffb46e033c3613c4cd3f8d87f18d71485ca688cd0918f4f03593f09d34d27afa68c149045ebe60b501ab929acd2816601b449c07fe47d1bc33969e79ef166f7d57cf14c0fcc790261fd57fa16147a65baa81ae65ed037c58a681234ea3b2016a203d8ec3fe185e1c7f53c637b17889825ad7c6f44a82a8688a20b7a0c3b39d5586d02fe9f9d81379685edbdbf4cd9129912d2c3067e82b1305b4f2c347153cf3cca4cb9af08ff8dd91ad03363656a1e4284f8fb623463b6142ffead21c2ab9790196e04a1dda778aa8db7936976023de299b6a975fcf375212411e713ae01a2474bb27490e57857d468977a668a706ae4a8d61bb8c9ff65dac7f1a5fcbfafe638fdd51593b0bd7b00c76d783aefccf3be07d13c8890a01b29e4edc94d66a7d574d9ec4f459cc9503c34a7450d7c89c4abf96a18c0c385be1f93d2cfd71e2247d5c3f47fddf77c9ab89a76bb188273ad4264ccd5f78c00f1e533fb9e39f36f009df20a7e85b44f9a51ec988dac48d0d421a8f1c42cf8dc7c923088908d639782914a276e62d4c8ac43fec19e05ded1167237b09889dfc266e91c5c2ee3dea4e7cad409bd993e435aa5b55991ed45eb024984b10f37a11383b1715ca227c4a804895b008e268debbe3f91014aa4072d9a3c491e6939e353b4b98d38f06faedb83000507c606a5f2224855640117b452ecd06e4ca08ec58f38e4e038fa33a70556a177116225de73d9ea5ae683771f5279fabff614f323c4c7a4ac9ddab3590502bb5051d7ccda01329a6e4b2e6043407f4b86e17f84942ce29f2bc8dfaba9773c391cab6cc3596fa97f118a253e634a169cf7ffbf950f74ee326a9d0932478352ebe3d89993fff04973256dfae5e026672a818e58a5f66f49e8059bb91f74fe295caf536d429a000343a6127877f69725a3ac092a3eff3acd796392b5ec31bf2f01514ab742feea1c05179d31755c6904897a90e4f5b6d1258d547aa4f9a0e8be8a95e003d53d02bc3f6bcd7dc1e09dd3ae646cefd06f38c033644d8be909e51447c9b2e564ffb2d2863d3cd2fc87b39a28778a987ad02e12f4179b59226cf2480525e71c1df0d2cf87568a331572d96dafa77c32985108238e4a17ab895b3fc0c44010491381e7bac7f7c33c4aeb4e13d1fed3414b7765b4a2a2966dd39c36e8c710de717b9809eca6991e91c1d44a702c34add40141181f1932169b8c38549eca79acebc2e303f90f6d2a4977ad7eedf0a9dea4403117b6a5bbec910bd0ff9ecf6961c1d7b24de6db028f847d0e8f10a554a31c3f1fbac5a40b8bdd53b078801ad0b048c94061f61374355f6db10ca224bc8e685206b61892065b4e5b37b5fce1efb722113e631898aefdfeb65e9b76dbb30a95fc6ee3db46ee8fc60963b2060ff73ea0328f4d2d7b433107cbc140ef4a93fbb51869153c481af696c62295796b76c8b72819e9fde1455b5648f3cb36007d9cbc668b8291fd7d0fd38b06962dff7762459030e6f4ab64a11bacdf01600350525432bd57ac399f4a09051f6d541db42e0bcea3e661d8934564df026c220b63c6d1ad45fc841f16fea15f83ed778d954b4ddfef48d279a774eb247c5c6c0dd4954bffbd7fdb94554ea1e91a1087122c45a863b09cc0b988531331b926d5873262fffc0a7d861da9de0a94bd567b08c81a4c471a810d00a5c0925ec67c12a3eb8f915eed8d7e1880ead56e7d9eeeef0494dd3d2d863bb4db4cfa20b3b827216576c301641960704e804199abca505fd323c429ee8eeab4f1e12c0ddc5459689a07243714f468a9c94d142b90ae65110b694d49d3631609be5815cc38d40ba61b9141abb628fc9ddf5a771f72cc81ed2f7782aaa7ce21c4c690275aaa00ac625cef9e6b9bcd41d0afe34dca298e72c96a98aab60538eb89822b2d43632c686f6415fa51822da884ae002c21f1dac40230e5b8ce80c05d98e7982d33b58c367d30f6372eea9520cf9febac4221c5bd4fae7c22264d155057c320a1e1d48f9ff24eb101f40eb5a3ac508345490a275c4336763aa632163dc92b4ff03a3fbf03d1ba0f6056f8222bf2170fecef90771160f02e58fade98465c39a674967202f72f137bae128ce02857375f3f735702ba457ded0536af3000ac25d23e5db8d7568fd31fa0521579bcde37198c5d6e20c6c8a8d37f0c197512894043e67e509e583a0cea2fe2f18c93e043a4d4480b0a8daad05c7684f8437ede684518d998344e0c274c039255c9fde4b18e3af9f90c67d64173f8558ecd68425a5a0942fad4c0a8b6ff69c56d31774097f8ecd3a5ad1b9ba0172621cc2ff4d44c4f24ce1892ff877f3de465dba6297f93c73e021dbbf9c3a03c8e084705d467b83ae4db546f4de367965c96ffb60c00ea419d8ea70bbebeb505586b51ee2c7388e9d7ede9686901306e868509cb2714bfcd4216107fb246e3db4cde5fd5567ee3b2dcf98b61dad47fb16db4821dc419b70d6d8862ba4369a9b1facd739449971f8acf022d9027d7708cd64de9770f7e77e03af8a83db9b19ce929c73b21aeb096896c9dd44d08a5b8205bde668c6bb69734c782e9937f3c46872d16568d680a030bfd84afd524c6e2b2c9f79ba5874a62114e2517cbb319734bf9622c1efcaeeb288192c147cd38472851456c2084abe3847c95e641085c4c102231dfc1e52b7faa7c5488e632ce181b6b5d07b3d4248443c530b9a77fec1d9cedf7d049ba8406a4a1f3ff1f2ce80cfd3cafb5ba7a53761d3a9a1ab29bb3035d9499ca47fbb8424546de4930d90f8607daa3671bbfbc24b46ba74d013042db3e5e29725e38bbcd04a171bc63cbe461c89c9e74417821b68abe1bbb187f1fa2a28bfdb534eb3a02f2a666a0e9867f4df80665adef24a976f9004f6d07b5ed61caa0a3379043f01d9b6a74a1cba4c95d67c2263b5d3208e1e324cd6b85530745b8fbb2e0ccb838cd06c400fe6280fa0d4182aacd976ec49a5741ab6b8d0692170dd20acf6512d427e98796c430a2aeb075799b93f8aa374e21ed80f4437f551da35ffe0c04c000d485564ff8f3b4993c3e5da89f828163942ae659800207ffae78f8cf707cbba755c633bf1fda4b98a1048727af75415d6b897b771a44bbae7066c280189132b155e81a8d1dd0767239a95617cbbca48f75be27254434f64c816b33e0de3a15f1ea565018d17035eb54148ac4bc9d65993eebe3991a7743d06fc346ac6154cdbffc0c55703fe5a3c6476619219bea85b10ad7e1b76b70b11134b304c452360c6c9073d52b9307736976fb0b90030d361fcf6a9a6d07eaf970e9110f60e0ae2a0245f5e7372247f3ce87fe322caef004c7ce9055ed89afd88a4fae6f238275e4d8dfdb10f0b06b8845bf94931d0b5a9fbe0760349660041867d5dd06fb166082353a315fe79ddffb478a10eccfb89d60653d06ed5a50dc18910f8c18021d77f4bbfb32fb2b8ec0fb6e4bb5a4467eb7f29e6d274602c4c29659212259b5057bba43c992e01c1a093b9a2a5b379073fd284080f5c5e8136b429e7e145910f05742540deead55c460e32b805498871e9351dc0581ee5314771f07fed629fe8e2f83e746e3d8d2c498b1f86b070ed9d43bf202e75a3b01b403e528feeef40a6db9fd2116754067d44adedeb4cbff290164aab5ae59cb7755db65029604f8113a76fbdb6354d14d99e9b90537c8dee50223e83e00668766c64c232fe728e6f0f752d918d089d9184ad49897508ece1822963b5582eb75ecfa1d64f5048ae4afcf7e2a32e1aafaa89056537f402120a4a62f35aba82794135816543df9274db239502cb8d549ade2d68b01d4c2c983c879db50bce5c4c19756d6ddc3e91a74154f6210bb05f4820bf58528a2e1b1614a5792d13061b75c56c3fda4d9ca7c210a404e43003224e74c33f01b1d174292d52a4fd66e08ad6d7aaa045775aadda217d0b2c99e2a1677fa05bb8835ff91b691e5b859ac6223aaf73616319013565bef9469023ddfe5e7e125b59ddad8597da309e7d5851282faa416f1001c06743107c9d4e936da00156a647601d96ad3e4303fa88b19240016238c3c90ea2a9ea47a1848a8b2220f64abeef1af2c1e1aa5beea1badd90759a9ea5e6fd091b266f8c16ace3e46be4e987656b0d8d0eb2c79ccba6ea4a9e82881e3fbd7cb304806c882bc03eca829396238b6b04c29680de76bedecae93d328f058bdebe7126921b4d29caf1939ba24cc8ae926d4d856e3d2f5cd7d80f2a1d2f61932fd9b3a44f74999696645ba818e996349a0a91a0ce58d1cf40a8802f559740d8e72c0e151899522bc816baef358ec835a0536046d11468841efd9ca078c028f4ab038b2694d7befcd2fb53c1dfac8c222ec16a6ab6084b9aedab763b3fbdf9b9bba40ee7fe34b34ab5565ad23cac1537d5165521aaa035b95d74552d8dca1ffdfb5efc66f73bd41c029d32b6bce54aedb4904fa24798c2874510f735e9bb10b83db9eb0fc0533e64d3de0a0edad0492a539bc22721053d9aeec519d86e3ff0431a17e7c3ee159a1a301c32868af7b392d55671bde43e597e8d43b81c8e1dc27b96b4c9bf2ee2d7bbce26c163509e84eec27f36362eda84a6522e33c7fd6a9128500993b3bd49fe9417f1a462a7484e57d76eb5cd0d009d3232f0ca1122d04ee6992b213442f34b6be68a2ac34a4f97b8ffd942578d555ba5e89e36ff21664f2e09baae59ce9438b4ef5f59e98d0389bad48e50862f1b774f2378c27c302f0ab344e217250893789f1ed4b3e05997487e5c5297dcc94076f3810665cbe076b7d87526a4dfbbd7fb7899cb645e1b1b01d2f637e502d7e42b435babca65666662168963f00699224b1b41b35de42fddd2e76603752a2000644408ca7711eb0388eab0d0baa1b1d187384f174facf3e64e8aa7c8305e23236d147029d2c9893373462fac79c01367f51de41b976bbf0923c54300bd9084bf76a2cfc205b809f29d93522494ceb283a978cd65419af0940239bc5c22da3240e0e3112cbb7c74a4c84cfea53dbcdd700f94a86c71af950e7337d03d00177c99c36df4e0535e9e44acdccc214204e15b4d6deac316aecb7ae993e8d48d1a1ece55987e483261fd45de5fd6985198adc5e68820e15675fd2491b5718c679bed5d78770cfb698ebf0844ac015fdd57e7a016b0585ac1b42505d46b7e77e72d4f27731db021a87eac197a578860e584bd41f8f12103dcc2bc9a2af6637257cf5a9bc1648dae77bac92294fd5400a5e518168b46f164533ac703ce7d007612a8162920b3269e43040fd076c577194c3ad9aa9c2dfbc8a3033eaf1eea4fbe42c2652df56284a8ab01f0f1740f674036a681bda8c57d2a575341e911d4b3b6b9a19804e3325ce193e08a0fb5eea27270eb7867a3cb80f17eefcb9aa6a59a4f1db51c4849c514f2588f36bde9cb3d14da0895aa68d19a18e68a5962622b5a664c06a6cc49ec22d524cb0d2f9ed53049f2726ba9143eb4da55f4a3581922f2c1c065815ddab09c68e10684b528db5c68ba2c44d60de293ed06ba3e5b49b16b8daf6fc65a12260d799caa6c3f5d1fdeca79633ed1ab63ef79bf87dcea2ffa47b305cc9cafd089a536f6ad2772d7b43fbc24e992df2d590e9d06de50585ea7cc14a29d60c1db1a459dd3cb6db61990913816711d75a5a86102f4ad758da9c7c33b27f222b04a1d0dad7ca4882cacab8898bf77e7bba85c25c76e31d1fa4339e3bcaa838e2eb7ad2b8eaee861b89f897f2ba7aa7b22b96506ed44b853deae712ca425b24f2dacd43faf10e378600c054020f81baf1b51c92d0ab0637d98ce1489c2ad74555f2f1829db7d62d83d2702ca7e405d7d35d8de2c813a82dbea5f0eaac44fd72be99470b763fd7dc313ec2e623163bb63439a6b8515ae32ba6d9af82908bd15389d4e5c4feaefc4a3f21a0b7b502b7d9dac48e8dd3b68ffcff52fffd8eb138069b75f0f1850178f2517d57327f836916c2d7222c18f716d1f0262d1e19b5ba3ed286641e6521fc210955bdffc4c9d5629280dbb81e5d72716160040533c621496f8e7653096215c5c0c556c83d5ed5e51273e26c0b72554f195a808e93c551aede83e16106c18e1d1888183fdcac91304dde01013b955708132021747cb0c338650281873e8d9dd958f15f58052fdc5f6c9d2515402b806b08dcae07b27dd24d1d537714e1efa6f70ad3cfc18c7caf436fc3c8d7574b3bde5545ce610d290b16a25f660c6d9f530af7cf120d50faaf78a35a1232d3e90330078f92b9b10bd774b89322d9fd77ab85f76b548365e77fccdfe3d870f59763277da20d1d6def2c288221173ee0ae8bef64945aa3563ddae555a94f20ecdff1572cc7e07cd91583bddbab6b42e70ab95bdb0e87ace8fc2c5cf97099e14975057c4601418da8f76c53ea06df151b6f35d8b3f128de9a7bdfee3b040ab996fff16d3f56b3b1fdbab7107de18114e962a8701677f220769d4aa10190c3dacd65c23cc1524eccc37b950f30372c6bf6001346932b36f5ac3b03fa70b157e054502dbd7a5d4521cf947fe3ce9f283b660d8c7b6ea4a3d7bcb67d4308b43d4661f5bf6bf717ba63f8dc27948111851736b64893ea99afd167cd51df5adc1f7401b360cc8fc0c496419d66caef29c30d8e7ed45854b2d8ad380a8263362fe38851ca6f0587176b90f8c5c8cbcf66f1a24891280f777b7028a4969a9aa2a785b7512e243dec24e2318456c44d5a52667ceb37a56772f6e55f1be5dffe30a145cec7fa7325f15d3c4161708675a2fc383cc3f98b0327a95420d47dcfad6df18e5ff385fca42ae3c6cb3c5c9ae345f13869dfb1d2c5db38ae20589b1eba3857387384e17cc417bca26277afeedc3903ed4a5937b95d61c14f38e89ff2f8b873799736a344401e97a5e1e7024d988122e57b5d4190ac85cd462d24e2c989670d57865193ce96acf08e6cbd1d576aa8342e2e9ff9a5cefaf5567550a218ab59525e0132582da15ea5cdcb09f1ade6b80e8ed66115a986da083c3bbd5f752b2270b471d9ceb11349ee29ef04c26148602d22a4b8e43546ea4d8654021f015c6cb596d7bf41785c775769efe5d1499f37a7b5d0cd8ae0a61a5af60b1461489a9507b5caa80d0e51bc3a53dd668b1af46e72a7d51cebde7ea138bc17ff17b5ec0f1ce73a718480a5a95e8107218fbb767e9ea8a755e565d931e19a1db1abf3af09d698c0153360bcce2f002b9c77f424151ada957c120a9e66e353e8420a7c3c7809875bce01ced5c0815cd866fd3f7dfe16079b4198b92c4cb013206503bf3136cf8509bfa2894c231ce5d78d061bbdccc6d0f7d1d5530ebc6ee0458a2027028d14c9722721eaa68c7ebd2cc5d5250616a453649f710e0a075f595b03688c146f386c4978abdb92c182c62e71c0336e67f60f97b82c8c25e6722d0928493e170f683a15d988426358c11754a74cceceee482a0a0b198c9e9372c90f352f96910966d78f9470c1e297eb0f08315ded0889d38a620af569adecb04617b582501f34d67b0a9b46f04aa069ee3f28cef2548cf15185a9ebb3434cc71c3defb6f929344ae2d0d96482830242e78ae2467dd4badd92382ca999d0aa65d3a04b83461d60ef1966b119336f389aaa4a62f268bc76892d0c1039eb19246e70d8d6b997c4d36dff84c08b035cdd632cb25479c21dad3cdaf53277f46496e495f4c45217e186f54e9c651d08b9b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
