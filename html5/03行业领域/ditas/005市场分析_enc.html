<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2469afa13d670152438108554e8ce91d174b61207ff3be86d742b1f484e01e391390365d4e096ab9932779302e56ef2e2a13f6921e2e74cfa117c95d3b0c2e63d2e515361e3cb494dca77c385509bc33c19a8a35c4ead3facaf46392408f7347829b88a9d5fa3a3c243c7c2365a5b50bd07e029467205d07b80fe4bf18f68c73bdda3fe0e4a9a48f6e633f0959e1f87793a08b4d09ae4ebbfe27d628db885dd6d0aceafaf7c8532d53c79c33c1343151a11a2bdaa3fd1c647efad719bcc97454bff57567b3b57ad98a9b643f88bafc0252c7f5440c3e3b246a191670767af42c03b7f743ed23f1d6dbca4e9dcfcaa3f5a048853f9d7ca4d9f470fe3a22ec9e52cf1a8a7500ad1f92626aa2c08deb7cdcc2c6864dab7b9b3620da8e42e29f70f5ad3f3e9a72e8a90727598b677076352279fdb1db97af44f772f0f4e3109454310a9fd2c267072edf058eb1d3c4aad728a184d5ecc92f04d02600e4ff82834137f44776db8d1610b4b64e8153642200bbdbb06b675f2068b7729cca72c7d3102dbbe4dc30203be500a3b3ce12a559fbfc58bc86ba5b8cd80fcfba30a686d680a2c3f6782ba35bb1f445ed709f05e69658e03940bcc3d3b4c9ee29843ffdf58117d81debd92d9d35d0ff84314222ff246e18660845af5517602e4238b596089a6b4f480a8b36a5b9919bef40364791e1c5f49151f4c4c913a418031159879ab7e50e676a2c36944d90856b7ad034d921088a01662271298062bb018529f9002c3e464d4e387c4a7e4fdf1fedb090c9786ddb14062b0b4f0ddf207fd83f6b9fe99347909e40155b0a8941c62f125deeb39c4d735d954f072c06e05086d335d3edc0fa78a9da12bea2f7f5a800e1ad32935845fe19233ae06e581f8685bd74d1fc52ba110d724ae52e2542e0fd62db7395483b918c866c0681099256e08085ea2b97eb95e8c53fd65f43ed41c21e7e54b4e506ee4cee0ba65098dc1315eb423738864bfbc6e875c91e13dbe62d1e41ae6ee21f6ae87179fe24933257fd5e1e79f4084ab979018cffb444404c6478f3d73d94b18213ebb3e6576d33c071e6b4449c275896b9776b654523f43c60fff806bedd9d8403593ab19fe9b1d95428aa5426df1218f583bcfed4d155c186dbe7a262c00562f80fef9e6e3f8c496e710dbbcf9dd53fb3677279d00e15646dbbc06989f332c42dee1cc4b88f2b4e4c50724c2c2201823bf4994d67795b6cb05aad03f87fae76f82370e9f1159d555ee06906cb1db61bc78f125bec5ec11b90aadc75289349fdcc690e65964475394eeb26263ea1e27989532a24921526c0f1fdb0ef5b19bc71bb9388dd581a923fe0a90a6769bedf17614e8449868fc4348eeee0240f98f47aa7da86b05c59a6efb5162b602e13a1ead16ba814d8bd2fe69e118b033de3b606d65e8f3c505d9a6cbc46e8b3d852de9970e2768bf7d3b735f1c19f8a4ea502008e211c08fa8e82e0f9bc55d195a550fb0db3e63fdfcbf44f7b0d95f0347e53f6566bf138b22c593c15c6aa33e1950da4a6796940baa3da008e25295a116954309a9cce9015b4f9b435d5093342894024f4ada0d83b5be1e4e49c16f0bdc7f4a190a784c0c5d6a700e51f8a7b4df8eac8a3d94cc1234fd241b288f4cb7d098a08503003ba1ac9176e5a408ee5f40a25408387c0fc2b458c5cccaf02984c65fe8fb0f8e5a49cf6103abc6820b0cd086cb7ced02614b010b4389bf158f7d3b7feb6a9b7b796f6237be61291fa04774daeb98004d75d35e8d3029593c55f2bcc89312dff78770d8ad3915cc4a975bc9b09ade1c7ff6c37820b4eb1e4ebdf4fb1546922a1bfb6a88b32902468c9730f29d754862d3371258458b394607ac2a449a0f04af0ed9c940e9e6cb4105dab3aee5bd7618b7829266a550dd773a94cb6dd50ae4e5a501bd2cf4f9677ea29e954d209c02fe19781ed3101cae0b9a4a0c804cc55ccd57d0275b458136b3a3163bc9283913f4ee63fee3e176f133b7553db6b1edca35096d4c6ab51a9cdb03fac1783e6a31dcc69a64079398ffc7cd8e783a433d5cd8bc0ad62e340eed9bc321459e5298c384f79402f21a2df11c33a7db917471688ca9d2dd0eaea79b09aea16f7341854ee441be791a141090314b2c7d3c60d53a715d4e5e2d54ff1da4b709fcd69881a713e6a3659943e0a006a9764836b3605a25cfcf01cb22e0aea1520f7325feed1be1aceb3a429e6f569674fa4d10c55452c791635c78dca93f152eff00b679a39d569321ceadc699749a1e8c68cd5e3fde661ec8a3666d59ce0632a0b65edb1fcda9dab7499a57ac7f7db0679b344e35d068c2e9cec2eb44e46e7b2b13b3b9b715b4fe9dc291b1aa6d1decbc2e4420c9b791789bfe91fae094a4b6d65cd12c78c1b07925a0710fa2c02e97abd04430f70dabf4720badbcf554073b4b4ae80c098425910590be865e27d92cf6cf7161d26789ce5d1c861a4634ad84b3eb5bbee7019e45fe9d390eabd3abce32e3ff8d2ebd3b12152a6417a7ea11e1bee975a21812ae168d9cd432555c9229401e9169d0bade5243b38db27d4a1b11fafc9a41fb5ee941914eddf9bf6e06197447e9b10241f5e382a65aebce5a1923265d431bb7166546e6bfd4710b850e0ab20cb5956ac227680eaf29371f2a9f6eee576d495b180bff2fa54d0f1db8fd71f57365e523cbf955ec96e272254f54565d1d33952c7cf0ea5f6d37881a4ddc19e3cdf1f15cd439e0717955365fecd299ff78ba80d40538fae603c0855c5909bc8fa5159dde6242be4dcb16e4b935670cc33d6d3531fcda3385dbb9d7fb8ad6f1b28d2d10f36ff38d8d1ef094473113883520683538298e7b9bc72eaec490fa5550479fb79a15497234409d1560e30179f25e90623bb159c6669be3c44fd4bf3c5054acc1c015ead4614638a6cfefc915d1f1f4db9bf79841b757e1bb23d54e57c997a99f7a3fc1ff87bb2bcae640b7a905a981a38a78b6f85203f6138bc237617972d1a73c3f54471b675bb5fd37c0e4cc3d84406b154d33df6d831e614044f095ced04dc21b8ac5a45e025e63c3b6d3032ce78701a7a8f92bdb22c9fbe1dd9ba1072fe973b8bbd0e1555dc85c594d358bde8fda80022ab8e9e3b0383c5ddf423430ba1879c5a39d7cfc4fc081014e32fc7e583cb4699f14f3f6af6202950f7527fd39f03d7f5bdaa6bb31f71b8788a6e0e33a9ac365369c4dce98595423afcd839db55e5b8aee9534e95fc5b4824a636c2d9eb50633621a65ed09712b7ed4d8c7185ad6e21a16b0659c759fc02f39c75e325bdd228bfd25c6d1f94f5b47e08b3542a8f759a479172eaa38bf5a8851d4760bc84e039d846018a7acdbbab2929b080bbb3c4354d316044f9c2bc43cb5776ab81bbd83901bc17eb36cd4d1a9723197e777b7f2e7419570c3d5b12af57b69a8c56be8a669fb6b64e62ddf8a823dfb7738923887e6a6d2d2da774d23b4165564b709bba2b1e68a7946f2c44a0e57af99604f77d179eacdf00fd2f7f7902d01c499d272141f33c00091a684c4683edda9f05542a8d3764462d9adf407cc55654d673726d47aa52157bda348b1a5c63eeb78ed31c1867ae1da214f0e6c6b6d083ee8567a96f30b5970ca7f5da9f0fbfe80c9cafcfbc772c987c0dac21f884d980482e08dec4d310e7ee77697e4d873b2b11c109305de0fe56dc5035ff258662709d110ca02ea51dea1ef78e0df51ced02a932263b72f6a48e0294fe31231ef36c5fa97258be1df11971b57ea0a443a741c782b108a8724ae1cd4a084328609da8eeefb57ec0e1c36cd703af94fc3629d00679d5dd21d8cb5f03a3ce19fce5f6d4f40ea3964ee965ffc35b6c6746dfffa8c7cb64dc3462adcce85da6b8a3ef5b69605307a064abec999e002144341ed6763fa4cb36229050bb3e7f1b479b8e01b0a06605a8d1a86a5d49405e1c7ad200527fab10879dc48fce9d819ff41bd5bd971d9a3eb64533274099fc45f0b15470680e6fdda34d24fc4e2cef36ca427adcdd5cfa7ab1e43864a6ffc3cd3e59a4804e974b9f6740e6419a5915a96b976ab42208c912e5dee64b8de478080ea366d7b4da172dde72c37ad9b5cb45fb7fe8e41ff5498fbd923c34b407910ea840ef7aa7251254148895251288de96c8c6659028b116fee0df953ac15afbed62667917268da380c6ff070add4869286f08301379ea096f88959c2f4587c96db0694a8dc10c173057032897bc5a31b00e6985023bbe5b70304f24384687b8e14d0b8ad0e2a2fc0cbaa51747b26895e4cb42f6fdcde5a70f09eb25dff7becc6d1db273e618069fb1d81a4eb45d6e570cc803d45e9b16170fdc80c12b7ef1103bd8f770daed12445ef74da0c0dea6feca6357513dd06234eb7f9fe8e9e98df5f756e57d0857264d0ebb8b8235ca43e75898f32eec985351d377694b7009daa017e002d5880151bb341a949288551aad0e6aed7f9decd6e7e6768c7f147c7e7f6c6479489413ce4db16e0da50af43660b4a2c75ba459a34aa99f4852ca6950d457cd60cc75017d9019e9a0b98ffecfcb8696fd5bb13064396592ed70d8d7bff5389cd64552331e6ba6005e610ea88ba80d884d5859a3cfac34ab5f23c6fab749d808629be915c61eb35814780645b855e0e8655da8c4396d89c9ead2089c51ebf82539f036e639ca02723d5fadd991a46106ca9fc2d035bbe68378ff03ef20ab416a8ccb4ab2d302e759f683dff706108076d4fcffd21ab0e4abfa780b3f5f0541d892fcd8bad9bc3d90ab0631902ef4711765f6a8008224748c99d31b8c336d0cd39c6c62f3e21fba65960706c4312a43583fabba98420ef1c98d9ac6435ac9a5c4a70b82f62ee9c6a6f8308b95edcd00b53fdf679722433e9235b2fcc13683551c18a6f8bfd6a3b8a1917ddf6f9a56dc866b803c48b2ce948539b7dcb11d0c8b39034c7026df33bcbeb18f3cfa13e004f1f2c10b78c856228bf5d0e8b11c91f7d71b806fed4c2515b237abd9720b83d08c11ed915eb65d6d514ee22265b4cac0693a1221da42c07c9ef99d601fba8cbdd4c0a665249f8e9d171c809aa373ef42f4d6db848dd29f67bafb25f2d4fbf52e8eab3f06e546857679c8694c5dac5a5bd32a56dee0f51cd1aa92179445d5b4468b082162d74fc7dc89d2758c28f17ff9ea5008e607c231bde9d3640b20ccaa29c5902c0815180735bd6547ceb913336c7575054dc59624c5429589d7d6086912ebe90dd5e93aae8238c38fba381cd53b144bc60eac3ceac2f6f6d7b45f35d3ae2ba6e032b46fdfb263f2bbd24abc5f4ef2caa043c7638a889e93475fab5501bfe9a444c0b0598a54de5ef5ae4cc72c7b61d006f079e3158cedb5c4b66ba7f32dabfcd92c25ea25126ba21837218c6f58f38c98848c81e14418ed8ebfcaa9e98706cb38b0cfd23d1403ab41d901905549e1583ab1b1e34c4faee58919d7fff8fd5a1a4d024f0a574b4f6932b7933231d14e3a495a645cd5e5fd9ef9cd64feb02b64fe078a9f959aafda07c4d5c7adfe1cdffc148902a28977660a79232bd7c9079b0b4cf0b059ea3643cc96f91d3a34a85b567efbe13c216daa80e92fb38d1e594c42ad312d5ca460f74077edca88fd8ffe79c04d43852c82e15635f96d0a3856bb13ba62c3f593a0e58e05aca2f969c9dad93ef62adc82e7b30f5ff98dcdb51accbc5fa8d95dc513e91ff6f5875eb959f72aaedb627b2889ddbadd3c24c2f7053ada7e0e55ae72a7e7f72cf9342de4044c70c4355f7033631f358f6561a0fb4da4e2a74da5a3c654a30bb80406fd8e8243a73a0fb78e64fc571f9cf84e388695c8825ee08e5966c411bf0d4cee87068ceb03eed1eb48b56b8c6c79ba47ecceedaca3f7e634e1d820686b55aa1d781a5887aaed11a292b2b083b74b7567c8cd460ba9549c303b825b2ee2cc1eeb5e0e11d1e39059e05130a339d18f6ce3298f0775afe816ff41f539986f035242869224eba0712c92faa2f05d32243a2854c356cbdad14307a03b8f52445fdb588fd23485bbf88b87c5ce331db9f32977febc17982f4a703d62112a47bfded7c32737481ca6304c1ae56ba5dd0126618ca6ee768f753347cf01d8a4b5c52ee02957a96d281aaf3b1ea192558c2755a6cda0d74c44e7569657f05405dc06678920d04733794a6387ecb72eff3b055fb86780905de1ded7a3fb5079a3adbd3473e1f4b67e70d9eb3f9b98dd8ab99dfe934c7a6b74fd9c51e13c041f189ef5703d4537db06d447247aa33d49c11f92b3cb99aa368bf076ed7206407e509c3a63ad00363774bd6227e54c225ed02aef3b9ba473ecc6f1eef708682eb91f19408ee18329567dfbb10a2a15faebca9abd1ebca4b6a9c2da2bc2ab7e908dd4ecc72da35aff400cce6f6641d2bedd7f8331962f6d0faa004dd6c516671ef05917b2d017d941c5bc643ee1fcce4470832b7ff4c48f4726015ab1fa697eea8fb2845fb794a648899eeeff07abd61450b4f9f8bc990ab586288110aa841c9f4b79af5bee28bb20b97125e1db041d08fc07fd4833ca74dee06f03cb68aaef594976754ad1021e22e266a2e49aab06c84794a5ad16a802c6cfaaf5a98b466c96232e7fdc4149c2fe0dd829277b668483d32ade8eb0c40dd0262a925cf6170901776ce67dcdd36cc87ebe5c7b58d37bb79baf68ea396d1eca564777be8dad3f5aa4b7bea20a37f9acced18a6ce73e14dfc8238b5f3e42c7c9b0adfc31727e23c1b4471498255a4857ad371b3b3a108c943d01fd774692ef802cd458d5b86fa78aa14b3464a99afb9bba95c3be4407a99456e8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
