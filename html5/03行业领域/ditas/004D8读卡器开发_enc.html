<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d9a3b8f6a3f474b9571bd15a429952a4734bf2f7821f23443584ed2c732ca5dd1c76f3b15b0325f73f4f534bff9a60f6ae23ae949a8173b5ec9ead0ac0fef2f861f8e858ff1a32e98010943ae40f896981d62a2ddfe795fd495c5ae1dded0e6175e19300f34950c58e0a725485d849fae8d2ab46fc49a58f8497afea0b1b1b2b4057c3250c1a6b3602df7baf16d2d6ef639ff3fd742fabcb2eed90861664e74cd80537e5e0cec4b939f2dc17040b5521f99c6e2c82b6b7bb8e1a5aa931464ae4e9d227c67dbcf006c8be38cf0615c7b996cfa56decc6bcbf759c129ef3e803882a5dd823a96b712df8cbd68d8fbf5a935524b4f916f8ab55dedaf181be0c4e917205ccead124fe0b96c404a75cab8ba2effa8a48b1358f4d8b7930d270e2ad4aa78af30db5803c6aa447729f0baedaeedc56be897dc94044209cb87c011a7a9ca9e2c81fc00a532054446cfe32b4757cb9b3eee7ab97f5c8e90847906bc9b088d65053ffa2f0633a0a205292666fea7a4d1aed40ab07b65b93ca2c0d969a66b21c2e9af703e354bfe3c1eb4857a615cd1b786b129414d8e756f9def17c6ba29e91b5534dc9e6cc0fd4e8279597c15e76ea69b82b90332abb9ab41af0206cc0cb30e71ba099db7cd3a82d0ddb2bfd5091337ce9664693547b6f7768e64d8b246006032213db79bc5eba9dbf26b1e1da7d8df0ee1830f1c810e9d3a72b93c7ef29ca09f9e1b6efaa9f37de3a746e46b075c28e338d3bfa19750f0e042d209cef4872da4e8ac6fcb8482cddef4a96fb942a0d9b2acc69014d5f5e76ff03a11390a4e88aec807a00ccc1a232fe5ca305ea96a142e53472df47b88923c5bce2471d8032503946dc71fa4b8cbc9f81cff3d10f2ba86d1e0171f14f44447ba0c15d375b46bfba9912b5c5ea5353ec81dcf11178e93c29b51e50c83653d91b0d4bd47150966518f9c7f5b031fc5dbf7ace0b7f7b2b4f1c756a85ab00b12669870696deed16285c6a2e682d60179f445f14df45aa7fbbdcd467736e83f27e2da351445dd4ad52ce5cc9c94f4e4db0eb7f8637aada2b8053128f2e5e64e727a5103639373441aa9028e0447edbe8cdab0920120efa76cb650d733265c74c1b75817bf26ab6c889f936a6ce9275b301a508c9ef8f1514f1fc852725e847c57136f72e589d84ee09ad5b32eb7ba1c0a36892f215ae9a20b54cb14a6b264d7928a9592044d1d2a1daf3cf480f85d262ce327731faa2f8f2bd93576ef78043a0ae6bca044b210eb0b56517f7645986a43acc670488d4308ab38704003e131f79d61e060eb216dd8641e6773d2a3a11d04031a815087c019f3aedee140e4e801c10e413eb6209323ac96625277f31790653f0c62eeda8d3c441ddccb1c7e9be85062a8d21870a14eb42b0386fc7769bb61535849614ab0775ac693fa87b24cd786dfb35a33c90ee936ab0c6d0fbd5bba50603a8cf8da2729dc144092445d0642f96648def1c9fbd335cd28450df7f159d1bb9eb4c992038c9ae754b5a1b55da8c38ed09b9b6b8ac903f85bfb000e0e31c7b0e34cb1efa59874b0d377341700bd2ef0abec819ed1e86ce3282986c3928d2bcab841eea1637620b8e93c3c7c35d087a7f55799e0e447d8b52eb54dce4ca651d9762aac5232178608c953e407c472c522d77e87b2813d559abb3656cfcec24049ea28b2865de05a7e8e63ab0e3df7245fac94f54e853dd4b2ba36ac96ac4eb5fe5ba4e35d978a90b63ff08078aa1c190f01527c724259cd5c53bddeb1001ea877b7b0048dc064895cf4fb09778f675db7d6dffd84fd51a0398f68ae026361356fdfe36e0e6065b724289d7a807cfa9f6aa915c7a10907205fecebe09f7f362d08fcee430f76dc92e1b88f678ff4a593a97bfef2e92efcd5722587c0b67658f795bfe6a8105f364b6578c50b474cc01a48b78188e640759549173548ce4fba9683a89293a31b37f43d09826e2c635d486a0f82bf0ccb8e3a651134f6844872e7218adaa03c8846d057f60c7a86dbe991d6581510899ed806383d45e4edf75374674b0fcf2a662431d245a67d478425800a28ac0ca911b893b8eda452859c3098bf20f20a8449e113bb6cb6f5ff779c587e20ab4a60b5cffc5a449fa4b0496976fa6188e5f3b3e97985e1b7d98bb227694fdf5a95294be54ea7aafee4020fbfdaaf1d4b549d8b7fc1e3872e630cfa9a3b93563c8a58260b59c609b711b4c6dc9de3843b32f85e4b38d74b741a71a419a946b32112de0bd196bae7e69e5f66232699a333c8b429b97fc59b1f54a8ebc3ea529bd537ec213ca7d48545109faa469181aa53e8e03336d82c422a1394094ed42289606e5a4f9afd671cadd6d2c44b3ca93ed3d8d7e43488497d8da3238d440c2ca35b17ee466db4781f989f4aecedbc0d0677d97ce3f1aa9d18dedb133b0fa0e76b88528102e6bc947c05935b15a4336d05563f075784dfee21d00f25d7e5f4223b40a14d01dac163a5e401b56def7c0e2912064a8d7c3b2856ab63e254ed90eecaeff7b4265513c02286eb0e095ca480543912464ec241cb6768866fd96594ebe109f71ad0dbe61903f2719311cef44d3c0486eabcc4f5fc12180336a1da17d0b75bbda04a0efd280b2eb9d0482467f2cb214ea0df90506a9def26c78ad7d89ff3474ec13ba238f074681a7eb7e47de5043a3ee1db93ddc69a004e9eb17d3a76f361ab2b9850b791d06e5f2e2932c3ba2098cf84a765bca6b172799271fc1dea1e80e1ad4e6f400c682e308261997b0f518736e562021db2e69049586a373f0e8f49330d8794c590dc770fac889b264b26b7656ca3a9ecf63628fc89dbc362c7dc986a3f20d4504c9b74a8f79e30bbf26545ca3f1878f9c3640c5ba6c7cd67e30efc32c0de5dc305b75779d2606d3567c27c48fd4ee7bf07a2815d4c91666eea0dc06c94b886b5adaa72cdad8790522310ecb521ec6fcda8fcb5173521929f4c508502497521cb033f5ad521426c008c8cd055f9bde3b3fa60106bf8d2d56d07be5bf5d92098bbfcdcc3ad4a87b708861a59e3884d7f62d3f72d28856805b090602dbd78e6e3fb8e4a25b8204dc32baa89aabb9b9e46cc9564cfa4ed3f4b8777ac879e2209da6ad8da47fedc2b924fccc05b85ba19f3754948c9134ba3db24f3745e68d5a32fcb02dd48f83319163a5cdbe5130d285ba36278c492f9c5774ca2389297908045a1938be80f090adf1299955dc232d961336aa3925fdad34ab0a4ab0b6e0dd5cd5d5529139a3aed4dbab8e5a193a867f6c6567ca07ec4cb8edfb690f34e35605f5c0934ac45ee4f3d9226afec4a8caec23b282539dc409c0f8cfbeb974c89ad3f37ad729d4ead390be976562a56a5b6514474771988898caa6a0a141e1d5d8a5b21e1c75d6ac374eb7c0b014c19bd296a44c2b6e934b39cf74b9ae8b0818f1d2ed3bc211f3ec3f81276ef2baf4a3eba9900f79c14d35b0bd3991160a42236673df11fc90215081bcb027e8a740963b1bf69025198a8a367d860745498c3886f7a1e4fae84dfeff36c7e2fbc803a72a5cb1524e2d2292b9c2382919d78eceab948f069be8d340725a26ecc0ca225b19e2badeb02f9f635b87a11de180bf610103ea25254a4813a36b10e84adb56130596ae9c21810f64da623ecebb22f456061e00780dd4bc950afc29d4d09aa5451cdf270a90789e098688e5d851cb3b814020fe06afb8c5780e452be05f756b619020f5a740a41a7a79eb644db19f992551b8fd90e63b4a4eb4c91d41012aa6e2187d827b29ca37adcfb43ffded7f5f6b2c3493cec65f5eac90764b8b4cbe017eeac5d2867eb77ff5e862cdc43fdca47440d001922eadac770758e083b1ba94dd6284af2afbfe1f167f4b819178a70f18118b91dca639df4319ce1006747b519422a9ca89bb5f9cd260657beb365c729daf668d3a6d6c3e63d79f709ec81cddd7d38acc0286fe6356c1515c4c470ebccbf138d70c0adc3d15c6d91133f2e358a4c826dbc5099a10d1937960330122bbb723f7cfa1af2dd6cd1933c50f925aef7b4fa82e67842384bd834bdf2e58b463c9964710396b66ff693ec4372ab994b8dc6e2a67191c075b6b1f5f177c7d4968d73fc50b15fdcc1f27f37f5b454f7d13b33abc5b35efa2a34ac917a51dd181711d41eb0535ecd5003cb2cc7122877e3ad7434740bf820b1a64a29cceaa7b7f7fbe1ebf49eaf03f00fa3c35351560b8f7a2c53e058f9161ea80f8a89fcb64674e46868fcd76a400b3e52fa8d4fe2dc53e6cb6544a620c2f1fa2061c715a829952dd740aca01b85ad23440af624e3454d6b3aa93b88044aeb2e4712b7922f0acaea69b2722be54b002d2818d77a07578a5658fca1f5defdc145e5f80af31018e245c78bdfd5737c711be8cb2c0a7d3fbbefa1eeaac052325aa42b9e59e420fa9e49a59950f35ad7ffbcbb3c31f8c6a8f5b0c81d616a34dbdae54e9fce9295cfc990094764f0457188ed9d25f8d2fa7fd38c23df718264b4645ffd2d0d66daea0781a9d71832b0ca65f87e925a75da2613a2cb8e8cde3e0505c5c9b0334cfee37179719ee80c385ec78f6095b86f5d6ad49b570e9d6cf97a280f581c4d26044352a4707dc44f18c6ba041c3ea3d3b55c5ab1c3e2420fb88965ddabbd2ba02b5aca8e968a75fa6f2a8b7902f0e576d6c4cb74d8bffaf60c56f8fbe0084a639a7bc4eac059dc32ea8dc17488bdb1a2e8ed988f0f15a373f0433b1a3897bada9c5d90b043fe0d18e3e0f210b40b77fb3a35584c9e3b45d492d89722df9bd8f60b53c77de3feeec5ceb8adb91db78c412d0af2d9d78dbfed2e4cf62a5cfc77f13c07087a16567db2b2a42cc4d45729b36443302e9dcbdf30f7bdc56f44db98ebe02b21a88732b0a8744953b38b0def777a88fe11d94ddec392d3b84ccf2887902d5a4b15764da3fb829641e5119cbdbc021d34ec6c9c2a534ac587b52b307a976030a45ef2929e147c61a041f5b6dbbc57dd6cbc4b8386a7d3c3b231df30acfc6daeb16a18558fe16cd2f07439cfc41d338ad9f94c9a80d08c94a66a910267fb50c447639f4d6a9db9c5b819d1522c0eb3e6c07e573a057ad65aa363b2166dbae04d02c67bd31f06ef534145586e264740b78f654218f508fdd9d7048657899d765f97fa47f966a101d50452530347871e96d12af9a53e3fb623211ac1ef69552540abc73ef4542fd8bd5e725f20035658962d0b0aa1042d9894df3185f14290d52b414ec2525dff63f00e70c890a36f3c7acc1b1d489559c851cc682e8d89994f03846d72d4cc7e03e4236976b786292d58fa841bba6ede6b5489eeea66581e0ad39821c36f73328e928757c9a73c0576f83d0c84f7fcc4830c0a004d658e8d2da4c3692e76b3dce00d18132f606ec43e3de2d974004bb4c3da2a8c4b3ea4054765896d400381b7c23890f1dee39d8b14c00888778dba7e6afc5db3eef99b1c055c55f422b996d84d361976ca37ab83c5aaeb5b300dee8e4e82d31a26ca50c80f4e68d8d47eb6ba83343bc10953a1b050a00bf56671b0bae33eebc9e5d7ddf367fad3fde47e631e0a7dae7aa265567a67d1098b9981beca5fb5548aed57902801778eed602a297889ffddecb01978f6ff78682c4ef029fd01acda32b05bc585f5edfb805d42d6e0b82c75f332968f588d33b2e41292b43092abc919d8f94e047b23bd3f6861e215db68ddbe2e9d2e2538ea7edf8d241b542ed337ae3ebebb5bb77740a071740985d5511e64a950effaf77bf43e0255374601ed693329895acaf4cd8f4bb9cf32c1dda48f56571a0612018711f347e755edf7fd73d91d449635b770065f1e1e84895e9cc42d58c9d98ded006a11ceb58cfd017d193e309ed469001e19d527cd7d4ad76773b5a2a5ad3fc64abce27bb743d09b4cd976cf664daf31840c22d88d92e4a0e821b26feb0969e846d45293e3793021a0e3cd745565a9c9637d8af57e0fce114065fdd4863d0f9c77a881a242fa2efc461ffe71001a3985ef7534cb113ebd9bc8462d054caf6f4a0b71fb7c1fb78f41a170bd498cbccfcdf356ce4783ef2cc73336ce2deb297b271fb1bf1130dd6b581635169a6b5345216990faf3e094a07c3481ae6e5ef73cd4563d2a118edf95eb6174d6907b362361355348ccfa7a5c75847d86b6fb9debaafd2b45bc08c91caf348220edaf6d8040187689c6a50375b8c697421e03a0b89e41515556392943ae773814fe0a48920bc4043243e80390167f1e88ac5801b6323c7d1cf7a19cc4d1d96123eb9e9c9f1d94805b088d5842d38fd7d40b51eac825ff07407db2a2bca1806127dea634fa698c7699bed3d6acdfff692eccb2521dd912d8db1ea2e5264e8133b55a9065ed3e7a1f030dda41b0c6ac9296d500503c80729799d84ad258bd76d2c41c738927a69cc0a3e262946dfb1412934550692e4ff19b7f63a8f8a51832a25233356ec877083ae78071cd6648ff58779759c278b86ecf15e963e8f277bac74a303767e6c7347baf4239d0dcac14119befa886c8e075998646cc8383393871aa2a9c549ea075f3fb56594ac8d6ce0c9ad7413359a96914047eeb4df0ca3a25e7e913f3d9c9a341cbfc2c11e24b51ab058d2b5bbf640ffc66afa9acf2542925f716f2d8f5810dbafeff8ffc3a61f70b8d23a80b7337985b6b5a820957b5a0b23817f3b3c80bfaf2efa0d90b3d8fca6a3292bcb5a0bfdd7ecdefb53ba924180cd39c956980d295f6e2ddf056f85c8f74472fee81745eaba33d1b600697b403eaf440b027aa3fd73aa9812eb69e2ac4c35a12b5c0a599d7f3ebbf1df46004d7281aba8d7d999e47e12adf46ecedf3350eb0795e536cd73bfe9826d6ab3e4e6d311c4695eb8346890a515fa8e9412dcbe5b05b15c8e874cba082ca59ba1db3662f8e2dd810b243fa1bcdc08eb7d740a794f210ff4812e8122e4668b346138f9d396a52e47f050b12953c929cd5231189562a6ea9ca8f31db1004e04bbc8ad272f75b387e792f3268c6bffab158c1dfc78bb7450ceb547c484494526aaee6654a40e7961ac05780a674f299c48ba3694335a1997a1cfd95571fc41f3631c26fa202c99f30e5fad138870a3edfa6b675963b53d61f31663462e488e360fd484fb8e6e38a9310b60661677eba58c2f004543e7be89e97ca6b552fe45e015473d7dcacc61201663b937954a543568534afc245cd9f9c76ba30b41956c27416b8823e986e9471316b7ef99bc85e9b012bdc213dabf07ec8f312c81e2d26958fe0878e0e10c5222cb86d9f4c2e53cc19a087c74a369b761861d5af5ef90d50cf4f6099a7dc20b36933505dbbcbb1d9b0050345bbd536b2af4176afd8c21ea7d69d95104cbeb7cde046561d56699902df20ff3296b429dbecb3cf246114e955bd343f3c766d8a5b791dc53cd91d2c56b690675b34e7105585ced124d6f78ca0edd4c90fea28c1944bf49508607944462740571e218bce2b4f3f2cddd5b9581ee683c0364700b2b7ecec7e667e7b7b9531fabd34d80eb947dedc3291cfe9757951adf6323095d8ea1c77c5278f1464c1ffd2686bbcbb5f184e24adb4812e583413bb19388491078e9eda91afc7527654cbb74c8b51a20ff6c62dc9af8b8d01b931505cc9eef44b93aa373a8219924d45aa7d7cfc6c2a774d3dd50167b77ed1d652643bb8c34dfe0bac54ab1d8e60bde1173a1a1040bfdda01fd092be7da0e87ce4a882b65fe9578da2271bbae8ef5f8149601c9f3972ffc63fa77d3e091913ed9dbc8afeff596511e471455b5c4545c5fc8a6a5c413a857d1128862bce463b7e283a483c019041da1e2e341b72a23e6d7031baaa4281f0e7db8b59a33d0876f7adc4ea8e117607230ea44da4be7e8cf2b8493590f32de70d3f97ae57d406ca845fb389014c61b85892440456935540b3fe7632fb5e64b36bc16d6e794bee483c1d0d1f3a552b0a6b111c5bdac408ceb81363eefd59b23821d2e3d4ab6a77431981eb4fe9f416c0fe523ab3fdcdaba2612be0b6cdfa09c83dd40e385a95146e638c6e540b0f152ea582fad24e6f12d8fe1c9ab9fa55327a418fd1cbf9de5facf77f709ca6c977faf5335c84d9f3c10b95245992ff52b62e5b5ce8ac8a735eafb7a7e2542282e0a39458ea36b653feedc68f21e3edfa6a7de0551c278731040b9de43adcd59261201435e7a2f3cf3807b660d78805120475921645241837981123e5be7dab208d5d8b2dd33a76d29d7957a5a20f310351937e095dd720c78a590cf1ba5a65d67e1c1cd25c875c0493437d39a6724845c6ecd132f245824c664b31f81c922bd32882d7a05bdcd87c95fc9c49b7ad8017f0e92da1d297b048b8ba57fb09681f081196ccafa98010303bd7ba76a4b195600b45f52a022dcbbf7fb66904e4a85b37c51d0249cd882663a03c079ab68f693b4da6ee7a1a841afe33a89aa5a3c82e11a407fbbe7c582e6c9940354ff24350498d498c23713fd5fe88e866ba7dc44b7c8c39fc730cfc7b17c8cdac1ce7388b10b9df962eccdfe94d749599d365f9fa2e0e45649684b215dd3fbb4b972dc13d4dd9f4328ac8e01ea57b196e74944fcb26f92483de496a57ff5467b1e2b39cd9e9b95c86a50c1d30e3d37459c7db785f68b2b714d512bbcd6810a680d03e066c3fbeed37f56c3bc9e5f3c4f6d80028f6ecd01fe42f79c2745c458e7986203e1c3f0b14f99c5c39b6acec8851c6b0b3cbfb3f49152ddd68324fa7a2b135e01d81b111ee93dca24dbb5fcc5836aa8fc390386085acf40cd2686fc9704138213c1c0f5588d373a622b11d71f289c7195a3787e73198176b11daac7b438f52edc869fb2b766f7e0cdbc1a682b783b9b167f2baa01b866ea966555c76a10de7598c0e9b9d575345b72079ab6a666e73f88baf267f5dfc2d7614eeb7a7db6086327b2f3fe7bcc50b4ed89df5a1796b86eb85da32555e6a1b5cb403fec352922a768667a11572a77b7a0bcf0d03c1dcc4070801c97bd5311630bce867b925c901808f16403f2230c36ca624a8b9cc74a06be64ab8824733bdcc4664ea741461e5e9485e3d463b4360812e1efe2eb08e899697be478699b752e6aa5ca8efe1742f9c9685beeb6c580994e5c690a9e606b6fd5191f712d434a6ebdd376666d998c7ee731058f0bb60ff0064e28c6162747397aa17c1d28c81446fc35948e4b526fc189e8d699b29658aa5893899d96ec3563f25623d753129386def110cd3ed9eb93537acbfc0c593037cf7ace1216cf9878c8b647b569259b585a8b45f79e81e82aa064dea4d28175488015b75e6ac0d069e44b418f13f0bf10d0b8ca127e2b92df659191237e1c1455f035f0910e5de556e3910b5fe261a6528df37e9cab9b57ecebd30bbe87ea503e4c4fd62c60ed7d7c305098f9923ef0ff0e36fd7827ad97b7c0aaf21baadaa1270f192b7fc6756eeeac9094c86964efff7f167488a0699d3e5fe90e2d1cc85052ab8b282a884f35e7d25006901f93ef55c333334e7b808979c20c0881557671c0c9f8133523b0f44251b19b903260b7115fae4b759563575397a94969a5a9c10018c95aa88f3d530c2301dee94f0d73cfb5356a88bcf8e630e22ea62c1b009ab97b650aa9ec15382344be6afcc0fc79ff6b2f212970f67db045209e78d8fd73ce22ea41c4ef68ca5734a8b2d991180e4b8f4275f571929da844b4f0f6e42f259f3ba2de0ddde0c58f32a7a19c231fc2fdd834ebfce7eced1de5488c300714ee3ae3792066367bc0e4892a911fc40d76854942899d1bf52078535afee80a84e9d449f8101f78186f92ccecb026b6b1e50e05f900d61c63a72dc8f786d9721bc192a1733a6d25389a9b237099bcfe24ee29dbebbe76f2c145c653b631cb375c4c55c952e8f4e8e6f4b541432ffba0f0529983ff43fa86117618997f5ff232b8cca82c69c99bca1cb462014952294b147034fefeb377b72f9b3ed874395fcf37b54a262d1b244423da538e6ced46d3c10d459d259236cf1de340ad355ead673d738706dd29bbe65f153f47760193995c00f066bac88b86ae45d47f6755b99bee4915cf5da26a18d0bd1e05328788d8630d515792fdaf01e61e2778372e1abc0785f1affd54d59fbce1a981095e1552e60b1e7eb69a4ce2678b129a9060e705662c3b24f02c2f35d1ae3980372ae5abcb6490fd1e03dd02ba80ec3cc5b506d67058956f843d96fe61c464ad8e3aef34d117638b30a0bc450c984672cf722f15fd22e3bd55fcdcdb43dc10079d3a32dcfec9ed440816ecff0cf116db3ecced4699c596af2ef9fcc76a5f4cbefcc54a30b2e2223f355b256641707b12703b3d3f61444d8b80af4bd7011a95f86518e5182f87dbf66d0c9e6a1c72e7573ef17c298da8487b7a9875af22949a953b90b1dd9bf522fee4994b5554b23cac0a23a9dd02d9b6ccaee8f2be427e373da4a5a7d59636277d8eac75e78688f4b9520b2e989cd0cfafb625f1ad5f78679c5f3c1480fbaa4032533bbbbf36a866f7303ff01c1f07af01496b2b31e985ef147d2e72d107844f590f3018b6514833ed4e03c96922105770ef86339f6c69458c926fefd8f7f0fdc10613c00e462f7db9e1ec6350c2da60f0728babd3748e3fdbe1d0b88ca95742f133eab5fc50564083a6e092e2060959bfbecf0be9da12535369fdc25ed09cd6ddc3d73bc0bb8e8b33677d0dcf1a38589a7135b0ab198aab71989c023c930b671cc5912cf91c8c6a8d79c7a8db01f46dc82a4e5485d08b2fad74036ce605f8e4e8b8bc3ccc338b0d390cc04e08ab42f862a282f56cf841f580296ef4c887b5b8e78b514329802b92eec18dc3d7f2ee3ba89092e66675d08cd321e5e4e81a63f4ea04710771d2efa650d7ea4c07f8eb63b9e3d85bc6e9182ab8f092e01132eac9692a88b1f57d37bd5fc0e0077533f6d92b3dc50fda685616e261fd34b1f8a0beb02a57f3c1a40255921d74eb304a892378b5387857fc28340ce419b83eb8188e67dbd230cb1eb7dcc2aa0c95ecf8eefac3928126ef3d816f9b479ac9d91722474af830c1ba9f8eb764776053acbebcb049a0bda9025be12b0e374ac41585284c177f4e1c20c451b29e552624e9a6a16dad2eb6a187eb86674de16f5d5c6547ae6ccfb97994926fae35ba702668af3839cd8b61485a4d41edcef3d484bfb078844b756392d7f77229812883c291a21eca363fcb2da937a9b058d3b36728d8e834fad9a075c3d92443fdada7d45e39b2792571eec053181b1711a48f722aa11253b43c8ad159a9ea00862e045f8307622cdaa88fb41e90d121f9f7cf4792d2e290b976c441674fe07da78a42a0f8a859b5abf0916bf16791345cc239d7dbbff0118a5fa192d0141d0f74ad2754e17235c626530edd49f8f960a0a0c3fff82e08dc351108540404262702008b48f170cc43386250bb1b61908851a0ab50bdc200999ea65f691e48609411f44a2875f8e23ea72d3209fa594c586fd982bb8749f316668f48352a364ef59337b187e8f1eda37073abc9443dffe241517cee2e941dcfed278d85903203aad71d7632a52a7001966c166dc5f9c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
