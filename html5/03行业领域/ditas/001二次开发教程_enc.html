<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"103ef2eddb3b8ff010da299541aed16483121885c7285ab5c92ef770fab571a7eb798b8481c43861f7c1aa1dc23be700453ed43a0e3f24acea2fa37d71f6dc7aa4b18d2bcdf0aebbb3097352a74e2fa5c5bcb0b514d14bbc76d4eefa23a40cb5022841fac69a7fb626a28d8c6f97cfd3f6c46759af4c655a0c1b7958a7e0bee64de02f9cd51225efcf4a3c963d598df59a26eb50d33e04fe62419590fab2a1153f8e91444fd294cf0a50e7973744ef61f746e7dfa4a0c3c470a4e3f7cd774aab4341fb4cb2fa4bfe2e131c3c1d665c3eb8d80d76efa01f0d20c65c55314b6ae4800a7f60cdec828ba98ccfd566c0e84a1ab0666343a45a9f84c0f9ca919becf4cede6c936104f3f5232a4fd545cbc456a42479ba2c2a3d6fc677db0497e62fa884cf87dbdab0afb8301b6572eacb78e8ab0ad4450b3e8e6e2cf64958b666e5110842aaf55807bb8f439214f12d94c669fee2534a0c6ecc95f876d6974aee92d51e2aff64810c5e4b92f41ce6a31796b9e588e75a906785e09c0fe3b3d2bdcf806ccb3996f76e683e8ea8a7977a96cf2e79336d40e753a1ae1622e51ad3388950673d1ca2a23cc4fd2a252b96f4f58bfe2eeb695d10cc524e5cde4eeb7dbc0ae376b584d59e932bf184a76bda7a82ad1575f7a795a7f8e4442824b3b0ce2e15aa69d520ca5b3a0b294d8ae8b1900013d094733f279f0c0f8e1ec3c34a8aae7e120d4222b7121426e8ea1015069ad1a3bde05d6859dace2548bfac913840e5abb8393835a38ccef528a1b42bb3281a8c634ce3b3b700ca1d63465f30c338f196fd230438f49150ce5b59a32bae925107f01b0be98492ac3371015166d474cc6e760f8abe927cfa4e64747fae8b148f04461f688db2b624292f771babedda73131c121f01422d33aecb5d118000f3ec2b83e31fbeddf70515e5bbc9850300cf91145c9a4e20d38090d23699d008e75a25b4013825602effb58dbd5379ee23f008558a6b3cbea7fdb16c648691e86393328bf41c48756cd7dfafb5178dabea3d4898fdba005618a360bf75ed919c4b6a0718e0c7157762063a084c9e7e991c5e16165d1b17e1b6572d84a69251e51c922b48bc2fc80ceba1c113dbab9332a12d6832d8e3e4e0fa7cebfbb4ef9bcd9ed9a40c642e4d0d530cc04550ca5e4fe5b5c2bb895196824002f2345ea4124283cc7523fb09bfa93c182a01320d96ba6209c4e2e33e3fa071d4c70ba7f6fa58fd071df95b05b1e8bcc229c8e12bfcb612ef6be485c28a7e14634a8755841894bfbb5a71966e852749c7a2194c2a60de8c554278546977093041b87c0b333c1482f5950aa70920999e900dbfa046fcee05559f0d9cbc70b3699a652bd6494781768733660c0e06bb4e955346fe7dc43db4265b092d799e7936852d16ad0930486751c3a36b42df827c781381acfed55e73019802dd9260d4dc0522ca74a3938d487f298423cc1c7fd0ddd12ed7a3cd04093ab7a44d6536f25a03c2d91e05a1b4189d25c7b31404bc9f0d1a6b43ead9045080d2311ff3be3ae48225cb66f9ce126329aad768312fd8b3406edb93808527ff6637cb2dd4854d29b4a2a5d22d407a233aabdca53c0e12a78f2ba36f326ae1e8664b3c2924b64ff738119445e9880b9d7864d07df55fc11883e75dd572e563591fede020144da3b77862612e3c90f00a1349bf257b4d415f8112594ffc6cde7d6a417ae3aabca0000e67018878c2b2eb424a518123a3ebfec099035b17c439d4c3f505f45a2f731b67de8bb28572c1d2df25f866548236c3609c09d14fe7a75f498739386f5701c598f56a11bb67ecb67fb743e7b19780e045c10025f583c6713fa89042c0c6f9defd10ca5e2181a7764184877e2507cc885308bf061ceb52a3484406d2a61b1254c5b8b7b281961ce7a8723c6442fac25391c6af7bfb0beb0b9c717036003daba4d43b740c87f6144a6f1b4875178386529bb249cf31d39179d8c8db8f44a426cc62fb1984a50b9d259b8ba53ed9027822ac46058f86c63a78f0927be8afda85c6087bb098854e86783788211908f7f8f289e28a6bc1e3b8681ccf5c7d7fd036bef7f4c8eabb7b699637a16dc8b7cc8d5d5cadfcd3d35da46a55b7a1b27170538a6eb8c3bf8bfdf0030107a9c47045a165c024f0370162d964a27fb6672165c60a564f96419504acc4048326f99eeffac11939a06abc8658f517a58aa991baa0a3e3217025df821673bcc146f415ae50cf9405ab9ca92688da850e8a07e5fc052fd68d7d840da001aeb19d24f33d2851cf0e3cba626f95f0cab0cb8bfe65d6917459269a10dec4dec68b29c86ab27552a3bad4957e720b1e4c3105b9749a2654adaafa4631ccb714a742ab7d2b73e1209313201679872fa162a7399f6abe20ff043e49bdf42ac95be814f669778b9f3583ec285c545c1fa233fbf916d4034bd8d33f8191033618f373438d74d35b00d5ecae39f29cc4696743da206981b6f92c521b4c4af57da6aef18d6a07f3b420a9dc9c2a7a425ee1d5c15841169c8b0f9ea9375f163490a1709d719ee19a490da0473cf8e2d544932fd153f15bcd3a0a5039c761c7a34f6ffbd17c812bd83a0ca60265aa335c300346dd8f219d236e5d33f9d1995f47b13900cdc05eb54a3ac813acd5b3950268e959f71ac2af0912f85e9343eaeca1a637f72a7f6866f8c0120f6396087babcf2f58037127b56c8b8ca659cb355164190c9e366b9d4a1bc5e2a988514099b9e1f4b8edc6655bcd9b0db81748f050e8f23b76fa20a58c3fa6274585632125b95a79bd7492b6af834eec80fa515dcdb5dce7a8dfa5853edd847b2d4421bfb7b97cea1f9ef719a8ab1a54b902504cd5b2c154190792fcc6ae9c8aa0e8da3fcb5c394e516b55b2da30bbaf5445f319064404a2d94e508dd337d2cfd146c2b4276d2cdafccc493828905614efda78a370b0b8e7e14985a4a643ead0df98c29e774d6f5b6bdbb8c648138f814c105077ca0cbfcf7d6e405ba378478aa0ebd615ef89d61bb32ff313b359387f1472f9c34d44407b099c9358e2ea0f9e9d568c4406eef9862311725faf876ef3b181cabe75c58cccd8b32672cddecd4dbad35580b54b946d95d8fc71ffcfe3bfdc91b56fc0fe4328d05be3cc8e45c508f1904fb3d2f211d2e691bb0f9ff5ea4b8abb268a21ecddaf9093772e4016c1c73278b4c52cfeb681f3de22caeaa5c88d5a4c318ff45378a0c1b568b7f37f30adcd8d0742daa94e81360b79d7fe526aad8a7c607edcc9a19f5b5c4b59cc0ee25c0973b67fe8fa51f668d21ce0bca033d3bc763d5b360e3f14c3dacb7aa21b8172b8073c74539d77428b75d59a51938883810c4c6b8a0b1f3106fa3a474372b0e236387d5112f10eba690123f4223d045928335d4f385322bfe8a477e3f132bea7012ef9ff381749d5f24612b268b2332ed8b42a006a950e25cd504f4f9e6a29954bc9b6a6f82f3a79a24a5c778db3f7a0450a19478bccca4193dffcedbb79a2475b185c988055acf5a68b236d7fdd990ca6b5dafced3f8336977dce82444b585f172a8b5486a59e81a2b6922a3d80fa74074c109fe774142457bd95a8487f17d053103a8d55b105e76617a110eeae366aa6f63661f263320f035062baed9d6085b53c79742fdf2dca2d49d7100152e3d28ed0111d828387c3fa290c88a390556218993a451f8e92749e5646bd9e6041654ce5ebbe83e656bc6fd063deb85b9b3ce98d26738b96961bbe1f3b95bd5a73e3d3765d594b644968c2df69cfc8275dd043b5a25f0047c352ff024d02f1773009781c4b877ee4d0333b7741a8bcd5bce550133bf5a2e1fc6828e90af4c42b1d95b4d4df527a1c091d6a0548584bf05569d319be9d99f2d2b08f001a873319e1fd85d4783ab272d30ca377bec85eda6237d7092e2460b0550ed8edec1699d225eb4c13180f011eacb57f7b952647a028003a922953ea5a69b368ab0c0fef9dfc21a6b1fbe903b5a8314e79e641f589d478c17c1126ca387724ee7672dfb6f64dec6ede9d1a811226761ffa36cfb1288c1c3a1d7a7ba1f6b7e7dc2565734d34f240d294c32823dde34e77983ca40572201e2bc512ad6d09dbf4ff202dcd04659a243ca5ae90067191f8a6ce598f72fbfeb7e18cd1aac9fbbd2704d9e2a0a7c9bfd7564525c3ebc3655e7c193f26f39bb33ddfe18397b18fd4803a74b8b3ff6ba4c95f762e1579d3dd7dc1c301e24b5e5d12efa9e3c4b140fba0a8bf00929a66f3d53d55e1b1451ee6c344e18edbd5fa1c8dea51d40c23be3b84e2dc9f4a62672a7d6497eb15cebfbcdd41ed567177c45aba06abe8014ee3a13cf81f6a984d3b4a7cfcd54c3b78a92bbe7a3e361dbf5736b706ff1ece3cc1df574a2db10d9ab02dde1db2773c45c9db1d981fa171d442ce01680244930b5df6afa05c83133208edb7b19d6570d2fcae657763bfd4d89b5a1aa7a51e5f41c3e0ff0f4495add571041329a72c978f6e926b533adcb091243c5d2d813ba2d44d887a1aaaec7949a805315ec245d70660e3a6fd0deaa357ad434e58f083ebfa61f5df05ef3ac895adb9ea8a595fe0ae3b00fa98928dc38d9c2ac1df78e3a597ffd0b4600655a0528ef333fc36930ad3cee64b0c07354d8ce81dc0014ca6ae714462e6a752f6626addddf2117504124d4ed8b2f8f3ab9d52d99c1f6597f5e7fb17b08b21c32b556c2f9d4e53f72e0c3ac43d2145dd02e3c853a58c9d8afead71b9c82e4f58f2f4b71eaf4253f74486550784176a0e38d6491c37b4037645e8d622e46ef3a942d4a97b5dceec1422ac9b3df6eff91f0d53826c0202c4a4de56082d747005094864a31c5426600a20e93e34f0c59d8faccc6c2dc8962fcc9e6b8daa74016265856edf28df7273ab23ff357ae835f9c55211dc5aa9ac40e242397e3169ebae5246a467ea39fc0c7ad547be77faaa1b9105c82d70dd14080eda7234993549117ea8520f6a91022d3739656be0fc3770394ad654a3c059823ea64cb3c2b87c2d9560d51aa417456af67fdeca8cce6ba8721761fd3cda715b3ce77b8599e899da663a46ece9975f7adbb8a5466cd6b93cb2c07e723d20d4020fff5b524699ea7ce91aad19127345c39ab2706d0bdab9925bd125fda08ee3328da7a919c1d67b14d4aa3c1e2aec5c43d84a60c188a807343f440ee573bb166bdade1f78d4dd971e9298da4e5b7d21e57a8e5ebbf3b027158990a8f73bb8fa2f3d23d21f4e70a0aebf995861ecc6288236c5fc2f38fd8242814e7ff5dc109f8f2bedbfe53f42e5924429215597f15277ff5ed7d0f84c08d4479f6229fb34a4940093780931a25a4ed141dda105be9f11ba7a78ad6ccb200f59c819046ce66c551e5332f18a7720a6cb949c6c4cc2ef96e7deecac256afb52076f7a2a1f9035b54b279e12859a24bd4a7f752e562777467bb90ce6254acbfa0e6a5d564895ed0fbb689210c050610af4ce64bfb4529fc74c4a8df25a99408a2ea79ea854a989eb0c0b05182364b88134cadc56bd12bba22cec52f339121bc832ab25f304a64ca6a885d06e62f7f0990c921abf9d60dad2ec662e770cb84823b1f730a5c8752769c9c55048dbfc5632519c4a9cc76142ad2a86d5f47f641bcae062d07ce04102e493c39d797581211f9ea8151e7d81b4a76ca7afe5a40a541679bac3b9054a37fb4605c2f825fd40cdf3987f7c4b2f87db95012b3006aed0a0b265ac1f73b8455aa1b4596697b30152881492e11d7e86709ea725f99df47a9da6e7a4b616181e3ab41cd1b902c71d2768d42c01346734af0e213ba804f37e152dbf6763b9e9c5ad3815cc3d9f09fa98d86d4ed2785195f5c3ad94ef80ac386008c0b0d3a561ed60505b2962f6c8f0e7c063f89ace8190de2a8bb1669a60dd70331a7f8e3b308db8f37de49fb49b11e354798cd4e5ae89c6c8328d52ddc2f078c9da3e89d3970b7d6a76cdccbadac89ea459c76c18c6860f32efa98d3dbb00ed919e78166e1a5bb660c795a2ad2b90008d70ce9ff7ce88460c50072abbf4edaf7f4a185b3d257fd4f779465f2e33294e92f50b1d0b63d62b554d691c9f62399bd3a3acc01c4aa3d81471051f3622033b51859d912222d4c210e42129e74f33bfe77476f355f70518a31763e0c281c00bac2a3334000e5e809f9da9533f9d315a53b5562a288c7562c44977b17bdf5da55b6a466d7560c4813eff46cfd9e29485038835454f8050451c0f72f3eb9f5386bd1c3547ed5838eb61cfe2e0d7e24b602cfa629ec6868577bf6db6dfa59740f14b6feffc48282f5fd06a88633f032b2b8834afee24064c2bc6e1ba47aefe5586c4eb763b02396aae5e04b1595a0d72c26c3b92a2b0a4e770fa4ddcedc6adc2fe2fc5f7c488d787d826ca5eee54c2be7d1871787a6d8df17d5b20b2948bc2e1c571a4e4861dacd90d4a19903871a95f9b37f3ddbab3eff03f8cbb034e50ec4496f7f6a1edb799c958b6dd1fdcfbc00578fae2807123adcde25ac76b897541837b5d069c166738992cb997b3078c97bcdf9d77ce374807359c533b4dc7c0010debd7a29c5983573228350a88f089ba5fe99bd08614c9133f7214a38203604172795b12e78a64b1ff21b0d551935753cf2ecf3815360321f4b58f02d95b63c2d1aa8b961f1ab528e4d00ed5ebbcc368e646c2f6c72ab96a3e7bf4f386a70d6bd600dc0b252bc026e10a94137acc3f8e24efd7a582c0d984ccc9d1552107436f127ece899ef17033b04c127a0454795a329ddb9b9cb8012b72f5914393e05fb854f8b87db4df60a33655a586fa683501386bdb700206b6a4088d3e77684eae495b38713156c8cb135f40c512137d0c5d0fa83e3521e3a7de33fa98dbbf67c1cd5d0f580425c04fe6a20ff604f6833968e1d950cf889c3064ac5285d8eaf6cc3a48e22d1afa2a7e70dd5a5fa8cacf0098281fcacb3904a001a0d8a05ee68b1ee8e687da396c21bc4bb7be2b8cc3340815da7296fd9f9f27f7f1c5a07e6839147fec7d28b4ca5254cad2dd573240196a1684b1017e943264c0651417f1a298b8d51d1cc54dea1211bba55fd88848cc21bd27229c19c0df0313b26dc9d87ccacbf47d98ae6bab7c339af801f8be5326610f86b3a9cbffe1a859489e2e4f96f2524a512184939ccf5cad0dd52136da84825599e1d300eb2d365f0a6a53fa36d015c01c81d80b4e86f381e3c087125e8f87db3161fd24838cb2e78780e2b41fd0560c81d66b8dc1101e16db445dd642eadcf1357e613dca9d3c896eace0c72f26004691d63281b800765c89f96a492961105338cf3d83218e0436e7567dad930eaeef2f3a3c84c49f57b77cd655c3cbb718d474ff297bf6c35ece1123a4a1cdff19625e664770e56a6318e3703887f103414ee3bdd7e9b4997ce0ca730b721a847d831d80a882180ee3f14b207313de68aa2f74386911a5ba17dbdb34f03a9d2a0d2e00f3dc2a3df9620e5cd4f98edab5b236dc9d5578d2bbd3ab013979284f0ff8a405661c3339dcc1723ddeb6eea571c12c7a3a204f852aafcfb5a31f0be721c037d50dd5ab239abe5e4493d3a84e3029ca0e95f6fbddd5268ae72e5860abb0dfe05e8ab4a4943bd45c36453d64a67887fcd5b8d05a4241b9972829df98eec6c13a7cdc4f71701174a8aac742f36f51165c636c065002d2e481e093b469dca39dd6cd153db8eede9fa1db758762ebceb09eeac37a01159eee28c44f5217d1da9620901c5490343523ca81fd39aae797912b94b7604dfa51ab8d2e3d1ae3cd5e32525421bea44f7eed86cb5164cbc3853dc28b955870383d9aeb3381d312cb6c83259fee5710b8ffeb9d23c567cbab9751ee457cce458c170d776a7004d6df3f3d117a5b1a9cf51802ce3a12f8b0c74be059225aad3acc03bdaab42a344c04c44b53f15990ec9606d66ed15fef90a424ce687909d3b9d27f99d9eb33bb488c9820001a489f0bed4f212f746347751775b32276bf1dcb709ab72516068750a018501313d0b5d035b8ff68976b8240df185d5797233cd86b715c69b1452e1ce4b327a7660ce17c2ee7bcd72537dbebbee7a2f0c0cf41b9e51333f1c881c9bbd13489dc3900c7bad1ac365cab8e97b8edfc28b74fb4c7d04a55b702c0d6a27eba68cae890e2e6f46cf8c636527f62573c8c4019dc8220884075970656d5dd70de7613c449f0a68d7522a5daf3ffce77c7c25e76595499059fd760f6088c1363bb00bd4f7f9209a177359eeeb433af4811e0a3895c4eb054e2cfdbaec564ca8c6dedebd07980c99ad2020c3ea4258385dc27aa4c9b5037171c897541c10f4afe0c8d4c1f26d0ef609c0f67ed68a17e7c0a4084d2844288b188c79246818dfdcedaff3cb8d637fd343df87397a9bb64bd5247f988cff48088d6800d9e4ab955545999581f445f382a0e6a9fa8cfbc0375edcd580ee8b24f80fcf04a1f0972c62fe76fd913d08b0c1280b94de3cf7fcb6f3ff7270c6013447af5613447d54ca8b9eac451c302edc8385ae517bddc112a33dd696afddbb09f6d9df3c8782363a2f4405728fe77588376abe89d2977aa62e72e3cb046d367225449470e9f634e7b14b82565668a90c6d5640735f2269c7ac64fdba853ffdcd1aad31a431a60e288d1fffa4f497fd5ff3d67b06a30f9bd7494b7d6a282f990df4b0a5fd9f4d884a31cf3cd6111dcbe009f841a3ef4a05627c94db1263c5e81e9e356fcedbf46002119114c5087e0aef1f6c3eea29f5dd899d50e808a0756e4cd3b8a982e85f56a002e806e71c6314ee8ba293907ed7e26f1e261c8fa53134aabce1314ac3838a50a221b593954660affacba99c40ce157b1b1f3979050bca0396336e08dd9752e2210df8649a80a635392df11b105e627e69d4ca37939213edbf06619082eb4ffb44a46cb526659e516dfefa9b34f7139bbfc536128e1b8122ae0abcbd101456aece306921eef746d07891e084cc675fc84fc62dc46e4594807401e358a38a001e5b5e3a5b9dbcb338abdd3119f59a91f0ae1a7afb97918b3e6feaa1c481a350d4c03c7a9dd23c5493286160a3e375a9391210a12772cef283947ea7b45b1441dfb2a431af9456bfdebf75e4495a4dafc4ffb2997a8cdbcb0cf92ac4980a76e5d595f4bd17b2d696cbdf4351b045316fbed2d1b8a92735f8fc088b061ca178d4fe8e26c07a33956c34d43b816702cd311b5c6709422b8843b323e7cec4baa4f8a87795f9f61c3442c33b6abeee378247d89299ca3805f4622bc3bc7e82c0fceed5e91e17f761d64483243927f5e2380d4cd8d60739eac61f73e2e3ca4baf9af66fc6f5f95bbf0bf5c0dddce9d2148f0cdcdf61edddb2a9103eea24e48f378a9c6525985c9d59ac290f342eaebc47db6dfb758e4f77ac833c2f15c02a56f1e1a2d9ddf77b048b6363a1f3c2a88f063c7fb7a0a51bc4f7158d8b1688f72488c2099c53cc2e8baae6fbfc09125fc5092dd09b6174bc87e8c2257684c3bbd8bd945a80bdb515fb4684b3cf589ef5ff33806bc867f82e5cb3831efb7829720989a4a08d5c15ce83947b069f1e67b539f4a4ff6cd1aa7bf3a6dc147a4f4ce18dca5f14bf243ed29dedac491e785108b8a6855fbe0a25f5d31b20140bf1419d2cba318259dfd602dbec44a4f713635ab4cc2cc2ec2b53fefd58a6cb5a3329c6f78b3f45edb24db1014d82ab891096f972da41db3bebd0b8329ac88410f81458b0a3fce7be4aa568d0664bec8b7c6d8f525d589ca5cb77d2808e7a3bdf5899afec3f5088e9da22570a6ba3a0b635143306ddb02ffbcd25845e800a3871da0bf092a488abbfc2787e6772b578cb2e59f49fb9d3cf55a4f99cbbe1cc5364386f3e0aaa1e6dd8a8e634c6d48589ecd0cde846892153f3de553e505582e8fd938f3f6e06d8ff9b8cb8de60309a5a255e1e9ae2c33a1416ab7d3105ecce6265a8034c632ced83b749deb0a3568f15c305c6674bf3274b8212f6d3c417645c3295db4b78c165a37c8ad075ef38beac435df27f91d063266c12be4deb4ef3d9f4a47dd333827df9381092c4572811fa2bd702d27291946ce5b223eb5dd76f46c14e59a1c041b8691b09cbfa9dce7c95c84f3badaf61874e29ed80877b8bca088b9d577479ba291cbe095501a19656da132d8793b0c7e0a71c7e18d85233c65721aadebce82a9c1f40b90a99ff9e69f5c85cbc499874fe45faf9550c4400473af0ce53fd55d7cf563f311ed1081e8d92e69fdec6fecfca8e52edf0dd9b7a9b973e89530ac3276f341104f21edb3935142107124f6bf21da663738fae81880504c60de6ae8605cef3df2b1072aa301c73b09f41c9c14d12da4171c589f5f89f986caa5ca62a5096e7a8fa869b7b1624aed216f65f9def6fcca7540ac4b3db77052eefc7cdbf6141de144c8949bd9acbfdbba475dedd21656608811f94f7942dedd2016d6cafcbdfc9e7f54df94619a2b8a227e5eb9794fc0bd125822125814feea3f02fa01816860550e5b46108cd34181c40f810a63002c7af9e4695d217f41aacc419f9bef9d7ae56cbf11d81728dd5d55531ae5b923439e62a4f3b37b3846cc054d874587332410c6af377f689505823d89566291758e85ae6cfd3ffe1d8a780f339b5533c51208a94253bd335d994467db5836f913397731139a6392e68973d3085bb8e1b7cdf2fc0bd5902dcdd16e52c8028729a6ade335df4e7c779058c91d9fb6f801823304bc130f7b7e5f33e2c203cdbede81a8e874ed84d19f9d13187b538ddfb6d223cf81fc958d85b8426d7db630e9af21441f23b755155cb5bb7a454d819b5269875dacd0750918b6af7013ef0b32ce60925ba5ffdc09133d8895e7f5eee8dc45b5648b8c08595dbd145c971aa93a8741624a6442b455f929a44322df490f85d49c6e6f495e7dbfb94d85d65aa5c78dc87dc5549fa85428b02e6745af391a122b1ad6a9831705d28ec7ab732fb31784728f20ee5e975937dcac830d4211c8fe4fe7829b1f4f6cc42f97aeb39e099bdb5b079da99df61acda40497268acc1e36abe180361cfaadd74866c615295ffdc9189778c8116c5861a03df0ce1321c2ee4d47133d8557a5bdd0077f173de1d622b6e733a38d9cd03b7a73f09ed4fa52e8e37f9cc7ef07e246e61fa035520191ea4f9ec3e09fae9874df4a4e631d941c6c88647cfeaf71f7c9b3d51df6af603da4e6057c7209a702ebc62486fe7abe0d07afdae450e40a11edf2da575665a74e4d792aa82ed522e6deaf4f3ba709bf9eebe007fdbc73db8247e4a83472b15835e023624f3b768b9afb077197be9c675b4c0b5c28ecd54d07185c2b3aadf6081da55860733f399a123181c396fa344d004f8c76348d3ada3a4842d67f65e4043b5277e81cc0b908e801f6b4f48dfce6ef91483c27c1efe9d44a66b889efcd435408d7e2eb2f48e03d4d0c9f8026e54d6efdcc63c48ad1d87c722d2db6da4a43a47dbd6a275a747bda445b7d411effdbf7b7547ea22f4f23e99d7e5366fb78f1f65d8856f490dcbf31924a3f40c9d35e38823d2338e3fe9b7434fe6c71301b33dcf23f413967851ac1326e0cba8fdab6bd65e789b983e08af245a5446ea8bd333561ba9073412430726842d9fb23181b362876b758927f6ee7ae6b0c02c268903489131a6a66c9fa48be68898570fc1213876a0874d95aca1f577b42592224dc1f10ecfdb8654177d25cb3738a91d723436a197b8269cb874760d2c1ea068ec0228e958a2fafa7f1242af6715bfe6a91f6827d6af820453bf5a61155c1f1b2ad95c5c827b541f2a85cdc5eff3ae5591e5d8972ba344e46f7fbb3bfddc17ce99e0b4e5d014932a3b1e73a1f76cb2660a7cb1cc8645d3c65a3f5245d489d22e31680af6f1d4726f79286fdbcd800f832e5488c364167d252a9597d0f9359e832704d1d5605fa1ad4fb7f1caffeb1b107e15a69f7956d23e8481cf82f04a9b8b627f84ed5203874d5cab418fbdeb0622ca99c0a8fc577af49677cbebce4c0446681eabe1e91e13f593b3d1f1786886862e1052cd69026335747988bc11156c15f91baf4701f8aeda9cf8059190d579df9a3dbfb09cb2886a95ec7b1e6abf4ebf212e3fc5d04e6faf265c715a9997aa93beeac9ed8d00abcc9139115f3a6eca99040d5adaf650b4bf4698f720558530d667f9a009debe8514f1a3cff16d366e4665b3b198c5d0412a46080fa492a0adda87c627cd96deb67729be87eedd27fb7c0ad652251cfc4dd32436a5b96e7c7d01e59c19c54a4367aeb5039039936614aa958e5c94718f083a68485fc0b0d2a39b974155f0f2bc541272680ad663bcb6f0e984a2db027a2aff93b0943b98719ec2cd1f3a4f931b97856f2532fb9f05426ff2c1162f7588aa12b96a031508afb03f7e96d4c29e07dd15e7e7dccf9e18fea6fb33d6ee7f570ed081e28d59eae545260f2e3d51757158e090b4a03c6d6712a3a7a0a0e8c41a655a2e9bf59a1663def68a8696ff0d384843689718d98aacb6b1bbe1d742e3f2d46b7505951b4ea5fb8f7bb633f5ee1ef540b892cfceb7a75cc801a2c60c9f994fc7719415ad8950165c72a713056a240d04f1d88f9b4eab542dfe470857934c4d31a80e5256ea3026af56884f6869b0e1a6d7916a72c16185135eb6a15ec36c83a178f734c183b58f20c0fdd7b695a41d5e6eb4d8d8ebc79ccdf95a97c0506a8533399770ff4f7596053c57c25c726c9a5502929b97edb0c852204e7b0eff28e63a9d936943755c15274f133c5b684276895fd1fdc9c11a12d4fefef390738aa21a670cdd778b73245b6e6caa2beee483a1e6bcd81ef46186baa5fa6cede2c186e768d7cd5db4a36c504fa7272577dc5ed22fc2b0ea4a1f316a02b9cb0b6b197114e30c960cc5d39deff428b0d09a5e91c48858854115b4d0ba829e8e20d2122034e32a049548cdd8921ed5868e0dee583ac4f4726bf42f26652c4c2c4caf83d00aca485c819a5c9fac5e27f7a9389185aaa2ad30ba847c766609ae11f8bc5b7719a8c3a2408bb99a6be7a4078a0f022c72921dd70c293501624b199d57115303210d21de2e7a2609866a6761320e13bc31f37f912c13179363309d181a9a9ab244a097c3c337a3a06770025e90d23c2b5b5452f2b1e6f135dab113c7bb90b1360d5084e1d3d7ce10567bd8b581b8204fe637c6d9499ce952937521a0df6aaee56200bf1658da5377ff7e853a64ccc3df00f13de9dd4b1a1f046a1ef4481fecde7b77208392867fed133fc353237c1effd05580a146a92a761cfa9c3573420c4ee1d4e07bb8d777f242e0ecdd58cc4692a87f0dc68c25db1784aefc376292b5c45a874de58f082b7df48229d941aa0b758408d06d468bda65419d9dfbad643c1d21b68678b8c998dc4edb780cc932ca39d244ffc2b09e24ff087d6a6743683123ba1e1b81df34ff0dc8e097156b6625ab7b850ffa222e8c9ba68a4d93a11ccc18c643577a9ea43176821f35d99bc6b8046ab5100b8d8b10bd1d0928be8a1539d8171607fc0a2e4d020c18bbee624e1af756c07b6b6d1ee557e18408937124691e30d87bbba24ffafe7235c008a976edc229da38233324313615f8762af3bbd0bd7a6848ca2f5843446caab06c03c98da2b5b6e48f23843cf03e629c20434d349958c1eca661ebc15f832272b96f9a5069d7299402bd8ecad6fc903a6586440719110914b8f5fc77a65d4e660e19c73a48c9c8e2ce0760e09a8655f0da7e36f3e75b3aa6d3b49087f36abc8adfea1b4b7ce1c5117377aa553c892dda17a302fe20ece29ba6830478ac295c04b78709213f371a7eabb2150c69d3dc3188bbbb3ef47e7e5cb61ef69f25a2e76f21b2d2ad53fa020496978fa72157e2f07111b1c511c69bdcab323e76dff374d06c8224c45d648ab7f5ab21b7441aeaa9ebd0051d86ee56de7f16830fb58ce8308b6ab9353b79311e68181c9ed629375aaae435b2594ec49044e9553bcf079eedbb442b075eb726af7f5b7afdd3f8ccd72e7b9618c496f421c0b426b3be09a8700126146d577094e31f81702632e7a03f000277050d1fb54bfb979d49deb4167a6f2cde641353b5b8a4f52970ef3c4065ab04cf1200a731c95048dabe0e03e1f23ce9069160a495db60543421c9242e7023f22397edd110d98b3c175ddd758dfb3be89f74122eb0cb0e4b9f91367c57a8e232b2a283cc0ef2f72bb64916dcacc957aaf97ef19e090b75fd28227de0c932024e2d5fb69163a051fabd98ad73632fa0642a3ba3b242ce40a23f8e08ff21af5564a7586e270818dade568932e79d874c4280ea320f4fa4382da8e3c79677aa3f9004a75b69d929abd79f2a41d17d4db1913979c319e25d32c23643b6a28ec170e4cbae430d9fa1274ab92665586c23f7389adc3f4f5b941057c443d83d3341f0834a69d443fada0c5524ea90da4047bf62d0dd11b3b7ae928092f102b6d58a34add001971f2d6e5ea9c87ad3946bbe0f4dfa5b3ded2c15e9bcea2b03eee3fd4cb9ee71b3153cb2f1e28859fd135885c13a35397581a01dc84c1e6239c4279fdcd2b7ee92b053acdbd78b22feb5d51adde43b04c7cfd2f1c4a9ddfe771762027a1702160b6c5a5e7eebbb89a43832d2cd1fcc6ec0903286da3a658b043aa09e4bda629ae3eb1493e0201034ff7a31e338f8989b0b568dbf845651bc21637be02bfcedc3f3b946def618c2e469cef8f4d682f82f17c7cecf48b5838db5cb4ef2341a35754d4f3a76141632a3d2509167c0a6dd2abbf5c10cf4a2ea5266e2fa62b106d18e3bde5944c8e4cf38f1b025751782e5d855cbd36aaa28ed7ce3cfbef83c0abe187ba8d12f085e7fc9723ab3d105942929048fdf09f7fa9cef009cc90b165b055eb9e645b9649a53629445d9ebed3e7c2ad8f71f453d34d900eb4aa8323b63c51e15fe4f1455b379804521c5107b39639f1aeba1a43d2e734b40e1c19f53979507232d6133cb0f5306e8078d2bbed8ca84b4c546041604b56f734c88678cbb2b5cd3029d4e9bcdeda722fd41a1af00fbe7d19db1c77ae9ce500fb8bd307967ef49c7ddd2b2805fd20eefe2eb35ed4c95ba04dd705260b46875f6de2e707f75d94a81d6384278f51c14548b278be4de7ca7686ae723fe765dba0ba39c25c86cc8e5023dca18097594f759f0bfbba2d9c87895cd6497b4dbe48adb8b4502971ad2c165194b4bced56548d06817737126dff69702a29421355095834964f685b20b3be23a8bdcd5efc6949833cf7b181bd10a5345a13f006d642343011ef025d5c0b6dd9cf84f2796dc6f12165b1e3bafc533d3024b61d332fbc5c799e1c42f9d13c882aa1be59a7b597e5bd8f1edc81464d6f6bd4b10f73f8f766cb31fcb3b1442348f678f3cc89f262548ec86c44bd2fe6c589ebed29da6cd5f447dba6d9a64cac6fb0717f12d7db0ec1bae0d3206b4ed5e4704163b6300fc360b9856323d53dc479d0b1ba42d30b29d2fde2c780c57054fd9c547ed67be26dd71611fd8c413dddde84cc75f8001177a631b0da2b81e0815db9c4ea78c4d5299df1a170a26e8bbd5a85a141bb6c7a6f71e21a34f09e3916ac22cc6aa99946b56367c4ffc33726c9674965b1f872de89e7319c36e94b9b336e34159f6d77bde28a70a718ca71dd528a2928cf67eb6f3667bf5d39b24abedba78a65f827222a7c141623c98e22c0b14e0828f4986d034d82f7267edf2d2c06ae37c9069dd82af39b6213b6685e14fac71998460dd9adb93ab1d782240e736366bdfc48ff1dbcbdae169bf9f3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
