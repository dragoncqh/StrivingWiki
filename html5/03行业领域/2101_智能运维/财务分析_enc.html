<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2fbd0ba75ad6b4129a8433bd000624bb65586308bb4f12b63f21bd0cf0541e56ab949a98a28bda484e43fb81436eb2752794dd73cb75054e496d8ee1d294edbf64a5bdbe0eab1c0eb0e76e410238d7fd7f053aaf30b28d3c45f2e928e613b912d4ab083f0ce15466533fd3da2f316804ad33d98feef7f18d4f43553da9a0b9af2a9011038adcae38f3e4b7ad9f1d35a6b9f29fd7bba33c207023186a841890228f30fdd4ccbfb1bed866b61356a074329454eca42a4f3599821dbab6836208259292148a1c16f251ef0d6547c595f4c9e2476caa6621244933898997f2ef27b3d45270e6df8718a6ac55ba038e6cdaeeca05dd6e989973bf98798aeaaeec3eb5d2a9982136b37c33634510d4c856fa7e0c642cf26c8a537a79a847e1a821f18e5a35956bdc8e95a1fa7cfa8fb5df4b699b5e0adbed7ce0e0d501e45bedc90ad47d43ae7b672f517776b161cba705414a4b8bdb3542df92eaf42e7dafa7fc8113a85945c8ca20544b62cef61ea1c1abdb38b3317d5f17274ab762aaa73fd12e1436392bec5a40f82d8a2e70dfa19d10b417f9bb3ef1e402ba640d4b07096c3665183fe3df88e6035ffeccf7cc0aeeee81206b6278382fb6c860c7f37aa4ade0a1258a6d402da74c6abec5a94c36bde51600241c56cb56eef084e236eb7fb93ba12f471d6a8910b46a7b97419b9efc2deb7c0e375fe600d9c753d04cdafcaba7c4d278dbe9611122f4f79cc432295504be9b07df0e4b1e8fbcbebe0e3149e1bb8995a62f6fad1b2d43e46aa10ca37f1a5b9ca3d5de05b8d173b6ef92bd965661142cd8bb3618ab63eebf0000400b8e06a575127dfdf813dabe57dd09d5c9758014331b125ce1fcce8fb49d61ad6a2064d17951ef4abd9412fed36772a968a9032e697cec922ead558a22a5309eefd95306051a84bf7be0abebfd52d5219a270a4dd146604c58d6807f1e041fdf8377ec565c82f224f500ae8eb61d20f208556d20b80a439b8e9301b860b2d9e3af4904fd323b771778a8539404ceff7d2be14865ce54721cfc232c56980dcb8209256538f981eeebc191ffc2a93dd004ca501ec23afc182715791d15fb056f92de2c53083f1f96a17f622d324381481a2080be9f9648eb50b860b55c485d9fb4c12ff823b6fb2d5c66c563b77ca9971e3d03245b2144ccb79587edf1952f44596f330263a1be1ff0b0edea87a6683239fee33018331a0c056c3559f669bc3b23ad2db189af2f322d5b04c38bd978abb159c191bb800921f9ac476fb23771f2177667b68d1b5a5a4064d218102887c0728af7ff78bfbd4d0b9c87f752138113b1aeaf96c0a4c12e55c2a589bfd6c8119ee52a79a30cb1db7c6861f0ddcbeec175062ed175bc40d1f7f4851367421636287abf167b028b53f5dc33139828710eb37d6cccbce0092ebaef4cd00a168f0716f051c9db8f66fcab8c0473911bf553aa5af06be2fcd3d8120b3028ccebbb6ec0a7064ec6c3ba1aac5db16e3f6253a4c11c4c57862b30c9c786081fbddf2e6c9c65c036157fc421b129c25b4f72c22f93fd8f383d4769c1c01e2c3ea1c23b2d6dff5de9b2331884d507ef817b20f22db1404523047fb77182efac805b9c12bd07c96418dfbef3892c59653b7f311a200601bdeeac63bb570c6a9af0e274d62e7239e8320f9afdc36ad05551207facb5f1e4ea79e11a579f15157581d0a268c5052a95868a6a8cc5ee2790f8f6ea544c2dfca683b5053cbb618005653901f00a276a8265db5993efc706fd82c453239a1e7b820583a7c6bc6cee1fe6ab6ada96c5870c732b31bd7426b1384c8a80edbe2f3dae005431d1fcedf85e174f19796f3ad43f29b4353dfefb101242d4a77641bdb1e3430f9b57241fec1d47fee46114f1df7b306c16313cf0ed0208eb02cbca170f906db347788bacb9979a0e0a78046e71d946e547df5e2b610f6878cdac1ddc4b27338c8cd84e4a591ec298085033f48570bedd68269bbd7328acef98dee27bc023f31e668f1624d1d09e30272d285ff733e3a9de7e078628787f77b067bf09992a3efd1b3e52ab536edfa0bf87cb4a2cc9d62353e7ef9f1bf79e8452a43ef6f6e79643143926730a1f821c0bc69e8845ee0119e053d7b1cc658d3a7206f16ac52c1930462ca777701ded24c063727a381952b5972540e6efda8b777b8abdfc5105166b13ad9648aebb6f1e623d1c2b117b3ab30f4afc2cef04849aa5b1a907ef2bb0e184bbdf90b04f6669eaadb65337690d4bb493c5adbd0cafbde51556352af367aa6995bac71ff5fe362903c6b469bfcba57c7ce4a35a2e3be3230a762d98d8640f63b9d25533f47dea5414fa6a92b1a7c056a52387bfef141f13f7a575c53906b5cd1cddb4d787e89c23d7fde2e7540aef0a14fdc6fc3444190232b6d7f8238a86fd42034a9ba27ba467df1e3f5c1ced8cd760f5aeb557baa6446068158768c2f70b6f5c5c442fec93244cd9c1737fb4ba49c15050948dd5fcdd5385a18390f923e1bb187d21f623d1092a4f5106345133660874d672b64884a3bc93b5b6da84dfc7045406b21f68591d5b3918a769cadc9bd8a7705ba08746047db5a53c50ec2375fa7a9e1aaab3afdbeb21c11f24aa52dcc9acd65ad49d4b2c2d9a70267f48c336d24d0d610e1cd45c21879ed943108b97180b71b055ce00dea3736d2205f04567fddd2c8ee66ecfe46d13967ff35873adafc0ec085f5edad73240bbeb8f060031a82f645ddeb24c410031c9df02bc32486477adbef58f68b3aedda4711bd688527029bd4bc5054ca528732d45bdc24c7f6806fe358d3147bab03bea48cb79dddcfa0daf9dd7913b1ce85095b196cbf9313ecba8ba1201e7dabc2e1e6a70627022d1168d44ea0b59842b602f578bcf99721c65592c3929ed1682c754aa60eca7d7e4b96e6364af10d90e915d5ec0954346ead82c4f8ed1ae4384307a9defc7dd81cc1fa5e33084ef95d146580c0baefd56d291432bd6728010f31e2357fd4ed109238d09bf51affc2f4ff16147bfc19f50d04da7f2cbbe67939f9b650452fb8da93817285d91c2f2c55b79c2a035d049678e395ee78014f3b2b9c7855cadc5010ccc8d717107708667e7026b5063d2f70e9bce33bfec76204966cdcaacb1ff7f197a5cd9cf56605f40c87669d9add5c694c0b76180c712c48f26193629ea6a312845be386d4fb7948c2d009953c5c8b4a3a27dd8e693ae23c06778862e67da7ef74fa8b49371ef694dfc021363188c3f94c3c43317b49630feaf7ae83d4ca59437541b1f7fb1c3832551488f03187ccc031e0aa17c36084fbd067f7047c93f8e7befb6515b9e0beeed36d203b74cc1bf42985d0f5a1977f0529925fc264f11c1783ad340ece6efb07c3e8b2f2d65368215a2e51a8d950f4eed46227e6c722574904f9b5dc606ee5ffe2e9d25acfc3c46f8d2f7b2936db9d8fc82da02f0a7ed30f0eb9facc4db4ad8a8c63c9badb3ec71751a6f9c46871b3ae4a084a1cb97bf2a2ee0d29c844179bcffba02d58a5194a69e2793e683cc54f8a64e168242d1914ea74396761e664e6b7f28052a83f4e674d5cbac5e9d20418dd35d5f55c056ac6c8795513446155520e7508ed04a254ab50b4e756881720a12ae802611193e22df7f850c1b3292ac51253519b2fe125b70ede8718b8de45acfefb2b8b1e0ca377cdfc382994e33368b07e8fb669deacc7d58b1d6a4ab329f4bee1a38f41383adcd4ab64e658a843c5aafc9d954b250d178f2527a6935a35b9a31546bcd5377d7376ec8758193556718df5923d83b4d39b5bf004d8a177040c047e9798fa85e2869376ce98f700e88d86d37d72359149ecf63950a081a523f91dcd2897d59ab86b8a9b73d06bbc2598367a5f81064ef682ea1113565372e8e792d3b0562e07a9b16887aaac0f6ada50767c8163c1b73ee3a1d28df222048c4a936f42c39ed219245d634ae1557b8d42ccee3f333e6f09370eb7045d1779b8ce2b5b08c0af8224daf3ea01a099f93f830a132b4026ce505817f55320bc92d7ac51c647695b24cf058f15b6e6ea573ab1cf761b47640e53eaa12ee8f0cd6a99eb3ea772987328496e3cd6e0762222b3c26b039aae8f249355b5d672c85e10cb6f6cbd29b9c3e7b1adfa00c033a1ab7e1c199b2e4823a64e2b9c338f7265dcfdf146e7c6b6505b3a49af5fa63cc00f9ab18e84f8bee511e3c93b792076aeec2a7ec2cbcea2ec9d1608fe9a807fdc7849c469af9b0cd7a9788db1d68fefb2c2a6e10213ca2d4176a1e97c1085c7a995aecd31950ae51f1c1af7df357bae5aaecde841027e76d70e116605d4640e4fb39e51ff10ffab3ae2022a2c689045522f26f652644f74557a34a143c39e8a150f856fbcdaca232cc2fd5b90cf765b1d258df85ab3133c6bd200df6e8fb4cd96cf69fc8b5ac872139be8cc05ba5b3d261aa620b1089c89927f1109e2c775f01fc671df85410c87286773f06d19c921b652dcbf674a5ff63f015583e931065732e4b92ab6a413e00667c7d96faee6d3b95bbcd632c1faa086d9c85c1fa3e2414fb44fd86575aebfee316fa88a8031ac930127aec7c653a59ed88b72d9b48c47103755d026d7defb7eaef7ec5da242e8fc75232d11a740b231e8cf631894e75087349391d5e514f5fa4603302aee279415c520a4209b1210bce6c9e318b486c07f4f5fd9c49710ce08004ed8df47a3272f0aeb100603e03cee7bb151b53e85d5f99a246c33408271d18367b2d45216c230b5f4d020d4443a1ec843cf71f8b28972d9f2324cac4f0442dd42ee13607c581afea7d2385bb365954b6bd8cb830b2877f96a3d47c1014d6538100d2f8109c13d45d458e9d92592c16e4a68675ab033a27f6c613d92a56abcd1c41baf5db648852e565988e098b45c2452d56c0cbce610e3debfb0c51a1e02b5a60c8f509f385bdce332464194ba858033c0dd326930b41697eb4a76ed7b5c97f243ba2496f6a0136cc081171181fe37bc98a20e6266a3805042ed30b4c345cf77f337ca562d938bb3d0a9669fe777af6bcd1b06ec95bc0170c2531cc9646cac20f0f64cc531a3f883866a582b723be7243bcbb7b14e9c5133995e5635b45060da37b2c453c71368adb2da630671ec789a1ea88736a88fe425cf9e3d3f8dbf526e85a67fb55d2c3bbeea12e4c2d94b8a6686ab268bdae7321f05691e06c118cc624cbaa6ab39ac5c84ed419532a8f41ddfebb001f38f75c8df355276be582eb030335f9a7f039bec22769d48a9021f70cd3c48d29de257186bc9a3f8822f328d4024d31ff41486cd5370ece9e829f2d29c2d63c5bee5631da676a985c2913529de5ef6582aff81658b54f78068547511df9b40a5f80ff9b51a3ab89bb2a4ff12d452e240fb10d9c6b03aa0d787d5b65db6f1f1b4757267ae0c35909a028c0ac5e2c95e0477b7ae94898501052ee6705075fdb61d0e375996f453b20ed9871ad5ded6ab22965d259ee2e3db85d8f348b691cd2b5f4d83fc2573c3cc23f440afb56267f7cc7a4c3475c3d320a0504e5cc4325d2765783942088283dec83eb6b73777fcf016ebe07093177c03a9338d6eb57a92087ca452d30dc0f69d7da4a03517c94d1451887398100b9198d696c275c2afc9cd7f1fffd574b9113b13fa46383d8b142599454f95d092194c45e935e976511c83b7935dfa9b642a53c822ef7c6f74f1d33f0f507bc0cdbfd8dc1f3c052216192661babb7eba28c97f042f1a8bddeb566b96e15b83be215ab424b35393784e9d8d24d27d986aea345b7ad8c00d8ec811108fd1b2cccba9785803b6952baa422301ea48320488bf60b8210eb6e3fcb12f218aa32907f62fffa557fc22abab97becb4426e85aa768a781cc33181e965c1c6031852aadaf8b8849df8241e76cbbf87d7055addcf5114db921b27989c8c61d1e72ad22ede048135da1c42f5c5a96cfcb2b0829059ca2ada1f8cdb35c09560995ab939aa4dae66d389057688afc271ef94fa9021620fc9fc362f7982eff54a8f5dc397e31a0ee297dee41f75a93be29275b628b0b19f690ce8430eac900c4d872b16bdb30db8d655118a57bda58c49ca2bfa08dfe55ba279c69ba8fceefe50a99f2e111d36c28e8c2eaa3536be9e77a46db96dd36d6c5712f7ca151169344c957556f7da50c5bf2229da5e6b32852ae3ff9723f1eed18d9195f538bc31e31ced6403f5a3867243da2454737ffd42aabb8bafcadd8fb06152b658969dbffa534920de9fe8b9131b2cf2e278360e3d8c07f9c98ba7838d7871577790c3f2df99eeb41fac0efb4b1abd1f5d27510be30edf73398648c7d38d38f5bfa53c45c725be7c77af238b67141d959c9caccd5e53d3111ed35e41d919ad891f6df79870882c9f646ab4a0bc1a8e473a4cbade4c1fb5e359c9805ef1df3b4eb0121b26b38e0e42e80472cb1219f63a35add7e72f0d18823efac2f3eda87e1654ab76d04d688218c9b0c4d439c370e798954f447b13a2dc806e18c82591d49efde8b56d09485770ce1bb80f23495aa546f81f39c00836008e125d5ca8a0c914a49eca2a021605a9823811796cc4066477581b0dd08abb96e1e466ce20a1e6ee753083f29617a97ce6e19dc55cbaa2a9313a128b0dcd937f0fbcfc4ae42228f4ce32569904183adad3e524b0cd86983a8d3deba4bece4dad4698c1ef136ab6d27f0c00721dc3f3c1178b03e1739333b0523c418f0345e425eeea01c950b95895d0877c714f8eed0774d76b91afa210f3be7876371494a828f1be97fa9468bf192c4c041f590afd22aaf9d0072350c247972b47a1d1ded0017d86d75505e233cf228a7cb72e367417d04e51f652895f69ffa2764721eb68d773fbad1aab2d38f1d25ff96128f2bb9c4353ed757d3587e4667c7cf85578e72d98b99b74eade1177c365938e845abaa499095c1f89b090cbbb39648508e7f2bc6a66f01ec576bae4e60762945d8655c68c781e6852492f9a48b16a6a84d94459e3f78a14e14b75e7e41cb8da756a5d03a60d25df8b80a1692a1293972dce7c55497e8390142330f98457cb0b21985fb03862324df95c744d057c40a44621f52b44861cf8bff226393ff0e3981ea94a8c9af164b1b0450c7409382d04eadbaffa0c4ffbac6303fb9af0381fc314fdef8120c1cedaa83f5e899a3f482cec3cd70b8741099785eab2c330c8a8ee1174ba43a7615e47bac32ff814c50e3843265e68abe18118005132378cf3a341f5b6ca9bf841e1cf58383a532977b1bb67d1f23847031a99b23beb2b0442132617eaac0d97cc1e9e5acf11490b241106dcd1f182ef31314af90e4014699b90791c9bf33726d37cc34b7ecf8038ce0a8f7c2b5428b3e658772ad44c6410e681b08ba8a729cd997f9845fef6c2a412fbfcc0fe6701a1a9d330f6f2ee74d2bfaf76c936a4ce32c1b90df47dba16650eb8e9b5a2bc0e631dedfd6f1176adf7db8e1d79b715ae8d2b9b4325f04c1402a742bd246bda8bb69dd9e1377b10e126d049afa34c5be767ce82b910c3f806788059908e76c22e8c01b2ddb5c4d338c133d25c303a772809ab664aee44090173f8be409017804c1c524525b7988c91da15bae029319a7ec7c855ad86e479130b21f249252432410d157eb73ca2ed5191b241615b9afd7c6993e1f00744a50167aec00663947ca443c4f4a837c463728a19772ac7279d334182457cf417e37956cb65c9a09316dabe5ccbe421ab5bb1df9b73d5f7cbc3a75a8fd5dfe7c01983e2465724bee1d90f9bd98834c44857a70f106f329d19b13ef0847e4db120094d152a8b75811496a163383aed94c9e3427c76d6c5e2f2506c172153ff3dc31b2b0785b2bd7eab429228f0ff2ca050dfb7393bd389eb24027fada6e247d9cdc9cba708e9528a3539a755ee67116bc467c1381ab5a03f45216f5a00c8f65d9ab8f6073e73bb1cf0dcf3173d48aeae59e128e0c23379e997fe60502dd7276f35a952b6a3bba048e6dd6dd081eb94002846ceba1ac77734b8362aa1da554380229b2872d703647fe94ce126310d7fd2e2d750c2da9849c091e18c88dcb225e8013ff1758c8a8d26d178bdf2ff89bacccecd9e8206fba14293db54abb8302fa67046d85d984effb8a64094418987b08ef49eda7de46ddb1615e8556dd55602fcbfeaf7f80534c2a98697c2471d53f184dc76032f0a12fbb889d42f855a0d5f7882a9eadf5e29884d4619fe774e4b81ee082d01dcff789fd60076de33a193b4e9a9a67ab4bbd7593b10ad6ada258c67beeb425f49514c300db72ea7641dae4a20028c90bce84b7457fe1db1ac1d5415ed69aa5bbdff9aa9155a08098ffc220db9574ccfdd3584c88e91e91911664433579b75af1ecb53a7ee307445f6a14fb453fe99c84bdec4ab7197bdce6512b0e196c03afdec31b3b3ab6f73705536b3ad86c47d4e11361b06d7ba78f880d58159baff558d2b5166d910c1439efb67c901f595666bafb4c3d100fca54c3612477af8f6fb4fa80094921fdc33e7b92c7259f234632e255a2a1da6545c8ac2e2509b7cb3ea23c7cbbff854fe1fa23c4dda109cbc068048145ee8129bedd7b06f25068b546ce426579fbebbed3c40a0a20ca7809f4b1beca6dba361d3b39bfb2a33313a4dca868a7a6b6f8bfe3efaeef6850967bb7e0e9c0592d4b8209499f846dfd1a01fa21aec9120cf4524dc054a1871f60d96f36c35ea56628eb2718e3c592a2f4111703ffa733a95f3ee57aa19fed484ff05dbfb6ed94d5b1b308185cf8c0627e4c7b9369c2399302a2d775e0fef90f58d26f768fee975ad5f3942800e78ea0ce06e78599707786969455afe0c1940bbf2e9583be588489c32f1f6e115dfc22d03815eb5efc69081c4dac934d605e330f59ed304bd6279592c230ae7e0131ee1281ab7c8dd62b069c6adc12a4fe8c743cf40be83bde0ebe5a219b182c7b605c85400265d2086659e50272834d96219f2313037ee5431a1ae9dd9654b728a1523f30ddbddc8e03ad257d648e8d9062caa1086cde956acd38c10960dedd77735e4e374be9368cec8ea2a640b6bd7f2bbeba1512a9eb8ed4445454c3e205db5143025e31709fcaa4cacdc1cdf379aca124d6e8f3dc735648caba5cb61f7951960e1a629d6527078090a2c42df36b10ae9d23c3ddd8c10b0a10a68976db29c24503f63ec20ce3c669d1105ad7d15a7d375ce75515fe3c8692ea4aa8e8e283f03519f5dda738d166d0c7c004833683e09c1e4d24776a984674f8348cd07a410c44592a11edee6d0cdd98ea2736c8ef0f5e46d78fd8d891163350e4c060ed68b11edf2eb692e1411bbcf987105e6f7deb2a471658591ff67634b6a18bf91f303bca8d894238e04c385333485b9e780bc76c1e13f60fef1c71cbf444443b2fbf4df2eba27a690d082db6358d25f3af0117b80b0ed0a6a91b7bf588deaefaf329f43a1f01ea352a4b3015c738dc63a1c644bf007ddfdc273c7c9c9b98a779412dadb0272e99d5945a93361af2b2c2d950d2bc600d315ebcf2ae2ff24b86cb87f8d70ad381d442c105d0346d5eb832c820d131ac36a88529af85d0c5fd1219a4ec7b0b910c216d329ee6681ac150adc0cbf49db2d4b359786da2ee9fb2ddd59f8a55d2fc032a65943a1f13417bb74ad6aab9abdb1d59f548af699861f26e56b4d9bac44fdac860c77ac3878750e33b9959a5399a41f4de8f79eb19438ebc98cfba160f4c2fcbd071acae5a0d0c7d476d5325d5b9452d6077df1b7adbcfd8a66ac5e7cd7e168baaa22d8d18990fd344409b7fba5fd12dde5afda673599158451d454244e23475d7daae1ecf8595316fd47ffcf66a3747fa6f23a026560f12605ee41570211094df1a177ebb179a6d29833ef30b6809773c39cf57adfdf7701b1115e1242c8cd74485abaf121bf71ff0d180193ae65c93ff486cf4404a9db055c7162e212a1694db4c623a2647a9102f5480083e2c09f5d1f0faaefddbf2907171bad1257ba85a8bb5f42cd3b39ff23623bc3040bc92a18b853047b0886042d7b9de5a39e9e72da464a3eedb20680d45f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
