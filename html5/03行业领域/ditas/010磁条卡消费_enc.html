<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f9f81ad51818b4087fd04daf5101c3f04b4fd04e317fcd33344473a077a2eb72f550a24319007a798dc4b70ebcaa1b86b07fc9860a140494b5ecb9a8d79bbf1096b8282188db257c363c505265f43b18eafcb014cae4884694ea431d433714da729e0321fd49c7fb5dea00d5d2baad97147fece930eb9e9c4d2d32510f8292f69d2c872dc117e6336e46ee7431261accab237bb96fa9024f4bec381dc5ebd71d8d31d6c089621a82bb7f0363d7db45b1efba230b62d369a9775386756c132d5d948c49d9837de247b63cf2f4a44f0b99464702b4f9cde52e92fb46ecee1686c32fff606ef8c5ca609fe9889092d74f1814c475380a9ad8bf7c85d7cc0e82ce9a55e216310460c2fa1d4e7269cfd6531302569c3405b3d57a9f67369b17ba9b260ebe6e4d33da6d2af5d19ef6803048a286740c78fedf44d9baddba4eec257df8cf2935838721ea6dbbe85f411b8bc1c65a95b50ad67892d58de994cdd0ca9ee77fde08ac0d48012f8dee82ac0f7bb615adaacbe1c14d66d0dc9b6cc3e58c12f90cdc719ba46c7a3835898aed7118159c11f7f3b3a06f47da16e162cb921b5d8ba396f4eeb67b85a368a63f50b73a5a0f875763c74530b97640d6e0cc99e6d738d3f1011352b8d2baa0186b4f6c83f5cfa5442a3d27b50648b52cb1c742a3a344df245c67b425d77de3d9ba97c1369524b9eb728ae941345c83ed5ee637b0fc0e4a4eb39aea8c31f7edca7673ad82815783d2bddd414fdd02535127fefddc75e54b21d25d7c5f12921818cd9b1104c0c0627057f9894567211fde2f36b4b476fab8eeaafbf033faa96695fb6f0d3c38188e5ed6a144b70c46bf5e5f2d91fd09bce9270ebfbcdbc00032169afad3c1d13bf466987efdac48736d9b6a354ed29add66797565eed1aaa9cfbeaad5f84fc9178d26b82532f795d6e91c1205baff1e97846a2e96c8538401b8667ba4231159c95352e19616c5c237887d045358ffe2ca230f4a31b22ba7f00b8141564f1be5c3747791f2056232360e5a11b4a7f6a811d41456cc79889db9bc215191e0572a1c78ca8d6d91dbfd73b4bca41e2fa992cf566eb8ffb97dc5b397eba8513f6f80e4581ebf4785dc67ae0d30952b838785d455ff6cc33dd779fd457a819150f26f6072ab2b5b740c8145457cdf4971cd64e3573c383c9a5608248b12e9f985706d550aa752bc44dfdbdaeb35719fb955dffbf68dc46d7c66167915584c7136c6b84fd54be02e1b45f76060a3dd0c2be42e48eeb30d634d91b8643179e63d8b107e7b39a3626b37c50471d169c267ee14d6f19879b47aaec1543ed121f60b1a2c108f8a9691d9c2932a5f1585beed9758d0fbe2d87fc89366c48dc6f1507b1af4063c7078d52c9cd7725072b9cf673f50e3081a45087cb2ca30f2dea1d6a62302e2edc280f3ac4cab316b56c2e5e23d3f893e7f5089d740908a9af4cf3799a1297fdde18bfa0d4ee6f3df7a5fc155b844cf44bcc9bda7a9c1c7966fd0e9cac547b7d71629a112dadfb808d8bca67aaebb14926099dca0f3641909b45b004a3d6031d13ba0d423107bc88c93c28aed368b00d7a0d03f7efc107d0862cd2e4adcb7325ae550337e8f9783a340079ce82406de9b03ffc9bc7e7d049798cb92a25ce198a85fa5b6203a5f70cf0a9659da3aee08134aaf683baa62c83103ea4e370e10cde28f080113ad894e6fa2c1c6037ee9700b5b154dc3969222dd0b7f8ed8c1354a6a0402b70f372c8a80b00aba1e88d4084f2a0b3dc7b3be74573f111b96f3c9684dbc1547e13ac040ceb3a2182510c4d4d3331a84dfc101d29cec5951e4f4ceb6f448f47a4ca94d9d6af6469e852cc85e38ec0f8c106be0d19c965d09bc3016796c3aaa1af64cb144672b6cc57a5bc594811c4244ff349e8005ae2d8839cba09c2075713b54e7461cae2dbcddeb19a75fb960e6a4e03431400d65c23c9f5b6bb98726642806b8afc20cd53bae0ffab08f4be3de36cefd010bc3e5092c6d3809d129afe0e727b01a314eacf57b397203c23334ffd7d5b254daccf87f2e0c4a21bc476b30971928759114ef51fd0ae5a05378160d7087dbcf6f05ec3899b7d4234c97aac2f30193fdb430a32f722a83dfbba29e3738651f78a5a273cac2566d2de9ffa4d415ceff88b0e73098bf13228e0df2c8cbe4f1459c5140cb17e3c6ab781173b4871a079d9b013886763ca15a4932fc14e4fb7ba25b9518576d7b7de13000a9caced894afbeea3c2a314301c21c0160a8864652cf17856dffd8a1337300afa1a512fbfb1f9a8cde51f837c606e8ae9ad550b9e997780c73eabd24c9124410dd845dfd7f5d6d2598e857092f84f53f8226d9783a9da5c32c85ba7b5a94a778538098c1ca30504a09bcea0c9ea2031778e12d8c658ffc9e61a625a28ba893f324d6ab62fe02425263868171e685070cd05de9636dda6909e77ff0796072df145c52d265709eab69748e5a259ad0f44f143aa8a4a7e947551c99b25a31685e61557af2f2981f883286b71cec0dd5ea7c56d06eff601e62c7a9f5cbaaaf0ec1b0c8e0c88815b14a8a757150e1da68db0d28385ef7530faf3c2df9c02859037a239f567a097a48be80f158eed2154ceb214d49ebee87f535c0a93a5b46b2d865d8f64e0a12145404790303158f083f2ddbd1790dc4dddca8ae80778eb5f645d062f9ffde52779c60f2772797ef93355ad8e95d82a573e23ee223082d51c834664573ef97f315c58b9b98eb0507aab7afc1e41eb101a41064fbff20c8e47b484fef4bbc3e1a5c6e086832024f2cfb662e2176780654bcff6cac0f49a44aab77ecd7741697091162d6714c03d22b325de392b4fadc7eac3f174429d88a5f8ace2185194526705d0c1e8f4327ec5363f72448a2218a81f7283fe464be7be3567bea2bbc62494f5c7ba9aced063470901cef3831f15575488b84ea98d699001a3eaad8ebb7737a61cb6fe420819d988169e188863367ed866e5b2793f52467da7cfffce6b5b5008ffde8a66acd1d704e703457c18b9c3d73d061329a8dd1d65f3905a7af674c3de81294148eb04924a2408e9e81d94770364692519da0e5c937986c9065f37d16409daea8e625fe82be76dcecf831412436c19e0c62e95538fe0f0b568dc7b168ceb95c559e3e3d380bd6e4a1282ea197662b6a7bea1ccad2a0b66e122e0701629531847ca5608cabdfe07818923b2831bb1e29161e822958f14e650d2febb348b1d498a524062d632a5b301ea5698fb3676d1af886e9c6f76d22d7e3db687335868142d3c0625ea90b0059f72d62cbd9bf6737fc045ae88f230d5141b92a218cbb9a68351044c40650e902e9397107921c354bcbb02b65af9c2e487cdd7d98ef50e25c0889b78404c93f66d0b2d7ca07a21ca4110dba8aa811dffabcf95cb884998436b4489156eefd6da3d23de7916fb0d075c1ed41e7940f6c80f09521acef96c4727a2c99e5f1d304f0bb6358395ad1d5349ad60db07efecef2df71327b9ad8e0f886f2b7fa7a8259c551873fec1110ba1b3a1735e4bcd8df0007abc1e3e7a6e8a42227758a708d4a87de2b3da0d912f34219b6427358d5101592af28ead90f32031392439e90621e0126c1b789d5b79fdf2d311ada66810139303e7d81d60e9b9ba78d95fb90bc1c4268412350f35d69d1dc4475cebdb5165490d96ea39802724690c3a25d2c77f4660a5886409113597b8e88e714dd0a632d1bf1072f214cd0046d1b705a9ecc66d4ad0234cf16075e3b4e5e981fe03f514d120e7862ec646d37cf6f125a9f3f35880eaf515bde6556731df6b21b9a70190586f5f1f8b759e54387141753198d22e53ee5c3a1a58e4dc356b37140199dc42ed038415e9bbd8ed54cc8e1b280f800f80aa77b66e1791a89d6798da46c0fbe7715f507495fe6cb8205ffdb6e0599be0f6dd2526774d1c1dfb950fc960ae8a4f84ae51405c624b966994bbe9db826c09df7a6788503432e8f6b7f3dcd0a19ba1f64c380ae77c161ee737e7578dd0e26ec841e3872c93622ce023d2d83bbc394f78c09bb01cfc9306e13db5603bfedf2c8a2caa95a5f238edd4442224ed9d479d602f79ce0dae59b3fbd7ee8affbc49c8dfd547554d2e4501d4e03f4129ebd36e0e85cdafd39a30709c97310900f9b7c4b00397f9551ea54ed1e964a2cd19e37596ef567e3948f0e65cd724624b3993d6d8f6c8d96405665fc171eca7d7e39063fb6b42ab19f3420dae27dc30937eb5c71111245c04cea87c02c8ba0ccbdfab16790d78830be47270c0cc1568babef9cf84719cfa17a9832896379105f670322d3c072904a60f76bddada7f5a594ceb8788a147887d5b1e7cd1efcc638cafb8d02cd0b359394ad295f6a7641e717ca7c24b41475ca6f89fac10ba1a02d6b562b9d85d5b1d2ea8ed147da68d62d6ef282a49ebd712fa96fcb46c0a8a0e6fd413754479b147970f6f0128645d191b1b9889121705a4b30451a4c96843c5c10ed437d6bee2906fd321984cc1c0ccd676cf516f62069e897a5f09b7228fe6cbaf174598b7f0865447d761b5cdf6fc2c9098489b2c09ae2d457cdafd2b5f82b9d51ac65bd504e47941c30a14548e13f0ea3e2cab64191492a283a80152b1c777e2e0f727f4dcb5977e34b58d82407d5ef4f0f8068f3317751f75f02da45fbc6f302ec0106485cc45576eb2715021c6ae4570e28b27125f9b6a842846561a693b926c411695df58f88d9b64f4034f176351bc8e3d1c91226b59c13ea338b757d95bae045ef5b2b7521e5c17bf01b213a1cfdd1a111fa14a3a8cda9d50c36ad7ca5e87130608f34c3c94bded8b0c9bec73219ffca3cf47a1c351ab2c73f60a5aab8458b9b63537230136e31ec6ff8e6d65f577d9482e4ee79dfe908436b096a04a7baa6b664a2786cdd6f54ae5922a82b382c5b4b088cbdc0eb373a0113a1ee03f7af8eada934205a69484fc4ef2023371abddd7e674a00b81d7b14afd22aeb36801667c0183a7c336ed7ee7c53e7bf8f000a5a78acd65d8cd679ae57fd4fbd08f0168610dd8cf761253cba12a783f4c14d8dd9fad5204802287fc8eac3fa948e534bc511a7fd7fec9d54f14d6ae91c92a2eb899fe4f7133bcc5ab503e9fe7a85c04c9dc6d490ed169fd0073a3b8df2ce131441feb1af8ab3db921415f985488d8deab6b346a4cb197e1de7c49f1b5ec9be32c0a79f1452d3433ba67982a2dad4f5111db512aa4a0b5bbc76de6b150e5d6070b8c574e183e241c476519ccc871d4b073cb52c365cf5fc67c3c616fb47bbcf2c41489e73feb85f7e167716ee950e3340653100d8392dbc795eed3510aa9aff52e34e3de8027d2329e9d86a040433d459e16111f1ed99bcfc024d38b3930a8019ad390c9e8f3d8cfeffb6bc16c2b8502dce6b44f2bca48334265ba1e854824a86ff8fd421bf73d8c63208132584a293d2a725a7d9baeb7614069af5faabd0a0bd8a6b630ff67701909e335ab69164ca6035a5e3acfad7a7dc503ef90f717d5fbab15645cbcecb6ab12110e8fd71ce8a3a06d77ccc93895684f3861d12d2469ed4afb7b5a56ff1601a3a3658ac091482045fbf93a948444095c4683958da5c3fc1868c877f711d3c6c8f7d1252dcd4018d5fd0b83c84c7bb2aeb05973a4f9df8597026f7b59325791e238e7a671e37921ce917f07d3fc84a388f05b3f38e353bd97a63f7e22ff6b61ee51aa0bd2ed2ae61f5a7cf0a94286c2d564f61d61ea9fbbac1fa5d1f72a3c86dd628930d99429545b210e1f6e804d5045b240962c4e8222d69c103ef96844e112ae4470c1bb7d48db75e281e408028ae111b2ac524c548d2d54e8c89d1da628d0705730dd69828bb5eff9be30e3e4171a0c93a9cfa13d069633718cf8b2a85f5c9daa6f55e64ed9440461525bb878c115d376da82827614562b39056325624c609e0818451a9bce7b2c0cb6bb4412dbeb7235522ddbbedd7328ae3dd5255261a3fc7acc82b01644650211067bffba5da98195bc473379947edae4b25ee1707c54906bdc5cc8474e308f48ccb14932d8ef27f9afd924c8e0b2bcce688c3098780c0fbc754dfe5128766d6587742efc5e4aa1769a8cdd1e6356fe75e1853c56fee64ae2342e2e3cb6a5b14839121d1c088a88e98f6eb3929daa9ff43cb6765b99210858a7768f43deef800e247aea043582cd063108033d3d08dfaa6d024a3bebf617259e31a2bf0274ab87bfce5a216531cd4c4ce6ee2f556d3bb1bfaaf73dbe80bc387175ad7820cd8534727570bfbef5863ac33f2d73a4eb1caf2476ede58ec077495fd3be6edf55497df40a142a543c633061b24eb2a74f0b092bb7731e1b8415352d11c6137e4c5d0e5073459907104bf39951f19bf9493ad2a929fcd4c61ccc1ca30c44613fd46fd008e09126d6950e806c931dd116ecc48bb70cac24377d55b74957a5dc94c74e0ca23ec81eec4e5143cd9e10112f4d1aa51aad0ab689a25e7e4513afba20af922e8464b56888f5cb84d01272378fa3626f73c67143e022e2a65f9723e918494afc12c49ecc967cb59865ff4e6e36f5815d64c57ea7e856da1b7a46026d2c8a555590422e3760f5b25a050de2f0ce21813419f6f34cedc2ec8d9f3588eda9690e272e05ffbff3f4f45ee1894e79b94677b954d850f50d639c14490f9287880c3f4a86cae6e0a48a2e84217f9683bd2bac549dcd335085af987ffad1402a7fabdb6a545cda9a2a9f0d026137ea520f7a2b6db8e6f64aa1d009496a84973924fae87c1caf277857551bea497f4c274cfa8547af989e65b9e8f57ea9d7f9c0fa3356bbfc374e72062d8448203a2ccbe1e62cfc993c1b93811a3eebda92184aea3b8dfc26ae880aea135b0f0d58544a3744822ec3d0e06b12336eaff5a8c7fc6de904a30ee090767e3d1bc9927d9df27615e92fdd2fbc960bd6cbc98fbcc0df05cc421dcf06459cb6ce8174028d7ff4d2d56b937ad4b6878911e81c2dce1186dc8caf8e3d60d68823198b72ae03bd22e0807210dcbfd9a61e21c6bcd690a6ea4cd6fce366469f4b1d7bde02c3f93be8d82c6a7b31cc8b400a62502ada1b26c2a311779cd1c79345edff90384ee0bb0b8c2ab248d4e406f86d19712a3dfd46ed4de43da6c1838328d82a7303f1b6dd0a8bfefa98dd2644d08403063230a04c00ac53fbc32431385a7b9c6d2dcd6913659b5f501c499418d2121d82e32769a1070acea8153c6395e969616f010d5a5175530a60d3250bebfd6a11a07d722912ac36adf00fdbfe37a40675c661ab722fe4beef4abd724f92dd08d51f39c0bf761cddcb0521f49bff1477772c8d37b64ad4d46fc33a52aff6cc6a35e1b501501854f274c38b4099ef0c262eaf8046c5bb4e083eb6e4e9ec727b87a7833f10e3625f5c0517af47ca5e3bbffc0f043b8cba27ff210c0ae1808ba48796e1abb5847cb9b4f78013b24ce3b1fbb5db2df457998c952fa373c32192d00b241482bebd41b62839e6b7c5dc7e08d0208532e4ba7f59e3cc47149eb03c90864a65377b11c1b29855fd494240808c72de76576b2f14ba71be70a4d08b9e405d13c7f457ed0c4e3d0ab6eaae3413df2b8c2a9a7ae77ad037af0e8590b946f28f9c2b971b95881c1767710204cb43da196ce8f341f48e8102ad06de8314e124b98c515550f84dd49c16503c9c3a57ec48fd8d96410506ce3aaf170c33977c5626faa1f7711812c18d853a276a80ee3fb812de86e5d71889a455592a722e446df9044b43d3b759b512615ddb608b9f7f9cb2dbc055b278afa625b7de8ce9174c549f62bbaa17ffb5b71cb37f48fbfcd4a21fe5c46af403209f3616e6110478b88975087277ce2360f818c5140d6e08dac681a19b3937ccd6ec0ab82a96b494ba47b126457ab6e80a4f0de4a1fc8c6820fcf699f83556c8b2530b1bcdb94449e8f2daa691d779c3f30cb3555b7c2e8355b899dc6e1be3008262e6a22b71ef7bcca162c25bdde85bd0046f3ea5f0ab0b20c583932d4141180acaed838bc21424f6916e2acc565f075e38fb4ff4e8f52601c44fa862485c831f53f5ff560290a344bb0f9258c692e1fd2e8eedab8de54ff1b1274ab31ece814fc826eddd94593f29bd3977f2726c214fb892b33d06d6968c625fa51b164298fecc457eb8768454be75ac1c84f6aad4130f119a7054b6f6fd8148a66c46037729640b4f0ecd2e58f9093eab42c1473fd046432c6c651b4d97f9707bff79f43fdc93e0afb95d1eb1a324b1e4a031d1f4c27c7703aff87270e0de9c826bbcc93a8503f95e4f377687e2bc1afc4ed4486108d2342f29b028e9df24f45be6eb3caffde47ebd80f70a7ec4d46648162aeebc093de158ee411d623870ae9885e4dff888bb32f619455e9bfba4a254c6a773b0c8c7a2ad984ecbb42400e477e9cf89e712a4f1882d28198512802429f9cb9fba265d67512315a5c78f4b0dcecda3de41094ec4d9a513c1d0a1283db06870590d5eedb7826e93f662ccb3db72d8557f5b5ee22346a4ed9855a760b763468d3990b60bfd83fd90c416de028c1efbacdf06be96f06a3e20d7a82cef2acf1ebdf909d1a60c9aaa8c4e85812044b915cac4ec6b4d1e71c5b6e746533577082364d18a356f03f18a2012ca0d3d5f4f2ec664e86eb2d6a5e418b62e51ee7eca2b5ba68c295b811f6d1bde71af748cbc2c4c965617adf8e4c2d76e896a12341cb7dc09e3ac868c689f136ab966c59a975b07b87f1742bb9b35690fcc843eab59a50d0360a8ce67b636243a616b1cd3faf95aeadb217179e91411016be1f7d3f5ad2d5332eeb0d117cfa27425a97441ec19ef4e32ea9c01921731d093b52bea225630a1f4aa8606725d6ba3048bc93d3efc19165cd93340c8a156de58b91cf75665b8c16079f0c436c2aa3b71d1b55e80c2718b44ed459c1b91eac59eba1e31945a3152319b1692202eefd001616550cb33bd92b1929a87c23d6a747c5c15d344b32b297c132c34081d09f6d8f8bb92cdfe6fa6cf622a048026f15ae592dbe2bbd82f9c8faa63bf448d8d9179a90a179e33e16591dbf5abb696fb5fbbc23df981a99f649a2b9d0b36267eb80407a8d9ff4f24632cde2aab16fcaf59ed4a50f570e579b314286e6d97933d320fa774fe0aaed15ea85a7b244e90eb538fea4e41d20b9ea42def8c4ff9b6e208bb6c952b1804fa969cd9cef8715138c554a9cb0fa721ed30b479d14081ff8a9387b94574e8f284766bad024d7cb25aa76a7af19700f69b7c0f6b8ca9498b5e5af228d55e8a413033da5ae6eae24f715f7552906c44dc24a0195d23674b9e531b46a92a7eb623249aaeba41e6678cb8285c1ca97f00aabd06563eca552a5edcec9c259b7f9938aa41df3c6b219e5aeb964e0e9685886e83dd2401a09c034f14bf74741c5dceb1355edd6c5ecd7b040976d1c9b4a22b50dc80df2e369627cab1f15db13b454dde57aa3b6c45c149ef3b9b5543cd11cf92a5cd26b4e0aebb24d851126dd79ce0d1b3de44b4907ef54fe0fc29fddef2cb11ef767bb3b893d0df8ddf7a4b5724ac1efbcbe6cb442f00cd4f0d60b39c169b6e39780bd893cd0ad8f6e29ae1ca493a6c875349c715cd6bf2b29e261bf31edb406bb2fa4506ee2e6275acfc1d90ad71f8f7ec38586ed2f5a9a94961210ba336c59e6c461291d770593da2e53890fc1d88a862e454a145c86609470fb9d666257defd0cd00afc457421a9ba03a9d0c2caed3834215cafab2739c66033fd60ee42d9c7a5c53f4ff0c4546a3f51da32eaaf83eb1d6fb199bbeb1d56d3a58174ec2b27994c3abd8124d1e75dafa04947555e3d4cdc12e748e9c6c5310e1d9239f8bd2e8716f8075b07bfcfea2592171602311c4cfa7c5f6cc2bcd1bade403c48ea8249dcb15bf1061ff94bf9ac5fd127ee13845c2f35fe3440fdeca9c25ed90bebfa11144fcbcce40e6973ad2963086e78287a126cfe5982092422f469d2c8384b0586ad62fa9cc6aa0bb00bc9bad3291918c699d3719d4aef5e80588b3764cb620b09041e0ad71f7696cbc56e297cce1c1598f2fb472e759ad87b107dfedf82a725317bbb6155a02d235d0cabcde88fe0fdf788f3880e3e43e145860083fa867a35e2a0ad28d568d2fd10fb5851100eb35af777868028bc0ef394a3efd905460187a7840223499dbbdb1e2f87f697cd3653559bd32ef4efdf9d569ea23ac6a628e45eb6a14068ccab9d0e33f80bca2fa256da8d4a918e2c99e0f93e8038efbf32fd12d7b59bc98fbe85643c09b650a678b3b64482e320fe80c93679df5e5adb6bb3fc96358300588acf17b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
