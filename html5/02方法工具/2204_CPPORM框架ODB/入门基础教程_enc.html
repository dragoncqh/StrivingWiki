<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"97f3eb0aff3e2ec8c77682dfd5262591ebc88438f3cf0c13048376b10de710df44672aeea8bb4174b16358272fe249fa3f151c39c373aef4849516f345080e8c8aa871926ba588ced73aa2b3df11fc33ce4d039e40302d2b18e707fcdb0ee41a07071027e1959eb60651dab96ccf1c4a59231a05570edcc534285ab3826d14a99ff3ddf4a3a3741392b92412d77b7c1afc0b56cca37c2a383d877af38e573792c28aa4d1005aea37474410dcc68364d518187e9dc406d175a17114440f85997582c73b3ee970dd5ada002e15959d4d418e12a1c0900a615d5467a47eef5edaed18dac96c26f996540afbedf1ddb491e5c1d94bd1af04d8d0d2fbd2f2999882c0c40b6a8388372e573fe0231826fb636a00fae1f9539444cdb672f063f9f58bab5a1cace26b6653a07bfcfa0536d46232dda4a170df67d658b317db46df626354dd2481fbdbd5bc3f6fdc3916d63ba55f2c8ef64f9ade85d38c254c98641feaadf12f855c762f876d337d23803f420ea3c98381b04acae111ca33dec2d4fb63774c51ecb950b87f1aecc68dbf8e8c7695a13f7ee013c263e192193a8c71477902cd01ec4f35537963e2ec2ba47912218cb024931664cc11127ae8440c023f6a7ba15557fcb60557ed3736d2dacf31de28400924461351d438e9b64e91bc79a95704cf9c4798fff87d056e703fb470461b4b3355888823656ed0ff189c54ab128e81650945745767bcfb72359d4e189799ccaff87bf560e2dc9b834b44f51812077e0987adfead8991e6c646d44900999ede3aa9211d97ad421f053fc4d959ccf82dfbcdf3b1ca3fbb4d5c5e607df7c6db1a8b8882ead4778c9dc0d4bb118eb2d7f0c2540f974abebdc9c7f6933df5289dd8ac4b78c16ccfb0772e2819b36e8894dfb5da039c333daaffac17c2234018d4f64b44aa208f38d6615827c10d899bf6b72ccccff8b3037d4c8f710d19c97a3a1d1320180477dd3b61b4533f5f54d2685350915e5bfa183fffdbbf0043fb1a35447da142cd8c3f18e2d80a3b6952b0f66ee7586a9ec113d3fbc48f6dd6aee541ba99f8579fe1cdd2ef0683711bf2c8d3c4c0b1562cd50ca2d8d1b6a203f7f8658544fce6be46a1cbafd71438fa1a180e2f9483b04c2b683c23a79c4dd7a50711e131b211dfd82bf34dff995a53d2dd4be9d2a9dad5775b560ad1ba74ca63c0698765ac58c93a21042c1c78fd83cd2c02ae98ba59a98c092fd040f7c8cc84c98e3cfb077b741cb7ddff1420dfe951c453dbd20ded8118e4d47143786a89cd07ce0cf85f5f84958d58a98158220eca6edf0be3436b85252c6fea1bfe1fe45b45e99e7d6c731a4833d436422c4af03ae2b081bd29d7c11c8c39989fc9aa335c47a7312cb43ca6e4bd7a2bbb6fe715d8582e2e85d4c6a9348ea5122cd313baf9e79295415d58dafed1f89a6012c1dca383e85d49156743ba03474739df1326421108cd7475735f656ef074881048295ee1fda65bb93df4b6b3a4ebdbb06052b0aac93f2efcc852af1eda0d8750030b908659c13ac8971ff80535e6a279bd1e3bf1fe928908d85697103cea25f4172f03330b80d0bbb9ca26f86ef211db2a5ee3dae75a6b2552548bee24d3647d24e2e9710adc54d6990a44779a160a1c029250c912bb6facb7568539b58f07b31c64f8fb182f1040eee28a07628a4a2a92be472c61ede07d718fe9846b0bba5f8ff16d85c580231c16ef79a6ba190edb69b5465850eadb7d4183a77d130d122b056df2b3ff543ae1e767f9a43b86a592809d643e7b7c7656b5ba2436ff389acc6c907cb330aa6ee038f78c680aadf5130ff8bb1778c7f52d3d456f56178a21c6e04041e19408a58b7fbedfb81ab9ad474cd3730df594e8ec67ed8bc39dd1a316c16f3b27e6c4dd38af82607d5296c3056c573a498e4f13d756ed34df309ce5dd5617aae95a2a7b76a4b6f9b5eec3bfe17aaa398738d334be5de3c14408d64b9d4d9dd974677d1461b53501b88561b700ede0639586a53dba0a45771c22acd567b5787a45991c3e1b081896234556211c886b297f0ccc4573e0d1ba3fb595d5e636167e4aa18885d2bfaf280040923b775f6a2ada3d64562051a8de8f5fc3427969fd0391d483db8659b0cffb7c5dd780c79dce2bc9d46aa1b5ba195173b4d0e7b914d8e45ab100bdcc7c45781889f19431d172806f2f5e5c89e92a86cc334ac49652358a905de10df307cd660c40943ebb31274493d384c83a18246d2b7123ea931a226b5bd85c6fcb8431929c4a1c2d2db492dc56f0d362262eba2fb59b599efd5ffce8b5dbd5471bb279415e9c0df45bdb2dfb89e319387298d4bf83a3fbc864e91551233d1b8626e190046cee9b8f3cc56f74c41b5d8bd11c7f1252330edf6d71fe62b1b82c933ee7fa66117d8942dcedd2917f5244c0257f131f85d0654989ecfd6297c558e1411391d86a16ba2b6bba1aa42ce0a51e6cda3b33efc31de8770cb16bd5ea0384a1fa6178e825c125600f335bc9b159b2580255a7be2c70363d7e141fdd67a32ebba2c8e30c0b76489ec6ec3179c749b16bbe6a847585d7d61b8cb718e2a12894ad1d3b84d655892f540215380052df6cc8f86da70a99345ab040ea52b27735b442a2e9ddff9c66b35251546de665857721c212b31c1811ef3bac9ebad684b11a0cce8a9f6280570f69a2c0a1c38af3103a50812db9f4450aed6514c3ff4912e04a5b939d9d95cae07c73c509974dd96c4f9f379c7b9f94ab6b02974be8eafe44fc3fe868fc2753ef24ad7a1e211552ba486dc986a16d4962599e5254c950e82fe1bd4e7ff3336c3eb8e252e785bb6fbaa483d5a5bc82b4276d051f58ede13aeb3afa99061518ede0f6bdf08c1be270ca8bb9e84acc733c90aaea3c2354f7785466e829dc186dea52d1b2a4f8616cc47092e78f36cf172f5a29775eed6dd15f3b09f61cbfda15a4b5a0eed905a65107663ec9d02be54aa1feeb1dfe0397e2bd003387693f6cf244889514dbd7a6da2bf319e50e48e998276ac087425bd8d97d81b5db630e0967d7bb19116176d89e0781c6d63433ee3992a9783ea4922b6c84637a603933514d210a27db49dc6a5bf79dfb24bea3bdedd75b51d1d09cb641bc6c02929681f1bde010ec3cba047972293f75a80e8e488983469a0b216478aeb8757942b60ca41d7ce468ff5ed708b89daa5b6332d4a2813cfeaa77565476862e27cbfa00f13f66f233d30387443dfeae98c73256be13cc48644cd78c04099de925f0428e89585bad14408f35267a4c89391b262b40e58b4ee4f06af17aa6fb4c8ea4286690e9695a10bc97ec11b1b397761f07cdd20c681d5a5024db8d11214144b6e071ba1042d721df9a6f36cc9869f245819ee0a92caf3163b6766ff1ff8e153b67ea53ba0ff9852fff73f3ef42a551f97a1256f04f0dad732e45706c63ffc07f861b4903218d676036909d296d0ac41bfe7fb146acb22a7e1cd73da50977a0c10bc139f6206d6fb0bbe6ce1aacb45b378e6053e0b481300572509075cf911c2cfc08448f47224d2d508c12df9a0a867b8feb47569e364c3c4ad8613687f049084f8d2bab9316553589b56f7a7aa8d092ea73e9fdb610c1cb404ec584339b86b9617f6d89c896b0c18444946806cd7b20bd9d80a3037814041bf05505faeef663db3594ca5c0e9f58fa36f5e1b898d148ba87cc00de037049762e9d635559a4693c02c54801ded9bce848611cda6dafe261b58c6c7f1458120b5947d803f2561bc0bb6687bc1064bff8d296344c5d4d184c09f80479d22d1c05be1f3b3fda8ef67e77d9be1f5aae460a16c8e404a937f3f77cc62f596c113d28e6f713a6d65897277689cbaa640cb85e2504d96c38f0d5525c16d10955043be610e3faab7717cae38526124934393a6bf77e38dadf03c908e6ca107c0b5db34280c97107b6fb8b6960432785b528f8425ec4608a2705d9d298a09ebf6de2364ddfe4c7cbdfc5c36e4343ffd35bc4b10e9150f02b58120ef200ba6ddd75e885636181cd3e0c1ca6d4e2de67b7078a60292a0fbc520a049bc0918b6a7b55b1eda29f4ba5ac9353687a901b3a9a6ae2bf50c572c069da792f666342f90b5a6cbb54e87d5eec7e1f17125f03aa06e98a299c512d80fbb970838bb2559517d999e1fcb52a0d45fa468f58f6366faff1172daa866f5f858c9dc62b710f3fd7293988f5924e1278c1c54927a510cb44f3120512be88d1fcdb14a2d227f9e19fc72347eb57e08ebd448453021527dcdff4224f2dee25a629b565936a7950955f4dfa804f160847919a84de09ce8ba4b6c508178d8926dce86f6b854c56fec3427ff0823951924b9a29dcf3361343a250e424fafedf112e15c9aba5b1ca35eeb6e89f862501e396b978a087ff54d42e20433c202ce26b835c57d0e851c34cf2f6410f1ca2d4d6fbe249cd24063c944cc25cebdb25f97221d3e794774e9e1a8dc1f9bb9a069b286826955a31d44aec0a277e34842566e639f98f2be6ae4e9abf795239c95354d9848b9064c731751a092785b2ffe3fb5d35c19cfb09b519d727dd18b5b7ce3e93d215d5a105f5d5d589bff2615582e1444c5c3d4e7b06d1886bda7405e6d51ddaea250bb389016b061f07b7dab4aece25680aa94fd180de301c93af22a51458be798f93a0b5b6a1a2fc4d9e6156d678e02ae97cd84332dbbf65dbdc2a7182bd78ab58b4c30ed7d018e5a354a98926542a07a8e3a5cbbeb5a3d43d08bb6a25bdfb62991fd785f448f03b6ab4e2a54b1e77b12d4124814abe1bafe056a8eced4b4c85abebeada2a764410b69d990dc72de2f01afd908115591c458c7e87f36254738d71ca667f7b2e2f578191b58165ac3f080781db80217ffc692fa025b1caff93bf8356446ed52691ad250ff306ff57d57538b06fc36ce3bd27f23e33a851cb358de81127cc99f70abae8d2e65b5c476523dacfa27ea2c85c57509d45b1e49848120c96548ab8e49c7c70e8eb3052ffd6259451a40548ad367aace7e71e9c92b62005eb0b1a95bbac60ff31e3946377c29a1322325ab140e976f48b241f644344d11a4e3752a1aa61dda34a42b783f4e981a908a2587b39d2798d10ae9278422b7e426e96d8239c483bc586402a67e4aead5b00a82dc18aacfe1746f7dbfb17cf767d87987a4cc0130b0fc5c3dcf09391add749510fe5118c86b0e03ed94541bb214625028f589e83bf53cdb59dc600580fce61fd440d3183c898c40520219623bb4221ce6aac34aa159d2a8696abe5ff3345f2d0008fb68874fc07cfcfb6a61de89d699eaf0b080cd1add9d1fb47f7877d7fad9d774346da3dc0f14662468e968c96ab550e5c19f57d732c956cad5369edc663e9aecb69f2638ae7d136dd618e416f193f4a1454fe007feddf317769e10a3ae0029c3d853279e0236ef5fb632422743e62d75c157391860ed8f53e33033445036a41aa87574c7817e22f565a0550597b952889e7e748ab3b1aec0663afc8e42aefbe3198626dffe56237de6226dd3a086536b6face02a8c46caefdf63afa56a985ea8870f3145ec7d9d74014ff60f399e027f40a8b1beabf18c550c745b57eaac99634a92f665acfca13d89c0a7bb41a37ef4b7fc9f49f3e3129a67259d118149ff470a41534009859d77a731cf36884591f5b7e6c12eae5c36a79b4183d34c092e611e9d6dcb410507ab9676414b6da175f4873539f55820b13b712cabfbbb523867d465484ce81f1a476ad932a47001f650a4dcc14034bacc9f34671484146a23ebe440b5e897d260c5a61c4d7af20bb2eefc770be17c5c5a2efdc15bb22f3afb317b7d14cf41afe5452fec4a054c22f3631db76c4a3c46a6a3e4ffbc372584e5ffff737acf53178c84fc2473b05a0fe3ac66693c84e474742c17d39c7256a74374d199c670d88652ecd064663d5f38de265a355895eddc956f952a885a956743a3a5a07d9c10ade0a8ce0523e881158a8ff5b56a624c742544bd5e43ae65f553f1e4c9eccc771402f2dc9d44167a20d246d697d9f47eb392b6bf1966c63324f28a1e352380455873394660bf85dc7bd629fe92ba0ea79e06430172f237e9f05f5df9830c8dc446711f27e78fd683499f1d74b29e179b550c5e6fa485b9e5bc13eb0d04da760cf24745fc2cc20c65dc9785aada65d3156fc8493cf561f396f5fec462615d4993e2b8a69245b65dc70896304536cc906eb654f824c6546007bb362bd875d0bdc6afc8ce6997de78534db921e1bd940f62a76d3474e469a32c5a28e5079344bfe4670819cae4128e2d749c4dbcba8212ac50e1bae1a072802be0d4b9af75a42988ce22550fa1b33a9aca641e6077e0b8700515d073cf3533af2dd717cf0da33880653bb7003a516d331029860ffebcf20a14cf392a9039ee93b143c50bd664685ef032edcfd33504fde9f36c8e3c8510f7407bde74c2c37c444ee88e470f7df91911ffa17ead636473c6ac6bf45b455433b984ba87e51b844ab40ffef61d3f8dbb94aa5b24046a165762012adafbe719919b565bb9c897a7f1815d9d3ccf39f21f08f7bf1afce9779c1519abadff5dc2402c126a959900f6e594bbfa5d16a9facedf1d055b94746fe436a110d2745ca47aee02654b94e5c4e6983610973ffeed889cc3e6f1f1c23bd7769d4132a80f445868b6e62afebac0b401c16ca9778aa43f4d01c6141d7b36407cd84bf9d19215609678ca560be53a50cb24d026471b5a24e762ed99861ad1a97a6697422e1de4c769eb9de1d2b34acab11c1badf3b63bfcd47e36a4872444c6aff7eb1f25b7e343145b73ffb4e88164c21c733acf8e26f34427ec725db6de44f40c0567f13e3bf8f0cf2df9eb0e323ad10e1165fed05df6890f63b915fbfeceda617b1d4c2b32b3e3066a85baf6ee5886b3e7443c50200f0768f91669e31f1e20f86c135547419cfa9b2ab27884b2d550462b7c3344e9fc2951aea81c871219cc1fad6494f90455301120ebfdecefb07f3718dfd196b40e8151bb4e603cc57afd4798dc2491af6cb58217ae8fc7e3bdf97e7ac06a0bc93d84b93593f796287b8565574883bbe1a283787c22dc9376d276a6f1a84dc801d8fd79058c8c5f51f9d7fcbf57bf344c995723e483034823661c7bfb8134b2c499936ebf996bb570595ad4189fbffa004f65e6e3b7eac8f0edcd8a8fb6e966b49f22f4ba59e1bb701df6759af796e9c646cf58bdfbdda23e170f37ebcfde8b9412f93c7174707266297cb735e516702c148191ab5bddd041035a338c312184e24685ddd5116e7a2f87997250425d45e0a1545a685e6bc1c215d5bd14a42e9de810b469b5463c99cc443b0efa8dd3575b94a5510635bf5fc97fb212b477bfe874d8535122402d4f52955f7c2158e5ef9ed4f521e8abddea13e7e9b4f2b1f5c885c9ae9d7867f4cd5b172b70d94a7f4142e625d1b647198fd4c6ed0f74395cd457eb808fabce88ab81ad9d1025b870b5a6963e3d5116320b375cb4c6a6d7d7463890726ee9b84ca10721a4b9526374d4890b14836544c43fafcfd26f26ad0377fb535a9608c9b902f4991b99b4a11f591a008bfc9e8dc832b76f1a60995231e698cde4d1de27fd517e873c1eeb3b1eab4a0255cb185d108f2a439455ba55d80147fa653aeb0a77dd48925d9ed364c6857a53bef9a3bfdf3674530657a1139b0e8d70c08c21c2ec852b06bfd9fd7620a3a8b0fc8b563848643d067ef1c8c1972efb1382d334bcb6c0870bc8c9922e290b95ee2a56d114a2a959e94518f2f500158599d391860b3de4a7fa70a9dce0a74680822cbc8021d9deaf2e144633af0996cccfdb1d8af8a89e86166369b69c8c4d2d808fc93c3286c98a9133703d2fd1a2d6340e17d52b5c61c859a6e123a0f478851fd09c574adb3d7e3e1ce256143a4be8baaf98d0aaaf03e74b7566a34c8aaa9a51667811997aca554b84f5331a5e374713739c880a2c48dea7b6f6c32a2978a1c63d2d7d15e8d7f66c5b0b62116ea3c0a3e3c0ef760783ffcb6e83b7a422a59d79255faf781f740de96d52093734e73c4e0fffe8ffe44b9e6137ee0a2c881310750dc3b58fe0369b62df434c3232c6974749fe90e28119eb29db12c32132b9cf734d3510398923e69a5669d473ed5dc761dff00d1da1ce738bc955912d6c7483bce58bae694b08accf6cfd38342ea000ea70ded5078c00939d2010f35c391665bd407d85470a32c251213c9aadd1f5a91b80a27d39a84619769399f5429b8301dbec1dcfe40ce74991845413aa7aa1612773f93d6c4fb334565c3b0833debe84f168984efb8e16067f129fa62bd75f61fd238821c86965c5b446b7ede9d05c55c53167f4e821cd00283771e1f81f7f27d8238635695dd9e331c9ea2caca269ae4c6e3357941d232156819f0dbfb9f316d980a23704e0514b7c865fd11152cfcdf6de7cf38d45f5499ddd37f3f0c4e4d5c997c0c301955521fdbb35fc90a2b59c7c5470eff814d50","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
