<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"60dea1483af759b1491efd8163e467ec3381635aba6d980bec9f410c3ba613e0afd2180c558180f217f08748aac734df608f5a0dca3f5c608f182f8419b4dac13c6ea547b7855881da0fe7044dcf5081931230f0b7f8689eec937f145a59d3d92b7d50b44773a01eea9fd66483bd6342a8f4535bb0348d12f03e18caa4e5c1f6b4bb57b327bba68aa8fafa5afa227832f60c9e3059f49b61433480271011dfbc89095e1040cf0656f8e67ad2bdff10aee538c7754a89091c66ffe6c882fc7749a2168d7e76e8372db5725826a72a705ea76ae6aaee12d07ef55206f4f004a777da79c4b3039a5f61d0ec0464b42b2e0a603b6be208ba01ea863ebb8cded4baec637044aa21ce975ab80eb4e1b8a38444ec3336bdab35c749ca9c20a865872708524f025663f40a5ae88666de4f749e4ef95b5e5052a06d4ea8f2a74d73ca6bddc69d38fad5c4a3d063050229808f94625732fe38e15157129b3634368754f9a1908a49ab8bb83a698333fcc4e6dfd1da02c8ee057cebbc46212495b4d16a71a1dfd85eb6d7bd761cf944080b7cbbca0838970b7152dffcc5b08f214cf224eef2ee0ec0f686cfc7ea5800e64dd57bba87881529289a6a03e9b8a6ba305853eecaa2b8df093cc84bc91f84c457654068b5ffb2e09369e45512e5966d98b646132bdd12996b36e7a99ecb8f9a9466095791653efa8fdee45a11c7c16ae6d318e13024563e600b373f32ba73af3609ba5841d3ec0b24987f74a4be9060ed082cb52e0194c020d8c52044b18a2ada95b67e3571754389b4b1486a685ca5d8c674f72c4619bc9626d2b0a5ccc9f15bcaccb3a06a000a76d165356a059c25ed378dac5bd0e6a5b1cc0bd88662893240d79be213a91afcbcf005cade64358707bf20f7428203fad7ceb7d6d54ee565560944d1e470fad15b49c8bdb4ac32e64a81be93e35a7a01c74b5e81effed3b4362daea08bbfad9e3446bd86701f2cec461cf3eef8024a0fda883b45b5f600114c394208fc1e013cde1cb4e4b7a93691bcee01ac3947dc79fb8d5c9c615475681e548550cffe97377e1824e213d14ef5f432d9080de54d9b2a8878d1717aded6ed8340eeac33c66c54dc368111ecf66b1bc737ae52b536ff8bd0ded79c95aa5fc0a6f9cd9862a530fe1cace51b35d349323fc41e15df03a5d4c8f170520b83c9c588c6285a3bb609f91c43423101efa2dedfd03aac897a713e66ebd5c8575a84008217875a2a1c5d3430afd9bb2cc86f0c73d0b1ca61a24a456f33939f01f552cb88c15c85ea27d1b9410e6578d4ce01e87e276c476fbe35564dede5e635625ddcb79694b99abb8850cae0a06037f0de223c5960aad88da38cebaa7e8f5762975e94f3b9d99b2fdcb1285f894fd217e4f8ab00b7965af3bbc814b81febd1ffd9b4c72115a56b4401916558f147b134b172a8ee512f651fdfeeff1664ad8e7ecbe4ee2354e39eb764505bdf420d8226e3ecca9e41a766f2a9a365bfbd7b88adc38285f19dd0f10b96728cd1ba5d70e8e9ed3d8e5303ee2b4b3b5a597b699ffd1d33f9a5322d9bbe78794c2545f5bd3f17adce5b86d29e8ed69b6ef5557a100ca1d1acb83a005f7f72874a24245d23bfa9d60ce64d3be432cce98dbfb95f8be4d66ff14c7a113f1315f9fa453b9ece9c879d338333885fdecd5b82288cd89133c0d18de50f1a76ca34cd0252fd1003f3d98f6f9983452d843dc7f9135251195db748374a0361e1409fd1cd98a4c89b4f62e8181ae7d686c9f159750f18f84e76fc4817808e72aa54853dc193dfb8b7096079a0542453b933c6ba2b5afef5e4be23565bb28f55cb112562bd539dbe8bd1333fa9f86bbfe9d0217efc4cfc49e27893777202d81fb9b47c56950ecbad21c9ede565bef5355af4805fd6494032bbe8a37d28277af7211b9aa30a1f4ba90cfcb7f3cfb1523c26d111fe008d736c0ccab38ea9ecfb6997efcac6e4a38f013f7917d6ed199182385dc639c6e5a7ee4be4a2f1f8aa06734d63c0f0f0059577d362701f156ad0d33678400228333c21bb205bc858d76713b8b3a3d5a87391e2432565d9f26669878078b1b7622db8d5c49703c65deba68203c0d890618fae300fa985701f3702a6169b659577d6a56c2ee3ad35fb518957642cd3522dc5836c0f912c7bfa36deb01419de20b91993e028bc2534a65f56ab56ee5d081f59447b8237376862052a7f963ee5ba44a984b3888617f17d505bd1d69b1f0a5b07420315ddb8b1547a48b9904a07341457e0e35b9fc25179a3b3726dc944c7101c40dc89df4f2301e7311a878a2f34c396ec5a11f0b97fab5fdd93411bbf72e44adf9c819ce89024e328e92cd23ce9aa93951a074ff0cf05b2766f70956b4eb0d73338dac9dab4482ce1f8f18cb8df97932a0394038414881d64335429c12cb7efbba0cb0668ca7ad4337d5ad0b81cf28d156799111ceb0ccdca4a2d2e41a1f3573370c4495e150b72d57baa82c776e5764f4e7181626f5b3e3212fd52a10ec55e20eb0e705d2de9053e4c0a4f81955aedfe0aa517d535eeccc57ae393614681de6942aa65cbbe4aca11445d4da9746bda7849806e9875071e45e3ee1a90d9fbc1586c42e16b887ee93d2dd61774c63a54e92eb41e6716f86cf919b3af6b0103129f55074381d94bc7e4b192b716c339603416cbb86c54fdb51436f4f2f5d7f1625f6fa0d02451abbf9f6d37b881194819fa3540605399a6cb5e8b09f052508f79a28d99c3f55134db048a33e690a75db7234f2746f8323afee35869e5aba7403748b424e0c478bdd4f61c865f6dbafac5f2d4044b1fe54db3817776e588a5169801f9334ae95a9937f2739922b287a0d67ca9dd712e8b4b9149368c359e7c827ce2f8f49f981cf1c8e4a007ee15c85a66dd3f31e0be6551eb74924c87922080cd555e200540d37ca0a355ee33a1fcaa416b7a78c053a51a300fcbcfffe97505b0bc2c34b62f699cb46ca0fc64095df0bc6a354f8c25aa5f2b6f399e16f02fdbe7a6a2f2d1badeb7938ce50fafcbc4fc211127d223f9f809f7636336edc2c3c40838dc9bbace952d95d62739df0d28574884857ef29ed0d692daa95737bf53414207c3da903b877665d7a3faacda2a5bcffa5dd7fba2605b0856a2b12bf67c00405e13fd5eb2d7aef780752b75f39b611764269e629a206868c702838ae000b3a511bf07adbebcda5c42dfed7f5d53a565799ce5893dfb11b346b6abd8ab265c487da1481c0d5597ba10ff73a1db99f22fde43edf82974dc608123c79dfab5aba1c4af1376353996e951f979ec42e3c35c09730bc6c5f42a324ca1d13b1350288e8d215bbefbfbbda83e742fb5447d74434a50a735f033fee769352ad32392959f5c9e1fa18054e649febba63c33a1676ecfc6eb80fa91faaf2f05a5d42a9466fea7dca11fcf6b41ac169f30f89d101e273db389df7a4a1b188a2eb81490e3513e5abaced4c784fc3455817f40e88fcd9235185e1c449924982e29d7c08f0b3a0d484305cf190dd289e0744ef5f5621fe0286dfd8816762b6d5ff3ccbac7d24e72e75bcc944d30c795b06cf8686390d73e23705f00a0d5073043c62b48d141e5c10ac63e30aff7e62028f061386bc46a5e5186d9bc3594d93ab9101641cac19714a9aeee9efcebb34f390d60f9c7f1b35f59de050cbee88987e1c15cd1012f8a835624d79cb6827a3a1820a02cea3d6ffbc959ee6fe1c120d571ff2ec8813521d7c21536b25c8519bbff7a3ea45ad9f17b881c7fbc0ef5ed5a831aec5a78beb26da6a4c5e0c342d3d84526b0a959b24fcbd6e1e66cfaf034f295b8cde060eafa7c715e878e2fff4c31e873c578bdebefd2d84f94772751355df0a20aa1554fa4d124794934cbb8d833b7f690c9cdf2f5cae013465c0ca7ab121b36a2105e2ef1fa9263efdfbb47ff1e5e7ed1ff030ec68d25e0eeb5bde607656ab966931cc6f237a8268d0f8476217f150b4b4c9cb0c25dc83a2d780d8418be81b1a0289d9cc5261a85f2ed48324774004b13f6f65da30c4104af56781ef1eaad678597f152daa1bc09f8846697065e01c47c403b46f6a98bbc8b1b71369fe9790fbf1647596f8ae9a32aa147bf418141c2199bc35843ceaa15e7d2479177e1ae09046d3def748e17ba4924f710f26e75aed8ef626d2c474b8a58a9aed75649d9fb89b36b14fa8db8a32b37feac6c7c6458c31d28607ef730a829494a3c634a1f8daf6ef4e5f4ea0379a05bc8e982bdfcf4e6ef2a96bdbb9ec52d7bb0213e2458aa5efffa90a2dd51d0f5f17ec8ebde5ea0f9022ec2d5bcca5c29a504412533e9f336285c48c86849d7e3233d1bc746e4f65c573b0af191a25412fd798d0d4b8af6c328764b61f6798770991370c486b5c09980172571a4710262c07d13a96548dd7840ab9b72cb4482a196699b7db0424b9d30ab41b3b5d27e249436c9f8dd3437965c727ef2130d828304309b57abc8d4796abb4f9553dc1b5e54a35b61980627403ec9cbc01c6f63f2801e66a342de3862551669bfdd822b2c51a7ffadc616dcfe1ffd472c32730f16742d44efc946bf8b3ad4808fb990592dc2fc0d7ccdcee76e4347d96ea037cc36dbffa6d0abde62e37b7799d2b94b3185b67edd2a0b0164ca9346d57db17f359d57e28a90f6005e44229bba410fdcd38aa6a1c9351e0af546708f357d92a5ca5cde28b3cfd1bb032cc9921630bf9868fd516499f69b6548e5e805c3289e8052a708454fcf085132b0d940f5042c6280cfd40ed5a8ab55fad4b2712af1a2f98190ba8ad86e38328c2cfd574590258bda8273198cc8de4af2c58045d6dc5cb88437e0b4ea5913b3240deef6ed4f74c5ca9bcb501528e955c389579f5f0db76444448c32cd2bbf7b9256e9b9c25422ca30b47b1410ec5f2a39c855bd3de116972e63076448da733a9b51a1ec459b3946ecc102e64dc6df8d6c0a1e7e827bfba54e1a45a42182fd5a4a809ef176a12e0b6392ef751e8101ed2fa5fe0d5f116b85da3c560d51157695fd3cf58d5b2481943a7075c4bf06a90df0bee4dd83a64f0ae0b42899b95a2096d319891ce7b849373dcf67616f8f9e2a785a6dee6ee0f23ee55a4c1ef082d18fdf114a42bb4ccb2be827555d00d2d61994db782f5e3bd5709090a3c506a77d5a09d39d833d9d4f5e659f746ba96ed60127f04e063a184ffe05a307ae9fa03799aefe0a5faaed4e43e79416bdbb10936320d1f9582cbf517915f60b544aca001ab4813dc4aed391ec28c819d1b36cf010ac325517031afa020fda3211bfc27a2c213af3e1907f59fe8b4ab91d23cd4eac142c63fd1e6fa906e911ab5dce75410f3d9a91f9c35598d00e9a8c0d2ed2d9bed321a969485bda0778449a2c2ff1d15b9a6d5f4265e2b2f37aa6575c6bdd07f38e919e7fea461a168a27f7b8125260c398e63d1f5070a3eef3225377a82e612aa10502761330de85ef19dd5c422732129f8c38ddd6a429d6570821f9f5c35c0e038abf218c1efefbb76f4232e15e8951cc3602649f9de11d1a8b4aceb738d1d9cedcc1623e6d24b45e584245953b98479b0b07d7f2110cd8cd7c252c28aab238e890b34ab0bef3f239aac1750a93c59f3c9ac978fb0b49c68ffee69990a137864fb8ccb21e757b828249d8e07a2ebb2402d1822c450984a0379ce3e5e77a456ba96b9d098884ca36e577e8086acfdbd9ebadd88b4beac04bacdeff6bd37c1b1dd1039c2103bb5e18dfa3c94162a7d471227f0d9a4aac747fbc574eb2e86c1488ce4b8d374bec1c2021ffd9cc88fdca887c9efaee96c6736badd0d202eae12e82a70e20820bad0982b486aed6e5c2511498c05e4e36d95b6d6e0b294f48c72ee1a502723cf7f4a3d4802b4c2f28f8da75431032e1a862f17dd49e91046c224ea4170212e53385f5adc3b5ec80df1aacd79497250db3be5972f47d22ad70ffebb9d6682c79c2e6aa35058cbd0c0fd8eb8d6daf114ebe86fcc9f3cecb808738cbe8a009147e648c686b6896f8586de5773b53abf79a917ea2f8033be995b2dc75acb6f5be4b0f6949b9400ed3b0529f8d7cd69128c4e60d14ae132e4c646866b21069f3518c515be9e3d10bc3d6a4fe002801b3be0b71d9b65506a3de0e7478668eed2b85f58ee45b56095c0c1fda17e7fa188610102559a9822f8bca68c239a9db15d76c6cdb53601ef7911b797c14e4a3e371ae7662b921af777192a005708db6d1dce2dbe081e858926541e8835145ce0268956da4dc12973536340a190097f20cc2151ca0f799859d3abd48a2e72a5715e567f89c3fc15c514c5e9a980a2c5312b5f6a50e6e8622fde25a1571769b17a3c1a29ee729d14e489dbfd7f6416ca4514e1252074323b40d620221ae38b87cc40b6b5ca36b21043afa4168ae2aefbefcfe979e084aa266598e06f3d52b5196b7be922de2947149504e75772c5d08a9b9a83fda1670be8e9f1605b2d5e051919c79ddfda0c1285d6d81fe7d190d0199f1fdb18e4da59762489f67a619b58af14cdb76994beb403160fd3e010809219fbf456f24e3fef7e43568330de2d3015bb7729c13e6fdad40c2a341e711e44c18fd88ed51dac85ab83c7ae878429c1840852d7c3c85fe3e477d50cb32873faeed715ab3335cdc396df8e22d8cadccba6e09300749c019e748ea5f3d0f5c36c4ac201b3c56d186726cf2de17c65cc077f193897d47cfea87c88c1dcc68e29c0279bb32606694be332828df9be5e4ddd68a2f50f138a1aa51163f7a7790ce8352d1900296e0e9e853115e5902f3522737daf5e126c2cfe1358925268fc029a2011a767176fe3a99c7bd24a687fd9e80a1c25070ceadcf77d45c9d8506c8b37ffdde00f2605f1b1c808775ebe92e0ae08ce3e277887830d7e99814b6e013654a83f9ca4b8627e6f4a45212503d272aa5499efeb8f3c3b3fcd2d30cc272ec499003ed20794d9ae12047569fb98bebc88d4df9bbb3aea5273e852fbb189495e126482a3205694c915dbd8f75eb9479b4b53db12ead51ac87db5ad376de54ac60bf35ecd841f6757fffc42e8adc961505b8d6d05d15967daf9b39539294dbd9616ef122de96f2a7c5a13652a75024810a80806d02f5a75dff6cbbd74b78de023074d4881472b5b78c1033c445b3a53b6d15faaad0fb05d1da8ee4b7401cd5a9629261cd00ce467458d25457fd20d6ec5f8057c4bcb78001eaf64e255a1de93dcbd7e4b9e0b984b32276688622246f6fd46a565cd3bb397a2e987c15563c77df5b886f865717f9089921c3b16a16e7267c0a156a05710c4384846a17e124ea832572502f5d538cce5c58c6a57afe45ff92b51a2a3d8438ee5e5a5b2e334f283015de9c0ecc8da4aab4b23351cab2b1b268d1e04d0c9fa2ed0c9448974b70a77babc362b644076cccd46558772a909a7186e0458a60bbd24d934fb2dfefc2f456a385bda1d4d6754ed1d08980c1ec694fc5fb44a4baa8c2c5bc82cb8c5bb739c7fab062cc4988d2e1f0b3805490e010bbccba82a88922b3bbdb1c4f1b68ce9d29feabc24686f6765c1d0f483959d6a54cf65cff2d1013c6a612934e2cb8c9678f480099eeb790f2cff0e6a51bb36027069c0e98257243884d17d42d5819b01075cbdb1c8c58fda1b9fda3615557834616c2cfb50b9b441ae5bc2f9f37be4c8bf6a95fda095ecc8a204cb3cc243845254b18a5fb25574183a88e19afe9f04f11f66b9b42c4a45ceacd232f32b5cde95ce4dbfbd5725d3985c1ea48a7cfeb3811113eb86d1243a1fae44757e48b97bac3de6b5f4b08c61181bf3b8773fed2e16c63b421702ae9582e8834f511d4142103a8641d3d59d5efd4367910241584f9435737a344a1794b806aa4f076701d965df37099b6da3ecc8ef9baf8af815c859888a297a2aa8da8186191d3995e9fa37ff4099bfce412c5aa58343de64efe4650f4abac2680e628e472801302df3041b8c7c864e1a63cc412847f8bcb15b14a885554f62c10860be6a2835d69e8a1422566756dc84ff64ff90f6ce13bff462296af9574cd35f9f7b44e80f822e9da148a361f393bbc6339b26c197b12b467ea2bcb7370e1f7d8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
