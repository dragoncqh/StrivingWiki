<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b309cc86b315578f6b9727d650320947f9466db40aa537b301ff20217f7b0187626b99626b2af83d66759407daf0261c16137d9448851f3fa1881e6665fc15012764caef5f0688d17b9cd36791e002bcdb869c756f4e51865c70781bd193ecad751d43b63513359919b55207a2dbbc6f5e20af53e1d7c4de790f2fb02e66bc66513f12ffb4594b09c9d88642fd4961df24be54fcb9374d256260bf03c8a0f9ae0ac700e5080c9688879c48c0b13554c914e7ce073ca88d6f98734176e23abd91176ec1cc3004a55117188fb5d0cb43caa42e894bf1555c2c07e6e0d51741bdabef9d08b990ec4ed436fca16b5b2ae21c39fbdc9d728fd35844c9348dd98c9b53a04b7e81ac383e613864a2443ef9a40e7d233087a8eb78dee9785a2cb19d6a2d0f85223cb9bb06b9b4c750d381c016996a0881d240b7cc41e2c525df230cf742987f0e5bf93f638a531ad4ca7e6c13ac4567baa79b764f84f6a399b24ef854bd7a9a753d2ba4c405fd9fc23821a3380825a7f6774d544de2df25de0a3e353eee83dfc087ad89d1e57d8c68adf1317bebdf259489b54b14e30af0bc3498110fc0033c2096a2777cdc7a548bb0594a9fbb6959301eb5e5469a0fddf847de1c029da143697f8929e87b81b584a2c45ccd5f02a3cfff65a5a0b3df151cdad0ec4a42f8f938749fd9b0ad78af6b644d70774da51a039fe4d0a5a768db2dde035731158d0e11883cdbb4178c58154612e4f923c43404a7ebc348a86de0958bc5623abd3d8083b39620f77e8af5a03d8140d6f8063d8205bf4d0adf84487cfd1cf5a1a063110357e64a6cad9218b291eed461f5d8f2735dc6ca9575f1fab607ffb3d57c9e3d1d5a16c8251b981c3f37344c7dfd13e5cbb43da0d0e2f9a8696d6115fc8ec2b9da1fc91610ad5e380d38f5df0b3b3bdd57106a6b5ff155044594c858d536caeb824a196ec4c60dd81144f2d4f2abcaed659b4eade1f53fd691da800af72a03f2f0f2e6857c6885851d66ce2fe20156f0f2ec26a2058341c8437f3616045a5540583b016bb3097a1a9f3faf3b0e1b091bdd5cacfac925d2d0c32a3cb91d94e168409ba59080243426e67fab216dfb6daf3804ef80e442c1ce73d5e5b10744f186868645d57d483cb264962ac99a2bd22633d0b9fcf4a7149659f829deaf36c27b8a5828cc441e8c4273f15d0b0bfe8be9df9516cfe9fee36306ab15570068e165fb69b368f1646525ff65c2ac6f1cc716097709ea6ed39eacb6834f85b47329aa3e525dc4aaca1e2f197e8f30400e4a4e1be6996c66d6867d42e5e3054a46df5d67b2f8b54145801394e525d48e45626bf49fff46ea4e33d982341894645d53fa96a599f76581a63253def68292dddbad8ec36149dfa2f47738efd145c076607f3a3f4898f9090a3efef56dd4435cf7ace17f9fd58246ed4cd8752c30d913bcd6ac9de8f01da288049281e39b4c7788ec935840c9a858a2b8d0c6ee8711c5118a63e61b027c3cba7556f690be6062bff780c8b3f05a01bff4fc4e5433779ce88fd769d6baec10229820ab60dbeadfc5894df4979b6012beab372d233b873cad8b40e875536e83eade36b2ac68b81bcf66c0320d8a0db8c441696b2c5a534b56f1d3107257003bd6b4e31dcac6fb3c8aaebbce43a2d69d2ba53dbda162a833188a3e3e9308c054da71142434450c995499f2ac797d2371d43d435e6a6e41fd0bee14ee8c830fcc6c64dd126038d304f3eb68baa6699e71efdc38832a75a05419abbfed4a07c2d83e70e3b03326d1c72a7b818ec9e384dbb13fbb17723ae4937753806bc55eee9b4fe971f347fb600aab1380b7c57d5e63e9a13aa3633a38e7be98fc8fa19962efd383062b55f4092af4b16b3857ed5102c6eb11d974824616a9135955176ac823efda2e109081c2feea08b56b3e74a9ff19bec7f52e9ef0c31a1e90dbb1c4741883f355dafc32006cfa4e5b7aeb76abc34a836d1df48b2ec559e3785387ab1bf7d69de0f4502401ba91fb381a9d1dc2c462e14e9260857c312d7831b0746fed43d9657688661899c1fc7f66e847a581c9980438e3a40930d8901d6a8c79c2282104e5aa27a0c845bca63c447fd43afa55f608034e8ebd7bea89e97d5c51b3b52bdbac90f9e118c5bb9be83c48cb7e3a14253299064831a929ac3622fc65361d2d6cbb10e22dab57b8d14638891f8caeb87126851ff892026d45e0ddd03587f88f6e4e27345f42ff7b1a0ecde75e654df45aa336853c76ffcc28e9fb2620b27d7699dd1e92941810d6c678f918040f213392cc0ba9f01db8fd267b8fa206d11af7fd360b2e139dd708fd13f8ab4feb988eb92178b7839ec219360736ea8325739dd31af8ea9b46ad62d42cea2ff20086c98ec8fb968f83ad3b34065da8f460ff83eeeec6fd5bb079f5925b2ccfd68d11c0fb700f8bbef69a826cc802c46057de39b47a59392b20d5cd70cfc3342bd098e8355a7423a75af435396b9f510e892f300acc6918cd0db518bf8ba44a98c348747f70e39f319f012e0c35ab41f5b755fa356b81ee9d4322dc290011386e470e666f973cc61e8c0443af38e2db3ef30eba2807555035aae9cde5f20647b87e5aa3de8d9f71fd1e84ed2fd90b5ef555c24129b31be3a87a16cc80324803ab07f6401c5e0886f09a45ea783185b4bb1f1267841bb3de8384e438e3ff53ff2f70425107e8cb042493400b699f239f4885c7929803e414f58852d016c9bbfab02bcd883b8cba47aaf0f31fc8b8ab48552d12920ce08fd127f4d058694e83c0862b2181f66ba9d98b35e9bb4a9be8ad3fa39e03f0f5714a3e8f3d2f998a47a8a5081d4698cf047d300790084f2b4319ad1a3dcc5854690434e3690dc9c789d47c034489da5b84b89f2d349dd36591d467e5a392724de22af27bd9e518d3a80c8ec08912f1a786ba3249d99d6910e31bc26e7d35cce5cb67c5e6ba3aa7a513af1ba7e6dd953b48bfb8371fa8a8f8bfeabae3bc82e8cefe9b5efbd925cc0facf4eac208eb4deb2838bc8393698c40f67e0d437e1c972886332746b91a3bdee38b49e534fb0d812edc3f743989a4a9f8094cec37ef56f05bee989bb9b5596f91860ac6bdcbc3742541cbfbf3495b10ba5e578fdf75da65a3a70d6471c8ee16c23699a9e84b8f95abc043bdc14f1ba4236ebf37154020ff54149206049e64daf87aa279a56ca4cf1c8557d113a2b890efb41585fdaee256380e6e2a04348ffc19b60fce3ddd845b45fe599b62d3cb41cb34d5ba564f179b5292a56e75a0cd800794414dff1f8d2fea2a8a9ef74783579f8791df416cd967a609f9f058261dbce05993d742409b11708bcf45c36822e7e0d57904f75dc06babd9d18c09637b96cec6cb659a3baac37ef2ea99ac9bd189921bf13c65b8a4b78a6213c17c901a76bcd0decdccb127fd87dc17fe21376d90f085497a9f326c7e9684e949ade1cdb28218be538f6774ee5b1edbd314063b4fab1310f3ce6c42c195cb593f2b34e026a9a7481af021ee39da44c89ec0342dbb7de971968ac361b07aec9e9116997a86c961e850f34967680840d10fb911c1c8cab1b71d71f02e7ce7f132b3905a7154232dd365037862e0c57d5d2ee1acd0d3f894163acd569ad37c93cf74065bcaa9abe3a0654f1fc67cbd0034b852cec8b2e10275cd4d89fc255d13e9d64c50b056342c3343a461deda82d51f5b203d0990a4cb6cc08afce0412173b380b73caa765c11ab92ab8ee4edf718ead289a2a89f8cb2220a99e8ab4aec7add4af35d96107b56c751d012f6074371d667f2eb3a0c3375b3dd5292c3b2857b78a8147e495aa39ef0ff1a28e2c0192054ddbdfe3e66a6e5b91ce844a62ec7ed6238420dac4db1ae416b12a7164fe175c59e53f697d140a25f3ec7f838803ca694ebb83b0e0cfec610b1a10a826aa842520181f3cadfbcca86d6927be6c3ac4fe87874810cba13c2454850a775e7d412ae999b373075f7dccd634a19edf0e6edb662e0945b04decbf3a1221e78a3f5d338c137b112d4f6a1f6065b55d39537c7e1edd12908552e4124c881c2fcd7c97dbfc7a15f27a897e48954d7930cbed360fdada2f38ec858f98b5ffe64b806d40653e0099c48e38b6b9af29abb56ca22feb15c82206511b7d42c8f229d7e30157b4355399c5ce09cfd67601989dbe8683e85f580a124af3afc7aba1c442bb027db77191429e5e73f3f634dcb72cd1acede6f3cd47d0b756886b5b9c14156d13c6c4916b09ccff42a50b90f7b9134ef48df67c56c926f73435ca38f47423f4cff6687d49425130debb7d066e2d0e1cc688e09e355df9bb2c6b4695bf6ce306e179569126e89e5203803e270066d467bddd7c807d6d044c4207077a9605a57b96e31682c40f240e10d34d376c7b34958ec2cd75bb0b51fbca0817332c9ec5efd9cc29ceb3630620ae44860025a542e90cf54854ef9e991919dfbbf7c36463e393f585c6289db45a29032d05658427166e43ca4d040c2cbb3bf8dbbc1b9d9f59c7a6b1782e54a5ad5cd6741d3d3d9b8f32f26ff3160dcdf4818f1f507d95a64b0a0af7a26cb59acc40f68066d3aece68a9f1c9e7abf74ce44ec37664e7e7cabaf76042342d25e9122a5e9c1036286f256f6669da252f28e7f0f80ec9ebba672a48ee5db24d3900cb8caee464dad19a11bea509ceabe2b837860f935c3a910608ce60cb95e91924139ff42d0568312bc688c8ec933310bd8bfa6e3cdd7ef3acd4862d215c2a37354216f6c218d174c4563e64195c258dc0944e4076c2a63a1d49e6b89c013b64aaed7a47ec5b99c55346c3925d6bcc86347d5463ae518bee11f03418ad7f0b196bfe45c15882c8b24d268553ed7178bd1ca0e4fe6b6ff14d57324f8828e01ba9944eced692ae523704237ae1e5c03e90adbfab8949b1b87d6dcf73a69e03ea39ecceeb8a1acd655419091b79c3c3fc399f5c626b358854012c4c9b3a55ec2030fef61195d00522f2fd88048cc8138ee95c46ef61ec20c03a75cd97de52b18d67a444cc6dc08d8abf7a6525ee019782f9857b7c30a9b3c95120ac11c4264b5a080c39df9403c007e8c80762ad8f925f41b920387b8a178087d37174f00d5c85ba583020d7ec16657da0577ff7ee229d182871fed970dab3adcbc7f1dc6d1eee91fa0cdebdd2f5904357730f8e113d53ba9357f9dc617fd4eaeadb578239cfa8fefb3b4c4aa0fc473a9a5f767104ca2245e38c9f5edd4954c88d1f45cb8fd7b16dd26549787339dc95a72ee642e149b9f183e8aabedf08686f1770096c03a07f51874e87bbe60b6bee8d54581da463f1a6de3b2e25f3053d11b519a199cc0aa3f03035b689e8582f9f1c2eb38956db0179239d2f3703df6972ee17a53c0b5863ba7962959dd61abab7fd71df441da138cd506064a9868f106df8c57dceb71d1f3c835f43d3d50267dcd3a759da4e16493b6f9b5370d70e884310dd13d145bf15ce0f6f1b0cab5cd7b6667ab6b9aa60abfc9e8d87108d2623886e4eb25846748122f1e55eabbf28134a5093500a7a8e3d611b5cf9c0223ed65957b8470faba5d9406a6b29d16ddc0299f8c72d8c3b88c89ce76e9d1656b62e00d388c591f6b333e5582ca17e8f456f7a595c919f73b965a4ffcc31c43212a046514577bb6e5b2ad00ec715ae3de33cacc4dfb1f8c9449b651b8831a875e86a805accdfa72ecdfeb0eddfe430f355f82eb7259e5eb118de00503fa545b12803e15cbcb13f6b85cd87c22f88356792b9c6b967ce0559b2cddb0843601b5c33595faa7e2eeb20e642a363dfce66a15a1c20e7e1dda0ba13a592280d0e705fd4bcc9f1ecbe54163d5e541754e2a00848d262c055aa4f3cfa8035109757edf9f803351b36cf2b288a0c6fbbbd799976e4ccca0725ef8f70630419e7e5617c4f5804b90275f55dea37d0aea8959b8cb5d9298ecf71d39dd821f285d79839b844e36d01ea90eb44f04d3f199ddd139e0b1ba93dd26d010b59123da8f61eadcd97051a093ad72922014ec1bc76fc3a5c5846729f0cfce57120e278554fc0d8cc5528ef90c7319956c8650136a328f26c9eca16775225aea4088eef26a87baf3d3b4678f5da36cba7cb31347b8352cedffeb0c9db95bcc09d8ee77fd0d33f41d471a4183288702285190218fc1c0ad555b15ef374296c5217de8cd88fcb246628e345b2b617b853483d8d322e0a75cd662c6970e433096c231d2c4ceb25f3391f997d6eeecbe5f675588932aa9c4ad6cd88fbf0109234aa1ac95488400408ebee9f95383e3428eb87bd4b91a7caf676cf27f01906f1f7d9b70b298cfa13931e40aded6b72ca53ecdc7b7a2a47e32a5372659fa42f59fc9ed84cb3200486580ad1b3633388db4f8de3a4376edbf06faa34bd6c847cf8bf85303e88c56738b58905e13ebc22d3d0c3fd6c34e1890dd83d4767eee0bfca4c0059815fbfde9c13372b13390d7b5a1ba5392c3cff0435207bb665a41a78c486b54db89bc88f66b01233d94e87f0976ef387b9b7064a577592fa59daee1fce21919a242fdbc2eb74e1daf4a4072f531ca167e69af0292706365e024c651979ec65f5dbf1922c31ce18cb6a4ba54144d93d4136f547a7846de1b98f351fee0260fd1b6df63760a46b518e2f9b3e011b9112e1baea4b079d2cc81d18ba569e436090fa383385b80b3535359dc0161288d94d745158c46d13503338ce5acdd26712f91d52fecb22669e563df89a648ef8f5067df5c8064dd605ba9ca94a8ff8432b1fb098ae63765cb7e16973523f0a63f65a2a2d4e3aeaa73062df36d61501e13805969c868d0b28272bd1e14ba315194d90b63bd5b2b62cc84c36ad855040bf65ad5c2e0f1c0710a9b2e0c2ab5530f18475934fa2c87bdc367baed9784e5a7ee789217e51aa0effce7378075f74de8fe20e4c3e331dd94e76059d481a3d282f7e867415015e69a562d44f39be0a65b37e4bf6ddb10cffa1d650a90c90df18d463282d476b810362754ff3c93653d70c6e9f7429320c2fb6bd4ed3f435a48060f540fbed5bdbd99558db147a03ba5d7ee5f4e490d8d963260898521eee40ec097bcdacb59ff87e3946d8ee91194ebf1198e94a0b10a7658d4d6d0ef01ed9e0b84f2af3a29f423146058b83429a866024ad1a11a5968f8aed341191b75f349e3759206daac598017fc9cb6bab7bfe36b54e06c9fded91e586ccdbaff748419d2efcfa2e6226969a2c1973dba5f58d4236bc29cafc46f3c680c3c848d73d71f84156641727e6ec65b7693ec0d7843f9b27ccdda7e668f397d8285f0edc4b4944171aba77ca880688bec0265a400b9f24fe2677bd11782781a1c6596139ea9625e00865651216aa77821ec504b9c5d373767c34e59c76eee92bae2b1790fb682c6b3e2e38c6b9105a3960a9fe4084920738e852c960f1d9e0bcea6abcdecb7d1655404cae15e1452508c64213ec48a32adf2fa0ff0f152e79c131e6fe92f0aa4bdf95fd5e6d73cee37b9b3ec5feeca76eed0e82d9d0c3cabedbd1626a0457f31bf92c6f874dc46bf3435a5ce049eb1f67f570e547abe6bad336f8adfdc716830e43b58234ec88bbd2cd85e3b00ace211c65725a241e1fbe5c4012509ef4c00989aee21cbd01838b3ab194badcc8bd84ece653bd7050b157f31cf866e39ced7bc5ee8d9b60b61d45530b5d17b5b80e13d8e6a534b31a2ee6dc70712ac29ca56f5c41009582f48401709304dfede5502b3b01e93aced92c82f9fe3357b082b7cf54c7e9e60da15a52cd168366c485cff1d56e187ffdd56b8fd59f64ad4f95434754e78d5976014ed0c5fe9bdf678d4682958c2d451ede9ad097d783e89b3b5fd40bb65b665c693b16a1ec8d9c393b86138354d5d456a2db15521636b46c683ddc0816fdd631d69faa7f7df22a6cccd286874055653b331da12c91cf665f41b9a61458252bf9248c3441fac853d9668565b328e7b5fe3a7de229c62972ac4fbee3e1df3a559fd650c9c02eca348e7d6ced23db1d8807fb7216c5bad5bc0bb77d41723f18e08ced2c871e0bab05082a481d9aa4ecf379a522fbd65e84427e1c981e35001b853baa5f877e69464ae64e1772112bc7df65972520fa71501659f9058142dfc71a06c9e3d41cf3b2970d43ae5e135873df8acd909ab9be9b50af13eea8f89db1d7bc98d18d8430faa019b8df9b93f51d36628465f34b3152ad7f76a71d4965b9539041489d91d3cc5694397667f8cd6d303cef86b707f006053ea7e8b60d897965e8c1717ea72b3afee84eaffa7af9a114e499b1051366c051d2c5ff8753cc8d4e5fab9b1c15867adda9674d39577606fe5abcd77d9d22b62a423f7e0766150023675b2bb831ab3ec1877cc53e4b5879c6a09abbf3c14777a340325ed05090ba82a249a18f5c211b9c5340f2c48e73f58ef364697eb7c92998d4454133f5ed46275ef83801a53cb357f846b7f4df8540fb34ce9857d06e43a3f4b49542b8fc1e474a1260c2e79789ec997bea05a467fb4f3712f0539427e2fa9b2801d68ff4a1125d1f54b4e0734868b867ac1ef128737b48f9e9f4345243e2587b4680eda7de1dd1201c7f77b4dcd84c4541cad1fa7abb3a1bc8cb334b01cadca28ecbe0ecf63f23b6a4065ee7d70d974ffd5bcef2f87a858bb89f99fd5e0c58261287048dcb015e89149c296ff2c449a38ef60cc978d3090e481e187a872d8465244e06ec761b9103debda713888103366d14241978c412cbbc37dfa369ba817fa3c3de2214e57972237f2120dbac6cd5cbde8ae230844dd5b88414104c641218831e8733fd6b7255b79eb2898f89591c99f7f9c07c1cf1ed33e0f082c673a75b9f8d8843050d5d94dee0c6295d6ac73085107fe069f87fa1f986baa0344195618ee266ea5b6a19f71bcf25b50d8a0181712bd8cb71c2182ef391063d6b6a89422f452c81b53fefbdcd40cfb760e0c127974dae8c297daad29cdb309cedd5a90b1a5d9f3196fafd26f5fd5f81057d71ef4748c27937c1cda629c43d1a86c40ea24dbeba05972af13f36271d5dd403ec662a5d2737a4b17620126706769250d3a4cb18daf26803c42a3be30cb1cddf4c12e5ccee92eafda6ebe1e5be00c21ecd4541b33d58c764f98ae3ccdea6c87e9b8aeedebe0b6f907167e54fec84dfa54969b8ee3b81b8be1868031cf8dccc3725ef5a8935c5d14073fc2ce62da6c4df0f49e853d2576e9736311e7074f2bf45949fd8fcd5f9f4c3c4defbe89bbb89ff40dae9b38c87eb2ea2bd81b02dadc4cc91c8562631ae9a4766eee25cd43e74799e4b4840de98cf68dd343b48029bb4bf376e8c0547d809c8966cd2109dfd220ca883fa699e778b5a07e0d8712da7daf086802ed5f914688b0fd1172e63818aca5954667e5bb5884a900060add60097325257d510715b843e19169af0748d6edb4b10cd0b82bcc161570e64184a5e474bdeeb08e8dc6aa5fd674485d1a397b1a2c5aef2b843b70b5a30cb5801cf995ce981d93db553e68d416869901465cbab6fd55e56db0ecb0a1953159e334ecea62254fd2e1e23d152efe2a007fd245815703c56eed97a7e76779f65ca3bff1f1a03dd53a02a89dc2fb665c63ecebcbb3c9460e3398e9e424a300e7c9946d66bc429a7092e424070c228c80d4543af72ecfc1f3f2c6d3538642b15e8079aa66f945d2dddccd5975d006457e79c2dace84804d78163046bc94e6205680818925c89ec883538cc643d6a53a44a7c1d11497106197b9216feead80070261599eb2bf12558996b99adf3aea5c37bd0a59e9089a394325cdf7c4d50abfb33e881f65926e41e01c7883c7ed2d0c85aa0a120fa71897569eed05172196a60df16c27ab16baf1943d17b302781602cb9cde6f30cd98a79985bed522cabcd03f33a344a47797e124bd739cd9a957a2072c4b62bdb3e2b62fae87e19e7103d2e0d451f0536eff13a51531e0c0b03dae83753228fc423ffff6f92f7f84c086f78f07306c669d5ab42dce3dcb285f42ab87d55413f620887f6a69b95e02f10d1ef823fc7e82c62d4cf21c1bb838ede0f75b605f33c679c3e5dc7f8ce4562f599aa102ed47ba3d4cb071faf13f1591efac653a4060d62a04af9c5bf32bad115a81543cedd11d5b4799f0f0f0f22d59737dfc0b7b4c128d77b90db271cffcc0fd95e3cc415b2ffe1770a3d994035cfba978facf1e0f94b52a654a76e26cd323f6cb1c0ebc55b61f3985ae07dee3791746f187fab520b2c94ee595b341b55bb8032a8c3632955b8961cc0bfcde61258d84e5b816cfb54154d3f58ff0ced787254fcb20ba7b10a9c3ef0132c5faf389276cd001f940baa6f69d3d80cb105e03c37210ef0a0709c4b736514f21acb169389513321f7f172d322dcdf21671754b6890b64d12279189a5308b15b1bb4583e80fc76e1ef9226999f182141c5a7a44ffd67855f5f9f00591485d4e03dafc4395b53898428b83a635a60f055163a4aabd2bdc4a04bb1c12657574d7c72a2ec31606400b30ad7ec664e34b2544ff36c3bba34510dd6af5da417a7ce5cf651d7d765cb9987d75d0892d7aaa990fbcf8ba9036c5213993aeff239a5a9806b7ae07b096bd93ee74c8b5564fcdccc791fea0402ba048d7966ff19ec5d9992caa6ce10383be5bf52090771ad41e4fed0104f506e7c20603825a197b99a716675352a96debb90ba9d30a1098134ab05d54b11527267c2c0be584b2c7a96e38918c51409c78fed8f148d235cbb0f7f37a7321a208439d257e19b35811d4b044ead37544d29ea0a778bbc63ef12396eff853baef08a336cc108cb77617bb645b5b18889818d8136b087b88e3f818903443d200f3d5c4ca827c678cfc9199e6969d7223c0c8db851355a4ed85f4c912605df40e5a8d63274e4bb17ac5940aa5a3bad64b93023de7477588f34df7e43b4fbf089c4fd165056f09167f7c8c0ad61daee500adec8fdc899597c0eafdedd42915fe37bf82b73b1b25aece1b285032234dc63119e26c83530bbc3605343a38f3f0c5b72dfbaedef5db68cf12e0867560171440773686ec77a3abd9f59964bcf2ebaba5f913eaace56b012c5f2a3c834bf2be0ffd7bb03b57a803c8c30b22f1034a08755b33180e7ed72fc5c7548b9cdfd7bccc3928a7383a613f57c3ba66dd828ce1b3b0532d8347cf3e3561903d0c33261962993b0d94cdc8a23c902fc0d8757a408c1415ac4c7f7b6ca3bb87948637bf5d98cbb1b45f721a6df7bfef85574bb9f9a80fafa3ecb72443027ead45db6820270008927fd9eefe9184fef9362631ea97f2ec2f21fe0a21e532cfbe9f6aa0c0e1d978db69c93b80096d902e8d3f5e1fa9d5824d1bc177c4b55fe417a2bdfefccb79ba599e0f88985e3e475c6a0c3e01627b5bd593b61174f510b09e114d9d1a54e5ee30368e2cf7dc4e6a53a7fb966d41e6f8e4997259710224377cec9be582a1c93dce4168f6f60550ee89b5fb8a4a0ecac4f15de1b095869077a632e87d63453e50da3882809dc79572072fb700f44cb44a8c27af944510bd8c631b95809d8004b631b43ef6429e2d5ba8740a49d0cad1a9fb66f182e9c0a19c9bc3f89119bc626993772253ab1298f3009ced1032b785e7e5fe94b5fc32216d8d5186ff29801a542b2901153fd7138280318e1ce3377423c9e9e98de8356a4f39a3be6346880fb10e42f622d8ef52b720ca3761353ac8915a59dbbe54333f81709d300cde41d88f6dd47b6ee0dde4f3502a399bf4b2cd1602f43f83301a37e4c37ec3ade3b4ad151be584e6823088ee754211644ee9ffda24f11062a8c1670a8c7456d59328a52026647c27fd1237093cf8c97b3b2e0e3cb7b568ed14759a5d9b2ae7a6d1d476dcdf79aabc2f2ec75cffb931dddeaa6fe94dea0490257b59a94e84a00a2659c802e9217e067c43dabd092e35c4066f6de236b236e70edf3a2a1e4754a24bf84cd0512b8a694e7be95a1ee0836ffe4e7d4c02e69545f8a667d30cf93bb3ae0feff8bc4c03420fb9a8ffb564c960f52786dea6cb85c74b5a3aac29174de2e6c4054abd4e62ceba0b46f1c4394d97193db39414ac6d5137846964cf5ee53bef85831409363f57b68f5032120a74fb339f004203484c9361dc313f5f80ac00fb3ec57d93b225dcb72c5257340341e989b968a1a7056c0d6b7bdf4ecd202f3af1b8ff8fd58de874b91e557f8217aa50b83ba832bd4ef6b8be7f54f5d0cac46b559f97ae4d50c3d25af218be7cd80267e5f72a580e8eb61342a72e37d7427a69aa8033a945f44afb168a886a6de105c7dd1b9f40f20784c7ddde838d2bf850d0a98301a7cf9162cd708c31e1c191626f64e0eb7a6b6b27764b1e5e3249e22757c90b5b0b95d3babe96d99e6eb002ed93bd8a2d1a0e4ba3b1e598cbf32630ea32e1192838f10b1fe3f6981fa63300192253adcc654236ec70fe4cb9e4aa8a9f30ece6ef9d8aa4295089b7ea9235f05e5142df7d4c5d733fc76e42ac79126f9a65a2ed270b02bcfa4c6c2080cf93f3def4a71a6487dbab9e263d4a5ae6646b5bdce6b33ccdfaa3b71dcb882bff25d4a9a695e5d1994dc465930a1568310ffd5b95b1203bb40a6dc12ee4dfe96420b4c21f46b86d4a7df0a862b6818843fc6790b8ed4d5a15fea27344c5e9f6d61caa9e79719866d2c7ecf80cdf4f517cb6142c172b725e9c1188f98cfee76ad36c4bbc765f828245ac2387ba34fd7f149f72ea81af5dc47676170da91e3780ccffa86cee94c888c3916078c141791d86c211f0daee7ad5d7bf5ad7988af8334da95858c4bd215704d10d156bc40a18058a0d63b54ead6c068a04e09017b9e711ddaa82b0744db6c684763626105f419ebfb6126bd8ca2a10a914fd5703121e38ca6c2571fbf5b2513d2e1bfab310698a2ecce70a74ab370097105f35b00811d4d93ab755da956c02ce54d83080caf2509a4984cdd496b002579feaacfc4ebbc41c1b7bc406e031f8015ca62771814bc0068b66a8cb8217a34e257fbeb921bd078f5fae092c118bf982f4da4feea2ace47b1761f86c88351c8f227738aebe4bd7f9ec24509a9179af651a524bc45b7c70fa8c53aaf386ba7d076a7fe7be735ea3df505f9f3136b53ac6e94d2ebfd891ee4129d1ed8571c1160e7698d92b67f43146319b4771ed39d1674e390a62cd3bda024b09b8859d223df6c999ef665fb4decbcd0b5e3489855d370c8234ee5c4d54b536d4ff80f3fbaa7fca403bb9725ff47afb0d17a231f1486a8de7a5fbc2ec046519a638cb488caf32390a46affe2e293006cd2037d0842723c9de3f037380f1abfd9da38edfa9b765cdbd3a5aca7a55b2f778de3babd6db219cdf43fc9c9bd95160b7fce5f0d863f826e0ab3ab48ab85bf5a7961e44fbcdabd2764b84dce35b47ac208cfe146cbd018b2e24c62e2466bbdf538c0cda0cfd58c84960d577e94a8052f2884a2646ce003bd55826004c4f6fd407035abe0de714a125c723b0216e55641edb501ae108ab64ad93a0cf089fa72494c29e9de9a4ea9daaf2607f5aab6951c36c00b865d9d6abc63df067ea85cf3351dd7435c9c425d2489c9fc69e8a15b34dac26560a4149231d653161b2a54cc961baa2537948e0bb42d620424d767b9d898e9a244fb05b9d93916274c354c0459cc46382f9074b746486a65af04c6ff9d5e545d5542b1cf0bc1563403a31c285a4e3deb8756cd8ff76472500599422d94e789253df1c81dbfa7020d006510941026e3dfd4ce672173c043fba50c3dd13d3f6cfb007f071bdb71f58a3ac22c5d7e985c4b9735f1b25b15924014cf453e7a6c51dbfd786199f1b4050f7366fd49043c380d502333ff3593bf186efcc9f0220db0f7ed5f4e42eabd3994ff50690e36221ab9a0fe89f8a2eb0624934b7a38fa2dab10a3bcff41c499981204072514ccd66f8948eea3f879bb1d1fc6af9705b8021d0773bdb647b1875c0640cf83af7f6b11d04a637ec0246114cb81cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
