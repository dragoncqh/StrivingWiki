<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="zh-cn"><head><meta charset="UTF-8"><meta name="copyright" content="(C) 版权 2024"><meta name="generator" content="DITA-OT"><meta name="description" content=""><title>CxImage图像处理库</title><link rel="stylesheet" type="text/css" href="../../commonltr.css">
<link rel="stylesheet" type="text/css" href="../../common-extended.css"></head><body id="CxImage图像处理库-254885CA"><main role="main"><article role="article" aria-labelledby="ariaid-title1">
<h1 class="title topictitle1" id="ariaid-title1">CxImage图像处理库</h1>


<div class="body conbody"><p class="shortdesc"></p>
<section class="section"><h2 class="title sectiontitle">CxImage</h2><p class="p">简介&amp;许可证 </p><p class="p">CxImage 是一个可以加载。保存。显示和转换图像的C++
类，非常简单快速。</p><p class="p">class CxImageis免费，对于 TIFF，JPEG，PNG和ZLIB库， "如果在产品中使用这里源代码，则不需要确认，但会受到赞赏。"</p><p class="p">CxImage 是<a class="xref" href="http://opensource.org/" target="_blank" rel="external noopener">开放源码插件，并在许可协议</a>许可。 简而言之，这意味着你可以使用代码，只要你没有声明它是你自己的代码。</p><p class="p">版本6.00中新增的内容有什么新版本？</p><p class="p">在文档中报告了错误修正和增强的完整列表，( 请参见 doccximage_history.htm，或者这里<a class="xref" href="http://www.xdp.it/cximage/doc/cximage_history.htm" target="_blank" rel="external noopener">链接插件。)。</a> 下面我将重点介绍一些新特性。</p><p class="p">使用 CxImage 版本
5.99编写的应用程序应该与新版本同时工作；几种方法的接口是不同的。</p><p class="p">旧DLL链接的应用程序不能与新的DLL一起工作；但如果需要，可以编辑声明。
要注意的问题是 ENUM_CXIMAGE_FORMATS: 在旧版本中，CXIMAGE_FORMAT_... 可以更改值，具体取决于相应
CXIMAGE_SUPPORT_... switch 所支持的格式。 在新版本中，CXIMAGE_FORMAT_... 被分配给惟一值。
static 方法，如 GetNumTypes。GetTypeIdFromName。GetTypeIdFromIndex。GetTypeIndexFromId
等，将帮助应用程序管理新策略。</p><p class="p">文件格式&amp;链接的C 库</p><p class="p">CxImage 使用这些库的最新版本： ，(
1.2.3 )，Jasper ( 1.900.1 )，LibMNG ( 1.0.10 )，LibPNG ( 1.2.24 )。 LibTIFF可以与链接，但
CxImage 分布( 3.5.7，已经修补) 中包含的版本可以读取带有OJPEG压缩的图像，或者使用非标准位的bit。 你的选择取决于你自己。</p><p class="p">j2k库( 现在 openjpeg ) 和关联的类 CxImageJ2K 已经从项目中删除。 通过Jasper和CxImageJAS支持JPEG2000图像。</p><p class="p">CxImage 6.00包括新的类( CxImageRAW ) 和新的库( LibDCR )，用于从数码相机读取原始图像；通用文件扩展名为：
RAW，CRW，NEF，DNG ERF ORF ERF ERF，DCR，DCR，ORF，PEF，PEF，PEF，PEF，PEF。 LibDCR基于棺木
dcraw.c，并提供原始dcraw应用( 查看"dcr。dat"原始目录中包含的项目)的相同特性。 GPL版本 2的限制功能被禁用；在启用受限代码之前，请阅读"
libdcr.h"中的许可条款。</p><p class="p">CxImageRAW 实现了解码图像的基本功能，SetCodecOption 控制的唯一可以用选项是插值质量(，)。
DECODE_QUALITY_LIN=0, DECODE_QUALITY_VNG=1, DECODE_QUALITY_PPG=2,
DECODE_QUALITY_AHD=3 )。</p><p class="p">CxImagePNG 已经被改进，可以读取和写入所有 PNG_COLOR_TYPE_...
组合。 png带有"像素深度"，每个通道的8位将被转换为8位，这是 CxImage的主要限制。</p><p class="p">CxImageGIF:
更好的支持读取动画 GIF，现在可以在单一通道中解码所有帧，如果启用了 SetRetreiveAllFrames。 CxImage
演示了这个选项，并展示了如何使用带有N 个图像的动画 GIF ( 当程序要求"文件。 全部读取"，选择"取消")。</p><p class="p">CxImageBMP:
读取并写入 32位图像( 带alpha层)。 CxImageICO: 读取和写入 Vista ( PNG ) 图标；以及添加多页图标的支持。
CxImageMNG: 使用alpha层读取 MNGs。 CxImageSKA: SKA图像格式的新类，用于某些视频租借应用程序。</p><p class="p">CxImageJPG: JPEG格式子菜单的新选项( ENCODE_SUBSAMPLE_422, ENCODE_SUBSAMPLE_444
) 为 4: 1: 1，可以设置为4: 2: 2 ( 介质) 或者 4: 4.</p><p class="p">下表显示压缩图像中不同数量的工件，使用不同的子采样。
4: 4: 4 子采样对于边缘清晰的图像非常有用，以减少JPG压缩的典型模糊效果。 </p><p class="p">原始图片  JPG图像和文物 质量
75，欠采样 4: 1: JPG图像和文物 质量 75，欠采样 4: 4: </p><table class="table"><caption></caption><colgroup><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">&nbsp;</p></td>
</tr>
</tbody></table><p class="p">便携性</p><p class="p">类和项目已经用不同的编译器测试，从，VC++6到 VC++2008，BORLAND C++
Builder 3和 6，部分与wxDev-C++和 MINGW。</p><p class="p">所有库的( 感谢 Eric Jesover ) 都提供了UNICODE和非UNICODE配置。</p><p class="p">第一次用户或者作为一个基本模板，没有完整的演示项目，提供了一个没有C 库的光版( <a class="xref" href="http://www.xdp.it/cximage/600/cximage600_lite.7z" target="_blank" rel="external noopener">cximage600_lite</a> )。</p><p class="p">控制台( demo2 ) 和CxImageCrtDll项目可以用VC++Express2005和微软平台SDK来构建。
如果你得到像"无法解析的外部。"这样的链接器错误，检查所有的C 库是否已经编译，或者将 gdi32.lib 和 user32.lib
模块添加到LinkerInputAdditional依赖项Dependencies属性。</p><p class="p">CxImage 还使用 pocketpc
2003 ；为VC++2005编译器( 感谢 Vincent Richomme ) 提供一个工作版本和演示( <a class="xref" href="http://www.xdp.it/cximage/600/cximage600_ce.7z" target="_blank" rel="external noopener">cximage600_ce</a> )。 对于旧的嵌入式VC编译器，主要的限制是对异常处理的支持。
为了克服这个问题，try。throw 和 catch 语句已经被 3个宏( 在 ximadef.h 定义。) 替换，并且使用 CXIMAGE_SUPPORT_EXCEPTION_HANDLING
定义可以构建库。 也许解决方案不太优雅，但在禁用异常处理时，对源代码的影响最小。</p><p class="p">小型端点和大型端点平台之间的兼容性对于构建的格式(
bmp，ico，tga，pcx，gif，ska ) 来说是由 ntohs 和 ntohl 处理的。</p><p class="p">演示</p><p class="p">几乎所有的新特性都可以在主
CxImage 演示应用程序中进行测试。 这个演示只是一个测试工作台，即使它提供了一些优秀的特性，它不是一个严重的应用。</p><ul class="ul">
<li class="li"><p class="p"><strong class="ph b">CQuantizer</strong>: 该类与 DecreaseBpp 菜单一起使用。 在以前的版本中出现舍入错误，在某些情况下，白色颜色(
255,255，255 ) 被转换为( 254,254，254 )。 在新版本中，这里错误已经修复。</p></li>
<li class="li"><p class="p"><strong class="ph b">复制</strong><strong class="ph b">/</strong><strong class="ph b">粘贴</strong>: 现在粘贴图元文件图片(。例如从 Office 应用程序中)。
演示内部使用自定义剪贴板格式，以测试 Dump/Undump 方法。 复制工作在活动选择上，使用 CxImageRemove选择复制完整图像。</p></li>
<li class="li"><p class="p">使用浮动对话框 <strong class="ph b">FloodFill</strong>: (。ViewToolsFlood填充 )，可以测试 FloodFill
颜色。公差。透明度和选择。 不透明度= 0和选择启用的情况为"魔杖"。</p></li>
<li class="li"><p class="p"><strong class="ph b">图形数据提取</strong>: ( Filtersgraph数据提取 ) 从图( 从扫描仪获取或者从互联网下载) 提取数字数据。
转换后的值粘贴到剪贴板中，可以保存到文本或者Excel文件中。  数据提取对话框和结果 </p></li>
</ul><ul class="ul">
<li class="li"><p class="p"><strong class="ph b">RedEyeRemove</strong>: ( FiltersNon LinearRemove红眼睛 ) 删除图片中经常出现的红眼效果。
你必须选择瞳孔周围的区域，在这里函数将过滤红色通道。 选择也可以是矩形的，也可以包括部分虹膜： 过滤器在围绕选定区域的圆形区域上工作。
 原始图片  瞳孔周围的选择  RedEyeRemove 后的结果 </p></li>
</ul><table class="table"><caption></caption><colgroup><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">&nbsp;</p></td>
</tr>
</tbody></table><ul class="ul">
<li class="li"><p class="p">selectiveblur/unsharpmask: 这些非线性滤波器提高图像质量。 SelectiveBlur 消除了保留细节的"颗粒"噪声(。jpeg制品，或者数码相机噪声)，UnsharpMask
增强了细节，而不增加"平"区域中的噪声。</p></li>
<li class="li"><p class="p"><strong class="ph b">自定义线性过滤器</strong>: ( FiltersLinearCustom ) 为 Filter 函数( 感谢 Priyank
Bolia ) 测试新内核的小型图形界面。</p></li>
<li class="li"><p class="p"><strong class="ph b">直方图</strong>: ( colorshistogram。 在noisy的测试中，有许多菜单可以用于测试 HistogramStretch，在有噪声图像的情况下，threshold
参数可以提高算法的鲁棒。 "半饱和"还有"全饱和度"测试 ConvertColorSpace。Histogram 和 Saturate的组合，从而扩展了iframe颜色图中的直方图。
 原始图片  + HistogramStretch(2,0.005f) +"饱和度" </p></li>
</ul><table class="table"><caption></caption><colgroup><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">&nbsp;</p></td>
</tr>
</tbody></table><ul class="ul">
<li class="li"><p class="p"><strong class="ph b">阈值</strong>: ( ColorsThreshold。 和 ColorsAdaptive阈值。 OptimalThreshold
是寻找图像二值化最佳阈值的新方法，可用算法包括： 1 = 最大宽度； 2 = Kittler &amp; Illingworth ；
3 = 最大熵； 4 = 潜在差异； 0 = 平均所有方法( 默认值，并在演示中使用) ； </p></li>
</ul><p class="p">选项"保留小于阈值的颜色"将测试 Threshold2，用于过滤带有噪声背景的彩色图像，结果将是一个彩色背景。 AdaptiveThreshold
是 OptimalThreshold 在构建可变阈值掩码中的应用。 如果不均匀亮度是最佳的，但一般情况下，如果参数没有优化，那么 AdaptiveThreshold
将很有用。 </p><p class="p">原始图片 </p><p class="p">OptimalThreshold + threshold</p><p class="p"><img class="image" src="../../images/2019-03/clip_image001.gif"> AdaptiveThreshold</p><ul class="ul">
<li class="li"><p class="p">添加阴影: 这个菜单是关于如何组合简单的CxImage 方法(。选择，GaussianBlur，Mix ) 来获得常见效果的一个小示例。<img class="image" src="../../images/2019-03/clip_image002.gif"> 白色背景上的紫色阴影
 红色背景上的黑色阴影 </p></li>
</ul><table class="table"><caption></caption><colgroup><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">&nbsp;</p></td>
</tr>
</tbody></table><ul class="ul">
<li class="li"><p class="p">收费: DrawStringEx 通过 CXTEXTINFO::smooth 实现新选项，可以通过文本工具( ViewToolsText
) 测试它，检查"抗锯齿"选项。 </p></li>
</ul><p class="p">使用 TextBlur ( FiltersNon LinearText模糊 ) 后，可以在后处理中获得类似的效果：
仅在对角线或者圆形边缘上工作的非线性过滤器，不影响垂直或者水平直线。 在下一表格中，对不同的平滑方法进行了比较： </p><p class="p">不平滑的DrawStringEx
带平滑的DrawStringEx 使用 TextBlur 进行后处理  带线性 3 x3"柔和" Filter的后置处理 </p><table class="table"><caption></caption><colgroup><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">&nbsp;</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">&nbsp;</p></td>
</tr>
</tbody></table><p class="p">CxImage结构 </p><p class="p">在库的垂直层次结构中，CxImage 不是一个清晰的面向对象方法，但是结果很好。
总之，你总是可以使用派生类来执行特定的操作，比如 CxImageTIF 来保存多页的to。</p><p class="p">连接所有模块和C 库的粘附是
CxFile，它提供了从磁盘或者内存中访问数据的标准方法。</p><p class="p">一个 CxImage 对象基本上是位图，添加了一些成员变量来存储有用的信息：</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">class CxImage</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> {</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">.. .</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> protected:</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> void* pDib; //contains
the header, the palette, the pixels</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> BITMAPINFOHEADER head; //standard header</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> CXIMAGEINFO info; //extended information</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> BYTE* pSelection; //selected region</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> BYTE* pAlpha; //alpha channel</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> CxImage** ppLayers; //generic layers</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> CxImage** ppFrames; //frames for animation</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> }</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">CxImage::head
是位图标题，而 CxImage::pDib 是普通位图( 就像你在 CxImageBMP::Encode的实现中所看到的)。</p><p class="p">CxImage::info 是在不同格式之间共享的许多信息的便利容器，并且适用于所有成员函数。</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">typedef struct tagCxImageInfo {</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> DWORD dwEffWidth; //DWORD aligned scan line width</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> BYTE* pImage; //THE IMAGE BITS</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> void* pGhost; //if this is a ghost, pGhost
point to the body</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> DWORD dwType; //original
image format</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> char szLastError[256];
//debugging</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> long nProgress; //monitor</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> long nEscape; //escape</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> long nBkgndIndex; //used for GIF, PNG, MNG</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> RGBQUAD nBkgndColor; //used for RGB transparency</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> BYTE nQuality; //used for JPEG</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> long nFrame; //used for TIF, GIF, MNG
: actual frame</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> long nNumFrames; //used
for TIF, GIF, MNG : total number of </p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> //frames</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> DWORD dwFrameDelay;
//used for GIF, MNG</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> long xDPI; //horizontal
resolution</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> long yDPI; //vertical
resolution</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> RECT rSelectionBox; //bounding
rectangle</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> BYTE nAlphaMax; //max opacity
(fade)</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> bool bAlphaPaletteEnabled;
//true if alpha values in the palette are </p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // enabled.</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> bool bEnabled; //enables
the painting functions</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> long xOffset;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> long yOffset;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> DWORD dwEncodeOption; //for GIF, TIF : 0=def.1=unc,2=fax3,3=fax4,</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // 4=pack,5=jpg</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> RGBQUAD last_c; //for GetNearestIndex optimization</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> BYTE last_c_index;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> bool last_c_isvalid;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> long nNumLayers;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> DWORD dwFlags;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">} CXIMAGEINFO;</p><p class="p">&nbsp;</p><table class="table"><caption></caption><colgroup><col><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">CxImage
对象也是一组图层。 每个层中的缓冲区仅在必要时分配。</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p"><img class="image" src="../../images/2019-03/clip_image003.jpg"></p></td>
</tr>
</tbody></table><p class="p">CxImage::pDib 是背景图像。 CxImage::pAlpha 是透明图层。 CxImage::pSelection
是选择层，用于创建图像处理感兴趣的区域。 在这些 3个特定的平面上，你可以添加其他通用层，存储在 CxImage::ppLayers
中。 通用层是完整的CxImage对象，因此你可以构建嵌套层的复杂结构。 CxImage::ppFrames 是为动画图像保留的(
GIF )</p><p class="p">CxImage类成员&amp;操作 </p><p class="p">尽管有历史原因，但是由于历史原因，许多不常用的特性仍然没有被记录。
在这里可以找到类成员引用，以及发行历史，许可证和许可证。</p><p class="p">支持的格式和选项 </p><p class="p">整个库相当大，在主头文件 ximcfg.h
中，你可以找到启用或者禁用特定图形格式或者功能的开关。 每个 JPG，PNG和TIFF库将大约 100KB 到最后的应用程序，而 CxImage的影响约为
50 KB。 所以你应该只支持和链接你的应用程序真正需要的格式。</p><table class="table"><caption></caption><colgroup><col><col><col><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">格式</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">#define</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">所需库</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">大小 [Kbyte
]</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">BMP GIF
图标 TGA PCX WBMP WMF SKA</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_BMP&lt;br/&gt;CXIMAGE_SUPPORT_GIF&lt;br/&gt;CXIMAGE_SUPPORT_ICO&lt;br/&gt;CXIMAGE_SUPPORT_TGA&lt;br/&gt;CXIMAGE_SUPPORT_PCX&lt;br/&gt;CXIMAGE_SUPPORT_WBMP&lt;br/&gt;CXIMAGE_SUPPORT_WMF&lt;br/&gt;CXIMAGE_SUPPORT_SKA </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">内置 </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">24</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">JPEG</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_JPG </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">jpeg </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">88</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">PNG</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_PNG </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">png，zlib </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">104</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">淡薄荷</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_MNG </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">mng，zlib，jpeg </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">148</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">TIFF</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_TIF </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">tiff，zlib，jpeg </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">124</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">JBIG</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_JBG </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">jbig </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">28</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">PNM，PPM，PGM
RAS</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_PNM&lt;br/&gt;CXIMAGE_SUPPORT_RAS </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">jasper </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">176</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">JPEG-2000</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_JP2&lt;br/&gt;CXIMAGE_SUPPORT_JPC&lt;br/&gt;CXIMAGE_SUPPORT_PGX </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">jasper </p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">176</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">原始</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_RAW</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">libdcr</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">132</p></td>
</tr>
</tbody></table><p class="p">&nbsp;</p><table class="table"><caption></caption><colgroup><col><col><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">选项</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">#define</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">大小 [Kbyte
]</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">CxImage内核</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">全部关闭</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">20</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">几何变换</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_TRANSFORMATION</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">16</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">图像处理</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_DSP</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">24</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">图形和 Windows
特定函数</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_WINDOWS</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">12</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">透明</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_ALPHA</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">4</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">选择</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_SELECTION</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">4</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">多图层</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_LAYERS</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">&lt;4</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">图形格式转换</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_DECODE&lt;br/&gt;CXIMAGE_SUPPORT_ENCODE</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">&lt;4</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">插值函数</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_INTERPOLATION</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">&lt;4</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">异常处理</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CXIMAGE_SUPPORT_EXCEPTION_HANDLING</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">&lt;4</p></td>
</tr>
</tbody></table><p class="p">在你的项目中使用 CxImage。</p><table class="table"><caption></caption><colgroup><col><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p"><strong class="ph b">CxImgLib.dsw</strong> 工作空间显示了构建应用程序( demo.exe ) 所需的库，包括几乎所有的功能和CxImage中可用的格式。 你必须先编译所有的库，然后才能链接最终应用程序。
在同一个工作区中，你将找到生成不同库和应用程序的项目：</p><ul class="ul">
<li class="li"><p class="p">CxImage: cximage.lib - static 库</p></li>
<li class="li"><p class="p">CxImageCrtDll: cximagecrt.dll - DLL不使用 mfc</p></li>
<li class="li"><p class="p">CxImageMfcDll: 使用mfc的cximage.dll - DLL</p></li>
<li class="li"><p class="p">演示：demo.exe - 与 cximage.lib 和C 库链接程序</p></li>
<li class="li"><p class="p">DemoDll: demodll.exe - program - program - program - program
- program - program - program - program - program - program - program
- program</p></li>
<li class="li"><p class="p">libdcr，jasper，jbig，jpeg，png，tiff，zlib: static C 库</p></li>
</ul><p class="p">构建项目需要几分钟才能完成。 当一切完成后，选择演示项目并启动应用程序。</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CxImgLib.dsw </p></td>
</tr>
</tbody></table><p class="p">要在项目中使用 CxImage，必须编辑这些设置：</p><p class="p">&nbsp;</p><p class="p">Project Settings</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> |- C/C++</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> | |- Code Generation</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> | | |-
Use run-time library : Multithreaded DLL (must be the same for </p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> | | | all the linked libraries)</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> | | |- Struct member alignment : must
be the same for all the linked </p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> |
| | libraries</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> | |- Precompiled headers
: not using precompiled headers</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> |
|- Preprocessor</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> | |- Additional Include
Directories:. . cximage</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> |- Link</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> |- General</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> |- Object/library modules:.. /png/Debug/png.lib </p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">. . /raw/Debug/libdcr.lib</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">. . /jpeg/Debug/jpeg.lib </p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">. .
/zlib/Debug/zlib.lib </p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">. . /tiff/Debug/tiff.lib</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">. . /jasper/Debug/jasper.lib</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">. . /cximage/Debug/cximage.lib. . .</p><p class="p">&nbsp;</p><p class="p">在源代码中，必须添加 #include &lt;span class="code-string"&gt;"ximage.h"&lt;/span&gt;</p><p class="p">英镑说明：不混合调试和发布模块；每个配置必须使用它的各自的库模块。</p><p class="p">在CxImage 中添加自定义函数。</p><p class="p">用 CxImage 编写一个新的图像处理功能并不难。 这里我要描述 CxImage::Jitter - 它非常简单，但是它显示了在CxImage工作时要注意的许多方面。
当然，第一件事是声明： 如果你在类的public/ximage.h 中，可以在类的范围内声明函数。 现在的定义是：</p><p class="p">&nbsp;</p><p class="p">bool CxImage::Jitter(long radius)</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">{</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // check if the image is valid,
this should be always the first line in </p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // the function </p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> if (!pDib)
return false</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // local
variables</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> long nx,ny;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // temporary image to store the partial
results of the algorithm</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> CxImage
tmp(*this,pSelection!=0,true,true);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // limit the effects of the functions only in the smallest
rectangle that</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // holds the selected
region (defined with the Selection...() functions ),</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // this will speed up the loops.</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> long xmin,xmax,ymin,ymax;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> if (pSelection){</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> xmin = info.rSelectionBox.left;
xmax = info.rSelectionBox.right;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> ymin
= info.rSelectionBox.bottom; ymax = info.rSelectionBox.top;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> } else {</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> xmin = ymin = 0</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> xmax = head.biWidth;
ymax=head.biHeight;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> }</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // main loop : scan the image in vertical
direction</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> for(long y=ymin; y &lt;ymax;
y++){</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // monitor the
progress of the loops</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> info.nProgress
= (long)(100*y/head.biHeight);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // let the application a way to exit quickly</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> if (info.nEscape) break</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // main loop : scan the image in horizontal direction</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> for(long x=xmin; x&lt;xmax; x++){</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // if the feature is enabled,
process only the pixels inside the </p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // selected region</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">#if CXIMAGE_SUPPORT_SELECTION</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> if (SelectionIsInside(x,y))</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">#endif//CXIMAGE_SUPPORT_SELECTION</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> {</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // main algorithm</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> nx=x+(long)((rand()/(float)RAND_MAX
- 0.5)*(radius*2));</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> ny=y+(long)((rand()/(float)RAND_MAX
- 0.5)*(radius*2));</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> if (!IsInside(nx,ny))
{</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> nx=x;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> ny=y;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> }</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // save the result in the temporary image.</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // if you can, use PixelColor only for
24 bpp images,</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // and PixelIndex
for 8, 4 and 1 bpp images : it's faster</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> if (head.biClrUsed==0){</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> tmp.SetPixelColor(x,y,GetPixelColor(nx,ny));</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> } else {</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> tmp.SetPixelIndex(x,y,GetPixelIndex(nx,ny));</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> }</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> //
if the feature is enabled, process also the pixels </p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // in the alpha layer</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">#if CXIMAGE_SUPPORT_ALPHA</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> tmp.AlphaSet(x,y,AlphaGet(nx,ny));</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">#endif//CXIMAGE_SUPPORT_ALPHA</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> }</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> }</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> }</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> // save the result
and exit</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> Transfer(tmp);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> return true</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">}</p><p class="p">&nbsp;</p><p class="p">示例：如何。</p><p class="p">。从一种格式转换为另一种格式</p><p class="p">&nbsp;</p><p class="p">CxImage
image;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">// bmp -&gt; jpg</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">image.Load("image.bmp", CXIMAGE_FORMAT_BMP);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">if (image.IsValid()){</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> if(!image.IsGrayScale()) image.IncreaseBpp(24);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> image.SetJpegQuality(80);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> image.Save("image.jpg",CXIMAGE_FORMAT_JPG);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">}</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">// png
-&gt; tif</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">image.Load("image.png",
CXIMAGE_FORMAT_PNG);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">if (image.IsValid()){</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> image.Save("image.tif",CXIMAGE_FORMAT_TIF);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">}</p><p class="p">&nbsp;</p><p class="p">。加载图像资源</p><p class="p">&nbsp;</p><p class="p">//Load the resource IDR_PNG1 from the PNG resource type</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">CxImage* newImage = new CxImage();</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">newImage-&gt;LoadResource(FindResource(NULL,MAKEINTRESOURCE(IDR_PNG1),</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> "PNG"),CXIMAGE_FORMAT_PNG);</p><p class="p">&nbsp;</p><p class="p">或者 </p><p class="p">&nbsp;</p><p class="p">//Load the resource IDR_JPG1 from DLL</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">CxImage* newImage = new
CxImage();</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">HINSTANCE hdll=LoadLibrary("imagelib.dll");</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">if (hdll){</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> HRSRC hres=FindResource(hdll,MAKEINTRESOURCE(IDR_JPG1),"JPG");</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> newImage-&gt;LoadResource(hres,CXIMAGE_FORMAT_JPG,hdll);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> FreeLibrary(hdll);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">}</p><p class="p">&nbsp;</p><p class="p">或者 </p><p class="p">&nbsp;</p><p class="p">//Load
a bitmap resource;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">HBITMAP
bitmap = ::LoadBitmap(AfxGetInstanceHandle(),</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> MAKEINTRESOURCE(IDB_BITMAP1)));</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">CxImage *newImage = new CxImage();</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">newImage-&gt;CreateFromHBITMAP(bitmap);</p><p class="p">&nbsp;</p><p class="p">。从记忆中解码图像</p><p class="p">&nbsp;</p><p class="p">CxImage image((BYTE*)buffer,size,image_type);</p><p class="p">&nbsp;</p><p class="p">或者 </p><p class="p">&nbsp;</p><p class="p">CxMemFile memfile((BYTE*)buffer,size);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">CxImage image(&amp;memfile,image_type);</p><p class="p">&nbsp;</p><p class="p">或者 </p><p class="p">&nbsp;</p><p class="p">CxMemFile memfile((BYTE*)buffer,size);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">CxImage* image = new CxImage();</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">image-&gt;Decode(&amp;memfile,type);</p><p class="p">&nbsp;</p><p class="p">。在内存中编码图像</p><p class="p">&nbsp;</p><p class="p">long size=0</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">BYTE* buffer=0</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">image.Encode(buffer,size,image_type);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">...</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">image.FreeMemory(buffer);</p><p class="p">&nbsp;</p><p class="p">或者 </p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">CxMemFile memfile;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">memfile.Open();</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">image.Encode(&amp;memfile,image_type);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">BYTE* buffer = memfile.GetBuffer();</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">long size = memfile.Size();</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">...</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">image.FreeMemory(buffer);</p><p class="p">&nbsp;</p><p class="p">。创建多页 TIFF</p><p class="p">&nbsp;</p><p class="p">CxImage *pimage[3];</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">pimage[0]=&amp;image1;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">pimage[1]=&amp;image2;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">pimage[2]=&amp;image3;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">FILE* hFile;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">hFile = fopen("multipage.tif","w+b");</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">CxImageTIF multiimage;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">multiimage.Encode(hFile,pimage,3);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">fclose(hFile);</p><p class="p">&nbsp;</p><p class="p">或者 </p><p class="p">&nbsp;</p><p class="p">FILE* hFile;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">hFile = fopen("c:multi.tif","w+b");</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">CxImageTIF image;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">image.Load("c:1.tif",CXIMAGE_FORMAT_TIF);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">image.Encode(hFile,true);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">image.Load("c:2.bmp",CXIMAGE_FORMAT_BMP);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">image.Encode(hFile,true);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">image.Load("c:3.png",CXIMAGE_FORMAT_PNG);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">image.Encode(hFile);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">fclose(hFile);</p><p class="p">&nbsp;</p><p class="p">。复制/粘贴图像</p><p class="p">&nbsp;</p><p class="p">//copy</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">HANDLE hDIB = image-&gt;CopyToHandle();</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">if (::OpenClipboard(AfxGetApp()-&gt;m_pMainWnd-&gt;GetSafeHwnd())) {</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> if(::EmptyClipboard()) {</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> if (::SetClipboardData(CF_DIB,hDIB) == NULL ) {</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p"> AfxMessageBox( "Unable to set Clipboard
data" );</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">} } }</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">CloseClipboard();</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">//paste</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">HANDLE hBitmap=NULL;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">CxImage *newima = new CxImage();</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">if (OpenClipboard()) hBitmap=GetClipboardData(CF_DIB);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">if (hBitmap) newima-&gt;CreateFromHANDLE(hBitmap);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">CloseClipboard();</p><p class="p">&nbsp;</p><p class="p">。在图片框中显示文件</p><p class="p">&nbsp;</p><p class="p">HBITMAP m_bitmap = NULL;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">CxImage image("myfile.png", CXIMAGE_FORMAT_PNG);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">...</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">CDC* hdc = m_picture.GetDC();</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">HBITMAP
m_bitmap = image.MakeBitmap(hdc-&gt;m_hDC);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">HBITMAP hOldBmp = m_picture.SetBitmap(m_bitmap);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">if (hOldBmp) DeleteObject(hOldBmp);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">if (hdc-&gt;m_hDC) m_picture.ReleaseDC(hdc);</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">...</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">if (m_bitmap) DeleteObject(m_bitmap);</p><p class="p">&nbsp;</p><p class="p">历史和信用 </p><p class="p">从我的CxDib 类开始，实现内存需求，我尝试添加一些成员来从文件中读取图像。 寻找解决方案，我在网络上找到一个名为 CImage的好的MFC类，发布
1.4 ( 1998 )。 我使用的是 CImage，GIF，PNG和 JPG，但是我决定将它剥离为基础结构，因此我决定将它剥离到基础上，以获取新的CxImage
类。 我还更新了JPG。PNG和ZLIB库。</p><p class="p">使用 CxImage，添加新图像类型非常容易，所以我添加了TIFF库(。
6 ) 和对 ICON。MNG。TGA和PCX的最小支持。 最后，我添加了一些特定的函数来从全局 HANDLE的( Windows
剪贴板) 和对象( Windows 资源) 获取图像。 在早期版本之前，下面是在<a class="xref" href="http://www.xdp.it/cximage/" target="_blank" rel="external noopener">文档中编写的文章。</a></p><ul class="ul">
<li class="li"><p class="p">CImage © 1995 -1998，Alejandro Aguilar Sierra。</p></li>
<li class="li"><p class="p">IJG JPEG库 ©1994-1998，Thomas G。 车道。</p></li>
<li class="li"><p class="p">LibPNG版本 1.2.7 © 1998 -2007 Glenn randers pehrson</p></li>
<li class="li"><p class="p">LibTIFF版本 3.5.7 © 1988 -1997 Sam Leffler，© 1991 -1997硅图形，公司。</p></li>
<li class="li"><p class="p">LibMNG版本 1.0.10 © 2000,2002 Gerard Juyn。</p></li>
<li class="li"><p class="p">gif rle © Hutchison大街软件公司，1998</p></li>
<li class="li"><p class="p">LibJ2K© Janssens，2001 - 2002</p></li>
<li class="li"><p class="p">LibJBG版本 1.6 © Markus，2004</p></li>
<li class="li"><p class="p">JasPer 1.900.1 ©图像功率，UBC，Michael David Adams，2001 - 2007</p></li>
<li class="li"><p class="p">zlib版本 1.2.3 © 1995 -2005 jean loup Gailly和 Mark Adler</p></li>
<li class="li"><p class="p">感谢 Troels Knakkergaard对早期版本CxImage的宝贵工作，Rajiv Ramachandran用于
CTwain 代码；对于 Abe tiffs代码和 code Cooper Cooper内存文件建议和代码；到 Brent Corkum。</p></li>
</ul><p class="p">每个库的头文件中都有更具体的信用和免责声明。</p></section>
<section class="section"><h2 class="title sectiontitle">参见</h2><ol class="ol">
<li class="li"><p class="p"><a class="xref" href="https://www.codeproject.com/Articles/1300/CxImage" target="_blank" rel="external noopener">CxImage - CodeProject</a>：<a class="xref" href="https://blog.csdn.net/jshnr006/article/details/7552324" target="_blank" rel="external noopener">VC6.0 如何使用Cximage</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://blog.csdn.net/jmppok/article/details/18794623" target="_blank" rel="external noopener">最好用图像处理库CxImage入门</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://www.jianshu.com/p/57e320f0843d" target="_blank" rel="external noopener">CXImage 编译过程-&nbsp;</a></p></li>
</ol></section>
</div>
<nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>父主题：</strong> <a class="link" href="CPP%E5%9B%BE%E5%83%8F%E7%BC%96%E7%A8%8B.html">C++图像编程</a></div></div></nav></article></main></body></html>