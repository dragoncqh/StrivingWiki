<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"65462618f43e3d99346e63852eebf2623f601d401f1cac3daed83c25a2e476da280935ddf3b8aea26ada63ea7a6075411a3c1cb9391e50ac3d73acb83e8fcfa4d5821e659f089d4b6181d778278a09c5db749c3acea5d182be71810fe9871c8f9c8ce2dd23d81470d7e2a056b8e470dc9a56a08bd6930f1be63735ecc072caadeb04bf2487b2df26aad92e9e5feab603fd9c87d7b45fb449fa0ef2923905f571a8ae5c0127172c9cb39c18a678f11486cba3ca70c1bce7f8046fec68e72899fba21ce488bf30247b97c20ab3c274baa23cb1922f4e173f719e7e13a98d3f9dcd0089d09e20a9cb6960cf05913808a5406bf0d1190498f1a4be4906ae6063b440b561b917ddc45130c026da8f45e68d43393483b2e516fe545dda874963393d5f5203e2b46ae57e6502b0fd818da5b5bba3bab0c14935289ce325f783f6849fd3a6453638312290bc8702606df7b73963f0543d77ee13ea58a6ae4b18744d325bcd5ca7ce0b9bd944937e13fa396df065ddd8fe2dd69cf2194dedb3581ddbdc4786ca21f48b5ba32613390e0ac584f2e03b940950830702d50f7a823427e71d66cfb715e630a8a0517f7158ccc147e72122c4cb8a4b4cd576e8b9ccfc1c7f9eb94db22f329fc5104f83554b50309cfd412de335afda7e945c076c389d0f0ec578b35c98c77ef1367078e442cefbee41d798b2a2fb5191d01c93d9cec7f3c5393a90a5ecc732e56b7418c66c5033606784b4b2f879badedf802e09282df4750ebf1d2494f9347259f2ed7f3b6baffd3361e2dcb6c5f59bf295ef481e3bce791d26721b6f63f38f802999c62ee59cdb8b7065504bbbed1aa686580ae2ffbc5efc2fe2dc80abcdf561e2d2d13ef06e079314877ecfb47513d0ef9a70312a612b2589f29a5d7880d6eea762c32c2c6e7d7a18b35be45e8b64c4d6579c758948701c8cfe88fc56fe47070093c944ca7854aa8774124396855616386f00c4cb42e62ac5f3b488fc1884402debe97d250df0276f0a58827e5d23467d06564c381545da388aa6ab5e9a0aa0db14e7fa07c280a17c2df3afaaa00c877866c4eb0466c0889129682fba986955466a3f10cffc8f378f982911ef0fd15e8f561fa9b806c1e423097dd51c0509e9a4dab7f98696765cade4aa407a4fc40d05e501fdf0931eb2bfcc8d222bd789ae10f7de14c67edba46ca9025c5572c940785f8f4a51efc87c0d64ebbc735329bfd376bf4d9da1fe2616f9ced79d7d85134e5cde869c5931983fae0ce41666fae5906c6d0a8495a3c58dde9b4595899da257a0db2b52463d5f41354d2b1feb1802a83eec68ab6b54ae55cc1873c0d89306f4bfd89e2b4cb831ad1473d79ea594ececc0dd5096c47968174d293e6af6896c9d61623ada95c9f6dbca51c6ac60bd13ea303675fe546da47a3e1ff523ed4e52f3e79dd51e0b5d28bca79f7d2962316dd0225a76e6c0dad03a36aa777b8b4335a9f37ec2f2e31864b907dcdbdb2194a36eada29944b15b322363129e9e15d63798146e30b026e3b655b3b6d2baf24d4e653c65b49161202a5e78291d8a8f4c480474642b23ed4985b9c3d02d8e7c4149b7e42cf988dd886e526ae5958d699bb9e7bbfd34e62a831446a788fba4de02527091894df5f964145e0ff96cd6778b5de4567323a2d25a2eb3a729f9da22539b1ac2c58202d8ddde9995b51a70dbe638fc5f8e7bdd59e011e0bc9ec9ebf8f5b5fc4d832b5688a536e1c02b5ff90ad4a4e92d2a92ab3a7aab57f1fcf0d04434f4a90fadd84b89ea727938d6217a6722e3a3f6a37571fcd177a87bc5ae8cd7b07ceef662f1e925d4822c1f70e105b949de8e79ea8e1534d5ec5e104d98cf47951f424b485063ab9cc2a9ae4a47a6c4f512ac2e469a059cbd234913aba1033c55dacf736d7627a490676b62edb6c737988686ec3f70027cff0d58d9b25fc29229228741c0c4e365cf82a3f1eef8583bfffde7e778c29e8ca1b0b7c844249a0b130ce44dd3aac9712469a171a395c708e72e00e960501a161593ab1cd0824b5b4e7830179a4b3c68e95c4c74e981821f72ac6914ebf2d833826756714f3406f2c6872918aa63bced6bab77e69c04358133a34473aded113a07e8987fb947d78d53ab0bdb90c7db6987ec4ae7165a1cdb438fd031e40efdd82245559b3082c8219e08f8b0233d776f15871950390c9c5197e1427ac8611f2c2f9300e1d06e28ff1c0168623b1a8b3f015014190935fd70b16cac62360c2f9b7640244827bff69ad35848af94ac095c676edc7c5d6917ed008e2f5bc6b34ac8d34c12bee741cc66637939268e0676183bfe7991c1653bd26e1dc664504476331874bf8c3cc5a292a0de97200afed03172fa33ad7099c4095de1b31cd1dfacf5058d5f785138a51d6847faa1a9403a85a66148c69ea9688d81d53d6e71aeacd76e73f3e561de557677aa88d26ab3028a2c833082706b72b593b0ed2230c3d9a1076b99e15d80820f8f9e8f462a387fe6ad36da85a475dbbc410f76914c1d6f9cb5e8deea02a71fad2ed546358d0041ba2d99071febdfda48364ea80487715dedea70c3d0e7edae6c03e07a1fd7ae6a887486fb53ddb852d27fa1b1741432a91762838f6d86b865c64b15568cafed9673c6c2edaae50b9219ba84b7d559517cfecf2b8f165fe94f4b2be44eaaf0bf2fa828185a49ec60fc6cf5b619afe8da0a2328757a86e302a2636e188b28cb39461c740529177470002341bb421551888a4a08dd62f2e7d66b1a4e1fc9152499cf36b208c76b430c59321449177f4c9674db80bf2c0868aa294b3671403403dbc987c7d147a9cebe8afcb8321032a5aabe7b1d347a9a395914023f0c5b094a82c59cf4960c1d2a3e2f41c6a4405e1170cf71b16a73ec8cdae96c30810f7dcf68f409f8a86f38169f20cfcbed1013a7ad25088378ad60526881de12d4aa729e5c0b815e4791fdba918359323fb9a4fbaeb4c0a9ee37c6d3bba6b03ef7aebcb60170264c567ad37eca39831f7065426f9997cee9be115141dbb0925343ed45c280ee309cc1409dea002728d1f5f8127f55ec13f4cb4cbff0f7242c2ef50744b941f11a56772ec9a4122427565aae752b0ed4f634d458f3ff2b4eb00eefcd67ba5f32f6cf2d1d0e0b295e7e9cbee9e4b9e4f8e8b224cdcbb7848384edb837fea5376338ef3e28d354040874491437515a35ff7754b26af0df1ccf4f0592a342022a3c8be8a1b66b32dba773d8beded45543ea4898af367f26e30e616debb15c487694bf9bf4e2e183bfdc44eb6ae51d6602be4c012d0227387cf91830d58feed202ffa3cf89ab8e794f0aa077ba29e00d4b64138e9cc4e73a33416fccd371eb673a599d0f081590a7b1b378c544142c43b13352f3efb4985f711fb79e44013d74a61c856978e406c4a5b546e91aca0b5e8f09bb2cd0f536aebf7b2cbd78390d43d3376d1869e638f9ccbeb834e6f9929602512390cd70bd6fd9881082ea143524cfb07d1b1da7d9fc6d520ad0dda65a0a83e5b09961c65ce8981be60e208b898cce3c054c2933e740a9da5da7d5fac47b364d15f53e85c194508784954b0c03bcb801ee94c92601e23559b15f7bee613e4af3055b94a0aa9a1789ed2d966549868b9da9dd5931aa4b845108d13bead3f5166d5e943ab2fdeb1478dcd007eb71bb59ea573c8c0e086663b38a6f2a2265c924a27aa1e92be908c9303a9538b3390141badeebbfbb3cec2d60a5caaeb7895e05d1b1dade0104fe9e7a229a3b400855e5eea2bade4e7e00f69dcf8bba385f84eee14a6d9d0a7d0f522dcc98af4e6b286a0342f0e307399b0b11ea92f4f72a75d078f08d6949344d5c26fdd7ba9cb603e4d9aa7670dda8a7e9d3db17b0844749d30ff124a71bbebce057211addd795bd12906f8686e67a2e57e46c6ca291249f8aea2fa809546376e37d8c92b0300f51ecbb7e751501e6a0242a9fe5ce62d12fc4884a9e6166a5da659040e35d0967b38e597a92e7a40bc45ed3526a23a414a6e04d722833eff32ed74376010adcc3836df1ad91a0e93c1982ac130ead46c5e6e6a2368718212fdcf5bb6c934e0af0573ae06ace974e28562be84892ea3d2ac37d8be80cf4cedc29bdefcf3e351962fdebe246096db88bfcaea998a72d2977474690c6fc7389b7ead565b8582b53b49917fb7faa4ef44860e518fefc34f36c287715fab773d9e08c08b4e15e816e83bc66de88a973aaf541d3894f0e3b505574ca54898b29b3a20addc8a2eadd2981eec65601a5f789c84bdd894366b447828ec8546cc469147be3c980c995674f8cf0a1c8ec01be51d7a8b6db6fdc8fde0a63d58a615f156df44e24cb5c85e2a6d597b943c4eb83cd986c681431fef9f99545551251fc59473e5d421c621261a55381d0b9ba1f24f231a984aadd510faec8f1fc4d4d68270718c8d1fa7eceb7142dfd2c7cdd73f8f1aafc674c50c1cda83a07224f96a6341fb998a3a3aa1abae8c8888323c7750852b991d1529eae57707cb5bb21be44664710fab96906225824a64e7ba56a231286befe7be8e85d486b8a1aa7d1be989a06fdf16cdb5ea4806de7889e0e3e42e06cb3d2cca763d1e3ae184dcb015eb1e993b1d42ec430add0f391172b38a3b007843bf33ec1bbaea0d6f263fa89d4ce8162f720094ea048804e02d0a9afc9dce6f53d3997ebdf6d747aeb89969a8e18b50279d854d4fbe8d99b0f0b8113797bc782aab1d0670dd2000c66f64f1bb412335a64add6609054dc2c9e85d58f648c754a16431aad0cb18f25583a51ae7417833b8b45efbb414d2cf140bcf253860b485d187b8cfd99036b57a50332b870e32a56e5925fe09c65960aad2672b6dfdd9395bc4008be0caf84cb769b14a54d3994b06609e93994fcedae1b04a425e883ee3e90bcbdb357ac9e69b94ffe135ee48313c173960665d4afca3cb01ee04597b2750877b0f6c23b298a4018182505c0e3f122f5c23245cab1b30f9cd765418ae4e06806200d9a0c75e3c8bcf63fbdd61d93e4b6994ea6d1b3cc027af8d3e835204191bf16f392835219d1e8f6d5651b06d5c650fd2c0e90f177f1ec431d58ed0d37d4aaddecdb5502f9eeed79c66833fd14102853c8f0e3448fcd211e7b6580916414c5e090d6550398aabd8aed6f1ea6d9b22b5ef2a1d72fc653eaf492c5a18b8746e5c5d1eab0193af0945be71898fa4109ed30d855b1d862cbc356b1bd5be35a0b925bd3022519280e7aefda414f4e36a225fff465dd683e3926f275e4c6972a9c24a99f8e920dabe1a56e0511c76723179948723026c6cac9fe36e9808107d26c3052daddd81726db661eef86d077c465fad1b04c4f1253db3c80b27db4c2bd90abd22d28d76513e428ee8a5f10c16acd369ed6c88f77e24dfb70696bf50219d8523e8e4c204024725fde0fc9cebb0f90884fb885e744f3f92203624c899c3b3ed7485b97d6ae35a149cb4186b3e7874e10695528f601f1d6f5e8b21f9305e10926bfd0219d55675a41dc7c07ba1c0484c8cacf720bcbc11ae3d22f3335cc61b3d2ad964e32907986914fcce94ced55afd144e993c81ef43377226486c99ec7dc51cb81a3a7c4f033ba12d9cadeae3633fb09250cea6a9c410d2ff6cf42af23575d3405bbd66d935eeb5c75214843153b04d10511e9d01c48b250b7858bf7c88682d0cf262092f2b690ba276828da4d0eae4b0865a5a5faf15bd569f3be97a64dd5140907e5c8ab13640127ceac40020ecd832323bb0d16c26fa703345c5b05258779b965eefcaba18f1da3c651953786b4639a07a0393aebf70e11eb9db08552c6b84193b63a7adebfff17ae63e83e240317787b8b28bf12b0abf4d47c2592b90f936a3ef951ac1541027bb7f1c136c6b3190d15560d3f44d3b6e93b24d6cfaf280f7185895f660ce73febfece50cd2fefd1b79f193553cf9d7809cc846f3df3427a25f4dad2bd8d1978f172b980f7591142de0f4f98575f3eb3a73182ff57e4b76798ade7a2ae817fdf16a4cb55908562164d9bd198a53ab4432690898377eb864babc24c8994f94330a44b2d8e0afb57c2e16972d78b31ea099d3aa40629c2d82fbff15161a215eb433c4f6bcd8cfd91a43e81a4fe32ea3780a171a3d39f7454e5c30009a5ac1dcd7e7938364700b8e4a1dbb946ceedde095e3ede81aa1bd49b45c2d69873fdc7204396048bbc78b03e91160843f1f5d7b780b4e0225f5ec91dc7a8efdfba297d669f4a2174ebe07c8471e56ab1157208892b8a83dc2197d2a74a6184a3e9f76d739bbf2289212fa253c946a1635e389da0c7ca1e5f7da5efbbf6a7fcb2b573d26c4cf50876b50d5069f4c785a23b9fb19028094c7b506fa20508681dd96891860c89c67efb213c10fdbd3cb688bcd220e4113d662cfdfdea96d81291105c95d5d6ce3de36175eda995e911273ecc6b3d795bc3f6ca69fa78c90359035f69e727f5cf2cb05d5a7f597c8b0f069082b14f3428813a15dea429af020272d217817c830c12a970b17025f21c58dfb1afa1e06ac6716e0c1473a691c9167b708df1cfeaf9dac7423ca744401eb0d087a97b2d0e2d4c06fe593cdab52106d2147c576b781c89bb2919e9be1dd6547d7039567c0b9efc69b3e8976e388aac3cbb049b6c452afbf552a2201c7cea9dca4dae0c66e1815b2bf5ee93305b7ad2518ecc3913c98c5542c37b8bd46c952b08e56329fd019692ec3183a781b2d1131f773f6d37606d5ee961da4fe7325910ee70e90725bf1036a472dd94442e5a5e604db411c0f9116cebe13301361321c19d239baf41940eb45cc988eb8b5baf177566eef180622df7d9ee0d7eb978fba5a78c5a15199c3b515e5d2e531787b30926911d7d0dcfd7326d8b35bb8285d443169bd8f5b8791b4ba6235b797a6ae7e9aca5b7d7eec8fa8f68cbe1b7b8aadcb7cd91f2673334604c83ecea2e0684d14db0ff12c54ab66383698154edda9227aff658c412cd92e12aeea481f984593b4252854ed1ad1495aed8bcb0815663b5688bc6b220c790a3862d55df0471ea63f2379bd8522506b08e66a703739ba6db25ab2e3601337f2963bc0ca2e99ec95588b6d7333b0e166365f8357e4fe505d85638c23337b24e3afbeff93dace65f70899ef6c91c928cf46bc777c779b5ccb359eb70c2aef141d546b5ffe234ef2f0cba402f7ae66a7980c1f9bd70e9069a326addb27755d14a96a921008d565ede712964918547c57488a67bca501dd8f9014f93c8a0aec69bb6d138ad6f80a68da94ba53beddda8252a9ed865f466c7629fd260d8dedef19c42154ed2f0f7fa1e12a0442e191a3b7fa2951b8a65a6c1022c4af08fbec9bd62ace62d18c0ffa9faadb6faa16c21df8ba6f111a442c8be025dcbfc6a4c65e68353ef8803b3c0023020f458df5f95803b94164ec068f1a4052e43641d9081793249865bab2704599cf9964be1bf6f4085569e8a5ab4f6ac59dcf63bf52c6c3b693f73a04197785b126af28f668bdcd437477865b9a89babc272e7e79d2de2bc1d4c4ea8ab5c4fcaf7272e209a9f696e489f70840eec585c6ebde4452d91e49b56e1d5f3d58857ce16b2e6491e09079df2f781b523e4a87a44f4d61a4899d751ca83e3e81e3f5867d745988d94afc07498b8d31870f5dec77648d6a5b2d226da3713ff47838cd194746842f33803851448f83045ff1ead96629f862f45d1cba4bd60846fa84ff5dd107faafd6f261a1c35caad9cb2bfa99ebda126108118f7ed1eb846bc79ff033d974e9a535171aa3e5a4b18391b62d448434a401aac00ee28601eb91ebf3c250f49d80208dcd43aaa12ffa6d69d765eb55cbbcf2e215978f4f2b7ac45cb1ae991a6714196dd047305fb8200912530afcd145db88f70c4d001380665ea7716aa551bc51c785ab3203a4c69d13fa71d50ff87b83ef9ea84a9528e991bc974992bd4146712abc4c4b17f0cd6ade039eec536565a0b30564441906a9374a625eecb9ade87d14899b04e841919fc1305be2ba5611bea6ddfecc2e59ed3cc5d263394bf542d7c4d063ac5252e01ff2330ff32b2b643a3eaf815990753edc6269e7d1da9f0dd1c15509dd7a83a5fe656d3a3b7f07c955bf6afdba24ef82f12c3850935563e216220292f0a9d8786fd3250e9ab4489c2f15a280cd599e468d123e28a43cf4b1f81abdf0a30f8169be6f60e9d05f0ae9b3b5824ba9b74f49391bdd10fbd1aa3bfd2c3b82f3034c416bc0698964db5cf1c68f39afc14aa0513c701b33df05ffaf4d82f4e74b668beaeafa4623e790f4473277212727eda73d591da81fd4872c3899e50b6d14a75fbe2a911d054c80cea537da0edae691ca22ca1199d8b72c699b34a3b5a96252923defeb1c3c249c711c0e8c8c2ff288a778e7fb7676c656141dbefea22250d5c7343da9004391ee429a291b8ca896256c66a13412e9c4c3f6a4f7425e958ff24c9f4a7361495a3dbe17502d04749ca0b5b62455d94c5296a96bf4d6cb440d0c9ca3193d2024129560b9535a95f04d8340dcd1af72609c9d4be316471ca0e471abe20fbb843dba342dfea72392fd73cd4f425879d91ba3334d2c7fbc485cb12041b404a750ebd828397cfa525e0b28405eb619dda0874f324590d9658ba1af066d2cacba4e41c4854319ee75686a73791b8d5328c25579bc36b007b8b25a8bd0aa3ec0b828bedd165e1c0f7688770074734ffec74959df65a88f090b5f4820e241f7e3ad7fcccc4de2c5a2fc8930833573b96b1f1a89d9e0931194442807171a5a619a1dbf3fb42694354e8ba30670c13176ade3e3f8574433414e1a1d26c853a5a5d9c8e1e99cd6e9cb7aa13af27a022cd41065b660e926c9a5c16007dc9c6dea78127313b27a0114797f2c51b986ff37afdb996608d2b4b12ba943063303140453bef28249fd995cc545c1e9839e194e1f869bbe353291a9fe6c92b593f7dcc9e3d77a5dd705b92b860abe52da5e457970a63e2ceb9aeabc2def8728afef692c7d3bbfa89b73155b9de2ab5f88ca25d5c6b3a92bd5670602eccef1ea2ef668fdcf28892a5bb5e99a3ff2db3510dfbcf1ca4ac0124a9837e747a26ed3d7ba47fa59abbd9018c503a0b5fc9db0c8321e2a87c8d2364ad4468ee8bdbe7974a527add5330689c8d458b3b092e7dd79d7a7507f13d704c359e163c3cd74092cb07b986d48a0ab48b569bf1133386479a212973f590d78d410f60aa9ee36c2d2952b402656b16e5f443a3793687c766ad9759395125da02f9e37c81f69fbe57e3b008c5393bdbfa2a1723f1a962d4e88f81a43ee1f4d96aa1759ceaa6c0efc2167b163ee509f86b74b06d121c6f925ea0510522c55a3c9b0860af70cd7fb06f7984aa79cb05e32e692ae0006330015212c684ca20bcf36b0780b969a26ef4c9adfdc308dbf93b32e14f4919403ae25bc837237dcafa74ed05aa37350f8eae3c8a6a71bec95a02af5c5ac55e7d65289031bd113668c78a999ea20ffd00c507364ca3ce93fc82caad20756d57a2b71012d585c7ab61f9cd854fa8ccfd0c0677c508570516b3bea1a68c68787c958572b48e3ba90c0b05767160bf447d50f00c8a4fc4ef53afe70168629344fc131925e24bef95d40abe608e26778aa3a326ae94edb17655bbd5d58eb26f23a8e50d62bc78dc57f51f2492eac1d109041edab8031334fddfb1d66c349d72b2aec0cb52e7ce1a9606d4a28fd68b5621c437bb4f8784f6f2bd9286cbe1db41018d824558a417c6d0372cbefec1f4926d658796a9d96d5bd478a5d8666c842e38c2ed61c2fb28bd8bf83e4319919bbe280a329a4918b8b564a092c44dd50ccfae0a57fb28d43255caa63d38a18dcdff6d72c6a65b2694b896327c290757d58842d71116ad1442d98dcfa3534ffe23d098d635f73bf95210f9aac81ad2d4571a4077aee80b1b7ad69c404dd447599e71d19bc3fc0212bb204836bd5859451ec2567bb09ac41c8883602ddad1c8a83cbf22232ab020d17c579fb76ab15b5768ac1b5c66443fb10bd94f118d97c1693e323faeedaf9511fd97c93ac84ff227719e85fdc9416499c8465cda80036b40de743e942032c849da8d887e69589cc2053b6de0179eab049442e891df25ab9a74271e2216316b96f2e82410f8879722e061a6bf4aa45bb8efa259c8e6f603de7609046084abbe5936431c9c372e01dcec56df0f0193e11de4c0ee567eab3ee6577f5ce4abc95e61f2a6de3d2e33fbd9095148f6d12ae4b8ca356724c7dc6463254f987029e3b88b27284fcb9bc1d853e5a819a72af8ff3661fb5eeede2e9de6869b4fd1dafcecf23246829df3513f8d01d7e0b216cd7d354e29fb8825b42ee24c80e9c7df9c1ee2bd97f681fa23ffaf685b0b0cabc131cc0b372094d332c549146e75b9d236feb9055bc678cf57ef5ecfa3fd4b7e149decc7563827ea7ea0453d898e49f703f4d6a1af584838610687e6257df560ae266b736e54205bbc987314f9f272d67a3c9e9073894d6023e96bad38713bfbc3157fd836ecf5de8020fc2d9b763d60534fd796dc03b2d0903899133627384df35787e59c35eba404b81ca58b14a69961263380513b2fb954b6e3d9f31e8b761dcc8a6e2d2e524f288260d44f93c97f6122eeba200a6ad1e198afd2462a4faeb4e276ded8e84d3bda3cc2f694256b0fc883c34c988a97635509439dcbe7cc78f50bbf20d02089db19938da58bc956f82ea7985b42de196855338119ee6ad4d8d96b5ed41188298f0670a9944304af7718b0dfc6a87d27fdb733cac0ce8ae520006b27e3b6f169ea3c0a0ddb4ba4a784c4ad5e33002a583088825085b15b92bee51768d73a11064549f4595fdd834e5c853ca1a9d6f1b0f474c6644eb992b3eab21437b9293d1d3ac34306a008e267e82b572a51feac2629a0662e2bb42c4dc1e6d771c93b603765cef962e74cf0a509ac796de0542ebccfa059e310bb8c7baee26bcae71f914980258e7cca4564333b4752b5091fde461fbde9e6e9ebbc59a1138be90e3aaeddd4103559e85900e756f50c40cb281b243444615b5d71bc043f1983e015866014f0a5fe980164c5baa5c7c33aecb6c95167e4f5159d5e90ddcb7ecc52e087534de16b0373891ca367b8814510e2178aa902981441fb11785b47c4c0387eded12a6863c816aca417e79116af2c44ecfb692fb64cbfba18e6c20a7f74b605b59aab1d7b2edbe29f3babb5778944cc07fe4aa9757e13576232b46ca4e4a6fcf793f28cec74aeb51c08653720e3ed5fd0a73c6b7ae60ed6625aad7eca35d1e5c45a87178ea56bc55911d5d3c088f928ad456b445b06015bf2d81a93a28df0e0e9b83be3bea3756a71f0413eaa52c0a89766d89d6a6175bd99e98aef5b238f9af7496527adb7cd87bac78aaaa7ceff2bdb7888a1b8ec5f3c2d29f895a0b6ab0db2f8d883683c76ced4df166f1eea06c9e982c2a59766996df9aee35e53dbb5445b6b7db6958bba9406f0d5e77ac09249e60d97f40a44af5afeb517469825e42ba2fdf4cf75b7ef82de4112390048506ae09fb823753aab8d80f24d69e83e8eabac8ff20bd1f1cfd759f55ac3a2786ca417ab27113ae0c10fb70ca9e773e9b57a1f7a963fac3e3a64e9933c4b2505aa2a95be5a5abfbee51b106fc5ce0dcecd3b285e1ef902b711be375581764748d06c18718e895bef24b67160bf474808c6fab3fd3138fe3a235b4f0726902219d7529b577c1dc428578994f24819ca5bcd1152bf21205a24904a712eedfb825a90069e0e3105f91bae1bb6dec338de5e83317e0325023fb0a7509b576c4ae8f07fa33d906b5c482f7cc0ee8a9d4844b79d0a28106ba1b281a89bf36cd01c8813df24fdb825aab8f6831f92956ef59c5f42a87b7bb8648655d2a01ce780ddd17d945e6cad19e734beba8bdeaa4e8da51e4e3b87d135f9f66697b777ad5153ad0efd73407c27e960d5483488f0f9dc4e7f7387ede156f48c9c8d15c5d4317c6b6712521026f0dcf1076c61801c7bae018075a2c584bd79c4f62ba4fc2c90db90c53fcca97bef034105b39250332ce4f4b97e7685cb378750f94b41e9e4adfdbc9c701923c21410bc8a0281bbd411c145e1b9fe53eeae28e337d4c3d23d94b2a498b83d94684cca0793867d5564ae6c7be6cf77550982ab8c8cbb750742d42bd67eda745641edad8abd8ee566690e2be6e1e876ce7f2258d4123573caceee77dddb37ef1f80929b7211f16cb3b685d8b70edacb03c95a41c5c7a4192888d89c46b5efc0abcb5c8097238d869f6f6e1120dbd45e31f966fbb3f3b18d7559e4305fd2c44f44ead53b04cac766ae540dd87423546c4be6674ef21575b8661a7c41b201015311e35f63a779690b92529f18b1e8cb99aa874c73260f322dfb4f32abd35e9916e261cd1bee6d473b57bb3ecccff5b43f3cd0031e11aeedd98389f1c10431518798f1af161d4fe19bb1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
