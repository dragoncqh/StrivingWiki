<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc0f18a70cc515496ef156388c8776361552f107467888fbac4f98439bf9763598d01f8d44afe0b08ff44f331fb344fa1ef627e04a536d55a29d11ea6de00cd97223dc27244324e63d8198dd5987b7d7034a2444f833e2135f8167ddd0a75efd61be1135dbb37525cc2e8ffd0b0e7baa000a764afc4775927148c6ebb1eff96ceb476320102c5ee7a8bd5ef79f6c3394340496e90412b292fe424f2dac34e09b73b3a0c70c3c9fd789aad2e64e3c9cf478982300654c214d1dcd9c0b364c27a779f5c57ba3410824da3a0816c8a6c9a6b0d87b6d25f60a499efcec2bd9e82b2b587a67245ed849eec0ecad0209f501ffbe25eb085ed59e31e226d75b248fec4cd3a2ad7588e4291300c7b296da4d1b98303483b4c8e67d164a7f99be7105b0fe5bfbbc9c4332876fd316986705ff3cecc3d55dbcb5e8a4103ceda1ddbe2d9bde406ff2f7a804e30193d81e5d5fa1d07cfa4e642123cf0969d3b4204a9c454986d90e12fc7acacab7ae0c5f432fb746897c0b710ca6e8524b41c7587a863a99fd0f36e08951b85d5018bc798565f71b61f77234c3fc65df049ab682e5d48f020af98dc1ec3dece61663381941080dfa498ab7c445e8af64133d34898d68c429d8901c8e89d55232341ce7336ec5a1ec267ddccb81e97633168a782ef9cde2367ffc3a2ad1a40117f0df4fd441d4f676d00cf1ecd9fe90ab34b6b24eb5e8859fb8179ab4afc0ffc30384dc8a22e08adccf3a3d5b24836c368633917e2ed0e27facf77fbdd1879a95ff91f495be67bcae80b8cb366b39fe687a65ccc52021eb0b54a316186c84b02f9ed1241afde5bd5226938530a2bc2d10c8943855f95be5728c478a83b6ad553959da58f2000ad20b623bb35fe8c829ed1fbb982dc9a690cf9e5391b4316a40b39f522a67a7624882bd7b4beca307e8cd048247185cb92006e7d6e964ca8247262092a83448edfbfcc8f541987283bb590c1ecd1cd178d17b5a43d015cbbfbb37440a07ba258f22c83c35109c922c4b2f98cc34cbd8662f82ecd65038d6c312c42d7be97f4a26127eb8d1067712c4c6fe5ff18db0f78706e4df537779a8e0c9ff620c3b3dcf12030fde6dcfb9fa974b93c943472eda869660f76ae9eb668a48fa5d095bdba67eb61d9329153638cbb640422da7f9ef29da5f4740e4447b757b8ae7dfdb5803c818bdcd9b264419afb7da29645bb05b8df03dcf6bfaaafaffcd473b8f85954eda6e2b53a5f3ed7a13767b57268659762ede975f6fd4a9632744482f61d99ae978c7617e4361d75fee7e1b823ff0c1a73e32d4b0eec42444d0bac33d741550b5eb4c74ded4f867f50965d2ef60e55427353eeb879af3bda7554936efed743292639d2b1d0af9cfc63e885421dc5a75de522db91a3bdf16204e11a9163dd74cca710719f9cf0703b0bb514b1b1f67c65c4cfd0ba54190bd194e675e5fa88046859eca9864b5ca8d63758d08173c9d5fb76bba88b03e30c329f39ae928e667250c85d9364683132b1032c0a0d961ae0d9fa42e1fb50dd15832346519d174bb6e1c7e5fc16f3ab6dce489fce4316404044c069a56b12471d98a2059ebc95ac7b0f461825c612e4da3a0ab4ca7966a798751e57e987212a0d85836dfaa400102afcc7826618f38c4fe8c88f7a82a8c16fc2d582a215d55034a2988c9e4b984a81247941ff8d4991bc0123f0396be88e8ebb4d8286c75322ea002234472bd56b26fc880ba099ee4dea9fe7a42adc48a671161957273079056da467e50808ccb77bf79e3f2e21e9e414a01ed416315be36050516ee80a9ad95b4b0c81470d916ae22cf3cbdbfc8e23d7001462232c31a53afac2a3ab50fc57019e5e90046bd3e7559c4ad4c7ccc3086f1fb05a33db8b910f175283120643104f288fec12bf7aba5d69d71da6d4a6e2954db724c435c981021eeab9fbf6b88cb0090c0360d43a5b8ddb0a3beff17a3d7a1380a1a5ad9ade64d0a324e0247d24e536e343d9d3774adc909e6400c210692ea93fe5e04c9a49eaf16a70365a1ada04bfe534eedb043f025398b242699e9156e6d3595ef86e8391684225b3c15e089037e717875660f821be14735f36449f7dd80c73763b301e99f7be2f353178572863aab6b5a091fa063cbf8f69135fbe45c68abe9cfbbed8ded8645eb4038a1515e43589b8777239d8ca8944d3b5b7f89375bdfdc0b1c6fef77650a3e5933cd4071f3964d9ebcdd9c51cdc13fa35f4b2f07973374ff9ed61a8e7d2751126c13755f221cabcc66516c5aee7f3c4e833b617037c2fb0a59ac7828b48cea35c8b0e668cbbc3c7fa93dd3b08b3dce51754bf943770ba98d9ef602ddb06c08f5b1145c141487255b81dc64cf4d5b2fddaa339561103999c74c40706d919ffcbbd26e08d8cbb32aad5dbea9a647838c2c8015d2085f0e985a389db9d4162bed996e90634ffa6b6531d241b79588ad50621b8ac29d2d92a9e097ae99c21767f8216ba92864ae2c899f52810283a21c755b68fe183bda8126ab91c3997a5d4a3e05965e3c10bb089cdc4b65ebf47a35e0c1e5d60e3ba42b55ba8dee942ae4705bc55ff90d51045d986a57bf1348c1e66cc226115f6e7ea8a9b366afe01cfba13ac1d02ec0c631a32ade79b58c66e8666808c8378492874c5c9d4cb21a9855bb12197ba89cb31defdcbbf1bfd213f4329745d02051345710407bf813c8343c335c912198f5e786011e1df648d90ac31f645934512b5eb245f3812cb4a5b013dcb1ba2f52f74690399557c86547f7cf1329ad041b6c1830f83274e7073ac330add8b5591934525a0137589f73347fd0d1cb69da103584be06da9c1c196fc5fb59882d618aadc13992f2cec0cd497020ab496427b58bf3cdc1d759f9e8d0a1c3e77d21c05971530af12f3ed2966349762b9aa1d2327d87b64ce3dc61e622c2f8c0e9a846466d87ffb860483367c59529f6816210e041e16082351d8fcd0d17873f9893288e75e87c57538339fbea6106aa0cbc456941ea38617ac1aa33dc87c7f216f48816d7a625bd481458b731147083ec7ad4c42c96862a2c68ba9c29435acd59fb068088973be4e4adbfe281dcce8ef2d8e117318df170da6faa78882dd5f69a0e3eadc7be547cdf3a90ff1fe1c5967849fd995fb3543ec00770e37cf4eef6b9094fe54d365393392e206fcd53949bd57fd63a2e4fef5ff48074b981208db10ebf322b1a3b7bb0a626ff8fca093aa76fb27e1a0b4414bf251cce96eeb65431c53727c5bd157a9c8c6f0f24a60be6bed12d7d3689427abf8d85ddaa0371c676a86da9f5ccd597b2d723d84c41811789822229f809a725a86a71607677723c3c12e4123c5247d71fedb6c43c8539353a9497fe3435a344a2456a690f454eb56de892ece942330fd0d2b868a56c31121ec6069eda3116eaaa83c7fe4453ac5c9584902c8a67d769d8184387c6c4e5fd53babc619ee52482eec54f52af11b94e2fbe1a97c8f6b3fd457557b7dcd9ba1deb325b98d9d76f233daa1073137af418496e856512a938f2b0da8514be19c3989c38cc07f250d3a06e6ee0b5cf833d4fa365d8333713f706310c96eb2b467045313f6e6bc49471f9b7fae6b1a9eb96fcfe10f6b537856c46ba73fcd68b514487717340b3baec217f3c2e2c00327f41bf4b1d5c73f8483f260d25e4e27e833ae172b95ad01b436379ed165e10105fd3c3b6fbec924bbded5897418d2a9c298f508937a536550376acb32a0306526c87ad8e9cca1d0f40a67c4430af53a5720bfde573ef81c226d4a9e0efa3c3a7f4a3d60da96fc66c78161e2bf6ce623cb757f04919e80e064e4d05ca070e9d32b55a0ff2f0bbd170b7fb8cf193c334f17a104338f319154f20b31fb76250f558fd1cf0a04680d78aa48c64db4458ce0673c1842458d31b3446f3f127eefe403bb7c20f07506c2141e9ec98fc336ba3c78ce3eae7067a4f529765ce8a28cc45c690d7de00bcee4ce50dde670a496d25918f08b55711897f8d3b0abf3c1f5e1732a2ff1576843249c0c357d9f8e18ab4796acde6dbb9fb86bdba7b7512bfb96028a50c42ebd4aae59c878245dc0fff4bd13d521d8821306e85f6f03a2df42e2214be248e8b274c396b56dbae400b0360ac23ee151e4af268bc6dd03a9fbd69a8215ede6e9d155513f70213515595f909b9bc75e2afd29011bc16a16aa7eb0846f1cc37a47a6bdacc6f0b60e2d892c7b7913ecadf1efb0145d1834ac48225dd6c0e36499890eab202b7b7e65ff6e885866a84f1e2a85d97d46a8b8f51e58e37cb07774b5662a9802deef99b5c9607ea84d339d0442724b380658d634787b9bba7e3a91078173b216b5eb72f83b341c27de0450d926b1b4b199c16cdc25aaff7219e075548f721d406ee4f61180c97ad12840403a3d0612c9c13fc2dd9dd8f046f74673eece081ca403411a312da8e7e3f4e5217685387e2940d7b7c9fc187a483821b09b8f37aa5b727be5c374455bba2d365ca85363df845152931fac7c4dc0aa9a134a054e399391a08d649843a0a470d899d5a483ab200768303966bdf6801430e3c3f65ebc250c3802fe11f5b3decbfdfa0d662faecca009f47683037d6e1de862d93f0c67bceff05b0549b66096a2ab13c4deeac441800cec0a125886a9b8d733856d0fac61f29fb325cd06dc4410ab2dc177ba631b36fa4232a4b7336bfefa59606c1336888c64642f7d6fc6f523f2e51901915b651709bc889ddb112cbbae2b9052f8bdd38f02554ee8e50c52034930d9a3a364f73fcbfa338b161a559e44182c945383c22765b6319cbc8999264b2b002b4d7939d7c17e130943c5cfecc78c250c1e675ad354f2374eef4bda9d28f9755f1cffb186363b8ec7a13fd34e973d93ca43982f348a90066720a81920454bd21bb255ecb5465ef0373bf23658404ed1ab38516f140a8a5b05907b7af02430dcb83fd3a90efeba63b0a22be803feb498669d6c24beaf5ac37d9f72fd366449e8ad540a28d221d4f48894dd1f1d39a4809de9e2cfabdfe19d9348de84da2c1941fbed8c5f4d958877f8beb564d9e3ab65a339112915b09a29083365a228dffac2a5aded0e6592544465273473980097e8ab466512ac1715a1b61ceea12af29c4800299435f752572eda0aa1d99476f5ef726cb3b604d707f1a2bb37c5e0cbb49b6d60d48f3fa96bd4757ccb91c2c88834bd951c8c2f4ba651248445f392d2af53330b97cfa267bde6a2adcb1267514095a0196ed7c0f18400ce4c2d0452291a83797688af402725bbe3cbeb6efc08b8c08191ddd311388c1d1d610fd8442523eaca53481c04fa2901b4727bb77a74a6380bd1fa96cd3970d77b050b5f8327d5af911322daf981fb53d4486c44a9a969306dfc12554e70d7ae38a0d313b93434bfb4657b6b8afc04ce0a099883534d415b8a34bd1f37e41b18b13c5421a12608208cca66ba5b7431c0af735c7a95f72858f13f519b23c7a234058ee0baa05ebdf9a5419c98e81fcd93b407f84ffa6281d0a31f1cb71c40beda25c7b18fcbafdaa53ee4a1644af397d94edbb5919f1dc5205910f76d882ade579ddb91f832f0081c57f12596de78022156b1a0daf091d78676549860f90d6a8588c7358b23fed783249f90baf9a24eb3a845426909a9ef9f5ee3467709e1a50d1266723be7cf62c950d0a3b507234a021a54a040f38fa6d50a0c449ee951819dba208153a73e24135685a64314193103f5ad1cb1355ad749fb1a7bf439250dc584ccab6d71e65f4a4bd5b9adab989cd64dd1b345fabebabdeb999a724b49ce089a680ca11824d809f70a4fc271fdb767f06ac29c7dfb9c9f3688cdaac78d00beb4340978e3605d63d36dacad540b37ee7e52da3d61bb1ffde364e44d737ee67cde959a93ec6ddf9e4a507c2fb4db4e47a1435fe62371d416a82275955d424ddfcd10cca1781fddfa63c673cb7f139062dfddabc3352e4b9e8f7fb8a874570634229aa8c2c6ad5985ae205699007263c8e19cb60dd0b7548424c6ec8dfc340fbf9179b1395e71272565b144527d65dd773886739d7a22cc5f51896c430612db174c823d5eade5376a6653d12cee36bd1a2a744f0ceae745741e3bd0905a232f8b69761ab4f37fc002d104d8e036ed93b9e5c1852e190964f841df83b0b4bfafcc4a6ff03b97efbbf890cec68b656c640ef5e96587fb10598225aa3908211eeef316f579be00820a135db4b1bcefcab7667db54969e90c212c70bfedf5799e48625fb88ae4a2fd32f04c1a173326ab126fcae8c93d9d26bead07f1297f16d494c0be4ebc0fc506511a691ab392548a8ec17ebf05b7275eb60713b678d1ff864125bb49a077e382181e3906c8ef69969a0b00ee059afaa85e38400499dee59b2889c955ae2597a704e3a5763164e20164f428f44d52e2ca42f059e9ff317681941f0ae97378bf120fda533c3b414ae278600fe16a6dffa3050c9bf13df32097c0c072c80aafd448cbed17e689b921ac2f04785cb07583e3b4a37aa3e34819b981ebc012395ef15421bdab248ea150a82e439a53082c121ec8b3863a09dd574805ddb3e48714bf4769794fb31b836edf0a6ecfe860ec9acb4d9f33aef9bd20dcbeb8b2c060ac1a66d2e610b9f1aefda1d8e32cc8278e634a102640b31d9e5e8f0f2ded99547ed3ff62a5bf9d0faea8dd90a0a4c62271a4bac3b8d6fc6f2b7de04e1f3067546d32e6baf0d9c7eaea4e00f80b3f6cfe50bb8ee6b7444409dcf185e09c91fe8c13600c9e7b29dcf9bc9bd374ec99df898794e3ec6c7f62df3b58b25cc87eb26b87bdacea11bb355fe86905fdd90d0a3a24b99fd9fa21c54afed7e5906762e1040fd9d65ec7644c5b76339f6954ff166fb83a780d5221b3064cbce12717cf7eb036f6d7134616b487c544cc4477b366a3e617523c57c3235393d8d24ff6f6c4008b6037e6d2f6db125c3b37f55bcd920e124609aaff1795f1eae5dd8beef3201e0a5e9620b94f31c9da08a0a72677f86cf3b7b759a6d898ed7b0bd28c9104dc21f9e20e34afd8bcd0dfbd2242ebe3c4d45290b987dc4f612bada0125dd4615331328f92fcae6c42c07143ef1b018ed0c78b48bcc6152b74dc8375c28f0532d5dab3951e75501a4f5d9d037ab0d8d5cd1dfda5440a45dcb304a34856f37851cc1e0b737dc11d8f4675bc8ba1fccb03904387f62d6c9e74d9f3414087e7c7aa144938e335dc4e65ba8783eb9698880abd0872f248b7339c0c5d620f7f628b2e0c2229e32a8e0fde6fc813afa8941755b57d5b11daaf470bf41d3ad9a2229016b1deda3c02c37ceff7dd47ac0d3140888c1e8706fcac63881d1130be4827a5fa792fe8ae6d78b1a5adcff900e1330a1caa34743b04db643f43adcef801ad8d6e545cc986a3b14d4ef44c5c701c2af61919a8c0c50ebfc4e644aa3283952035713ab25ca0c90a1a3c1400caf637229f38800f54a08a48b31d2c07f317b11278564aa8554bb5d1c3b858c3e50b29734c680938cb4f962dec3917c573eb9e9543f72e79d54ba0edc14550a07847e0ef7b338e1af05096b5eca7a4eb0fbe84c95ac0f06c1eb46d90d7b863016ac1083c80b994f2fb03e36371baf13ac541c308512e3e4375be8d12f351db0fcbccc8c6b102eebb6f73a7fe5f1759c96b91406e8b491882c80f9ec5c5b153132568d48503b22479be29e3f8b12fd45d697a849073c0a9acfa9effa76a3a7775d5d03483ace2f2a9e74fb3efce94dab7408884c924561886d061407d27723fe3181bac2e7078adf6ba1b7fe3a68b59edb52f709c89c715ba54647271149858bce40d0d53300351219c4ddb7f49ec5024ecc454fed2fb4299d2193b9b925786a6d79775d7ba67b3346ecdf8d652f14975e27d95d69af70e8f3361db92a7f306128f7d1eac9f7cb1a567805e234b48132c8b94dea88bc49d8d52945b49cbfc4e5ea514c0cdbb9ef954a3897d181728e23ed68debcaa3120c24b976b96e020c848e85b4dab9c136ae223bc6c75588f9c56f021d915bed0dbd75adc3afe76272850262b65bd226655616783b013dfdceb679c07314a753f4cf6d6dd65d1451fb84327cb2e5864c61852a506b29c84972bdf6a892f35601969f5a08df05a3afb00deabd4a8eccfe3a9090a27ce783cd50aceec07db5db4c4ef10463ec81bc7e7cbf433036474eda3b78a9563b93db0ea5645ba7aa1d55f8009de367ad7cd373f31cfc475e73358c326c1b0702df2e30d40bbd3b7916541a7c4367dc4af08852155b46aaf7c970a00c4c6fd0a3cffcb363fc2c73f6225f52be970ce5af8799d9c54331b5257c7fb80267613470003c3a64777aa0bbeadc7f7c894ec835475bc63e82645fa1bdda4089fb185a319d2ccff7ddd52f3dd9171f7f3e16412514d47763290742548c333a579875c2079d9cf35522e7c34db40619801a0acd7b3092ca68b6c6e20758751d4f1e0f3fdd0580bfb8139ea9220b41f35d404f9c093227c5d1685a37274ab8001c84dacae4338f84d3063856df86214a440b85c3a5e6d105b663da54ab7b8e26532f4922bc633b75d5493f7e9de2bf072e3de5e6eedaa689df4da438b8bf078f6fbed8cd52c9e32cb1077bdab9ba8a700605e25bf84a462ad17cdc673def03f093811808b1c4fdd54368b8190a0eadec4f5a7a48c1c65b66be0e6e8e0e286891c2b14c96cda02c3f46b0cb5f63927c2cb8a1bf1a12da49194407179f0b44bb735b5460f9c9434568cd3e4bea0412029499b9872e609c5e09708d2d257a885677ba41ad40716954cd3bb22a0810e6aefd10e7535c34279c8a050f27db9000744211705db221c9fc2c84e4773c46d2a3912fdbae240c7c15071c9ea744333d5385cf3278cbaf95a3c31665278f6d9bd6defa0a6f17585a65c5b27c23eee60d832fda9f6ade65eea983e5980bb1061618850a993470563cb08fb736c89dd82e2523cd8b94ad6b838c35877a6886975a97a01cbedc8ea07df2a1e250107e2c128465eec3bd345ed494e33070b09bf391c4f02507f0e1671cb11a34f523822f444c69bdf4b0e35eccd6f7679880d483251053e308c348cebb3aa46897109b8b2d60e2ab5df1643089fece60ad58e04cc772449e67c70902afc8c7bb36edf226dc861f8d7a206a766e7cf13c413c61bdacd7772fe7dff0c809ece7825c487a76c4fa2e8fea573354cf399d17e6ea586913b6a3a0c8a34cb9421fbc34a1039a3a1f2fbbcdd39bf051909204e0cf8707ae60f96869f5d98333f9f6e20978e3e82d8f0222e573d2d4df48c2acaf6b60e8c28b449c35ebab805da62fa464d2eefc7ab907536424a2e70f4b6d9b009372bcd622d951904871155177b3786588226fed4af6fecce1f9dd26ca63ec67d5c3095a00d471352783514703178f7603fbedd8fed26f69040d5c2a3fce19c4e3b7944a0db6934494c6673ab53174e728bf8e0142ad0ee00930198104efaea5c63f4309ab5aa2f852f0800463c5ce85ad3ab3fc55c48c4517ab491463f1635c1b538c56ee1798f2bb876ad3ad3fbd27b20357929fad750f9fb46781f2d8377f097068c4f45f09045440860f70353d3c4dd82448994c0f857a4a930b1b230a9fe717d0bf8044ee4fe62a60ead599787692939f20e50fdf407ff880fc7891a43f605709538d861ebfcb05ab78f04c53e10afc4a11ec401695cfb5ac1729e36955be66e52dcc9fe3663e88aeb0e1312e8903d048930ca913bd63006d2b9c3c2f782be16e3ee0bc80c6a982ee5a0caf7e39ac2c04e6a911c43e24b840e30a98985c36d582f78f31a328ed2368456c503b5ae851d52cd4f60143ef0efba8150a0feb529a5f09c61fa40b6011f27f0e32148366ef59ae1d405e4ca34bddef40607cd7a66955f5b4c80aa5a96544640284de22892a555ba81292ef6154e00cb2ccff29d1b88474be2c46676d136e00378ac4f2822f7fa3bad60e7c66a31d99ce12c0ef7c3a9fe662f8c8b13986af31ddea716df7538d2b0110f2d21e79abb1ddcc8f764cf75f8389b11ed1d38e5f609efa80bed8b9aa219d458711fd1fa7104c2b4baa16d0c13fcee966e4fb9b06a055a373bc266f44c410ea27bb8df7afd794140f16c5c0d71ecb83197ce7dc570209a89e5c7908dde8dc6c49a14d465d9f9dc584b8ff80109fa9f23f7b54bb03d737dc969620731fef4159d06e2a6708890bd026e5c2ac8940c87f0d880c4630872d3c657ba9dd883a00a3768d517d0f7924041ca4e083117fc6cb0f45c4b5185662ea66f2c2252ef56a3b307b558da258f3ccb756516747d5df742ade4e8a61e2471720c72b67ff95794873c29cb8c33856674d46a1720d5a0323c300ae0c13511107ea96ddbba04f119fa6259d67575318a1d4b2e7b3156bce3acc6b1ba97e629b641336057fdab586c65345e5162ee62e0900c2e89ec487731da6a5cf18d7e9320da111d4a3dd69456358a8446dbed0a7ac0563787ab617f2cfa65df05be97aee486df18f9b2474345fb115dcb2acd318642fdf5e58c4b58e58781302c659d5450569bd920aeff61537828dac40544fa8841b32f3f4eabfa0a2d697c6e8643f14eaf6dee4ac14273bfc4ac201308577e06b8b91784922b9e061ccb38cbc1a5f879c0972938d31d58f4336cc58274dc49288fa6c39d75796caf4fb64934c6cb44aab71ea80e183fd089fe841d4f4a9314b2f5531991ab18fc7a9b341bd4a2f9d49881259ea8b96633c176f8df3f95cc095da4821d533407443d8e7db1399d8173372ef34ddc6aab3a9ccb12f2f3d215b2cd96fd35cf50b0e6316dfe424943701592e58119dc57eb9dbeab5aeb48260558bc5a2302da74cf7aa5d4d87400ddd07a249b917f32943cea1544dbfdb9f494a1a8cc0e4f107dcec0e0f48122d5bc30cffac37ca36492a3a5a81b847878462eefa6e4a0decb54000c4ce3005ab2a7877e069e70dcdfeb1c40e9be5d645101266da58da69564e8b8344c2d808272b5979f6d761de5bb3650c71c17f12e0af75239c8e7ad849980e8223ab55365d77dde8673ebadf2f772c24f3f0d84fdb9bb1b106771f523007aa77fee4b7de68255be0a70db3c580e09dcfa6be9ac28637c5cb10394f041bcbb4c8d780693004fad0bbecc6ea56a605408e9fe2420556841fb311f77af3e03498c9defa8e04ef1e61d017dc2ea15cb55df2c2652a25350768c90a9d54df05073ca2d8043ae2fc06089f21f09cd1598cbd1f6ca3303191832bcce46c5f0360da8791afa18135f274594420a98139783804aa64c0ca72c05343644550bdb07869847288dfa7c4953a3ab8b387b82922783740cf4f56c326c091a719a123c8a0cf5cca12b3d0b12512df09b1f0eda491737ed99e7cf1c0825665f4feb80f91a72b52b26bef1c018b4ba2508d37e2032cab86854a25c6cd8b91785f4e8ea579e220de478b033f2f65f7690d47b4e2b3e084b050fab84a5e089203da9b3b5b961b6c8860ec0e2c57009c86cc07f14fb62cf71b89d6cb97c9be0597fff30a043ac18631a2f7934a57169ccce2e317b015b2288f89e269eb7aec5d9e2c8e0155fd885bdbf83daeeb54b049c4333e05bad22d941cd1a406ffadbb670820dbdfb98a5e611187527c591ad04ad44c0b6515de15d4a37c0da2468eefc9c57a4fb124aca1da8c3d0041c28de85a06fa4fee31a0ed4a76e01201dcc7758d36a98467358400b7b8af4bd87984043bc8ff39ef4a3f5dd2c868637fda56c2877d3e55827826d0fbe1780fdb7ac02c892dfaf84647ca40a1b261e3799a100000681383e4ff4eba763cbeb6cc82a7442628fbf3e70c2f81466097027a8b9aff341a4748f9cc07de5ef582e8b168fc2f7fdba80cd782dded09b48b1484bb0712362b1062d71a4fd7e6a8759decc317de7875c389b797405cddcbf15c5a05f6b04b259b0f12b14cbb2e02d147b2010ad821e043b83d4bf5c10271827d7364f0cab63098f4c19617dcbd1c118c6e21cf7c7f74a00665430568e5030f2baf2622820012e83114589d59bac238004b52c2cf3eba6844986bc1ef9e991f5efc4bb9547573b7ebffc5cd57d46ab9f5457513a17b73f083b16afc17a5456b93c7b79d06c3ab27ae3121fc18f26b664ba97d77dca17da607e93252d42a7d244a081203c98e3a971848a07d4afcbc085ce6d4382aeb5147729447262ee35c6539d05b2d560102393b69109ab5b632087d3408343bcd0bf33e195fb2f169fd8bc2f65b5179ff1d9b9a70e019cb8cf1d7d23630306cd6bed1ce21c087b1f56b3d734483f8d6e1b7239b0e242fed382834967624893f259d90f4eb1de4d91b7f3089e7b6d3a4fc9c712bb7649f7d866ec0d5020ecee26aefcd2fa842216c30316cb08f7475655b24b7b345858d638e79844b78a5fefed34e8e7bd37df1f556d35463fbdc92165e95966d260978375a0067d9365ecc5b4805447e4aedc6d22912d7dab0fa7aef7c17107e50c451b4991f5bdd7c2e5e378815636fb2ac0ab1b3811ac496d97701725b826a26f93ab9dddc2aabbc691f58f8d93b35db0ae3369d8eb539802a28ac7044bcbef20d45115b6b01cc3192a72135cb7b97cdf715a751bacda1f72133b548c5ef140a97a9c0bac2be482a85d1c740dec77f6b634e1c842c8a42e04b8701cb9b37c0ec5897371b336d75d48ab2acceb423950e50bdaca252fb93ddd1e36fa905b7aed30209a94bb0c1ab620b62d89828d3a8194da8dcd0dac5f27969c1349acbbed2b9190fee806b970fd62a09406c679ee5b820b2a18b280e7f26a0118865b4085eed8d191875b84a3e0e11d9b932a3c88bbe7b851f706ac37b5c2179f76face9ffe03ef4404918f59c519f44aed366ee97d2ff53fe4dd82f058d089b1712fc8a7eca93f7a40bf5da1afdf9a8733aaff8c66efb4e9bcaca33c00064480e435e237ba00936df23e588073593064f31f4ba1a9baa466cdbc9b0f65b56e46370f2abf5178069b38b45dc00495bf44a838a29ba9eaeea75f846d22bb6d75d598bbec88a463c381d64294f04dc531b10f485291884d421fad2a785768535dd9e7634313590b430631aa013bae56ca8225e1e9b79afe5db28857562ab92de65cdec6ab4453b43389e4fca7747f34933607731e7e9ee5d39485662e8058ab73ed639cfbe645de27ef57a3c62270cda4453512e466dd3963124f17e35a45eb1c5b71d9abc3e3315bd33020afc9898fce4db0576105b894c0bffbb690948be75ac32d4f4df5a3e19e2153d0e8b1ac8896fba443e16cf620ea101301bc7e8056137eca19d41d097cd858903be1e651cdb789d46319bb63b8b4edb00bd266af583bf31a5cd882e3804b9ac582d79ab1cfbe1eaf49fb498f2360e5cc45770affd3500fad06a970b371dbe10429d960ca0cec9c840040d34ce8393c38a114f4d95ca30b1764ab12909771ecf4cb68b856ef1d4ac7241967abaad1eaa1928a4f907d090dcfbe2b6175307d9a6c4e202ed0aeda518cbcd6abf36d3a4aecf4d849800bb92190a056f70e9288b89be706eccf0f1a10ba158752ba6077aa6e7189e1f0619f1b8cb84370189802d0f4b094fcd64392f8c512dfc48bfd0b5b7e3ef04731fc56cf896a391587fbe5e937d9411252a83123742a20e5c83b7b9441f86993a46652f75321e42a4c87417c0b6e644dcd26115b21dbef024d2cf7d0d739f2cc6e4369ff67ff42d031be2413c260c83073be707db408f0dea36a94763aadc44bebd94f4a177858f40679ac3762bbd0f03712daa3198ee98be95fbf9e3a08dd75540298d8a8685eb2cb873438a600eb54da5beb46678c1f7f16d26696d95ab6ccbe47b7a592b8d9c283efdcab337a6a28edb6b9d2a9b4b2163286c22c675729ce3c93dde86ee78cb62a08e1146e3c7197e77a6a40f81da96b6a6f4dfacdb4702bef193bf0bf83ea7561bf5ff0b197b75cb7a8efb8e4827f1a29daef84113decd540225f8442a63f0deb8179bc4f45ebecbaf8661b56786f89b8c2204506bec436cc9684393ad2d6af5f6c171a4821983ddb623f2602e5bc8f800de3dea782f8fa2a8079041b3608dd7a786ec9ee881831c82b20e34167916923c0b7da99613854c2acf97e18f350d29c66fde9c825ade6cb686e03739ce0f3f1a798d2d90f79515211710a087ff3eb35945aea8b4e1edccded1f0901ea417f61f180fff2c893c5506e8f8634d24cc5796e967578a850c9b3ccc2c773ccd9cb71eff49e114490fe2998357c28add401a2f8372bdd5bbc7cecfbed656330e31eb4e1414219cc2bff8ad69475d2170528c49954e662727c1d3a5f570603a23438d73d39dadfb09df9c6c3524568dcf538090614918308f3bd10a182d03cf4126c68f1d8339fb6d184719b5b4720e21e069f3798fda93f8387ba1424fb1f6ffebbeeb03a6e89a78dda10a9cc04e4612fc1d513ceac35e7935844f3c52ea099da4bb4c03ee676d403f52f7b10cede36cdc18e430e18d05e98a5f8fc4dc82680688cde3fac56a66d0941935353ff9a3fb65f0f1d83ba63805892ac32e44af15c388044b9e5cd65e921e5e0ee84d8da0ab5172aec02f4485f7e39bef6b75669ae7df9e2d0bbcb4c7005b3345ccb39f1719975935410d257d3f12e3541b643880548f57f63da828603a6a51f17096023e3c636f9f491d8329e8864a91f53539fab56b236b38b54b3f87940e49dbfd658ae1c3a7ff5693ef2da0ea0a664f9f070031338996a2835c59c03e48e3c4316ca9d57b86ef8986523a65bd82714af803f5240e7815a6b89102b026e2c8bcc14ad367103c757798527b344ea9bfd617f1b0f603fa4a6bd4dab898092850fefc9b98b353a3288567ab88a4441408bd790df7b29dc37cce13dd2b54b18239fe81ae60c662ec0c07a561f503c022922fdddc37b6ec9f95a5d956261aaaf49a2970dd711d7ed5945993c28bc427d1310d1fe03ec7dfba34eb39a9e2c21a19f4522a519e522dd2e848363ecbcbbbd92d842f75e1f97921757f2d502aeb2998e2166e4cdc9cd5e967f16dc930dcdecb06b08ca07834620bf01148de03dd935b95e8db947016b4757ec71000493f53ae7a9e546ce2fbd9cb6d81e580f06f0259ea9354ea47df91220b2bc86345fcaa75e5dc3c432990af6a6ed1f1b4103080870b30dfcf25ad5899857e9124a14f7d12cd8b8a5fece233831e53c1d7e9fb3b9dea5dd086b23140044f978628c586f49f8d435f73afae7c6288b7bb319675a1269ed895087c47b88448a0add8e16d24cc0b2a07fd7dc36be03befd7d2017a4bafebab98734975d334dae35ced334048fb2cf45747efa85e1794792f9dcdbe9a2fda7e7f76afbcdfc8d9cbf84f94eaed98a3c960de2ce7b13b3fa3b9fa90606f0dcbb6c227a0706a33dd2b718b431391574caac0cb2c35b3a8138aed0e5cbe8fed69e2216ae41e68ea2ef275e2575fd647f84a1acba5011317211744f35b217e8e32d8d0b18ff5eccba38adc348815cf53480231993c68b44fda522ce5947c18cc5ff224280113b79a0f7db23e6cef682eee1f8a65ac071c9482326d7cb85f699d06f91710b0121205903df342d6fa06cea7b50be092af0d7ec8a4eb887a9378e8a4629dc9bd8de80076e06536ab601366dabaaf11a8594349385c8e0eb63f669bef261bf51a74d1eade22b20781c755a1737bddcbf418d1b67719c1605371058229e75a3e4ab6a1df782d8d40ca3b2464380e5c37d1e5692982354c76102b64a902f0a8b742bf9c9c9d3ad1b77e55c2c0b1d2fe97c466a4318afb5ec62acc613c37de47299ba0720d5fdbace4261355cadaab3801d92f0cfcd0233ca3cc806bcf354c5e47d724d498fefe6767c0e5672f5fb5050e3f34def039e2f579320812c8e62d3a09c337fc9ccadd2da0a2d530d84e40bd7e60ca320df64c6a67f109a50a6b24eeb9af0e93ad4fb192db6a071715509b149e8f134fed2b1c859802e3e21f73f54dfaa20c33664dc454647819e85d711602f5f69b6b8544e79d927cdd09d6e381bd32695a6f4edaedcdc46913f6d8d667a6c026a103cc114f0164b3cf26a95f93438d602117870b87670e292f5ab1ebffe3afc5628585b117ba257046629101ea932ee788585f429b04e8af687529f41e2f84ca2be4b089d4b6c42a90818431eaeceabb8825ad6dfa6370bec5b6903b3820aa5241f5bc8452d98ea094e11c80938539d5c164e59ca0eff7786415900449057ab94f112b36559a4feb769c7c790ea3560db85d31f2f5d8d065d5fe6c7d19acd2261b2473edcc8ab882a84958222d1c3b4a0101e16827f4e3ec1766a4abbd25850d274e2c69c38f80d529948d5c47c9d6797df26fe0b5b82d8e48c843bf725e2f86dfb32017416af594536ca514936910de230ff34512aecf8309e31c9ec665877bb482e86e542ff4b4b43eeb93bf0dc2755db0ba6d0eecdda2845774efcc31eefde3c81a0b5927c27a1172bebdbc9e3c0980ff2c4de7264a9a36d5caaa845ec6234d56593c0983b0363e91de907d7d7c21ba8531336648c26f1352aeb82250ec739373e2e0e1c2faab2ecd16f72fef0dcad60c991d457c4cb4dca88cd3b7cb0a40eb5db9e4a4446fa819da8a52fc7cfc912b01f94d6f213536144","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
