<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c894ded905e225071108f3082cbe4fe1839cfe569ceb5d11e071a5225bf546c3c190cf0276435fe5af7f10fba41f680bfc54498a3b71e8626a5b53591aacff05d91cc547935b64e5e3e261b655f2ee17092bcf998ef2af8e4ce441ff0c4c541a786ea9aa5720e11586aa7eae7f86ea9a7a858b34265689effff25b13e5c202b9f5b8dc002520a958977a16d2b5961f598bd883512ae0fdf2f38bcf7f032b85c7993e790b3882b38b408330bc79f954db75ae5fa49456d3b32150226e38f5101c56354e54cb5e33e5e50018c6956cfb755eeffcf8ad5e8ee8e93ad27061f08c3529cbc2e4abe7c9963d7fe18948e2495a52264ce93f19d5c9c7ff0d9eb2b2d9e70791d39cf2f97eabc34148f811ea336a5dc8f7e433418050a60e6336bb8d6865c13470ba6c19ce4383604390ed2e4302b939503e8d54f1df7178b7fd16fad423742b364b59e0d48ae8c45bd0a478cd840bcb7a88e54b7f4c6954b523b71238c89e0278d4062664db6d57728f70983587148b22cc7ea4ef69e4aaec13524d25d1205ff697a3c2055bada7c2bf9549f8415112c6d9da799ba43f6721c59bc9b2b4aa027aebd2aa50e0b14d22dd27a03fc943d877659a13d2c5d66037ecb939b9b43fac9afcc5c6fe0551ae3524dde1eaa84ce2c1c50c41db42e519305909ec6e42010ed05316f604b2d1ac2c195001af30d266f04b1d829488aad6d7027149dc0363952e3f2b06960948c62d96abe6788e8b5a6d80bba114a174f248dda01d6b904a14adbe9b70b83d6180cec1ea9d57dace2c73bffb926f2d084b73d1198fbc78c4ab672a7952e02c7191829bcb0331674fb5e4ac2a1ad75fa5e654045b1db9be47358c62e0c8d53b859dd1121f8cdf6b60e0bd4cbbce30bf36ac1d566b1c695d71f440239be0e16b97442f631fa5fcba2506e08af6083b81e777edd89e889af1c5ec75564559b5d63ea39e05602fd65cb60771106b9acb7738a7d465bd3f59c7e351172d200383332069ca7b0efee5cbcacf94758b43e56cec2edfe34ecd7c6d7afbb4f33c7f9562959050f8e73ebfd82bb33e9262b8cb6e60cc8952f925e207bb9f59e6f4a1beec626292d652afcea94a5c1398d17cf806bb52b0d5dd6663fc5aeda5ec7edd126b32c7ca2b2bfba84adbcb234a533f14ccdbe7a9690815f2ac30d41b73e648b110453a1f675cbf857dda021837c1db034a90603b0ac67a4f3f692dca5de54a7aac65e7036f74348a37482b96bfc2c6a40dba12a96e1784d25b34ed5897e3c2a6757f042c723b8c6de1612a5c338e8c17da8f6e35aad2778bf2524f4ea3edaba8b9f3621d240f6b692948c60a574dce2d2a33b985333cbe77c76dddcf593b542ef11430a3c3d55fd128a885b9dd0a0cbaf41d49f3374a9ff6752bf0c84ee2d9fddef19043b8a34c4884490741c4869d4a0092af2b6469ef61495c8aba455ed9d745e1c2220839544a79d6abbf9ea0e1f92b86ca48cdfc0283ffaaece3a87d607771bbf91a2d38cdc30c6ac4063bce983d93086aec694cffaf9d2718e529536bdbc2abefb1a7fccd2e9db9f7c4e7b49d65c43cc40a0f3a824a8f8abf434d9b7c88b04581dab147bca35fa2f27a5ceb3ab96b86c4c505e5bcc2970c44c52692356e9bd0da7b4202625ded02b022b7da2f9f7549f4dd1d59e12bd461d9707aec90e4cafb61d581a996a8dfc0bfe6ac614aee17d1d8c7b23bde8ae888bef2c1edb72ffc635a09d8eb686958ec9302908f10d3208c0ccae60592c7c899c95bd2c9c84c32ea40a79620db7f67572f9c2266e74a08377c50f58561c436e5b567f0e8d56001a526becaf99ee46d0e3967413ab6ba1f917a44fe4b8311fe9eac5eeb87df02205a3076f9db1bff00e356803811473b443196dea7a13ee518bc8964fc58635515836c7382846520b66f5f2e13a09bcd58c08af689ee75741745b7c9d0ca5c0bc382a837cbc2bc60a4c674929184d0fc286d3dd4267be5c778025d35c645466f7f40bc9c9a3af43b8db20fccb2f7af618cd5cca1c6dd2177577b5f1f44d640962f31d072b92cdeaeedbdd81072fb92345b5765189a033e2e0fb85a194423f8f372f14a96f9094c2ab632f954d0d0378bd640c89893be7f70dc03eb36192a689571a9e9867a95b44224d70f4ad90488ac2630c60b9fdddd0d9c2980aa48c9a8d7e75d883480bbebe29459b9c1556f6ef9ff47ce458c667b75b28bd13e6e5a0b176840f3f01437bc5859aacfa8a59d4a89c2558806e4a21e5e5b74a07ffc2d00600ae502b9f0a45b3a673d58dea5d5d9c34b803d80276ef1acb89ef170d2f0a53d460ab1e265a731bfaccef37b2958385d4da85fe895f4c588ee1d2680eb9cb7e2217954711f4646f48229e717a7f20fe91f47461a34258b04af8de7b512e1002fa1eb38307d87176e2165e19efb81e651fa0d12bab1cd8b78e72b0c569f952e6a8ebb19562237b8fa4a0d38d8d5cc63d73dbc2f2017d27305034e5ce8ea73b76c02028afad65281f92f5391134ab5fa00cf66da33c79d59064f2a803a855ce5690a6939e7ec6913e9693f032f424a4cb98f3afaa5ad9ad0b1fb6f2c27ae7f92345c88d0580da299669d344463987e478edb37923f9d548799a61bc83a99ec8f547bbde5646da51e879b1b3ecf96357d8113494958798d78d265a42c2eaa8e95bb6ea89fe5a46e0b8e96cbbd362e4c1ebaebd8f40af2d04de26ca71a8bcf03fc46e9cfcdb9e66de1e2af035aa1166ebdd2c3c13b29d63da66c25eb5d006ab4b4982b8d63fe9e491fcce506d5bcc7af4cd64961ad12907d531d33afd2896e002e2ebebe9129c8ac0613a1aba6c812c02592dde8f2ee017748c0558bcb29a83f8585500603a326df52b8d2f43bae7d9adaa69bb7342f16a77f8e2c3205447614dce0232ab5c6c36a4dc2ef21a0f806ffab49466b358b9204e58ed2ce86b45694493fa841bb1f131955b88762b98d0c7246583031bc09a7256e9c7833efb8b01dbfc04a0679cb2ba6001717a9842884071d0d2775bdcc69bb1d26022e829bfa86f3cc924aebafb56e056261b870ee2208acbcc3d59f12ae2543f145069014e4a9c247812d94f2b989e3ce11cc5f4419639288dd4f9f9b80fc6d6e4eaa1d13e074cc9593e55620d24de2f81c55f5bce1512c5493d47f2facde9152a8b4767e2960a27e94a6e01dd5366de144405dfb76fc4c0c26c85d57eeba1276091cd933f5a00f9b149d73b75fac64d35554e08af987e521a84b10ce16c9849a652a064aeb4f326d7b6a490553a921e90f646f4f4bf9a0c355c25e7b11b723f2e8bf071b00195129c71a42dc6a543bf4e2eabe58a24fe4d48aee14e5c1b533c20df228819e8e24ed551397e26ffbb48b5bf7af48ab899a9c3f6ac1c5ee4764d7d85f0d1987c54503db0bd652712b9a291d5cfbddb2457a0b6ac5ef7917cd57b1dd9a7cf1e54f3aef481c5f23929de8fae9e378bdee51a418c71dcdc855ee486b1857dee1c85fd927af0afb7e55561ac44be23aaf6595263f1d6503bca6f64a2489164e1afbbe9715f272533987e483bc70a29e30ffc905362b6a5598aec54c4c82c97bd893e8d0a6b1cdbb342837b2b6171cdb02d8c6b35909f9bdb1308341f9a57c072c059783dba302f9377bbc6416e6ea387b2377a33df960a8a4f89a2fc9351bd8e709e36bf2d831d173ed1acd717fd4decc9b5aa40fae7bd1b37867049c97454ce898c080ea7dbf72b399fe389cf2a478e2a1018bf557a8428d627af3eb25ebae9dd49381143515be6e3485ff108f28be6be8ab9b741293ac0c04b94cdd9de5dce35c91f161c78bddfb29a89004cee1ba74b2212a12257bd04b9d9c2513436aee3f6b1b2c944776269f739cf289c7bbdfd953b8160aa013615c6059dc71142646599cce63758581eb055f3321ad3494d6c7ad7bf676698e10c887671c52494b0629ddf9494d39bad6f619ce7a72dc963ab52aa4da438264e9ae703f9662c912775dd43e9c8cf54303151908797f6a0bfcc43ee080136a8f29ef8719899a31e6138e3d35e8063789d3aded8a5860537ca92a5d0463f60d660114a2cede139ca5cf044821beb61cd0878220bfcca5d194692880417516b834194db1f9525446b8de292c5accea24f9808ade154314c668fcbb4b904e3e7af693cfff7b8919024f59df5e7003791fc0ffbd60ead63ba7c19bf02b08cc32dd08da98d35672274b0def2631da4fcccac241534efafe20852c78e70d743e5b9ecd670e6d00ba152dd80927e86baa9d68a5118359527f471f146455abf9865cb4ff1fc5b758b87bbaa8690b5bb779e4abe29c8090b63feafa14d8d92d0ccd004e160dfa0f1762b6e17284462a619363bd593aa84f74a1096ddb287c0629ee252ef377c4d35bf53dd08ebb173e94a1474d8dc35a004fc61e1283453e8b8381e573df88b32c3a2e31b4db2e2544a8bf7c1ba2e40537e02dec573625b916a0f2311789f5c5ffef20741e38dd217ad60962fd8f952d22b1d97c208607d2699874e4d605e4a96a44a9bd5f95d2743b0c6c43168c9244cd4239214d3822fe2b974df445cc310696e998d1d258c24a145f52073ec34c7bc1cd9defeef95b241ae57cf72d96ec87e7d09c603a9bb547f3f106cc4ca89ae7517616c9b1f64ea4011b9055ab11f842bc96ea26535c8a2441cf0a8232b8416992d79fcbdaf9abfcd12ef135b46023ca87f1b1c6644ce1dcc95344dadf751d829d56fec725c9098b52dc0dde03082d1d54b8646d913bd5f69e5e4557f527ee08d36afdb5a3337d0a24830ab3e6cb9a2ac1d64a661ea507ef9c1863868e0acf9350b67a8058f3cc9f3582136a9e14e813447dae994e73f98dd41948a2699c537cc4b19f8392cfaf9f0ffafe131a69c53a99cab411485064e9cff10e7186e7e0c756c8df38af480d04fa2f809a0249799ca66468b9acab3f1f36b793a7ed0c4eff6168be65a5b39d53aac81a5caec9ff89b72062381c050818bfb08a94c3c6afa9c9ccea1d7c93429d7b4fafacf857ccda313437a34e4572b0f3235c735f0bf4715bbd778e51e8168457790d0cafe9ee23121f75472b490671bc90bb7e540a8623778219164da1dce4ad12c2f88269d80d623df32392884239eade5b6db3cd481d3354c68ff6e0503552105473982a01eb85ef7c56e104f7be3dea787d2fde43b7a351e95fe35268a6e9b100915da8ae3bad32231d014ed3cbab117af4e7ee8eed3c02a14c80768fb9ad68cd15480fba1b32bed0ec619f0c05aeee1b6d61bb06a196a304af2445c423405d642385e72024d731b8d2dd86f77e52b1f63be793c39c6226502de7f458fb626d678d5798876074d472084772310124735654918a83548b7d33ef25d05ee27a33d7fbb400d304e40838be01d75a2db6705baaffb5b771804511b41a75714f42af9ddc8d4d3e6a6b6028311d61d230b683e51e09af7ce92788924ebb44ae0eae8805e9f7c16e50cd5a618fc13fecfd25c2e1890bf41c28cb3177017af0ee63fc57e93751c0ada4ca1050ed10187b83eb07384803dbe6b90f38f8cbc5a9aba5ef1f8b5e08118882ef6cd8329c2decd4677a24586f64bc1fbf86c87d1046f39b5e406a625fae965b78d0d2e396bf1f1b421f2a7bf9110e0cd16144254f821378796c4bdbaeadf698f07182509129bb1067e81cf44c233af902a42c68e42a179a3f6557f5f27bc57adbcc781890d990406b251bb600518ce4b91ae334f486b6f46fd23a39707782a74e07558a597cce965984420e81cc071e6955582a8b322d50358e319e87adb6dbd2db9b674daebe0e363f1acf13c2d9a7809b02b2d6b9158357707b1bdf0b2002729a7cea8bc3a32c0b1d52249d9f437871b4aa5288f23e82efb10c4bb563cb7d03e1c18a4e0dd2f5384f483a4ba7895e014a4a948a4707f4efc323a603d40eb395578c7bbe0100c42b3bc7e18214f03848f4ee78539896fc7ff6bb8aa77b28d891a0757345ceaf3062307c8dd87407621ee6017ea631d59e8292deb01fe0f27868fc7c25da6b11916dd66c23baa20996b0b7fa23ede888a65aee0b66a7eb7a4806f0118a10587685de87fef43b46724fe79d661cadc21830ea8ab4b8a732ca3149fab67577bb3256761b5dd77c67a62f6e6411b90860cc101fe8c37a89df43eacf2bd5910d119316c3f85569b552e877c2a3398da68615f6a623a389b173d95fabe011d86969053c31bd420c72ddadca74d9dbe0f38150d2915c9d81a78e3e68e1566c4cfd3357aa98b612de1f1994b741cae385c5bf520b0e621a727a47f8dc0aef6ba12ae5e65813f097345f7aa698427652b996def0b816721a7483f98d475a8fe2e83bf99222580834ddcc344910448ab84367dcd80555fed60949b1bdd4b7586f3f9361cb5b01ca46c75f8a7ea92ea0f05e651e3621a630542c9137f561b1e99fe6cfe9319dfe6b126d162d75ec9a46393574f3c6a64de617a68a4d61f23c0677528011c85c85f2a064360a151efdbf093e413ccbb0707c76d09160ad0bc7facc64778f3e4da223d48d705d5c9834b2dc0badcb7be1b4aa82e72703b7105038d79e19de750c59b8eda868c768a21eded537a6aeed04091dcf9c1178d5f6672ea178fda63e79eb9d9e283725e0c71ff0aac09154e60ea0f635e95dbb9e32170ff6b6f070421440880fc80a3d07e6622713154982a664c440cf420c9d7e79489c2a54a1c6bbed2836808c9d7c4ab069d4afbce1503470c10c44ff0d45ec06e3c2f16171539228fcacede7f381cee6cc3314c7cc7b7297d87d85825992027424a24e8b6b458ce0172da60789727384b8444c6d1dd5fea7b4a059ccf417ee3ea4cc91764b77684eca20517f541e870958c5747826ef489b70601bbeb04232822fbef8b45bb184393158fc4b23dc3ba864cd2ea7cbb889d5cde36ed629a28b2d800582dc0836a02e6e562f1d02aded6d20eeb12d2cc873947c115bafdeeb42a5fb22d3b4c7a3c0b185ea199a37695c390cb05fc9a6c5b083f4f8e9d3d4b372b505deb03169eea97f8dbc831e567f6a3716af65abc5a6d45ca53ac8246aacb13cdf999e1b8cf4c159b58fa80d1fb077d8632bc9e9515d1816b32e5f4e0868b8501951b77bd9b6443f6bde431ecf9a29308c3d56feba4e1ace15bf74a4f419fc8ab8e7bd1e6a8adf60d84e4271e0c1d44ebfa0b0fe9f95c34e7fa6b142e43e1c9143d25243bc01aa6dee452a2d4d6a23f3bffb85c9a36cdf7b4f4acc87f03a4375136ed677f92f8bcbb530754d0373a2194d4ae0c574c02c7399a699236eb3fdee345e45dcafad4b3c65d5c762338ddff87cb116fabc7ae58b48bd4d8c2e6b3ce30a27b2b6c69fb072da627f4148d866f03145cc041e476d8fd51f27435afe8c0415f0eee1d654dab6fa13f426dd6e4658b00b4ddcd991e2eaa028eaa6d3f77a3153ee11f6405cd27242937bea77e05b0ca3b457ce83f0efb72a3f01bacf974544522e96fe501bb5d1c431654dd4f0af9f3a224cae3d0ed96522606dd05ee6379018dd5711d8b10ccb23904c0c991e929a9d6ec4ef57277c3c4a70a7b6cba153bfac3de13ea61258e7865542313427299e5e2fe9fd6251dad9b60c55f748f2b479307c37895ff20a7f585975781042a1a625035a00d7885cb171d0cf1ea10d45877722b2226b594d661f124f31eb6592c0883a0748e89600bae33d9ae4a790775e429195b8e51dce4979f9f7a50d13e05f805fdf3c30569f497084c6b05a3271920036095d1197fb30017c64a96582466bbe2d83a714e083768af0ca4ac8bc0ed46f9b847b9f666274bec0c197a005570c12d31c7d18e4a66f43057ea23f1567ca445fc9412a24185884774ebd8233662b11b1f2f00b1ce2d5c7a445ef59f0b0a0672e6e5656f70dc573feb432b4bfc67555db6bd4c42b698f6c3cfb62bc7b919955903fe3838c16be68d79021eb6a90bd82c2c22dc1dd9dd3a412f7b53f572e0d22cc97efffac2ab4ecf3e28e1631f0be978d8849362bead988639c0e3c6f8fde2b9c582b710211b44f74ac107ed442a17d3246b86c25a1c27f3d1da24670cc08c632ac10c4bb76e0b6c880a72c2b1e30cd97b380e8068b72527d338856ec83f8645ee6bafb40d5f649404717faa847d86ab5a76c37f4baa46248cf2ae6b853b7adffa9d627b69382623f5873b7f28a3a8adfe68599aae53dfd1d5d56c83da147f7c738744924c57b279ebbcf7616b3a63e3d75e65e4aaa79b442f724f99d077afd9993cbefd964a36517132ba8fbe227c0a04ddfebd8031a6c43b94973b676bc0de3bc991d294447bf4b9caaf0a8bae0262367f4bca599652e750f9b1188db1d5ede68d5f9e2878bb488172808387fb668c3604f39796195d4694879cbe2822e8b08d5af72a66d0421565b2b68b1fc41e7bb4a51c5a810c00263a2c97190c219e3ea5bf359b14ffab06840505dad654ae9e0bff5188aa8d13615bafa98567d09c104d668b9c4196d16f7f788df77ea9f7b8e2349708144914c4fe510ec865846e008a5a035cfa909f69df1340b99dc477ea1c31bd38bbf21d0ac7d5c8c4f3ab1a8509b356a8009fd8a1e0dbb914ec6c3dbea40436c17ad6b6c7ae25ee53b70428fed9820d52a27aec83f406654e2513dabd7a9ce6e63ec3f835c843243b67e960fafa3035f91a9f7a8299d93e3718bb80323f714df6ebec00df0121d2c80bbfd395d8f7e003fa7d6bbb3434226d278bc5df93402ffc03620c65bae9d4905207909eb71beb8a4bbb5d5ca95a73128634ab8b0bf0a27082f5c2e0987dda05e64492da58d613e7f5881c722fbf1d1d51e42cc958d12751ca490048c8c8391ee65fa8ec22a0321d97bea503f7687ca7425a7280dc01aad14e17639e6557f04dc1aec49315ba425bfdb645596ec67474937eeabca1f97fda719b750f895ea037f140c107517aac4fe16eaaff66780e2c9b6d77d03955ec49577e5f686d3e076fa7a67ff855252a1a77c3036ef40ca601443c14742fc63d49702297c78fb083255b09eeb2bf3e8b17e304c7d6608dc69a978f04f4f3bb0a2f9ae468c6e1984a56e2cdf13d6a5f82650f97b0eaf51b3f6a1464b635472b180748a88f9b2fcce1ba0d50f8696f7574e15e126e39930d738b9a171478884724aa2523eb6e8ea53c5a32461a89dc3453fa315c4efdaf7177d4a5ccf2b9bca14a03d9d97aaf61d989982ef010422c8a816d842e795a3dd1f312ce29e83debd8ab2c5ca86c4118adc51538199876a954d7aa4229b87b520fa8f85b29bf3ad433ee23e74d968e5a0fcb0015b2dd0a924ca311915a5a7fafdf20da25ffa639e5f33778a33c75858bf711b127d38c0da705f3200850c50fe160a71cb303e13ab849e37f1dc19cde2f65f3f8d9a840e68e91d234425da6dcba266bd9981dc7616d9cd480a1c2184e8914c1f02e47b5d399d59e3290e77b4adc8b99370a06a17028edaa3079215cd9c3e55e1724a686b8810a7fd962d8bbdcaf7faf626030b4e3e62b6d234a62f4792ef1cbb36ec4ea973d9ec14b87c4da997ab4a390e3ab93a9c652807c86746d21a9bbe8dee439a5c0276699581cb47e9b8f649da6e4779b7bf6d7c523805bd7d6e98b12eb668287a7fef3df30597364203f0de53ea38cea20773b9515e596d2cd9c2f60f76c493370793acc738db4ea4d662f0913f0eca77cddc068fd41c0fa831f795b9c003d5f308f82e656c69ac371e5db41f165c34782363086676faddd3b4b4e06bb5fea2e71e8e711732da6baa2ab4b2a954494d185f61cb70cb7e190604910a3dc9fba254aaf77405a452febc4c66b514ad8015fc383d1b5119ae7e4d993d99fa3b4019c74d43d9a8cd0056cbb7f240c0cd363db2545d8efe9463f4bdc7ba6df29c5fa02a739ffcc2d47ef8e0d06a3290514d807bfd0cd31e643903c8ecb741f14358b4c8105744dd1f826f52c0803ea36dc667fa4665a0a91111cc4161658c903f3949ffd2583e06602ed256342be0a273c37d1b1fbfb688119f208f6b97edaaaf7bd5e9ab24c4d364892b63ac215d5a8b53bcc23c2cdc1b22909d396f5832fca2b16b2c252eecc97ccc7cc33290f666809e14538d4bee948ee0da079b0277f6785680242ae49dcf8ba5a77c326b785f624261caf8d75a1bd8caf4f70ceb9702083d6b12b7fce367a6f0e10ee9d86e657f5ef51ee90e1c81af4db4c63d139161cbce18db7745dc410951d8dadeb1a5826fabb5fd1d725d9246b9f5ee38743f5622a2e655b86d692bfb32e7dd9ef14a5ef2c9d47fef81a4f055bfd8208557043dcd34e2468231d4c9db568c0d75001a56c452c3c82fe508cb4e8affa310f86b8a43e2a01e0481cf88701ff49eb363563f2f6c6b91533c92718c47c189958b4f7fa411a8727998ca40faf8b5a4a167cfdfe75cc69ce88c084e55c0843d22741f6a0650f02807f2464d24b935df05cf1f28680bf9d3d34f72730279945d8589a766555abda8c935b2bf1845a0dc953d5ff32222f902bae0fc7527d2dc417ad216556c288cf7c7c56eaa0066a5cf52f54f9e5bc3ccde39f30109b3c71539c159d90f37066ef4a50b0df2942c55b23f7d4fa12765c87a1d4109c0e0f4aba8c0e0b19ba47d2c15291e62af06c1d4044ef49f247dc2f652ee6e69dc141cef10572d7441de5cf00eb3d683a09896252d207bce359bdb4fe0764553c2b2b45103826251cba5ca304c9b4f28f96ae6f03ff08e13e2de69527989f3a51742d844f4685e8bd3a00b3e4b05ea164ad153f98d50fcb43e3dad05096978f4282825bd5e38dcb01837ee9a892d1bffcf60e32768a3f695eb048a66b3489d4767c34ef6fdce9ba36a28827caf784d0b675a597fb5a63868f1403a2ac1a69ccc668ac7b6b4daece25d11eb1425153b7c64bf3b49c3b1b516d87990d74be63bf7a96750a98d291d5f1048de56c06c8d9fe6742a0443606446c22e02f442c4178eae4328f43fd3305be7ff4696058a7160568c05d350850f01326e275f6824a07b53d07876bcf4413a7cc1ed15fbc4d6e4d5764d6a7efb7b3969e27013d379255a7823ad4229d5346dc5696865b71cce37e056048d842f3ac9f78b340783682838cae8217123ff92708e8d061ef52e2fbc17eafbbaaea4fec4b0fa07f876b58f951a8f808b9c9e30ba03ca00988dcd07695af10adbb311d89f80da7f3f2f7eaf81003a69691b535cdc61cfa3cc5b91307c60e21f42450b07b296212a2b7a6d66bfec01838cb76fdfc9274006e0188129a1837ec3a13196c494356c4babdaae5bcc03f10420117fcaea8d13e3f6e2ebb3f10bca13c079f79a8cc0d3fbc36a06405b8b42dd98ffcc80884a1bb933c6786eb0f5d7287baacb2fb8914b0cb82ff224708dfdb827807fe8bddcf33b55c99d014a9aafbd9e0debe77b1be6cb0963b45544c0e79031690dff60566885bdb644259814b80ec705ea359f90a33412d62bf0fc7cdbe46dfc98c37d521a8e0c4dd5f97be08bba73e5a861006a4a03fa0220fd81e5abfddb13d35ea87017a232a5fe8b68b62ebe00b5ed6f3263f8498d26d1f2196f4d0d77e08eeb3cd7259d5340ab949dd23dec65a11b9d9a9679be29f600bf6ce7fc91919654604218dcbd1dbf6e3a16cc599c26d266e0b58507850dd593ae23d341255fed1cb32a2c0c3fd6434907c75506e64974e0ca2783b1dc3278869e4f918d090136ca08040912aa48905c67904c4494e1e236bdead32257c76df139c6aa0c8cdcda3d553400c6730b3f8694898d340cd24a06b70708f4966f35ce01718f7199fef15981a2bd96b524e7067f1e17ca85db00b6b9661f54bb96885f7534f8f5cc2d6c525678674050576d33012e1839c09ee2a8b26947ace0fe5842b954b6d129a1eb37595db032c555637377ac3eac79a6ea5f0c9781ad56ef612bfb4561eaf16a3d53df952a1805dc7b5323488b09af25296c69aaf7316c0e9125bddb574427a779e85018266e05240e6f8bee252856b0de200fcfc30e7a21105acb618bb2e3b06de17641b70956bfd1b1f7c8601aefbdbecc6c427dbd11021a2677a0e3b5e01d92bad839708eb7cc7ec3b859f885a81bafb8286ac7617c83cc026751321f7fd1a1fcec05c7e45d0ebc0a2928cd2c6e150986588dbae35e0ea07136102178d9832afaad1825746222ef20d025d7c5c6956c5111ae9f0783524d344cdcb56bd3c60d7b4ceec0ee2bd56ec72f5cc261beabaa356cd2ff23a8e09702ee4697575c7ff79e20a067aa03240abe53f45dcd3eb02f2a9d5e8605dcdbdc247a210e66baef94164fb44cc57514b791e075c2fd26106225335e11375677407fc231ea3925570eadcb34fd1eb845ca1188e854e8417bd9245166f0881c0490ea222a378b33df2ab24f0513298baf5602ae71647c709a301a084b84ef277dbad9c923acc96405ba8ae86377030d2c1e5f9c0ae079172d22bddb9a69b0231d13ce1be4bfa11fbaf490b5c542f907d84b08508726868fb62492bbedb437f6a31334963bb634db85eaed5b5f7cad8c0f16f91752fd7881772ed2358902476836f2befb6ebc7e1268675b62e16201b67a7823161e0adec124afab0195940b56927f3875725c41f3d6c58626fe009fa0f3e64e15d93d7f55d5648ab7a39e4223217c8bff00725847f68a75882fa8350cee57482cd2ff49a8cdf4df0a4d3cf43c74f2b38b6e5e4214a29fcb63f63ef101900351bbd2ba2486209ca70c26f7f30d7419a063dacba414133f6e3dc651319b1bd485c9ddfc871c60e24db980ac96e0e7e26ea7cdaf12743f502176ffeabc289da9b7ef5850330c892f4468b6f72265d9e18c89a5d34fd740cb9cbda1ccddef5d577adc3bc8c9eaf14e37fd185366a5b3e33383163d92530067db3d565282497ba7fbfa2b927af9efdb04a3b375d2d346e6c969a22e1712a54cee00ee3ad1f8a0c47780fbcdaa5a439841f6c5b5221a9b961cadb2779a24ced7a4c9c500f987c5c0a9b2afffced4838316c2c2d80b4a92330a2dbe577b2ce19842fc616083cc7eebec06ed227c5d7cd6df93d00c186147b1b9edcaa2238e955f80e240a171ce73f027f5b7d7af645737e9b753d98bda1f3a67aa8339a9dd25e30ffe351c30d07ab820a9ae2f9cd0f1f73a93a3c56c486c714e74c2ade79d6bfc19237a4bb4aa0e900175b2d0a9bb9601873b36bb0be8cb25180ae1c43f8ea4a8092fc222fa82447425aa080396e295f33cf626412f5e9bb14f29916e3e56b6b6561ce1081966b53681c3588c67c8a3291b7543926af588c3afe93bd62e112b5162ddafdb47ac8cd76b1bdc19e3dbfd3168b22139105da7f548f01f61b169da6b7f2154982e15e9f48ab23c7fe0689ae9f82c96da03fd64b45f97d1cc1835bd6a0d41e708401833cf8182640ac8e35ef48c7c2f824f339320f7742a27fb56c516ad6a1623249f2e8215de6d2f4635295f92f07558466e42d6c8d98d864e4c93548f51556e4c58d3f80cc0d0aa5a94c141c46bac2cba6d04ae39ade457691f1388416142660c1b275d5b13ceba3267cf762302e7c83d68537d01aaa94017896aaac05a2463133286377d19ad8c3f6f75354ddb8aeb5e7b3175ec088381259f6ede26e25b4b93bd32507773a96b1baa2b4e8f95ed7bcd04cafd74e254d8158e5d630dffa8773fdffb238593c72765824e113bac28e5e09c6b4fc752e8fb4817c246683ef5b6415c008f170fddcc73e092ebf219bcb13064d2e7f98ea6ca695d6b9f3beb1cbaec3b88f8bbe79d26b76a4a51bc523818425a59521ed1ee78f46e6c65b6d280508c47c124f07d87ca8b56b0d79438ef27f594da0efe2b686a46541682fcab88fd59a7939d50770a8bab6fa8d1880b35946cda001da852581b45fed45b54f7ac22273b7450740af32848bbf2f4f8b230fd2def39bdd7cd029beec53a97d8c996594ea1e9123285966fc7b5127e2e6951802c29a154ec090054e051c108998485ba9278406a337968a301faa70b351b330ad6c7870eeb306bbbe0e377e9e3e78491311f23db3054d774f65b0222224de998c10aa2d70c70d65c3be31f862dd24bac76f26e7e9960f2bad1348c4742edb8fb4992e7909b5e44da9b1b8ab4fce7df812344caeb9ac8473757ba200ac7c7adc3fc95b46416fddf14bb6e00d42b035982ea6e25eac645817eb4f32db9d984d6537bb261ecab54c1d3749f5d30b71963f7bbd0b0ed0f89ce6e296e898445db06758059d8b4852f42fc0df5d35fdf4446a70b8dda0362d23298a02ad655f5206e20e4854122b248b043415b4bb40094c9d08d601cd9d442b3bd001489f6958396fa1627a9be2affff1e78549ab9e9f8005b4ce71712cb56f735e08a57add801fffd32d2592091d3daf6e1a4cf92cf8fe22f53dee76907e6f729cb62923edd2aad38c817a2af6994e3eca4d6f20abf0f0dbd6c8bb96b341b58b33cf4526fb1d1b8281702c819e18c8709799609be68eab35151fd0d21628a7cd0dd4740dbb44199eb8d10cfb503d3d691228c4e8d2914760b0cc640a22cdc85dfb3f52270526a21bda14b96b19f1a81a46840d05c31b08ba0565c0f88c21e8ade7d0a110a6495ef1b721a300f202fa420933d00fddab7e1516a54428b2b95c022a30bb6e2c5361b091f319d1725ee659b468aea0dcd529d60cad58e3ad37e87fed5218b11926694c4a361ee94b50ce027d542c3f8f23b22f21e00e0822ad62905cc254cdbd49bcb3f26a833fc0581b9e3200ceea53b3cd156e7ec694b4f26950f94c26974b0e42e28b05240a697bee7051e022564c6632e03aa83cbf899766cd53468a92e2b706574ae206efa077aea0dfcd26549f692bbe29041372fe64ee02629044ce115e47e8e1f657479bcef5f4eba56af017736ee35d0fc352bee5dfe96d7c88338c20342abdef8dadc8c38da97cc9e9230629ec5592edec31ed3856a74538faeb3c6d1a891a97128a2fb88afe0ad7b01c4a4609e84e738035e81d32330d274f80cb935e504fc51cf9d8786fd0d90c226dbe2b077c427f1d755493a2da1573e82e767d29e661ae27768c06fd9b39cd86a0609a404504b0dbd00258ec058b62b9b3fbed30e36f4eacb8560bb38c88fd466301795356299a2ffb4fe92159e6d348fe0c2a21eae3358e01ccc1eb85505b514597040013978d88a964805135436fbc3557feaffbf07e35802aef75ed5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
