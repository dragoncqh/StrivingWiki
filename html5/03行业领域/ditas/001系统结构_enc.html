<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81c7cbd0a4f8a2be6fea534ef3c9953d43a3a30a2efa01d6152f12cfb65ca880ce08b7aae741a73f7fe4f5ed10c94dc88ca732116471fc4dbd35f2f23d438721941fd9eb262b70912a987dc0ec9e869959e221a6af5c2de177ec0dbadb3e77a7c71fd4c307c2a4105bf719f0a2e63ed55c0e1ef8e8ab8c2f11754431e205aee1499f4aa95a3b2c9c8b49ba63a58433bb162aec88ec259e7a56e55122f4d0c4fdeeb08ab6c76da2c0633401500ccadf7c849a9d14c2a080a7f0aa8101417765d97b87031ff7aab24a235dadcbfaf3304594197c86f934cdcd90ad0d88f28f52b0f553e564af4eb74b690ac12cac932b8d1ef6cbe7c25e5e3ad0b213a8540b7af5da10f86b02a30e75fb855e9ab6ebd6d2f5bdf3a843a518ec2711ab11d85ea583daa05192767e1d3d72d9cef75cf146353607ff1d87ffbeeac779d7142ea29d97d46b03200a178e0c0cb6b3a162aa6a21b2c5fa027aa75bc4171dc5bc3c7f5d198f7163d2fd679f37e8d30bd055816bc1b862e8fb71481abcb35a1287a98a79c0d58dfb100a6295f781399230f4e71b075be43c0c61f8e2928811e53b9691a65ed10723482ba21ad7d58c8c23423b423273ce8a0af96b715fdb90952a82f8eab5e9870d7ed43fe5c029bbd52254dcfa881e9dfd13f7d72f91ef1de1144068aabf0730a2cbe47ee1f89c9fb4be8b7616c91bbdf31fb299f8fe33016033460ac83a9744bfc099b69413d3754e151dc0af57e64e3ec463dad4f6694e353236c7a28444f2f4725e1cc2e34a36348b6d7eb9eee3d0a86c6805bab530b5a4fdf200b17d58303da284f3b7687c2b13cceda7fda938cc1f8abfaf9ca60e00eacd1704fc0315dda6ea86bec7a1cccf8f02f4702ffb3e20df4097e4521f47191a038943fa86b8b6c4214807a8e7ca1fff348569469859fc98407bb641f00431be77c9d2b4aa839b7c2883a318b8bb65a14eaac918f5cbd1d98f29f17b5d16fd679b5f9e167b633e686dc45a36f1e8bd9059740ca4458c5a5ed84784e2f8a5e4118c7c390b011b383052e03543178ab24c3ad1001f9af2a8ef91bd2fcb6a6a81907c0e67c1f8c8a8414703057018acfd64a4b962843067b093b54f1fdc06d1699da72fa9adeb7d9317b985d648ca34d214b47374abdb4233508c91f6a392a681f652570c48379abbbe39949a2975d1957f9472b4eb33b5183effe131773f8ebf2f34bf7371e5400c0b558ef6ac17e00767756a3b79a35a9287630a99f6647df72b5c71fd03ccbe20129ed534748315cb579a1439da9f6813a57350180f09e4bdb3081fdc2e00cf9f32f1d765eb7ab27693debc48767e8c7493f56b620d2f19a725f2efabf5ae524b11baf87e865484e65abbe15f9517ad69a036deaf0a59104e6f1e3c2f5f276cc2926bebf9aa8719e8f0bb0266464931cd82e1e5000c16f1d01e571b59918c9bb0d4681e88b113984f19fa89b1534cfa7683ef462136e0dd2f3e5418ca6919677f7e4b924de6af2a337a2f142cdfdba362aa2d232bc08f4b292a558751b0abff4ce3f87d82d4f4933590ffe8380174325f5b4c99e0904b81879a413faa79c03b16077537f11e02a78c716a624ab1019c33e421373899b8184243145b2bce34320410ca6861b16e4ad5b37c186768d1cad956eb2ec5298884168c996533c1177417dc772eb2a0f9ad1a168cad970ad5f18e6de2ab8afe70d20cccec59708e7d9d7c5504ec8a0e10a293c5a5e11b48c8e2ad6350e55c537a781837719ab13d6fa8cb3ede39922b3433a04807503a37ed08d0ae70617a83048f2c2cba17a7c461f635f5453b81e4e88db93e3ded18c40cad6a69d18bf1a60fcd046fcb9ee15e1aa027eef3ab11b4b9478d21aa7e16450bac9260499a302c9223e63bf0eb56ab6fbe40ba0f72c29a7d75184c9b57cbdfccea86d04f79ddefec11450f49cb84e36640b59519a7f63d723fc9ffe16a9ae97fa5ede38091bf6bd2845995a9c528e20f70e42b48910df8f435d4231b9d45fa351944c2f966dcfe3fda146f49134848a985a30ff4128257523ae43e829696a6996d118e2d8370198da211b7442a2bdfd60460e81fd1c148919b6924271dd257a8331d1380e349513fc035f891f5e91ac925a21344e0cf4d54fe8e77ee68be544b834452df97227eee0944b6071112dbca43443cb3ee00ade998899174637ffe184637167d8a0931f15f23408c5f152d259736733a2982f3648ac8efe1ea1683dc600c4c0fb462db0c0b81b45fefa50c2e69bafb7bfd25f12a07b39536e9ce6ea9be2463cb8a4c6941824489f2f463dfabf3494eddf4e24e7cc04c021a069b8ee20357235b5154056e91f6c2de53c85c0e7e2b66cd4e427cac140a6d6383c51ffe6079e32acaae87bea7eb2eeed5bee8c251d2625cbc450ad426543cd476b74fe5c0e343009e36ae33d90ca2c4294b87fa395aa8a5d3f8d4166eda22255be0fbec57d11b23f50cc5b542add3c3b9f56c37a2757d8678255364ad5f8861adbc23b17e6bbd7e00c316f939d60be2fc3a4aa0f7eace3feecc6f01c5a714d5a9c33978645e97df6c556ec28d418f4ac4bbe4e8cf1f2dabadc2cdf9c26d3d97ef7b97659b149b6487e22670be85379fc828bf4b08e934989eb0e0e5bb470ec3f1e5b1814064630824b380c52c6e6fe3e3cc8d8579d3ffbd55e897a41b76f9c6203812382fbb74a9fa598fc9c9f2533ca8a871806284d2263539bb13750979b41fb202df27dda183c8d0c9815eb610370a9fd60475554a309535fc83e1b09cb284ef731c7d8321badc8aaf5ee7d6f93affa4bc5b796bf95862ac050ba45c4659adb46cd88b44793a6e02a72c6a968ebef01ed3fa4ad06e261e897b1b09b2756840ed153744fadd19f24be27f8b292ed4b91639283b0d251e0ef96773f842b65a2d760be98cd93b5d738d44ce5adb27fb907f61892954760735843289e162ab27ea2f23f7ffe211f2efe434b85f701427b2af5fcb1e972b218be120003c6f7c1e9dbae1ee1b3f75b72a9f4e862442ace23f131b6406c57e80ab3c9095e133cc04cb18a45559b95cb732a1861ea2e4043f8875d29b60ac206bffcb56a380cc4b1341c36934d51ceea4f8a00bd85085bd6f32b56b48eaa77fdf3ccfc1d8d28a8a23ac5cc2843ec69b08ee1d71956bd877f4a3e37ba1430b62d4e928a17556bfe78b68b93c814f88c2180173c45092625e5090b4e7b7dc0d9ffed997ec400dad450caca33a95c5707bd31fad73b07880a31062289764ff8196d6cfc9aa5ec97287be0857ba9350220230d1b4f19320352bac802ef268d448b5ec8782ef9b07dfc3940939b1af4f78cdec9f3997641c2abbb634a2f70bf33cd58e11ae6ebb2ec95f225c5b38f94125aba5322289bff2f1cc0ff6e5d94d1002822d8e5dd4be79b0dd9892e0aab0f3085314777cd01780a329e43a11316d7afe1130ffdfab03ec80430751b2e09e685f24a6c4e1ce8a64c9948980ee9e3ea7313c862cb607edda5f5f998e3831c25b44da49c3ea0f33aece24a9666f30af95d7e16f4838705ad9e8ec83039f158cae4f777088cfb5f3cf8e60aceac9fcaf20c86ea9f2f442532ffec082c87d4e75da27683259946e006048ea8abd0860da3ca953ec8ab18141064c0bed90e7bb4c09d8d6787ef156db83a46ab8302a0b6657b8c9028a1c94331f48eb9ac78f1647d209f3a9189a39c02320dccd6cb853f3b9aceaf1893b9e2d2b15e05769a7552d43663ac17ef47ac7924dd40f25cd089528b967b481fd8c9e96b39d8ee5c323f64ad5f29fd82347a7ec4eedb5da6e2b1ebf7f9946ff02f389c2009cf5d276a7a6b42888756ea72ca3d8585899c2b64ea84a140cabe460dbc44d1f058c6ecb0eab5f768680374aa56f08bbeecd22757466aa4df2b28ee6afc625eea82af1da4d044e1be1640a2c5987a310c9e738d6e4422ec4da5a4333066720e1251651996d0315e0a726942a9fe1187448e3bffe615908b56e811206eea46de24e983a830eb3c9654a7df3d827e84881b3735c03f1ccea878bdeed76251d6c07379f1bc2ddf64c203ddfc8de93c2720fef0de841ff0b83792cba47c51c50aea8576f996fa6e81672bf1651758f49866120028a4193b0c4e04861e5aca7f614daadb1928e68ab854caefd30e5e3d473a0e668436e746de9c22735e71e695a38689a30c80397b0338e7e5533d17f47b570d1c3d0832602d666da161a978b3014483b2c7e27e8160f0c679d031d104be3a9a00314e550014c573219e7c596a2b74519c538153bef55c6e4dba62b25f59f5969512c12fe2e1e5ad3e5022170cf4a01309e71c12e3a09141cf462d9a3846f1b63b5e8cb0ef21b7f6acb8aa8e925ea526283ec7f97410b5184af546602962d0fb242fcb58c944b2147363026636819b3bc1a2b50576423c0d9cc9ee692963308fcd04626dc0444d51e44c4d5cfb8daf39a7278ccf5a089417a4502d3d49375b6dd325519dc1d08b09e0619d48fde6be41070e52cb219c91eef8f5a5654a6eb2b3aa5dc3e7cd385f7d49097c2de067ff63c3b1e82c7eb6eaf29014b63c8c2b7071197db3dcc284206f883d58c8de6a5f266ec9ea7ba5a5908325987cd535c429e3594a0490f139ddd039b9e59e9fe02673a95499e07c5561600ca2ee012693ac1ad76fb53d34816361c646ed48b92d32ef0215b30f23d72b43e7b68a9593ea0b1dab6ab37ee044b94cf03e6642f519e0b2b96f3f0e8fad537afcef0993e7d46581980e43dafacbf95087ce82cce8bdbba2405ee0353457b169dfb9683e064096eaac4c651c5ddc37b40d534bc32deafba41a1d6c7c1222183a5f3e148268bdc2d0b47c51c15b7d795ed91287015abd81075e7d4792d3593aa1c81dd1a96079c3a8c44382d679e65ec5160431f983c9c6fddb8205c32b5a3abbbaabd8b1b03cfbb2e6a05ed4aaca473373ef624c82a6073549530d7dfc21315e3325d44b07f623b5039b4a21e1a81d9c146ac3bfd5a022c65f14e216223ec293adfdc63d07d3dd148e25cc193e20a92b10c00794abef97e70e2eb88cdabfe9e591184999d540ef934cb5cf45517175e1730e2abf0436296c312e16a29d78991c6eea5d0903349477b08241034b2f1a531c236ac381d5b42e5590e1eb3c436eb20142f977e872856ba6485e1cecee7613a976e422d458d75968f726e84d01183be93d4fba41c2cc7bc722684c5791d3e438f47ff2a2ea95ca61bcf56b9d03eb32d3d0571688a7d113832bd74082007c6129ba6ffbca63f3c505c8bcc8979cbaac44cd398207eb7b51cafe51f8fc0eeb864789cb9b3d2b14da83a3ba4ed67d2e399f5171c8485b9652ab6e5372c02c367b629cca8d7874681ad0d88fd53c3e418ae085681f66af464819e9f0399379e5421007b50be2390dc14b151b5f80f4100d9e5c9227c5dc8cceacbe3a5268ba0d8f4a399ebbd22ea6e1225a4de9df1b69c4f40076f9d6a61648f76feafe8d79a70830e33ca17db59759f932e99b16cf65d02f1630bf7fa8fb852b606e5d56fd51e278de71db1248c7cde6b8750b6d667475ffd63e59c81544efcd846884fc90f1ebb4698be5f030be809428dd0775e9ad288b41f08deed9970bf953a2174fa263ca4c3d9ce05856d716972130a2da586a732f9beeec1ed5e1518be8fba2d01ba32c5237c94bf6d14bdfde4b9a9a2cc92dbf30b7ce194065dc2cdb4de6f8e838a839e4a9c1d9e88cb7ec72715d9ed3173c066e1974e07285a54dbc764ed4114d67817912892c2dc8d5be1c37173e4db0ce0b8f6ae5e2fe753871e17c53ef9657c8ed5a3a65284d1e532f7bc3c8032be1cc7631fd0f8ca4c84655c651b854dc709295d50efa4355d711912c4cb7fb8d3ac74aa8cfb2a0e781102646ba15a1b334f27a843acb0b05415c706b7b67de9922dd0142f7843ee2b182d729820714d365da5ff1c47ca92f1f1d8843db3a318c8dbe7a33546b95bc4c783e8f9702c1aa3207028d0ef700de9a852c103fb7290436b2c28c63b16c20e59109a37c3b438c4e707f7167fd4e003ce2c0630e62cc5c8de18cdc806db5d0054fcf0ffd4caa99002a998600f672a1049eda10e485172d10d08d33a314c972e457ac2f98df287cea0414fb32378d8e854a4a0fb83d11ad76c3c02d3d0be14210cbda01e14944a1b7cf74869dd17608f71eed7f7c81259db28d2a781da13340130883c44eb22f8493d491635b97a2e502491d73a6ce321f8b82853ec250f9f43c49db61b4b0df4d8fd3e4801cd2598fc8e3480a272a28f90201b04300606c4dae3a7ee29664035431b48641cede5dfc7e9a5ed10615cc3ae34c072611c6c61c38dc71a8987d3fbfc3f407965f5b0692a181d84a4cdc71af1d41ba2a6b84c293888ade34aa5c71781d5117a3e5cc32ffecbe2d40ec2070b4415f01594d4cc4b3bfb5b9fcfd54ed741eb2732cc1e59375e81f6b01e3b168ebf5bc29b7c214e0581c4ead1eb91eca618d10393491fc230628dd5a33274715ca9175d64a23de58315e49c097df93f53465e7eb6621bc39888321297146c08782fb95bb052cedec552ae476b9fecde113ab1c569061a0ffbe942ab61c7ee1b672afc312f55a9ca339a4010e58a66bbbd0cb42c30dadbcfd4bfccd38b2b68c107640fd99739cfd771eab0258964c4be5435a66a916c6e06b1b2f52b86ab3e2d134ddc1eb86a5237f2e1484a5f103ededd9516e3206504e08e0fa60f3e24d96c6480e8967e71000ba7b7bfac34b10789ba28585a818a7d3b0475a6f2a3d75370fe825339bea74fab0d6dfaa07e1acb0f11e2e78e062d6d5a7c6f06392d45c9d280c18566982ae09019d4f33f0550fff2cb18863e94aa9ecfb9d2d01be0740d047f26326465650cb573ad8bc8a55cbc288e15e8505658edbc74e4efd4ac488f939dffd068cb8362b35104679d53d2cf71ee415b5bd104fdfc475abf1f5621d7be6b681115060dc36da7ff0630e578f22ed3ebd4c6c13b47fd63610e8e9053a1f9cfb861b2fe5346f552b0c844e5e412d514549a7835f931cb29346d5699a0f6a11f9db570d6ddf4a7828e78bc7f207d7b05d41e959116ffb62bff936cd80072127ee5ab7fb34a2660c0d1f62a86eeea25c77c1098e6557ee8f2de11d3bd8d18802750d4a9f7a1e8365c0a1d340cb29e883f4cf6dac87a9f42c9ebbec63470cf169d1472d5ae57442a78576e64e62b2d17d47cec8f91440e9cc0a8773d1044d6814cfe57f17b53b968fbf6f82a5d032944832ecb5c9e7e91e69711f85f5170ed170753be6533de726a114282bbce163ba936ad4169bea5ccd76664d12aa01ebf1ce76edd01b7d9636414c4b8fc2593ed470eba935f00751f42f44f8cf05f9410a4ccb52fd4b29c62ea6352c6cb4e1784e809dece9a28e6e1fada62fc03dbe60ff8d02ef461e7c3a6a622f03d73b87eaa2c1afaca9089d789ffc3bcd53fd7f734079f4c409b11dafd8f6c559096873c1c1dd86ce6752a0446f7c1429c1995658cc8e913d5316fec020f671d10b770be26a2926e882d1beeb387fa1355959c33c4e62bd06b04f8963cbd83ca14eac001dabe9005518eb1b3bb7e65c3f5fa0d7814903d7b4fb155e2b4b88c4263467c4fc89425f2d96f4731cc07f6cbbf794432f0cb2cb7ab9168c127180225a2d7412c86185ec03f8d6145c94d62492bd46b7dbb604f2b3765537a0833cac5ee25b20bdc44d22404df5a6cdf9e298aca674be7fab951a8f1686b0514fadb9fe930b4e0e346d604314c5f6e11e2bf358d0fb0a8be6aa8f8e01ee78cd2b74dfbfa342c4629b0bb252b0a3cf1b1a13b599ba773a19dea69dc64a8625cd0c66ca664855067ac55cd345b63962ffc3c0a10cc0c16d40ebf3bf36f177dac3facffeb84fd86c3afd3f402db51a11e64a7e2663e401eaf3037fe4e4fb96e1f6fc11e4ca3a3094a0924164d8a730ffa22bb311b5add7905918668f10ae02f6cd144309ef65a517ae2437a6672b4703f368768b71c79a8aba9ae7351e04bf115784a1ac697116332808c5439b1bbc31e7565ef818e1f73910929f9f54bf8d105c61f5984bb5d1b93047ca2e610d3e47b69957f6870a582619b7b3463d4622d2ac289ff412628d474c0768452fcc035e900da54f43757a6eb3b9945891e15c50bd6f4b543746c1b6e067f5eec2611aa38d850d9e3eab87d248cae6285fd7367348f39c69019acc5cef4b72bacd24cd9330ebbe3524772dbfca0439da870c372a93f421128874e63f851804652e88923c5af214bddeb5d1c8161747a0cb18e5b688313915952e9a66c7fc40493103c627d79ca2a36bfae5ca68fb4ddbfd07462aff1ff9f39ba8f2de9516cc7a4272c511dfd3d5939bea20f78b9d3a5244e6810982a05ca0155df69844681fb264116ff2e967c20b457e74b286cfeaedc1e7779c6ffd59e93b549edca1db76e78cee478fe61576c3f6584a92c60d9ea69b64b8085291a2b8a79e38466bf07d698475cd2a7da1ed62612370a2efbea2de4c609ebc3d83c3f195957e060c416b93b9334ca2decee900053889ed57aa7ef315703d4890f51579c61e87031bd70923489a25895d986e880b005cfb25ea2359099630f07a38342b6b7576330ce92ea373f66f6d42b8f199b18d86932b4a7a5869289b94cbb7387f4e722b82a5c9be93f19c71d8466d9923c00d0d2ddf04fe049143fe495a7a48e94b6684b29d147562547aeb1c35491414fd667387513688be4830dbdd12fea2d92ec8e3b3862efb07d252fddc41cc600da8df1cbf4bebca831b383b3b3922a34d6013dade4856d8978b71e5968b34ad2f3d4d0a8e0e3942677c72409148a4ac56b1b99af3946ed03bdbda7b993c30e41cf12f716ec612a3f1518800dc637d623833aacbe56e67f0380a65dbb61e402ea20d09804fc3a631aaa9594d89b1ac041b791bb3a5eee7255ae26e8fe0376aa39c80264c05f25f7063269ad50a751f928ec2a143458a5a6ea46bf221d2743246845d18ff508dcc7ae91aa780117a2fd5336740b0905a3b9ea4d26585d20508696323c25b886bb8cae023e0f9a1f87c0b26557ed26b44d42767d0a478a901ce911361e76aff509565ac2ee842e1224f753ae2a50fbf5ca48baf9f9b6b30a4a0acee5ba36117f892258ee39240dfb06d57aa4bb7f6ef69ffe550ab57c9378b20157ef491c2d127f0330c2ed66f575ec2bbafa76baa9cb5b2216ddd2392b379e72b038bdd9cd0291252fe608eef79a102384d130d12f09b1e98a4335c0c6aed22ec97c0b166dd6f6e0e2bb1404e0f550bda3683c7eeb5937f481023e0ddb823e9ed0b321d0a19b4336e3be6796f2b8844930c18eeacc0636f956b66a8d4260e8c66ce77dbf14a2e0fd1385440a92ea9c01d917796ce243a9e4c612714db642891a97ef25740be596faec304247ac053dfa1d74f9ffe6e38a7475b6ec20724c249244b011617d66658566993dcd1be29ad746e057272ce30c5537cb72be68097dc57269a0bd01927997dad8aba4c5a8daef6625d19c047952d1229fb153452023a1af1801ea4a90f86a5e5024a51c40165233571ee83f1d4dc2b5c230ef922931687f8d8ce8365a9e37de5913fec269b50967b3c24c44a30c716700939d95bd0c662cf251e9fa23a9cfa27837c4e27d0cb343569fc2eea5eda1693f10f2b021ad71b8795ec4be28b4d42238cb875acafe37d90ca8182d94c9a8d08787b187f5c7d65f02d50ba1f763cab2feb88f1f89e4785af66f309ac32c43967d1b5133377f81658a952df242da1f3c09018d125ef8898c093739e0090a08e85d849035b9404007803864949047afffb86cd81ee60b15aad7363cb324e4ab405527c8dd3e4252ac7edb78ade26dc1276bb8e475da934bad3b6a9f7137f917009bfa90012dd4c1f17a0d49a33002adb93f4faac1b4f7c97b3dd6667baae63a148adc285fc5ff14d117ebcf44de9cd88924420b8e38f0cc6d6915453235eedce6c094f4112f7926bff2b0236b09a386795ce14e0505db63debd3ea3d0a4809c2ce52658f0907810b0c9296b410562cbbd84973041ae3b3e0734d5c3a1b37c58be17f661e7050d351b4cc3cde32eadd0bca7a88b5fe571537b429602456bcfa4723c8b02b3d3c6cf73889abbe4cc982e979245efc97add47671c52ba9ffee8ee2d1c5c84245eb554847028e691f86797ea447edbc5e9253216dc8d9c722eb98d26175b6da2645dcc98121221608e5684f6019eca589c9336bcd13294686506098a479a0c4d7af2df42155df0c79b0c12922dae2e93f2b8a64698aa4a98abcb0717e25a04beef4180572150b933ba7cb0f9ca39ec59d2037059e4a861b1729e9501cc925143019b86ed16271f687f6ff132798c747eab172b054102b38fd6448911fe4c8977608b9ed7504507bccd845f5774ef415905da745a734a03085b6efd96e584f033439430b775c5c235192f2202980692130303d8669e9999c514e6eb827ed16c7cc9078afd509a35b850307008706a3599a2ccefdf472b849fac4d352f54160f6c3b41db6c2388b017677cdab6697e3ed873999b1c2086474b3eb22fb843fe36ef7215f7d3be4f58ab6d3f5258866de142407394c83e58fa472b8a6dbdc550aa73d96aa03e501ae8e63782ee89cc542db823cfaf2ea95dc55d05305dfc69187709913dc9f9b009ba9067fa6eaf21b75c8cb2591619d0d43cc78b184cd086583ace71f8b477e2ad7bada847048f2b50b24ea9d50ad3d4867350c6ae324d0c589667dc780558c7c54a6f575e95a9d8240216e0f2f3f0b7fd8911e89f6a16d3f16e3f83251a6d36087e06bc93583ddc962906a824f98adb880919314a0d7681f988b9b8ceff31d5c081fe5e8cec4d9dee5f80c9ffd4147cb75b0b6f85d98592820744f26a7b62313c99f36226c7dcef30ad45822cc6fcd9522203fdfbf63e3f3097b0ca454578cf6680de00d0dd84e78402e941c13fe1556c2615715223d09c3155eea6d0e0a78fa72d4028d6587d05cfa22b99d9ed14ef5fd6b8a10de50bc4f08321d4a17086da76a368bc2b05b3152a0dfcf6c4821adf73d00edcf21c758b2f6f1dc8ff739e30cd066a355091a339d550c72f48c83ffea03556e0babdd8f0504cfba375e920737971d469ef1b0c6a1bdc252cafdee7cf277305f776a4e6b38c664bfd9cceed27d98beb72a9069c4b1744e2823570da2f07ef8c6e46418fd409fc0f6f5a59320ece02b8b016707248db67ad24a5318312a551f3e18eddb316ac4b80c49e552290ae3e69994c354f4a5938493addfdb6af24681d072f42d43571663546577a4b9447474f586ef780e697668ffa9e6a2b2d5fcb3418f8b9323d31ab371a17aff970b3410933f4aabd35ac37425f530b2fccef95bf27d9576064210125a29a818ef1e924720c37e1a0db77f73fe63bd865f134d0728ae33e899c4ee7dfa5bd9f50f71313992ef231d4dcfb839204b2ca17f2c12f152d7e2a77966062a2b2240e27091803f1db1b51b0a4455b88ff7242744e2846903145a3bafa7a173b0d6e55bde59c78a410a3ed245a111c58689d541edc324266ed7ae9751979109efc02da55b74e131ead62d25a63d3770e3679eaa4d65a6ee43bda9d8c8e2d64a2dee9b26569091c566ef85d5d893f7f0f0e3f96fe856a11c6a6a6b51607585e06209da3ed2a8a46667a94ff6e1ec38ffa3b3f9c84fd1d29fa344673da0a21cafb546777f0b3badc4b884f2e3c8a4b46a9ffcaf3108a09fb368916f4a0e2df2e0b18916360fcba9b8bdaeeec9f45ca85d43ac4c82ec42c804d34d4970614c582b23148147fed7adc00318a6822a44fbf12dcbcf2d0eb282ad0fca4f62a580cb34eeef948f2e1bf278be97fb6999c1af7cdb541d4507443c91a5ba70b231bbed2d7c0979665f7466f48bd8ed9ee4b5ad397490b47d42b7cd2f6f344cb9e6a2a34d2791191597c2041f3dc21be413465240537ae7b6b9305fd9e27a52d15e38d24b8a8bbb9266393edf995daa7b4c1f86d9c6a0830930b9dd5496c43dd10a0625acca0b786bae9b3d5b851985c8f8e6cc4f90c4b07145ccef9fbda64d18b47904edbe7410f104513727d6c1e493a6b37eef84173dc95c1632abebe80e361e7a8d9e65db8591ccb4bbb24092c45535d80228144737cf48da959989dff0bfe09d9e8a66197989e25a629763d977cbb6273308bab93eefa887250340896fa091082f4b7d01495fe1ef8b9d7fbcd0ee09d9230e0159eed610715b88ed2b10bca5d2769a1bcd9919386b9b2cfff68d6ebd4ee828acc774db10a2e7c37b893345d431553cf77f285e1e04718d8a87b3b0e634abaa7363c8c2663f2b15d781e7efd5686570147da8917f59a488e0078a20c2c7d2c5992a2e158dc2be1359e9f97a7a858caf6119da5b2498198392f427b0c6e097dd9a0ab1ef22a92da046bdce7188a5f8e257915f61e44497bdd2dd0c2c1d4cc01e2116d398eb83c752cc891b8cb26db0e6ad069fb834d07c5635eaca728b1b86561e6c58769dd172b224617d40e07e27c2fdce87559484dcb470a1fa82945026048d33f3c0319f11e15c90e473ae2a54eea538bfe036d921f7156829c8fa5f1cdfd7dab3983c51324aac61086fe389301b944c9c4ab067c10b79a392105f36cb029030fa1b0bc3e8f49355ae852e680d145d45b2898c8e9d21faefd375d4214d77c9f565eb6b53c5c86f7301ee90c5ede32acaa4bee44c00839f9d932dcc6deb356fb8edda8ecdb0f0289b7de7a3a2a50cf6e9ff3ef8115e1cd74915f0fc17e01a61e60139f450560a8d8116e851bc9a6ce22a936ef2cde892ddf439e66e9860bb882e6aef02468f5e7dac9c4759db2ef159c5bd185ddfa5e3327ae13a93b2551ef507b1a620cf46e179973a5d7b8e2f133c02aae272762ee4a9d5672c97f33b7206d574821ff0e5995cf045fb36cc3fcc0b06d646e923f364818f8b32d0d8d77544323a74a245e28664fd4ecd348e20bba569ec4bfc1062cf456b53547a1fc05e8234ea13e6d80f4bc1708681b37cbb4a4d8891ffa3a98aa794671403120259fa69e1a05ae3a7ce393b5d5a23e5d143eacb1b2dc900839a281e4e7bdcb511fb8b6a55f3d00e2bdd11a79e031fe997fb39d8e816ecc14fa11c9a78061c3ff85fab31cad52818fd365b5bdc96fbfe94d181b94fc8ae82b5336612b13f35929d0ffc7b7be79ee8783a79c97529556afeb4d52a70bfc4966df099e0d78c7b8431de397d03ae86e33840c0de4d00785877ee652e78d1b50bd69ef68b4a536348e3ca538bfc0e7315032af89715ea9decc8b5b1c4bf1c8c34d45f783ec7cc162897cf3d7a6254447d0ba02cd5b76070d3f79401736fc0d085b11a3a8618e9c071dea52ba0b0ce27d48408d4f8a6cd6efd40fb608711a7efe3ae6d380ac6cf36eca6968474a5a937346d4df3cb565a91a8627ec742e1f328e97b9d9759fe1cf4d39571fc47c0a809f4878d447e05ab4cc9eee3e1f59a2ee694f19784b224e0c307a6b27792ae157f1f1508397e9b037b928c78454445001789e0230d0104aa3af300dd981f09f3a5ada2ab33f0de2b5e6cc4b37246e559ca023df4157cbf002722789835b1b2ecb09c7cad634909119cd9c72e8a68fa957bd569161d207f75e561dbb721cea4ccad897fd7973fe83807210c8e12ac22d243d5942143039c3fbed2e32502cd39ce7f57de104fa5022499e8005883952890cc5e597120479879c35a1862ceffeb37c8c14d7d9de4680e3b05b299c4d58eb714d0f527bf7d5d0468052b80cb55d67062db0bf4ec5b6d70583a8172eaf1b737f1b529e28e1ffed7b1bffdcac6e51bb14ac312b8f8d9b53b553fcec4719d974cd691a8ba1f2315a45af2dbe0e41d3c21095f90475acbcf2f495fc4cc4a36aac67f6b819aa144a376462f9e07f574d0301923e17b285c65865c3492e6cdbb0f2ccd2a1d800b864279726c8996258fbc84d71f058fbf317dbd924de80e17cc1f77a07a9f7ba0233faf79adeb30e4992824b5f3def5936f1b048a664160d2596b400b2561fb952a5b8aa664b229354c207ea54152c04d114081756fe9c2a02405efb6587a625a6833abd88c6eab45fb431f35664679cdf76419b1dd7a2f07da91805bcd96edcaf6219969a8abd1450f07d2897f2106c370249abd97df1703833e85973b5fff2ac7030d1a72778fd204fddfaef8ab56f4c5fec529ec8c28ce3a8320f9344a2924efa4979acc7c98aab81fd812603b526ecc6f7a240a067de87b267fec92cc38807637c55e0eb0189a9f6fd4b26e4cbe1b39172694ea7a90289891c44cd83967dea2dc6dce4de032ccbbf1cbd044c8b7cbcc75bdbef425267a9f0b9857da06d179d61de53032bc0a1e2741f9cbecb00887ab16a21fe1c9b05a86a82a7a736e998955ff612061e97e7bf8e10a2815115c330111c9b628a853ba0b1940e948fd3be25c676dada5583ee201985cf83cc8bddda4d72afffe0ada45043160a640ca443931eb3e9ea9aab951b5eee4e480022dadc694f7d62a868a288baf7200cd460a8a83de40a7a3952d5513038779db0ee0e2638535a7b1148afc47e20aedea912f2288987e2c4f855ca17bae1c0edabb6338b4198ba3545fd024a12257dbd653ddbe06bd1d6c2d57ce313f338827361c4f42c7d53fdfce33e03086d1a496107288fcf7467d4e68983a73d28b787fee214c22c0d2ebe069be8a1d21b0f9ab42196ed1e2a29977c2e9f39ea333a0458a393470dfea43adc42abc63e818907a851edcb6cc1f5672c1f265c49f032359ab17f3dc803f91bde12da8c590e1ca7967d53e70e721e063ec7b69689c62872445a7c425d9792e45a0a5d1899b86a2f62ff5aad0c154d523217b12289be7fd1797c1c8c6b43b7fe7e27eac059328754bfb0b83a8dd81dd2a5c6a5148d94864c4b98258752980bdd5c9e3f4f92c904d7be5c9368fcc759b063b2ce7772113f86008303155b513e1867da157df9fd5dd89aff763cb2a1432fa4f6f46b40e2e332ef958727e2dc75cf0200676d229f82cd4b99109a9f4b60f559a05d9e60d1dceb6a964768e2e842800fab61f15058fe1f9e9f9406184f8f7c1ba4967e636d2779211e68c0e9a9802ed7b12c03bd9661516d6f63c9017932270168822a2c47ea062f47fdd9fd30007c67a87fb9e975b141c4e798555e9a4dfc5b38ac898004614877473dd8f7b5738f492597269bc43ea3305cdbad0db9f6dde8e90ac33839329e72d168e0b314d93be4732a71bda127639bce9036cf8a89a36338ebe6d6b716774a4a94665d43cca735532c9595861fd5e36b77607ceb202afc2c9c99678456b558f5053f25ca69b4d2b5079ed02f3ff79834c3c92b682c0ddef7ae247c3471412eabe04e3f555913cb29d92cc29cf03569338ef6e5bfaca4df0113ca6a59dff11a05724650e2b844e408fd182cf28ce9b5f60f4f8c8a694287d426669e2201d806ba4db171fd46d7d529b44d948baff93fdefe9d54b7e96c9f9b9d44f9e315520aefe3e13cc3785e9feab8425af70957c4a61d70bfa9c9844068f21d6a161cc3ed330a48d4970999cf21334c047eae6ae0d764a1c88812670eecfbfe5935e96f45d4ca865ce19a0b59f31eab87c72ec9312c6db8151191912d15c30612549e5ab6d9436f30282fa92c91a7e1bc8f27f08e8c0c074d2e8221dc30409ceba6bfddd1b593a0d1970606c2b30e0c6d156ee9f198689aa417447aa3978acb2a7933d9abc3c9d8f7e44d2de75ecad3a35c9cb5be278328406502959565047d866872082cb5931fc169a23bfc1a1845b364c12084386cc3cdbd6d0a803fd7c8bdc98c8642afb6a2c86bef17a1bdc59a308d4a58da41963605cf3c4c5839b4e44c00389cbd82c3544d1f3cc67ba7c054c48133a285a35a11cf82c06875111bb33ec1bb61a81bf94b27c5b11b8d1198c88fed328eb086e4f438591bb961d0e41640374468df405ecc1213c23341735a0b195fe5e334c7bb1418fc5dd0804d71dae0cc2849a851e6f1b6ddd735e56f17a4518ad5b8e10935649e8b7ad9117eea57b1f9e473c08f4ab09c61862f8c05d142b20c362c023fdd501838a5e2b9d7f25a38f6943852b8c665db7579e03532b4cc71d0217c9bc588aedf9ad94d7906f2fae8814e3e20b2c22a62494d0d2d74926e403177dc905dab2a66914468bdb3491076c6b4266189b950ffb2f1c9da571780a437c752d512d3b03427d49b45c5972a7a1fa4780ea9f87cfa01be8d98699e97e4ca4875c7ac30fb676a5e5b52f53e97c5bae401fe1fd7405234694b18b2508e022bf93ba95739cb21791a3af90f4dbf6c9bc95aae3c3e64ce15220b4dc9d1539ab00bf73fa226a2a9aaf0f5853db50ad901c5a0a46e7f3dac40d27f5e29515b8f5b1ce5d9ae1f3f6a591a1df593d57fce5623d04df95e1527cfef6b2e509bc2141ca4a9720f49c88ea8c667f91ebb90c42d64247f3a87d1f9f8b97bf5d94d6595152e568becee90110f7e947363a89407b8b42f79dafc6ab0e387f94a1ea1209abedf09c6261516f6dcf373c4e42ee895dd9aa83c2f658ac10ae1a711f210f1f44c3353baf9ebe0b3736c7ec2a8497b80539e48bf4530277dc1def1d10b3ff232552cdbf213d7fe030f9da0b9d7cf98b95f7c804e66749bad7acb2e73e920a2451682d23e2d611c94024b26f6d6a75d6f2b3418b14a126dff2ec1516af8b5eb0702efc2287ee677450b985c79c46abc3547214a81ad7d6df9856ec66fdf30d47e9e90a66a89b303d19cacc2a518e3faaf11249dc6041b173b01ae13724aa530fdfb27204285032d722e8478caec9d3d666914b037b80f9f3a15bf2796324c7d46a55ac922430442f1bd7eb874c40895bd4e21dd7d5b69f3e95ad5f9b2368b3c8e0180adf20604ca8a13c3299092c032682b872cf2c55df34b0a50449ee940edb4aba5112f1148e1f7bf56c9c71e7dc27a421346c80fc0185e60fb73c6a0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
