<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"15018e884daf71f2b2de4b351ca41a1010651fd0b1b4006020312f14ca9e3780f58faa658172541ba73812831ce06f61c2d33962c7cabab66196a9c30fa03054a34e3ec60870db1758fd62fb0fc5a5de637334b8d53787e1b2bc0e6ce652933e55b10cc08008e232d3d258fd775f3590938fd251406d75574ade8dbaebeb938b4e42a312f572308723678951e0621d3d8e215a9cdce77791c60ebd40044d64a019e3b63dc154d0de2e9202771b2021e42124dbea04c9d24a1a6463dcdc9bb1af3a808e3d267bbee7a543ca6ffc2e2a1bf0dbf4951680dc07c91a8c820af788ee125d3017667ea403f37260c217bffed400650d3d871c4133894051e1acfdb54f9c05eb7891ae9613daad502520bbf5e4a755d90af572b01cd2cf20f2151189517a1e504d5f2c419dc6042b65cbc2374eb43240c249ec48fd732fd16aefc30e8b0b429a309f98831c75d7d31fea8c6ac7303246886218be9385929e7bc8e8a8e5535eb0f73fd4ba41081ec524e5287d1f0bbdb88b53a53e523cebdf14e33965c4d726e3d33cb7265df7e191f7f05492afd8c357737203d9659109c3bf19e18a131b43775340a72cdc48b30abece98e9737f128469602994bd98a28e9114aff283217978bc85e1985fb4517d0b903776e14f7d647dd182023247277c3f3c5e762b452099e7f29fe60be5b8486af7d17b72355e3b1079d65c50561cb05d012ab45d95ffd64e0ac86b12e99c2790ef84fcfd0906eab4e92a2c47f2ff849429334df3e8abc6b5b07a309d7f9b2eac6bf0d3cf8222181934156cbcbab3aa90808e79171dab61916245557b567a9cd44c8e8e41d7b85146dbfdf16e1e24193c0e4093886c9102203e7c4fc057986f2216b671bf2010b2ac5b143d0e67f9e37bdccf79657f88b62fd06d598827db4ab7702264960a5eaa51ff33a3b125121493e29fffeb2524ae48ab6156866e890bf3e13188e64da64b8f4bcfa9b41a228c873106bd0da84f73bb370662009ba38edcba4fb5ea518e8dcc6177cbaaa32be82270b4bc9fc0e54161fd8c89d7fbea92ea01bb3e344d92c3961e17d1781d74285a6bbc8b18a1f575cd4b6316a4a63cdef7c3c9dcb0b8be21db2d07edadf5726fc26b700308f007fbd92a052224b772164d54321295ae42b07b26d211e4660c5bea2ccef488ee6bed5016de9f6c030efec9d262270c3b392b11fd2528d399f9ec621f86fb6ffed94c050e8d531581d70892be1af783e22887bb001c4901a2c9e8ed58ed9e214f864ab82ddc59fa00643aa7bfc39bd823e55a52a30393b7fb049e0c18e0e39fdc80a93cf3e5dbb14f4faad4e01c8f6d93b224d6151e80201479530701ab86cd58fe8b17ca7f7f99a0a0a864fdb4a5b1b349daefc83618a6eb0f1a4e96d1ac7cadff0282037391861fa52408932f0158dfccdad85ccfeecb8ef50dc5cc92e00f1673068e90dc902e1d2bf53ed700ca8d84361f370d8e97b53feb9f3e76df1655b9805c690900aa81bb609945f29b53ecda68ac69d6d3bcf33555c5b0d7452d9aaca3c52eaf0fa0b55e251e2f63414074fedec3a4f72f4dbf613f2622d3a03fecca02c8c960532cac774036493919797fffc2face3c74fa4854aa02248b96f6bbd3aede46786fb2f7a7c4db490fe8acb4d32977fb54503126c04f1ff50fe176fbfb159e69221721d2a693eb575808c7309436ab8214736d67bc40c9c88e3fcb7ea1078ac31792896034e99858360f6e138bfc68c3b4917ed124285c441dcc1cc6e9e0676001b4a5a815d5b15233ea51a0dc1b46f193c2d78f3343a8297948eb41e44e7b4757192a5b996a614eb36848717800f133b8b45cbfbfcc5335974e0f805085331427c59baff2a6ee95a314fd8051371c1cd95fb3494d0e763a2ed328a40537c57da3a5d23f7169f5f6299fc3137d5aef698bcbfbe252c7feebdcdc194240d460dcea9acd4c5c4a28b22bc3852996cf535b10cafcb8b805f9690b700f4964ae488d55546b2de7a04d18a5de7c736895d14bc7ac19fcf3b16f9c482d44fb45b9cce2f43b584215098bc0ac440edb73366dc2ca16f1be32308a687ea9ecfb60d1670a79daee5167cd8e7bfb49f238e46906c61d2908c8dbc48e073eaa29cc63dd3651c077f2d7c1662fe022d18b9b105ac146eab11c4d690f70f79dc009204ffdd078362e23f692ee9ecaf272ec27716c76131340f5e4352b7e962f494146b0acc6c91dc17e07870454687b0dde5627a13fca1a694b2e63225df1a0e149fe8a0d9f730be35a93710071a24c088b46cf90579ed8a90b08552dff3e1510e99f706aef697714e530c951fbeedd83c78f45912ec24b5a618d2fcc9fd85ec9d4e80d970b76e626a96b9250c2ee6ea711314be8b55ba7c2bf02a1313f800736877008041f50e33aba9a7e9546f95179a969fa19580fdb6394fe31f63423b13aaf01b1c00c6c5915e8960cdbc00a7f7982193892f5569abf38ced04ef6f7d5f0301de8419d58815d2bbbe5149c7d37089eaaa9a9ef73b47437750dac912412ec84ec1f70b4015b406b637c0d3fc3c2a333c5ff19dda34465b0d72a2df277a3414b2cf0e8319e0602eb9b53559af8be06b9cb1d15f7733f26839ac0ee74e3301f883e3b17f1f8479afb84bd87eb5183e44e72a3efdf0e60d8e28dbfb0540cb79bb35c4fb32bece4fb9dbd4d5e3828d02d70f2a1e733602a4246888773866da029a993f5e693952638c010be10e21e1a4a127c8d83bc460c07b8d55bb91600aff6b1850707b263de7e774e67e986dc495ad927ba3af0f4020e7750519cae8c339d907b4f2bc09fc4b132fa3e8b7e45cbc0a4f9040ea1b7059c988202297729d5b9a0d43c719dfbc8ee2adde405217a7c6f9376545b4a4b96acf441739797f573d0239404434bbc4145912c23733cce2e9b817b37cea6bb0b212b6f80f4e9049b7ebc845b0f47f42b43ddc587e95c4694457efc7a76d10365ff3f99d59c227582a9f7ecd2565e8b52d61fcecb7e2287c905de30f6ae5b8bc8e952597257ddc275afa4a187e2a1970df7bb80876ede8ca77b55315661cde9b885e5555aa6de8f065dee931c259b208f752af4b851a5a66b736115b8c7f6d1268dca242a2bcbde39886daccbcd0180fe34e2635cdae6b3576218c525e4a14bc79067e1997ca4dd7b709c782e4517202608163b514d35d10ac796813cad41477e8c8018b630d0aa6e27745c416bf0cebf4a0c1419b5ab5bc6780d866b5ebfda62805faa8f0cd515ca8e948c88487c19897e8d2de195d53effde6424ca4c59db7c013247a7ef3772ce505f242958407fc966ecfc2c706ba8009a8bd4f989ce150da046a971c5d01577c077b1ab79f4e0436876811f1e561a0354d48c800298fa8c720c48f90165e61365ef95bcea9f47e9ed89c270f08039cec0a965e8bcbb17b0fb7599b91e260974ddd5eb1e866e064231f489da940c6fce18552e7783cfff6cdf1f10e8998509da33de20e7170e74a72281e4d5e47584f068046114b5124c58bcd903806f5f6f42ec8493c530db0440a871ad6f99544f023be962b5511b9431641e3ac41c57a029828951d62da5de24c080240be8d0ecbfaec178f832aafcf7ee48da974302507a8a0581e40b1210c84ba94456180065270398f6c4ac8f1bf65490b5c6eb55b41d640a5826adcc1c0026bc4532c2da6e178cd2782fb90f7cd078172a3a9f46575d2b0ced599bf97969b61172e8b6f1814c44a6c07239134857a0463b6d3fe66f02110f872674284e1e9e9d321c62f99c830d4a27fce5c7d1fe1c625041161fbaebb22dcea3ddbf7ac10173028935c712674ddf63af65d71bf6f96d1f3bfda797d2f6496b789e21af85abee85c1ad415501a85744512624055534f40b6019c4aabc84d99338c6e896df09b1b23ac48e6530d088994ac528fca9e5e346426ed86d48641e9367df1cf2a23fa9fd4056f6cdb7b34a9d488747851249d90038de770dfabcff6d3f20d8992be4443194f53e5b62017bb8df11869ab8549e3939ee0039c45484a80f766e42d1b1d1a216ccd708a134dff5e2c69deae0b8839cde9f0ddecda35a4d63bfb109c1d62e207be9645859f6a989b0bf58d398a6a422966e503133e18214ea6488dc6b762551259175d4bd0169de6e2adee5972cedc96bbde2a47b497ab8ee80952d3c80a317a84ba2de12ac1edf6b8fc22726e0437319c51b91e4fa82200ae84a9305e80a3ee520e750d8963c587c04df69239e9c5c7a2d13db0d12035d8effbb4eb2c00f0e1e1beb17ff822dba8afee884e01889c3c977cfc962f05a9b3424069002f948eaa840ca50d9c1955f89ad269d9fdd77b0f3751351558f0bf7f62786cf045027d4ecc27f5e0ebe7e87c84cfeb5e66a0c94fcef7fc19ec263005db3563a6d73cf6842e7581131022f02a66194aecf97c87feff06b614f6d697e0377ed0ee48a25480dea6ec2b8e193642a0ff24b3f5aba7054c53e871ef74bda8dcb373289e4b243b48cd07f4af6f3c5c87dce267b26dd37ae00d84f498085963a7cab035bd16ecd777082261819d8e2fe35bff28d35e58b8bc6ba597606eb359e46259b3b3504d504288c323cb1a1fc72d45efefff74328b3bb4a764bcd4b01e178c8ccc5eda021e538c11929a746a4dc91c9a1c6d79eb668afac5c5a8f330991b93eee2c02afae1768e7ca5cc180c30c70423bc8395a2cface9a639ba57e1c5a9d9bb2fc13f9d1ceb804e9b073fcda268d3e4c28f4ac6c54cf13f87f932f5da51a37ee6c258245d0c5750bae0f8f13433cd8d3e25dad32b288e18b5ddec875d8d2a4d26ddd5ce869220e58153a210efb4083bc8bcf25c4c1e0a4c12d31d1bd1a8da936b4f7e58eb79e645328d27ffd719a2b00d82619f16a494d1c4596a7402c52370302c8b0b5b8eb8dd577c5875f99f032c7e20195212cb6e3a3e6aecd3dcc0e4449cfabd12c44766d7ef70c40bcbeb75c76f6d741f5bba149d136d9625dd84f3c3884e521951ce40f4a50fcbd1ab15bd20d1765ed9ff57484e69fc6307a012c290caeec84a61b605e1cef022382fd94849974a4926423d05dcfdb6f9f6351e0676df2341dbb5b459bc997acaff4f7e6a1256b39afbcf1c1601da6718e910c63799b6e19b7dd94cad22e6bf328a5547bd34d2db0bda779b69ceaa7cf607868ae90a524d38fdeba3a964971dd39b3b53b405750263d298adcdea6d4d01d76b34cc6b4b1d353737484cd6213b060d651f551f9fb5f62219abe60cec13e89510045200919e7e74540bc6b37da53422f74e6421a59824a58671561f6249e10bd4d44573614a5eca4820b51103d896203c23d44fcbc826975450fe4d8a070ca91ff8610667ef69b7f75d1645c40caae5cecfd7f1ee8c07630b4f6f85760dcf5ffa4d691e2be8e0833ce873b3a7b545d5ce307881a7fdc7770c7ec1dbfe5d2df215b179ae57d6c124dc8422bd9261621f82da1b14c73cd344a6ed5f69147f0759ea505b6e651ecade14c25b3216a820e80501a3acc92c2b9cfeec0afa9ccfad0848aca1d5e7458d0a1b2062d1392652a0d8da476924c5cf0d62839a6adad8a1ee17c0d5f9259d87798c0956b05a59fcb40e0bf1ef2059e9928f23cb67fa4b47dbd6758ead7babb3dc201abbe86617b83d9b666bdd123c3f565319a6dbd06add25caf21a97a5e823293406fe0336cacff22f4b470eca367a4f7b1003f882c3d4eeeb02e46d50fc47ff482e6b2437c538159372fff2bf7f13d95ffa3fd67488152e69e6c04805f5a99cda39c2a00b346620f486daff4a3df523d4319955e1428dedc1647aa221fec5379f28aec04c7e510a442226f42aaa69796c59e3dd5bced3723d9114cef11e17547585c361887a499f01811218559607c3829d1c65c96665af7f99503d1c1a1d876661283b4ae63506084ef68052eddb83281960b3ebe5f6fee1b8f788d9d4d5e925b7d49180b8259f80a0eeeafa7e9fa7c7bb6f3c26fe9767b062234df188dc584f30423ea86bbd263b06b8ee6441272a7d5fd0b3a43434534cc56c2896c570b9c85d7b8f5f16b4e2310021cef553620d5e79a1ffa027b9e14419dc2f7428dcca1ee68bae2a77e3513884dbab3e8ff2f5b140c20755f01e6d8726564ce7745cee6754c714126c34c38258259928776086c47637241c33d1e629567267f30a509ab706bb18a24c1cf4a85bf4efe0484569a9589cfec67a54053fa0c3613d7a8cab3f03686cd00e51e56e69da7139bb410ed83200885b2bb8f0851b07be27eb622b62b7e29d84887ce4ef2e404ff6a45f6b7768b1a41ade3b1d23816b4b59cc14beee6e77ee8f2a94725d3c6c40ac9e515f9d139161da350810e752b55a2904cf56004a0a7ef78ca93693408d049132a953fbc3f58dd98b54b33620c051828e3130201b500446676194310e946a36dc934f0c04647022905649a1f8c1f06ff234b500fc085cae472fda03315b1d74a8c58777a0fff41381dc49afacaa5f1126431305980cb624142490033b47c307ac7c52bfdd5a86ab40fb5564334c6847602f10433e201a124d9e70cda40370f0e215aec1b905c747414df897db5794931b07e0af73f2e57f091689194e6a0defa1b76d81fb0693c24d4c14900511b75f43aad2c327adbbb9d9cca9640e10126ee9e87ab6b69df61f0ef108653d740f68cf6e637640103bff0439258e6213492ef221d53222c5259bc454b9646969803405687620909902e81b9e600d67e84ccdcb268caef7683a53e8c6db9d389339a6542313d8776ba92024bd6ccf567d3c384d3631da378a292f89859a6dfd272de28ab4e89eab0917b489671472686ec4392552f2cb9c644bbf7ef5ce710336da89eb39555b5dd5d868caa9fe1169cebd76afa0cb00d0de216a3053958220b440ad3512b94cb7f474a7ef6f386c31eef017975e3a98ae3e52ee51de47f336ddc1ba2ce015e46cb535821d127fd59314e2e3b7db9d71ba1f8c0f3f751e1a5a2913b379cef7226bc4eb04996ce4f6e26d5370747245590f49c40dbc7b56042d86f9a365dd56cbb88b7fdaaf6bc08815530e62ac85ceaea147e6061ea793765f291711f25867cfa59d9aca6c8926256b9a1a7b22d907381feaec0ec9e44bc5dc58f478fef85dcf37d21111fbbc0edd6af430e0770a1aae457affb9ded41d1185cbae6bce6b86492488cd533ccf4d18c0d9ea76d4f9be01ee13e2b9a92499fb421a3faddd23472a3335557ab4f5067a69d2d5fc07f3dfa9da8443f781ff0a3a03b5d968170f33d302091a0cfabb999c9b75963b68ca93292710a3769de5e4cf892cc0d0a04de565a99a0ee326f670006bfd9fbd8daf5803ae0e2f504270c0d1877abb04db97e42bd5cadfd3c8145c5952a5652f7770c427c3d46bf28f4f838e4830781422e61187dbd5fbbfaf4e41c0462a87a8636a7bdc034d35ad08c0cf9b8b59c82257709455f8f454abdc5621ae0c7660ef54aeb809f9d18401cc1075d94170b39f3089cc15cbc2ca10c15488c52182ccb7ee305fd7761338d36d2bd0e2cdb3d1b1e3c9dff7a1ba358f3938ac7093e24b9b21aa9994a11b75035f96c4c1c2e8a44ca3e6302222ed0643c77e4f995819b2f22ae84f1106ad81489b70246b2054feb87699cd3796639e450b2cb35d40f442918e4685065bfb13f5a87aa79de535398b05888c6a121635ed28e1821254d741ed8c829ef7956343770e5a40f012263929d65f3476f4b9f81f00809fd76b1fe029e83d2e8081f380eaf657dc1269ffef2d80e32d19c1b355e304f90872736b61872bbbafd23beac56f72e9031dec962d0bd38d763f4cbb6907109908d13b98b452f5ab83aa045cbf5157d425730eec4b47eeb35185444c47e89dca8705668c1c6da0dd49eaa11737fde22fea2b94ffcbe9d8a86547e5a605d805f0f607ab7bb8e7663f2d143b61be194a275f01349c2641203a6226fd3d614d8209ab8c3c82737b92a5cfba567b3c4bd9ff538a510856c8f33d37e17832ee560a32c3436e78a102605735975fb11346b18d6b8cbeef25c038acb14c2b39454498d540580c37c654a314b4eab020bd26f43d3de77a444ffb2b579785ce2ecf5134c0f8cab50a43590347d547a900af993c73747094133df83445b5261c2b2aeaaf1b70360f0143b63c6bfae2e6b817480a8ecfcca28e2b734a9dea07b908e7361042ca64505cd09192d218b32beab15aae909e35e71a22160e425d2ab23dbc48d5588e4166ec8ca8860a01633e54b75f50f7f466c815152298c4727575488c29ed2e40221c38756bfd6ce34638661cb391fef48b93bca21c06a18650bf67c0c5d5447da7fee99c6bf082416ae50208956601e535ce9d86b88aa7bab65d29f0f5272178b4becbd52cdf7fe07d34fc4113d9de02fedf832bb4104117294e651f3bc0cc296fc317d6acf00e82da6b3302519a3e5b68551df66e8e53a5311655e733ece15dc18d7492d12240ab6a59bfddc57e645e517fd4958c91474508a9887a17b3a8afe5dfb43da218a165124dff2675c0c8343b5736ea4d4bc0361793f2685778b827abbbe8f85fc8d52af44e51852fbd9d3ff23f751827ecc3768a5188c8ba36257e1b259383cac2dbabf1e0f106d9f3f5bd91bbdad4cc45ba9a4f055b1ae7c355d8a8385959259c5886584bd6c0c65cbfcff4595ce7c76ef4e10356b6082540345f1d24e84fe99ee55dc18d94f61134a5500e3f9504e177f3560cf3effe2d6d7f8d90e54c64bd33788a66c4499cb30f1e77dde542e3188bb34aa31ff8216c50679952d9950b304de5e85bf607dae38efbbf0bec1451f21e1db72e9fe8ce7c5f5380aaa39a66dd80f24877b059ef38e896c099623bcd983489a518e3612d8a8f6b3fac4cdbce715abf36d8a7852e49e8b2507352f69dee796fcad6f83cd9bca2f0f44708de605f1956585c6d13b661d75a84ade0e5c39ccfd07c31c8c6d6c98c97e24ed9949143567b525218ca277a6925d23a568b7a4d6de0030adfab6c446bce1bd5128f6527af30c8da9e034b51782aace008de21c78dcdcbe34e23c276123c05bb1a297c05cae49d5c21ae74049ff98be0140ebe754337010ac5b8ffa477209a7a1cc917578a12f553dce952c02c94860a777c64a2e2818f11958eadb7151f00a315b44f24c33649e2357b1ded8f1143c1f4eaf4edd32f5d8253419173e378660feb0401b40b1aded135aa36d80bea904aa4434581fa2dfabc4b1aeb576e74e89c41574f8b764cca5b10ddbde079a39ddbcbbf69099130b84ee3668be7831a68c176c53b069af2c961aa8552ec9148a0e7026be4b9537a460db138597dfd88c53f07cff74c0b4a834344e60d52b6677e7c9cfaa02257fba680ce01529c6349b228139f3ea4a711f8a050cc02c0e571e74b8b3d42188851479aac40e15b09e3d1a1455a5551751545d89ad369fa0bbc34ad84b35b3cccbfd8a60fbe135d775553342a30cd85cd93aef950b27a81e185f9d0e62bb4dcf2eaade1bda228aca8d21d5cc64ff24b9a6548a1edeb4e377c70290ebcfd0e7320346ec29603c26fa7dfba2cd7ab47400db542c21103a0ef8349165c0c2e1924d6fa93e81817d682216c2c7371c5bf62a87c4fad01e4b97eb827a010af8e95db07376b6cc363c75a61b705eb26d4400c4efd025a7e327fe8222267a1fcb2c8bba40f3cca45384329b3aad49da7e7bde1b4ac2d48a070823a63c47885b7cc3543d3d4747d1040d5eba489f3e4dafed997e71fc47ae958ecabbb2324d9e9615af6c7b3fd0b491a76865220c8fdacfe528a2113db09ef2153b194738d440cb216f0da750b9f777b69accec33d3462176ff92a8bc95f680e9f55ce7d4d10b9dabada359c357555423a14e0c63db77be91c5521e9bdd5361e539c71e4ba6d04db44253de9b6f271fbcc91a51a8abd16391dbf8ede6c029d22ca3bca86766a92c1d892bfad5140d50cb3329898a47062c9f25b829eb65440cd7d762b9f9bb41f032d6826fa7993a9a0fcf3e7b0770aec41c8df911b74a23aa46ccda108ba090d4c97b55d4aff380a9f417efc427a3dae0cc9457bb526ed906f7185801472a30836a2691ba1d5d23d78f013c017177f8a33aa1bd20ba16cc46d3f43c47cf0dec96cef73c5fc30c1f2e2e36dd2033a005c388e121ccba2626f12e75fecf086960f3fe7c044d25828dc9d5ad061cd03afa53205d700112ba8382f8ca6e749347049ee8e2ceb39d5e0df061a663b5b65486592af4e0e25476c71130223bed65508d8176979fa41cc1fd21cc5a4d7c33b8c7695411fdb26e269f33773ae080b14c1995444d667c64f776394c4563caf8a384f9bea43b1fa8d937c09eee5ba5bf293c7e45f870d3b9b02fb2e40a00697d915870a96258d694faa49142e52d0e33b0518ff255c6117d1cb6d70d65c25b9c59864277733558b6932c42a985c2b12ad9ab7ae32b17c0d3101e3e3a3eef95b3c418418c186390c80208bd0a48297629563d1dd96081f9ad5c487e9d9cc78140038387034177d09bb9bfeeaf59000fe98fa24254506d7ad9a30091a9c1a14f731154e51321a754ecd0b23616396616ae58a8cd6377f97acbc9647e21d21171522e54dfcdc014822fb17cbae8926db5aec21f150537e3264b0b056d7c4cff7e6f1ddf34db1805b700ba96375bd3556f8ae9808cf93096a355954fd30a369560bb98f67cd647af9c09653e69c9166f0e2129609bad0b6f9a4d0aed200e502d74a205feeecdec0ca89567ef0df425f70970bee1cdc1c8ac63ac833aaec20c48fa816ea0d058bc10eec8358a121f3ed83b5ca6270cca584ccf16d5773d5b435e0b90c419047c329922747bbadd83c2247cca38d5c50c1a456c0ab33c8bc6dd1af2e16c2e3c74318426b66890634af7afa979153ed6dbfc0aa5b0b1ff85ca40f4f0e5ee9803b9a1f8a85d7d575be160e41bf473e428ac484bd7af7b23e84d350b394cc22b5c7b69b3b7ccfd34e8f0e38b675f6590b65161dd363fc159efc0f4e271c8aefe955627fb2a4f1274861fc47e68dd9bfadd30988f9b58f3890aaa19f5448e9ec3caa0f10b3bc82921ba23c0dacf118b00f686b26f98fa2dd84e8f35d5899e061a00fda6083025e7210bbc03ba6e2ae350e0925031410271f2d8dee4f100e07d5be1e51c06bda4dc12cd83516998ba9ae0dfa91858a36a62c11139635e1bdbcb25d4b61080384e95b166050cde52ca4f6061b0395a5b4445f851ff3b01bd3f56778d612cf35b57d999e10190d7ff43bae849c394a022d594a8871d1a7ef1f7be289ea44c0ced38441a15519d1519eef9b92fc80715a5c0c1e6b9f0919a35fe409c234f98103e640c1b5bfffbade986fd860471a40dde212b685c02bfbb611dc149754d119c224a3c58aae88b6fc1da8adddab00328f9fbfe38badcad09002787552ed47ebfa858150de4e59b4c9b51075c46b7ba9b9f190233f9f017166f193d22621a16ea4cb5d9b7fbc93ceb7677f1487e030662ee7c84da602914fe7b4b0f1db75dd89d4408efb9f14851b8c8b37023daaa4ba95d123a3418a75160f701c85bafb6984d855c96e5f99a73103255fe36a753762cbab44df1bf252b5e0281e6bdb3989a6a4e3ebbf0b8bf1723beca3e9c89ad007a9c83376009d6771a2afa0d46022660932fa049bf3b9740fd40038bac2df3b3ef4ca6525df47fa7727f8b63877b9f4247b42d95ad2395dfc6eca939e5a20cd63e07d2b3c38e52dfcb860a8881fc78e99679055b0905b78ea82e1a8cf42076552ca59a34960aa90c6cf043466f927329fcf662eca660c94793f6db03d1f39610e95f56726f52ad24102b0a2918f9cd518858827aa288ad4d20bb60f47f538ebcad0312a6f66f3b3e22a003f12162242000708f06d8e2ade0e0c44ce4c0c85f19aa1b0cfbe874c6f8e3569c867a7c9c352961b263a03217afea001055968be038ce2ffb691c2be4b0452ac5778a18b44346bdc4bc40893735846bda268d02eaaded2ff411b5496d0dcde464cbf45e88d15de9afca313ac8c0efdce14dc7720f8350d51db7f51da09a4d983346a3b338111fe458810bac237d41f645c62eb47860ad602fdddfaac1d114c8ed1e99af8aed1f37100526f3998ddb35c55af5f4aedfdd9e77860d4e48cc508d505603a8fb48fb9a534439cbf3ae6c6e80c7923dde0801345ec5ff48cb0d2426b2b5bba5cdc0826d37ef6f4bedf1de4cf1e5e40071a8c0a5aa9f076463ec32d1e2db136f5f2cf49a31210fb08c9521c56f178ab141b1ba88ae5ed2ce6be54e651b2159c5fb46dedf131fba4c42930f5bf8a3eb8e2f4bff4ff638104286c7dab8af52be1c8d756bc33aebeb1aecf2128f9dbb1c07fe2d2b01f17408764fa7cc1971f57c144155ff60052461468629c16319aa654b488f0fd146dca6610241d5acdf965e3328e27abfedbee0159ea164143a9f05a6da0c8304ae1ed105f790224679fd88bb06940b29272d436295d5a3cf7f6ee3756b6540154f248b8284aa1a43b663cf0ebe8146b3996f7dbc372591dcc6e4ca5818dcdf5c2ebe50ffa782919ff4ba086813e6320fc2678aace5ae25c84db4dd4fc9db4ca92f706911aa13b9bb31e9040e6e008fb06e59a679a8f72368c039184bca50dd12ed55b0d829e4a8a0aad89d009dcd14d17aebb8557fb725b2b070d446f81605271b05dc6635db355d660d3c3e42f88847e94d0096634f4a2a77a30ab8fc29671101cf61c5fa95e8478e6c6e0ced48b862fb8f2104915a85203ce7ecbf14bd7ee25416d4345e091fa8caedd86b842d9228b2b8bb2337847ecda9378f65664a247770357dae8abe436208b0afa97207c654a2519078465ea5bfd0d2e44bb5729dcbc101610f5621e819fe5a14fb215db00f62e7daeb64d94b558b61a62213d5268098b69f6b574d935d16d0dc15701acbd14a7dc16db2db969e14074e84bc753848753780f290da3b391c4c7c4ba22393450e77aac1e76333ac14a31f2ac8300bf9e1bdd4cbb068db5380c53e0c4f93d40edf5a8079d908686826d33f30bcf09639c3663e80d34186f3c29665fcfcbd667015fd5629698f6bd08f1b2babf664dc1cc0b5385a4c94fc47edba16eb3245db2e024776fbbf22ac6efb116c24ae02afcf69af753f743c8d31ae77a65c0ab359f9ca121750491ba0803c908743bf78a83bf663d48f7f6cc5d55891425346935037d4b4fede0161c15cc071cefba3237f1e6599b8b4009ade4e5f17d78656b5dc735b8a37506c31fa8d41d65f3f213186017a83af53428cca22a39e31df29a69f598f11866797482f7446f823956f06f0aa5276d59abff337cc57c11622afee572469926833995c29e546b4120789263aaeff4b1e55ba62e4145d1b762f042d8f73810874c93850504928dee90241b0f943f008e41e7c2616d933a92295f37beca19000c1176c41951a83f59a76ee7a4a731b25a8691b9bd3305dd62ad91d48a7090f00142653b8f52fcadc99c6da1e7e593f967a461907edd77edf503855f780e1a45c14b6c50ac9ff43b6c23d923409397933327a8fdf28b34007d8432f7c372f9e740b66584f3704f412d59df8d9dc18cb4906afa2c869d77f9b9cc0dc38f0b892cdd218e9e09487cfcadcf7ddf6aa3b9334f7a90e0f9a07ba3104340aeac26332d98f154caf7f122ca412b9890ef87b0e459f951cf03dab3aa0502721aae0222ba6435f63cbba70d8e85fd9628ccfa25f7bcad2c4eceeea455afa7357efc073891fc293c38a9fe650ea095457596fd04f7a9735fcbde8e19cb287928e734826d89fa8bdb303513b586f15c71cf5b2be8d5ee435b3b08d2ae076bf4de854f8a8dcb7c2fa3bc6e6d8a45d105730d5a0310d45e05bff58f92d2be28098ef2ca147fb87f5a87f218d9dd9fbd8b2d095066521ab2cfecfd50d3963b7ec99a64b4b8a440ea40a715bdcd103536510679ec3f4600bd0578a7a69cff090c342543c2e8ab829a51fcd3f6d6987fc368f874f2c24ff9e09bbc6ae5c014bda","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
