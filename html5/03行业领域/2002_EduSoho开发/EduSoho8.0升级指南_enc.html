<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e76f747b3f3949e6b162159792ec8fa2b2a073c14c048937cc250ed7c402ffe38a920ee180f92ce894bb158a79104b61e2ef8991267bdfffb0cb5f168df8c865019a87be5dd60248f1cd6212346ab3b1b847818548e699880ee01bbaeae6f13e99deca20ff2ab4c34bd6665fcb9ceb893982fe9a20428ff9b7fb5e6e679d0a548980a65f818bad12ee8b46a5bf460954e75756b4a7bf050c755acbe6752244e33971d48c4a3669b372fc484732b7b4347ce6203ee6a0bcfe3103f5f34cd611f620e9294e8d76cc46e02242a37e9735ecf91aa41e32d4d2059e01860fc3a749259da87e0c8c10aca38f4539682c2ca7b4d44851d45194d8ddf75f3d058d9e8dfd2a7c94779a92a8d30ab4b0b28e04b60a0c28f151b949652d9283e9ea92f40b361337ac3fe847e84a4a7ab17fd26b7e2c65caa8766893ae8ecce9f635518b037cf8dd287eb750803246bca70b3c1a61cf98611aa2c0a4a4dec0a566997d6d18d65fab922633ce43d98ff55d267ac11268151d5d59f7b26efdb2d9d1010e9d8409d8870462047e12795ce31fddcda9736eed7face026f9fa1d3417bf927141c85feaae844659a9704df55e1a80a2f5368a7c1b377835ddfe09ae4f93b8b52c57d42c99a010761ba39d779fb1f5af52fa7590d54333f388354116c1d4e1df1860234b4faafcbd2243464d80e19b742771b2b1a611c6479bb53c18a60470d187eec522cb74e1fd931738aebf863b3ae8363dc556f2da44459706037ad242da15ef398d6b6dcc70fd2cb12724d118892cdbf06a5dd06a297289d361022c8633e58d8c15ef0ee6a034310262d0813893313b4710993405d7cc181767262181e374eff42f79e8fc65319904cea77568cb58569ea5327871617860f11da9e2a85d1e4663741b6ccb2fc5152ed7d3f81068fef30652b1a4546ae8a9ccd4c8a30be64d43aead160f3139664e5b84fcc465174ab816294094efaaf3235312c2ad56db52894e392b54e787f2e87c99815b0f1d027b30d37425ce99cf488fb6bef66f06ee94aadcc254ab94bbb93901fab7b562ee5e00849df04e78eb3446c1a7549f0ff05f365a14501a0fa2a6a062f4a447c4131c65f81b89ed0c818910bde465e449aa218e2d817dad54f04c95fc6e161f6068a2db9cde7eacd258fa81947bf90139f269013256a2361dedf36ee641735f835a79edd76ed3bbfe3be5da12ae70dad6e2a0905e59a5b65758c42fcb22e9b62b7a899d204902f0517064012980c6ad2b35520a22e050f62aa67c5d9d4c3486029816d8cf3fd6db2f46c4d21b3f95b1bcc72ce5e7de1fb39c6d6de5ffe00ebc3ab6db8f0d525472ad167f9218f593a39f7e93787ffaaed3ef92cbd264879dd9edaf881c6316d816fead4e8b887ee01f1ada855912cd2b2fdd98bdbe74defa537d74a8b6a362caad93d3763b1f9f83dce42864022502361b1c14009ac956ee41a5230e46fbc177ce80775d6398ac14e2e2724f14e5d6e62a31c5b18d58f8d2ca6148a01e9745b124255121ab0519af5be1f9cbac697cbaec4ea7627fa2f9dd7f40c108d2bf5ae5e4ecea4fda890e733af3e9e99e818950b847f4e292308e47b351e2f917bbcfd846d51401afdd96cd8f474ad3b225501eaf9675dd6af13edeb4ecfcd47675aff4014d848feea429dce0f2b6e05a520f100e9e694fb05012757a36096bb1e594d191b32a938e9aa8dad1f505e6fef37e52647227ce1fb0612db372db4a37f793250a439314ed330ab97d6a9615e6c3a08ec910eb7383f3ebff499557d7d9668cf3af3ba2e68162112b114434aa8eeb7d78991bab44cafc209968206be4b5d08500f4077a897f9d3ecd51087634183a1ec3f8513cdb8e41251685c7477fc526f0d46a1b4f0eb781daeb4eb3cc24b99cc336fe52584beff327470bdbe1b8886780fbfef29925894988af4efceeb8ba5f130b83da22589b6f8b56ff9c18fd64701d06101c90cc027cb31a1890185294a033111f33b4e00cc98e623867b9cc068541c1b354fc0986e81375cb06cc92bc65d3981156823a2c059c6e75d7c725d7ebc6fd18d4818b4f853fdf11719d69d5022a1f7cbc2f8aff04f18860f879f8f09f755034caa57cef492e5c5020f443498567e9e90f208c3eb5c727fd90c483b1727e80ea95e0526f612b704fd028500047895812dacf1e44ad51b64fc5546025012a898e938108a8409c53e4fe7bbb57bce491bacbf49c70d03199fa8ee535071e0d298484f51faa358a4d4eb0ff2c992805a9389ad2acac85cced2834f85ad2a48802d51de1638dc8dcde31c6df74961bb143c1a0940bcd234fedbcc5ff7f1288e90d0236fb8a2d0be956d36c335eac79456ef6bb823ba70cc30aed84bcae4224e140f221582a063d2b1316cf12a2d5fad1a800091eee464fa75477295dc9a2d2c4dfa96dfc5fa1cc7945fe2cf0cbb1cbe2a07c5bddf4d0014693af38d18c300e55a5e211273ba2c991fc3841ececcfc08e040121ded3d24801312c92e1a6f8722d52882fd56de93b5a65d4495357f066ac3ca3f9bc1a7f9911cdf2724b73763d413f9680e58b10af1a3a1bb9c4dfd51c2f1beaa03dade5645225e6794c1436f48317113ca3ea1e0ba281daa75835f1b03531c36e3dfc413b7ba74056e6d77a0b568db640b0db129deb65b7de807529aa481a346b13332d340136855a5964b974a1d84741b79de046540cea4a931474a5049a7801b438b74612da7300bb45c135a98f4962b105adf7c6fa063a6496f92e6aaa10f178533753f8fa6ffc46fc6742850bd959e4711374cc963efe04a3e69f29a32284db87aba5df83fb69ee999473edcac0085e14d98bb3141032717fa8da79bb106ddfe71a5bdf33d5a41f13b5e19dc54b0880534768959b535aa2b1a0a8d784fd51ea08750dc600ce500674587d27a68d5f0c12dd89ad148401a85af3b17c50637dd9755b31b6b69aa763f2af36182dd4c68ee8768ae8f6aed5eeff938504b43d2760ec760d791464dd6f92baf16c1a80eefc55e4b8783af776bbe4b22b6253cd87bb256c3359aaa40a7d9a6d3ee020cb3fad17d6171ed5cbae1c6c37bc56a04777638654044f271d185e94004f338115f20533ee32a08f02a11bd5be95e91a02e0c4d62d6dcf2237d8b5e626a933b894c54f861b5474db7ccff97fe91d818ac615d2a9d3a5a70fb504627b9c057afb4030b8c3b0f33bdb670e894cdeec142e396ef659d5bf411e07565eb7e844134c935e41e3385a183cb741741d9cc57e9f10bfa0e0bcfee091c870bd39a7e0c60497e5f51abee576ce018fbe8666a1dc5b9a538860445d6f95aed15aac04b5e3b35016b3902b6d20219c01c2bd469ff72e68158beb22b13bbdaceee5fc877589854ecaa98f79708b9d50d74534b2f65cebea806bd8bc6b8042653d585e169058df1858c23d2f06c55c27aab4261cc20830d623c478f93179f78a9a4a68fe9c3743169ed8ee692d08f70a17823c8443a4cab4534389195ac9d72e7a472c9b8671cbdcb2829654bf0676133b5b98412357321e3cfe3fb29d7c9ae210f8e9c7dd333658c16160f427c58fde3d7d96858c4e3541586aca5d0c800780a6b3a651bd7f6ea71bac831c7353b0f2b2c8be750e030f6a74906b1b55c19d0ffe2fdbe8d4374dcab052abdbd01d0fd5286e6c117f731904151ba40e9f175290e4f0a42acfe178604039e18845a2ddcea433d8458ca97797cd6cd02c88124e3886a559fefa7d73a0ee3752d588fd8048dbbbf88fd471ae91cd9c3ccd3ada0ff9b2d3c1be49576d78c8b77ba769336220b951500cc8abad5eb3be81e090a79dd9ac2e5f031f554aaeb7e4bbdb76251573e202f63b9351a31603575ad0fa946d8e3d885c9d89a6d70477dbd273fb9912c3909a049387ebec666afb3153442b33e1e2327aeffdb12f977002e76e1b2772a8bbc5f615c0d8c21e0ab3cf4e2696a32fda86e981646f27f9d48940eb71add08709e5536c862299803a7cfa7adee209b5adaea80618158f0b72ac098fffd14aff66ecb91d201cd6f6161c792e8e93f75e11698cb8d6e502ffb4cef80bd749ebcd0d9f736b126cbce0bd693e08f0ed26c84152d43f0e5a65561552707cda92098271b2d8e0d2e1429842c59c7302a80181d67573b6f5924392550e259bf82078a89f6ac754653fd696cc2660a09a7e87f87cd6d63263a1b75c36d621d14fa7b78abfa5736b5fc9704cc1515c23f3f091cd25065e109f237e44fb65e7e1399ef7434f51e413856e1fa52327a79dac0c551414126e0a9f8e42c4a1f5505c72aa5cf6261981c030494649c5c0b0a2f91eb78f4eac4702e75d5a66c7235d730de251200301ab195e55c43cffbc788c309e63efd80d49fdd807acabc31c2cc99ee823228f50f5a7174ba14bcc730ffb8bd8e9e45461506805eb2dee97a18e1d7a176d7aed16f967f629b70c3e96275b0a6c5505a7712ab40aee63f249b6b2ab0584b221e1b82e8b25d182af9891b2d47c18a27910b48f3a0d3b827b4e43407a2bc5b6be5737fe7e522b361d35bf266a9d3f3ef18eb72dca04df5a99c865ed705d2ab1f39324aca1338157d375cf98a868428309f1ab58f075032e5def7e4ff2ff3c532c8898449b1e115263cdcb3bfb6ec47087b84420989dc7d9c20786d7682f28992504b3177dc53b1c32518488ab15622ed7288a343482303cd01bbb2eb33e9da2f3bd853a5238479ee5f90d282dbbb710f92f8c7bcf6b7d86bce619818923620a47caf0d2b19a3e5b870f069d3d2097ac3802ae70eeb4a7bebcb42234c929c3d72d0327dc338f966067179b08faed08f4af713eb423d53320552ae8a7fda12ca1ed554e700371c94297f9548fc5d253a4bae461b47114a12b879008e0e5d48b6e1e8c12df71235ddacecd1665b22f9db74af3a233a999e059a566a92eca62ec00a1a4d379fd7954a6a912451be092912aa0337d1054c429a17f6a45ef2348280b317579490a94f9c4c74884f4117c359870ee88722015458a5d56ee519d94b1b812365289e0563e35e3535cb456efd487057f9e436cbc1279619bac9edf53bfdb6e513d40c028d2ee03d737a8ec539edc2bd1d93506edf1f1722bee2dbefccca15c1082ae35fab8f2d553754a4f8515c43ba9a5844204bc39c110f9a07b6af0a16d0a4d1e24de08ba8b12c28946a16c69caa5e29d222706808d8873095dfd632d08b688a63e51735fc3ca7d7f54da788672ad925d057695b4b9324c8d2ce20163ee588c29f859c7ede732951a52260268318adcc4cfb668aca03fdfa3d621d16bfb89bdf8c50e8ec947a7b72e564217be48ca821d71a79be01a1139e07ef816dfa6f148562ab06f717095e7c08f176f17c8732c6a59f92b95f1d3f99416552bacd3d38343849182764b107ba94af60b0d14bb04febf55f50bd327621b9662709814e9df05dbcd870079f32cbb67924ab4b3322fa2ea0e09d97fc2ab83c8b866916a80386b407b761eefac09570dafd395ddd820098dc4fdfb8c0d6e396b0764dcb093d5bc1be8ffa62ca907111d769f0e30daaa7dd8c1cdcdc2deb4583cbaf7738a3aeb1621d0e1462debd9c2e3fa9f718c942243d2037d0f4a67d4556e4adc3aafe52a6c29403293c8e90790879c48f0185493d1940d27cabb01ddc1c0ee76d62b35918057870f2f5821a68e999d7792a396e516855750a4bb77f4a6494512aba86554c454f24641c193ed39c8834c2c3456adff6defb3b065735e5c036b42dad1848ed776ea5f9df46baa18f6d618147d06024e4a99fae76a3e24bc8e21c96e6acec0379f5e370f9b8d366a1abcf4714361e602ab59d8be52ff445204da01300e8e1b5daa92f1188bdf8011f85cde732ddcc483e60ed6acabed7b81f3db8b4d8c58ec480794cb9cea17dfa1e6684d53c0141a47b55bed71ec0e17d1c41f354134d448e1343b87301fccf6412927b052451bf6b023001c913b79a1c7eb033d3eb5fe603f07848c987ff9542b9eff8b79c88adaf68a1ad492dda7423d27a48fb2633fde6f4ecfc488017db8d323e4d99853a7872984f3fec61c70c1beaa3f7321cda81ec81d6c52e248286dd15c4bb0d1d6221c5c79cac71ee4ae8e34fab7d9f17efc2ff22527d9154b032c3241a721fcdda51c23315bc748b26d27ef9f09c13218c1ab258ada3e4acb69093cea29dcb3a331dda17fcdc99bcc67a6a37542ed17094cc886a9c14c2496fec60a73abf2f1b2a82620053dfe79c80f952e3a7954cd339012be88faeac76f3a3407db185f22c27bc9b4ae751faccde23d303d3dad113fc3c9c0d1a118930128c38cbeed41855d2d6cd010faf76975628a50855e28180d7810809f9010f6b34551d52aceadc901ae429fc4448e811eadeaaba4cd4fa0f136a5c4d040403ffc73811d5da5a0153ce48b09ba19f0a937fa5c48f50cc1e8e462c789be97b3168be9654b3adb68e24b68ade853674a97459522d5a299d50e0f475b1b6f2c02128c03e285df91e8bd8f9f03460f2e3317dea99f4222e25f86f80501e3cc1c583f70e5b7424ab437be57c40e7438144c42c62f3035f6bef576e2923bdb656ae1cee1c95b056a24a976ea4ba8b4aa89348f56179990c79ba8e68ed52acf1da215502e8b61c3a5205c0fcde11b839a7eb142ab5e4698d7ede5cb1d41121715326873fa7e216abd6412cc328b218e1f36ad0bfd625df40d8c950a60ba19a46b9cd1f30cc79d595d3cd802e832127ba34185b5ca986a23b634c91c00d555263b23a344b6e544cd074457ac7d5cb70b72d5d2c4654ad7d370c6fe31c6143b2010a56f37af7f0152fabb9e59c864b1ea742d3ffd02e126acc360d1b9cc5e37bbb3ed5bf9f76a621e2cb43cd11be62e495528bc0150b5fdd708dc21f08ab64696f295aae53c1fc72cfa01da66dc0821cc39d98e97a9fcc1bc845c17c5a7d78c8834c506abb9dcea4cf902d292f7bcb1e1e28326753905c7e7595850e019ae8d8bd61e75ac39a8c51c5351ddf45080fe088ed4c2e6e3f42f1d9804d895aca94799e905c02a1c6264b6444c86d4822f76d04397c653c354b5746fd4afa49ba016061b80c05d600be0d6a0b2f012e91288a6de411e221aaf08fc80120e76c17804e53e493063b41577e3d887f8a3f44517d59a1db256901adab627e8fb3dd7f3f9c2e4b6b862d23310ba96cd6e18c901e61e751c4466042e4fb5b41718eea172299569dadc2c254a0212e2093543050461957a0f072ec9d79b24dffe910f4692ff907af2d82cf452510341ebc4fc57747f7015aa4ccacdfbdd4a10ab131fc4f49eb55cc3eabc368f3f08b741ca665562a4094a9866277fed03991538e7ab76df3b7c66da76d703dddd6592cb36374851ee8f8452350a01e448200867e7cdf236e9add7c4b0ce5a2aac56a39e4ddca013e9a81824ce738b7bbb1ed184c9c9f2abbc459f3f099c25c000bcaa9dfe27434db24d227ef90cd74a3aa432cc6007722a1993dd1ac10c513577af6074dc889e74071f34767a740347c848237a7da83d53f9dc25112b82931c561dff8e06c8787c284bad903807992ad4acb9ea6d858294058a88317fe4c1b82e41e75095d08ff4531baf940d3bd620350c998a5b66f268f9f669f2a13b1f84d1392744940b775a395648b78ab43aa7b58c35903d21aee3ec79509a8e1aba97ea7a76a326431ed8eabb95a84464e68cdc612abbee847006137d2251243a2cc33f2320b561815ecfdffb669dfc3dcd75cd0ee90f8cf7cd592a0079fbe17021528ecf3ae47472626341bea9fe9095590d4c5b7f632e33354baf722bb8afbd9bac1efe71b0921d8d52daf8fe842273873c9997f0e971dd7aa04f2ac50cca91cfec71612ed0f269eaf58e175f7aee3eec5bde4162682121e10e2c5dbc8018112133ac26cb840e4e16bf049cee9967fc5bd726303a0fa2c9aab6a6b14cded80b83e5d1b38ea0e587759ce02e8aae0f6400290980f4b34c4a3533dc8beb91bfaac0bbb08f0cf934b2d500c00c27390aa5f84335a9b8b798977411bc1c7df1cd15027fdaf5e78fce48f30777f0a0b0ebd6e1e5fc81f3d15dc4c3b28c5d9b3566587948379ea052a2192efa9e777a426a1c6f5fc7f6e7bf5c8bc83cb23e56f54196ebee4f675b7de0d324bfd1ba27e2ee1b162ba73e0013cc5bcdc0119370b83d2f342bd22186dfb6e9c59bfa08813594a93af34536f93ce2be7be033643262358d21c8e6fee71d524e37a6d41d6328c7c1fa79583e0ed58ac410f148b711c04856de6972d78c9b5d3a4b8b5a99f04e4fd8ce1c9ab31dfe6b38086b23a7542cb0b1e4da5d26cf777dda791d6c7c1dc736ed1a61428c1fa26a4f28d7e152f3511821b4f79c0f6287f52346ec3610debf23e05f17cc0db496853231e74d2a1ce19689873d3726bc56dfaa6e97f8aa01172a6e83eb59cc21d042141122375ff8610dfa9ea1bab3fd1b0e4020d66f161a4df4f0418a2f230036431f0e68ff27eebeaaec66d1bd95460d56fc3e75987730cecc2d0c5baf85c36cbc6815ab1daf51d394cbde69e684a9447e62fca33a94bb1117a6f74fda5324e2cd58efa26db2590c9695c7638473846e19f20c7963abc377cc696c38e8dfba2bb69d9ba62114b193c36ff195fb2cd4315595da9509140a508fff07a6b83358e01d60e2d306af9303a8910dcab68811ed6e82dc2d85dc64ae896091f499e50188aca2485b5b7c9f781352615266c157b2bcb0068adbbea7e5f88124c5ea999d0f6a9e7287ecdf2f32e71540ee75dc600a6bab1bf861f4b2564a0da18c992b955822d71d173005546d033377f7d970230c53d247390506596c1b50f33ee75bafa82fe7c33f29ad5120969451605cb82b69dd5d7d62a0f09d71e01409c4a51dc7fdc97861508789df35b8f07453289157b6b5e654d1d55b1a073596c8bb7f23a5a66d7f4c6cac9f64f601ff7cbff1778b5d790ccc8058009448791fa3b257051167fa8b435091133b01bfbcdc027e1c4d59f36f23158551051a243131b13fd747baaf27cfbb9cc839d184ee33f01ef23100312170b4def7fd5fe99737f3f788434e521b532c2d93fef7d32e2f238a3d4f3447f22ba76a1508644ac284befedbac002829e3c0d87c56d17bf461e15f36dc517c38cc051fb92acdbc30bd4cb6463efbfc15d250fa54b7ad528c3ba6a8b714fb062107b2ac3ad3d66b6b5c01d1167f5811871a259db2a0c1cecf8691e515a841b9949bd7c847439ea14a2512969a532b76abe06b4863140684fc2243b1b4c823fadc6ac9358fe211dc201b7724038941d4a8c76c4bc350e96520a6ece1a6fc31277e384588613177dd638de730bd24454fee0230f9761b1dc9ba21a01357e4fce9eb9c788f7ed4d7d936f6b775b2d05b8b9e78a3d3e2fbb99d68c8a5912fa0a9213a40ef75b3605ab4e5bdeb085c70e972c3d4eff74af3403faca103b6834a70e486b3f017f7d9a6283446337a620a3511225c5ebba24b4abaf072786c47fd1b8c6c0c4682af46ad8ec54837960d2dae3c93fb03927ef681aa23ebba24005606d2e794fafaa85d7fad8fcf6ecd212a9199794eff623892cb9713a51791f8f8777417f556d5e081e8853679ab429716b56c389b029da9c6a1766bf54c103193dc20180734cf6a69be6b0de9d291673ac435559421f7079209eab1eaf68f4f7b6ff63f207c59224df709a702bbd6af7145a911a291b03906e6f092947d88c5961ff2694912e8967305492c79d8c10e79223973fdc915acf3a5ea0538ee4f3bcfaa13bcdf365a22e165ed6f8d881b2f2b903dfd0ecace5f5a1fb11854333bbf196cc9d30ad6cdd137307ed744816cd05103b655dd761d7d5c17d65f0d03f0e6caf5cb8aa7f265beef9ff42bfdbcc6075abfe4a3241235a16ce08e1ade4ca8a376fb1414101e39a4680880ddcef11eaad2e3552a343b5d2a4cfaa835d61873433b19fd3d3a4d416a28daf504f195b55c7c44c3c5d8d904a8df7f04ab07c8049cb009001904e3c895e5231395967a3e7f053d6c096749439be627e95e18c23648307976657bcf2a95be16cfc73f431c6b0c58023851e1f9cc7c93180773c8a601acb6b4a54632dfba4d3eae7b55b2c4ed5c76c9cad168630b487654a0e20a3346dd9a3c772b86b0cdddfd1396849660ebc1868b1bb1cc6897001ba5fa573e2a164eb5376e45f71bba6088c82fc2c8b976e3f6f7e06f4718b4628444f0add86ad58bf12c2e9ebd41fa22291ca35a5be94652214f1195c34f87bbbdfca09bab97c2f2d30469f7fec6e1bafc095e9b6475740f9d35470bf3a6e61d5a5e4c2445e5eeab140602e78f008a050ed680b4aed1ba0d8ebeb2788fbab35ba3c77dbcadb8ca4e1d19323419274ef62e3bb59bd3db5a1cccb42e7cf22fee0b23a0118687f88bb74d32d94df6b334a3b409ce2d3255f9fe854841a96c85811060d09ec74994a5d865d69e33b94407fce9734c6a5f31af817cf6d32792923527980424b6d4a44f268ce2711b4d17615c298c16664409681be469def424d9e1830320048f9be5b449260ba6e4c3290779a030e3abf690da6edb470aa7ee63cc6fcbae057b7d3f8ca8d3db95bbb061d61319bc67a25a54ee2a0328a2598a83e33048d9cf95ff3682e624860674d6377aaa7142dbfc3fb770feb2e2614bfe098c7ccb1149a21fc362d9842a88ad3917189a126029fe46d83e9e77c19db62060b8e36f56d69acde1ea5ae7a3c3bf92ee31b08574b42dc912e817365cd04702456233b90fa6414ea15e233da0988fe0fc4ff4119c2c16f435fd53bbf392412d65e3f6356b965e50aa3dfb80a5e5fb65525b4ed18c30d7445f5b6870fb5b9a177f6e56239d4051a23a91f099d31b5dcc3baa1830722a1e9cbf2a915e607c4adc02797f5ac02d3d7c280af2bdcc97d8f27b0ee1403cc2159d0f25607dc585bac365ea91ca90fbb1a6f7557f2f0fca522bdb69f41dc39f6c1e00d2c18bfd70fe1fa4904cfd074496763f15882dd6ff512369b3f2d083bcd5b2b8fec596210e229a723c986d1c11565a4762c3a31b7d72942ba307d8324674a3fe205df1df366434c1f2ed588320aedbfbe15895c5bb03980030f35f793b3d5e2cb5ee8b2f2c1fb32589e7b0ff0607c013f4e9e7f3e99d96227b8a034f27764e72e95b1db59cf97d3bf4fc98237529461deb6775f019c323997bbd59e9fbc330c49cfea22e21b61a5a109cf0f351cc7645c45a5f6cd268c6f2f545a14ca65a74cec7026c94d798a3005488f7551b6ef7a62b8299d6e3ff5283732d3330c30559c77434d4f11712208755fb6bf4fe3d4be49a983811afc4562746f3d0d0a03326abf00aa4a35ebe059ec642a88ad9c8f12a3a4c10b5e4d9b1d299655b419d5727e2d8059ebc113bacfc26fa7a845ca84839f5ab5da0cc3a43afd8ae22976b9f827bc6c56205fa7c1f11cc3578c22ff01fc4ca5a7f17303b3188647d82d6ea75eb1759bd5e27f61c5129e4d0bdf0e80d910f48fd9077c3c7a4a28287811b7540cf55d286f380caa2f774dcec485a2b64868489e2e62830c997f574223fb24e8ec1dc2001ce4e18e33f54c168b792f73d00f6a13cdfa025fcd47a4752451740608a0e76ddae16ae538291966d4ec013e632394a255522ee2c6cdab6af989539c2be6e7a907e4686ca182e3c8fe981516238bdec07ceb9719c2296ade0189c16839e26e3d7587f62ea95ca38dad0002d1bce2f4a7e49df71961405a3c700c265df00b5b23c95ab39546f503b7021f804ceb1a477b903e375a492941917fc7d60341f9587651aeda5e5399b97e0065ba374f61a6b584cb56bc52a8e1f27a4d9f38a266fa345e0a7c1d0cf35502d9300746049e8ed5ca694eee6280062b8f42c1afe07b96d23823e73fd5db3944164c64cf5129cfa13a4e28019707d1b2bebd42be09c6943df4ada03659cd4e84688cd96f49359b10bc66f153c3f77d2dae8a129b2c943bb2b5c15483f08220e202d26c4cc54a1b7fbd1faed640197741e63ee2d4c6a09126e87d019799f7cc549136929412bde1b8a61a22a602a6a30c7c97ceb4719313d125853a700b770f569f4f51e5020dadff59a679524325378c72cd43ad5fbad7a6ae8bbb6305a3e31faa1559664d25e162f466327b05a5dd3939dd6681d13544251e704d3208ae0e0eca2c3471d8ce90187938d733545a31be4f21acd05964f0219200d56bb471999e043a6d0133e01bf987adcddf0cbe2296c960640df04db0046d6f09eea13cd43e46f9eb3494ea3323568fe96e26f97f732b1eebabb43e31abd2ce9e0fabe490b5188d7d2527073928552f08dd989f7895fbda0cf1de99aa7c63e0f97d5f454245e7ccda9ba7f3f52b7d86d5244cdfbe4b83423a79f6c0ad5f910bcd98405a42b48f05970af16100d0479aeb8c576358bedd180ee807324fa8b0a4558335c3ce865c2848d25e3f7e191e021a91b07bc4604d4dcbb3f7859084dc7838b0f68d0ddc2beba648a8d2e20a83b61d967fccb365b70a6715b56c9ef8a4ed649c4e307ec04f75378cca3ba50f5abbceed33ed33226f8de4203a41bf726363af1848bbab8b51f438323f26e1f975136f7afeb22da5ec6f75036afb78a74dd7e5e221a95db2862ccee0f83686fe6ef0a4d8d0b9a27daca6d71ccc46a618df20dfdd487dea9df12bd2c60abcd4c543b461744d16ed938c664ec434d816b8b849117034970304e81724d2366b4eeebc98f2560050df5d0a74baa6afb28b1c164ac10bb182bed447399a4ec9546c0735625033cff3182bd80134cb3d1491df97f74d811f749ef85e051678d99a3c404e3e9debfcdba7ffb34aa72720f96ec28226a898b31558d4ff6f1ca08e0811da5a5f7d3333c287a65c38972cea3ef2210c50ba5c6c178bc405924ac7610ce99afb33a4d0e8688825ef64c5ca943810e63e7309cb1884395b991b95b5ec2a497692fe953d928932eee34d64ba80593fcab7b5443f43489851339f66d5a6515ffd4c9e4cf3d4bdb7e7ef103a01b2519080571aa843ce91585036e3d33e5d11f409a897fcf83eb6ae8aa33cc45f0af1029cfc115c3ec1b32877a02e99dca7c27cf570cbdef2e3d33c9f271f60e173a8eafae06a6a43ed11fd5ce865fc6ff7cb543fdaedc33e7b97c4ab1ebfd3a05b306397d1657d18f3dd718d9fca9a50f7f51f5cf205ce98caea62a62a2bd5215ccb83bc65fa69037f6930c6269f3a4a422453ee2a85ad9e86d0f188068509e1f41a0f426e2f493ecf2620c96ff562b5b5451f8e2d2b880c45c6f2418d63030f4c7db8f58358025d215f78ebe5b8105f593846a50a25d78b09a7f96c7521b9e905121be8bf0a7b24091bcfdf4475b6d2464b4b387035424dac360b4d4a8a9257a227ba28a5d27653fe33ea133bea07cdd9304aaf7769b44c78d37db57eaeb0713f2075752e3ee3aa718fa509fbe526843f5dc190f98a5000dbd12d68038a218919cf2d3b748e1110fd5642bc9edd8d5b3628fa02e5fabd0a012c4ee696c28d64312c817ab0e15ccc0595832b3d54af433620437745de8829d76bffb7bb725d87073f03cb6be1deef67e6b75f6c1b532393ea1a17122c598d52c372faad0d5c0b13354a9b84ab96a9e5c7b8a9f99c906779b6ed7145025969b053a058210c78c63f046834068194aba1830c8ca14bc58dc6e26a1855791799209586aca023341aaf334d2fe32e15c90e95a976daee69840a28ab410d21c227100d54f564c04082f11baad80258d6433c445017bfb3b5b650c8b29826897cb44bd0760be80547e5e498e0b577ae7e7c86628441c7cfac45e17bc3796f8d93c0dc58564cdf804e3985334b1b8a64567b554760cdfa42d07b443f87c9882f6c0aadf7cc42a5aad07e16122b5fda2a4d8e0bdbfb5ad029d4581bda3e9bf70237db492f32d60206408db34605f06262a9692b0532f3fde385f8ddbab5c03b9cf3688657fc059cb419f76331446e353ec4d262d483412424c77d9cd3538202545374f6d66ed5a28fd9f71d4dec7a12488e1189765d1ab5df2fff2d0e513e1fcab77aa2c43d26b1465a310c11d5a60c81ace6912007b59d24123ca68ea5ccf3a1d42e09960db4c9aac87253ee6eb07eaab19ae512af6d776180d400b251a31b91aa56b820eea331aa64042f9abb92db6f000d521eee3d270a907b22675b1cd535d1fb9bf5cfdd617402942c19d72b63e5db8a14f8cb7b6d78299c6106a15404a9dfa7d61216a80a962ebf9a80ad2b69de8e7374bad733bc0e8a236073b798ae3295182e9957e21c49f396399b57e8e5833e16c7b98c2690086237158d405b75335b985339dfd9014210373db00164e0a04e82469180f8f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
