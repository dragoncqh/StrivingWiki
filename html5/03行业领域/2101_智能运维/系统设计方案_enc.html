<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"95e70ac767e875cd1af0d07cc3c6f17a23cc4fe8a77c8e7f386fa41a6acb669dbeeed767aa9992c700361b1a15f7a691a64a5be9b2203246e317f43c382a4c4c3038f65dcfeabd6c087d8c6211087ebd030366559779517793f12b69cd19cba4db2f4edf7f416748cf18ebb9f914253ba67d660f88fa02e3a5f3e84371aa05caa9f21cfbf0a187ff12f088528585bacf72b823a152257ac8c505fe897d14db041efd20c978ca727d8eb843617520236e6ede3c8b33d9bc52b91ba1ab35cd8ccbb2a4fc263c4955913782b2f08392e777580db137fb2273035b72f5c3b2b8b3859775a70ea3d1a4b2f82e90d3f541e351e860fd54f9e48648886a6b9aee45e948adc28e9d6f45d5ca087dbec5b876ac6830a8d11a787ebbfd9918f9d9165f81319a5fcecf272f3e79acdce7caf433ad12eab592b6161a9803aa7efcb351e50626dc3a4e2a819993c695bd72d7ecddbbbdcc8e99c95349f517a14f5a4402ea430e1faea931cc872f3df8af0a4a53ca6b90bb29f30a4920edbb66ea17c60cc9e4cf1e03e0021184ac7a5bb115a7bf5da8892012c68ce785dcfbdfcb7393edba6254a5fdbbdf2e57623c1b51307fd1c50a108cb226874c1842acf53fc82d3cc874e8f20dbe99aaa230a9a5d623a51f2bfb869375b992462349714a187fd5badf570800a7765915726cf5350cf58d0ea1383e5b09d31a8a0869a7df42911bdd6cfc76165f3e41d1963a656e32d3cf68052431f4064575699f66e1da6231284953eff871e3db9a985094363ebc88a49a7955c744f16eedf62fa3543b6a40e5989d9f8d95a30206d8ec103004f3ea69179cc44098971311f8017038c080490e2c95fc972d080d42dcd2f52671acc50f376787b29168968de0c76a2c64bb431ae78778364397abca9d44f28e798e1029396e7b2fe9aefcf75300fe45f0742ca7eec5cbfd805a16fd8a07e2a5211e6d27484afe6033cdbab937a23f28d91083c167d3875918a383c151dd0509b56857b29c15ce5f679a22d2ea31b729984f4d41cd8187f3090bbc2bd6af830faa0be15b0b159e2d1f5926b633b19e15001291b1d288938460674e65e0f29e228259b19dbd5df0042cdc419427ba6a4feddd5e6ad675b30f09d1df26ba43cf48faee5acae5fd7ddcf829be9ea4acb77686ab02e2f26fb9a73a7485a94bcebf2035a5298cb43227b6ff5e3e899aff2e5a210626c16cc5a02f5db1d868fa8d5f83808ed8621524e327d8f636204ad4c412a93de15e7e191b5b071f27ed2c6cbd51bdf4b7c514b0b7447e4ffc32ce22657fe0eec318535da4ae0db243b7a0f114f3d4a01e020022e8b96ae8eff8f69c28a5de4bdc492b73be433724ba6b2644d50ef883d711cd7fed661c00bf85104ec94c3be0a069d24f695cf20d86bdf3023a3239fe4e96c4e8d655502a562edc42e475f38304e17ae6fb722647794621be6e552a52d003f291cc57f701a739c701ab2458a387ce98b301ec2edfd39a8e4f4f080af43f0fe8553ccfa071012ce291cef9d9138856d75dcb399e8de7d958300c1c9ad59dc9f48ac0169d73f26955c6462703ea84544ec47af4ed3d472336c22f3c5bc09fb517f1200d8d30518ec5f41fe9ec28efff3ed55615703219319a39147b662096e275113d3a523767c41dc7d86e3361c4ef5d3843679a2bc4138dd722aea34f97c61eba3f5a638de4df34d375fd3272d458a4594089ac261556213b7f4338544aea8ad0ff884386d27c8b1c4173b51f9db486219c06739e120d81ba0c3f4b146b5781999244af100dc9e3fbc1cbdd20135ad8e1e78c7903ee5b55c1fde806b142eedcccbf410ffe68e6e0aee15484f7c150e8e86281fbe92ffaa37aac2a95296fec0e1af2650295cc1676e87437e4693526173187bb0fa7a0bacd60cc1569a5e1ff2abfb8b00153040877de6187f58bf8a8086670d57a66008dcf8bc894760d5175d7f1b71eeedf4e05ae767b7f5ff7f1a2721b59b9f8e5f5f96b77fb2801c5fb327f0636f2b03eb2f4326297aa5486146a277d53ab26485654b42dc94534147235d8e28432d741b5d405e7f291afbd9b277ee75d692cc5caafbb2a56fb94328055e046cc3a85c15f977de10b35d2a38b260f9d206a496b6e25a225112ecf4b2d37b14c49eafe73c70325e3f6a845d3d29dc759415e10bef3f462633410bd96ac9c825aae5a20935bc4c98a6df0c834b7d4e6514aa55b433e9fc1b76804129c2b563a629ea5b28accba735f3ba5b4ccc215c42eddd5f28c3bfedfaab22b6250d8ef9e8e14b892f7f3206e046774eb122121bb21d86b3c299ca13649df32b14b344ed27ecb962715eff71323fc251cff250806c57529d0d1342394906c4066af6c64e2ba09bb01bcd06671f9a4c3feb2f28b8c27fd2f3c66626cb33d0ac38320de2bf12f23069bd53d4947fafb42bc5dd8823a14fbf214efd2aa5cf681942963543caca3e9c79562eaa924027d7e925516d1b1a5ea7ff3f0017ad8dca6aaeef213ee5a45e654dd57ff7af26bf71e2c9e52218fb9359d75a43a8134314885256e19cb25160c33001f23b623965d39d9e3bd02561895f53d43cc541064a62e55c1cc5e1f59009cd7facebfc7869cb9f39fc513b64a0c7aa2e43b18833c8707bd9c54c0c408450333c8021cee2f50943774df2380d044c4392860e3ecb399fb8daa9e813c9f7a754631541a93e3fd443d44ad58df194e1912b334897361f7ce29b0927d53d06a85604fcb0b1b7b4a39fc4136d95db3d6905ceb62201131b8a9f06be9596821bcb30ca492a388460cef49104e8ac5cf728b676eea3c5001341bfb7506a3fee7eacbc81e2c68f09258e3592db97ee885f0b889f7cc6f1a0923c09f04a6f021fc9ebc866f9c8568c68a9a55187abf2d19ef850505c84e9bb42c750cb06546ce60bebf3467bbdc470b1e0e001f847a752afb0a615ce7e5bc27bc596d6e26ae9c66778f454c2985ebd8164b18d7dbb167a95b9612eac731b30d3fde47872a964019f422b851cc85408e0dcf30553a7b5980391aa4084554372df119b67c77ff248b819a4adf0e249bc5e3c285a515814987cfe1fd95d98d33dad77cf1e69404b19ed0b895bac8680b862ce94605eac33ff1aca1f072610529291d81451dc3388e276c7a30a642d945d7e94a24bf6d3b3437246acd40c4aa8209dcccb8fa514c7dae1051375f85b5bb02b7c2f3e6b59901188ebd5e1aaadcdd0cdbb80a6346382ca3dda8f3d0c9d7935410c81fb6df2da06bba5f69cd3e949bd3dcadcaa88fa953e498ef63032c47193664bc1def0775ee76ee1dbf45b8461f0dfc8ed1fd23893668ac046fa79d692f9642dd4386fcc7aecd5be272ea0c93996c8565e3e6f4fff295b4933aa602f270301c7c85c7ce535870c7b749376362aa096687a2d616aecd65daf2c5fc31f361c0fdd21a78d7645206e578c7dea68a3677e71027427ba463d33d7c18743f00ad2459130ec72de807c8dea100dda4c520b36bb6456e551a67258ebfed714ad80dfae17cf3e8db40e6f6c7ef81d175e9ae07e263254bea05c19852e4ff4ee34a1dfce5b1d6774b1f0a8c68482c875cec9b5f0144069534c70e77cf19503f7009df44397ceb0b2e1648c5be8cbed83c3859f3d8abbfe2f1ebb6c90c3a660f8ea82c9e9af2662e6c3d269b8d50bd7fcb8f8c9b6639f063a1e6ebf97c6dd6177b210aec549770522f59e41f552f957dbe87cd4d92855a059c8fc9ad29d6402144a5b1bee8628aa770c556215fbb01913851acc64c0528eaed052ddef3d0185b07f2aa8d09b9f637c28960aff8e4e37ae426f926887e87b8aa4b87b4298ccdfef958fa1a1dc02795bd532472e7957aebf23ec77a89ea7a880ec79a4bfa6defc6584e9afadb48791b726746f2503978ec81625de180d39f5309bb4f5ef9f3fc0dd316904e4486b82608d9004d8c6ab891606e121fb60ec9cd9fb9511e1ead0d9f7b50f16769a6722cfd2d562d0266531605a548dc146669268be875985665ad63f4728aaa3d778f3b734bfe4979658e1f78ab0dc9cef8903ec690875cc07682a4452bb804021c758a328fe902878ab7022b1232f1c48ed9be2487c2adbafd364f92907b97e919f7ad4bd1c68b4300df65e810b90b495b7dd29a8673033300bacfd90f2dd3a03f70abd15b512a9fbc31aa837e19a480e7fc951b25682457066d05f43062d8ec983721631698f074f21579cdfe333e9b9bcb7928389deb9ecb34bfbf9f8f1d285ab1c01c205a99afee088db9f13f9f2d001fb01dd576cf1875a1692c44d8ddaf205a57af126a15c7c22382ee3a88475a277c1ef4b005691ab90edeb5088305e04fa2a94af9ebe0aa87eeb4ab0db241f4aa9a0fa6c0c8e7b0de053cc49f1963c3368b796b7eee8bcc1be19d505c894d966d9e60e3c4976b866ea7b0766a3f00c8b549b4f211307afbbf66949b7d72cf152d33cca64cdb24d6f301f041d5c7664d411f1b14498902c444a126ed81c86c004292ebf64730707f25d41accf274a7e19b85e569988bb33afa2057787f389d455fd543c53f3305c7d8e10d3f475fcb94aee8f2bfb973462cb5afb8790883f85937b5f9c6ef458b82a0612639cc230cb2c529ea49ec88000d92463bc42e6288f1f4d0b9fa57365080e3160374be2addfd11fc85fc33acaf079e6a36890706b446a9a71a39686c7b14d887084a0b71b6b78518b9d5066b9f9127a14bc7d103b53843562d2dbcdf42e23e9f9d342f519f6c6d01d574cd8130c1c91aa8223748d3377e66f850bce9fd1c1f5a56c39305a466646a426927853548d8ec1d791af5c1f8eeb41c30f6837eb3bf89923229bc07d1e5c808d344cb0c19798f2df9ce0466d48924811ba85f435576b77c129ecae808b2bad578b760bbf353367e91a6b958c52c76fb6f831d7058a8aa6ce1d5cdcbdf44e7a03b710b535b6d6827d9f6766acf1a353ea397f8d91eaaf336c4dd8e5dbe385409d791494c261f31e911202eb5930947b9514c0237a300d1784c711c03082ecf7f7b7e092bdc05e3a5b3d84fe4f844fbcb18527983e9d7a2e33a0cc181c18aecc7c044ce75143e282362dab614d6c4e92b6c088526d9163d5a9e86873a7e6bfa3699237779cceaf5f40bda2260dbf2e1121e8b0dd679871a14a155df7612962b2736489e5aa81bb7ab3b5fc2cbb5e669c8fb5b0f2504ebef9346b12b9aca89ee06d648e09696f350dbf73cff5b9d749fb1a504ce21e108408394cf214647e3d5cf7d3f7098e9188f3f5cb7ce1d41dfdbabc5bf63bffc87c3a1e46567d3b7f547dca1ae776a5caa763306ebccc5b491c27ac177b86f146407af55629b29068efdfaa200466239a97ed8b985e04635ba7e4100354cd1bc0c7cb66d100a29fada00b44ffa4bbd30070c6b7648c3d719ed95147a378bbc6ab9f30df0f94fd24439f2f5358882ab8ad65f8c7a046255a6c640e31985e660d928c9256d5aab0fc9e224d8e9082793ea99b63a2453f70106616c8952a2b1a1f1d5e72fc468f0d9b7f964b4d3a2d1647d8a7dfbd8aa389fa31e5ba785c538ed6bf6eaeb388ca278ce95fe24f07299422cf77a62f1cee5fc8988d1f10055670f53512245cedcc0580935ead598752860091c496789883ecd94496dafaf0a0431addf9f999778261419ad7c032ef7acf0ca15c3ea72a436bc413e8b46342af7dd5f611cf1a01a0a78bb5b85997b07b5dc6a77ddbe7db6ab5ec877bb2d3f402d83bd5b808953447b297a7cbc8e30e15498394f41064653c1a262f16e303a8965445a18f2814d52a3f7746a92c3cbeb4f1fcd003a529cb894da48adf09a1289ded40cef46aacc91f1b85e4b4d388f19bb7c145b44d0741e193b4de2b59dee14afa4884e7ce89a72441e2b3c688f8be2115d5763944a35df5dee791994389ce61b38967148df12b58c593b23e8b619c69820507b53712a76eaca49526290e845040d5a2de1a06d354f0aa6a771d272d5f3e1ff125ac9a7288659ee60f4cdb702927d936c45b15510d98b604c0a7a829b152728b8db1779f5a33ed3629670abd973e61a6a5508e5b03d2970284a63d1336bc922bb0b608be3dd5fa5726a499dd1ee2a90afbe77b4ec999883e3fbbff09eed06adc2ce7a74f06af3a1d1e583b19fd52ab7daad81d00dd3f8042c4a5423c9a41967146dfc7a0398766a944b39075b60e371666adb674ba589454146b5dd71ceaa243524b5b271acd85f6fa207bd2d35b874fe4926582a83cb2528e68056fa62ca9aa8eef710533e41d86d15e17b865861578f7de730cb5d33144850435297eae0813b3eb457452626f0a4f86f381df31765da7c6b75e9e18bade61c0359e9bd38532e9e78699c8ffc575abc71c8c0d375a05f758debb174de459d1909fd3db70556b63a3d312dbf871fd904178b18124778088c242cafb83eeaca5b9dd46e831c60cfc59cfabca02f0d5695f58ec5695d4adb76ec8f0d5175512d89c3e54f927d8dff7a9e757fb9413769544c71f0f93ebb6a30ac09eadcb18218ed3c817602d9baa6bbb727c1a4f649e5e904d8a49d722f24d586e698d1dac56d158d2b9033acd212946e38b4a1cffd51ec78537ba66302703ce92e6b48fcade358623d4e60e8efde8a9edbe7f6b4f546fd3a5b648b2306f2faaf602a10cfb7eca2cb538a99940952b57d144c905c764d78557d1f2b971153222f8e1765ddf57cbe3e3ccc9711e9a266be622521ab7a84a7b3d5b4abe82fae6eab2cb7618c65f38b730a7e141e8183cd588cb772f5d0aeb87a81791a48d67c5315acf1f9e5e5bf4c52796b9a4a151d60f2f55016a70284e8745b2fa04d673694cfa9f9ac3d443d595593efeb85bae27f9cd0db8b8cefe4792d5ca58beb64ebd3d72fdf2e166af4f7c495927d3b438cfc44e7f648e7f96d81bbff0707605bcb60c0e9cc170c20889afc2b6326bdf658cd991d2e8b5c79c96aa64998497db0eab750448b851d8f8a737a2d8e9dd17a3ad1bbf2c339f8a0fc7649baae686023b04ec7c9d06dcc1da801f6a915bd8bd293483ca38ae7eb8df0cfe41b2ae5c1ab5705525b411110ec6c81bc377a821c7106347f7dd9b60c397339478d97c9816b0704146c63ceab4d4b24047b940d708c4bcbbcb7af05e257b79137dd93560c6d8b1c1719eea8bb7928435953e10ecf4ba514a5ccb6801fac9df00a90723c4d9604a1cfa5b3a9dbd9bc8fa9844224a84ab7bb2a4df457109995752542f9064eb3c834b54fa1f816616ee08692461033abc273067e582bfcd0a5da47fe6d598f7a5b62026088e13c3f4b44c9cdb11f76c3b9497f3d6528a09feb79c96beb07558045da5b64e1146ad7bcca85cd05233e94fb8c3ca80115a0869cddfbf4db9ea57add5eecf2bed97d302fe2a143cb2f20592a9d3ffd250eead668cb5efee7cd06be17233c0a9bf922aa2997cbff9519248d29bcf0a0212c5b882bd344e3bb4c444f32fdc9dca06a5f4c26aefdfb4110202679bd4b7e568823ccc30e2eefa218486d5c9c3da7c2926c1e32732126fa728474b2c021b12677c0ea2a82c2a44e384e2b2c7fc21e07d32c45fdc1970bb9bbce00acd88c1a847e61483d9889ac7aacf5de594be43efe494f66a40ee9222db2352a3bb555457311cc1009deb92e20a4db7bc2f1a87bd7efa6fe0bde51caaccd2e0f583ffbb62d92d1bf2f37e174dcf5ed2939c7ae804ada3f172a53e1de18196b606759e9c16e0ef30c7e00c2f490e1819e9d17d2350aeb8f257e660fdce7aa04316afd87796be9aed0e2c7ff4f05f725aaf4596d667c930e60cd3b9fcae652b3ae575b730e18fe7cbe62a2c2bf74f0aac9b29c9ddd0c43ce498771c8992e726ab3ae146e7cca7597ba8d65089e0241df2c7340333eb87da3563a1cb1b8c021ada54b4af49764beff67211d5a411714104e3ec843835df81c882e6db1127273fc3874421d0917781a3fba2770a33d4253b36e53a27b666fe8e92d46688be98508416f75168d1c03318d59ebd568330aad7031ab594b264990dff1b9bdb5fb00be9e498136f215ec1d60c0d43b9180404cb02daec69efa4cbbf43aadefae11e85233acae5bbf1c9889dee0f7a9fd50c561bd5fb397b83312abf80cff9cab15125106a3d1fd17b5ccc1672783c6a59d3aa765a564643389a36b1401f91c403957c975240ad797d4ec721917650b1d7f1711a1a2d0005db88ab861d6c44073a8e576e1e0105aa3e869a5c11c21e35213b14010a9517db987ec8467ef4097b721b278f5039562a7a1b9c8575016580383f4f4dc2a2ccb92365c81b1c58992a4cca5dd1b550aa93872e13161b079a75ad1524117f103704e85c5385459e3fb4bfdade2e0693c07fd1bf51be85482f3599dd5d3b04ffad513150d582df931d7a32249ddf1e36f60fce86051b537b53836b12e3304677b796ef7cf5d2ef934eca3d8ed9794b1ad1da342cf199fbf09b20a4095c0cd1f31fc275805623861886ddd89396f593234bde3d0d4d577b1aef673edee1efa1f1e19e3987d4d2f3bd1a3c2818357ee0b5673540ffbd3cdba5c4dc9462e4b9ccad7e359cb0cfedb6dfd7c903844050d491afbbdabd63f3171f47973588d548523bf9cd59b29d110bb4e82805387c35a732bb7fa6a4736c36c4e1b5b46e194df6a153d47bc5661f56c56b90d963adcacafb6d10acec24a5fffb09491410adb132281df559b2c8af47c6a557f6acab3445bc6a270b6fcaf4775731cef1bd1dff7c1e3df0fbcd41b0d91e2d7c0356e184c3b38a202a24e96675e136e8204090148ccc729cf6e0a6f1536256572b0a8863e2800dd24158a445e4e9576bf50f7a5bc8d9b15aa53578b8e2e42f7efddba7ea1a298c302f3aaae89b28a093abd1329ebb5f8adbe457f4cb84bf45ee1f0206d6077fa537c3fd1dd18bd6ced8ca44bf2f51d1f46e188b3b5e289e43ebc39246ebd6b30dfc1fb8001cd0a085d367ce34cf8b8c7d5a9e8b1b6d2d041dd270da93168adde161e56e6dcf62bf82719d66bd33f0e87548701dda66c1c52baadf4510269be4d6e0ad23fb908c393a4629b83b9714da8656510c37d0630cdc553f3a4a8a367fb65638f9800b0a0d012ec5cc3ad1a2e00e9c33a6fb515a3282e409e058d4fecb36fd6d17b40122726096d3d2e812bcd9ee6f0bd7c79a9116e60ffcc0c3f8ccfed63fabca9fdbaacd20a9b9e2f707a759783e205ca0b04d96d317c6be67f25f8b003e5caa1afba936327aeaacd26702e1a6a0cac5e4833d0129f1733cafca0db447e36860828deea7dd4a0d157079df7146c398b2ff4494e185f91bfe7f2e6ac21ce92618b1818a3d3f50707b72d59f5f40e4d496654e3c8c4328715f3bb3d130927e9aa90ccccd26daa0226048f51ce3e8f8684483025624ef9a929e1559f7e0c8ed0c51f19ff18224af611ad6274645430b8341379294616d87ca0ab2ea84cec53bc2320a8d3f1433c7b33b6fad5360be41e56c0fadcfea3d99d879be2802fdca3aaec6cfa8690b7b0be57ab8294caf75e87b37ae111bbf408880464392ec42d742c707b24942146fa0136831bf4ec84c9528fcf819d084a75844e394d737a56e772c446eb353aba391ee062dabf09233794e84460c463ab368c2bc15a14f73962ba96c8d0b9cf498369942694a7a0f143c253ecce5417ec295c74b3ecf43313f298586afe2e90ee5c206739b816eef4e4c13c9662c1d07304d2149661283d17d821a066e2df1d3e3592abb857785f7f86c5a8eef42c7ab7512f37c6c70b5d80b30a26c296b43074c1838a5c0f4063e6e7fb1554d810457e0bafc7daa1927032256b6e8aec75a7d6851149f46ff7a9390a4e695ad06432f9e7ec7c3f7761ef918529e6366958559879e1098ecded24a2c6b73c0c2503c9bac5e7f3d1ea50d7527685a1da507fca5df94fe01fcecd7c975e9174f7b5fddd2ad4f9320072bf6fac714dfe6968f541fe401643c59d082372b72be9ec9740a8c461c3fc78af0abb0440544a4eebd8d5ca6bdf3bda63784c138e9eca576ad69484191da8948f406a5686ae9767c02be457e1e2c99c3ba1198e851ec161401031e01fac239b323bac482dd3c91793c159eb888fee14ef65fda7a6a81ec3907bd55ecca58c1058b2b07ddd58c0601b77b14d6ac98dce9fd301cd9e7b0f9a234ff69ab26e36df16648ce3ab929db6e32e923c1e1f602c342a61dad389197a3380c1f6a2c88d49dffefcab3f3044f7aa3203873f9608d636a93b3325af3b5984da02677a7f74f69a0acf1bd97d54894cfa82bf63826805209f2265efabf1859fc56aae98a03719b4ad423dfaaccd30abab8376a262491a2249551123f078accc6192fed702739c334214e02e61cb991981a243da629d2d95242d9e1fe7f2c996afed97587320078adca5ae10faae17bcf322d2b1ea5045b6095208bf094556f613dfeb7d31a5316e15aa4ee8744eea4811a11baa45a84914fe7835c8a7e19d34b1b63e059c7d45816a8b009e976fcc69b58d5f0709b3aeeac1c285c5ce415400fc4f175ab3494fabb2ebba5c8778cdecbeba08fa6c950e809cf28d099dbdd9b2d383a743eeb512d784d6b26504b42ba18b333c91b34f6a54c75d58452734870544947468003509168cc033d81810e6936fd00471f77cc64f1a0444c0bb01b3194d7a69bb31e233efe3238b940bceb5388f42a345df16bd263be9accd7a0cad6364e22926ac96a243e4bf760a9118745c1fb317225ad1db2a9233a1a93b4064f60d7b11063f4f66ac1572d7f6ce106ca1eb0b3077c282cda39035ac5339f4345e10eee6c14b23b0a6872f9e942e414dc3797c93239531f253a23492777fbcaf639c1fdf7f1adb6173ad10bd1ec8a4dd3441aaf0c3644502531b32a4b5f5b78304ac2857c409bf6fd44363a8b9d1561631778a86b895b0da0b5d9a827b530e012676f04e3347756f141a863489e33f421033c929825a4731ec1ee353c5c5ac6ad0c0a493bb633b5a484e21443014ae36554b92576c4043a8d35f00370f5c319b4649025242860c433467adcd965cf596f0d25d2251346f8b9535397ffc38d1eee9914ddda28c82ba3e1846288d8ed478ce8ac26c80b7c82380b051d1d9aeb95c223c8666ffcb198d87bb5c76cb0e74b5b34ab60e4795de6907467c3797afa51b6ae20565cd1504d49a00ec84abbf470cb212c961d0172063f7e86f5b4736a0e8f00f456eabc649ede01488786c9b6a9d229cf1dcce2c47e5ab28d05bc542920a1953b5df68e1c19872de09d4cfac61ac2a0d4f2ecce071612acc8753846ec1ad9209a1e5f85a237d0f84eca6e5116ca9eed3874e02956252ae3cb65aa5e1d2235b7af276c85ab357fc3131a279670c0159ef098544a927260e8a1843013164fd7642dae661350909974b960d7285e39a53b39d5c36ef1dc116318550d5e4471978b3a8715df948b8c27cc42c934f090d979b1d641cf8d6fb9f7414dce2921cf1426603161c0a3998e8a006c85fc284a2aca2e1505331073feadb6b92c6a1a0f4f7bd00228419575c7f885eafe3425d3c9fd50f7b7ef9f77bdbe0f4641a993b73f3ae878f28365a1aa79a6bd46805a6bff4c2ad892691c428cd93569157a2271b1e04a3a71ffffe136c9cc7ed6537e2912c7ce0991585726020981c3ebd327c861923f6943900f0070be16485879432e9f0d0e44ea36995908776c2e0091e2a403524bd97bb7adcad5ed8982cc17ee9e4aeb129d1a1a37fe2891649c701746d8e68714c4f3212228656d22f843c66372624e30cb28dcd03bfd1ee48cdb98045e5292372de86e53c3e74f93904fc02c8739e15902913cb2f60f276204fccac977eaef2ac651a3be676244ded5f9b1dd0860359095ad877c55035fb4d5019a96144857eff7d72e3e4c6730b9bc23cf792284114eec56ce782bd6fac56e4e248a40c6d211005928b4040af63c0f91df1011afbd19e82689ae5d38a83fc4cc6cc8b90162351eaad6f415a73e1434ddc16a2fc435c42b7b5a01a200b20a5179c7717098f61e45ca86b8f3b0b549cd8df22396db703d7cb02721b3cf8636c4c5fda3ef8e05bd89f844bdd33c8849984d4387fb55278a5a833f05745f271f8478770c1c993d04629ed66cd3b3df4bbe549444f9e1f6e030e2c7cbe6df714ede8202b756ccc34e16b5b269950d5e227ff11a3073ea1f899b25060069992ed24f0647a6a022fc86dba77f3928ec73d49e77675bf57ecca28418d31f4b84b8a2d60d7d1718551a3f2ee7c34cb8893cd6b063e7f41a44523491d44ff37817092240f3981b7dbc425aa236ab00aa6078ce44be77d9020306913552f99febc089bf1c2b7f345f09ff1413a727ca513f145f321eb1180f62301ede6ee2cbc0b2d699a8c03e14d8205a04b0bd0b0b9cdb6bf5693a3c4affd94fbbf37495803b3b6f5b15908d538f653696e770895924210b51257c8df8802ab22b99bd88b3cb84eda29b3cbf71b95666c7b458553dbad12d9c49f08c27883c929ee9f39aff5bd3c9bf573a033f8b9f373b9047b2f05bc920c09b31f39bb3d54b24c0b94788dfb1addaf592c7fa31922762439129ed50a02ed5ae732440c9ce299a8f05f83b15e2c5d1c824da22dbfc2e0857983132198a63a1f6c15d78b209c4c9940283daff8e3cc862e627a54242703f44fb97a6c73810ea4b3ca941147bf7dbd11ea390336643974e5ae1b341790d6f2f3bbbac659621cd11e9ef8fc82be1d576885542dc1dbd85577b5d064bff8d2de3998c00bc5ae12adee25fe44e42842991eec997364a1f5f48aea9cabb8551346796164b5cf2aec5db793f1aaa93a5b63bd000a5dea8174d1abd093c6a09d4afd543f63ff2941ca64190eccf97aae3a5c7e2b9f793c02d7066fd7a4c211127065ded699f5b4914a7ca004ebc234f5f3816c3b7d5f5bb591a9c50d192a727a3a12972934dd272b84bcee29a6c6a7b5e942ac46de42c027ddfa3a22a882859a6ed9749e082de61be2e3b879e1c0f785d4be0c0109b194d38df535524a16137793c14f8fb0c69e770f937e61a1fe99345efd7e36eeada30990b64aef19a7ab7a6e948fe087eee82e00f7ab4c8fc1187872a6534f8056520f2364e72276218de42b0d0f9ea5d0ec82fa91a1d298e60b2925951ee477e0bd9050e8e1292c6c1675738fae28f8fc759f7ecbd1f9dd2bd5df5f27bae02d35e5686bcbd293309f92484965003c9dfae3f3af36035dc4d5f134ee33ca046b92a13e09c191c0b80c630b406944bfd89fec276812891c0f3328f46b7c5a5e36f7f789496fef109af69ff6e1c86545218233e36852baa9e367d6a2094ad45c73f488487d631bbc4e9870fc343372505973a31ed58b7c2f03233c493d5e348b4277cb0f9eed476314557c9331e30e86da5c9125779ce8c56a975a46e7fa7f6c14200f82d197e31e6cd773f89b1486dae14f33b43aa3f39b5c469c31597624916818b41286f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
