<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"128bbff293d51748554bbd7be0a18b53e9a3d901bfb9e6111f97d12ebda8c0a207c851931a61b9be17c54e980fb1f7fc273ef2bd1150ae66f56a14eb618c0d28026d5f7c75e1073307f378f5ee70e94e441a081766773a50c3493671c0199238f1a5bdec8c8c40e80c0eb6a315d47e1fee6b6e59fad6a172ad52162a56be40f7eb566ce4b18c7446a2d46bd1940a236362b711af18d7f67eef1e0801bc59370275a360f78fd57183a0fafea82990cb88eba074af6338b2c8419c30057943f7b66d81fef0ccb4747b227ad0141a01e928069af68f24f8e3b47158d9707d0ca21ad0be57467cce491fa858a6f086aa8ac7715d19ddcd996fb3b7b674246705e3ae2105a49d373dadef9b4e9017a7614687a14d01b866aa111533163ac20c1c3ef060647b41f6a85056a21774779fe23afb3166d8cd53a91d8bf1da8fb930d71b8d2011d5ac6b90bc903cb00f01c887d7d23531dc90636372ddeb732dd016e049da79c2961ecbbad6bfb5eec8bdf0b52cc0bcbfce9b47bdb66ec675576f476c1a781de45b148dcc72e3ec3d040066a161649bdb00d0319cf4a89d345c0c41d9ce96d0c6a36802ea7fcd243b54727d7da0ca423258c9ef3f1ad50e76c89143e305e5572d7fa1bd8a3c16cf225aec941fb695bed08d34a104c9d726e099c99742e7f311bfc87a578822f0fe7cb25d059b51e6f8fdbacf55945830e4ebbda4c01e2e774932edfbddd23ae10ca80f8ab790898b0bb34f1777550a46da86dd79f7047208194d28de04a7e2c1edfba1491bfa13c3fc860098edb3b2467aff9584ba593de5b37579d13041b575acc8c20008cf6d0ed406d0a58e8b683288ba8964db99b6b89438b19c8fbf5ce9199a5c045045c04961d157657b8e00535b20a465ad6f150b129ac2663ff87cdfdf0669c9492a511dc3e2d64c6aabaf394b0e3c8905538059b3d60224626be57811a03626d16cca357f53edd3d37ac5b1e361391a811e05fb3eab0affa9a73997197765f22bd4d5a675506460569737e324f4847880a0269c2c5ceab1ec498a1592718d32959b47be3879fc6ba2acf408296488514a7c9b2818caaf7a4edf35c29bc5d875d2f086cfaf2ccd7190346d65c28b0567a541ecae80b1ff64c1b7dbe2d4225fefe05eaaa444557376d9478c84e2595ddb2beccebcb1b632c11d5124a716c8eac53c79ff14f31e8fde2c0dde529653c06ed0ab3f5794e04b295552ef8907821abf269094a4338abb9a4bbd7a7e0a35ee671856e79062c6ca230b67c17358127678b4bb418d77edea218bc5eb9a2a104c563c13f2bec7ae1f58c31fe40857e6880ba7c5fada7b9a9b38ec4ec2c664aa6106a595a62ed8f0053ba7977506e06dc64953f7c2de615a605940d89f20a4ce1904e70e7e57e0174b36460df8879feee841404f75a96f8dac2b316109186781899f137a8d2a50e4388854722c16d3767a5295ecf71621bff75670dcda615fa61e230604df7b5120da59769cb9455636836de0f73bfb2abcdc1bbfc55adae0d1be2e432ce423598d9e628ae009d801cc40dbe9d02163fc7ed0975b568ed0ff58c4812fbd2198b32234f92d020e41e6db4ebfa7d69fbc19ccd9edfea21edd98271e43ff0bca9d92096035363e20be0ae5a208dc5f5af0ad27a7f26d4bf0efce6ab568763fe7d09720fb6db6829b3a283619884ac05d1ce9e138836875d9fc1751dc4bd1b49d2a6bb5789805988089833b7661ed8476c890e13f4a687857306a424286bab972758be43484bffd0159a3f48d3c755b01ce3e74668506c2a99841f5a6e4d6d88408b9c3dcc6e7ce4d63da4493388e891f72b13378fa4c732f258bfbfea5249fdfccff30e168507df675dd83b65447d511b796ba67c7614e5f0f0d27c95b5d68e713c99bcab146f71bd4fcf6d6e3eee632911ec895e4a3d50a52103cc9adb58765d91ca5ad02b2f235a9ec376782bb0ea00c93707fa9ca60ed22dcf6ba454de4e308c59d0cbe437922956b6eee56312207c6e59d78613c5879a20b1bbc83645620d034707b71329ba523cd5e06cf49841f269b3e34ccf9710831295ce82b1d022685350ae25c43bef9d6e2e24a43ced679f069e102ce945b2e01ad1b993c1c3c0d04d172b25104d3fb7b6f72e8c35f512a31e990ae402d1beeb5e4fe3c0c0863fe9cad041608b23d4bce3e3d9b6b138ba931ae60146519870734f52066e5a640751281f7e766a9121bd8d740141a468e15c81862347e3ca4551ed3849e3ebe10f1c65d912cea8f190b5de411c88bf296e9db2dc3b261a8be81ab554addd249763e64bedc1270f58f90b28084fd1af0c8a2ec2383c2a38fb7b1809fa9b11d0ecc3a872e3a21ff6606b4290b568612053dc14e4dbe6cd4929929711106ec5c239deb6615dfd6b6775fde4431ebef56e9a4c97597fb1cd2d499ed171f9a32eec9cbfaa949c8ce52f0dd6c8ba48b23a6887310dad850571e61521143b7c37fb4af94466e53de42a17f1e5bcb66dc02753865b735d59e7d2000ff85707c89b97e7eeeae08e76bd679976d26e6302c7c7f17e27eb910ec576f485a9a2e5d57bb4ac4c327ee78ac378fd6133ad29fae19480a61021977924ea7d4d57233bc2d9d3c29908dd3e6c44168021d0188c988f298d9f9d012f18bc9b79186460a1450da2ec8991c9ad41dcb6f67b86fc87e2370234a19bbf5ab926578afd3f527b886bbad18e73f3779be39eec9e50ca5d3efe85452c4b84690724ad6144630d048886404c4c0ecdc59512afdcca3c5acdb03d4b8048a1dd1db41cebe649f1e64ae6345009680964229266bc27b3916a5ab7b0f7d5b45eba3407b73142e84aa44a1f48940a81f45bbac2a9d068bf88fc80f34d6bcbc1ae329bdfd6d825abd56c00cd2c13325689ab0bd19028875c0ec012d60ba6a5d719bf2613a87f984851d625cb2da2400cffa47ff3f40cb0005444f34821a4c59c4eb48e25d8d3f1364b9c8c4aa666fb7793b8b90a6490fae62b687b34c77cdc07728e0b4d5a1d04cfc4046159d59d568e88472f1054e3b53aec79c19f915431d799df77a4dd935555cb2293ae681f2aa610ecedda58b7797adb69e0985a9521716964e9557341c0322a7f7b91d0c59bd2980c5a36a6ca541565a8b9e14139f8746f4554cad201ba2038feb7b2c3080cdd1b6398a53bbcd8d68fc29cc9e74fca42c3332229c5af30891e1f5bc14077fec006961ecd1c0cdfaf484f007a3b51568bb3034782808e15e718bd8b8e279b4be02a185f99638705d6d09e7f9b0162cf1f4b42c8d5e17505dd532c7054e0dbb45148e435c55921a94ea5e061ffc364d8caa25f20b7db0ded984e40ce238919ebf10546c59c9a6578d69cd5d899d5ffdcae6b17987cbfd732a829e0411273a81fb9b34e45c2a08c806b23b0e499f75e554a266e51f159dcd52ce235da1cca3d98366f9158ff65ef1c483aafea1b7394e11e5d9b22c71c7dfc747f43a351da075848d74eac2cd32c7628630ba02d65f26779aee238cec16804f3aa91cf80c74c861ec4fc993dd61f4329442847ab3aba92b9d7105f49d488896599dfe2b3612eaf5b3605c515d12d11e01bd1bda261ad0814f743cbd353f5a4914ae5d6e015f5d222ec4fb0389b5f5c9007e972c7db27604cd784bbf4d8648085c21acb79ceb3ea55df029b76ef6a4f0d9b0bae6623dd8677c2399967cdacf67952a0525dc1628e2c340df1e2c0d178ecb942b1411e23c0697a461a0a909246b0e58404f2eaabba1251dc59db0e25c61fa32b70f875bf8bd516d3833c506aac2d66419e50ed0d6830d7dcce60f695a6808b62b9c353bd149e848fabc094a5fc9d98f0ab866190bb56f89919eadb8221ed778f49eeab486e9c98106639302461d94b4872241fd038dc5cee2c8c3d30972fd94302f4c3007af0a60309822ee80d556895582fe0898ad63ebda38e181b84c585abacb01e98855390de719e760d56184fc78dca7b64334ff4d30e3d65234c34c1dbd3c4ee9cb91efeaaeb7e7123bbc3a9f35365a76c98aa0cbccf22013a3fcfe977da7a84a2f94f3ee897ee605efcdc73694642de6a5b8c1dbd4e081daac23a8216fe1d0c93a0afcc4adb1200816d4017d5a7cdc47f22a1a45120a0f69c5e511b971404931f2449cfe7d962654a26ae4f1550c66218a21f7a345f17a6fa88f14af2da4b2fd0118c4ab09c2da9b510c2bfe7c8d7dc8b5a6d89fc4372f1a146c055e1967d731608964f89af467318afe8ca128321412a989300b217689313b1baeeb535fb619702b1f48584dd5b49d77de29c77456079f66a4cebbf40a36561048e14ac4cd7f789088c8cde61cfc3046a237a8bee78816e5f7cfb6b95f5e494abac10b2809320205d0de3090419f58cc0f451a153afea8267747503a5265ca3284e9c07cdf9bd4f54eb8698f5690c5b5b2208fa2730111921260753623b9816f36b1a6acb3bf60c4e7d752bb6875cf580aa3784f63ff5a1e685b1e1751fcd9d23797d2aef15a65fa48728c905a1abfab4e91bb0955b1d4fde44fa14d01eccf8db96dea2c7ded274905cf63e9161fbaa019d140490c9bbfb1d39b2da01264f04048bc3356bd8b1c60e9dc8a982e4e742ccf3de07b287eca563ede38a3fc89fbaf82e325718f93a716e6425839c4ff16a4d91aed9288113197ede88985c9985f53df81a8be3633cbb1525e164b296e4a9a99c060c35d35e03e4deaa65dacb920e4c76f8e19ae1a638421c853eca6c0ee754df12860c3ab7ca68b673f0ea8ba53005d7e298ae37e0f4518727d3820ed352b4ee20573aedbd75d827d9cbe72fc95aa73277e760251c14bdb59c542e05414abcdd01a815c79b417e84c493bc23b3cea17e2d7aaa46a70edfccd3c549edb56dfaa1bbbba05e963567f5d834943d3ff323c7c59fb4b2c76658914471c3558c37f6f29b6e165a010e9772a790e75c86d337c00dd90dcfb3caeb680cce48ee5ebb8ed681177a6020b2ed53b7f81c1ffb89f864b85a711918d3bf181640d85de56ee00e6f607e7f8927a29f3200d897c6ac7490b3ff9e643c3df902564ca581b3c97a00f04f58dd3b37cc7f5acf87475e2ab5ea844da7872c96ba9195938763eb5abe5f6bd6f5db78d299002f8197c6cab18eb4fbe6e285c580d1069cd3c930feacf85d3691b950cb082f973584666fef93d1122499bf149512fa2111758dd29043f36c1ae4d1a73620db2e32705891bb91e8ecf38ef0964267e159a1964cf4b4a68b87601ebc6535d0857a0ada3ef95c69fb028f8db797c0cb9d0f0d69d159622640ded457ff5efd99ba0f0a31433c28a6bf311882b208d58c550a01bf6b97bc86439c0212ebe3fe208716941c50c5d2d1e0768487c7b419feb73c6e7738ddf511a75508590912674c1ec431b4cb43f745231756039217e2e5aa1b0216cd439618f419bea4b1987286997824f0d12b1118e6a5b22d0c2494aed5e48b96b313c83a097f64b008c7c2bbd4533ce200a4933688b31ca175ec60143becd93708b55e0d17473d266d08431da5cefdcbfe3cdac2d67a8139fb3f2066b3513e35440fa08000ec0c5150eb5f352fa6f2ef4d7bd41d78bac748a1a2f80fdcfe21866211180bf3e585fa84dad8b7d069acf91d113a6bd0623391dea57f600f5366d29b965f382c705231638abe712a3b84314d9f781de1a981c82e9db8246907ee582725f3954885e3711560f73aea50fb951f8a93e92baa76127c01303550d4bd950347b02e113aa6cb48e461114bcc3fca38fca6a89aaa1bffd2c95cf8e10c743ee2f4dc737cac03808bbbc78451c26a5fc964b3494fe18bafb9e83bd2a95867b27e10a6932372e7bc46776e945855b6536d6554f99c52a20097c5ced0d4c6842cc8a5678d8627eb7ba7d4a129b3b0d5bdea007cdb0167cf0cc4ae25b70fd4fa16399d88fa5337454db4045632ff2fc67338fb4073b5824e06bd06d9c9b45d63fd90f9b0d861142d22e3d5ac464ecf307d14ec1f3c22bb4bb015c025146a17fb2d96a6a887571b9261d4fd82549d93cb06add7cb5c6c8e7f4263746f07a212937be75cd661dac5e8f174d93e3537c443fcc8515da21b75037f822c5034def2d229b8dfc7e4fa974f2f81c5dcdbcd8aa1598465172e3debc4f7db75f74881678dcaada36a7185174f81bf17a32b5b47f4badc39a8681ba21e4571031563ee5859fef37c22bf25ee5f62539875aef4b6905cd541e1f9d19cd64193300a493452c6f4a37fe947c8baf8685a3dfb4bdd79830f76f681d4e2a83b9847c16da74655016d8d7fc4e91da49fa31419498359092f9ff0b1d84a7536deaf1891a529dfdf43a6beeef408a6533f9cc8b10253bcbbcc2708acc8307f6b8304f9be2a85ce54169d7cf66cd4b3f34369d0fbd282cd0ef80ff26ac066c03bd1bf13ccd5ab2fd38f397c070254b7c874781f27f099b9a6d7415f38f554321fd447562f402469af5f99c068ee98c5088233d25d53b0b14683a9fa57e9ba7b4269952ae27a6a1e3c32248ef4962abf5c33be497d1de0b2ca766b57348ae0fdd149b83fd1700d385ccb6cf8088905397b84ec04f41e11da7f8d21b4c9dfe1a1db4bf0d8cc7332c8023cdd41b21397f72390e96e423497bcd82e97999f2c4a7097294412907afc7bb2a33284585c32db10422dd82ed1be86aea5eb4837733e06c9e0d481e03f67e9c02f77e569a4c29db2ee332f1c9497f376c4bef9270983198495756fe837aeb4bea929a51b469ac111bf59bef91709db50212537e6617931a58f24e721e8d43c1470c8c0cb84120faff045c1f7fd8a18f4266123cb5456afdcbdfc4c89130200cecc37ec9ca2b001bed84e4285a098375fb632f2c71ed49dad685c0897019a0016fb5f37d3c8aebafa9847eef6d15d5f597ee85483d82d9e568d63490fcee4d478ed17bb145c059022fcb61c81013488b8ad61da2416e25722992c59970f4ab05fbb19b3d1ee70ef88ed9f2b979d90a5273d74808bb931287c486d730fb7046d437770b2231ed8957c6d7143d63ab3bd8843d257f6a32dabecab8143d2b6db6c223d99c1659a2bb1d73f8c796f2e80849ca55be4b3c0874d10814183836452eed303540c680f5ce280d1c1f306fde354c78c529c56ff10b83345ab0b91f45e59027a51d0780d6569b8259ab9fced49be45d39d3535e22cd3575507447aa13308fd05dd5098c6ba018aa19de64535361e2ad9c11db050d5e8560f50ef1e894d1c4a8fb8715f01e86d1bf282fd22ab5a3d53f38895ad1840bc4bf0739941f5ab0f953693d98366eb654ccd123251b7fe8d602676b3caf7634a294d0bcc25eed70ce38bd563da4ed76e367aef07c601306af7b7bc0cf94f62e8234da8717925f8f1bdd5259270f22994859a2ced9051cb8782cb3eb65ec062d7a83f5f77b70b98f622ff6ad270415e16db4417fa9dbd59def40d4cd6692e79bae4ce0e8d7552d3f1dd56629e08a0f1b6b5d4d91cf6d824a3780a3070b5dfc872f508f76cd4125cb6557314bb4a45c0749baf3ab1b547f8077da570c93461071a36658a6b97a97562610258a43fedcc839a0770f3910e7176d66a8be1dff178190720bddf0317d17a29f53f558f072245c1f3149fc1834315019a176cb76fb253dfcad41a9359aebe26cbd5fb377c115f04ca30a3b33057ec6e8757a3859bfbf59586e9af703bfe2523d0754537f1c01cee393db14e65e63d0d4065d51fe184c9ebbc7ac892d7714419a11a01ec3a323951ada3cd451d9923dfc34bdea64bc432378fc48ea64e1e01c0ba1a7d24ff82345830e1beab40f2af16e6c77091374577e333e9931c87efb6a72222d4afcb811a9949b76767896641f135ebe3ab02020f93c47dba4c5bae986e23d2e21e5146c2fce94aa0b2698a65a53a8d738910ec71b321ddb942fcd50635bb9885f5aa8d098cdee3e851d901f1386d5ea2b40cebbb6670dfc890c36743e4ac1588028d654c818c38b6534381b5d03426e7052143a34f3593c4b9d379020686138412dd763512a068d63e5deb4dfda7b7732aef6f582ed3b39a3c416e3f94d76253412caf3c075eca40b1e1c30188c350d9c5782f1339ed85995d948760ab6ef33aec07a2cdf2f259a945d5b5dde336361b1409f6affc2073fa881f132701e75f24579c53e6aea82c96be6aa1fe26c004c9f00fe7988f1343f3dd8717b80a64fdb05bbac285adaa628029a37eb7f43ad4527ce94675dbb7c4c339713b1c494e2e47fb634902c3b2b869e6eede24aa8c7d511806f34592c1b3439714dccea3197b75f39907fb2c4bd49286ecba8c84151092a3db024f2dab5237364521f85b208c527b4c446e35ee0b7101a05a765eb7b1cfb55fb10350f5df9e33840f6c9ebe22b5443e0e38ff1d2de84d8f8918e30400838cd7f4ea131b435dfe1526f675c64a0d5cbc9746bcfa987e37c5d822d8e6e41fc121d932f1f7b73d7a28d236993749d1755bc7cf39ec1bf1dad99d62bed0e1206a55cb015c9c9a837a17a66c8479f0e88d74cb2f0c06e3bc67fc6c2ec5b23423569bf45691cad6a36de42cd5b24cf92c8f817cdc0eda28ae258019bcb2f9529a8ed3c9fa78f620bc7255d2ff4fd259065f76aa2ef693376c5d73961a5fd2bcfbeda3d49d41184977a361ece8e01c983be64db15bdb8c45c4fa6669faf44ebdfdadc6bbf4dde6374b9e068d59321d03a54a2d5193426f01092955975467271d16cdb9eb07b0611ed62087577ac1bd2539e1a32c849dcee8fa518512d551bebdce0ea1cf53694e0c60702be7fd7d79aa5a89ba37a8558efc2ffd69e7164e93a3e1ed1b2b5451230b942d6f8161e033ebaabd85f297f2aa82ef864261d4806c2af946c19716cd338473a08d74a29a538a11e2ec87b4e611ab78c97576f9fca24e8ab7dae35e6f77a6c403c9d29f86149c7717763aa26b89a80d59080e4421a26c6df8e82a5c784f85de8f35f1a205e7e4bed339de0a8805b961dc763cf2a13facb28934c177481cbb92efb2abc302c7b1b6f4ba3f660428ce413a987b19bacbe8e8432fde99c43bfa2151a13d9f64cf5ecfe450ef6a9248cd12ed380822c8c28b732abd0305867bc09c60c76afe3be3766ec913ab62b22440d6e29d0c65b46c478bfd98c0f27a10b2e9b427f3273b5f2b9eba565940b68020037569e2824388fe0d04c3d88c97ea17883669fab778b2f42030d939d830fe12e7905b37aeab6434b6ab6c8489af45feefec8f35a7f7fccf062bc58e8b0a5d55ae2c944edc774fa79914d7a6792926cb5d0fd9c6dd0d5987026719fba1f9a5f5a30f2365428f950e6004773cd458099431788a1d73985ae29e70c462678b397966361ce0aaeb999ecf8c5b48b4f3571adddaace35b23dffaecdea0383020eecdcb14526ff8732e15c51f9b94861c2699f1f1bf9eb910fbf03816b876c57ba40c7360df87e3b7d4c1e604dcd5b6ef9be495e4e909375cc57cf5a703ac210c0f232a3a1bc4923896ad3d4c5a3bfb6f8bf25bbb23f3a0892f8addee46bd6a28933ddfe6540b557dcc9afaf47dd1fee79d28bf10a73d31ab8d653a911b666306381cec78bfc6130686a241eaa554af539b145ac4212d285f00c7e9cc896ef3c7305b1d3f7b74660c927e9b7f67d5b7a8cd165771e6936900b82f5d875b8d83854af980671022f25f8a1ba116342915564bef3e9961db5f51ef4cd994e2eec772b9dbf95020cd7fd0fc5d1015424ed1fe2b00a61c814f2d755851a6e6f80472e96f41c9a11ae846d2500b5d7936730a5a8b1136981f10b8b78bdd57fbf9aa018b72babaec914a2d29cef4945e92412ea9a85d4c7a6ebd2b19cdbd80aa7e2d93453309b880e30537f5dfd7e59dc17fe1cdad38a5001c7f760ee1d8d170e46151f02bd2b3a17fbacbf85f2656d2c66cc70d7a853bef842fb75af8de8500339e42419a81f89ce4cd70b63bd0b1bcfb31750aed486df00a5c0975867b160558743f0e1b0d081d763fe3ce59d72b362762461d35e990ed5b74436cc1f400449ecf78e792e5b519921b0cca5e99729cd05188fd63a96f881b2e1091206ab4b7f599945f98d96bdf4bec0d16eb6ee04659590ace329f624e53d0beed3b7622ffa606cd18561cf3ede3153e3740ffa044f2b033d0d30e13e49c2cd580b699f6e430ef46754796424d8d49eb249f2f2fad30321b9cd731afe5a85da6166b337a77acfa380d76eecfde8f6a20c811d12bc1066f7b020e372a7ac147861fc1c2436c357c92d7cd49d75284bb2d245e7661697f49ca1e61c8ca87e4a75bfa42629071fa05c682f510d5c84bbfca3b17b23bb04b1441e8b1b879cb1ec1ae9546dd0d7e0f05c108685352b90239fe7f213bdf1d825196b3b554cd211808049aa1f834214575f4f5fffab7dcc847062c4d96130fc270a64aa6dd6fe429536baaa9a662fedf52acd5031ab128e374ff8c9d2459284347e85d7ddbebb52731c3b6fa59cf6dc6384b691226c01d848de7d7553ce20e6ef94c662141afd0f1d48a2528bd3fb51a49745eed74e2b1c01a5cd6d49631b8c5579632d96a5a81450edbe93599bc6d5099aac6428e43ab0ae39cf5da48a278125b3cbacbe970f3ca0b6636ea447fc2038917eaab1755c73f7f7b52a72e7661710b4ff70cea2df1fab44e2137f61600319ed8bcc39f799348bf830553dd605256d348dad5b06a9b3f8add29c4c5ed2fa86b9cf9b0d632d4d8e3fa49caab923ab9824516e88651fe2770f3b123750c3116be6f7e17f8fd6eb26c6973b58324509ed3a071a9bf893c2b90afa4b4be4910c73f7e6e9385b6c95a8a90cd298861cdb61fae0af37ca87475ee3e8aaa06555ac7e08975733f3a3a4a2703cf7d25b1f9bdd482b8a6a6b58fdfe17ae13c1fa751d289a2d17218f79665c0603a9f181091db1d188a478e866d2ccaf5222382b29e22ee70908bf5ead0187cb240bd4850e69969930499840613382e0fd39e81cb9fcd59a52c34ecbb6a4af0e594d1798ee3c7cd5f33d4ac139e39885b6553392519e053fc1bd67a0e885fe34aaa06f04f47f697881851117960b3d6dc13bc5a589c961d7d1708a2fb9ca507f6a06861136d3752a47678d7995a24b4ba37b01a59a1a80ac0428592a4fe580407e9456ebfd48c07a6c94efe4aa650e75d28c8e7c4fcbeac9570d290ac98a52d4f78fe7ce4b4b7dfd1c16668f929e7f4699e0f316df25c95f48109b4568b0ca5425611623354e75fa33c0c5c5f48ebed7668ce946b6dc3366a95f81d8cc32d071d8e31923013f2e9817deb83f597c74959597bd5f407402c97d95918be79da55d3038bb6e04b33d5109d55bffa8a505fe49613945b1b90beee71404fa3fb8f059434dd11a3dbdd78db916ff65a776513a3642b46baf40a156c9aaac6b549a0435a3b7ee03cd3884ae4c3a682a3a1f02e95479ec7a58e1d9ffcb228e6a58cbfc9e14a3c6c79f9131be9bee55dcebabfb651df51408a151aac15babd739500f6dbfadaf7c4729c557d684eb179408b4f98aa7487ce6b34acbf9634b331b901a80d5e45542c54d5e95a899e67c062b68d88e18ef6ee015972fce7e437d2c80bf3a83eb8dcbad176e36fba13f255b58d8045b20b93bda4bb92f3630811e5422deb1bc1b9199ba6a36d5583fbddf0b1d3393f83245a6069c7e065dffaafbd4ca313dda4c93bbbad9dde674f4add9e08c2097f84ece941f3697533acfca4062d6538d330eb1df0ab4feed42bad14c1f751f1a49474906c2ceb3d048a5bc70625e8df6e6316bc71e7a730146aeb3494c1f9593bbb7dfd3f38c9ca7b13e3026d9846bd7529dd1d7e6cdf97fd06b6fd6d05fa3b6e1a9dfdaf9476f37c5320d4b38796c3fd52fb913a73b29e940db3e6e8296b72766fb817fad21d4f183773e27cc56e856dc0f140de4e93b92ef02a99f798d652e33b9a287362205ec3d25d56d6bbb556678f0881deaa752f4af8e46e342df117712f05577ebfb29ebb59d4e6e762b0096e6757bb09ddb53b5896e95619d8092e1c5f1dbdb4b62979d7193486514b11141b30a0577a1ccb74506e3d1fbead610681c2d87edacb54b39ac8fe0ceffd08b2cc6993fa3085987c1c7d53aa1375b164275dca4fc0fc3eb887c1ade3c4b6119e9106bdc7f844db4d3387ba9186b9b52536fe0a67bf10b8baf8e64b29415b298093feb1c768d12589986a5e06b2c11df7c61d38ff49188e17f6605552c16ca28efefa72fb59d32113a7d92fb53824cd0bb2ca01bdd35c3ac762cbaca61cb71f6b318bbc3bda150a79587bc21c32b486518224199b3be08e6190624c2d15206ad0e8d8ee69509acdc8f6e254cc4140a6196b0b35b05b0d30bf54907a602d7c58a748acbee01ff30783ad65bb2f96f30ab535f1b8dd4ed98d19e91085c8407ae832b74f6f66e01d9ca6fde725504dbef659702b5dca4cf739e14c626881e51f2f38c1b1238a0b51b22cfa0d50e4b200c7e90f08d54d6b82b096a3058207cd928d06e6c215db2d2213990d5b98ef956a160696b3592da5e92f92d68c7f5d60a2ccc3516aeec2909fe7c6f96bc097359dd6b8e23bf897be5e3e5901e57d43cf03e25bd849c0360bd9fe92ea93f09877cd3bde34ee104232e0bc3aa71e3c7965f64ef53eb9589bb42a537219b71e9bd495cfb776704e3e143c179de36115fbf7db828d81d065efb366b05855da80c3897ae509c5beb6f24808d3089e8af22e22794458330be5409730c4ff2b2c631acece2a8a5b977fd9c9f7afa7c4b28844c32711627873790d6c217298ab52af3b550039e5d63dab6752ea705e3ff1234a945e54319d925ee46502e617cb75159445afd0c6b9969d4fb8b9b3b7c7aae3880b338b9395ee397a354dae647a8abe738615b5338d016d27a71c7d5a24cf80543a2f694aace37e17793165456dcfa6f9a96292b2a49e639d12be35721669ea4b97447e8bae13c837f6c53a1400daed2d524f120aeadf0d99be058956e89b92a69ab83c50d0c5fed6dd4f7ad4e3a721bd8c992460cee8586544319f66d36fc2b73c3d829a14527c93c609a4be09e3058ce8350cd426b648d6dbdbc493c590552acf130c0939f818d1ca261369ed4c85a59542f561cc99d9e4797690455afe590456d0d6e913de7474a27d76dc6e085f28b7712aa0187c9fc7fd508c9b9645d294f782a3265cf0d09639bf8b9f02e0ea553af413e8463827d64987e8d16c74faedb1c552280b8aba66815c3ab9a601397db9ef346b618049fc5494ce6a15b8ba62e295212662cffc4a2cc31101db5a53945e444a9da682d9b443080ca7236fd32dbb03de5f4e01ca896749e61fd0171cd7cb7e2da0c184b5a1ec3d6155fc0e55917d08f1d99070bff643d11482c48873a22d3e26ce92be2686d28136c22d36a9f2079e560ac52c3b9833b39af1c11ccc397694c141bb67e901a41c794de8ae2c8029f769c8b33e4b4238d450bda844cd358c7d914bd2cbadacb273b1b2f89748ed3fbfa5f07340d98e509cde269c458e3cd09d6674ec57659a1410c38c40f143dc594c8a48e95b7fbb391ad7cb8c22d7e759ed7330385cc75eb25ac311d2dd558d72c94112acfe343e09f586df082ccb88794ff92f9b02c1907ed83da4134ed70aee3a5080dd4b036c1c35bd47b825834384d91006825f1940cedbe812222f61adba527ea1bbdbe701b896e5e735401a9032b17e889f39a13998c5152a88329fd441a66306bd9c00a7b5c47da5e390727bc6f907a10d249e1957044d56a33c1ea0f44f23ebbfc0b50491037ae2a2b6693e560107a287f38b038d78bf817a33aec712d7fdc4b0404021d2b7926d9c9da50ecbba6ae4aa6ac7dfadb3d08e702fb8a8ea04d2ac8b9188d65731105820c94ca4b542f6a972d79f1611fb83dd1adb91080a360c1e40c536c95342b2fd82908dfa6b825c0c41a113387bd49c248c2a31c6788b3d3698eb1f9a6a18fc36a6a78fd4efe5e37505f777bf67a777458ab9be7d6f0891f3fbb37a2cf243638921bc53593e60abb0e993bf42ad7016ee9d048a282f958bff1c28b7682ac914a3fcf54e7f65a8d0a6fdc5e7e2bb0515a1eec1517a989ef9dcfd44df16d6bfcf13548311a1a7f512fda4e5201a8587ffa1ee6a106f2a0f97caa9198cc35e78cf1e060705517fea3b4e51dfa8ebf93d22900835589c01c4e71a60eb761eb3f942d0af1f5d718f72f2a2d31ee451eeaedb538e08b78aa95c4d60778aefb6617645b5eaee94613fab8962007237bdb0b537a28c62ef25a511c9c6cc7a30cbbddd698344030e26897ca0d97d2fa52345fbc7a1c5e103fa6f66222c2cfc6a3e1b8824eca42799d71df776ca96a3009fbfd37651a6a6afd1830b391e254f6bbc3da3d24113bdad437451cc5f8fd5ff4d2b455fe97c8c833f07a2a75babfc83e017151b2a5a1888bda529c3b55b8842052e3188eaba37756e9b25a0a3e784a5a062c0a3cef7e92665f18e3f556f84dc136e67112dc999895532bbd9c3772f46cab3cb65d97e24d6c523e20687352c9bc9d98f411b42a159ad3fdc833813e48b864ec067e73106ce36baf71d4153149798d7e18a8248febd34842b85a4ded6e65315c939d491b3f2ba597da6802e39796059ffc91e46a27add1cc9ffd31e14644bdb964dacb13d02ab97567ac04c76fff487d486d687c97098d93aa36fdd6d0b2602f38de3bdbf0b708577ca80c5713c5c2b1b1f0a8aa97e99d1da54bdeb5db0f753d730bc72cb581ee222227f0371920fe660f6d504511c0d8739187e4cf61f4a331cd44d6e4e73d0142d0eda58f4ff61a1907dfba4c926185d94e55e874ab92a6d164269b444007004e2b58568e45db74caffe8c9c081b9e4120bf1a6cb9e99ae7c1c1b28973ae16bb480218e31c28ecfa8675b7a500f292cfa137955c7e54026e6501112ff43e8ef533e92898b81bec2be5da31f0a9dbc098d9b8dc461316e2ac027c6d67a5694def00bb9a0dd585b600bd3d5b7bb9dfaa7af6367093fa294e75e9ce7f3ef60acbde7e408e7f13951ab89022c03a1255434683d91d1088d720a78f74eea397695ef7a85561922da9d0129f2462391e21c0ff1df08c61798bff9c2871ce81c742055224f94f7491d636ef7e146f82730890db7e5e02ec81febc972df3109a979e505d948799c9ed0c030d548f0aabffba7bc3559959d88232f0ff33e25d81d2343e0803c041193589e72c1fc3970b3fc4f51a2fbf7733152463bc5b07fe58e5edfc3a15a2a63b9545f5cfa1050c77e3a1150dd0229530ff5e8ca6aab4d17b29d2edaa98711934e1db3a626f01c306033f7953f5f678ac50287a40999cbc7dc488a3aa523f6bc70006ec4292b8423e343b1131002458818a68efd89fa2485e7c302829a62f3624ba3d2f51fa0668a5ac10aa64b0fc0a73dafba35945ce89de524472132d64fee1d75ebaaef67979d6e143e75465f258bfdfb9bb6eb2325a14d7a708b694ab9e5f1e628fa6f52f789d46b7f79271a419e4ba983ca73c7dc465e10e1bbb234ad88a0b025cbc0d9c772d7c499c013afcc8c980142db96466760231b9737f6bc18284e0fa8567139144467435e02fae06bca8bb940aab0b7d1ff7167c31b3bccfc762d3c4dd64aec33ed55faa0027c5b34a41a8fc79ae6a655cdd4b68d411354453f53760460dd0d6909d7051e7c6cf271d7b05623713504d2177232d2a600b99c9792079e259f9bd2e657524f9df192c62eb2bc3319e103516d3b4b51bc86726ff4ac6df4fe2eeb3adc10797a144b0e64542cd52ca8b5c0469f65b5a9cdef09d427de9363bed0c7cd297bb1bd94cd730dc0e99bc2f4a2f23d5c41f763a4bad4d84dbe35497bb6912ed4a38670e4e5173e654463dab19555906ccb4f2ad19232bd0fabbb7709a3d804ae6a98f51787bee7513e0a61af7c5d2c3785cce8a8bf58c8d06a6285b60540d9017f9b47c19d07c0dfbf49069aa0cc6130cb2b41b3906b1232a51c25c071dcd01fb8191ec015105e4097e8d4e4b9ba18d30f66f013c4a635acb4b1fdcc8a762caa203486a05ba55052652ddcc5752e6f9d5e3deb838e24f4d6557f84ac7aef709073b337e54c42ea0471a36a47fabc3d5ec96e9a1696bd5410d88d85d7591957692ac50903b612007515933a49fe68a1ee33ffe8e874d1afc1a4cab82e06463763a33f4eabb3470b4a990debc954ca24a6b68aad06ccc32d297b862df42a86cc321f19d88ed623188820c68fd29d9ec90b547e5fde8c1e3d11cbefb42ed14219fb09b6f26d5365d16d3df68a0ea3f1861f2075cd20150c1eca2d86cfc565f4f6dec7ffa369139cf45dc40acd0b14ed585bed6be3437234af37cab45417105f08e73a595cb63fd3d625f8abc5410c6c88a1a17aed4881f9f3b3dcab0e53ba19ee22f5e95d8556d7124a917db0cf91bb1e235d346666324c6e11987591c260a5504a3b968e313f7a80be001ff8679a5f3e1566e41d84d607f2dceee942b9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
