<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"14f54f6bee4f96bf6cf25ce9dceb0ca00737a81900d4e9b811261f17f7dd9a81212f7b108fe8a20a5830367ba7a8b23f140e7b5430eefc37dd490ec53c0099bca1240f02fdda883c2ce0aa2e3adfaf07c83d3c2ffaf4a168ea72f825c2666586e0ed296a4519d984c0110908418038d8589b88a8cdb117b8b7052bec47b9c94880c9c9e3ba03a544874da3f85104d71633e6bf78e66c44ecf96a6d211000c49a78d0fa0f0484c0445857a0b1543f3c78e737e16d7fcba3d9cfe6479d86bc695f66558f8faa293f643552df0961545c09636d623c43f3691e4da242e581d6ebedbd8deae09b09a99066accad284a970d85ca81314a8de9d7dd3b907275dffdb792471a319575c829e09d3eb4236db4d0d2cce62e91a38bb044742830e5baaf97be6db7f203531ff4aeb5685d5eaf4ffb31d4e11298cfed84b78d2a6daec3bd1fe160f77deaf715464d31d384a4207c906943b7a0e3f28bd6d5d427eeaf953bce03da1e2fc9636fec2f05d3f5ceda5d2b8a87d0c8ab277e4cb1869304b46022e347c08369c097a2385ef83a146a1cf7020d44e74b3598cf673877de85cdc23acdf5d3ca7914bf6460820ca4d18756a4225c5d5e05c1a787e406275e267c30a2f7469a22a03c8d7f750da5c33423aeef5fa812b3cbf0574f9dd0a8de69d608fbefb61f9a29e83002d071aecb6abc88b8e16ca77bcbc1600717539a68b7f665090d9ccbbb1b29b8770a1ede0400f76b0c7d4a0572723bbd936907e05798d7d3410ce5fd810a7393e9cf1b261bcaecfc29a3b4a25a7705a9ea37d3b4c309b9aa7911772b42302f35511fd2259d719f60527db49f9d57a769e79518ddbb1828746f3f478857a3ec1f6216ab865ea8c8d50d18ffa6c6797dba8da608bc78d9293dd4f4d3c3595910b553441539477be8280911646362659d6329a676aca03fc19675efc0db71f8ca9aa8e97e8521626282cf44c55433249cbe6cf3a66226ff7a46bd45c2b219545c9f63092b26aacea5a8b8f04d9a7f47ae90cc063df05b7eeab3efcf197302df73373a7e1bb230cdb6779c05e2e7c4d1a97c52f04f5fdd679aec0b85d259f7ed3fb961628d4ebdd90067c4e6ffc375a38657a2613d5dfb7a0038e627cd7343d7d205939be61265cf507896e3474eb1ab487656f44da010613396c60947ddf8b1d1487a72cbdcc314ebcdb7e1a126e82132dc7909df5db2a9fb6ba64454149fc68a2e85ea28c264ebfc625d73ec9927c0a28fab88626da7b6f39de42ddb7070c4f02be632651b6d2d8a996569496a797553fd455cc29bca2036a341ab68a62c41745f886da2ccd9ee62f28fd3da1d51fd6e90f9846bfafe6bf0403fa2601449e16bafcd30c3340b7b47cd7c0bd84d19653c3af74f76fc4c3ae804ce51da04a4a45925c9b0e9d697abdf34958268c0055ef51245290f70f05947725bbb783f14864b78c7a1e4fbfb6b40cef9904d0078e4a08c94686866118e3a160e92d98fdcb12d576af47bd6a8d8bb5a8e216ab293f5eabbb66315a8c9fe7d62f603308d1180e44a0c3c2c56c25a3434b1bbb4e4f646452e63b0c4c90110ddf0f6e39475b51528a48d56160a008e2b688ca527bd26bab14a50537bc2f6ebdaa7ad08905596fb2a71cb22d92abe2dc80657e6e67d51f595704d767b3cacc541548889a4603281bfdfd58fe18e1f85d5c172b10ffaeb40f5bc5a49d72333d8c33b00ef657633429e4d070d77aeb99e39dfb25f59f01b3edf0428b96fe65b67085071b6787a59cde7652ddc676cf4001a6c0a2f109234e3030fb1eb6b7954a899724be4d356d401e05aa3d2c7f8dae399e36c6d5b08491d9e70eb7f7ef1478423b8af8567f63c27d9a419e2e9978f798a83a1e9cb63000f6666a7bd949e4850ce2dce31850ddd54eefb4744284c2ad3cfaee82a4a92c7d3faab51a45daace08b73afa82bb8dde90d25f5810fb853f383acee0862e862c3dff500002c588b247645da551818f5f22def9f53f5821c41f1554d9319422c7faeed930d1c3e4471914a71f66b313322c96a2bfb61cbaf47253285a66a5e9087d313b0ad76c90959190e0a3447c50cbd32fdd15d87cdf624a19aebc07ff181fa5b85c76f18ae222435e8db371d490079a60c4429c19bd9322b499e40f6690459a79378b5dfc336afbdcc9ed7e4f43587b61485305d26af0adbc6f6aa61045c0bd58686439900d6ca6368c60f5e5092a6a9860111dce4de3c7d4a90482f8ba7174f106a0601c19bccd7b0b4b3d54d4ec59ee8d91dcbc3fd73a06f9b5546052ec3f0c86ced90c443301274448dea685b586a513f8db2a2f394cee886fc0a9fc34f3c9f68d5be16b1eb00a6e5974a9ce0cf583b3c9e64e430f3e2cf45c29ea6597191aa151d3573954d64f56073e23209cdd3ec04e2781c26a0ab6c829f9941f5f279860ba88b3308c0cdd5902fee2c64a517f1dff6be963bb7e21182638fc7f62cf5045c5521003b96a10a997c7a931e4d2e343d05fafddd8aa84e3796c515ebd9eb50ac2169942e1448e80afabe64decf2ded9088e9609381d543f4db805677ef895cb0e0418ef087847d584d268ff11910213eb1b9a0e8e3d5df48d9d698d381fb586aa7beebfe01d10677d721921538987c08e358d3b2966c6471279820f8e10bf9057ef28d31aeb6563db8bf1298f8c38c56fc1627a472bdb8498ffd6be845f5bfef7a94e4fe5730b03a7a84d47e44105355e610b5669d11eb1552ec953f5c4e3148211688dac06852d3b8ee9739326e935ceeffaad18dced33a11067701732914ac96333c394f5af76e3312a54ace8882be534ffa79b695c1335965dd2c5f6f8e6d8ba61a96dcd3f478c5c1c48801868cdd9056e4b12824986e15c1d15433b4eaf856f518e28ed41105b7104697b243622ed21532192db9f1a3dd4270ebd34c086058f34a8372a9c29d3d4c63f4d643002c2a41847fd831a0a7c72a35e14d22dae3d03ebf5973c8f3b6e0c7e01a4ea0bd83c923369e0bd0dfca73d67f2478286866ef6ae5652c69dc6312606e8abafb5b62d0c11802dace8a603d8b2cac3ae209c0e4cebdd4b8b24bad8e35a883d96706d536dd093850a86ccb5a7b064c620c894d877038338d3bdd74c4bffcbfe2628dd0dcbe746e0d0c0027d90195b8457d0e5a6837299d42a459b736fa781eb392729264eb90555531c656843f416a336ffe53424e908c5a3954b2b77d890ab040a2a82dd1ccb2206541bf3a1597cead26608976d80b411947cd48ac0dc9d1355caa57ffd553da793606fd5ca133e9edbc95799d62116721a14136239bc5e0ebc4f1f91e3b59f9fa5097cac30ae531c2dc4382899cc6261af5b5678940dfe8e40c1a483b4c305543d0d99c1692b5784d0c82942c07be7ec46801d20f34a4a2e13909052f1e125f0117843dd5b63b5932083bc7149d406ef14bc3e3885ca977ccc8f0c8324e84178554b94a7edd4c0adbcc7ad25dea92bbadda6029d0c1b9a885b18357c49e4115812d62d054ead9e5a286424719f18f92435451d473094f050647efbd5fe8d94f8639a685e22897c7d3a1674ecf731e8c8f36db36d8e5339bd0e3c566b5ab7166d1a629e214184fb9e4eff4d0c3317de84117e0831e091b70e3e0ff835e027309e56624af994cf3ab6dd0d56f4b92ed55fd6462b8ced145f543817c94d98b8cfe76b090064e2c2e70bb1302c2c86b2916fea17389c74e009a06c52e796bffbbfd6e009c2da626c022b614609e9c1957a95861f327a9ec6323ccac689d79776605e8c6bac02807c98e155d9745210e62e305297552be3090b15b0edfa00a7671f96bfd0cbfff3ec8b4668dcba70e9902f966f1e1810cc056455c13346c1ae7a0a4c5dc97cfdcdf36552ca1b966c4a303be3ce6a75cd5837bdd383865cdccc71edd9cefe61e72fa9248ed354e860f4548733224eff49f50b5cd6fb4bf103e7c340876ed885795e317cd9d266933f20a9cfdf08219721e242893abc64e81f4e5ce7d8e6bcfd379f6a17ced1d2fb5baf57bebfb22060ab9d680f3faada8304879384a9832678d9efaefb9ce6d9a3a92cdbfaafdf42742c042db3405db569e0437f29e7a2e7faccc016f9b6e5de2129676497a5d31d9d51daf0b3952448c7d2922c3a571ca49dbf4ac3024baf33c3b289dd2bae0e1bdb38d0b77bc6550a60df9445ffe7b44be42187a2d21df05e40c0847cf54f709330b2f93b4656940c2bffb3791511bc0b794ecaa826c08c7c7fa3a2a23b79845e3eee072461edb2f4bc9359fd123bd011c9fd45c480c5496208f859d4e8968c1652d64afa38924f5bfaeef025092d488c5f5afe9aa2066111aa6339a465ec8741bd80114a227cf1954a33a99bc7de8a7a546642c04d13298b85ce879d06f7ed3c6164ebae3031cc21e6ba1ab7ec44289b74b6f6a89d1a794b75e7d7aee9654be3ebf643c07eee97398def68c20cc4edc491f08029c611e9a842be5f947e9f294820e8904cb542ae2acc7ff0513e1c8760b93a5096a7804a371b2086f49413da8fd5370cbca22685b741621cab76b15749f4ccc4f81cb4657a5da6f0eb28190652b379f26007bf6dad660058185e0a44448d5d33229a65730b3dddf07baa79aaa3dd69a3d4ab4ae319db0817441a092fec0488fb681e5dc6605c4796d645727a5c423f6441130bebe03d14c539905e59ac5a75b6947997994c7c29064532442f2edea706d4b972c4120947c2073143e7171e6ba3e373ecef54422db237e0de0893f11b9b4d878cee83e88bb380bd09de2a3c61f3f1b97b5c38e162ca4c36f9f7c7574b18047b36f39d177c66cf5ddfbec5ef8b8681cacfa8f040607090e84bed798526dd3fd90fb88329d9f269c15771502ba6f07f912aa2f2a4df15c74afa2dd8b1b67ad04d90600429f45b29caec5302d7f8131fd44863c087b59ac41e81890772326c3288cfaad92a35f4f9cab7b6977dd778c7ffa8c8f8a034bf44c6aeca6c695a48fe9e7dc7e82be7baa32c5f9af6342b1d27d43285724ebd5f925da9cbfc00a27a2db6d3acc2099cdd6c4391cf334ff2083700a46a6137cad66aa2d29762838918c33c317cb405dafc8f0e0f58181032e2bb502e3eefcc946b98975a8f60741859c8733e3b6ba8fd1f662ca3871f73d18d23023551a7b186ac076680611f9ee1b053dd9412bb41f8cb0f6767d73c2df04e21e4a89a2a2dc5955cb84f2aae2f4b0d797c9cb7963bb1fe700753f8a8bb17cf1059fd0d63354b68423a6555b4851dada6c0b938c03e79c8bfbc4eb3a4bcff28c5b0d13274678a1360e5d826c90f8ab3368d2ddf71bcfeb0ac5fa70c465310e4decf093ddb54fb09fa70836bd6cf271d031e8fb8a4c1eacb656efdb10ef617f167e14bb4aeef1240c86b17a9f9ff9cd4534f347c97bbf464a817ac45b0e6f3a13abc4da34a809ab43b0b3496db1e4bb25a130e6657704cea03748d35014400c19a3a9d902d1ee6a6762a67498a5b9425e53077604632c4efeb5717f24d65e18b4a0a1a4002a1ba107ac00c09a96a25c0a881638111641cf33806392f962e3b5e2d6d5341988fd6436b5dd38206dcc9c7a216ed71dadce4379ccb8935763ac6c7844f07976bccf01d093442f54a30e14034ffb4659fe1333144134aa3c9317a8914626ba7350288c52dda380a4bfb0d5f8c629fde44100c41917b83eb9eee82bb72000c93fc8ba489b7e452cf0a1be74cb6bd3fa4586c7f6d481a871266705be5bcccf6bb9d0d0af246b17b8dfc5c184bdb144b244b4d10e02489900adb5fbb2018611aa5d11a349c56af6901562c92b9f65b276bae64c5071e54bd987eff03aefb8984d66338cbae1ffc58c6ad3fcbe8b54621a2a5989c64aa1ce149c3f76cca3bb9061b459d1d3aa2051f67d4c14988629121e91ccd44961e340e21ded5b2c634950964e9b21d8ab6c8b89409e589492f71534fda4838915dcbfd48f91398b9a5f1ac08c7ab27e2d21bc3c1aa2fa8329c9c71d5de3e14ea9b79bf7a815ae046d46ba871458ea53b8e72f52996f284f9146c42ef17e3e21fc35d1d5b9809a5cf296b7e2322f07efc34e6e4193c0f5fe45153b095e115f13818b846f927bee192cb565c85ac3320dfdec4557a1fa1e33c2aaecf5febf993afb45b7d62a57d98ee577ccd92945faae618bec67180365d23a2655bb81a69d184920c2b68b8fa796fe240918d61dde2278f2f6e630f6545252fff5fef2ff6bf3bdc75334bebe20f02f6c2d1bf8757c65980fefc989155483dba4c75dba9a5b55a9f1b2e79aea0604e25faf9f763d9ab0f8ecb7fdf90d6c32cd41a6dc50d0458f7503f849f56c8d8b8ba43017a8032a87bef113c47af6cfeb85673180a701b22ac93d229f428a73702588cc62295f13f593b7bb356936846f4e46269590e426d5d38bff940b0f9f940e765930ee49a82662dd5b29d228a449cd189027498ce1589b639b1fe15e054b9f15c36d01a62a843ddac52f8bb720ecaad76430b74527f3015a6c325e8b8bdda956ccd82f2cd33b4fb7e6a37213d226bd7f0e8afd9b1baf5879324c2783ef0ec81d119b9ac533fafde196b2d904717523c906355edb2e309dfeeae594fc784e57f43ffa37a3494e6075bbff8524a9d80a0aa0a97c1fc408b15434e2179ae9feac92a67e09e7c8cff7785ba67b543063bdbd7268973157b6548843f642a3108cdf8f85c987a8b6d66faad81b97e137c19d5b031416c94c6375f6fc69a3892368a1430b969897e170ee0a0d83c18e3456736f9100b6b7c5dcc227e2dcf80f3797bf6dca75f2c7649551094ea6556cb51435ca61d14ec81de5d1884434684be5074378e49248f84d13292bd3e6c9a152333f548ad3afbb4a64b6de7c73d37517b034d4575a38ad6527cefbf7c2a5d1d199b691b25918c47ed24874402172c478a6e262eb409faa7469e3d93a98754f480e195c0413aeb6cd59591b43c0aad9292eca5b0ef0b79b439ebfb82b0a704742d3ac390f696cf911caaf403e12357d73ad825fbbca495f704f2f4d2fdc2dd08a8fd133c9d8740f21b199e04a7cd7e002687f6c1d0de000c95d8f7e74fdffed9607b17c0f276c0d24a62608ca23c71fe2429b433e9a1f00260f16e7131ca3b936340697604d80e9de4db96ce603340a6310d2a73ba332187d324af3d7b6498ceb83e997a8c9d9af6e715f553dff664ac5eeda744579c74febc23ebff082f342f318c4b7c370494d7412fcffc2cbf01a1d30123b581e0beedcd4b3d8b268f95a0e0b6e6c47561feb5f42113b0b0c56a67adb04bc206562ba6ec3950b8ebd7e35c48bc6985e891f089fb0f941605ee3efc47e670098151a2122bb651cd3be87abde7e210b268c1d6d1d96be01754a54fff18e894e80e97cee3563f7493213afe52768c6af1ca3d2945b162ff45fe2747317928971aa75e1fe93e5ac61fe5ab81b34e3b34d5fd3603d92c2f7ba7537635c3058a9ee7af8271298b4580c372da36543c88da044bc04affab89985e08df22b0e7b350a460a1ff0f956ddc7606984094ed4a4ae94993ae5b1a0d81dd25b51099fd34b82856fad89ac2e26aa5ca4b9d0847b1ca7a65f9558583a06247cdd6c878ac0aeb9c967e9b0e9888f9ef3f6a2aad0d134bf7a76bc09b9489241d24b20fa9dd028ecbef13d205c0ae8764188b7cdc1a3202feaa051f5da48baad70ae3f98704340ff0907b36920d4faa525437f530c8ecf6a41db40e39ad9c570583281589f4a7195fdcfe4173acb3664780c277fbd6cb26002d5b4a2b49206380fa21bd094c9cb681d737061c96c969b5de495fa83f28185a009087c7750a03aa3086fa7fc9a42f375bbb728acdc75ee09972d8d47a3b50df703d7c59f23711059c06bb9dabada65863868185d355b57ab18fac6b01e30fdaf092cad94b7b91db07c48c0256cfc3bfaa90253cd2d96f3a4fd2528c2f768b65e24a7a098dfdbf74728d4e020406b3018312becda614e0ac6e9df543362989cb5519c161b3a8fa277ff7bbdac38c7023998124384069644506984075e1016f8f90eb8cab94b94a2dc7d8c0c415f4c360db0eee80f23d08f07fb0a66cc6775d794300441a5bb04620e84d907ea8875b00c64e05bf657f75ba446a6f6cdc247b05b27f5d82e827fcf2f46dc6f0de3749368e341190bedec1fb131ed29fb124c48046789738225955942d45872420938ae2f7d1b6a22d1f07270290df29c87b08fe220badf1e19f7a634586c72d75304534f2f157224c1d9759df0cf05263a47947cc0bb8432804594f419bea82da7dd2d448edffc9bba23af4733cfa0af8e6b6c720df58f2952a98175dfc793008fa78fe8b0be288eb4b8fcc92dec4f2365a018837192323f65f4719cf8dd69adbdc1a4adffa17fd8d60bd60323e89db6cf958bd4a440f6d2c43aeef6d5f8022b4fa1cdfa8842fc5212fc57e801ee096c95ac89978bdd92750db55a32c4eb8e3ceb47ca229af7745b98b1071bef6a560ef0c2ad19413c9473eb7a158b5158073b96d7754c842986304a5c384818428458143685de1d0455c08d607d94d66f01015f5a4ef0edf2de0cebdfe63c311add391c64d28866b4335f0d7200f178df96562c2bc2c9763148d8dd895634807e2c1810cd697909954ea975ab3022c26c857f166058f6c7e526256f1c36722f2e30ddf13093d01bc45f67101705dfefa28e4182a25c5afdde5432bc2f98ca6c52b85c46889f13c67342bb38f108cd079ac390dfb33a8117c0dbcb337983d6be10c9261185e6242ced6c152b732df539554b80bd108738443d7cb9b215082563c6f8058810bb120194db1f41bc7cc67ffd32d5ac14832e14f34648aded80bf0f92176fa2cd74747f8782085a1eb43aa54f3f9b4e2cdbcb9f4950638066a684a7d402499c587cbd27a24cfd63727105a679ac1ef577fad9e856501022aa3b6a6774aec294dd913a0d19dc593d221e114dba3cc71d75fdecfd67b490f5c6ef61fcaf2c73266cf8a927ef972e57c5048b3d135ba9646cd8b0ae3f9b31a23878225c32db80ed7db925e26ce26c105d2498bdc5cbc3cb13b6e9d36dc4f1b2b27f5a0775dd433277ca062360f16ff85478af9f8eaf383153a1bd27d27b0fb0bde10cade075f45f4271aa4e83c27157e4ac2a5e9d6477b87e150625df0c7208d554e91e59f0ac711a93bf366698dac433eed75c6c76d5797be0eb16ff9e6c685aca92167abb285955b78e5f34ee775f1c28ea2be2068e2e5cd1fb12eb9d0b81be0cc118b6c246b70bcafabef606845c2c74d25bbc9c68203c2ae2c34429024ebf97a1915a4e6431d4cf8f07e5902acdfbd528a1b6754881b36592805c900be4edff6c68ef6e9085adfc8beaaaa16f75e406ef35df61defc225a05abf37169dd7bca71404abcf92a4b05c4f58f33a59e03f33f91abc0a97585be6f62365f2d8a4f6b19020b541785e86d13eb8f5057c995ce375250160b83b8e12098d9e4c9a85963d1412d2e75f2b16334f62d0ae6572432133a80f7f61166f0acc3c80bc91948d45a2c9ed543e0956a394b83aa3604ef3f20f59932344f27bf4005177352d8c0bb458afe434e199b9c8f83b49daf974856a73a776a0100df835b26db0c0ac1fc6ae8f22df9091e297c4207de33c036f03ba4013ec82e0eae116489287fd5312d8547de1685455793f15bc46d0f24a096a6a511fb649c95a815f19db07dea914e02048c93f00ad77a30eb3b289fcfcaefb645a6e21c52137cd9c3a91f4e1697bc6d03b8779f34bbcb1ce024c966dd09a05bc15f18dd13d6eb08d8b95c2e6f73e009e97b96e626dc84963b96081b999de51c2d98e184597ff3fb476fc2f9ef4e8893ca0c6911ddafd9f1508bcbd00a72d6acf174267fb8196686eb933af71d566508b999546521c86f776c664e8eab79e5c2879c8410e4482a9cdad32c3965606ea93432b4e2cf20eb2cd83b4c3dd2e3a82e52015b51cc000881e7395ef6f6da908d8225cfc63f6ff4d99ca6f840b4182af1c352f8bf9b786bc0eb399993231a74eb03667263f8906b7cc25eb2a673a6f304c07ccbd8fea448b5665115fd0547a4b4d2414fd415b4ad21df87b983a3a51bc327e87362d325d1d58307efd3a8b3fa9b44610e17833dbb215fed937b12726825cdcbe87a269aef47388d44a80fe2bbe4958a539a19b20d59b4dfe23d3ed4f44d5c4bde52061ac2192db8a4983dfb9fcacbaa761cde5dafa5ffd722177f4e628581c037e3a86454d5e9adcac81135965e484f612a23083464be7872538f9904bc25e98b50ddd3fab2e61025c6ba9d51aad81324064d718f4de524c8682f3f70369f657f01e5cdfb8fe67bd5d4ac25d6580d98814d0bf3cbaad8c34b796cda5ee7dc202d8d0136ca07f5280abc05aa693c1bab3515ff6bae2b332c4c72cb89de7c067a0b890b76fee6e7a03db270a221a8cf0b192b73e9e7e26cfc0fc76537fcbe2d24b62ea9a345c2a9ff0ee7c1c628b345539585fe781184b720fa00dc70ea09766d27014a69b777c363d115f422622189f58c11d0916a3600fb0d7675fb20f3695a2633cd37ee970f987ed7b04998bd96d8ba9bb9fce07883817445c03734833c2295bafb79691aa64d0aad3a12b104c58dbf30772e753e66803cf7ffc30be6a0474a6171b04ef7cb3b15c1ddc81056f2781874ee471e4b7ab6a623267dd3a277d50a59d55a80cf77442c0293036b7166ebb744b5afa3b6187d72522392e833005af3c664394afdae118c1892955ca19ee9290a2ca5847a2434eec0d24f988e53db49cb47832dd9a377ebc69dbe78141267a0a9e1d394b70d6acf162c9e29d714768b50ad7ce77d7bf0f3417c498ffef955ba29b5cf496bfaa2af90fa4db255dafd3c864d7246e8f5e0f0d3694d8c450b2eb5fd006d96139c9dddd9f28a33fdc7487489d990b576fc62ff1b8f7ad4e1790594b3cd32f4b3453f48b63525ba92df42be5a20b2d218299345b19f2a33068c88adc891c83ca46553bf8363bffc22bcc1e4ae6175d68bdaf648888ed5c102156355ae4a4f7e75ebd62261695378fc34d5013e792758f640dbcf1a86b29b63f314789683397467010fa829a262acc4c5e17185c3aadefcdd69b251ba99776557ae0b4cfe800caf2460719ef559377a60c060c27c43011e2e193f88c0c59a12b20de25abe58b039f7c9dbb904370c52462e9bdf57e728b8786757367e530037ae534b5be1bc7ab7f728d495304e19bec5e4290c7816adfb0237b13ff40e87e272c77b2541b536f7ff66a062ae3968f2f9ada4515f3ba25e6ec4230b831e88b804bcdeba1843a92980ee7f46b15f71695828062e2044cd7c91577d7734f36a84a11745caccd0661b6b7982bd84ff3f445eea7dd15ef22860b7a6a4c70f41ed376d38d07ffe7d10d63528ca7fe7e715fb21f05063aaee3ca501460e34e20435dfeac7c776de3aad70b524b7ad6540db8db744211bc21fea8f93875a5704063c82c99511f3bf2b4f72fea6eb158dda52b7507254e43f603adecb90983102105e4bfca406b141f5f8c7b3728e7619b744981213684b29728eb77bd22fb376d1b7bcf091ac2d3d0ec8a7881bf7b8b6f335ea3c8f70503974c1903eda974506e565597b2f6548e83d0abdab02c756d251fbc6509e5925768f54e26eb1f27f85cd76f8f8d76302788fa5362f90cc05f4bb96c6335f1518d33e000c1c6f806168edbeb15663c5100a28f748e74e0714585b4248f5c0b960132d433b9117693d5df3e8e8ab7aaf5dcee8debaa0cffb702c08948f6211e1b085fa5e7d23ea82dd0e86ae384aaa2629ee7108c9d3bbcd6f1c944bdfda4f05e9444eabc940ee1b466e44b2279f1c478f8975d6f8bcd0aecaa6e10a75fd217f3b348f16db29835aca86730bb26fbedbbfc29b7819e84ff7af92a6991ce113794032a0e874d0b7b8a9a6cdb8e895dd6c52d53ce0b7ada33dc7d6374a6ddeab8177515436afd5e22b1b1b6156f3fdfae86c47534d2af7b1c536378d5443478f61b0ca1f4ad288f32ac86db209735ca503fbc9b161c2d2bcd9080153651224a926197035949f41e1378e6e62c45e68e33e77970d8f505a7d8c60d776c2be1dd155b2864ac716ac60362df72517e8ebeb51665d32321f276a102dd6fa5c36c6e30dda41546b60277814192f0a8e43c218141b04984cd8d315aa080826d68f8649f872d6938911c3fd3d73ff1fc39f8bc736f79d8038fb076974d18776904d715e61f9a2abfb3cdbc133fbfa3ef629342073f67373b090325bc0436c0760d260a655de7f062718e168b2a957ec228b536ae2861ba15ff6b9bc8f1265fd58a477a2e37b099743a85608c40c6401fca1dd370af5bbfcad771e99ef9b583b1b78d752001934a3e5ab00ccfb0d6ae3f12a525fc68dee978716790b19389da94d83ab4039793de7ce76c013005318ee6df2e991b9b8c66c13fb4f4611c8498ab6d3a1fac16b72e49b63b38d36a44e6f31067e9f37576a672261e898fc60c344960a0ac337b9ae3f5e682fc9b6da618060e4bfe6c3b6864d1258d3f078ae7dedaf409ce16bf6f34acfe3f4a85988126ab7998bca46cb023429676bd3ffafb1b86b27b05e92147b80139ed336d23361df7370ead24bfa252423ce2fcd83502fc6025ecf531346734af098f0dd152b81e58bb9db49a90057f0bc2d42d7a6073dfe812413175b1a4fc70e2d992ceb0061e69f7e685c377d2a5e1589d7cdfb5df49817e1da33d34010bfbe309ed98ba27eb42444f2d77ec3dc6ba6beaae10a2021d4fc165cfc3f0de364e62ab3a1eb727839b47b2e1a1694bf526e761b4805030f57133adcfb98921b75af165d82fa99aee4bac6b1b651280c0ed532d4d9891521ad6a91b2b21315f11c064995f5772bced7fff54c8ce743435b77123a9ebd6e1afd4230050f5ae0550207ef4bdd1b65100207b36aac8a0e4d5df8958da4e8dfab27b55d3216cba5b41406ef9beaff997b2db7c0aab5cec02469b800349b939e7ad859b84467542edf06bff9bc62205e6f8d726264cc122754dbb275a71f11425d325bcf44f5f32940c0f41d47b20f9e90e62c0c9976e6789d860f56c99c51402953fc9fa0a1018fc83ca95281e9437b419352290b4f4b1046dfda7e678ad05ae4ff14442f292781f55f1ab8086b639d1d55e04bd3aaa37871bb89b2009b6df0f9d8686452f296f54110851a2b0c052c08ac174b9ae8cfc5d47b5502f2c1dd6c85281a7b38f95ed84c75c454e26c15725cfd0d81d7f47c805e27804ffc081df3eee2233707c5fc38d1898011a24c8321d8ab265e3db3deb27c929c234d3fcc46ecdf247e716b849e0582952b367559eb9fc60c20eaa3a5885a3e2830315973a071549d3814b96ab443d8366d12b0a3cce10087bcdb0c0efba53b55b187644220a3abf2bd81807669376ca7ab05aebb340feb5c2b0792eb18087c8d612575300fd5bd49f7ac568d8cb3a7442fe5de43323257c913f37a1e5c2f8651511e569b973315573d579451176def7232d1fc1fae3cd3fcb44d40e59ba344669ac86b318e9ce5b1b40908af62352f16e1a0181a2761474ce9b0c34347b9a39184aafe9ca5c42408f31803533f00da9a8cacbc11ce74af06e9d0cf7097200e6904feac7a5968076b36387116395c8b4891199ddb948d6687487f68b282fde6577d6d229afe7d272ae491e515ef7214f53bd69ef9e2714568a81d3bb825d752cab115f3829a053bdf2477c84588fd50b2ff5d4cb995a3df0c84cfde870e4c59f8bb764c0c895c0e93834d0af48f925b0bcdcced1cbf2805291b84433a217ecb719ec8fe408adbc55e11b47f7c852ecebb15c9a280422b62b9f3eb168bc49d0e4313115cd68c9c0299d357aae5a86c1f653d065136e1aef28d54eea29d793ba3d21f8624c76f93d0ddcb3816c11929aab4144348c8e6ae1638646cabc85b061c1b0360a66295ee088a6b31cfb8b3ecf6ff1338a5e264d592b99c7b43739c21dfc427b77f20886d0bac7c136106cbc7235cc8c169eb2b93b1738a152f8fe07b79238034d93c114000fac1299936a762a6ae2930b8de5c01712e112ed8a226f8c4391ab7ca2567c530cc2c983198a54c87d1d65f09c0a23ee7d529bf203ec89d2538640af84162c8d35f41b79d0e139d842e6609593abf7cdd866abc395fa703b9d80f7c716443fcee0d108cfa47896fd5452527640f615eb053413d998a7e1bf55b05cb2b01d8939635daa3ae2723bd2994e6161b3793e6f0233fb8b08ab2fdfb6b85d6a04583479d780d5b30c32df0d09a166451db87e36be7eb5f3ad09c0ecc72ee0104d5e91ab804259e36572dfde7ca8dfe39e81d75cc5f094deafaab541208c14e391da84721e5726f06b41c5604d9a1a8439956322f932ee8cca6fd3b3a9e44af28c1a7242e19b4405c2a38076bfa959bdc131bee3d8051c9d45b637d78babe5be9b57fab292ce9519e78406f4671200c645be3b5277081e8beaf1a65ae89bbdf795f200d1161d7bd6edbc419888da85d83be96b81defe5bddb70e31eea14ca44ac295e50ff420f24c4edfb74cabe25ccba62c77b965d995a1a4e05bf364683d12fdcf20fe81146461ce966376f1bb3dfc4d10c354caebc77c0baf29bf8b2d098a7b5cd84c471f41c49604260d1978cd1f568821f058a5bc9df6c6a54c99cfdd784aa88abd28576ac494e5313072bef6d9ef5838b738c02d0f6b2750127431fad3fc70cae23913aae62ab5ca64a6029e506c3fc34da5c0915329c2e59181172f496f394bb0ad4590fc70b7dca99f7ab4e1fef7ffcca7bb1d97222ed9a878e797fc6244f96c5fb7785a49994d614ca6a9e28eae843e0f0d59187cdd990078dda485f17001c56c843b7bd6ecc2ab29323b0963328d03a803340c8f28b03d7fe7ad3ea456440e56bf2e3d31c0c971eedee41e9e4d016112746902299eef6d7ef41a751f5c2e226bce7d764f644977f1c0ef4e026df117348db1ca9361cffd449029464a119d83815a634fbe436a2243b0c1a677a4f109926609e28cd4041259c78c9322f0d67c171b8b5c9fd093c41df01077df3a61402c5fd6fb68d0b07461603f0be4bf9718d19a14fe1891a0128723bc6de6e47edbc2d3ace0ebf9fc768c329d0743943ff39f806c834a1766a9a126ce9bf3b2e2279d15c62a6e45c8f158c79ac48835deec534fefd4a305f2fa18f7e2b0741b6366ba4fa283b2f19806ea21574f9606259a53e37dee5e67010ac8a53bfb52df871b1905afc21650a4cfc184319c3f738179b1c19e94621d091e21ff302104be53a656b5e91baeeb2db8db1b6afb52d5a3d08034b441c4d450ae80522a306e179c00a350758d33fc4e11b90c60e1a5eb9579ba00367f9fbf45e7ac585e4bea5378ef558101f2ecbfa9a7302b46484cb8ce5be92f486f02a45f62e79b3178090168d7ee1f34fa0daab1f2dffdccabc88904b1c6118b99965c0a5e6fb0fa85b15c6b5f24834ea624bd8d9e335abd329a2956a05ff970670b6880d8097abd49eb51232486adcfb231f1c9a63894f9cd164cdc72690db17addd9931c8e3cc79c2344686f557f8cfe9e740ea767747bc50f911c4523993375852ea09b972a438ee7d58aabfc8292df86ebcff2bf8e9a45c2511abf385837c407dedc5a4603ec5596e12e164557aebebb4251af581eba4ce30825281bb18439063bb8e02c646396c8e6ebac0ffcf0be84e8f7011a6848115da6ef7907ca8ee395734a16e8ffc18e544f03a6fd39bc4419ef26d47ee3b6cf055a8f02d1d812cef519ff103a64404b006a7065929e0ebd2ad619fa2134730716fe42f0a199ea335aa21f46d3862c8f315513c0a82bd8915f14edffc7e64f46603beec2e72f2699f1c99917b158cfd61097ca0fa7e620cd6bb20bfe8c8d637c99c6a143b054f212078e16bd480dd1ee0c72260b793ac46be825a972a9810b501cf7cc30b285f830722d0adea6091cf8ce4352600c9d7f3a528b3d14c9015f603e8d7f248782037ef20e38d9559e3480a9f900ae459e05ab69b70cae3fa685115bfc2f0b822151af8e13139392e2f12a94f7410704a4d437baad4406a30de565ba4d5b7aa24d19f6e252beae52027af6cb564666640c17bdce81c27885ab9bae0466f9c849bdd8b8dcd5e8f155641ba4f50ab1f8715a7787567dad52e3c00c965adcc9dd9fe16191d718d880afa1c2d9a4039f39ca30edfee4b5baef9e1f5f3c2ed789490496671ab0edbe907f0cf2b7c4276d380a1ea2c07d37744db33","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
