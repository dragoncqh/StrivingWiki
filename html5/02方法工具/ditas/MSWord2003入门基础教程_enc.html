<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9494488b5e8a615394571e7b376236951571e3260cb90eb59655415c8cd6c23c0a9f30841f695458134324201e6bfdb51748c459c9253d7c4d51aa18db0bccf34c60633d7708b37b93a3a324c01598606e38f1825197617341f517e815958fd9a721a004feb31510199d368c6ccd0db4ce4b9f4c0162531039cc4b6a7ac34c801a5b2babdbeacc165aecdfb8a307ea6ccddc4d524243760d23e4ebd441a13e025be098706cf349fbdf8059e04a54f63724f1d06e9bfaf48aa7d73d22ca31279892c2245e3ba03754a6a31be73f95b432de26f37e83ec0370c94528b46980a49f68667e1bbc3528b89bd82e670009ac24471176d56401e3c0658c3fb8fb88988d36b86a2620a4b491ec63458a902e85fa09f7508c8e3f63b3ab1b5f3059c58ba7538f9dbb5e2c02de49c9a99d47a55a88ba5095d7ce1b475f7a2bd4108efc736a7ec3aab09b6d98a9e7bab9bad523f2a2b17f3641422d8a4b27524952bf1e11685aaa474b747ba0a224e756c4b670f974fcdf0db303f17a033ffc74b8fca359e09b85c9812266b3f6a2165242cec835d33a97bb64ff5cc8e02799163b89b7e8592a8b3acc946794590d80e2ea5a41d619ad2b0c92822c63d4c66f6749ffbd65b2d3ff78869888c1a0baab6b86538bec0abbdc121e04d20e5bd96879b2765637e8b55c9aec15e7291481934ec50e4dc448fbe924b83c53f8d05d41d2100cd734b0a926b69bac2b52dd721e54ac33b9e312cafe5563cd2044e1694d7b8e1f5f29562262a6eef8fe3bcc7e91cca11d97fb4528228c53b63891a02b51ed20a70a94196f5eef67eab769f7c53fd667a592a962188e0af364a9de6e8dcabd5b69da4b188adc963253fa390581a2d75842a20d364630db3776d2374b8a6077e97d9fc892f782c821e80904994be1b5e84362292d963af54fcde0d7c3654bbb5a3a02656dd615932ff6e8b652fa69d6575517654bd7a0a36062755527c5ca09cef552c0c895149bda4231ea0ac9eaf834acda69480b3b7dbcc9a14c19f717736b2c96d9829b423e084957584608e664c82ad7cd1ddd40efae5e3aa9a07ad902a4ff2585db610e5059fc8649361f474e5390498b05396cf6886759ab101d85d4070564fbd0bdb295b56369b0884d5e4807017752305d34c7bac3933148053347243a71372647af42efbed46d9917534bf200ddf2544556c3605e957f350d90a4b99f09213e1a02eece4ee2b13cd2429993e4f0c1258f78e57d9c0c5b51def287f5189df2157e3cc1c1aaa1c6f3c6425e1c21c62901d820784fa1232d414d8cd8dae1cf0c1f2cf3998472e17163d0b3dd8eb7cf4361adb2abbfa6f4ac96cfeac834c25076ebc328cfb4297e8d5b0ebb2858b8c4774113463ad7a662af47f2ce3376e6eef8259d26028bb5ed32d1e7d759d6825081bfb54b839dd620b45c5de6d63740b1cd72f3c02f40a2d77be2128cf975e844cbfd9ad8818b4f71523dcfbc05319b676bd740c9ee28f2edb6c78e3e8a7f8febef4053a1fcf01dd502bd76ab14beedc021459823745cf8ffb5f84523c41376d79153b188ebeb7d9945dbb26e64c1d617dcd8aba2c004c7ba586accf170db641ac1edbd65249cd360323974e44ab42d3c98e5844c34258a4bf683a0dfe39cfea795a5e387130e34624b77cee6e342ecb8c29cc8161924b06e1827fc7b9a090c13b9d15eb2b2ef22c76a21db659f411dbf15db32bf3fde9bffe9098c09cf774f8d98514db4425f8f5cddee1f2c220a2704b8451bb2833dea1dd08ade0556a3d862fc285c854a489486059ad7133455508f726ac481c08a0e8913e4ac6ffe07d60aadf572bc9e71db3220dc10a454d9ea538e50628e50d13e47905f95004fdb5625f7f7f65a58c4b63aa0131e909ecc2928032738dd6d0a9428d1d3801e4cfcac9786543b227ae841b8257cc6925cad0b22d0c7a8d3727505dbe6e191ddf1dcc6340c9f665c9838ffcbe0c98527de421b122c65cab0514c2637c2e1b9201543c390e26b603840e036f8262238ada9809e1d6008e69985aaf4de6b6ff551dae9c1f3f8f07870aca545cc4d024a2ce5f8b24f4789ce7f69d7021e00a23c008cebf668611b2a1557f3d803f3b40ad7be35a546c0c3b463f87b791b2fee9cdd95c1940f4258b8967e4ac57909e17dc93d34ae66c8a94c4909ab5ce7f5ba45172c7f16c19e27ad80810de4aa1b3f2595fcc5176fe0d7ecadc7be6759b3791b1570f92e0f2d3ff58ba1a7c0dcf71733c73733e1b93958098f2de91cc0993812cd78ab8eba3b31f78a39dde8c0670aed2ff54e50822d9dda5bf7765d953408f0fc59e939a27a0b5059a4e2eda9d3bf15a6c38071df9b09364e44d1362518d0ab052defba0fef9dd2e348c951f4e18b8e94fb458814948be5dcee362ecd7e1b790ed4c9abe778c7c233632bfbb1f1e884ecb19c408b32403c2484e8c7286bc9ae7550bb2e76b0c002f6a67bb349b8cae1565c386d39d3e5c54ef85fe1125da209f591788453db8cec0f51195f58cd284de2346f6d22f53bbd957b3892d719189b72e647dca329f204bc4cdd4cb2920fdc1c9c56ecf7f667ed4a9bc11e4965a5a9e32054dd34abe891436ab7f7b47749d59a36aa93c098bb379aa53a22fac20e6484d7874b8404fe202d18aaa505af9e08633a27523199018b515c7f6f710bcdd8bac9a500db11557faa0ded3845ea90ac4f1873943e0cad4507be9f9c825987438cdcff943ffca65990abdf8158e8fdc42ac8d063a409cf70ad4e703f1935c966eb92ecc04877c0ca51a0b700ce1a1489a50b4f1a8e3eeb3f8055df01e1ca3a6c55b1096ed2b3231f2998be03f2e127962909b1b0a84a2b7cfa5b5802a30872f9e98f830f7f57c5859cde3d7d4d2ab5b442acfa20f1954bccda1c0ccfd49d3fc3a3189d42ebde1a529e9bc3e310b9ef526b02bd1f787e8aa941d22c39c7b4f426d446cd91f228b53b34f911c2c008c0d33c645dd07c2b503520a20c2ec20ab6e63de3fc264a9ee3f611ff43ad14611e6ac4866ee5a7bd1482584b102ae09a5df684cce68351c2498b052f13265d264845aed01c8d311c27e8705cdba8345a849639a980ed351a28d52517476db49938b4f2e2ed27a204374f58b2aa910d846f2bf2fbd84a52855e76848dace4e8e67265fe4d25854a92fbe6af38e2f75baebed7b1a9a16d1ff55858873726c5fc6e704d21041c45d2a655c544249b3c2028db7e434d5364515db6eeac9da40c504940cb592b13ee918e59162118cf90ac8f6e210f4398ee7c125dcd3f8620d2afae92ba5a067ba09162cec2844ee433fabf6c953773c0eefead0776449e6e4ed443ee98ca38cf89e896bf42d4ef2c7865ae6bb06bcf6e5d1b88a8a13a559413fbc20ad0ab611dea4059730a1c0c71047cf28cf51ef140829359f4eabd051a07f3be851d0ddff20083f321e483b3f4a7e5aacaeab53dab1ce7d77846bf728f10a4c5c870e42b54678b0495a5638a63fed65c99ca5ef474706309a283bacf0825da081be34507804934d8b2eef6b446a69614db8a38e2e1dd4bd52fd7521414a2fb493dbef854710627d65dd62eb49b1ae07d7ab5b3fd6cf83d13863d5a21f515f2dedc6ee477c36723545ef07bda5d7db8f033b9685a22291e4b7833b363a52b886b94755b9a565588bdf731a9e24b788bd2301e0dfd9f720db03f728cc0bdf6b35a00fc61d4266f004b2c3b106d5e67c366772c9ed244cae06a4fe58be7b290f2ad0c285f2d8f04d33733626569c65ef0a18cc027b917c6320658bfabe9f7825ced403718731763e7a6540c1cc967d512c8db4f3d6cabdadebe24eb0f21c05f3e5187728043868bdaf8b5cf7a272e9f26f143220b94dd06de4d2e97da5ea62fa124669148ac5c74a120620a8d19f169ccb015f59c4d9c34ba22387f96ab7d305514d078e03deb5be5461d7e7462c944ece1c147c05980539413bba3cabfb3b38e74e9c4ccb58a038c787e3c03080f69a2ed6f8742a4ecb7e14e61c45fb795e7ed312c5acb7f6f98ad2bf5b9a3a800271429b7817393f8a957cff1df3378e5336737404aebaa3cf23bd71db9baf5d5cb0f8f4b7a439f06ca45975149632086293dbdd86b912ad8588cc95d176e14b5ddae4d46f5e2a41745f7e600c00ba27191819e7b22e24ca20ab4a6b46b1b95f2de499109c4a566f3e64781db593b07f30909f8cf9795159a44f79d70727cbee3a7cc712342dc94bf9103db1ae1eea830efe362bef8a005a975cea452bbe5741a320e6d3da824e15de9c8e78d7656ac610231e87788ac899b54a251a811a7910946a881b393bda337d628d6bad515159411b67705e51bfd4b4220261ec5149143007010d4cdca53845278847a8416c263d6a443b746b47a4ed1174f988963a869d5e51e349aebda88018aee819f67d8ebf4d7ea02e969185490fadd73c0d6b4cb1b6db4ea5e1db588b137da8b44afdc636e465169112f781087f409df02afb04c91123e8a5db60cf68a2b1cc36ecc68b36fa9f82860fcfa15ecea3035690344ddaf89883572f3c39d580ce538eb14ad8cb9d3a1d53b0dea676e5b0468105390e14dc3faf38ce8888a9467ef9c6e04eaeceef49ef1658c687a057739486d8bce0e3d529d7db2a1a291aab358373997641cbfc2ed2bc38414b64f8efb75eb49b3c18f1443308035344112159a7fc16bcaa17953a17fd3d1cf35f20d19747906be5241e7790ab0f845220913e2bfcf796a2fe8d70f7cb7abee11fbe074aaffa1db6a1f8f53581e4e623dcab376f6b178748058ecc99bfdaf25d5269d434998baaae39903d89e29a15950fd7f7b8a54667d1c76d7af113f2ef1de450259cdef0ee6dcda24ddcbd23e1ad70cd5c0d5647c3ad078ce08eab612c2e63b9a8038e175fc127f4ea4d69ac8830d82fefa919ebcc9b8bf2dbf2cb9b18f94d9d4b9d64940989d37e8407bcb606eb6716f0b860aff4ab9f6cc0029edff32c9ca7b474f3a9f0e846ec7777a2e0a140ddf04ce8307f7f12c3d013636f0d07cf605e4e6e2c705b6cc59c90a3d19e981eabd50aa49a694928f15b1617635bfb75211f440d4c942633b5c85c63b9476ea11af20ce1324128149d52d005f27bdbc30d4aa8777a1e42209f29a2f29c2e85810fd95832ed8f6f981fe54979ee80940c325407733b0e062abc816ce720290a92b9869f6328aebdcdf2d98237b342bbd8d2af21b0b4a3b2131fa9bbe9c0f1beb5982fcb5f7f6263797790b5a62d12e0b234e34e848181c9ece8e6cf0e5318fcd2227ee7ce1366beb97e37e3bdcc1002b0755a08effc9115ec46d24922e94e8e9a6542b72350556f5e38b3f8762eb9d54b321261f12e3c9fbe54bbd82efc488fdbc7c9c4a508e14e20c13d09261b9a98f2fa6ec3bf9bd8ac98252396750fb62c8ce023dac129c5becd2f34b953d6330540b0ffd4e81e8460d88c38ac64a91419a686b7529a7bfbaf7462bda93fc96ef4b157b602e30dd5da49e750b68ca7124f3199cdd82ead4dd63e43606772d306826ba883fc72acb553a7a725cd0589c404abf17959da11e3c769314e6192a2ba65a6aafcf7e90c1ad1f5529a014acf52635ad4a45ac9ca7cf6f9963b04a482eaad607d20169b4cb7c7c6091e5d98d662acddf816eda6b6cdc2ff4cd16d999109e02f0e59b3ae35578797609096dfa4709c9ea0ef6f5c4de283211e0c769fa6591d6490f1912b8af0ecbfc975071a97485505176cbf8bb0d8cccffecc3724663b39ea4d0eee0aee717f83cb3825488fff5a24524993e2def94240a98b7fd861c90fd0ea46759d58c7f1b9a58078650cdb6680e5f8027fee7ea507fe1d664fe17e7dd3fc9501520ceb36c3775b36e79b6cf1873a193a723bb17f1040742cb3fd971d7292e6fe014e69f29455c4bfdba6b31724913e6dc2a5eae6a2f17293259d9b8cf1f00facb5480608e91525a0c669e93ebf421da9d1d460589543eb4109fcbd5b6146afff47f2727606ffef547c92853bfc1a152e9566c3a06e167b1366e1ad9dbb1707c453ea2a9dfd54dd5fbc2dafc2706aec5f1b4f1283ffd47447791c00578e8b0c935b0cc44d6baa22bcbd4cb6cb56d857537a7177695be3507152292a63c7f24f58aaa2c47bd5591eb3d8c5712ad9ab24825a584cd36814968d3b9eb28fa1e154511bf7a8644983b5aa56bb3305bc41c94562acaaf9822e8605a4c57e0ca30bad6e8685dce7df4d6639a64fc1c1600472440f7d87c69a1c8dfbcb188fb344e864b9dacb280028d1d006fe6476e0e34d92aa688de0b506fab7a4fc0a79724d43ed5ca551e6b96777a24f3a458500e351dc80fe30723dfb15bd9a9510adf9f2ea78ec47db82b3b1c9e2b8ff78cf0372b9215032444d955da0124fc69c2258cd2e3201b23f7c0c91cb081773f1dbd7f49455db8a7c86b4ae4568401447ef421277a7b414c6369d39c554e33ad3859034293b856e7bbb1d38f274dc445008e3b42305a1969de39cd84d05f261f63255361128cbb6ffb62c1767fd7921523c646cc85ff6214f52e1b1198277e9db85b20448d37845b0660e47f8b712e0739a87110f6c5ae92f29d049a4ca4c6883003a04dd71c1e49af2c11c80f0161a38cb3805e50a56b0f4fde0edf2209ccd99d0cb6f7ece0c5b9621f06356f1698e81e9f88e137d076a656184dfb69974f3d96f669a89378a9777923739acde179055ea299e136256682a5aa6926c13ccb9a3403d9da5208cceafd7339ee51d2fe231c78689b319086dc4955cea7d5de1b7ccbb750b3805e9b6dde5bda3a614b87e2dcae3fd7a6c69c19eb3a30deeb79fc87f613d18f3d9365880214146233cd57435c497b1171773c2366a1eb7dbdc72a0693cbd4d17e2fce6f2139367a269beaa9529cda48cd7854d25ae142cda28ff047f6da1e639e604f66790137e542d200c1d1a138c9868bace65c3954eea8f40b4790f12e5766e835549b5a32925ea51df9c8e906d6e21968df36be70a10479cb8907bd3a71fae536cc80a718cfb09e8061eb83d052201d07ad4bbe86e0db22ea1e43046f279d1a8057d558cd5a3662e94fe746c149dd74a1a5de50a9169015002aa2611f3bcae54e41f90658fc39f693d71bf25c4080e16cd5f0759f1a531c2b43789af4f34ecd871886538401b8f8c9490c7375cc7711c5d31ed858347e1fa1096806b864ec2386b0c3ad0a0b652dfcef15348a275cc3561cedf9347c5e87389455e2f1b0b5e52a909b083dde7b9696d3e610a1d0003c75e50b6b2df35547f5fb3dc426a1eef1e5caa54f652810ed0e4c1fe2f8d6196f4a73feb1f4fa1495fbeed52a34e160d8c8e7fbde4a45dc77fcb090486419b9337c81e2f0d80b51af09cbfc5c41aca4c5139b839ffa929f18946b774a6f788bd2d8fc3019fb48b493cc63fdba90b863cf45e7eb792fa19d4001e849655d376bfffd38c457bd3abcec419c11d69c00e1e65fa49a9e7f47cc83b098af93eec7d1ad1400e9b3a1ad300aadfb27e970a295799f80a7fc745716ba04d846118855f69cad21ceec07f07b2938b6640701a12dd6949114617282776a6c820503ee50cd0bc3d4427eba0761111835ff7dc552b57bbad994ba120b08670c201a56cf3f6090fac4dffd8cd61da83b966f214694cb14d8b2fe0e7e37d096614adef01364cc77484fdfcfa56f5e15d1a8b8d0dad06d52f5262fab18d91812c8ee41797c45677c497bdf3b7c4a4eac8f026b8ca682b8e62b7d8b8af11d0c192008b355083b3c6ff32b35ff7b2feb2cebdf1c51115b7d15c9c0fe5a12678ec39c83c1f5d04627e1ea1ea51d598f8e81c80f29674d0a89272fc5bfe21a56391bfaed821e813e0da8bdd6672f99748e316ed562b90ad1f37a86e00331be0fa2c21c65d19d4c4d8267582135b746a2dd5149b551f9d54809e9fc0fd781842511874486e669c9a082d53c43fdd990dee33c70cac452140898d7bf17087b2728aca085d6de02e36e7b4c92de5ef3ff7d5a5bdccd6eb13ee9d7255e73f48e5130c5528ff606b2b1b692da13b8b76bddea6963745c82621967d739c16e09af1ddfd4d8e0cdc7fd24a2e37256d73e2550cc8b774ebf8f9ef27c8b313d2bf42987695a96ec415ed6f34e6fee9ff46b2655f37fa310aad273e73e33a315bed32ccba4ed4a3d3ba3ac56c3ded8a6066f76f0c73313e7f74f0cafa115b3fb6d0247620eab42d64f26cb054ec4a7932527764d0812e456dceb019c9810727c996fedc03b1cb73e94406caaa13b55ba4339cc8de56b802f52755ef4e7d7212752132a52421bf78ed52f4a496e48bb837aa56c274de3f8cbd1efdba3099a15e937c4e772e5fe91366abb9a1fd1acc54286585d22d9281ac0e3011c0fef42b1e3dba712cd839bf7476f644dfd97dd3c3f28d206bcadbe8aa68dd140528da837474a38d5198d31447446873565afd8615c8320de3989bc9f91da84e72f55d70d652aed102ae101316c0ae7d3aa58076a40492464f7fa067348c93db736e4faf43c7ac00e4f87097a85178c22abfb277d35bff51143bf2e4fbfecd2fcea68d8411d8f37d214ffc3320d5d4cc83dc2d5bce4ccbe70583e8c8d59fa11cf860e1654017cc00d26ee61330d135f83d0b96ee919c56a5fa3284b1dd7a7e95e88f6b21eb11202912a9f8ae91ff97717d846ce15c306c5fd1cface182c1c582e9809e08b32c29b7211582651017964a5722b29004e902ee672f381a2a466f86c8814fd2fead1cb75a4e1004e0656d3a5c91d2f9c785f1cb0f2fdf8850fe67beda96aa99045c2e6dd2234e4229a252ab153f0dd758bfc60d9ff78632aaa3cb22ddefd639cfd437fecbcf952b55453f830f2effa82c253196356d79f8a0206e35baa5069ffd31c63e322014a29de41c84533ac25fc80c593d0e1108070dea5384075e98ef01407d867ee2390f625a209aa0304ed661a021d44faeb707e5b027b14422dd70dde3c681590198e9e652fb955a5a42e3145850fde51f04e0e7031ec280ab0b47f6dd07f75fc8eb61bf52d48ce5e61d17688ecac62f0d743443ff0ffa8e9a163ac24d407455a75836d0621013371916baa0b57925fdec895effd9be4c9728de8d22c23a641e13204099836b6ac26087977d7d8b5c5fa05a4df899f9e65c0d92b0a367c6bf61617e1fab440877ffdf790934005ecdd1fa03d07aca40eab880fd274cefef6a2aba3a58f942e5d6e5dcd7fcdbb1dc371b6065308eef946cc7a41fcfd4c5a5e35e92a774bf414ecd5fd5848a5a0872a97f1b3d478c2f60101435585d4f2a2db5c38dbb564b352ea7122d8618e677110a87d46c618e1f0d92683991088269e58f1aaf3fc996a269a35554d4eea724d42ade2b3776c638ce1cbb497c2a6e4a17d1638357aa37cb537a0d3b3b1a1c84a5cd719110e68695e3e24e065670df05217aa8f1d664b59773db4a3ea435980a0f285733d517ce8d9ba7082d8a2baf57332d3f458cbde5b9df4d57f33c5dc49079695528f6f335224681dbb5ecfee0081aed5da8837c2b81d3d62df8b6b375ea68c21c9d600327af3bd010539a125ddc4aaff77508dcb01e9e73338fffb15975fc4c8040fd91d3bad14529121220b165a81aebc4fe4ef4ffd0cb138d6f7ad80def72ac100e122623c13d4a44197615f4118c9f8e1f8d73755d00defa35d1023a1a1018f196bcdd2ebe4ae74ce70f97fa7dbb53c609501edb17c75ddc85aa3bedc625666794c8d2c6eeade46632db6c5bf4c8acc077ed9eb162e7014aaefa136556c4cce073c285519bf63f5369958a70ada12d6d3ae9d87abcf82415b0249858a4e9509205c41edb5db45bcf5a9c6ef7c1469d4e5c3d7dea8924ad1144e42c45b3d60bcf92a5802c2d71e9fa60be0e7cd1f0482ff5a4742766112e45400267171a4be383d8e09e06d077a304473e94b1d97db848398fce4231afbf9586c2936befe3cc04a4edc979fcfb2736c63fb63b11aa62bdc3a7ccfab1eef97acf1cb19e64a12fed9d4c168d8e0a6ef6bd31998ed8a4e6f43e0a410632cb3da36a3e4e229bf33ae6d8948ab5c029ce3b5a3d0eee5c1f0711b944e781dbf9f9291fa183a4c27f0fcf04ae58eb4a0c49d16af78493fd28dbee3d477f6a745e89d9a4ff5cb86960838199d05195de6cb0af5deff10632b293d038152511979b87cf07db99709aa7e4c5e497b8582bd9123d422de458beff9835f3e58063c8758a68399fce69082aa2c8cd0a94520b0e61417080339ed74cd8181945e1c593e70bf66aca4906bb7ebf37b4945f08aa55c16570fd4e07ea35ca4428bf93c6e32dcc6991321aadd86a171d5f096eacbc2d527eb133cd1a531dc4ba413eeb7353f000ee29397e99570c9b4411e51f942e18e26b5f80bdc85b83a8ce53c16f49e722d6a049f61e69abfc082a70e676c9425a99f789701e639549a800c56167ec4a68b22e2eb04f71bc5ba51a2c9d60d0853a79f17a96c6ab5cc18557670c3abf0447bd344d0d4d61e43f0dd3218037725e556fdb6d479dabd635d297dfbe67585aa4759af01e4b04533e71bca42d90282cee00eb1ff1cbe41c0cc76a5ae439bda4415af80f3d73e39c421cd534f928b32d88833929671ab92a0f894a570fdaef82495d2558d74a77a5f5e1f42c50c17882389a6f33388e0bc7e4de778f54e6e717def181620a4f7cc7cf1cfc4f5e1e23169dee04bdd8b4a8186163969f6ae940f341be5ae2edcaa98e0ece27eeae3012012198b44d5420663221fa60d2c351dae6dd6ed215064f06c9700b7b7f3df08ed843f2baa970d46ae80e735eed4911ca2ac75abc5f92a9f066caf8b5c4df6fd34769b8143ff87d8b6e9422efc05d4b7110c0a423b91079394d13320061b9ee9b0ca35ede16de427abd8ca2ec524bea201d3336b68a67eb44be5a16192d52acbb4d6d6baaebf3bcfc4e97e4842f3b2bc1caee00b9dd05854fec3f2de18bbedb196e8e7985f7ed40de85b3e31a20a55d35d9fa98c1d231aac6d404a97fdea522a98806a427b4a5e798e8122e8711268a0f94510b65ccdedec1f3a4bebfc9b85ccd8683610778f47b567aa590b3b0cc4874c30124519f5a5d03ef551e4226bd5f6f2b4a239b9f943023d131056858fbd8c1ffb8457058e20ea5d25e8c52c9b0acdbe2fe00af42e0722af8f7eb7a9728353f06721509604ce098e50624829bce923988425d036e702ac3263703ce1cb7429f750f7f625a2fb29e2aedd45e789422c89410f8b4aec02a910dde3f5a3d30ae4b7694821bd657e5b9b7ed91fdafe7722cd2b0040af66aba1a4a342093e84ba4a8ed06c1cc7cefc93a978cfdb80e257e0cd238c4daf5938dd1d3b7d813a27b758bb6c032dc52c1a86b7d24d6a594210b3ff1b492ed1cb6d3f9e225717a2b1c1a24c962c9603970a6b7429393b9a0be4936e9b70afe5d0069c787c0d1eea945c9bf64b1ad47ddcc6ed6893aa1a996721474e40bc7fa7f5a37878ee7c20144431efe1932d48c37fdf444d38073058ad15c47f6639ed7733a5828607cc7820601723df3811825c1981eeb3b9eb0b97f0f71e35466d0822c622ef060519909eb9b7de4b5a4fa39a4ff6f0ae7a6728a00a6be3385510e7cdd551bc057b82a7331963a4ec64663534fbd8b44a7feb87d39c8b8bf4fa34fba9f7405a0cd2e11d2608f609d213e84a2830269fd1e9c79037fdf589f8d9d6966b9d4fa97f4125ae8130fd8c82f10756d43f55e37e147247b52dfcd03b625f8d8cbfb5fe56415639fc8e27ab974224ca89e708b453d0682fb0243e0d650422f689ce40dcea234507510e8822af84a1860687a0f9195612b0eb82bcd52d4a04a00b0fa17ee982beaebfa7d3921fdae8707d7043e53efa648c51dcd12b6a9bd1c5dd43a6dbbc143a6d0f348d7ae2cd3e2dcafc501a0fd38c2598adc950e844e7826f82c6f5aeaabc95190c884af42670fad48f191608c471fc5c8953408f0d45bc418157a84048c7cef4161513050c01a76340fb1a9853cee4e5e1361ef05a37f629be9d8cd1358014c41285f491e7a291371d99c297d6ffc7795e9fbf58e7f888c733ea10af5255c955c04eeec03cddeae887dc2d134abddd17aa487bc9a96f23f75275ccce99ae686efb802a3130070699b3517d1c7171cf96cd415369ecb08010f0df250d8a821667aec25b2d42fc6a0f60bee87f56501fe4f553daefd87da943e276ab34900b250b243b09b9c0acdd58b5d8324254702403dc179a18962279882d73d4f5582e5dfc6a4c52cccf91ca57b30c44d7d9290cd6607154e49a73640ffd4fb5c31b12bcc828f4cf1d60f2b48e54e482f6c66c9f506febe932c33dec2d5121da64c5ea24ab9c5f7f0f7d8f676b3f7139554ef611cf89d50dcd290f13c49f3f64fc4b61b22f0421da20c9d5ff9d3063329b1021c5e43258d4f73d6bf77620d93fdab4b1fd5079368c2c1c909011ae92ed2c604343f42e2268474ba384f18438e9254b11925aab3bcae191dc2ae6059b71097c7d33140f453224a134e3aab4cc08cc53e8abe4a2b36044c09672180219dc7ae8d4654b623b864a15e602e70f81c01492bdbe335d2711625c2e1bfd3853b55918764a6dc5d11952d6f95b575ab77260370cf973a74a1257ad21c6d0af4926c8c0422774b66336c2301b458758268a6029e47c8bcabf61c3148bafc8d983f36648b0e350ad9ee23b576f19aa4d90c9989622bb67fa0e23cdd87f7f0af4fc1b93c8a319b0f36af6292f6822e234ab425069ae4f8b6285abe2687ca4c5b7c104ceaf3e962956bb97e7e1fc191d9ddc38e87139c1176e7be99b268e4e6d2c19dacbbaa56d0598ecdf271d24b04c87b1e994a9e55bffba7af8ad8c818a33a7e8a26f2e1f0cba2486ed461ddb26f51890fdc17e1043f1c348396c76704a4c6cf34e68e8775c6592121e87b98f6c0d68171c92b97c0481bedd857e5c50c6fd44b6a15647f7b3444c5a92992f6c8743c0c23a85c2250c4c54db94593e6356f0a5a6dc1afd480e12c42950c2addb424834df19ef3d41d11084c46dd4d7da209986d5246f63582a3f5b600ea79e03c3112167c0c361866ba8b0aa9b35aa8e0c21b8eedc44446bf62ba330a31b002e360551ca9973452c8ffd161efa03ae83ff601b25ee6947f51bb3e63f96ff6f2d69572c42d56e7ebb1e32d1dce0c601dfd227314a63944c041ddbee312cdffe8b3e891c8c37ab3cf77bf19190712a608f4801d61ad12225fd7731c5305cded085afd85f5bccd428c15f6fa00bea58eb3353e3a895970eca76887f781e23f26c42cfd9d8763c003e5c8f476a1340550119b93b1028bba34405d4279a53f75c6c9c7eaf0a53096943a295eee4310be1659ed0517fea877e47a9fdbc72e4fed1e16784e2f0754d441639eae515f6f411aab5e8f5829c0ed21f43b315ac07a17d089d74034431b8ed0690487945270f41a8defc0acc72550ffeda496c14903032758d946bbc3cfb52ddad39171ff1ca526760ffe66b9e4689d3fbacf3c6f95f97639d1dbb640de72efc9db3d6908285a5924e5ddb64e21fc4aa3e769aaf84f7bb3caebe08583e8acaf8ca38eda29bf792ecdb6e062876ecd465ba982a723236566abe9cf141cc7a8a725b19c99a8b18d27969c3593c998a624f1cf54fc44ccb87a024470918f834ae09ba81661ca38ed73e8e19ea78f1d4cccbcca551f16024f12a66a103df10d01450b4a376794abebf745d8c108d7d8b82a897e7a6379f8fc199bf4d0c47697e1cd96621acc69329486373fa185e038a2632d7d59f75e9085016e34ac4c6776287b858386abc73650c807ad13e3e18e03af6523d1bf3f7a530874bc7b644305fdd49baee6881ce08796764db8b2aefbabc6d93d2f314b6810761727453686a88787cbd3b7298987bd81d590ceee7eb00813e020100d15b0798b561564acce6d1521d6cbb9af6ab89e852e96d303356398a5b3b353191b3ef9e8f3732528bdfc810d8a203ab8e4704ba8072c257b49e495809d3d02aab2947f476e70d21f290670adee53594bfbad2304fe676316f37058bff716d9abe79840798da06cc553786a605bb86cf26945b19e1767c602d73978869d37015ccc6b7b135e0578f507de0ea89923f95ae8d4b4ee7a5c8f2fee02569a83a83d9aa7ad6be4b3a538963bacad2cf2aa10095062da0e97affde1b9f668b93f1c7dcf6dbd6326612c7dc0c5d52fce3cd991b9e8a75487a3c6b8397512d8929d958fb3398c0b001e1d83dc095748da1e66684d4c45c42a757c2ef7375f7ab52319f683d61e204a7be71ccd9d0b2f39d28002379c5c78833ae42653a701c71d2f5bbd91bbaf3a02b45aff3b8984f0aea682187225682f6d1b1d5a221bca84b03305133dbb455cf90f6ded89692f74188ccf7859bf237d0d137276f765cde4618eaea24f0710d5c3a48a4c59b4a0eb353674d4cd8a42593c7722519e46996ec0ba0793e6a75f9952e46f8030203d324fd5c04df6c1666c830a18d8fa2054cbc0835087918c4297184456ba47e388c0949f5f71aa1add88f6e768e6c9bc0b92cdb6b3a3168d40bc28d4c38702bf7ebcf1497f31a5d6c41587c279ab3d14529a66d8d571d1954b4433b8cc7f68e6ca1b77b92ed424cf88d05dd2e6cb1699c96eb06fb881858b383ace61943cc7159cfa5ede885b65627fdc11740b5d25402421f7281306f6540bc8db72b22d129b35bb956edfdfb57b45e4ad3086e6c15aed8eadb564510ff4378df8d02739bf2a207fa97bf38f9beeb116d721cbe7906caa6ce1ede2f33867ed5487994eaa8af5d90651e73971d4a73a232859a155e5aac8effa3c07ad510522e6fbb7dbfb26ba99bb01978f58ae4c2078bac84fee660912e78e29fab8aa759cc53cdaa6b9702b02774d7b0078c8789a71a03b63ba971edf24ad0fcefd5dab221934d26df13bcf1d3f1e72fb1a056878234563c2533d2d6d0a44782291903e6f4f9e7d531db3c4a7913af9e0d0b87ee695eeb1943e5b762a66b4e4c229979f7cedbde08fe37796cb618cee84a5b8ce2b9023b2ff59b3fca34b2737961a2cf3bd59e0f076101f94f6cf1b0d646699500b2042cb56d98923be7700f3e63a919248bec1d0b0560dc2a9df5a46da7b3c32899750009bf7cc92ef0a29d4409aa6cf4aedd5f19332ac8d10fc16697168b50c74f9a688170a774c206d1038195af2305ad7113ad1be20158e76f528c5ebd17d0f1984ba1e446fe650d10201188b608eeef07d6a0c79ee9d8c9ae8a11f940f6e4927819da67b3f501c447b038e0fc80fc6a15397f06f67b6b0253e232222e3c1b0a54df0e115834d716d3d6b659f73a4b47b6a5cf3ae43f223d3bede8db1d53eb961a4216733364bf0729368606d4efa4215d795c49834a93bc8a952db251f2f604a7cb81d46992a48cb727d9ad5f2811332365f9096da6e26ba8fb45383d7df8575148c20b561f9e4ad69a93f9105770dd566512aca6bd3b5a465810e88d18393a20c12273106e3d41ad617502fb1b305e6cbd8be9a5f36e55071414f36af57024418fb637f00e6dd03b74e3de9d64c6d27655b073b24c25325c04ef442cfe930e2b608804967fc75813c1e168a5515baf5df3873437ce7e73067acef6b8c78ab8f00ad385769fded80f388acb66ef67959f6eb25c892e8e11f495d5c493f1e399de0dcb0baacc5bfb1e261eee88ae109c27e4f56e716fcbf733659e8758ac64257834d612825fadba251a4d501a5002857f8241b65eb012d34f36f7316d8a5fd23c754e0123401b9614c77e29dbb0d0cd93099585e5c53b35b8664b2abb3ffc3e9d098e309fa31a39a6ecdfb8796bd210061ec84508ff1b2dfde55ea45b2de0fd2524ba9c360e99b28f4dc9e1993f52c3f6f54c70bf5d274ab05242b26c04d1b7d0f3db0ef38605e544a3de6a8ebf6fde3e8ee6a2aa7358a67b0f0d8c2512c3121ab24826f2495a3498ac45c27ceb18323dc296201c4ae1fd823d01290e50bafc329565a8ac68a4f5807ebfed5fb146ecec0179a7d04cbf87f7f89da7b5e88da85d4667057203edef8d3898ff7976da483365b537345041bc00ef78a7800314f17a0c7ddab2fbe94259352ed812646d3048e4662c99e431c27bdb098751b6aa832e954295bae3f08e35449e5f3d73b3bf150b7ec77e10289ea36f80e14acd707d3001dc63038a26f56256a3dbbe9e7909ee1c7ce430c4c9a73a7b36f20141127fedaedcf38afc9b0c7e7bc9d402947c22b70c609aad0035393476b2b08cb4825637c8ce95f8ba82dbe184d793d2595a2f7f332410b21cf2985cec4c8a66ac3eb71b1a18c0abc615b2a8b60db27dcb99605522e17b6a82ffdba76a7a6279290a4228f37aca3af65402af525f3ddb7f894f7666a125ec6e06431180897f239621dcae62900c169647421be85351fc8bf7ca08c20f8587f382504d0e3df93cc2f04f033d91f7765d5dff7bc2250d77a981c17655a40046e2cea0392f30b8960d1af13582626f9d5fadf517882f299de5e02419e4feb13b6c0c07e1f641d0207c17a41f20522797ddd59efbfe9ef13657daeae8ea02fc382d7e33dcabc3310ee3640fbf7d083483d08ad853de4717720a0b53b3968adcaaa5aacadcb9e712718ee2c677c7101ad66877b4809c6b32d178d964fa2303be7aff26e712112ef9bbccfcb99a2ee758287464480b629d02dd9c661927cc95018dcf01e60fcf22b2d7507b812b761591aacc21d68d0e5ddadfe96e79daee008e9d30fcc65baba650fa46aaa55a913dd84e0fdd9c2b4a10940f86593f4398f452bdb91a6ffb858d80c73bf7918a49e950b176f0ff02f9102fa25598c4c073e04a9dd7404129e3378b56659b8da8172a84e68f67ffb60c30aefdca4c11f635d977278bb836964479c243eafb587217c3911c5573f5a09426ac1ec74601e02918453ab5fbf8db02dfbaab4cc83b5cbff395a52a993c011a7cbdfc2b22add4898f87fad83b436a552d0b3316a3ddd6d9a19337abcc60c9242c3244ebf24b16bdfe50320f9638acb41fdd78006516f31ae8fb0c820e4a833123805fbf60a43554be2dd18bfd7fba986b53bfaf3888a6e457e3e700ab1458d8f636b6c14c099ef427fcc99d9f31103e62464e9feee0741c022cbf1259bd6e193344b03d34d461ad551e87298e15a8ef7fe8bd154cf55434dabd930a70623d7db0b233919efa0c55dda3dae864c5b12746393bcdd21227ddf6c549626433919f6112128981403e0253885c4e68fc9e7cca47ef1a7ca8ec6d82fd3e920b3c8e34c5dcdb07bde838f6a47d342deb6f2c6b3741d64ff138e24f0232a4bd2978e56d1d05384dda40a5c73bebb01ca19010a5426487bc3ae181487f993d58a97ee73e5d1aad7ebe2e9e029d14b7ab7dec062961d677ff28e2ad73d10c4bf17fb6acacb9af3bf8c77cf22dea95cfef57cb5d7848a988b78247ba7e1e6b2b781a0924b2b4a71118e1a138b60a138830b5c90ca64dca92d0eb45424e958e7d8bf237662ef4bdfcf1f6d78f4e7f540d7001082578ca8274f860a2f1a96ecc9cf2da9716838fd0a1047b6521f5ea56a4d4f21c5a61ab0fedc3bdfe9993e7329daf756ed25021def1b6945b8a965e8f4d06c9be1e1efe79a8ef1b2fe09b6ac8045891ac8c74651dabd999c87bd7e9797392fb824d30c2a81399a525f30442095a22066ab4498aab60c78aab6877f9a0258588ed5b0138901e74d268cc9253fcf5ea3100db6a5594d4b925d5620c5211703a5203fa3efe3326949d745f290c4d20aebd558856b3a6ae1f4eea8ad9e22c8919e79fb5bd2173ec7813f215ff51757d2b99ef870865361d99cd3d57307d23f37db8a1e1e3a8e9441921068b34cafa81bc03bdb189f3779be40cd2c4d51b309340b5164da528d5c900ed133f43ec92979811d73c87baf78360ea1798b56301e85274f8db891145ab4a6a44d89a9a4a93c05f204f57c710f6bf25cb17f938b79b097355e31a62e7fb1b1ba9d304afca3806561651ed6705c2e90a074a08e3b5d4adbb00504fc8c027c60674abc49d0269a64ef92d2e89df4380af77517c7ea06e621a8d796bd8acb0060b87ef2a9fd2b8d750248f3cd634444dffd8a57cd1243a778ffd66e49415d789a2a026802e71b3841014a6268dae16ecc2cb2036962a9683d03423e59a1db1cbad127d36fe66fff538bc6617323b6819668e6711ac023ccdce1ebdd0e009889571f8de3554ff9521265a1d7af08b4eeeefad9921d167c304e4ae94d90d717290e7e9ef879154ccd711fafd47e7f1af61f7aa8f4f5269cb72e4fb1297503fe7da92d8d6922532d9d7a62467d19c9f1c43dc6219de5290058cfd00dc2ffcc52a838ca8f1bd55d1dd0c9f4678","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
