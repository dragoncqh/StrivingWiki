<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ccc3b646065ab445b8e5d418c92ea0b5014b15004abf7fdf32a02568e896565b6c005a79b00f1634b16cd10858e0d1b193ad2a026cf0455e965bfeac0cf0f950fa18f7d364193ad252f3a611edf14758c12498f29469ccbf0ce9c65007fcff59d6e782046691e16ab19a8632fff25b76e3d25298b62d03901208748eef07cfb7b5f2cbffb0d04f950a21407f7835763a387b60e3cb70212af5d459be79714e2f6b2f3524d03100300ab50ee06addbd8bbc29ba6dcfcffe1f81441e9dda821f81da885281383ce9b6e303726316dea47a0d3c2d4ac1af770791109ae93b9f71e9c22821e0f7b9f46610eac08cd7cba3fb67b50de4e48988b94fa6062a08f625564d1dc78a44d0dbd2c4711a3427f7cefc340b37dabde7978b721b6e600dab9f5946bdc8eb45a20b539a6cf3e2233ab041b4f0d8be9acad172a2a987c671f616ae1f4a482a1f76a5bc307aabfeac58a0f736c4bd3afc14eed6b4cf24a8b321f6afd61446578d1142decdc5bf0e7f891b4424386be035d73a4a7b858ef17cf19d38e811ac980a35e7357a0535b289776420c4fa58592e72f4e39f40ae77dbb6c1f70e92c9f1ee77326af3f801d1295e6899427a843e4771245570cab0eb6f16e66b3a1dc16af78a787df9a5d58cd5080fdd1e7546d34430d3aaaf481b06bf680cb890fc1dc34521feea3d4588a71741ba935a6e880d5345b299b69a5268ddb185b41d6feb57bd4771b2564bc1dae4b54a33160382cf675344d38789a96df255774a19b09021f2b1790abb6870aef08a693c50ecd6ede288f32101f8f48c974ae5f4f1c42ba01838fa3339070eb22a3e0600c7eb95a391babda571f94e2fbaf120783168a127aab7c2d53bae4fbc4c6c901db5f0fb92fae0ce197a4bd54283245312fa6ce2dd586a2d4f893bccce9ce5678398ac11354666aa7cf71faadee48a010888f02e9e844a23d8710637d51fd66e89e7d3e39e04b1deafbe5d3b930c6e04afcb16bc1785ca645e70dab2b9f0a1de450b6a4fe20513950d4906824d0f9de568bc64a2a4710acaa47bd78919b300770ab9e9b11827bba050e78350ca5e5f606ab6e2f12a92aa4331933f0d64c83ba9949dda88f4e4eec2a03444c8b404309b3af2b3114d9ed58e92922123e8c9aeb7ae197fa28ed404c166d3a9af24a26c011bd158b3ca7ae00061d3f618c6bc5d57ca8d2ca099bf2762135716b591bf29db6d6046854588c46b2205baea5826744f833a8f9f1e48524db9ff5b7fa2839709b3b72cb401a97e481e2ffe4a3348c80a5c954a91cde8503aa76c87cde930dabf961cfb937c2ec4f8ae8f893988d7d6a28ffef2abcfb455c932ddfbff453123837ffa25e43fa0b65d1d7c070ba24939e32fca8d1b9b2f552c76fac7ab75ac6aa49642f6b9e68dd4101eac6d35a8a4c153a0c5e8e5ce95069e7baf82f6bda21e056b3982451562e5183e4b5df2267f16b3bafdfe438d339368ddcba6b61ded877a959919b7cd255db3475384510ce4a8ee0dea2dffea5d52e1413d7bf684c15185383e6f3269e6511969c254e6d61e0690806ace66ef61ae9b634595071816e33ca6f3f5a1a49f0414445c7a83ecacd780ff9eca19ccfd495eea0c91c7dc0a5efc88a7ab81422cbf7cdd4e1c40b71908f4371f0deb23cc430634a921848f931e7de31008d8683f02f98b4f64da53a96add4788aec309f63797200dda15c18ad028dea5bb13e00a27df38e56686f67b5331603a6db3c4697029aacf3814cdc2159671f8ee3b50c4ae2cf237f3660321f759bc51a5567633c32a6452fa5d29d00d022dd3b8e751e86be2eee0e1525df4dce7c5790079c2d906e6c6ae5ec6f3b111a0276f89889e78cc76a35aa7d705827c1dd51f004f7644f1987094aa8f621cfac190fececc956474126dc7b39f390e3c2d9df4af5e985f52fa0461fcc1354fcc9d5dceb1ccfc64fa2d5329ada70319240ff5e3aaadb303bd3a8278585a7d7d4d62f027067a42e0e830989fcb5da9e2bdcbaa613ca8fee48f76e5a77d5ec0be713abd0c4e585fa44bb4c8499f500faf384484150a271ac7783c7a3babe1786438ade39fba36c3d6edc43ac63847fa7a024184fb4d72371324ee092d63e17dcc577941c7ea7bdbf6c584f6562a23bf0c5b0e5d2649ef6366f84f21a2f76a78adb6e0a5eeb9e255517502e16def71c0995e84ef76afe24323002c77d5d8df43e0708519bee9145c471bb45e3a62f7fba4a073bb718088b611d92335cc1999ab97057aa25d390b609089005a9a69ed18ebf191cac1eca1ec18de337a6ccc5ec22af5eb5fb15987aeb630a667f5dd72c336462371701f0de5c9aebb5820ee7de0839c79cbe487d371a0fe226d446fd31813d2d74469423b3cf57acb5fdfa0490e76760964a3a052d9006a04a465c5f3ac23428444339be677de7fecaf094668c968a3096bf83ce6e71528e3a291e48c4741b120bcefca29f5ca914b21b7da559de236d5200d1a21721212c9a2eb6eb25cb24aadb8916360c7fde4f7a7d13f47cbbb8b61dcddfa97080cf1bb66fe74f7988cf97b31801c1bb36681ccbbf219d299e504d425cc792fdbba36364d434e321bd46541c95d21eddb973d3294051642dc95aed3685f2beaacace912ae3ab054d594c9f474e60e829c697fe6ff482aae763922b87aaaeed4d009b7c0bab8c37fc8e02bbef5122a6297d0d1d54c6c5f788cc0a122272bf573fae95b8a389518ba2c113a980f6a35fb082be58115186a1eae3147da098081b0662237898a115d1acdc8753d6f7afa2e6e94396a79ac7d6890eeeb60f6e9604bf8037e5fd21345cd7ebb3b8daba86c6abc6c0d18ffd0fde2e1c10906700e2c8a1bbca08841d954f4060db27407100d5cfe897dc64256e1a9726e8468cd420ac3bcae5de94550170f082df36d2a9df288c98570f9c678efe31838f096d8e4fe336edfd616366c2a257b17c2800477d62c0583a8d4f0416ca0e039c98221b8a892cf01183c188a1eb386549a07399e728125e3c06bf1d93de046ced4ee70e2c1caba84c43c4b12b023a07fcb9b2db744c7207c8560adc0a59b118e43bb1a17464180ca58b8957b931e381e8a247126f87cba601806a7b3a86e3d0e78f2f48ac7f5dd8179747ad68958bd789615071c075907c97817fd9df7a9bdde46fc84474832d5e59d3019b59673292387957caf196c5babd548923ceab1e1f1615ef4ba406f947d659b33c1124fa1712f52d4e7d861545e964377afc3de93248a54e2a69590348219dad5a1c7341e0e91c92ca09d29fdda81f13d55a560db1fe80856767c0657a3891a2ad502fb257b863a74d715ed76a702b1f658ceb500a3881a0a629597ab3b9f467a0d6b1bc2f8b341079ac0688c0540516405800b95971240700c5263ed791625736a012f78225cd49b0162df682c2b5c2241f5a20b6b35b39986de351929be9a84056a4b94cf7dbb754b3a20671e1de99d0fbc1279ed4dc65257a2869fbd217300f9268141d15c4e7356d8c6e778700bc26791c1cbeedbd296b487b3abae33e3a012a866365c66a9bdc4f334b7594e2eea61dae59a4bea0699c0072cfc30811a92bb330d5c27057c551d501ae0806720ade56bdcb71933f105dba1b0f660f00596bdb118f3feacac94f8587ebce38fedc706fbcb30da975dc5bb517d08c4429790f9efbd0ddcc4f5628c56e7ebc894f11d60d5363d47105669a762ac942bd9cb753b5b35262654e3c32ddc7607cac8c51c4ef43aac457bcc7acb3fb77f37f7446cfa9ea1866fda2a389f2fb363c8fa814db7cbca06d48605887e7044314697e6e9139b4e6100991d24e007cc9a14efc7ad6e41ef228adb8dee237643ccb533ec6d0d1b5374ff114a14beb361add26113d105e96eed45b0191c61287ddc457a76856a64fe8a0918865d41f21084c7a1ae58eee483af36b46cd6694747153a8fba8366a0429d06267eb14eed583edff3ac023aab1b71ab7c89d016ff811d0724831bd8a087a9f95cc808d8342cf1428923f6afecdbfd99b5141e83a10851e13ff874cc1da27ca273d19442b8f8044fa6fe1c3dee7be4497cc95403b26a9da442dad5bcb240b01f4dd601916d07d880b56d57eab3b816a2d729b663a9fc81bf2b337078e9b6e2d0aee30992a79f60554598c672f61c5094cf9b710cdee14c35634db31c79f22bbd01e41927d1a454b78a974db7597f649f9f5a3b07d3cda95f5ac0d0735e29d2e2c37c5388aa951a4c09bc1013d96ea1be8242863d8605a60986a776bb7a260f1775bd5d809f702e0969f32ce745954df76b8dab1749be51e108d562e671118bd46a1d1b11309ef2914606d4ffc857d2e3fcd6842c2acb68132f6893d72ea04b490512fa48d789806551f17e78eec728ece8a4b9b69adc4332b0f165bc6a8b5f71f604d511ab5011c5b848d6f451fe79fc77c557a907293cc9b1abe503355d2efa6a691fc2be9e7ce2718fa175e1cbc30305bdda4bb19a9d44cf4e3b5e5ae50cf42a47f88f2d234ab38539d4efedf01c57cc2aab96d8ee5b29603c120472611e0a54cb5c4e47a7b838d178ba924424f2fd2cdfe271fb956121e6af476bbe7bec2144013f33443e0c202dbe39e5a72b736aee79bcb60ab0026c04b44b26cb225e6acd5f246bfd4e9417398ed5b6d6894ca83312fac7ee6ac358a68919ad7d64110441d88ea7ca9375abc2347584d799ee20599a1b405782dfbaada73c979e3f7af826e1cd40304f71d3a46ecd579d0c1f29d45dd3ae8cb5b7322bb1ed99dfb0a793b77a2747a39292e7a6ba12b9168b887f457347be4ad812409a05ef31f5e52f40a41778c54a841de0b80a8c5b7f3f333dee21191eed445a98e185caef08b88eb8f4531f71df8da2c25759386c5a20cc26f6729fb6f2b6e33e1451b56385f335ee7a78d413a6d63081bd9c5cf74ca76689f4de8317282131f28fd333d124c8a94d6b54a4c820cdf10a89e1b26adf39998651019229008071b592fefcd2054c16fd67a7af45bd30505476a9526e66138550ddfe0e3a14a3a362897b93b872f211dd91fb5d3fd508f72e763a2238583dddea3def048e3b5d36ae8bc81f1f2e52f50fec43ae33177258138059026a989986941a8741dfb278ce8639c1114716c1d93686fcbf4a9cc0ce787da32e8a13eb0e99ee082664c912063d766a1316a982035dab4d374beea9c9c91c83c0b731e6ecc36ef3aeea0766035c1328b6e50a44c3fc2e5a032a7a35e5dffc8dcd2fef65ef2e5781536ca8025214cccdae012e56c89c3f8b5cfef55b7b3dcb9a34ec6f0e728de6d0c1d76b45083b40a0d4a4ad50a40cacdf6c46770034570ebbaef2172aa7896dae3cf20831bf46e6b8228374f8c153aebde5cf87dc50d364bd952f3963138c2e352d045395fece26c52b0fddcaebc3f452c39f72d5097f367b9c4fd444015333864e8b6c2c35940f8e379f92f8d65c763b7d941ae0774080ecd7ad1b890725576f04c1dc491cfa146f0d3abf3cd2c01c4238dd8280af388580fb40368e378a245764f5fa568aba4f1dfab46cd327605aadbb1f79573d4a975a9a6d5139145e3d9ee4b3c96da8db851235c3680e608f493c0c129a1dc31460ebf276189736540695fe08517757d46f2f459284476b23f348215f63f9e7ca81eec527b0c5ef6612af6268f3eb0f3d168b8d3651bcef29b3613416faa656090f2f4c0696f88ca0cd31de36f0ed265a9ab64c7a9f5173362f3c198cb07142887d45268672090fafed250c980423cef5f41ded46f8d9fb6de07d5d05e382aca1af3cfb995d76af9e50105a146f054bd81117464397f67044dba2cd0e576916ed7f9eeab970e0e8b7f5f2ef7d48fdb4602aaf914f891965fa23fdfe5a8804c57c11d450abab49eac9c443d9211f2c3efd12936cc2e283c4ce616339d82faa170d4a5e09d43683dd0c66b2e72290dc44664364b790fa4fd34092bf91a2c1c8da2b3ed59d38647c2ea4116264d7ac24567df3a5e1fcefa69ba02d58002e559cc81ea36864c79ea27b108419349734f7673ec0cbd73ef6cf728b57280586761b89ded92f738781f88c244197cc30bccbcfd64b95a12c57e72d215bacd882266d0a21f0ccda5fc55960279f5d2a296f6288ff36106c6fe24be808500ff77ecaba14e77b5f020e9b0b115c5822d28cdcb5da9d10bbbdd60c6ba4f748f37f4cf6fc0c386f64f9fd32ac724c9061928661606cbb316bb385bf157abae336afda503480e43a1b6e4aa556696641f97b9f0724fed942541bedce4ca0c960f18e542cef4b9d1d7ab0a29f4efe6590b8fda0f514e22c8d6296fe41064e4665818f1507c18e482fe5514eb9edd0857fe20887311c60e6ab28e4966cd4e63b5ed2ed45b20ad67b5ca81e672476a168cf713bc32250676a1794e49758863f03d66a6f6a2deb368b37bc97726e7849b3cbc789afcc657f7931c3830c61270ca55cb6bc4ca463f26f80d7d96661dd05c5baddf0a8be4b1ec395a58000b4b1ab94e973e8aa173f9bf23c089103ea411fec776c349c0c84d2e6a20542445e847b1ade120ce66e56deae09b6fcfb4c6a3a2cb5ab20b055a3a6c657389ee8050213249fb11b46be656f129a00ece3b13a696cd9a98f61c80c257d5dcdc29178d8dccd5d8f2ef5c894fd968cf42cd95eafd1ab62515b82fcc14bd949d962e372889e50024f906f1e12ffdab005c3afe28c0ec3d92e644c45804eb38cb5648a13033cce342d4b8db1d1f0bba48669a5714e9958944a883a5818d47aaf8790fc475d256de830f04180d2d9ac37867038e98b8daa4c26948408ad889aab0b1de9978616dcf15cf4c80a84422e029c46ca73d5379547945c32e2d04907b94a4b1281967c4a753a51a366fb0e8fe8c3be1fca60f8b28fff8998ef840d53078df91917a5c5da4214e0c7d97a1dd9e393daa4945a17f52ed0c06fd1e28e5e3af85905ba1dcd7ee6425c50660e90d4b0355da557a958a69a80057baa7415d613fdcc6053292efe0c0ec37385862977f5822eaf2d0e14ad055c3ff8a7be66b57c77c463bae291290049523d29cc6b3f0f91e701ecb145bd9679b3ef31b89d1985a239d47dbb261640d3014d502a7c22d8d4f02152ed6231d5b44fb651a5a463f4a3a97dd23000de339e029625a51f0a7f557288581755bb6dab59dba18c2e28311a4cba06f98967ec019ae09f77fb0d826d1bb76de4e3022696f049d0de2bb3d5c7eea4ca6933dea45bce1faf312232a42c0cc992e39f465a01a58f284870fd9c03687794ca06b647c7e440259410c4cd814c86fd9e49508d3e39563a05aac9a65bc1d3f699aff2006e76a57ef4e0665ccb5dc9f65132e7b4804fd3945c5385d949c030973e84c545c626b772edfac83570a4f5c5383308f6f40546b551730071288fc3a43b199e7eccdb8f06f6ed924b133ba35b131f3ac5f2fe2967915999c7818fb69e756976131596","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
