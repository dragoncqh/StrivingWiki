<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3be52437888ec97e060b7b23924e1435fad9976006ad0e4e8c5e1348569834bec0c3c93990a8a2bb73996597447383333976bc4668863d6389869a0a2801ae0fcff398ad637493b5525e0225936b7dfc902a7ac485a8141d7980d28cbd538564c316e98c417ce100ccd0c018808c64c919ad00a52b69221b8c2c87745958b25a5a8c1c92f3030ce4f9f2e0d941050a2e5cc4a19493430f5c16b0d76a32cfba82e277d4de08e372541812d50479f1f6f5c5150848137a97cc55fd905286b97ba01997fae9788671d22d73e965a700c609d04bbefdad87f783ad3c4ad939cc872632b1d681048e84718a6dc28d8c4d260fa2f11fcc69b6035acabd469f27e0a98eec82401b9fc6877646dcce2757b2b0f6dece58febd621d236fdbcb8caad126ad1c962a2f3362f28e24dbb9b112b4e976f5353dc97ad72f14fd57b022173ce48a9a70d5f16768b42632bdaf301c5eb9e56b0074abeef0410259707ceefdd5068d250585311103af5953c8ab6d8dfff7c927384981ac569dc24b291d4ce011c19a0b242ea4c0b5f53a84c6438e693a0c7725105794dab789b969037a2c269e0868f594feefe5b3d58b87c9f3597f8d4555bc503a6ff23c7ee16c9ad60353147449a8d706f4f1255b904a06bc6c875723426d4b0c17a9f0a87a4c27edc977068e3e373305a0be534cc248c70c979cf90c068dee588a46c0715f251d13386044dc9ce409c69cf9ca2f71eeab82c8f7697a603b087b9bddd1e0f7c942f44c064c082f2f182a18ffe848c7b2cce9b2da4723fc5268d978aa8b74c0e6bd11c1b7142867d9712f01624fe1b8201909c818ade7abf27185190efb240210f9cc31f83713829f66c6ddabb1a95786512c40ac8bc3d3ab3657773e94fd58fcf4da26ab0329f5eebecf3b71e36075fca0bc56ab793c7ffa021ba15e26907a39e39148be1b3bd5e8c16780a2e0d55835a25e83155cc3d72709ec0ae5e06dbf7e9363d31328b59d1e0be0e6087ecaeddb38b0f6737056bf6e0bf38b7cb45db46cde34962ba522c38a546b16f03866c4db834573f12c3d9b5d72897933d691e702402bb7a88dbc170acfc4a93a6da3c5a00b090c12a3e34f8e585d618dbea63b5cfd63f8961d0ff6f8c736f149e7467ec001378acd80565d550ff6b1019f10a30b1713a071f461ff0ee2202d7a81c1eff67a3600f428afb28b15fd6ae6a36ad515b8121b1820594eb10a6eb8a15a735f8a313df03813754a715d81f2adb49154677178ce7b6efa912f0f72a973e16eb63529cc7f0f4a0b6552b5b8577f738c12ae1537daa3642866deac175297ace9cd7436e0ce0e3e0cba768592e1df7492fe37d9834cb16c932c6dc22ebf801f8098e4afdc503bd7b12ed35e717b6830de3e8829226a87e5be61a0aa55fae404ea13808f9fc69c835a90be2c404e11d3d4a67cb30ca6b683156bd35a9d9020ea0c76df159e30c22aca8ed656c1ea6937c50fc267dbc9d046b40943b1c1a56624eb7b02bbd23824f3f0811cb1d3488a79c4e95ee4216a86a451a673ef5813f460f05ce80b12566271ca2fed5f367586bcf0890a09aca88b5b4ddb1f8e8876878d202a5829a6cf45a339aebcbe543743224b0820d18f26d7915226760727343fd6303c7940d32ca1bf4012e68cdab7b66d3e4b40a269baf73743db3cf4b2c81519e79b04afe6f8e43225150f7c4628217fc82ede9cede35d24e0bfedffbb1d890370f05c7a9ebb8a2abde6b8326631dbafe37ff5e9a59c993dcf04dcd9808732b49621e5a4011b72a410867cdf713e39e6fab59b80d82c74ac141640299b16116c27b35f9ba4a9236700c3c38c35e5f0bcf101d8dbb431ad786f21b0a8931de6702512f722eceadfcf59d7e019f078c3942a8d855b0fba1e746e828d9996f7053a6f36100b2cd992a59eccffb48243a2f8de385d0c6883f6fecd26152be69418c4680ab471dcc607449e26861a6b67ead94ef007ba492ae062b48858f3ed3d7fd07694a8eb1757dc454ddff5581fb2f6fc61d9b1e3a795bd32243598514b9489f141df39cb5112f7710d3e4f61abef2164a5e7d5c298f1943f6812d51677605639bded1b4ca59770bfcdc94b01573ef09da07f1dc9fb916cdb0294459dfcd132faeb51d6afa9af3f64df88fa32fa853a076372b3fd6dc882dbd24a0cb39886d74f99484b99fcde8bdd45143d925fa0298d75432677d5ab5cfd832c73aeaf591f979d3142288c91255dac024bfe30e3310c79d7a2af1066239cbd56fbea94e91271cf9a9581bd1ef8fda24b7cd50d4eb76e1a7e766bce284b6e9a8ada2e64cd280c217def6f685ed53e16c4596dea05b3616d5a1e6cfdb38c86df2383d6be7fe9be2ec6575c2564649f45a73514ef2875cb9be7d20a95d0f5f3a5d9aa4e4144172438d5c417d7f358fbb72f6dcc9e1a4924a33d5f5e6a4ea3ae843e26b4c0cc85e3c286c3ff6357510dec065f7c65cae62dd15f8422058a1e94d7e9f54fd4452f94a2303f7127eb62b4a1bdee3bb24120da2b3a96a5e7d9dcb2f3e11513fd24d71d53033fee7c066896f4b75c829c9b686eff85fe1d8308b9085db1f5cbbea65a7288a13c00f627c8b9e8c279de6d426a487694fabc610c52b2787b5938fa15b19db753cd25a7360b99a39257e205b81753e62a140201e8d8eae622dcf52879bc8f4211b04bc36eab3d5dd538fe2aefbec34140aa2860deb878c303d2e25169925dcc4a871ecd43d400b8207edbf0d614b2b4474cd68154240924453fa3788148dc95bc587132da351c5652a0d5a2de13b61643a749915b86ac2b3e2a32fb5811e5b4308aa9ff45576f7dceef5c010ef8e3c8026279c840edea19c5eaa3317ea2c06a79e3161c203021dbe52508825f2286a3ed3b24433b35a77a0cfe3121008b68cf5a8acf93c8d66b672b1c7d9b7a7836b3b93597336a9c56eaf9d15a3ac128dc26ed7fc2b16e01ae79ced82e1a2424c50c1f3d9c78acf5c765af8ca893668c8eb139cf8977cfea0bf9a4fa370767419413cfee9d9e6718f0f3983dbc72a63c42a3457d6b908dbf8054818c01c3de55f7f8e0175c29f6438667b225b12b2280bab5ca91c63672778a3487647126a780dd22129bfc008ee3a0bf8df0c2a6122489dfc0b07dac754c528c5c359bb7c84b616ffe982c8f809c17006e747970d474a734dcaff4c2bb548ce199946f3137da520e7fba1f4774e8140875e584001e723031fdbfdf4a9f5da8dfd3e16f3ce05b3af7d4f0e087d55f22c56bdadd2875da365b5c5a2f5973c1293a881b50fc41d2f3dd44b6abeffe047699d4a656a1430dd9c23c910ea2ea7f2d2a589829228f5d128b8e4915d108e72daa8f99a27c26644ed29b8bae7865fbac58a2ba3403dc769ac3ee2c3d82e953877607b2aedfd27466bcda7e1ced5c31cc3d4aed57ae80c113979220d5604997adb61aa02209016fdf562217955e98c51a6670e020f80631bc2d469723afc0167e96b010e48913d2e51413986b20ac34ec7843346c74a5721fb2f478b5da6f24e90cd555320c2384d45e309b61ab98811eef3479da322f0fa31a3a149ee8563386dc2a8a1bc4af4aae2e83c9aeb602a2160f8627db9f5edcb30b62b867fcb35b1cd471d7faca498d4c988c0eed2044ed20ee07e8cc41c235e96b9d3f1d4ff8c2e968e1905bcd0735dd242c9d3128521a9440c4a29f2e6cc5d184d5884a729903e90fbfb081866280342ab86c47b23732de23c229630bac6c3dac808dbbf41b9473397807e29024a6a84c97dcd0fc0efe39e2393d7eeb4785801f92a5aa379ee2db1c2ae04ac179b1d978a1f4ff64aa01fb45acd667193bfaae1e0c4688545bd3fee5a9be7d8d22dd930dbe085c82d462f6ee8fc803d7b07f1fa8ba1c4f0dc397adc78c4b1e838560db98ad3222d785ec4226252ef3e560d9bfdc5c64f2a6707e6fb976a09df39ff89b42cd76b2f8e4fcea3fafd46049950797c77d61e3ba0eacbe89c5cd55e3f2c52dd7bd7eff27344083dfa045e8d74793a560410af3d2d76e14bb53532c09628f42c0386ac66829119ff797377b090da11587b6de4bded1061326d160079b1a9b3d15a2447aecc197d937bd197a5cc9c7c80a0e172452597ca2e619b2eea510c85c8142d7f2cab8b756872c1397d01c85879b86a52558a382f66c7da0878a59a2b6f2e034eaead6110a31d29dbc60c82fe038cfaac46bc03d44d983de9fa0a6edc19c7bdd80843c51c6dfabd2de703ed3e31810fe2a609955eb929026a583c21e3e751e964fa25ea42b9f49ce95b2ccf149dc68c95bb75eeed41954b34e62bbb9ca2edc26ca21e1257b597ac118fb6339dafb4fb70dff7bf10a0f2c9dab5ee8dae866af5867028d9579f2d9a4fcdb04a0ac143859f95c8b1d337f5c42dafffb24e0f754ef016064044ea5abde21039b3a7eae8d7fd05d692a6537078c7de1ec4446693d8eba0f79e3ae595c07f64baf99bdd85ed7dd5bc9cd9798e649340c1766ebdc964ee595a7f26d01846947016ee2561ffb620af3b5900be83a9cd94eb66beae6840c5f8adf165091e37fcca750332f0dd977fca467dbc5b7733240f99ab11379de296d85ff13958e1ff522ea0fbb89580fe74db5053e774c2917a82c5b46d17bba60e3fdfd2f8518271fb7b31f61fd93f20b2e992e0cb954e196c0c8f80cd37412c11391dd24bd8a98a0aa001fc526905d68aa9b386650e8c1a80450fb245456428b7b21167ab81570b045acfa4a2514f3a0c3bfb151076a61246bd4f9dbbae787c22b9e8aea8f213f0d9352571ce124bca76a238d5fe01c453a3a5de071dd6e01a8ed4db3919ed04b4be5d0e9b66e1cd23c6403b0f14d2c612f119eee3bd6923cd46709aadb6e63bf5e3b57c505cb6e77892b7118a24109b0af18421080105a10720e1fa1a4988dea60571f5d331797a6ea9a4996cdc5904c8f61ca2d6825656d3f8fb9aa5f585c8a09d07acc5731e3bf828601a185170817feb368224b9937af986496cff0ba1eb05a0e7644e529acf605d9e6001df7decbdd0342aa64f2e3fb2f274c4ffb16a7b390b74e34ffe0411cffd3bd382b5dfaef9047df00652b3aac72321b7642d47962b6fa0f3143037135548ccdced68934fa279d62dd07138f2b8aa015ec5d651d7f37a0178fa87eccb53cdcade66cb0067ba1dc6d32e248374d581c264881480c7ed6513382842d44bd7a0f24de0759bda7be1aff38b22c10509bc5a4230dfd27b0802c31834f23370e28ac42acb78c184dcb7c1b70c9f8bea3124f3f7e5dacf5e929f122092741958af47984a8d54fd984dc06b2aadcc3d4300a83d7d4a5d5668e7a44c33828ad0c679d228816e0ba5ac2990af923d34f93ccd371599c9c648a02689f808435944e4a66321620cdca3880d2aaa45aba46311c874c06ac79b824364f8a38e41d1e4cbd2e6d6057f62f86d83822cac54b6398a4b8ae4498895d14c2dde982dcaf7deb343788a36c827d10994b9b1f97ee4a1fe20e710aeffaf3313820730998260e97680624c6fa699fdb6971d216f3f80c775b4f8b970c54954bcae4c1dad500b9fd55bed55952ec4bf17bf670879a4768746390757bb9171a62a4bae74e725c1436be99d456ba6f5af9fc318cfa554e9b4bafe295e2367c690b68e0528bbfb7e24d156724691552f00b30e0231eed4aa839b47d2b16b19df8319fc29816fc800c61a0327b1c79bb7578341882d5406cb8918d7afddb7a277022c856a98e06046bcfee57f921640274e753041d7111fb68efe867934b4586ddad7bdd7985383d7fa98acd1e0757cb311b2f8c39906e78515da020f0f7ce210fdd361302668696ca3bcb1d3e1c90143882a28acc16aa202e3a6a556e21cf7a3e3cb4cb86b2cf6ec6272e1e24ff5e99c953f3304f2ebee29dac9c1310d366175e82fefd293a39b715a1ea76bff12c74f9f5095800c4bbe5d677678c7d4e8b9805db01704039ef3729ab69f6b267f750bf9cb9e359ccff2eadb86e8fdd0d628cf772b30007589c9e1c4f8122c578dd096d598a9003b139ee237439f4dff007d6a175cfb8dab59490584e935a8ff8eb321d1a61a14ac498222239a890f352ecfd4579765372b1d80a7dc40e1d895b7d81b927ac4bcc7de5d8eb066eaace7274f5b8ab470b2997b9391fcf94f81173ff54f63661320c1ba118c82ec6f61be6ea285d0193fbb2cea82ec9f48c29cc58683b942723337d4beb880230d3c088e0f0cdd8263d3504520f030db95578ee036b6ad42708cdbf148d4c71c32243dab269aae6897c286ea9fd114981b2ad7eda7c5bda0a86d978be85d36408535ec6b108f0ae96812478a367abc3b326d2568de4ee841f8a13962fdd82f88a1d037c61ebdc9dc2d59161b459886da60599fcd87f4a959a22be446bd2de6ca0f075ddf7e44e9b1c6be851a28c93446f517da4da78d9997e3969ba36e51f432043d0182b7723b4177ee086a189c6d6c8961e1dc0e80acac5b21caf428cde23e3bb1f482a812d9ab5b84abc0841f887c86ae404ab7920c1600ae566459d87d246550645f97c7f603f9cacd1a4ff3edc80f01040d23b78fda4da38afa1cf61cf65736515c5a7d38b6bb4f0bf8a770087d59cfde81d8cd624bd847f3dfa747ae4527cfcc7d2eb6f021fd68ed26f10fa20afe1efddeeb26eacad5380bfbd7f12e4d6f131c031ecdf9bb474fcd2ed5e00621f081c9136764d8df6e0f76aab29f59bd58a63e5dee0eb31eaf6ae06a0bad3314ce06cb8fc24c4f764f6e3e19678cd7b846a3adaf8cf80c01e1e7dd8fd53a54aec77f42e1da8cb5dace6946c7c263db8c721b677aa3ee36bd8b577b9b0b997b9bf0678ad9170a1d8165a7391194caefe4b7c26926a717b20047dcebef1f42f604c8ef48a317d13621a3f98852d98da85dc7dc63e4c5c74485e428be5c472df9efe005b362c6dac1c5f02debf6319853fa13265edd8b6bd8f42d2c5b43f13e8965b0aa779376ff3c668925cde82367044af0a6781a5a159a0447707d0a500ee0932f0921bb3a12f3380886b95fe0aa54e3abf57abc289953f994d27b553a674375958ae23e35bd6f1aad4d0ee924918db2fccf9e800c55e2ad63748c7da8f1790a1fde9ede862a2ef037d48b10f1aba4575e2a5b9d9a0742234d161100c36f3dbc1c9a8609282e5f82ec0fad4c9ce52fb5afcf7d5a16a93d0fbe6af6555a4a81092b0905ea5aee0e4bac273be5cc065a3858826f28e259d2ed6dd8c5363c423319e1071857dc18c1557330917dadbb91d68b910a2ef4486b6d85b68171639fcaa440bfb9f80dc6376c1bd6b6af31f6ef6b4e2a73ee19c8c6cf4876177f025d103698dd051d8677a0ea344f7c1d4c9edf1af28adc40148f696fc3d31f75310a921a875a4e1805a775c7538c3f30b614b375dff0a80ad9d53a559d5aff095876e27b26c5d6e0c78416e220387d8bf75d8c250ee36055019d25eab09bb7c9437e640480f51b3fa06c9a63e25f41440b9b28ae13fd119189cf0b7719b0720f88146c47f1c85e8c4acb2474da1df5f741e682030344e247b047bee9e40a0258226870b44a4b9edd4fbceade6c3e8085507aafa5cee5f010249de9ac0cf2314bedd655a90324621696bf65fb0fbfbdfe0f6d98539cc0ae78337fd455afb402a658c5acf67f7eb36aaa43a5c6aebda1aab48291a8f1c4292414c71d88b1150037301700457830c524d0362717a39f10373d93a490f681bb74c859c58cf344b0716fb695efab770f9964c36652b42a7337af10791420cb06237236b66aabd6b1f92d00b908569f4f7c7438ad7fbf3a2bbb1d1afdddbd9a6fd3cc202222673c5ba8c35cef3281b903f456aadeae35dbc79d323038dfe861ce7585082b93606ddf1a33db860a8030ffb38600ae6dfcd4a45ffd5fdd34dcb0c033251d5e454796095619b01cf0337fb2745230cb865ba18948794b38dddd169ac0c2276c730f39d58770c85081b0e849bae17dfe16c09ccc0ab6a74567f0d1381d0f364ab474e4fb9eed3e6062b598168c4f187f151d36e4cdcf5528eb4d35d1c8cc79e47ce2a56fe808487ffed7759fbd6e8753bc1b795193a120be74e153283ff6e2050cc45870d7ceb2c0e46fb25b79a614effc7cdc882f6ff29a566fbaafe74cd21f23b0999cb213eb55930573afaa2f8e9fcab0263f6e5fa40c6ea3be395313fc5a523f740f6296c650027af8b2fc6a5e4105da6a2d782775355328aa10c6a90da88cfaeac0a8660ba52103115ec43c841c8005048bc939b14298e6e1c43f5c1997ad214edbd0e3787f7d9da0b5f131655b9e74604c4c5f9c92bf83bd974c2e262e43d616d5c96f494ab0930b069dc94e7a63ba79fee96c7a8d38a42df5c60c17dcf4847a56f1c9d108eca5ae449f9f45de4bdfbd932699c59fff9ca9edc968cde872a18dd0c81b0fe304c04d121b7a9cbc893a3fe8092eb8ad223a210b87e1a26d36302c27d5311b046f5bb4d7d84bc1a5047515d49b03b896ee44b09969ef4ee2bc4ca07066abac1adb9d9ab5ea095db8bae66748c2e64ec3fa0de7b574381a50d52472d53d4c05dd0de20cc512efa0c3245754a142c356ce5faf7fb929a779b3f072ab1660d6db18f77b81ec90bf2f2bdf627fa1ed2241f6c35ffded71098ba662a5c03e3a3904a68d806138d2fab99bad2d913a337ac0ec830a93121560b423ad902981049e9aa17d8846f85f5344648ee35406ae0e25a21663cdbc808ec5afe53e01850a9f68e0a1c98027bd4ed21404b9ba0632b12e27337969e7f4ee73826ab70eb6538228c7ae4aba96d372af424512fde11a9578c26dacc46e39941e6119e448914ae57baf32f537acf3b09cc81d3f677e1cc49fddfa1c22b805cc6bb679e7e0e5f5ad8a39775ba2e8c17adb809bc18b61152a8d3a13628269ea22d2fcbde2f36559fb7a4438f70c55009a7340389deb5160fc0a808712d9685328ca9eb8252adc40513bb2928f1a753f12729ba8f6a35f10d4b51c45ea90c027ea81e1fb0881df7677d985d59acb7b4e3006b41c210607f04874c9976a6af9237d2eecd7bf67683828180d84d75ce77b2833077b51c9337ed2ebffaa4fe750a9dd1a2b767b78bf6f966414c7098f5734f70bad8263f4eb28153e272d8045d1d73b9535605286e06666ee8aaa511f096ef7334e87673448ba199a1539fd58c40b0484d742b16f840687e07d43003ebfc3ddf4e62a8afaed2892771ae483ae70fa138381582f20c5f54f7f33dea194f008c23dc889f76b4a53cb61ae04177bed541541e8053a4addcdca19604e9151bd9b8eb0f6bc368c7dc3ad0a4fccf191c5098668e4208690b3d35e4f0d0e83f0a9d5c6fdb0671180ac9660beae4b020df250634cd859cc1503f964df678f4164ea584f39f877ce727f736525e79c2448c71ad6799acd002a24babe8e479c4ee180fc69a908c23a1c75f9687ba67647118e019b16bcfc8af7cdc94320c988bc483c9d08f4a7777d1156c8c674e897a3649b63971af3525f14bbb57dab1f8df9a38fb72a927265166d24e5262e4646013b82586099fa47ceccba42f5a4ccadd819ef93406e0344c41b13f5dd3ac6ccb83c0d0d7bfc3d8f29d3bdcdb659047b87d95e8732f0a48a3a40866767e748286cf17c36028e9f2f1ec56e8f6efb00dcb9467941df7e4f50406eeeb6e4ecec148a43e5fa4228ea6b6f3279736abe8d55027d0ae1221f602d490fc77c49dc19fbf712b159c8e9a89ef78293817b913745364a806cebc3d26c31b953f8d7fdc90da1f32953868509a882c4cc447f826ba02726165b7d7d48c7d4d2c094d10fd55ffb24ef4d5a76ea8447770585b5182595d74e067164f6d2956905e0ad23f51bb3efd6e0fbfab58659f8872d5312ae6fe878e3fd7957fb89cdacb41dcb4fab9730e6194cf63bdb34e34f4ee3178e9f9cfaec4cc8f7cbf75102257035bb15f0c09b7af4dfe67d6904dd449390862c5cd893ce8326c14f52f5af2f638e6f6d0f1877a0386005ea08e86184088c0cf810fa450b7d0d1e9ece4dc3a4644d628843bc35b84917899b4065ea32cc1726bb818e53eeeebf332a9234f6de237c590b45227b557db488a87965cf706e12a12870b658c303995319cfdadd6df377c940bfe0f3534adf02b954ed0c6e7dcbeca51b61eb3ad053d24f8e31d1c06eb4c102928cbeafbd377ab42648ff78d4ec873be16245faa5558288318fd24e3ba591ec8034fe298ada25cb607f77ccc78a93d749ad02e4325765c792b58cea74cab89437a1c2cc88fd96f07c0eee66207676164847e4ee6252a3e6ece4bbc38eba7d9a9125b3682f3df04b4011a7df6cec0b6248559310f86808c0163e5bb640cfb39edf243397bb60992e294386b46a7ebbd625292ea3c99c135c72cec15e5923e10576153390773e0be98470be30095b93876a2f261914dd58b7a8f8653ca5ea271899c92bda5af264b708e05ad8aebee230416fc36518a566e4e2378cb5f55bd9387ca48895dcd081e9eebaca83d051968f6e5cc2e61ae6afd3cc88e8876e9a6fceb96ddfc04c0440ade9a2f2810ab490292202f76eb41bbce3a116bb6b1fd3756ce45cd4cad0bc83da2d983239eaffcf65cd2908727f40e1a440fac5539a0a94d8da0914a1c8ae458ea573bc1089e7efc4b3af54be2853129295292384c840043b4ae52f8fff6c3c6fa4d907d4e42a9e2493420fe7287f68dce14170eb0c8910bad91faaed1e6fed327d96b775d181bd708c3b9be7458f3027f2d58a6db1b18912e922f1225ca8e3138a9916ee0f3e47726ad24958a94a70012b22769f3509aa2b889fd5a6a4a673861cbed2bb43734b1cdb9ea6ea0b77996beb860c67f5a5a989770a5449d13bf2afbf27c8872646cd2abe19691fb2792c02627924ff697baca227d481b47e6381a94d1b63065eb41831e81b7a959728fbfdae6675ae36dae66f6be297751cc1070088242ed460354336f197246fca361ace6faee5af23e6e3555621b5806ea9f4aa04ed512868f70370f7faf836bc328e476fe0e6c9a1e139ec579e97a8f24d782bbcf1355076c19f291591ae057ae1c9e81f87cc0b1a07f26e52d5aad68468943761038e9842828a4e5e26142cb2dd293358932a084fb8dccaee82ab46b8c6902e209087648c6ca93154127bc4ba4db50f699ff4450dadd73ebe16e996b7de58d7945c40a66aedf675344b5845beff8a65c26234846e3a6e41a763b8c219c3bcb4b3b0793b0ffaa2cfc932f2ebdc305ebb34118d7b67d167bdf01eefd1c7d24c15f4923d75fe9464f586556e2fb7556b3d9b1c6c8163ce9df756ebf193901743bba75d1dbb60d9574934f4f7ff0a6efa9d09603d410c280ba26923f8f98f2ae177d23803e3ca4722bcf0794301b53ad721d8a507bb777795c5f06a6c87f640aa0e2fc6515835e5b74b2cedeeac1c725b102ea17a726bc4123cebb27ad7a02c5e7f47d358654d18e6395cc0a2cad948eb7c41ad3da74aaf425281820b1de5700d245bf61b689bdb4b93d8c8f1e6ef52c698fd83a8442e2b186b3b3a958ae72c30731077bfaa6eb59f7798bb67c4f4380d210b38df6f880fccfbd827c8e209c82d4be4af4b0be24a0ce5b322a98e9e1ac45343f2d3da30f797aa0357bd3b6375beb056bc69ea4ff26bff1d84f48844e5a713441ed64b5afbcf8f610fd9fca25ed306ed60ec7e0b89d466c6ca44663e463687b0ed13d7e4e1f60bf5c128fce4bd504e0ee97491fe43d484fb51d56fd4d57f516e7a8aa2350547eff1231450ef9f724749c21ccd442081f71dc5191e4837340b2ec109261a04df744ec6588676e8c6a4f1e946a4e6e5e8081484bfd3af5b4f091bd3db2bfa1656f409341a45ee781227efa442356cb4cbb912d351342e497b18a4145a352913b9f2c7e083c0a3b757e540cd05ce3d0207a3532ce5cef7f5ee52373f1bbbe59d91adba60c59b0de52986efd788826e1aa0c1a590f4191951ab5414b285a81226dbb106e0c2b2f1a05157a1f911c5de594de79420e6112e65670063cea983999fb406c1ac1da54b01fb40b873c62eedd8f6d43f3701cbf8aad0990219fac6878f1bf5cbcb73cf90a43bbbcfe1a688ee37fb8c2e4a05153295e1685ba29d7bc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
