<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c195c5325996c3af537c73d56a5ea9682781119148cdb443df1e85d0829b4ec9ae26d89c6c92d7bbaa17d95bd5cf5c8a532469428f41c8ecb825efae7dd920af6408775676f80688577c1f19404df223d2ed7e8e234d556d48f841dbe71acc5bb40452db42f2af5ac4d566fac71e0afea6674a414f6bd01247055d3c536e3557463e20c9d3d031ff697f057f15644a646beabd174cc2dd57ff28a31992bfcddcdf212c87305296b018ef76b5be114dbc65e44c572a9635eead11f0be3e9afe34d765a398d1a920f2e9860f230c0b588ac778488468335949f456d312a9d516b8311071cc55c7a740d5fa6924d0c51bd6eca4d75d1162cd68a816eb30004e333522dcf06588cc21d99514eaff96a525f994d5fa84ce7b37c68aa89173f9cf3313d9d0566f6b66e7225a79f5336b6983256e591dd8baf838f6f4a911d4d37d10746f2eea2e6d22ce15f31cab21666da327c64e3436c15c003d1f2dc6927d6c15efd82eb789a965abdca8182b000f4456bfdf7e887ea39f6339e68e8a5b616321bb2462dd4d87a959da6885dc3d750ab0517b32b0d4762d3d95590d87881464e4e9936458800dd6854a2af892b0859f41080b5c9112eefbd51436862c0ea12a622fc2745e541120d10162fc4a37f8882951ea8db9dcefad2b59d59fd8618b4018f6313eb7be7597679c5793ea238200d26bd8591e83a002df58db2e181de817c99659be4d37d02db3f14475a9e2fe7da47cb53b3350eeb5f149713fdc5a87a142a968c4cea5c0b76e4f7dc6d1171b6b08d612eb78c54f874b6156caea21b07c97416600008e926ba1fa932e0028feb4ea6e1bc0b54cf3b89fd946e678e70d4d06ee5c12c3fd7c7a25231397e565e374db6b8c8898f462983234d61ca5a3a051e419ac29915c97c9090a9e58995800dea8f97079214009b8a3c77a3206b87c9799ffd58a645c1dafcdcbc28ab69a6f89dc376664d65cef87054735f797e3b188397f23937b46cb72a41688635ee73ad3acdffedfe720660086a249f6da9bf9b9297dd5bfe955b8432abde4aa2688b5164f8a3965eef15fe96ca96b05ad33d4c4d4d517a682a62b82fe90c06ac9e1db81c8178a7319b56448b419071358b2929ba3447958a0e8105b28efc1868645a76ba936d50e38958f51f54bcef6ccff8439271e2848f302626c1f0574d247111bb86ec1efb4ca6f85eb6a84503bbeaad79db2ada7cfab70e8b6dcd98aa3410fed1f9422c65971ec9407714c71a2fba4fd5a7e918527cb9d4036d3c0a8bb5a6084e6a820bebb5813e7b535185c57d42363e9a8d30dcf32fda9c70704a14b629dcf1b240d7714c6ace752d4e6b66ec04eb90d4c26e514691dc9928ce445d3c129848bac7ce8ff7c4db08a39e4685a2c52f3732ee6294b566cfa9ee44368d93c7a4baa40f9a932b2714e8368f059418733b3aef24512b8cf265f1592e607b88b9248dd9d4f46327bd898b7821ee68f2ef11280c05c9a3f3b22112efc4be1cee0d86b8dfd326c78c6eee1b984effe9c6fa4aee1a86a2763361b9ce7acd2a10d9019d0780be6ec6871790cc29b20cf7ad1bf94a4b056e0bafd0e2fd86f4559aa4ceefb3e400db3e2d1655e42666e24ebdb5a365b979105b6593c9ef304099bd572fc728b3f5a0b082cf65b52b35616aa22577916f01101e8abc89cdd8040cc9835b09bcbfcdc4f7b9347e4a242b77758e5d86a831ddbbf040818f8b8251d360ea6cd7e5ae697f2077cdbb1ddaf65c152bd91cd4c26570d51fd204f5283dfb0b764c1feddbf3d1ede7d28c8a23117348decf7a73738c8d2c3fcb8607df7cc9b55da76424e49551c0d2d086616408ac54d19a406d1a1bea52372d46040d09fea5fd234b39b07e38af4fb80659d00bf7b89858af141e577d0cf013387dbb79d37c95d6212ad6c7f7d43d9b1f356f419b2e2fe38137ad381a0de9cd8fe823ffd118c8e67523725f7c9f88108415458d156dab43dc4154704d4a7630d92376dc8564f5ae671d22617c7970d6d4596cf1981097519e9f4f18e79e7b4b73bc92d0ffc6fa1a82741a3337703c8ec74eeb226f5fc496c0dc478fd3b5a78417ca1e791c1454fd3f2aeba3a7c678433d7b0852dcafecddb87bb0c2b938a56fc43baddf1ef5cf77e41116419b8ae16980ad456b92ce86b374c85174d0a42cfe6c839bcc799a885164f8e6e5df0d457685fc51151902014909fa39532744261f540e13d9fc2e2b6fde6d2c3eb99f1665fa73880813480c4bb6259f8db869b0d664a2d2074d953f147da71338fecfd7a7f73dfe43aa2a8fcaa5e52d8754b8d6f361d19be2e36fb01b830c9f302d6b297e98c898a580ba4a68e883daf273724b7d48caf4d59c940da12fda21572580929049168cf6741eff5b11e4b798bdcf1377f5ccb5af79843dd98bc171973f39465154aafaeefd153fcbe27f2670c632efc3a0be86ab0262ceb5cbdc4a2d530885f47155d827ce7fd40cfbdfc33805f225b775b927866785468569e032a76cfd745adc60f227cc3b79a12e6ee2477b74803240310b742fdfe2290d1f0c3852d821bf8b2c687d7104c1194f562e7b5d468a316ba591babe976b457da45623941f7437c97a17c4d86f8de03f0c9d5c470553a8fbc91d8218085dc8f28766f10ad0c781f2b9f257073c9f63714be0034af69ffcd7927102072892fe69fcc5bcd20bcc86a6b694ba16c1a2c6bf72693a8f97ee5f6b99a17c78474455b8bbcec93df9e1303dbdfe1d328a5ce0f6e63a39fa02ad1c51a4d3e3cce69caf300665b1ed44affea1bd9e0bf79b306920682fd921b1ad1ff907172e41c621c0f38307dc606d4f6410146911238807d3e090e7ac3ddc3cfc04e9786ab9f190c9c52b4b80b14ab5a53bb9bd27bddb10ac25eecc39421baa88f711bcc2a26d7023858774ccf4e678409a4c1e3183cb4757619f073ab6d466877238c70af2cc57a99b7879ee6fddace6a5c344a52a1f3b81733e1834f9a5cdb7537054e655925fc8f6df10b7a575130ecf730ddf054787f36d19f766486d2d4add2e4ea87a104cda313ee30353795a91b4274189ab50832c5420536d247e3a1139142db5ad119b7dba20641f866beeb8f36d1f95e6726f8216a0b0f33afd30165f36872c48700acc59ff9da511af285deeed27297f4d1ffa5a619b9252ab73a6aa40af10c8eb4c7ee539154a4880d1a04c0bec4fa72bed19c125c23f1109b5026485d069a0a730b2ca3bdffde8cb454601981dfe87aecfa5dfd505131ff405974eecb1b36ff5519c528d602d4d4bd6e19d5f163c96465b90b6ac6bb04822d07a58edc4ac1e01df9188351fb41e2d826e2ecac14c302e40be2078deb56367c212cc36ee9b9c83c73d25a9533878e930643a286f72b281fd9372c537ae44b32d7e05ee4289f86b2bb1b299f4e383a8a7d7d94fbdd72de86aa0cb35783467716cb1f61dcb0d9cdb790931fdd448683e722e32c1ba4a4a19a1e61b0019b1406819744c717c2f591e8e8c52639e183b30c43abe48d1162cbb4587bc8174d44994a3da38e59da74fbb0e5c3456a31799f0136a656e9f6b6f4cfdcd7b95f68d1e630671131d0c42237ae83060fcc165cd1849038fe728f1a49872899e3d8b846b950167bb5ff87c81ef7831e3a743374f1f4a5fa3fc95a899f13b547e1f3a0bf702971a4fbb4877b07b39e55be5fd28c5a507e324e1134d9cda442ba7370f323c367a73c683736b6a27fe2e46bdd8d44b25971edb1aed9cdfe0765096c594ee1a4b704fa8c703dc5d2e3362a732cdb612de16383d03c3f3b82d7d0731e14c829a7d09a74d218459d2d698af14292bc067af1ab45f0a12d85049a14596dd48815c4c96a2854b7ebcf850aa72030335b23c2c66ffca5d412ff2bb15ab41eaa545cc5ef3b2fc6fa265ecd4dc434b6b320d5cf3f252ff90e08ef130a4afde0344853195edb325874bd372bd613cb4853bf7e9efb80ccd1b10cc10b3bda1d08f044513b9189e586d5112fb777706081e3c806b1d331b2e5c046b275848786a0e1fa26a1908a633d79e2d888a65f7e6b0aed8c8d97d21b85862c03034210cf23166fb0327ce0814644f43b134d3152e2b587d57f01ccf5c55d41f9bc2cbe255fa32945f292c8b3affe88788c5d013f566c112a8634eb688864c38ad26b051eafd1e0d94efa8b7d1b78843979b6d6ac9bbbf235006e0811fcab718ed6139bbdae418a15abdd8fc25595889230b42f3ba3f031884dd4a6a606bb64c71e8d31578fd4d75fc542f41c8080d8639f783bd36c0853e8e5b3ca5bbaa06f61d463ad1c2aa38a34eed95fd09fdc857fd9579ead30cbd42ae484ef869414ea00f14cd738da6f8b511a1790278aa288ac4ea4c3784cd40371a195cea7054c81ec3614b71c1ede0c3ddcd33c2a0e259211ce98633c54be43c6f37892748e6054c2ee85b642f286df81b9858d2e66e0f1c26495c8dae49648c589213874d623559ecbbcdd153deb005b482204f2f3df722d809c27ca73b3c2b610df49a1bf1a0732d3ea94e0c1f279d127f0286a4a9894cc1e04dc68c2d00b855e7d0c8c1cff488bbe3245dc0d96dade4c247a1ce91bad9dcd2a932e0bd02d65c2a068f028a0037e5fe24c7d66dd761ddb50542535c751ea120cc64cf28ebc9c287e1b08ec0f3efa40af5fb3377a743edb111404844b4008a29ac665df6491d103428faf72124fc515421d05724b7a9bdc4d472408f7a6cd45447467ce73e2f67db788e3db2dccf9823694db9401bf8469d019dda51559b6028c6b1a47535c660226428a99ef7ea0f47037e16306c95f3b366b9c7931f619611cf0f554c8e80d8a5c238c394d636df1c79875ad64b03791bf933ea8ab28b93caf1398fd7202208f4b1c98e0e5172b56e085163bd869ff89100722b2a28b6bece79660cc337023d33194a6e4bb1ea461f88bd2a9d8b982acd2d04101854be1af2e981bcec541e37109f214f5b293bb61034eddc85a457df276db22d9efbc23cd19fe9ffc8f8f0a236e35d82dfb9deb4ae91de9c5430c59c40853125c1a607f6ca369a20e54718e0f227031ae74fd44cfad65d193a216593773a6bcee7b1f83337641ac10a6e6f2857ba3afdcd407704e2e8c1f5c716ef4da25fe0cb8173dddbcf5650520662170b37ac4bbb75ce20f8a080601625fbf49da6492cdad978116af2b43c5f4f0d7477e94a8f7c12199e9e1772ce12c880f0c254c2faf5c80311d7d4c410df440f20ad502a125138fa4d97b49cdfd809fe674c79c90c0db749f0464d25282e66f7122ad4556c1c9628fcbdb6cca94dadea700240ccaf452cc84330d422ba658314d37fa973d086825c235a9ea2ee633b3e4e0447897aec2e913d219dfd45cfc3d2ac17141b9d09fbea17dc2e232f029cdebf3868adf2dc558d24b6d486b62bc1c6d396da49b18775323c539236b8a69d7891d9c6e149cc3881f0dce88bbeae05932aad689ef4180328cb76d08dae3b783908089ed56af8e06b27e551ea1b9fe61e3f60a5bb23b94b5f7b37de992181c80d4ea0d98478616c997205330cb2cd8208e574962636a974088c409ca1ae648d675db0170d362e4c88190df6b3d84fbbf0fd03b7eadd136292cf71cd2be5d3f44906ae09156b1473f7121200fff179475f86623369f2c78d5abc49d0b62fa61e19eca7413045478d0e456a1a1a9106b7407fc8a6202e7011b78445d6edbce7c0f4ff0dac641cd1b32d56a9b22e96bfb5875ae5ec8fe4d8fd4a8103b0520618895bb50af7c582674b83d29dea202355fa0278d55bb4a2eb50b39b6411f8e21661046097cc02cf0e4d7255830bb8558c16943228a36467c00794753288b4ae9c11924d72b03ed7809de7acb7a35df3507f9fc88198dc0e6f5ae52a808227f393b9d8364c5b24fa02cddd52974c2d23b1a3cd2bcab4762f4e51ce052a69336b7d4a56d05f46823f5deac539aea858bf35b662fef6ebfec5f35971ac311a00b40aadba8ed595abeb4f5827f7c06272813a7b1813b683a412efae87ca66be6c909716d9c210ecfa7a9b35ddcf76de4efd6400febbbdebabd808a3475841c3160ed730a437444171709c3a644f527cfb774c50c8d5620ff6295e6d9ba3b5c6da936e69d9520fbb91679821529a7157437576c65caa11fc21693f306f309816345fa3a9c7f78fbf5b15a6820dc4d1150b13ec8ea4a03a6197f00b8275573a2511575e9ca39201c343996f517d4524cff0360abc032254d1de08f1340bfa5c0a5e4df53186920d1de14b3400449748fb15b3e0cd3942f207bd15555b8b36768da39e086ece9e6df66bc33f3fbce116e4f75bdcadc18e377c9683c71d1066a746e4cbb00dc7be9a326d706dbb6576ac635b2643901dfff21e4a41914bcadd4fbc79eefa68f4f20096e250bb9fc4c9c118098964bc103e3fc7a75448cdee9eecb7206c4743b86906af7b1d02d5402f29498e01c94e7c857885d831d0b317af0e94e71dbbc1b6fd7e8448fae5a37375c8af484655508acdc2c89b49d7d240a4eb63166bfc01d4834eef6a17628cdfeb7ef8724811dede8a2f661ed571a56787988a0e40681a69d534f917f51026fc1f9a99ad3c4c49701d19acca34e6bf9b6203c18e773801d391371e84d6ad644d828362244ddab332d2304b03563cb35c554c09605f2b5fc87715298ef5dccd9ac8e1b6e47079fdd7003b17b3ecd31620f85d53d0ddc8780945930710e957be08c23b9e2e9f5c080350bde83df0f4f71c42830cc77264ed3d282b8646ef760870c4491d129989741f0939e8f2ad6be347efb808cd8b28d66340fc473829281a04fb46fb281e80eb067151555513c821eaae9a05aa408712f2bf57e5cf248820c5bdcd4c06578bebee376d9caa928792b6575f1e7c2dcb0a22d05ee41d5db5f339803ea4cf2dbeeea86e037886fc195ef3c53121502f075bad557a31d9f5fa3f4a9096ae22a69cd2a175a58775bd39e6e9d26c089077c3ee75f782cdb31e7983470dc12948f964de79b94ef332340c8873b10f46aea06a267940d54d0551c1b70f8c5fc262d20957faf7a01004f3a8c03066ca39c2647fab26860c0e3a276fec6405b6f2eb141303390743620dd5e0bfd1c04b353413d417d0ee11ed3b388597ea6aab996ecc8578ec29e65237d2fd145e35035898a69c674642a33b9ab02ca25d8560add7494c1d860d7469fff279d38cb5be953c3dc371e1973b194ddb049be3d28eef2c413747c8bb5f92c10e81494971f9e4ece47917d954e06b40d22c3e09f81b0c07013c8c276c0d26516698c3880349400fd2825e273cb19dee13d5c9ee3af15dca832ce49aafb3d9d50911da91cd05e2c3406586aed08560fc3005a2d135b4a271a93bbeb02750bd58bc085e0632efc08122aef8728dd7c278d47c83b848e0d92737c0641940ba6ead86f78aff3ddbe659a8180d167a3db342ee09c3882850d2781a35271f8848cf9721b6c38a730a3e8e3a8d7c2f065781727dcd653a8d3925fff983d949856c09898236d9c982389488f1464f1ac2fc0545d6daafb586325573a33bca72b6aa3f3dea0299c26ce456a023b59b5fd30e8c6a243888bc5a02bc54ee6d1b4de96a753d8459263983ac333b24c53f49b7d965265149f3c587329ee5947355dfa4a4ec8c4be6848749e59eaaa385b30f01d5fe34c92543dc90b590f8036074ade9e7c865db3689fa8fe9cb64def07b58097a497fa0d272c8c9c57ead52d0a4347107cfa2d112f5ac3c5adbde0f099d8f97500a5b89e6224ccd9062c1423dc0e7b301cf6573b7c42c284487c27289281c861dd104094aaa1ebae372331ab8d1d1ffa30ad70f6cc5652d619e3c71e10764d43020b3a54996557d4567d4735c01a546a85cc545261765699dd1ea7716bcad13817b858e57c3c41f52b4af78d9eb66d3413c35f9ac2ca9da0e55863a8157acdea6b0dac63dfb2f5e285a1b03bfefc554c72f69b936796c51d33ed6dca410d44ae383da5042def4ad7d31228697004a70fafe94c2f3da9e16f772029d346b16c66f503f623c4bfd390b2da84666c930c6d0865b3962e59b7c6802ed3bdb81693b50b792f56032828f1ad354a9f2e963cdc5736978a07c062f7056e8ccecf749c0fbe4f3b327f43ff7fad2834f87ff902ad926350efe9a0d491d5b4d6c694da6119796cc7d029b9cba73f2607636d39cbfacdad3bc13254a263491d61f6a58ac9c27001295b8d8850979b78b5f3d175ed2a31ee6799ff50bac2402df160e0d6332d617b1555937c6c7994ba811d34e4453805b0292cb0d08604b89bf577d34f67a90e29a41bdcbed290dc0b2ce67c882e275f151cc5be4146721ca6d506f795ce4b3cecfd9d14d064e5c8bcab27c93821f033689f5518d463439c31373b78596c320ba79eea6c752afbfc0db2bf96b4f62da5396425d673f38d9b40aad1331bd28c138c1376e7febd1f4dacbb1437dc3377d23a6cf2e0eef2ecf619d0bbb8c30dbf01b42987e30348cc022497a2ad510f176d9956a50b29997af872dcec69d3962d88812496a253c44038ea4d339ac49dd6ffe06f02afe876acce234ec8a307b21089b11a85ca5e6723d83adc92ce6c04d0500a4d09086a38742718315ecb1abfa0ab17a366238a993ddbbbdeee5f2ec4aaff83dd38eb72e08d918c2afcb0c3c274153fd1c8c526010fa6e3a9240356bb459ec6f9f1a39b4b1bbac38176e05c246f12ba95411effaca06c37ddc06315b61d818e874ab60f383e48e5d199631202d2f83b2b2f7e451cb78ad4f1cafb11e9057bb1ff5a6fc93c385a3a4a4da2173022492db405a434082303649d550a85a707f55c88ea3e88a0ddc0d86fd436c98d9601fea1c7d4149d14578bab4bb532630c5483e9d56d3d453b1d5c8ed85f982857e83cdf7c0a67f91139a46fab72409cd3233ff02b4ea9cb5f5624c14fd3303c37d6dd900b7235c7f27a4e783c7b552342898ac049493754626b7c4027afca5202ffd1b98c9cfcce10faa1b0895697360d6fe389385d4693fc191fc22cc670063bce26c604e4578eef30b67a710ed4aa4f743ffae691795e0efa1d8540b23bd9c7e7dd0d96e5af8399b178b7a7fdc387e619b0dc1c9ad70cd745a2c5a32186f4b66bc27d3d1a5c5055ffc60891ef68b3f0d05219025d6e91abb90880be1a7b12a2d3c0f7d278fa20d90fca4a542520d57da747d29a91673af6680a0c5561e0ed5bbc289e5451fdb496fb46c1d746f6444639f3c51852eeb91d29c9a2ae448343f23acf8f8679bb2807b48418fa8d9935568c896be139425408aafb1be4505bcb53c9723252925e4b774d929c71ceacdb77e6c55f941ddd9fd181168524bcc7081883508af6afb1ce8f2feadcddebb55c1236a3fc6f60990c0ddc55b8fa11045d25bd629d7511c06f5f854de599c8272fcc8975888e2a94f6c31c25fcc0db923d3015e135b669f3ff038ab43b060b6f4c42f5b6a5ca9b8aef5fc06184b4477fd8393e55d9a88b3b7b8388a08d481f67cab7f911c948e6f540e64da2ed2d6a85e6410a66f7406c5740aa7b14c28e1c9b91292eff4831506bfb86036da7640dd3ea0ad19b5b1f0ce42b983533f1a7f8858a9b14dd343e72e5fa21f22df35fb2bc97cd1ec5929f41fe08f34725b7e91a61d4d440cf96dc5bdf09edb8b6e03419063e3f8c694116d6cd8e31139b2611478b022910c885e01afe3ab9eb96a76e9523fad096020307c9a942a28589a972ab96951516c0f4148dfea99eed7d73bb2e423233b4ff6033cfa4db85d69d177735f56bfd421849ac5ad91acfa030aca4e889fd0d60d67a2b19060d68b740cf655e3e136089e9af0b85acbe7fbbdac4467c45c941b9b4d23ace0ee198db6eb5a6264f625980fd744e03d15c5bf94b118a4e5ac63d332b23c377fe35396f214f97a8487d4e3722631765bac437f6bc45515dd5a3e03b1fe970d386bbf78c762daedf628426580168c22267254bee4b8b7656479eff0b05f2ebfb88f62957ed3742c1459aec349f041565280daa8ad0fc0a20a259919094145f19ffaf82d195f7e23a4113b5b77d4e1b04f43078cdc1393ac4aea048853790d5395a11698b8471aee1bcfb476e77193d59a8b9f3f866a3a54963ff02a2a64fb951b117d01edaec01a873c35485d6be99c52a48ed1e3b49243c57e23f8f0bb96c51715c33f7102f0dc4867a0fb729b399fd2afd04e7a9b0eb35374d7ab7bdf622a3c852b7cacb0067bb80e617281996658727daaa7a4bf35530728b42756f6e541cb99b02b4a9928e20a9deaf7b44077b3bf101d8562ce20557da9b286c46adabf4a5bd499d0669982cbac3f2f019a4974f16afe05f87d9cd292c574b0653223a214c344f901e6fde4abcbabfe35d81e57268946d583f1740b5feb6e815697248eff6b8abdb94e2afe8401020418f53f08dd1c21a7a1f2254dc252414c91c6232a23ddee4c2b3b6b32e6ff39f583c13ac907b8736d4e075ef26f80cf0981fc2e5d7706a6eae99ae903c27f493cb1d8247de616cd456a332238f6308f03e9a7e2a0217687909a440fa49501c644dda52b4dc3a8562dcf629bac57bdf0c89180ab75bcbebd8514da759725ab0488967dbffee57bc806a77a2b37a505eb7ba89bbec39add5fc0fc97930e03c137f2e95fb7bbaf18b446083176e3e3a0b0e21abdd6deed0001d109ca812fbf15b1a3eb946fc0e0adfaada990bc8081bb15961e5f53760e1abf7a7b6a8dcf9a3b44b94b914a9eca08500876e4b16dff227b51fbdb5453a7cbb4dceeaae1ef295bb76060c17a746513491826c4d46e56399188e61014703d8e601295a6a0f1a401109ecade8469a926fbbce57db1802d74db77ecd23a01826b1ecb5ba8cf059aa62230a315e9e034b2445f63488783a3f33779bd99453cd90acfcf6b0a47631f1ce6c37da162f154473229b9741952ab2385541a577efea40e24341738078cec4fe00c3c34981c67076ae0c373ee45f0b9247beb0ed40adee0b798e86793c623528d473af16c1f19b50bb2fa6881532d3612e0ecc0bb38b1559f9ac8d33ab8cc2569f0abd16cbe0295068f0d12321c162b86062a5997f15dd6d31a2d4a08d50e8e388c5d17747452c464050b37cdfd0831d2942f30d219d8e4a05a2c95b2e36cc433db0c0b033749c2de4b17db287a72b2dbc000247e55481548b3b96287b874ee67bdf899ffa6fc4ecde840b1c9be9432764ab09e54aeae6916300bd365d715c1d952be9e1198671ebd8b4abe2522ad92e27748dbf4a830fe6db2b13ae3d12833f26d4edb684ce3ed34b4084a0efecebbe1596f20d35bd2e721aba9326a426d1b31913ec09ca9ecdd38023c25a7b8934cfb8e97f1fcf3a9a40526319f4102fe6cf59567432ce8fc4a08a354e4ad4c79d853c7d8f47c5b55a0ec629d83bbf2333ed0c32f373ed61c939500af6e8425d3316d38a4674a2e4713e7ce2b45c2f8ec79eb1250b661f8b8c8408742f1ec04d6fa6fc08d74c70ecfc9e380d50aea32fd79ba0049f7f0bd756c6792678be01537cead92d20a5cfa310b842f69abc49ad379adb28dbcc40df33c4f6a5e7fd5620d277c621c7e27d7ed4e8293a02c4b885c1d1e0cbe33521cf860bd7b9a6c7724c980915c945916c6f4c32bbfc88304d739d18dbe89bc72bd0fe4b5842ffb5dbb878602db3326626c3413f481cd0a98119ce7f51f31c9d3d109ce554428449423604588645747bd7a1c9bbf2e1000ce12f55de5fb09691db697602f3b26d20d679dbd0c7c5ba36bd0347977dee9cc69147096cd8cdf98784edd0b8a854939da167f29a99bf93fb5d7d0ebc72888f126c1bd25aece7557c2dcaf03e90212d12fe716fd2dbde2c474d92c2fad3e20dbe7db14faca215b73d7ae41ad4791941f7bf510048a00d13c80671d3e1c01c2fbe9ecbd49d25df771eb12744b6cd6df03e40841fbfb248186a735171e665f36bbe38c91e9513e14e423252ab3adebd23f34890e54a737f1c0cc4f7469335f4ddaaadb3347b6d58ffad37b96004e78a907d9ef8d8b5dbca86402f93407e61ff7a1a6218d066792e757eb3f370bfacdab40673c9a591a5c5d380b80a483099e7cdc0db5707365d7515327362664a496a2270f40faf6e15f50c3973d815c4a51b3fb9012b834cf89db2e58a62b20d210ed31ab5f0a6b2c4aa816a9d0bb24ba45f6b443f1db872899fba901cfff1c435ef7d42f80b9d01444aa781886012b31c8472cc1a10f6753c130a93db47f4ba9bb2f93c77400409c6652c9367a966c377faf95c7c14eb2880e68c5af66fc34779fb522dfad7c0ea732e90ce020cb059fbe907bf1b9bd9aaf2283e87153fc8ad87f6c7795d966be2bd955d2fc184d8437a0a315f604925ed13bc4d0f6738ad4850d406fdacb3ff8fd2070635b03cbddf95234c569c0d01c235acbe005d44ca83397bc4646f861b2862bc72760a4000d1916a378efe7b8bf050044dcb3785c69165f028f617e0cb54cb966ce22fa0170d393b362f107e2289144fca6e3449c5d373d63d94952124172a7445c31afcf525046d7dae9d6ca44279f03a5c65df48a1f34d29ca2480ad55d9b131386eb8eb0f892bcf73d107a5f981ab98adc323dad5a2044572b47b84f93b8796aca0fabe407a60a7322e450501e4f9c8a1d90df0e7e3756af76f8b6d8dcd3e797a9076ee35ed03ba7c221b91252db53a54da010f3103e3664d9f5f9a54b99e110e48564ca0dbe59a29b2dfd49abef1f52e85824b0a4da7e4a42601773f0cae1b69d75bdd964829306ef638286b926c433a2e98fa67a7c5bacf7f4c02a3dffe6a9be7f8931c625e54d6465d778347cfe861584e40ed58f2437777d39e66b393a34e4ddddc2199f712054bc38bdf84030461aa78f3521dbccb9dabf34c9f7d35eccee332ed2055d58bb7bfb91e127bedef304888bda99c23b6d5163912c17ebac351e2ad32d67e6b2d51616f757a11878978cdb67c5d7744cb11430402562387d354d1eefc119fbd92811fea2e2dd28187938b5d3d555ecd121e7ef7649a83cb8b841f28332df6c470c5c701cbf923a51cc84e1c5ab8929f690e82a4865711b282a132459e0fbdd06f22bc327a68189b60445e7a6db9c16f30442e5df013efd7c39175ab183d2eff08fa6b447e0486eb71295afd75bdd59571042c2b95030fb5668cc291bae07d30411a33f997e55260ef99dd68dce85446aed579b098405129c0841782e1735665b4eef1e0bbc631a3e4cf33de5be43ffcf96e517e9020ceb782d4ce399024645565ea87ccbc1587b20ede8cc0cdd0318f87b00bd56a3e71045803dbf7b8ec100167553ba104893bc758f515b6bfdc278ddf7aacfc3744e1c8b9217f0f94e492f8184a96c0d8e2f4e85b3d1c9823ecf71769543eee0f0330a90055c86762071f995206f83424bba17af141e8b06b3d9b446555fcb25f3470aab1f0206ad1332df666dfec90b597e6404450b60f1a4760b7d92fb9e4d7c2c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
