<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4995c4f45725a8847c639ea171a4c98aaed5a30694d90f7bbd65532dae872837e8b6865e80794790dcab830946fe479a9f36bf3d6d812950b6833ef1d3466322ce083c575c5243d3de21629745c38df5ca98307d91ac43b077931bdc76d39ce92da849c916e175aed4aacf43659f942fc7952e02a37bf0a2f9799616ee75cf63e0739bc141ed71634d27f321d98e7a3a0b731e29971eecdfe11e5fa4f7cafbce303e974f87051b76dd2aa965c724523f69c4f87ff514bcdccf8290b1032e512ca0b6bbfb6ed991b1970792df6d4c06c10cf9716688b40155c5e5c6c20269a868a4a3975c7e99fa02aa869616d3704369bba19f98d477de89757d26eaf9722c346b5ce970be7b68901e248834bab478ddc7cb4ca6dcbf4acb1735041ca51c0038d68a033be91013ef4e7164fbb1e1d5257981d286c9a958c27cbe7255448c7065802f9f9772529e8a8cb13608b854726647dfa9e75e336c6e6c8f3832169f266b9246cb5b07052701c6bf2fbcf44ec48923b5d08a371339655c9b3ca79f472dcc25ff21d057dd5ae0381812442623f470477abf56455616baf8180b40b0d3b8c402c0c33d644a285a9d86f8e01f8c15c52b268264bd665a8367908fd28e29dd6ed7f14d7c08ac249ba7b2df5749803755cc331a9863a544da77bf5c985bd113579e5c8df2fda34079d963a31206c90fe43a5cd9321f97b5328ebe90c7dd029b08b132bc2f772bbfd6e09a348042198f778cb6804722ebd43d70a5de65d517663c770d307f5e91a935423515f53081b678ef988adb8d49f6156ab193b47392cb10170eb70b391cf1a685c9d37efc05ae9eb57436ad3c01ebfdb16d65ae188d7f94b66f0874642b6bff8be81b2ddb971803db4cf125a8c82502f67f8a739e1bc61451325c8b1d04ee8815467e21905b9666c5e84b9023c015779b74974436ee02de8d7da7b94d8040a1b0062c6576402803ac8a65128188b19244b3c56576a60d36caac0d3af890d7c45ba1816ab7c27110e9b5cf65663778f47893427145b16749d9efe1b63df7a95da3a0b4693c5c9038866eb7b76b01156d14a958821a50d5399443c9a6155f83002dd079c4ac62168866078e5ec1476b1f0ae27ed86633ef233ccf43b5fe82e9c0cd5c5c4f2a0a1351d1bd3773c951de608fff2e63ed43db89413b341b71499500697416ee3cc9250b6c78b4e733e1fcb8833e16d76a99c422caca786f4bbad46f054c37c2acb3ef4bf019b4eea1d70c9065c44f72cb7a279b7f2781dbaa1e97fd057380d6efaaf37ce98f006d1c56bda5be45d3925b9e34f881b91ca2694e9f1b316f1feb97e5d54a7c1c90be841533a2394a8b8f29916e098dfdeb2ed9ea9dc7e03fd03f08dcf9e22af659a2bfc5f52a66dc47c3b127661393a19867e0119ee828b1973495b67bdf3d9d4fed6bf7c5e7ea9d3cfe683f7070e804b11d209a9eba231447db20f9876051c45f6bc21c85bd380feafd790504c260bd48e7d654bf5b07fdfd2b0bc9d663e2dfbc6f9ca2b670733e59303dc56d2f2e7c395a65629beeafb0f070d83a794472d876c90a5d3f095d70199d0341468b5a318f7ebdd99bdbc3c6703cefed783b30d74724aa9716a7dca1dc3f942edb316d50f9623ede3c09b557f339e0702dfc42f427f22def8e37cec6e76ecfb12392943ae414a30d87ef57348b998a596de8b61986fbd07c8c815092a8e549bb853f96be60c3d3b14b23ef4f9ced0f320c51c3198b6f72574f3914590912b55c13f983a8a033ef4d20a5ba18a8a76700e5bb9abfdc39e2312391bf8d2a3bf978d9c68c9cef1d9ab735661bf94e98e6b4c5691b7779d685895eb1428eab42d5a1e705ba1287859b70177498613d21e4b94b3fe9dce996788d5f3b14b8036b86ffdaf253ed0fc2e6345f8e9247ecca5f627837817d4a1f04cd90cc5a8a101a83358b616d91dd1e6ea8b64c37b0a86ed75996982f1383d6e9b0a7510b385b452ed36905f89a5968953a452fcf0d11e5cfbaba76b64f09767d3edfd2e34c2d18cb039ef44b5e6192a2080765b43a9e62cc3013472509a36acb2f80bc412bc4b9f22cf9faa6d1b3b692b1e7c700261c1d615f1463b7010016fd343261f2c9202ab8968495ba2ead6a2df316e1b9d8bf5f476da0003df695834d9010a233461f1fc0db6b61e0ab5c7b0199ba8f086c91cabce0d8e62d6b015ba0f06025471cb2a75c3d70f6d93d603ca3cf5bb9071755e23bffd87abddaceb805f3f40db3a4afd9e2c2f1d2056f526d190798a872ab6371fdcb1a27f78d4984169ab0937221d9b9b32ee19bbc7529182e90cbfd6d9c5a6bbcc04cf5e835d6dd009db31769ce96fd79ef42f7bed58ff4e6dea73b9ca7a51ba8ac241f6efce01eab6990185db5c8f2cc7353c4b7b226e771b03570440fdd9a76a2ebff1040d390fbc95c5eec9989c54158a9e2eff03335dacfc2dcb238125e0486797cf2b588eae6ad47e9fe1d2a6d0d0578fd741d6b22246a9692764e6216cddb6853acf02ea21712552bbd7b338edd34a6d1eaf4fa2d130257f095313a41d5a5a7e683a26061f0bcc6af0b967ac375bdf1a03960143cb8226dd70fd4880b3664e6205976637c00c15f5af2649e40bb69a582cb553908924116cdc5bb6069c48accbe0b81abaec8100960b3c533adae35acfd01b8ab06c48c495970e3c2ac178e54436d864ee3f326191beb8f1e2aef6b311b2fb9a72df24e39698d00cce58762b7fe2466750bb9499b421853e54411b70dbdff9320decd6e8457dfd81cb71ed6c6ffbd76f197b6b9eb2ef8dbcad6430b8cca4ed9b877f1e4b7217034aa662dc7176021b60129d7ef34bf946baae444db3b0305b30bb3b2c2802155930e8f9dc489cff2a3547a58a3a4eb4024724af770123b33f87f47edc80e16b2fd0602e726f2ff11be6896b82c9e487823a5112d82982df21061ae8ac5275f48e1c29199e80bcfda9cf1af408ee558a60cf9ab6daf99ac6d546e515ca29f06689c13fce4fbcd8b7d47b3ba3178ffe3b765c6a639381e017d884a2361bc6d1f64463e15e73300e41f4cdc78eb5770817c39e566ffa8d17e4df8a9990b79d83b01fadf32e9b8fe131732908641beae157c9675cd097c3b07dbd3fd3f4cc435aa8aba0978c464acf070ae5113068972b0b98c9fc02df5f10501bf959fb0c8acab35f1ade998b1d497273b9ae56c328e50a086924b80b921f30f85daec789ca3978e7372855309851b0b47763233d1cadec98eb27a72aa489b533d415e4d93eb50bf69ceaf277d351d1344f79ddecf24a47d6de822d8fc34f106401004d7afa6d8c07e980fd9b9d95c133710a07a15f2b40014fd9c4f2a2f0da1e008bae3051bfaa5bec0797dc34c3f0a2b97e78c0fe8e2954898ba695dffbb1a0d48c67bd0f89d3e517b2e2efa22f8bc5a06ddd1e84a7ee861fd79ae4fd42d96d6386aae2e045ec452ca7b455266a72e682bb951b113224559812158265b8fdf62461d744b93d5c956bbc80fcf32e2e614707ce5977d26c8e525e4f81c6f4ccd3917c97293ca9d8cdfc15fbec2be4f20cd0fa151ac54c05a5b70d7d573f48735ee48af9248cae29a6b289e68592c5fbaf898a235c03ae9b57cfa3e3850aa2a382f454e4f2795df974d5ffc4796760a9b0b8f3a4cc8559717aba4cd3ad844ab63386f6e93f9c3b5b78fc57712c6ddab4ff8a366842b2d3f93b98fdbc93370748556cf38d8b677c86dd6552622766d2b7d24b681620e2a7b81d3ca8271c41bb242ece5f46914bd73873014ddac8b9c16b5556b5fd1d0be1a9ce661786d42f6d5f90ffe23756ba92157fdb6c265580bf2dcbb90093a38fa6cb7b1b5602d2a6f09543dae7ffcc9cf6de9dafa94091dbd81c096f0af6aac68487ab43e836ea0171d93b63d971a022553231e43ff94d7298bccfd6280086c253bf0608d062ad82cc3cc835db1b5a116ce4df74b669c4e0db361355c6f2897631101344f0566b03835e13422b65bf9d43659c58b045e931d74c4794c72ccdd6440a6da3812edd13679a826df6df864eb68cc9684b35c9d2adbdb06b1ba9e9a16941a9dffd6b5bc52cb8c42abfbf3713c46f214dc81775b9865073ab40cd549d6313002cda72d8eaad38cbc23e0b1707cdd6d5840ab35e9cd2615fba3ea3fe5ed41ec62b34087e1ceb6ef73eb05107efc243d53b795682a85f6057175ac680cc2c6bd0eac3c79ee8469d2e778b692b1ede7ac5ebfaeae68df1d645a4aa059493e711cf50ac0e42dc0584a3fb8e42f3863de7f21feec2333012a3cba59c6e48df1b963e39132807f1654f45f83359986714a56cbdeb335850602f03c5dfbb9a246cfc2da5a1e8399450590b54774b2422a6f65cb8133562fc55aae0882605f709effcab5616c2d07df4b2881da155d9739d93aa059297e21123f7f6ebca0f7702cb02e1650de5b4e792fb067f15772b5f491f25e177aa70a4531a9310020940acf26f1ba2f2a6e68b53536de362054d78b7498c0a729c9390b76c5d215beabf9c1e55bd28e34479b4ef2fcaa2aa95cc6dd547ac5e21a8484702ea9df37e5d3c1cedd25ce348172bae5e34f18912aed04976657297c207cf33b03c316bef89142ca1315a6ad150b2224c42f442335ccc3cbdca94c7f1a911d672dd9e52f2d8391f3b82625454ba5bca7001ac022ad2349cad31bee096ea1b7e7e2d3867f047aad70dc396c840d29449f8ed83e70dde1bb3f59c030073cf8db401cf42b874bc14a59f6951d64a65b880c6c755f09eecbfbbdc192bc8e38adf73d5e834aa7826a78f74f08006369c28b3a85552bfd4fde9bec3376fe7fec9f62d949f4e66e1107a77b238ee4e7f6fc19d2b9a45ccf11374bc8734e046e12f16951f939b7a273fe8042d92c469cbb2701d4451ddf1058a8607f15e099963b392e1f74f5a9405a401a9e6121ed893bf53858d33eab9bd6d0a215656b6b63aef70b0dd58fa3c22b79dd9f0d173bf5af7e4471321118f9a0951c736b0e7f58cbdfecdbe0445ea99fb7554e74f223355fac098758aa050ba32ce1bc1593dce3bb19451052cb05dba76fc129dfa7ee56a0bb88eba25a2304f6dc3addab11552771248c7e85d6b82a0d14828a23ec485b852a0ac12fb8d91a2209bc22eca9a956e696be3b124bf3154434e106f914b99981d790c2d2280306d3d569f64baa292aa113d59cab406e4c7567a8c7f21f96eff2ccf1fd4258256ae21867b19fca820ad4919c4ef0dc80590760b92d2c58af3efc774e16e8a3203629ba137883ab5d0bff08c77899f16b29b3f6241b3537376d1886c27ccae53f201c742604e7913851ff8d3e70dcbf2cba8cbb61cc166554aa54b908eb3c69529a3aac11af359242a4d1b79d37ab0f84e666f24e38c46a9c86f1a6e3fceba333a1c3a06cff0674c246f9edef661d6b2c58933bc5cc43b8a9127b85514bf3aafd038d578f3ade581fa339ba2b3a7d5c092bc53a2eaf595c858df590a342604e3af52d7a054d9abf27f1cbc9cff47154a43b7366d47305157fce0dc72a1d6e9c875e2631cba5e9874eeeb7bd02d329a096a8f1e7b426f0226d0b2a4c0eea99e3887544230dbce15b7cd617ff284b5f071e73bf0c5460bd562bad48102b2eaac963d6733fc8bfcb7b257268cf1b44476f33839d52326e2a5e6c72aed4ea6cf4c0e5a9c66e48a1243810f1bfc4762bd04601bb3b15a9471dd5895bfd5f5ba7806e4116fcb0e4e4f4f2231e325e1b6f86ac1b68c6e465506584ca35ceffa23f6c244d49998b8db5633e4ba10df167789674623fb67afcbc18a942d617bad5d07a98ee1490f3b304d9e97903ca6dc9c8a1403872f73d5e2d909725205b6b043975656365ee6bc6b77514edfd9c8192554744bdfad2494c41b6ad9b55e9b1c683fda9a6b1fcd9fc66e4cd9dda736b760f25675821b3df8cc82a2805a09c7e0c5ef426329b361f25934df71b8e73bf8bea7c611619399365e33f370550592494177ece90358c4b414615e66e7eb54ca8b58afe2c7e46ddafcf32c53c5d6e9bc8f83e5c636cee0fdfa7ccf049324f26829e972f726a54280b096f8f5ca7caf3035662719fca607cb520fe5a9813b0950f60f5ec8d129346271defd5d3102ae14ba37f979d4fc4565424b7318259adedb342a3478bd767735d201c3db3105fd79bc65d5009ff7a66e1d9daffe255f886f3fa95b1df7f5557cb36bac0a96521e39efda0d79d809fb20b99334978734f8e1016d2fac1377fe3d5be34d0802fdeeec84ce329e8f82145c61d2d74540a3fe3da3ea13cbccc19a5b492b5fb48ec32f08cb3df6a3375ea474088ed12ca7704675e6b7aa767a7ff3a550b894c3913d60d30eefef86382e403315848d7e203244d292664ff7db67830c857de2b7fb1f6be4ad3f3ad5a73f8b1a1eda5416a93aa078821bc37ff697825d58443a507247f084bf7aaf587c3ae23069eeaaa211a5df43d419b5303ae64a3ec038e4fc74a4110b30482f4abbc39a771d0e28bea3a755e9b4d597649f7b378c773bf60453627b78474793ae19676eefa77a3a440899d1d2ed108e5fbe31ab7336d37660909e59e21b9b8ffa569caaa1be739f0c66f1a3eaa4abe9359f0f63cdd78a78608011a852ea2d53dd8d2f44bec1e832fd1707dfd086cf494caac3ae28ae4d1d2cf3d561ac086758d5447ef396141ce6f3259b85443740d88f38fcb0b3bdaf5b320227e935d2252bb2ce222cb20f990997b6d6d2f749ff09bc92ef6244c64080ba2f8b3bd2e3a4cc619012890f995eaf55c275f95a455897693822a99c53b4886e1f4d8862262304a0c867c7fda99851e089285624bd6c1bcc0fade95a07ff97fe08493ac4318f43dbe20432e9b2d6df938687ff94e8c770b482a94ba31184562e528fb96492c77be59251e9fa884c62b75e77d10830f7e7dc9e25cb29cab25aece721857c64cc51b44d67d9894820077b83f2c570e83b36beb848deeb622a3177ea480a6c6351a3afe574929fec764460c4709d585c454eee51bd591df71013120a9f90025c84f99bb3f47b99b45d851f4006db879ce039f6ec1c73816f226354d298c7c817d0aa1c4fe05a81fe9794d625027b5a56d841a93825a4c2e7c327431a5cda82d73f7ec16d995a534ce878ed5409402eac944c46ce5067e5c0554e78fa9a60e040b07525891c4a684f9b97d794f73f1eebe88adb1ddf0da58d3f60c9d9e126386dcf186025eb7925cfa2ebc90eba67c49f6be5f849be1a8625dc7efd544b1e503e4612bfa12049fb6d8977873cd92b3ad40c8cfea92a1b5a35d6315b35f2d12a666583b85955dc5b738e33c2d4832d746f4d92e099a2295ec3b4118d7623684b99f4eae265cc88acf820263444b18b094549bbfb20679be1c2fb7847b0b7388f83f40c6455c6731777d96f204d54662cfaede76e4b01ea00e56b8f0a05bcc6af0d6dfd2c7490afa4ea90118371e1c4737b64f94db505d88c8e335ac6947176866d7174b196b1ee1854658034f7fa21c8618cbb6314ec5bbbb1173c1dc53db5c35fd6e0620233ca26728f36c260992e8b8501061eee39be3a1086e69cf5e63e4b2fd3709f1f18e72edc8d7639cb8f5ef75f386722fb42c2ab9caf707a066099c6b3033de01fcb80c7947684f2d5a11ce74b45b242d7c71bf775a021ee891c35b8b8ab312f758712c6d366dc5d6a6b7812fc878abea7cdda40cac1d2125cd9933a9941bd4b6bbf92fe92f01713532c12e9d50328c2358681a1c8811dd9028b99371a0988b8fa07c9fea21a555b87a18a31d54c781f2d27df0ae4548c901b860baa1e96e7a6481f910c510d45d2646345c82540a8b78229848a8e1a00bbf7d02d57e13617a1334c1b32265afce07a1470bf7fea8ef6e748e3ce5ebc7f236b0a25d00125117820c40479f2313655e45e566b31f08d47605bb9820e04b64b2f96b28e7e2a42704c6f1315d4afd9790544a28db8ce98a491a9d5de70ebd60334eb88d2cc2bfab57fe10cd578fb9b6bf796cdd27cf60b5a718bb7444cdbdfda7d53840f9e652cac7191e91d3569adc4bbeca8ac6d5649794d477ac3f999b51900ddced5232abc3cf18284f0fd169b01edcbfd60058234b0e6b3ac6190bce00de92a0f7846ac3e8bcb2fffcca161f4bdbb8976aba08ac6c8b805e8a48dd0ebde2499c1072e80cd05e514ef875630a7abe25ac5ace3a899e69eba9ff5834071d8e97a27e070b9c7a288c1beaa282fed7bc8d39d8de70d8073dbe3d457bab55e396f88018e91342ebbc1c0d90af1191f6fa8ea2eb90b63a4e0249045d262be67b1c912cb615c53d3b41e510e4e57e1f67fe6d17c96a9f6c91860d5fdd3e1745152bfe8d60dfc8b8061d26ac1114655b651d521c0007276e17105801ec8cc5ecb66dcbfe895850d75e9fabdebf30c1ec57e13ee6575cb5a5933404dda05084d1bc31b7941576f3b91a18aeba01ce54f3f411689bb9c3d975158a55ed7c5719c0e8574acd7e99dde80d8d25b4cf5cf80d5119020a9fc562c89c1431122dcc681b8cdc8aef81d0893f17a652221c63947be3702eec2dfebeb11023248dbdc846fe7f248f7b8a23a227663954cc1da7e756d638df6331ee931c75a01b9bf1b2d45a2c388c62a4733f977ed1d1225e5812512d366cd563b1d1d7ed2b07b1e6943d25da941f148c8b03d70daf414d78042df7a97a4f0dbdd52dd33f377787edd087faa9b25deaef76ce5dd0a9b39e825e97a6e3a58ba08397d3746cb1e1d68746755c739f839cef2269f396dda902fbda7e38301d72cc1a459bcf78b6d28e3ec583bd2763a5496ee7943a35da098e9d718c9dd5b9534e733f106781487b2d669d4769d2835597ffcc7aa43ad91d687bd0fba19cc3f98351733b8aadab5635c02fcafa00ed86865662eb801968d3c284795c567d6ecabe1595d99e73bc9cbef43389cf59c3757b8bdb72a53e6d6e451ec565e1c058768562ed2805e9883d5eaf582d566648477cad94fac77c6061b0c32443b53d9678057e059bcf22686c9a11762ef6066b3c00592b9fd11ca9c45de30185b0301b60d2b5bf174947d0506edcb2d1edf92429e010189aa20b863b70391e3356535053266089a4fceb54681b457e233d63ff00c3570c81f6b8eb6b7d65ac4d15d8de8124a1d5de5f2f26dd1e3e65db8e6ba3ab4efd238cb9f6c0ac3fdbc737dd45d309056d303ca652f4384d5aab6f1a9645ba2a69324f296ecc14798ca75bf8238a5b692b3f64376bb4f6a12562c47dfd67867cd7f05ee7e5dabab308f22ec5cd87094b9c9bf3dc8241c8071659a5f7daacf4bf6353b3650930dceb45611c7526ee54995d8f180e954d5cfe2224951ec357757d479b0a6c8398038cf62ca51eaffbc953e7da35e32ca9bcb265696630acd288f1bb107bab8f2dc0895b8382fd269c0426016850457ad9a69c7fdc734bd1813804a0af750fc11dce8f34694c7b746d19cf5bf587a686405e1ef260b3f59854f5e176fbf5820c474936afd3b200f069e29d2da3f7c818659e960db952e571eded0b96f8832f5898ed4719adb80cbd5dbdd8cdbf55c2f043518e2230ef6fba905db81f6135bd9de99922bd865c94e8e8b4b4fa07a5eeff36966b0a990050b88849a96042f3957f0db95f77dd753e6377695ce7a8eda2a6ee2fadb79982908cf55e23adde93643e3d9503b980915bedf1726cc7bbef929a11baac064898029b016912dc9b3b2502db26e92e61573ba19219a76bb32e1cc4ab684fe44aab95ea44869d305312ecb1d68864168656d86d05943f9fd4d6f127b241badff27664aa3abcd816f4fc52d6246bcd3f6047a590e180a92ce3020853f9ec45c4606d4cf9efefc0d4218ef4bfd30b2b6fd72f0cbd55963b4f3689fb9f70ed0bc7d88a313bf8249701e723687fdd51891cdb8fe3ab58bed27099f0658cac3895cd6893eee482acf1be6bb40ca7abdfd10ba9bef8082bf8ed7205bf9ebf564992b3df194d11e256d611cb35d41d0d2a31c3a3161158819460a86453ddade509c944a7ae81b06eb7b32dea372c3afdd49e37313da02e0b9c86b34ed72c7ae55e2faffecaaeb648ff2628bce362e8ff1e75b3f9b4a3055abfa61b8ddd8f9c45fddc78be01d25963d74f51b5dc2b364c73f247b99d96a71d8dd84b07a20751ef35c1484c7c40c7e6f8af59effbc8a62071c46618b146d83ead388801367f1bfb584bc7da3ae66bab122b6077be2db8f4cf9d385aec1097d2a4b475e8d5fbf03b32777ed8e107acc950f687815db9a052ae2ccaa90a683e84f3eac592132a99fd49da64fcb645fca2d0f35f965cec9ee52e0c7637bc1f231640ed0825de5594b4ea3c016fd6b9ffe6ce9e55e72c5ab090e34bf961fb8379ad435b4e296156065957092090fd2833de7778440fb0096e507f6d55c62ae7a7e5e5381271fa9ddb13598b5835d348607b189161131f5750e7eb5ad3b9b88e013843ad927d8ee4d01f27b9759acdde6b7d5ef64ddbd0e1251b90e195479c110b494222309df2287eb9debaa226bebc5ef383d7dbaab2baaceffc451b1f7f2be99f054a30324bdcbcc40c87933d7f29402c6ac8b725cad9d4b6daea38cf85e196ce7d482f88232f4b4a7186d3898ba13888a9d6f11a0d63a7958dd01d24e062156587b2d1d0b10402cd58a7bb01eae46806a5589b03aec770925fcc28a7bec1df322ca5210757575327761908a8ff25c7df9166a3a8b54e708897649a6f49de13cd83eb4fa3c878a03f097d486b9bee5fbb851eed3fc46687dff461ea247e3e9277e46ebbd1984e66fa26aff7e54f189fb9dc7a1d15f7746bf9339a1c0644e86457529f9338ce2bfdf09a45da93d62d2ab3369d98c9bd7416eecd7b082604a24ca6020559d1f5596e8f121e3e21ecf58d8f6e3e540da10b4541b7d245bf348663ca8f8616a0cd57eeb8bb7cec6518e1203f94b137f0674bec1978040049cf8b20ac349ccf294b57f6eed9b9b652cdb17a09ee69d6cf46e2e35101d735b60d5f62cbb03ee51d2172140798723f88aab28e28a8963b10f8ccaca7b2129cd6c9701a3cbc637ebeae02a5539316edcc502140d381d8dd6e68378caf017bab09455479942ad66119e0f2b14574c06670c830faf34f41679388fdcd81aa635cdab4f4dc2e8e26d6e5d71275f8832bfd34f21e9e9ab9f71b3b42886bc7741459355e3ef0fa3b852274e1555fb85da51f366029ace4f8a0b5a131ac53c144ca793662e63c4dbef08059e9ba59fa1bd7db71ab4814f06ea55d1063587b4f0dd9a8747f0aaf0b4f9142d2ffc9bd102253e32dbb270cac4b599caac2ac8c7de9695066e2ebde534cbe03ebfc371cb25b36600c54221eb30d9e6f5489a929e145e780c402d2e1d70cd31a53e9290ca70d42f5640d33195d23586d835c10c7367a8920f923177986803579d3fe7ee3acb88c49894e5ea655f89288cb5802b446a52d246aa44e5aa3faafc0d3e3e8fcde81aca14192e4e15e355d5a6c9b925bc1a84bbdbd7a5570f62e5650fd5b5c8b5d899d7ddd6e77e8e6e8cb593623f7ce66cc95ee6f449ae989011723a19dc99f7e73e1fde95c019733aa480797e2507f059bf54c71cb037af39d7b46a0b512026f218898f29d8e8ee31ac4897e021b3fc0418e61180e28e87b7cc782a1f88460179cffb5b8c750406e6c3c865a3657226e66542cc0cc6ba78cb59159ef7b6da244f1bfef2feefbf51ab832809f6b01b93a7104ec5b8ea84575600e77cf11169d97870d04d77d550e0da2999878a9d637a658ea106a4edb089cdb4ff1dddc7f26ae0b0d27efa3a8314ccd11ba8b09024c194fe127f64966ff930dc7a9446a0f5f63ddb0bd842aa5daacaef0ffbb7a166d8883ae64fd166efde81a843d2bd76f662d1287cc95ee462936f886c1046022f2506808a58822e1057b3ff8b17029bc7fc99d30433eed1d4486ccc888075b3157f911021153be1827bceafc1014ed3042dde9b567f75a7e514520e821177b68073ab61794ea13ac4ad28306002b97216e4273bce1a61ae495ec393752e9f2e518b476a3f03dc40023f24b62569f85f0c19d08ccd124461f0d0c8d7cbb464fc46daf63c257871879ea899d7b7ca982c5bb68b66cf4a5d251765b54c327529c26f395f2f2cfde7176b7e45300bb2993ff8cd73e8b8f8b0f065ecaa06bcb476f8c387da2fe502099ce04a342b0727ccff1a00d0547ed38e07ebb122fe45187e18a340f73892745f019fa7cd06adbf15505af8e5b27d7eb59f275ff3afea20816cd1f0651d7e8591ab3245bc40104d19e0dbc84cd78eea6b0e9119c45a5fe2adb66a836a0246893258030e195f539ae0bbb87e01fa7d8838321cdf4de4d7db809e0e948971a194d99d04a8ad2caf5fe610910cdbda38efa5cbc044188838a7c4a1bab62b27feab675b260b8cb41c2a3ea8537250060f31bc68350a583a405d184eabb162073b9703412d29053249d2c0d4cc90a835ed6e7eb0ced06701a10ffabd06d1b832feb2f9edb6ff4dcb777824fab7e71324df0592a6669d1513a540125bcc151104eb7b1b1fa41c599c9a685a6c2ffc915a9be0a79a22a848c8675622ef7a4e38b9d73b46e1e32fc133c77fc40c92fb0a8342c081511142ee99142a21b8843d544ebd540d69a5c36bfa37205d855c57bace2eb89bd4c23aeebe05762619541a26a2678caa9e3a2520f49cdcbe7db0bce7dbc97f4e1e13541d31fd2b1bb2d364801c943f07b3b028edc119442f9f5b2838b8b53664ba0923c4455bea9c856c4cf93a5f4546fccf75d77b2dc90d5fb852d45af6c1a6e4c06f82a7ed6a143887db98b17e6f49c95356d0e02c47772360de8b30ab156965fdc7afc68ab579c80901b470ac4ea9298cc4c942e432a4bb4c30a9d5bc14cdff02166be360c01999a978832bb0f26a6ed400a82a799ada20a79890a60f8773be15ec81ceaff6f07ccb49bbad551af494e3f284a462fb9ccbb91269a24fe6a0bf47c463f611f4cc420671a4d638acac1f9bf41dc1e26b897e5f19a8b0cd19a0e098626791e9714246700d53da98dd34350948224a8814ba269d0360af6f055d0c07523abe1c5d2112ba3c93f53152d3d6a1c7e62c90b67a619055a20d654c5a1fb96a940e62d911b84b0837da810f6a6817d8b0b8a45121af2b1c7ee5317db676af63394a524c47c64c3fc76596a2c27cc3a4e0390a6a27e18329ce738be08492137e69ca68cd98cfc289949b0d3170d09d63d2026d96340bca0e37bf5aa3c017d2b146fb3d69f26dd3a7246121bb8dc3c50f22e3e99fe3f252f10ae6eb1fea244a23dc59de2583539a772e5409288b8ccaf2899bcaa36dd1af99c8466e8a379e17816c7462c14e666c713e119e441b114d4d7f461aa28522417ef8328a5332b4f4e095d16cb01b9bfabf3f202f1d0195c5e3bf3e4c799c743dc4d65a929e8dc6efbe4f03c18b4cc63c615b7a718f1f049539150513ae7e6a85f08540761de5e869923b0b9c961a6b717575cf2a224d5862e230358cde16ef0d5901063d4e6a9400b990d2d5da549905088ed4f14d8bac44e0a9084b4b294d38c3160143da44707e7795a33ce4a28a00bf80be513d4c351e7da28f288fad697b043d0de6c02e099cf8d57ab2f81903234fa73e17aaab58372bf782558685527257bd8574536f278bb7aeaee37f65a6586e9bc80bea579ce14ddb377208c90a1638bb01c638991d608cfd1dfbe7db300803926eed00c5ba0db26c026107ef55fb5dab0ae1db212125a331a0f9edac7f22afcc469fd825e732b776f0b7df7de1419c3a309d4a66325bce5a8a5915b6e553a7e8348b7e96802d1b320358f326ef43edc4bee0473727976b67dc451ca1d59513bc23c84246b90ca764f56461431a31db4fc2cc61c0c99cc733bf391a0d976d30172f545b0d95fc0bf5fa79c41d60a206bb42e529756c16ebe7673b0455a85175e5531c016b1a434febcec323b6badf733a49d95d523b25ab8ae8c149e2bd47c47a81029ff67ca4ad8211d62e9d5c2ac83db92831d35f6d8e46756bbdcac53a852f79ae3cfddc1e7011b9c7271e309bd30e33fb711bc0e3c05f94990e501f821fcc22c7376e6f5512e8e5575391dbc2074eae273fd8e225d54eb01869156fc9bf4667584566d6d5523cbc4188faed51edac8583e36830a521b234a07c92d80a3a379ee7ad184c681604dae10d5813135d4961664afd32deb29d03fe6722c98fba7b62d27e83f02220f46de14071b759d10536b829b2400fda193a0644cc09efadf9fa40fca35fb9e1283ae67c2292dbebfd6462ec6e99fb5ab09b119ff3941cd72e794daa4f15bab169268a13d0952","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
