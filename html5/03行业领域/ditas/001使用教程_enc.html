<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0d2146abec5cbf486828518199e25da7a39b6607560a2d2950eaa1478cca5f247ef3e82463e135a4ea151facda8fd30d81b6367425ffc294e18e7860f674b34288a95f15740a5bd134883cecf0002e222b3905b51f235f4700cc9443fda92cbdaf9c838cd0508e9182446f7efe3dc6c07073a10272d1f43cb0cc1ecd8de8ef827d4f28747d952ed9970c424ede1294b5f74c32545e366dbb66d9c452ac5232de30ed7d0eb20d169d5af0c864b63c1622f3eaa2af4cd694b64579f2ea35970652c57cf00750d8be34141a8dbc3af368f134f524115e03a57ca7b730ba4bed1daa74dcc6348dc75f429a936cad723031a7473db78444024b8f4f587122e0a38b28c6dcc3fb06659d83023dc0316048ac3cc3013156115aed2520f948dcb305fedc18092caf38e8d98c442b8fcbde6ff20cb5f32c35e1350c5a40130e6235c0a111adfc06ad2af3453ed735c13a585c1bea513488f6a44c3a0bdf974ec32a47839e025124769d29d0f9a4796d2a4deaf617a195f17e7196a3957b62a316096691df4a56f913451fb287d4709a2e7d3690ad61a7755ce022264d3118e466714c9f0e47590ded4fd659c432208612063a28b0d430fdd023f09ab691683465e1ad2bb574fda0e383a774a7d568f807fa70c7a3173c79909c6e4f3f4759b94758fe0bba876cf3521a5ce8989159bba65475da13fe9dd5a6c4f6746dbaf2e7d776603b77dbdaa87a02753f3a12888dd21565716d6fc4eb228a8311be6fc5b3bae6ff440fce87ab1061e48f9e3f6f7cfe613726ba9ebdede34b4a819de3667e58c5561ce82a5f8bc5aaeaf6356c1452dc9155f401c8b727165840ff7ec625dc52248de80b6cd427e4f48d029f916eeeba2d4ea080b8d4344e3bbbff62331fd1f64a1aefd7f5be8fd466bd09990470890ac7a65462efaeeae1097b7c7c37743709d38673dc5dda236a8567c31e510cc926971741bd51b2cbf034eb9abae419a7b12a618e62a906285909f99c3e0d20253dd355823457e407194eb9df626c377ca886937b4bc83e968887e6efbe44a926406cfb0b9a4683b4eb50b3390e4675bb28975f8f1964846089c1844f9c958d8fd6e95fd56c25631a54983d2456aa83b25faec6025abd1d06649a65a3af2c82c59e3b79373848828e43c44360181b1775600d3325a2ba419863e29ecfe24e3242af3b7528b7b50d91d330c31ed8d45abcb3cc58d193b4ea25b94fd72fbf972d42d3710dcbac7e0e0128c25bb81d3f8a789c47ae0e23e11f2e759f8fc60dd176b57207e0ad0f281d7b9a1a597442afb520084a1f1100a777b7d9367890f51644c9c4a86eb9fd4f919e4ec6fe4cc4de6b473425c23c5f82d7db7d078be322d099dd40b51b5db7cc565ecadfae7e2f15aefe2db6ac7a4d24ee5ba5b46c29df907563237cb66836bd3c8bd33b7622d82288c908573e35ea6e4f1e115bd15ea03533cda5eddef255c23922a1edc254f8fafbe0f1ccfe453d8d91e60199e318b039798fb7c57410f05e22327cfeae743ccda35e441bc3ce3f362fc283520a666590ab966e00ba01a8403d05fb51f44569dee56361238735a5e4af6f57588d4faec85a86e28323e72728468ff7277829d3e0da3338294288df945f55e1ba6f104573ba16f18e566bc59ce8ba9b9176d3c8eafd886e69ae99ac9cd40fa02063ba41bab0935aedf1b74d8945bb9520e9ec68e75e78094c20324fc087e9ab2670b3f308f0b4fc3e403d6ea4d95168e16e79ebe12fc03d9de74839f2cd0670782a9ab7c3f8dedf80a78b43047852dc93361e8261f7e47bc11843eca556456a3ec2634a0085e25870142f85b1ceca780df36830e28056740d5254d13ea14aa66bc5ad437c7d42e7dc908a96ff9adf2c7b7155a18b27f89637c2935feac46d3662ef61a266db4e8b366414b83a5bed677588279ac5f57ab3329baa0e02d4af6af471e201b6815cc92935be23b9d000afef86f92988d67e3427f243e64996ddc818da38a89b2ce40f85d64c6b7eae1b00f9ec23c5f88a2724f897013ec9d97a37fc82a349e79ae007432f644e16ef87012a69ce5b31ccdd006ca7346bdf63b713ecb9ef20e5355c7d925a02fbc7569a8d11c216b3fae2031b49e77741503bae2217edbcb4bd921d0afbf44c7cd93d1f47ef2edb8e326f7afc44fc4f81a2f68ddbb8abbe83dcbbb9c4d209f9cb69b26156c17601b9a59e537249a33d22d57dc1361c30786ba9e9b7d4894ce5a2f4ee19623d06091ccf7818be7c91d2d955429c469c876fda0bbede304779252acbb5211963a3aee9199468096beb35310062329cc6070e0f44dd80c7ee077a132dfe6e6714a2fdec5ead3b40b2669596703bca75ea853b2cf9d88debcd53fa64b62a049691b3401dbf8c0deee17a6636e4b5eafd58aadd6bccfc719d90f92139603beff61d4f5ac400c182a5a67b28e7b9ba24bf63a1cdcf11d39753e554d5cb8aa8c9d037535fb2072cf3bb37c6e7e6a8f687fa85cccf1e0ab11228630f13ef8270f19c9a63aa90d0a545b2fb8169f02efa27589f733a7ff518be4e9bf2a20f969778ac7eb1cdcab67a664513d1a7d779827122a811a9dbdbdf65ed615a515f8f866c1852417493151c3c0da5a01e05716b45d76da5075bb3ea2e71cf95c4283f66a318be5442c9c2d311ce944e76d30df7132c04446566ab4e6370bee02ddbf3ff9c010eb03ba5d8c05b67a39a0d4b868a2166eba4e071db89db0026bdc7829ebef92b8c774b57937101dfee0fa2b3bcbb70cee62f96c9600a687b67a9438ba2d8944233a7bdb4ff166b0d81ecddaceb8267c3efbad0be9d2d9b10fded1f2fcbc705d8efb8505138eaa757e288f18f8658dee4dc72854fa447b058e5a7d3f7aa6979f634eb28bc730ef3f469478ffd6ef94d823ad744169a0e29fd425d9f91782172c1886e53e41e9210a2280f5f9c61db726b85d9a60fafee6dd259284432f5ea3a6d590e9320a9480fca4512b47e11498e4982d44e05bd527fe4975bb909735337569f72b6a4bd19642134fd55dc714c5c07426636639b249f7c28f6f4f2ed22a3b05aac954df9df9e79310b530fc56e380ba3c29e33950d6d0f8e8a55decf746e4898d00f15e70aaf366aa5d1b88e53974e6be839170f722095f2ebdbf4b7773137551641ff6b4cee13be779ec02f45c1261c1276cf894bb9cfa4cb78da91fed586b74a911b03bcfdba719bd52c4e144fab5f1363975f45cf45521ae16c06b9fa25ef8717cd3664be50d79a81fabfddfc8861b82d13b09b82d2474dd6570cbb732529cb8103c022b6c5170c2eb559cec35d143fce6bc78579277d23efa25cf249a70170242506ad2d4d0389f7178526a0a8bc4c306e8d0dc467bc743a6fac66ad2a3aa9b958007f0d19a6231f6c1bab734a3b530d6c9a8843f6af081b99e529083e8c447799f0a557dedd916f5a3717fc39cc23f7115be936fbfa64ff93b4730834e016d3d239c4f0ccbedeb7247cadab4473f4c18e795e932db876177c5e3fc32c4a63af46de19427c4e330db10cf94227f258cdf8cda29055e1a7ff385a9791d96b8ef4842befc00eb1db32a8844084fd1b2d284bb797b7b2eee4ba04f7d027cf83425c964ffaeaf6fa63a6aac6f9748297677f4653a03151a63bddd24945c7a971445a8788d0eca032fa40622585069276c0e6abfb57c93a7ff0294e9fa89d42f3bf61a604338e2ab2b304ea71e129bb9d852df1e4ba03883a00cacf5b65d86277e9f61b48bb391b12b218b34d693a21edb51694623d27dce84856c1f811132712434256fb53c45145d7fd604c3a82487e88e1982a93bf6276919c5910e8ec1a4727919c45518bb4cc9c3e7e4110f382d7d57955618d44b21d783de99b2cc6ceecfa6d0763923e440cdf19f691f734ec0db49996f80968c9b90d83812f62f5d10d1fe437634380558881cb9d4f6604c45efc13ddf241208f5347dc97d3290e37de8a85c62e6bd62da8873c97487a85b1d47924c1ee84042c12b3276f55486f8440193e3083bfc03c664ca5a8e0896d1db276e4f595c7dade82d0ecd709ef61935e7703306c343f542bfe0fc8939906e5428f77829e1bff9fd0d7a1074879993557fb4861066bb7c4c10b5ab4d77a8ee363ace3ee11bf5b88a96cbc1cfa4698f76379fc208e1157e84f3527299b2c0430bc6350d884d767157a09bd1793dde04cbccacf7c8d216be6e1e92162688a524ce2ed6cbabf161ea842f6526c605bb2d1cc2cf17bbdd339bbf7745d7d0ca51edbaf8957302b8d290a461dc92b5d97cb06ad02d5080867ad9aebf59b7342cd5c69e50d2342c89507fd7371e450c25258f1783123790382d432214e647da9ccfba988da967eb7e8f31451c6e63330ce669011af678743dbd83adebc54827a0a58cff61188b78bf16d8ca7e3435878ae0e4274515f72e1a6f1a6031264b8d8ad809b4ffaf57ee142e08ac3afa615980dd2abcf07d13bbfee30cc1653d0f42caa1c0886b357a0256d829e3ec609f123204e08519aa2beb0f5d77dfebf1edd63bde7d70954f3e4bfc7684e16dd143492a221001af0ce848ac0a4d5f1c2ad902acff2de46b2d0f5b07c0f59517611cae7bfc6d09e946f30accf189b97d787eb773a042d8c15175d1db291b82e1ae4c50147b4def9d0d9a5d2b02a8b083c448e9460e4ac4a42a70d056e4e6b54e82c69204623f42a933adcece93a49ddc2b4b86821ec801a601a042df32320ff9e2fb9fefa4e0b754bd4d30b06feffd96b770c15f93d0f2e646dc39297252afbed3a0da3cda1265d7ec5f5175fbed9a84aef07ce5a0bbe1dc6905226249546dc98b20215912e12cc92ec9beadd9cf7e8494624e6aa738208ffb7c500cfcbd59bd1422acd609af8b4c393c778d5ad1c80bf2d5cbc80eba6056a1b2fbd2a77b8e2924a1c196aea9d1bf78ef6bbb1f4463f59d315333b165e415af00287dbf6d18023ee98a59b833b8f7b42ea5c67b875fbfd25a4a89f4d358fb1c4c7b460870a7ad7e34b75a06e3e8e142713e288097ed3e9d61df4e67d885022601eff5a469190b80696c22ce8bcc462fc869152bb2c0190212f323f3af16883b2d42910f1911431d93f452032f3b360578c3070086363adf75d0965486b9e410dc36a1899557b57e045caef0c4a480aa03cbc53a5510fa29f91b3e3a0a3015f6604e17c2a64d03cabe1e9ee657707bb194dcf8716330bf6165aa9ebfdc8044db73e13fb1f8d2521b7ebb68d77a5f5db92eb18ce53c0c3cf7abaff9e035cc0b6b7b09cdddd160b4b293b9060a8fd28bc22d343de20d246550e74939982327386d661f40edf8dc8339161440a59a43ba9307afe72c2d63d53825344a7a6e0abcc74afaff6984af6fb781011706e9fed9d6e50a7fe81f32237ced8607edf37e999838c965edcc8c16792a8698b0682ad8b2e21bae89f450d759e2d96b0e549326c89680e294a90cf57abf131ba551a649b6c402c533ffe878e2842f75e400026788e939a561083f0949476091d46593cc64a7900ab2f52fea9a02b5e271ba85ecd1bef11c54b501f14d11604bc254eda569249a3352879e8b867cc509fc1ab3a39b81ddd948a6b0a4eebd93b012ae531417e823489c1b0b163f45d1f8da0c12d00dcfcdc8035d625181b43236310c13ac5052bccf625fbd6c7d510c0c2d1f8bca8113c0fa363fa6576511f27c60b7c82aa282d5eedc72c43b4ce265f5df031a828802130a4d34a16085bfee335a6098756bdc5759b87a3d43a756bf678732dd09ca5f0f2f36974994daaad9dc772464709e4d81451e499e830abc1e1143fb271ae8b6d5c3f104dcec01dc92daf78c2650628be20bd79663d13ddf006a0775c723b7829cd02303db5080d5b0c7ba79327edf61e0df1357bbadfd1ce91c76113edaf2911ecd7612dd7f22b9f7483cb884869eb4f279e4246498224cb27319245214b69e4f566104dd3f13f70b4bb1e3aa77294ec6020fe88e09b0d41ce60ca3cb0f4035a5f3d6dfac8068a1993a0bb21e1de5e5cd006d779929761a09fd95c00be817ec85de750f044e41164301c58d682807cabd623a34ba68045dfb1798f57452c469d36b5471ac5dc443fc7233581f0c7a868eb4e82e0f70b2e617199e1879ea2ee8d7b2b0f1a4e2093f537a4e41567af89750966679495181da2436d6e657ee9acd0942c8ea5f3c00459a5a789df95493cce152c517e727fef9372fa27c6592db1391b02bd98d049c7a7b48a00b7886eecf5fea4282a4310c5d2c2c8d0863776e8f30a856197f48c8767418409f5b7521458d315dc4f63a582e904ded68df64c209c2a9100ab44a5db9fc22a3bcb269b8d94b6cf2d578a0bbe7106aeb8f87d787c7252b7468d034eb57766a19f56f41303beeefa74af1ba59cd2b6717c18248a5a77d82e240f3c6683629906d598cc71e9325452de53c6b796d0efd3808bb866b0bc0e06b0f69d26322b1037da3ea8da5e7650e2a709cda5bfd2aada1c7bc7cce092fec47ee70d5e702225f3836e340c17e3802398a73a50c23d4dbe3d01333031dd861e2435464fae2489b6a0387fda010ea2143a085df3cde18ca7c7cde788945467e8b6d9f569df2d1377a05b1b3b0838697ac7e43c4d25d93a59104f7e9967df525a441e2f7c305224c9fc3a381c0bf2f899cc4365fd694830e30973cecd3374ca7e487fb1ab2103616dc72f0a584294764363c484dfd066d6cd6dc4478759f7020e9ba3a71765dd225ec7702e81594a691b6409f5d67b6d6ce8255d18c82b6f15052b8f05ebe571cff0e510ead7968d986e76fea8b701228afe731104b7e7ee6f1d2cbb2df8bdc2f8da45d3069b879e83b261d86e7f2ae5d673c02b7f4310f695c1075027ac2318d29847502abf5ffd19041d0b09c3204b8ce9bb6887606aecec623242439e2b9eeb9d4e5620bbe1e79df1e419b4cf4c69b6fbd05f7c6a78aeba26886c97fe435d2d43feb5906a96c089cf05edaa8fd9f0ef59113ef1c88a83cc7d2359ecea31e8040de1ff66eb3dea7c7dc22336b724902b757352ec101e23e30d3f38eb0655b362354557f02fccb2d2c2b62965a4998f3978c187d95a4078e14872eae452c12b740e307bd6083a66c605721e0596d3bbf8bca47ee6756739f7bd560f709f02f8dd58ed40a1d4d7e1ac6706088f0e7c6b0784690a0182bb1f7bc6b58d5045116a8b4e7b94ac65261a894182c074157054d73dc9d11a9d2a0ea04e91ea93a97dd3b09c88e8555a273bc755a8d34a3af3866cccde6370c014252ef03093a82ab6b064a8a1fb7fed99f6414f1f84498d0d518cba465f8e6b349747f450bb033f9fbab11e21612cf7b5c028c2213f10bb8a28e4444c9e84a635ff5a968881409cfaf66003bebef55bf7272b4b667bd2c02483b1712dd62cef93989b2b1b26995bdc27d86c1fa864368a0bf587c503fcfb362e630b87b99bf1053ad83f676c9abce6921a5625cd78496e453e48be66ff84a4e4111bf9a421778c294c7e3fb4d0e5a7471bcfc53a158bbd045c8639f7de5a3bdc07228e9c1d7759025486e28a70fdedbd291a2a58ed373f1f44b10bc8502d6447e26f72701415453f4017e569b0c83684cf4767037c51ed3a20da7a6752d1a8bbb8d482817ea23d6459ee5d10221c267391a39623ca4872c053e0d41e903d35dade0c53d43f85cdc95496cb8ae5bfbd569445b182d78bb09342cef8d92660c6d6c6f15a8038675f2bdccb9cbf3803b94503945d19e2ef67843eff93df2a984878c42b49ddc73aaa104444870d9b3642fba32218483f2a6e21f7e26354b81280225f2a53080956fb13efbd0de7df789209836a8b0e29ad08e167669af43251415d2b8330e474b281ba70a930ed02db40269be85ed3a19b41dde14811780725544b9c4a801ca9b909039b2e360cdc0d07bdfcefc12e0ad76ceb108472e9747ea68e2d7f9e3f96512af5f68e2e3cee06019a72702ad8aed19c1cfb0848a6ea11988efabbf337f724cf53a3361163fe2f1c48aab2aaf59bfc07320691796b1a24ccce6de1e8156e40f55cb102341b9d57f17151fb574e3312b7f17660275013fe99d5d80907791c37014de69978871ef0c2ec8a314f31af899d30e2b91116f27a8370c2d44f626cf5f7397a05d739ac1aaf479b32c7024ec5c792d0b0b57580f447965c394377baec4062dbd6e5f8e383940d45d7a75ae7757c9a6551f7d3a2fe47dbd6ada2539a305aae14b85a7661f7cde71920ad0d676c285edf1efe615c55e83311f45779987b1966924433ef28ea751bb1bae3b445168a31490bc212b32faffd57790e4b8004a033b7722f1f59116d132d598175ddcdb56d8aa0bd14d700ab35babaa625bb2426bda9956db7ab93898fbb9b3259d06a5935e6cd8d767586f740f1332e0dfa0853ecbb948f505f280764a95294ed013a823690ea3b35b5ceb7cdb40233a2174807e18dd91a66938f021cfef1882e45499a67a399a36c9e838ba65881acedd45ef52f7c5697be5a13fd28ea632f1023f0262b113076199c5760a3319c8c8bafdbcd646d4622a1d2e65d14888f023e0e963687322820a53000cac2cdca2d49592f0cfd0d6d8d3c56306141220d00fab7c32e7b1443a11cc8152b0ed776c1fe4f1ffe31f2e55a9ca8a136db16a4621ae11db4502f629bca6932a50675958cda89aca036a84798f8f394a499fda26e29d1c32fc7fd3102aeca25a7a5c58bdef8a18421ed1b0506cd10a6da65bb6ffc6c264558424f2353ab775077418956891b7a490ea2ab4323ee7c3c0549627ec131bcc7d7746298151e1bac737fa64be75271220bfd37527330079ebb744a5d0f92bab559ad6bd0cdd85f533d506a9edc259525a48deea27de46da5002dfc1456d035db51618b06f8b719f632d2391ef7f702b68491922975bd85818c79f97cc4ba7b9e06c0f8b4ad7de976018e3e9647f6bb28410a9bfbc4be6320cec8d0164696f354d07892e2303250415ff7916ac57d545bbe2b7ea7aab894db0a97166ba4e4d5d52f785941c3cd5802b7a32a810ec5c1a57bd9628d4d5ff96e743c54dfe5942569d93b100577c76435a0593b5140e786c54908dfdbf64c63c34d786d9a0bab5e927723f0c6ad876f0660dd4bb3f078472e9b5024a41ad153a2f77b0dbf5a7cdf6fa300356ba64ebad521946c0bf89207b59f60cb5e815c27e1f5e62646311f4009b4cf8f211a5b42f8c32b76366c0760b1fd2915d081d8545a6aee42b5210cf96a774fdfd81553758a348f764946bbe2b8eb7bfa546edc73c88e70464ef813a10baf1052ff4c16327f4ed0ab3e96a328186eedebd663a15a24e6a0d0ce044da845685d529efae140d038603ebf4d4cb4a6d528cd727dbc543262484d59abff744639f2123c0fea6e0c467f0d4b04cd5658c4b6c5751aea3beeb234cc8981bdc986114560461cf9701a56852f0b6749d9aa800e87b412ce4729dd83f1bf35821f7ed3fb66cb6f50c05adc2cbcf789ecae9faa3760b58e396820ca0f8b7f93ddf768ebac961c274b132babeb22d4365fc10c9fb8f02798e880ab27a6c34860489099d0e0973f944584d57c8cc3f1b2b9f48c37680ffe5ec127e022a4c71308612a9a1b376817fbc501f41c52c854200d3c797a2da3ef7a2f097f07b9721f2eba8ea364e71b7cc7e84fd79e03a7b4bc7d3d51af39408ec3b8ff31786019f11be87b5f938f0a5f641d63c505050a18bdce468bf8d69b88b741c5cc4accc1a82d917183051270cd4225e49b2ad9bd09fe807cdd25fc743f62cb9da5c86f7642b988c4319a26212e1b341a72ee1cfd9ad8d83ddbb2290efb3a5ba4da2b7112dad72151e5c173d761666cad14f3ef143f5db604581a3401f16c4a625ae3b108ce1dd93ee8d334603b0eafaf284686b1d0f7b084a5a50eee4c46f16f6d6ad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
