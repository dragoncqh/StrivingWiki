<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"49b051c2df4aa262d92ed87f673421f49c23db8091b6a995f7941db925ff00b8e74bbf6a5f62524529340d6b3823b613fba8eccd7497bd7621bc8d63329ab6756e3230e57ac395d5f1f1ed8e78e801511c21b1502874dbc1f347db9c860796328592683d26259392bc02d8d07f33da5e0e186bcdb0a52254d7d6af7e4c3fd6344409c6c30f345c9a0872f595522db81b4b4f232e07be0d8342e400aa2a8ab775773b95d86dc4377f8e28e204e9692e1de0cdfa019a264f5230ae8c5da5ed514f094a9eb6ba47359e4fca62f1d28834db4fd92156bdb1da684fba1bab0d41ed0ad5ce94ea7ac2af5114fd76c51d101b31ec4e5b7b0bc0534168254e273191f06f909657d7c8690e8731dc606b30c63164cde94a822fa65364c81e56c42c40bc0e2375fc753c1a135ef0b1ff5ee6f36eeeea6932985e686e38d88fdcd650957004c76a9ca158b27246734848d38304b161b19005000688597063fa4d1a117355e609143e87f222fc8ca93037d6f86accddd6bdd90014f4a6a336b5fef2dd259f0feb0a46d2d79eaeafe4c123376ffd559ba2a74fc8b64204ad68063baa2bb2d8ae978b964ba8effd90213461287096dde64155e90535e160fec449758724e04ff755435dedb4e7e91f665121398ba583330c55163565b53c7c36e34c5389d11675ae442ad55dfb221a14fc2b67dfc8087605eb012c89a50b4665dad566cd7d81bed6042740008907b6b69003125a71bf693601db75ad24b9691d4a2b747417428a76812d2b7dc76bcad3f9413e87230b62e8ff2b904345b6ea46aede5ccc7bce9a467ed49f42773dcfd944cf9395aad4b60b3fe551e776e1457a61ecb1f14895790f09d14684bce54c082dd369f1290650d5ad90eb0d3c82deea8a154a585a237efaa20e03776d63a133ca19548ec66fc1a1359f4ec62b800023c18587fac14970b6b6575ef7f4ca32fb614a507f6c9514f00ee7194a56956ab853568ded3c9ce2bafc0591d88505e1c8cf4967a4fdacc371576c04cb31f07aa96dbd8f89527b37e6deb2820d91f9d7d8042a52db8935ae1efc1d1b2da443140d249a2c4f91a5d258391b55702e730ce868c84203f1da912df2e20d95b0303379eee93d6357781c5e6f9906c2e1b51c16b556c3f0dd710af737ae2708ee125c83766261aea25b50fec784e03ce5f16422511e495f7aa1dad0f780e1dd4f78171ccfeab8d7774fe348676808d575ba7d2ab8e99c0df72b14a5b6553521c5de8183dcd5afca5e4fe9eca8bc790747a021d0cc8f7e969eaacd0da96080799a5f2b330e99f3c91fd3ebabbd8c98c5968fe98d42e8993f4d5a1e1e748878bfd8d45eff487069b2ca48f47d53b73964c0a862fc25363ad10bbc38eb39261622e728a253147d1c7b0e168423b95ffc26186f0a66e07dcf8f9419f6b814ff773e2bb155056cb9b96dd82c6fd729fd9d9f5d8f0c2100181aab15d494cb4e0cf2db6c8fb99d4996333e38730691b1fca2077497ded6bddd0341c0416a569cf769dc38359c97c5bd6778597810d8850bffdcf84a3531204e07ef98d638ff5ea06efe89c132c17ba35c2e1c85b6480886665aff2159bea1243e6646f6e20e0b4a8d8688429d28c917753c845173acaf51286015c5ef2aa4709ca098534b05a1bf407608806e4967054c5fa75c87de429df37e9d11d4eb390e985c8326f493a99b02d071f689e562793f93d68899813c62250665e860d0408ccc73a0c94957da4cd7e84c64a6d9fe9857f9a6e4d1e1e5c1c97126414bc74a2d511e914cad24b811b874659bbb6f2a49593455f57e941b5ff5a59cc05e78b6d7111cc1344430032a0750ce67650d3a804ca53e0baaba71466f5658722bfda12912571d0828de61c22bd94df9f3fce2b74ce5c9866ecdc4edc12f13958df1106b0d3e0a1e89546625540139d9bde271fc6d9c4b91b0ba0749fd7e0f50dc29ea88330af98eb77ac6d3c65f2e99b5c4ecc1233cc53ff39bf5f9461e9b074d0cb74bceb84335cae9ede943ebf468f251a1fa109901162b142a39f35dfda6a6281d548bb7516b15256ffb0e196857e447acbb8e43789bdb37e843b0206c19e4f3743d35fb5f4e57a1eec003e1308930b4d41958f80b6d119a5ba2478e129b0ec601e96bf0249abc9534b15ad09303bb7e76c42b4cca59f5d8a4c59df7aa66a1ffab6e72259fb75160a95fe61584e8cb48592486dbaed068994514df80fe16b43100b56e41847797982600353ce9791cdb7e242b67c181a8656c946e70a7e49523b3422f4f5ae7375db43661847a1d10a7eb909f9e9bf72eb59fc9ad23fed6abbae7d270c0ecfa18a369fa57daca5e9d6d852342ffec17294c89f7cbad9bfa6f62474949d8d25d53e59ad3761ef605802aa69421c383159e2394dd64c4867e8de4ba9b2fd56d4b58944a45f1fa439937b44d3a8682a1ccc18513158b1237c6df7d7463e1364bfcff21c2e48b9cccdc53af6393ecf3bc4bb28903a6e871b8b73fb5a640362339a71168c902322ec7e9e2e8228dcb18273d5eac26b93d60e90b0e9db4c9fb00385c4a901bde21a03f2501148b56af53332fc92c9ecbb9358670607bda5b2ed78c065611ba280e3aa8b6f8967eacbd6505bb2ec3bd6fa28ea59f95040e1916f832e770acb3d0dcc213f5cdfa1265bd939876faafe535facec7cb18f8464cc485a7db31d0b853f30a47eb315809f4e467e60a6d5d5d1f916cd133a5a5f596bd02c513c99eb6edcb3bc0ecc23a58ca3ef69a6964e895b51da42b1c555fb255653af4dfb63f22cf8da9dfbdf80b6c885134b6f3ad5120e2172774b942afdf93742c5a8021998b8c1a48f8f21d5c3e72ec13b8adfe2f64d3e6367cc306128fbadd443c92983e39b566123b35292554cb269590e66b14c7783ff97f2fcce33df30d29ca80f8fa78ae21e8894ea01d1f3db3bc2cb9f9b4c2b3ee48e1b02ae04be16b0d858e093f27c085fb937b533199cc7a2127eb54a8d6f40c3199274164b82df108ab882e5fb3bb73bf6d38f17aad417e723a3db3462cf085b4330a604c189c71a63b7d088f4bd9863aa329eaeb97db9790cf1d9a3a58af2d450025a5db11e0c6da90b7e82faac8437f828a864a9e9fd2be7e79b549cba6fac791b7ad84d5ca9b368c777824c0cd078913c4ffa3435ef5dc1763e1c6e1afd5b919a671ffad574deeabf54165760f6da115bec7b3714ed53502f91094318a5967073c3311ec9157c27a2a5350a853d5eb3222846e6f377e06e2e258500430afab0c0aeb815a5651872105aa160d361eb00b411c39bb63456d23e02f3b7d1fe077ea2f2151e5adb8275e02f944f648024964ec68228e3af1b444f87d857c1d1d5af37845b41dde1161b04fcf983329fdc70f681228739e0424e6c58bec441f3010e602cba3ec9fab357502ad6930c06d5c322d37b0e35843a72d1dcca1dfe872f5d8e3858772d4f2e8f4d957c11243d311eedcbd44ebcfa3c88fabdc0de764606850e336b6031ba14aa98c4f65f74a5635866f038ed71868ab5d352cf15ab1cfec83ea93c6361acbd80709cd6a9da256f7bc970110ae8d6aeebb3c778e8f8fb2d15a884cdf44a7cdc761b346c17b6cbb9a062379a2078d7e32ca3c39cc9b774825d29462c03f52566b2d3e6b50d82f5d29a1e3a5ae18797c13c0deed3359c094164e8fe689783d4474af492d35bd482c1a75eebe15456e0d9aae650970b4dd12428742d0a73671789bc8aaa78007600910f9fddc62e0b56a46cb411d3f5ecfb69af0f09dbae450c06652e6ceb56e1ca24fd3a7157cde41c9c9d99cd95c9ca4aa997d1f922c7fc180d351290c10fa358453392d1d34613e01598e6f28f92a8ac21c41f46d94b2f60cc39196d14fe9cecd98379adfa4e889c0c32268669275185d9cf7c0170c543943ca99de0f9db8f935fac421f0a2da468ffbdd8ed346ca5995e31d7d9f034c2d80d1f2fb89f1401eeb54a091ea92ab588402da8934c9b5ab41413f3997a8b891451bff3191bb5064ebd3662e988b42fc584b71c58236de2561ba70ea9cb614c1a781cae0922438456794aeeba8b3525843b661f70d5366aaeb8900e2210e7c0f480c196999903526d2bf482ed452cef85e8f8aee8cb1aabb110da7a3d5bb99b4bfe5b3fb243e3e4d04a2ae25084eb314900ab4e664453104d139022f59f57c94a247cca29dcf4591fa2efffd40fb9e41db8a85f3c1c15a48ca5741cc94e23af4b0678f52860a53a36bb45e8881ed79760e1d0abdcc589555c3a639700fc18c3358f8fe23760e23417b2bed67298ead4c0a7db2234c013ff62a8f295c9eba35e69072fcd906331677ba70cefd0261af88db58acf4413c3eb1a07855ab56e2d580fa580c9ed3492ea8d22860e588d0c6027039a0b58c71e400133a8df908f16eb7e72e6bc65fe74a9a69cba415850a6d43174f733cca754dc662634ddafc896be07935cbb6d38919369d610613ba359992f0a5876ccbc82efc037931e0c84fbc304ef8c9222025a0ed8589b524090de6e3cb735c41c02f848c360ceea44c396f209d79010d22a0ca4637840f3ed03face4ae70ac4c86cb4c2b1948e419eef39569d9e2b01dcedb0421e0143b8c1ebe5bbe3f0a35ccbe6a4d4df156ac0ab618c640e04690ad1452b6fd33cca37508d153803469d15c8b2f099d69d16186ce29014f2e1c674efec6f38e3480d6bbff9c1cc74d4edeee0856609d2e7eab130612c0447f00142f22f590df01843d1e46ba162ca914df8bc59c5ee56661a86e5423efd695083c818bc5de2750ec62400b58aeff4ae6faf5deb12b791ad7d71415cb60dc70ba2a8800870ff4bc588f3c0ff181d7321ee8dfed11563b5743ab3e6392eeb72e92182ec7926e969f08d1ea9bdd59e3af54194806756d86c2b6bdd4a5947a44ffe9b5b88b409f0119f4959bc6c0ce13f0d7d1a57214aa7ca60a54c5ee7aee2a48b5372009d00716942159b68f114c3db856b78bac93f5571e9bfe0a8894273a32e8be74cb2b861e28e472430cb79f5fa79bbe189c7b13aee7c651f3b2d56973b586bfa47b67a35cb4e8cc5ad21695ea92080ed71137acfa95d94bf4a8baba6e76e4b1dacb37dfd5dd6e0242c5633140d26049b7ae1e4c1921f612253aabeb7a5ea414cc185333ef0eebd6e35836916e26f20ed6534f827962170264f7f32adde04b1f932acf5f69a6a9199cf2e06ba83b67722ad84032deb06cdfa99c7e2264657f508ab50e715253c2185655f7ff4a998a6594c18454427b7aa4076a9d5538236f312e8340235d2c1247481be8b4c5449f5062ce958fb6f6c94db436c847e3698342bf40cc6114abbe622202b30fe094efd507fcb9abc05ce23c2fbba31005fa9e7bee359418aaf120479ae6d0074982997ff71f2d7d455cf297b9b011c1f9ed01f665b5d305f0466e1be800c7bbe6df3ebdc35ba8ef08cb7488f7bf4728e6e68e063ad1906a20da564c4d99bacacf2b7cd447b736a807c9a5099a9f3401307c248bfc206d65139b85a2d0cc61e8b248b024faa414846047186b90dfb19b4360eb448db16f122a4824f9cebc8955d0ce5ab391e3c46223c1d02823fd534af267f93d9060e57ada9105d9df43a52581f2b602886ce80961f804e64af806d4b607c3c192053993e7b9cb5f53bcfeb09ee2f67b8335f61b1bd4697131c02fb9076afeccf9c77f4ceaa7f78c4db928401b67bbeadac643574c5c459a8d64e17ef1721de12bcf2356ce50bffc7665fb1e1550eada1a57470e2da3a12a2534a8d209825f5060699295556f3d4b2073c38adb63774e89f46a37fca473332dd240ae6961374885856825b34f4e7abec6db4f0e18984bc96e7df4a7b2ca3d5c15e6716663b863b88d07257961ce61bc01121764a3fae35f451fce136c715b5703fe29cba709a648fce9bd295562c6b45ea481e3b2e959c330fd67378c6984a7a0a03526363e3b4f41ffcde9eac778558bc1c71477a28d5e6180144762f581fd2c237cc2ba090709eeab418b10a9de9a56327656263cd9beb85e8c9aa3cf9a48c97c1a19bd83e9df128d27c5630f238bcf7efc48931ced3fd2103ecba8974dd4287440edea837d7ccd77087f2a9a02e94c31859c4de4c0fc0fa1769a6a48b8b2e8aa53f56ecb0a1e2b256ea4b1b93402a0722059c77a0f9b33ab55bfc507c86e9eda39ce32f2660f956d6911dc800b416767b139970913a6a85c12427bad95f7294f7c97c397227a81ffe8097331ff7ae962f1c581dd66e2a97a79d689d98157a828802a47cd211557af66f0662252b63113675c94ae36766fff7359a3b04743789a4c88443bde77058a81ac27933809611ec5e64a132089499b2a188ebc719e8c84fea0171c050ac5a2e164a218b0b54072be332a42fa3f541bd0e65b63bc543086b80648f848e63e59a8c2aaf6ec5cf09f747da69583086f8c4036627e2d540e5b9a94665b96c8fb42124a2bea32b6dc73a9774e2f6f686f1e229e1d776df88066b9450a83d8256755f419b09114695c7c9069ce5468d9de4c883665d2efd56e7e1bf30db378824bec39955242a7a0cea523eeee2d962329c88c43f7c9eae7dc87f5c11ce88906bd59f2e0cee06196038933a23d14b1bca73737562358c74231ba64d0c45417f078ce94379ae8d89121ceed246f585a6a54927d39512e925240a3a68358858f028e3059d7dc19ae20a49d69b4409dcecfbbb8308d9eeb41896dc6473a0d762e53b039cc772acdf505033c7a2fef8f7d272a2fe4295ddfbec4fcd6f9445bc6740ab3ab75ccd2382e9cdfa72052a39cb536a97142dc581aa02791b0e4d24481d17fbc4b489fa8b5d8f57699c9a1aa74b72b5463a49549692a1175be598b5e04a9c2d495161be8ebfaaa0dee9b77584cb357b59261e0114dd41760e03899c1da9ff3ff9b43ff4238e28713382cb7a96ae346c86ee2283d9878595d667d42f11495aa66957ae2c6c12d2fa2a265d7a7413704e7b4b1d8c1a9d51ddc409a5270cb909f94a2852457adbfa8dcf4e82790bd2882989756308f54d5b1b7da420b9af5e31917c55f998465fa5b93365563f5bd139c989174b499c66cd6f530161a05a01692879215aaa28ed37db9eee8cd39513cf6c49285507c37e2f90d91ed7934f486fa1b3d7ce8a3536916059b402a7342a3f610f3624fb16bacbc6e387a3f3d874a4e8d643ddecba858d33ea3cb3eccde21ad34","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
