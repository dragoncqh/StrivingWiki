<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"73e1829ec5dfa0dd3c75a00e540d5012b4afcc7fb1c0aeb39d58726767b87e9bcd542951f3f4883fb98e067a11de6b4456d254b8034d47b6bd4fd610372fda08fac960543cb95450057a7886af48993dc0a697e2c46f165f7f77244b4f7c6a453a787c4fa3934af91bb2dc2cd18b52eb23c848aee3b29bd571ec86d07b4ffefbfd445ddf1482df2f5de08db3c9eac541b887d3a00a49d99ce634270c8a72cb2de63329221fa2b0512371c04dbf03f6ec710139bcd5b268a041e462092ffc7a55a81fa269cfe77ea25014a8d722c54ae60b28727be1d70df27d9a72dc47c359ad059f740503a796409e29edb91ebf678180a60268b4461f60787582e4bde7f736fbf77cee260b12e43950ec133794feeba276a5cf8a0bbc8bdc9f467563d36c7f0113dd61bc72a508b89baf4737dd7a32d553f9a104f6df076283e25bde9de61568da10de322c72dacde990c55c89dc006cddc5a7f257f657430e98d0c9bfe94119a4f64ba6a2b5c1154d322f9d9de6c5fc936b9d81d82e005f6fc06cbe1af42b7a24cbfeb74a909da67324139bf95a1a0963fedb988982ecbaf1082ece1676d68fd69f1ccfc0ab3cd5bd2bf950b52dece5cd3b3d59da17edadca94edecf19edef7e1501818ee4bfd090874a4340d4c9ad58e9d00c76bff12861ddd607d71a5c38135e48b09c780e2d129757d5c61fbcc4da687b91c342f2e727d484e3aca3b389fd4a17cb43f41264a0e2459403f6e40e992984fb8ad8d6a80846525da20c52f0ee5b1d87ef9e3cb774cfa6758a3b4624d72d7836ed277c7c511d6960fd0b476e447b4acce724870a957b82e33f5bb39bba11b31243c0e7752f6f7eb072d854f019853130af0cf4eac88dac9ee60f0567777fe690d56ff92d840be498c1c9d1c3cacc8f3268737d9ff84721937c97f60e214982e17e7697739709f67a8074cc29e4e35cc8563ad4d1561083b19940dad3d8026949b71fd9454f6365afa44dcf4e64c8cfc0baa0083c13be797e830b8f0fe00bd3ce1071bf1c106134fe5f4378057f7b92c187d248b603e6a17ab5c3784db063955bd521869fa7a726afba2573b004b961e282519cfb3039092f59f894d7968a91661cab46fa69a399bb91f8a0491983cf0bc1038fe8f0a380bf95ecee1a4b8269c49f1aedad85caf230f6b4b3e75109cd6cc7caeb3966d7ad9be568c7f88cb6ba23308bf1ae7d1c6f4e02e71691cf04da1051c937a8a19c59afc857e50aafe1dec2d7c9a82d7c65ecb50fe03e13c7d0b275a475c5cb669ff6302669379c35094a77cf9fcb7329890183c549b4affb3d13e7a2a2492d3724eca443426382b5834c81b1beda83e249b0faa6a6a20bacca04d25da39327d50ed4138aca9edbf9ce00930903568e5ec7ea2102c68055505a762baa1e3e2c798f0e2b9a29d60c4babf66ecdde32831a83d2bcaf534a9d46c10fffbc6787001fe38a87dcc32cfeeeffc7ffbdc2d3b2150500492e5dbf5d0a87ba5d6dafe74b3ebcdd7b4c7a9a01696dc040471e5c70e182eeacc25dffc1354b599154e677e1a00112e906b2a5abed40d9854acc3a3a8ad398656a330eb6d3ff16cd916d8cf3456174efc1a4be9e39c4b913334979ccebefa58b033ceb111eb717312bfd75887577f75e2aadb19dc074d0980dad83cd7156177cfc775596fe910e513db7c4c8a257fe04e06aa989a784611ede8ed194b7406d675a106fe33fc49299518c7679157c171ad22c8dadc933ddb02887f85e93d8479ad68ea573c79fddd591b91ba50894ad01824dc6c5b028c0784ee42223dcc0ee3a12dccafd86574db364625b56fc398ce62b57920670ead5a5ca34d6686930ae9de0f5cdfebbed9e00497d93a2f1fb181c34799d06e02ce56eb84bd88a000a98ed62b937ff081c70406238d3c2e4379616289cd035af67c04c96b218562c0123e31eadb59fe00fa17dfd55626613ea4a280ae422322a225df49375511a177b30809feb8b10e4510fb45993119a94fd0268a02a459d6bf017b0a582b1c78911f24d11b52f5125e2e004b3eefe3730546c476655a755cce0dd740c0a920549f8c1767a19b5b44fce70d01d980631fdffa008033414125e882509c07d60bf16962f279cb76e190cb162c4ff41232acb902a510363cb96ef8e4987f6621e7b1a7f663104990d6bc39c61b5365aeb2f9fe9c5773ada551bcc192d8314a453ee7090b97b5f2d24eab0229d74e90f51ae25dba4476f8922423adf64340e4c977b0d1b65c3ad7e0eb461c8db77a435ab082c00d68ff9c610f785482a0e0b05f35934037e54f4a91a7a354e2962624c8f74fc85f21d2f854d008752085ef4c6ccadbeff0b4f100c7e02136a8908750f760d840741688064a12d8742aa9e58faf28ab779efa4ca5e2c064ddda01aa91e83cf42f12574ffe7bcfd5c61f041c45bbb8b9f1ebc611a6695e65023995f8d3ae479377c337ef8df973e730498480c26ed651a83e8cac69890e7d415a6bda122a394d0debc09c30bb7374ed3e600f7c478b83b06e2645fcdb6ea8ddcc553560cb555e6d422ad922b8d4885acf49480e26680778d904a59638da1553e63f17bd040cd6a65b335f5266955e4819f5f1984710942359e462e05b6775fad1a8809c8674edd92427540f63ea7839773fdd046f30a8acdd04e48d63a4d7983d2b745ec998100a4cdcfb861b463736213b3d9b55b76a30ffccd92725daca28117d9cd6e2a95ce71965840d6f65e6a8dc699d7a90ad02729cf636c39905c6f418ca1be43adbf9b8aea0c1c710765da03f1df1f23a295a41f5ef04484948b7b440d8f8bde001ec9620bd0b37dabd9eb536722e9c612ae71f4b150688fa1101ea69c6ec32128c9baf2e78143ad3f0afbff0998227f5ca3d50d4177166032f7eb521136e336ebb1d0f73f18c94be949b7771c277e91a6f8c586ea9ceba6c3dcc98a2f524f80194449dd520965bb5756fc110814140de056918a416dc93c7138902192afde5eea9e54dc352a17ef11f2296072907992e0272379d3e9910c1f3e6d512ac72f68e7b5d078a972b02d82f039256e9d60849a8613bf6c33aab31d4a08587bb7a4d32bb4c552d21beb6363f66a164712889e14fb2145a1f14b3e54a3bc4624819513d3f80af0e6f1014a65e7494cd4444d487f9dd7a5031bec152e788dcb81dbef86168f73dd3e1482a99491ba5cb5a52c2031f38eefb9e811d2f024279548793f492a63e49eafe3780c6db8484cb9a526f7f80c3a69a83da19a14ce8204ceddb5bbdb6620fa1cc3dc9849220ed23bdfb4b741d778e1cd1b2156ec87ea05fa481ef45f7ffb829e14d9117d7896e2a97a9d0d88d936c98b5ce6dacb21609221dd4a1ef379ef31f7fe34d682bd9e10a27074e01e955324ef8f583d583a278acf09194ed815398f299a5abd7f4974afa36ead8399e785fc20207d3d3758fdb18b2053611411b3436faa4bc78145f64aaeaade34760c4210b64bb6e8bf524c4ba167a3321a0d7ad64b22feeeafc6d61fd424589ec777efa9c6b49eee89e262f08c05421df2b23ea67c064ecbd9a5490879bfb9c242b3954c285f7c28c68397933abefbf0c70bce12c72b339eaaf4dbfa86a341f20c6e4b89c4e1348b1bea7f1b70d569a99ef68a0af87c49456751eaa0edffa0d376f01a9d9022c74e120ee26916020bd215324e4c872c7a6f8c385d89cf141419a159eeae9afb8050de7fb835d1e654b3440c7ae7b3464282598cc6ca0afd705abc4872571f568a3f56e384475ceb5c7c0e26abca5cb25a16bdb721b8a50fe782f0e06b42f04522694c62d76744a085db36a94a8a7305be12f58ae1cb116aabdc2a72945f53a06051765f1e7c4b19bc9b1aa07c8dc9149f924a0d5c00ce0c781aa3421ba521645bb5de6329ddd898306b1a47e4cffa485cab8fafbdcb3028a19480bd064bd6a4d6477d5440fa6f72201db60c53dcce2a044d7308e67cfc912cfeecbab22844144897a1c40b13b0ad50a392ba779b1d459045d42d14e508e360a697d9aea2252aca5c92bf1389167df5e848872e85fce5e2cc3e3f9c824cb002e34f118b9596af13468f5f60bc7802098de61bf9841f4db3558f955e7c294d4371000d6d59cad3bf43e65fc1c6f6ada375547bd613d8196b078374fdd4036deb4617ec85c91da0b3be015cb645db1820d80b589b8032f94dbc6c48ef111a872499debf2f2eac1d2dacaa6a78da953eca15dbf0753335d63cdac8660383dadd35b2db1db6c54a4ae19daf2c38b4a05dfe43bd7e9e7b9c059a84ed858d0b36a767ebda105e340c3ef21ada7dc4b710067e8d67468c4943eba78487ab5ec82896193f3bdbf4713ecde4cc6a569ee99518738b6393c976fe2a1762ec7ce424a2d6c038fc4716d423d3041298a06fc39785de83acf078cb08600fb0789fc1d6033d0f45ee27e81d66cafcf060e49f595164d204c25c165dad3ecb8eb8a6f8f8da8073f5c1b1bb88a427c7e78b1a3f39b0a37e016ad2e1675f29cd0aae339cb8122f6b91a7cf56d34869f7d71b04d0dfad45706125a6efb9f0a087e3c11a2ec71d41de6922252aa54725d57f1bb0c041c03a5aed10732b58e1ddfe6b4db9a1604d667916c675f5404f7e7921ee955266c489354fabda8c81ea4c16487212bd26d7dd00076584d9f548a1d1072b21e1359d53dac3d4b9981e3c5a30e805c40c179f5cc4ed8f960885ea336a0f4652667950a0c1fa392535d1ea9756f6ab77a8bb1306947913d45df2102c50ffddda683e63f5f7ddcfacae50f0dd81df22b3bb7058f263fe860e6b5d92a601ab3a9233a821b443f31f26380c93b6d0d7cd7dd2a9af4b45d2168375977247fd4f6b21619372061efcb9a1ecbcbbbe1b2ba01bffa991d3f516c1788ff8c453cd1c938a754aca6a2e5b65f947aaa46bda154b5be4fd63dffc56bbab1cdbbb93a30fd190c1a58c0317bec9345d1d30568386adbf586309f439ca909d34825539f672733709f1a1aef403af1aadbbb4da2d5c61d07e64ce80a36a62012902fbd2be0f6dffe8049f664da95beb7aa562bb765d6e912083629723c841b8ad15c2a9531497153567fe6a678cb4be77cd21047f4ee8179921412900750ddf8cb9df91cb55091835ff2eaba28ee37e81ac77751ffec81b555f6a6d3c2803678129abd0dfc15fd27d7ed953e3057b7a4f3da1d1eb1fe7e59ecffb0a5dded11bd204f2e2fad7a777e64643473fc5e01c3dc866bfc4123e6a4ab15d7398a64e38dfef71db33a2245b11a1de05a796197d4c79cb86bf69997477766d37442c915943566b44b04b302f8f84c32589efcf314971e0501c7291aac1174b5e45641492223cdbfb10ad1b52b92331980ad0dd75d5c55f7265285674f9baff094271f130158267c330f9217411e65dbcd5d2dde4fef33c90bee58664bbe4187701ee9dc8c2ee60f42e40189b72f5d4f471a4754aa781be52aaea22ffe9f82cd6894608d73bde5f45a6eabc0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
