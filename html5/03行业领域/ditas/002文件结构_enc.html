<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"12700a17463ae33f111f68322c3939c6d209272ff158cdcff2409dcae64316c8a727bf538bd9bde40023a6e24782fa342eee9bfccb2e2a536c8add1fe65eed7d25146c8df8d4fa46a9ed8f88514128ebe998af2379a2731f92f7ca60be08a85d10ee280bff7f6dcbac5b7a5666d833d6831ea433191098187d058cf562a3a53ffbaf15756626983866a124c448f0faa38c7b4888ad8921d4e4496b513998a386aaebad918ba53e84296852f71d2cbcaee3ae067fdc3545534b861e94e04c6bf45b87440d52f723f70c1dc04cdcc9edcce12060f37b586f4f0695b431b4a811f60cb9874effe8780aca9569b6ece6d487fe181437dc994e678b92917bc214d73fdfc091c2b294495e576a89e69c750b1900bd16e8068bb44f7847d80cb96fa309966939fff673d4572efc69537c15b7f852ce11133578e160950f1b134a9bbb7d824fbec657faecb0f7e78f865ffdda2b3131821f467adae4ec11c6d08454b1c83dc0805382c2f9807e2319ca9f042da9e8115afc852dfd8bb41835be5a2626106cc8c6874e9ac5deaa1e7a2114439f12fb621325d36b482e83f35280faf92988b67081540896f35fb882c272b07f5d9e41c6ea325d8d9a6ef37180c926dd06bf6da12d0994b622716f6dbcdabb6f9aa26793d366f182dafcbe8260b92573fb5749a4126f133d29a42a58eb4881865f5ca80be9fd0ccb008c1a7dc27e4166d0449128c37f0c1e1c54a8e315d78f503ad0358bea0b7a9ea20ef152fb095fd10be5c01b6898dc71a3c93697a5dbee82ac26cb224da3cea5e89ba5b962a59f331a965b5c6056abb8922213971a1b092f845d021af7570e9413f9466e05eef271eadef7bcd12271f3442ddc396644295497943bef031b795d146cbff84660d09c4805557758804e46e800658d281f35fdf8b062d70203e3990cdcbb39fa025f6e677d53c2349126509ecd673dd4359d20415873d45e7e363da249f1b25ea9f2a488946adec1857242e65da57502f7cd3e9ec88847381f12f85c203114bdd0f8ce9a5f4de320a7d4a24802f66743b984d207334d21233b9692c98abbae4f1cf0767e6e7788f1fedf1880d4105a1ea0c575635202c06b3616419d910c584c3bc5d512e0240ba341ba7f0c6ec539ca30edc7e4c996a79aed6272621f4f1a49048692897108f3441151b61b60dcddf99074105255953679d4f15c17a5e26635b0fcfb7a61ce72c01071f5bd273ad6b1508f4ce562dc52527d28b317d3bb23ad961af5b1692f657647ec0fbdc20b1a0211e19727a6e63e7be778af44f469a065a1565d619d6b539c286e5bca2bdc2e6ddab990e0e1fffa76a7f4ee12a8d1e9643153ab4e8e18c68786b39374fb5ccfec2a994d7fa383cfd8c0dc98336868d87b868c8e418968c216c12ad684eb3500b6663a3ef0c420680eb736cbb1e74205f4a19b618b9c7cb0fd8a8d88a80ce371c6bcf9da04aed200154debd5fcecfe6082b8f7ddfc5a4b5ffec9de5690c08f63bea88d09d075a46c8ad46f2da6c88b62a69f20a6d9666c410b2475a15ebd3feec4dd7a2fcf5f8d65ca0fee33b32ef0920c569a3faefd4287eae2e657c68d8da5ea860abbc7ee6eda98d32cb737a0ea68d913d5d1cbcb6d0bdca565bf6c37f96a6c5d75b757f0cb1195ec4b3681c09d68afa3084ab57fc463f09f42ceb122dbd4b412b0ba849e1af9416bb3564bc115ae47c860acfbcc12b93287f34a6d4f3a5ccfffcc79be242527c6aa921cc0b576cfd914cff62fec3111d8c607615af9fb820d0325155f0df9ea0766e513272d4e5089be81cd6ebd889f5fda3be44741023614dff488e9eea86c6001cdb76156f3d61b6e5d1c506c32d9f37751d01d2ca642e2b507f3d6c0b587ac39844b66d10995b712e6f69c0e11fbeef9757e0df03bd9e73240bebd7a0118113eb587910adcb355eac16e2b0ffbef8d02d95d6ad3ce4e271153c6d39e0b85076292905da78ff1f125f307ddf12783c42ad57ef465f62655950ba4af20ad67719c06e7f0e303abecdbc0807af81197fcacb8ca09a348c4c4746e9ca2bdb7341d6209186d2e772f216df080f55b76e85a61e443dee5f6725c37b4d13a7baaf49774ef30f119bcc54597fb33b1357242849a21cf253013351efb1ae11fa434f7cffcee7d81d3415b4e8dd507c37566c98872628b0db0e6ab23f6b59eb0ed56f25c624dd7ec39a8c412aa87f20491ca54e4863b73521a8b5e91aeb29c98fb8543dd96819aacad9170d32b4409106bfa232fd621f8aa8640e1eef27fa8141695910b21074ea883261895937ec3b8cc749a6f3e09236c777a09d729d71f76dc78de2cf12bf49df2250a1192d730aa0edb394e2c57df187fe7e22a8244fffccf783741b286c6c1727d2d2c56c12a6b55cf5137241e2c6e5cc8b51a0427b9caaaaa4c2c5101c8b4d3e1b697dfcfa719ab8e48af2c83f4f05d72564742644531f553f3ad6d880dddb020a41809176d932145e1876085d1e6d8a7d3f4f99e76e3b2bca30bf6ac16cb18947c0babae8c3c6c99ff47b01b86cbdf2bbffd41084f8bfe9e2aefc0e22cbb2b462290db26ee302efc2db1c748c1d00d42848781396442604957fa334a4900d717b53d384676956849875477c1bdbd499b837cf3db82c4ef88b7bc7b3216859afdcf5d18b7f5083a30f33d160e754d180a3c57080769aae01bb09ce7f65fd95f3eafe253438f4c1bdf913848d3b8c6a287fdf18032d51fa79b36fc27190c1e1070bf14a95278be0f88365a5536ea35bc5605c3043759b2d41bc6bb740f20eeff7343d859867cc006d2376d9fb81b1cab18b14ec0220b80f939503b274db08359f905e0d1c8d431b1ff8e21f5d044bb38d225d9592a877b34e35909bcdfd3365a5e4f3538c4afd812663559b273a18de6460664949157c550781d02438b08a51716b7e0598d07cee2be257516c4f3e966e1bdf853e1647db440e1304184082b34f93b05066d6124fec47c794ce615158a6ce55ef618cbd88203554bd5c4d82328eabe516db5d59d5fee85a2b42c08b9b43f54ad8558d5b80d985854b9917985eed2717d7f99fe5e15251f9dc4b6345b5433e8639a8ba84985b5672636787790a882eb9d8e10e50db4a55aff8d696a3780ce6bd537c9db391e334cb3e54b85fce2489fb6f507b3e3fc33c8d59543ff094f6c8a218104c9ba3f5313732c4720c04ad09524b0f33466cc8ac53779ac55afd89deeee1631ba11d6c4aa525e6fa2b858cccc259b9409ffe3eeb9cb4656ace1da9ba33757799f87c6761998fae2c9651efb0f6fe6f26e48faa6645c13cffd3a2c004c05c2e30e8a20a309e1575fd289460610dbd1f81faa2a87688427454ae2fc6f0fc14bbc3d428ad91943051568d0295015e9e0f5b02532c6427830eb7a68500723cb1da481139430087ff9259a79a5fcd3c7ea3c7ea06a286aa33961a87e79f8d20ff6a2acd75e471ddd3e44a4f005814e9d78e44d639cadb55c9c593f49ebb577345386d21e30952585698f7a65bcaaedc9911a21765b16e267edde49ad3ddf3a23f2aa89a39c2c3b3683c9b821d01246a10950cd6aa362110583290cd2b99155c97fedc2f03792cf40837a8dfa1e05b507a0173b518ddd9dd018b801ec7e1fbace68ba945dd502c456032d87098d6139135e5ae17d38a4e11680f8e9a00399b321e76d624698e11def1fcc56d0f7d18099af0ec0f6136521c31dfc76af91a8dd729da230207835a4e5f9870215d629333f53cf8a9b4a18d2205a993198df1a011823e88564045e7345258bc4bcf67a041517cdcf7688583f2b3102988fb6fb027003a3968952ad61181fb5d46e0465f8a7d9f293a7d0091f8c5f2670a77a89f015280b0d50b54cd8b8e2608b47390031ae29a78307fb8c29cd1fb59ace60f30948624d9099cc32cf7e0044678eaaa8432c1c82f7c099b9f326e57d0826383131f762ff3ff65c7c72d49287b068e64fedd8405d9568c236b1d221cf2ad463504ac59abff86beca01a45a93c8bf4791a49eab6ffab3be4c563ad01a0796e0a631cc14bae1bc14f327e2065753d508c06b3bb4928b55de2cb7cde4a7af1ac896bc2c06009f9b5caada594e992f5a9addda01781d715d1760222c2f77e91edff648745f4cba18e15bc1a8c7fd37ce366b7cdacf474c9857929d7a185f3a16f9c5393d3e25c2bef4aa1a02f5548501372beb9c62496d0ef43c65437f8e9f198dfd04bc123e19313c4b121f37c7968260a595f4982bbac771c5a1dc9bd64b5b564ff47d9f082360b9ad3193f978646e24bee7fb776a661b628807b2a96c158cb79753fbf6470374356d8fff778c227c783363c23b285dbff6ed94e0d0ce467004c5ea13eced0d1a0e0cd23a2e9d4aabc9ec65457fd6dbd0f02bab9a158cf9e43f98afab840a86a73f11b47936c21987a6ec80f9614892a07af23c27d8e46665dbf8e2b7ee651e753d205f4044bf77b000d0f4c34f95f02876774f9b90da3401d484a0f587a7ecaa6cf5d91df78f47de9c3407e0969af85f8e3d695a389db982d4e5c33a8e18c3ab9725fc016c75e002790c5e48b268af7565f91e6fa17b2725bb7d77cf97fea4cf61f31d5e89c5b16ea444fd5be09382675544f37811a4f26b8c00eeb98ea91eaf5bfac809d0af9638c10c3c3dc1c40ec599a3205d7b07b822772a2320390a3b3e32591a0cbb171c232c3acdfe36c8027a9688cd0507c2a151fedd455df05073b1c533e58818471a09d3a37f470c8d4d0ad78b7916a4a2cbd6f9eb479b4cdb68851ee5d5332a7434e3071ad49085ec9d029acb153dc62a82f669db2f250f21d0139dd1e19151ff94da4ff2d2cd03cd8d2b0f46a18eb3971814576d56d248bc2b510f10b6afd5b06878a7f77c1054dc0db44df285618bd5c403f2d452012c1fa539cbac58e1449c188e62a060e531592e57ad9aff6f3d8dba39622127416a23c9154e79de3e2edbbf291b3e5cc48daa62b82026475bddc704b4e079c8f83d62443fbb25454110c6e14af99cbb2a41b49d8aa4670ecec59f99e1f944674839d104951d8ce387489022a67d27abf3d6ba3a00a8f747cef5255609f4614dcfcb56e645a900379482b872c6f9a32fea09d5554a2c40c0cad6d5d957066d59e944f6430aef436d187897fa449a82fc90f84e891277a2d515f99825c451fd03b9fb1a26db43df26648e4b8690fe631fcaa291b383b5a7b29972ce3dacf712daeb79e97120a8b23cc29ae0df6986efb6c7458bade342d2c8d23407482e44122b4f6f8524a87ef5889567870918ae4957c21498ad5739b9261371a640c331c2e878b3156738f2835c5f669f624b85e1ff8997da0b1f8c202454daa416c4c0796661311bdeca919500a9261fe65fd8d4dc5e93dd900746d259675cd79cfea681a988b36fc78877cd477605a3f6434092e93a911c40a25f73ba91d3567d99493e31bb2ef876a6e5ea64be29b9485b3b261bd4a50d6aeb85646eb87519e4c9ee8d6206a5790b9efb5f084cdca65f176d43381bd1fcc122538fd1f510e720b91ed6c1ca1ec0c3bfcd661f60a22f8c88c5786b07da68c6fbbea1a0242b5770ec678c3f679a8745a37a79e0c740b385490b196be73c119d14b941b0c22222d5713c7e140b533f64b988ddb9bcbe21d355279df90fa78aa196cc3e8f8a5ceaa671bc63b72cf0d4520c9a5958d7b29748a952198de91a3cec62138c7932efa0dc0a871d1cf888fbc236c729650a2b09915fb0b57ee6d729cdbc9d79ffdc0890f1c0183e3d30be418883bef178733ed31dfdc110b315ef0a2f7b59fbb9f3a86d200f9c101bb6d260e3fe25dd52e387c77ead0d9176019affa8efe04f596509375a11731723108d73c4f3a2ffe717313aa12ca93422706cd5097c9dfa6c9b5d309d0bdc225ffa26314349a09b11f3ed0525d86d60e5e3131c315d11fffc2a8fffd36a1e49d4cd982d1119aa5e5698e5fecef621a61bcbe1f1321c8d6d2251111ae61b9984e2dc1b06181bcb9c8bff97777d314eee675ea74486a6e319d4c0087a3e5603ef9c34a6b8708fa9c5b7144baf8a6e58b6d8496b3b8d7d9c047a591ac4b7d6d099e6b8300c667662633afc5dda791bbcf148cab651cbfb6d5aff2385fdcbdb8e09ad1fcc525576efc1c6124e509c04fe2610d0701c1a2b890afa14d380cc395bfb58302b33a9d12f074c902b0c7bc84a7adebcd07c340c58cbf6428168b45794b9d4bd1e05452bd4916f17d72e572288e1ec0519dc7c1949b5e51d69d7c01260dc3877d2d7230002238a3a99d8cfa6b467e2e9799b23e373e81fb1d76fde6f35e3371ced1a0378748706a388ed06af9fe1f5ff1404114b071eb37c57d80e9bfa8e66125c7ebce3cbc98b453bcd72be62cf7dd0509cbd7af92fe798a4aff9167e8d74b5c14d7078c7848ae099523141f8e09dd3cefe8f852a1f3cb427ecfe89c3ea5d17bdc5d6cb4295277072a2934d8158f6b38f8ae61860ac8b30af3367d021a40d71d6261fde1488f4fd8d974d692b476316101ef94eabdebedd20c246de04aaddf2ead27faec434f79a9045622864f4e5f7dc20410534b5b8568451223b878ce29f0f851faf78ecbe0171808aa33a0d71798d6853d4c7d242d5aee8c9eee4ac82865003e570424d8bf5c4f1ef0d73a592812d32e5efe5c5514041436e2b2a5ee5edd03ec0b7b0f86319760d7856926f26673b7d0926d90ea084bfcde56bd458a0b4fb0652649a625d070aa5afadcd5e080e75fa3b565ee16267f34962823047d0f13fe8775ffcecb1bd90da0f3c32f8e67e28adf49d6e2441ff6f95b277802a42e32cfcd1fe3830ae82fa611451e8525a9ebcf342a93c5e4271fa2f8e4334611f960c558b550d1c887686a9ab209ffa16d171adec86e5008d3fd9873c0c2fea5d95f39746b799f4a3de9af75313f57b6e895f6d24d9a5e5a34c4c44f2089f40b44e2696e68df527a7d6412920be8c356a01f97b44a7fff5257ac3f96ba1b0f1e536750ed89056f96eabf0f491a219a69cfd376c8a9bc8a3a5c425cc97e10225ad012dce9662a004c8d7abd4a5520ebb0ee54d8e4566bc84adca56d4628a6ee95a9023ea821f9846d9a93ebfe183198a7e2de3b9614f16b8045d3eb7ef2b7ffc364bc5322c3df54259408556b1cb09f9f1e7f212d4c3986d15030526e764530db5087fcf8580395dc1763a8dc39c7b07f6158fcad7d1b09ba4aa07c4b4e8fc0e85bafa052919036200d3206afa543aac89f16c49bfa3a5328abb403bb33ac265e64a1044045e5b0cac0a68243ca25a70a54a59c15a662c4dd2c1d652e7f17f20156a202f5eb13e206b14427d47fcb4693ee3498d5933264b51009cea378907c158cb39d7fe2acd915bf8249375bfd9d63c25577972ee5dda7eedc532c5d28a8435bfebed5cb341987cdf0bdcacfed48d5566b37716f8ca4bc08748667ead7be23ee42c061179314","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
