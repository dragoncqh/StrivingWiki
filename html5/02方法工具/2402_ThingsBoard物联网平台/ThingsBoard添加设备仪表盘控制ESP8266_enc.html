<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ccd21c506047772e862eb0a83dceb32ac752e0d933683a4ec0b56a7fc8eb845a389b5502154b1d288c6cd11a34e59e966a544cf5d8386aec39a59dd1e2e1c46681bc50d368f7c88a37635da4f806d3d315e69dd78fae929357179a44e0bb5fc6fd43c39ebaeb9784ce1b009b91eb369e0cefeb91ad08f00d77fe807a4fbed9f27ce313ee2d35d2c5a033151ff0d6b0c76f52b1830880a5d6f34e87193ccb2df8f2532e7ec5b6a6b373491d84ac91a03d7b35d1a6e04511cf8ae1f6b5df88a880af31962e8f0befc5fd70dd6b853a324a93256238de4eae69b5cfa9febaba98401de5381ec70491e6ec73bcd48e8baf1ab5304c15b3a6b96360bf96938aabcb96075f9e0c074a4ce369d021a71ae2754a6fd352b7392cd2ce5c779d35f24b477e7ec07b806bd0b6eb378695ef6729a04f90dd329cbb1effc82ce025870de28f8bc7f11d3446e77cb250c3d6b139879c4d3ac608110970d5552a02ebad13d30868453a8d0cee1506ffe16524df95b8886590f34a1a91742111b6751a7a743e53b7d3552e61919ae644d292986b78f3e41c04517c04aeb6d5d96fcb207f91354a074a08ac6664128651e6bdddc03bd80f282c8bc498b802dd1758f641f1017652bbfed1929f503fd4a42dbd75990cbc7eb8fe74f438426fc113464d2bf162c24a186a7bb9154a3e413aa3a02d7eb911a0e4b7e07ac2bef9325382a683f1688a891e6d3016e9d91ffe3156f21611943d4072193e71e3b62c00c0518104623e2a28cb7b7e556f22a4498b18ea1d5a5bd945f81650fcc4994f68e3f44d513ae87ad83101efd4ad6a60e1fe3ed73f2f04aeee9b1ded884217e8dc0c2aab09562f22e9bf737543cc08e3e6cea9433cb17ca33e66b0a66e6b9b229a88a62f6431db4346b4f95bfc3865224ddedb202d5e687cd33c7a0ce018998798b7d8edd4fd7c73897658d6fdb42a1e5453da48e97ab8c0d02305a11f7d3286f9fb615520e38298c91ba39700454ab27702ac6902c6e5acaf777a124e61231fae49830c101390b662332a3b7390fee1f8194b6a717abb3eaa74adc5216756ed3858f3b8b16b1882eba67ddcc788e18a93c86d5398aa5619c0f3f44888684db3c513f61d7d2f1b23d419adff4bb63a981a1205fe4568511d32ec7d5de8243d635964cefd0898da4813e8330424636cd45444a6d279e4230d2280a80b9c24c6980118c9b30c53eac529b6edd6ff05569543b539e9e88087cbf9a28597caa486869591e702505af3d6b22cfb219dbf2d59e8e9f9a346bb3f1206ce73b3cdd5119e23221241aa5d812c7f88ceeb942be604bb15ec823d5acefe3d79689efe969917a9dca05c4a871226ab72cb94d3ed306bdbf00ddd01e0f7c7dd8380a7b7ae71b03091507160ab4f7562b8c442ac79a38fcebd939e27689bd5293ff075af7225d51cc38a26c9686c5609032368040181f31f4816de6268fb8261dd3ffcd02ac5446f472db746f806fb1f6399a595a7e02fd396342c4e3fcb5ddba5f1721c5442fe21a442727373570e68770b01d0fbb850d1b0804bbe53d81118ab30f92103639b519f4f3772c2e2f814ffe19a6debaa07bcbbd22924cecfe66382c0c41c1af82ad0cd09d4b073941180805dade2218e6f0c4c88f5e365177108a88ec5bfedb04866b44bf3ea6cdaf362bdc1ad27f4ef867c51a87a168e0de0cdd27267ca06aaa74fab189436a736c667f554ae9603087c9b63482df1c5eaa9b3543fbf9a7bd8f0dbc2e1a97c5b345c92b192d05075e614632b615befc95e333e4d28635e0175a1e3259a2e0f3c865b9668f8d71e88de98f93d7f95d679310b36f37b6ea299fd9e2efb19464d317cc8421e8e5404200049a14d9408f32878e104fbb9bb8a39cd9418be48fab171e0f1fdd351ee9eef52c5d7c9107dd66b0483f44ba95cffe602007ff4134c13e23edef278c853b99c99d39a56e0c1920cf1dfad5a36ce09a63513bc1daa26c4f1d24cdd47b363d09f1662dd7d12f21de11ed34b66e64df8cd0adde2be97f15109e7fe61981ac668fc73485a456a2677cbb8c77075fa3eed3bf919991ad8a0b572f914ff965c5e2d9b54e1def49ef52f2d8c1d1c41eec89bfdaa2c01bbc63fc4ca724ff1d3dcaf75113acaa6874b9b826dc90e07f7b996531075ef85486064d3349bca1ef715e076b7a23846a81dce22ce916198db04ad5c015e79aee998aae541e9965011d431d70448076beeae1432d72268a7c3f0ad0dbc4bcd210469c85d17502f5109ffab284ca79e53e750d6de5871064a24a314b0597584825b493ef387900acdd2343d1aab982efc15eb7bc4ff385648a8502ef71b07a9ab6b4711f5d76e818e660c970ed0467d1e871573d12abdeaee50de54024b342e819f0f16ecf3a63ea9250205f0b2131bf6c529be57bd9a4d0c892c0e3137aa6f154fc79f3c877c696fb10c44f949d04e87118bcec02f2d3a6d8aa9cffc34efb5e356e370b384c959827de4f378b1346a975e3066ccba04ab6e2feeb3de7213febe36f7f358cf99237614132be97e891f38a4a85192512f28eb95f95d4329a34b58fe7a1edebffd0f392eb1cd5c2702f738d0b13cddc9b862b9c4fa51a12b4970d7600751bd7363dc3b89553ed5565c70b9613d75aafe44f7b5ba5d5fe07ef379f675e4194d0734de0a67b928f3f16476df8fa31e447090de596e4e342c2928bfc9d6cc07363ed7d220999566dd6d378eb5eac2f7e89213c713793960336ecf656b5959fdc6beafd4d61201c35c883427b0be935a0939f7bd0bfe3143c38e36ab98fca81bf2cd75492beebb6ce22c50e322be6e621f48be7c101ede0eab1ae6ae37f44d0f77de1b84441bac5da2f9b0e0fccdc0277907c4a9def114206459ea4c6b8e3ee91fd49035c4891f421b51cab7cfbacd3c7a37574b185b27503cca52f700c5e94db4504d48bea0692de650e3f058f76ed40de4c7486f0af57279a628a407adbfa2e5a538436f0abf417589ed077113f90936978a0128bd237325dd7da82adb3442098dbf4c87f3aad525dce0cca70298cbf970b54bc47540e37d2fb8b64a4f9373997d22a1adb0a191d997e66b654cd0ff93cef3ac854461a508e3d8831b3fc386bfff55b3a725a9aee5fe1001bd72bfb2533c29f8a5b9a3f81f6ca6ba7c8f341a11eb29572ed1b460eca73ad01a4f9f6b5b4aebfe1178c01ab95887e18733e7014c94fc19b3d3672019d95642c9d8fab5eaff42858a93caf1e695740dafc2ed175e7be59b1955105a0cb46ca47f073231744ed4aede20f38365668e9272439b0c2798815116c39eac756140d0b081247fe86bca8d78dede380b1bfccdbbdeb745b2291ca07c2f625ce0a9b21569ba7a4c6c529596123e657b70b3f4a92c69409d291698323b530eebc3cee85f93a591230bba30aa86fa5b4a889faaacf0fc872e68ddc74ad39dd9980b53de2217ea9eba0ce62fe107aa0eefea6e907730eab9dd8a04ec366697ac46ccb0dd978ea72e5c11f56e3dcc98b0d581a06108c44d0c7383b7f90eaf24a08ce452926ea75863fd5133df910624580c159a5d6965c70fc69e196827063be52ca68a6ee42f80f322a3397898b56892fc12d1aefd7eb649429b297a01d7e66bbd5a48401cc92c01a5c9f9cbe1515831e655a928c8e04f603d64f37350684f1396868cac2d487491635072cca076837129dd9828b0b5fe0db122cab0dc4bb8259ac84fc444a419ef771c4d4fd31736a8f62ba143f6d10f4f8072fe10210229f0ad9a77733bdd35e807f5cc006cf686356b2a4a393d3d39c68fd3d11e3a3fed3e667a992ad37d0837668adb977d0e414a6d6cd43570ac88cb92ffbbac91da8160ade8c38b9930177792105a85c122ac499ea55e602eeedd7e88126f2de6dfff2c42fed70cbf5cc9b5a909d6701e08551f6a64e6015e40028136f7bd28be24c7100ab4b2b76777128b5109b02c14c8ecdd356cb4ddac517de855137db6ab921440be99951fde9d8fa3be10f5400bf31eb3b34f66f32c67665e4cc839588a8b5515380b6ed698d248a395f16db41701a530b5795af19b1eb52a1c7e13eeff620ee731ac04acc1b190bf5b7d52258eca7314558f7d0de8f4b8500322e10f499446ecdba3fdb09b54984ae69baf89c3f1931a8f3c95e826604a1e84ae7a92cdab127df5929ca9477a7b40e208979b419e617248ef21647b51d7ba1c5c3d69c5441664331dd2f5451b75d83cad4ed3204a13faf7f6053feae76e4d1f0534370e2aad2a9700301dda9b2bc59b67e8a756ce41a8d3ee59d24fd56a6a745fb187f66c86682cc37342393071b014a652f95d85f67694ec8f3c2d0895ee393f9c5f042e08442ebf0dd65cf8a73c0f04a893868aa73cc62e6217f9e575f0fa453f1e206787532382cd1da0cab4617d58cc123364bcd5aa5b4ecd3db61bdb7f5233941054da08bcc0529d57e1172aa1e72c285c5fe8904ae9cfe3541a60a81f5728f6e84ff6d34bccddea84d2cf0936aefc9f025009e6831cd982e85cd4ec854fae3b4710bae21b24e14460859ed8e2a72ce5388177ff7e75aca1ea95f96e48cf45b41e02509a9f5679240b80890ab2aa82a673b78961576fce09583bc975fc991fd3cc412017ad05e1df1b76e7003ad16918770962aaa56c7d204436043ec1106aea5148d8f7aa263fcca031eb4e429077845695d83c62d19d4765108e484a65c5dbf4ab8ce5af4da06ae88f7121c58a97a59c2b8e6fead2426b4c47e9e86fc6aa933157e9e443a3555891432d86c38c507c3e05fd4433e44ed3ae94961a63dc1248db33cc4846d96eee2c85bb2e445e54760b9cd4e691bb7a287fbb9584be150773539d86a9d3a8dda326fa300117b9db0ba0e5dc144426a5ccf1d7b8ff6ccb01925348f4f3ede18d1a873afc37cc35db8952cfffb0b3601308e51bc661714594e89c56187663668cb2db4cc10d72c6298a436c59e65a75a318f1e39e2b8a44ba34bcbd80110267984a313e3e7cecb672fa6ecf91a0d7e112668ad0fc4fccb5a4af013616f8bc1e395f195fbe32456452e7d90b1bc9fb95b21c7977d1ecdb1823e66a9c46239d29d99b158148f0fc2524bd0dd0c279caf8c72e0dd8c9d8035f70dd9dd456a9ce3a86e9a96310cb4b242ae43bd651206a41eced5a4bbc1329c975348f04111f238d29c8024796831a0274a7445a6ba504ccf642ce42a9229a1e6bd6f86dc0b0fecf8148babc1882c993926da812303ce01b194d39129fa20e90b353242b09ea5e6044ae5b6e2071df4d8df496201b29cb5a5fba6c0e9ebfff9f84a5adb4cbd31ccabdfb4cf3dc49c8ae1d04052b0b0642c21051042a7b0a8f7e471cc6c842ea8c7d76161da780d0196ff829a8c5fbdbbc1fb4a58f4b7a792e73ba3ed039462a1b490b98ed910cc0e844b2ff24a50d68145f91bd948450b96b92fce23aef16b3525e4fb7f00557d94aebb927eb8e3e082256f3c7fd7d82fd8580c5f7c2b6d4f474f6cfbe86b7793702c176dc4888157a82fc922e2373cbb673ccfd0a1a9f813cd4acfcbecb6361924e7a4510fcd6173933fe222d0636af60255d7d03336c0f3e891b479af462228f1566bed5710aa7de42839480c692d4bd12067b57b1002d914800124183c82671f4556521d38fca3a9ab683e55670e46d4ccee7227f61d8bf7c3c452e3c9d1fe73017f335abad5199866e74d1b8a69d78a67488e5d947d1730b59e10a5e2745c8ffb9482a5a4a3d40130d32bdc837dd174677e4d91db26a732bdf618e5a21006e464771b71ef921f0ab5d6ba95e1118bf92531498d5a148ea5c5d46903a8eedd5e61689086a280e8aadc6acf3db3cfc033d53be42c50b67b943d6fe2a04a6060550240ddbb5ed819ad99f7a92d43e33ff83e616472c87fe8a2b63947627075e8071f67887b94265cac2eeafa8d151b3525cc78b3df1dd758554a0be2e7aae1ac3bf17ae3ea00749bba078fdedeefbcd7cdc8bdd777bf64779877bd6970ed069f61a627b574858a93128062170af2392c6ad27df1fc16dda88b4d7f66eb6758e87bfa70ec1efd552d815db3ab88bded4ca5c17c665a9193e8472d7c3bd8448faed87e0b25ed05955613fbb5b97329e7c94025806764b752c6117cd1cbdad5ca9569121078cd2286cc154891bc8dc44e75cac0f42f96a51107e7aaf249008cbb9eb18b17d74d46f291f45528a996eb19e098c6b67277b265d45fc1056c045f6e34d1a2941bf089cccddc0f216951515e1cf87b06c11671f7ccc562d50e1899cd1e8f2d9e8218e844ade6990b1fd7922fa1d2b129ba482b8053755236404012370a1acb79a9d84d0242997ff916fff1ee8f7e2b3ac9dca2d7a447614320f9988f9b3f774bacbde2b93cf496f11689882d8513002da6b230cb9c120da345f93905af315b4a046450b175b5d8f98ee72dd845426a09a3b194d088aec5a419c141c85f9070747b8fa44caa8df64fe37bafd71fae73250a82f8a42d7705a19ac3102e3838782332c8303f890471eda7977607ac86bb180d983add98b0b161be615ed5a4032b1834b5c79dd194850929d9c4293b16348e1f091782248832ba9b1ea520345ccdb655c81ea747ba378e3fbb9a0a579ca9e8532f0b036ca04164beaee835a880f3d82ca682f1e07a54080328513440461b4ac842873c87a6f73464071edf148c14d09a0afdb59c0ba26501c15c6ba7455d41c45ab42ca311ac1d8f648150f042e536b8d237c830c6e4b448c7fd3ea617d32708722ccb42b0b36db1b7167ab03c4987679fab357d36301447823098c1e8bd8c45d426c6057a768dd6a7537fe282857ce52c0d512607e67a3489d9df1d84882815682cb4a1c96ece0648f488987d68a40e9f656c0d13b14be6f454dec7b710b1ce20362e3bb21b2a607b36e6c215e293f2466a497705a37e22ac20ea06cdb0d24ed46ae3e1e74bdd31ad1fafa64b6670a857729686983084fda886f9da901d2504433c257729518ff7f86383b95453e428038c425e6bad3cbef882e6b4267665d575f444b38a0f9181ec75413f1fa3ffbb368f25761bbe8d7686adcdfa025c670a56be7d831726673d6a42219309907887660b07a683aa7ddcb6494394521d6e7279a19e7ad06f10e4700e20619a6d7ea9905a26c04f55ab53f2a4444e854223f8f5279188aa88dbee5dc608219931191ada1e47635c6e7df2b50c1ac3aa8f98ba879e3b51e901cbd5a6517e71d428f48625bc19de8355ca5dd6b727d3083391f52a216f74135ae815e11fcc1427588df9d41b1a8bbf8b3e5e747b63a60bb360e150ebee72509a15d754ea38b750378eb7a447c40179cace98cd92b8014ca7b643c9c9b78121939f04193f0b3f131ceff2bbc2faec59581ebcaa43e10bee9fe3582cf47011f89d5b2bc13ce79947a212614a05e64bea158fea8fdaa584abef19ef6929c9ff14b4985e7a75f677bc4c343df6e096ca8b796288c8ae1f9d600d98a072ad1deac6523b7cd8290307e03ea43bc8df9b8a99a72b88f0883b84339ab2e6549352f53b643f8408556f01b88d440cb3aff1832cb1c0e4b913e2b3cec4126eaca19709a65af706a7c433824c655334f95fa87a45af346f7c29fc9620d0dda8f2c74707a84f4a6dd8406b425823dec176ed8997b003199cffffce61769792f01d813637a2b9b034badffb37d47a6ab44778251880d8a716bf75e906cbd72566449cc17362d904dad4760dda929c2a199cb60fd3f7d35b5f17831133b246e4cf881aa7a79e3a397fca2affd11572dced017c272705ad0e972e975afa0661b1a45de7e14bb8e3c492e639d85570c56ca894484b5e714bb4e5288635f57ec55f88ed9605a10009053df920ce815c9db2a4f7323bfc031692a064f855af5e637fe8871bc41b9e0011b5479d0170677b36dd98fae8e07b4939c59544aec9d4dc37e53234b5fb8742546ed72d9dc5537d5a90a96d4e08474f5a5fc6419714542369ea032715c6a4eaf0b69f08423d5ac73af02e3bdb08b355e669aa85eb5cc499b68e48c6a42ed0b49d3ff32e13611e2ab0673ee34fe44018dd3ca465bf970d17167d3795a649b34ae9fb73033bb63c01e7150e0997a337345ddb1d16d4e35b348a60966cdbad70bb29b9b72655d8e0c0b19f7328158a67f90e8c4fd8035a38a84cdbb7475be5af13019a31ab26b91712afe13ee858a52536669cfe182fc9ec04c0a57d01cca3a4f5b2534f87276f8f6ee2107c15c2e893fdefe3191fc46a1a75bb43d639cf738ef22ab6c2ca62274f02ed4ced875b551a1ef4a5916ed8e89bb930e79c5f1835e15b9c7b2496b3b9438b443a96809599ee4c8a9b8b2663af6d311bbdc80bd120527274b5efcdef98269338b71122b5f2da33e825fdb22a2df9dd5bcefa1f86169d33a751795687e5c79612de08df2a102ac58cb5a39342d1e872c6849ee2e540c0259c7ec9a93945352f26df9430a79b7d409db305df71390e8a1262fabe086ec08c090907d9ffae80ed0c4e86cb2098e06a8a2b811edc5c5710b99e013bc7d1dbb4c65435f3887277a498222a6e0194bc59443641a9ea1fa02d673733c405fe11585673b840fc60dd1886e6ce8dcfadf8052b9a515639ae8b2b8511ad7f094ea0a8f50ac4c2def16a387691e02e836b10f3ed6a2a698894d902e22662b66cbfbd310c10f64e3e45cc40284874a1146a35f916515ff9e6b7d4737664442d7c73001c9808c7ef2087e0664dd89e4f636a5fe4978baa0a7ef223dde1cb4b87a3a85e4fa193c591159219ec18560989d1cb4d7c5d2b87e91f859b3c522abeb2f6834b18930c0ca4975129f7d84501bba021d2ed20ec3001b1355c49b67b2d5a51d8fd4088f439a8f3091bf04406c40ae39acad4c3bfb01f9755186ecc397de83751aae360d989f7af279a21b46373317d49ad4b4e4e706f4a7bf700cd4f859296ecb2ec0facd960ab554d02b7a8e2da6e40ded1bca88f3f89be3b4cd4c2eb3297c9c04fdac5b088792e8269180ea5ef6db7380b3e8b4ceb30cd83379c218171b68309f8af6e0a58c57acdc05606606845e4747153c186ae36788c6c87ba327a8d022390fde46d5f3eba6671d2ccf3112c9cac4178826b2a85eb1a6076bed5c0c57934de6dd72fddaad06d9e5aab578313abfb5e899270f6cbe00dbc6b654cd978598c16c431fb29044bf2a18c5ff3b9ca096f3b5abee9138dc4c3f1e96e93961f276a24cd849626365c410dccea18cc3a194abcdc51a990f87fa09a7196eb8af1a5395c0bedeb7aa101ffbd1fdfb9853d31b4f9113d4fb22220754f91472a28b125ddbaf31e676c71cc76b73afa25542156b710f9b03e539f1cd96b9f432973cc8b26181bbe2b46e43956043bbf3d197e2ee0342b7199cd3513adda605a32eb999e669f1462c8345c4ce242064f6edb147d1b739f629d26ffdc955386e0d38bef98ee16d90094cba60aead387f8e0b994fbb1e4abfa11bed2e0cbc5d899f79426cddf50834417543fa6c6801f5603faf8a79715e67a3aff097c4ed167229d9b5e4aba7457970943626e7b35a470c0bbade11c07fdda3b80dae754a600002e44f51485ac39405724e969751a2ba576629246e9085d9f8dbdafe424e4a9c353a69f72c826c4968b11ba10562be0291b93aca750c7b230db00fba7ccadcda7e5e1ad335ad006d2c9b801cfa5baec2a346eef95eb7323fb301c35cfe42e41137a81649428c707d7f870cf8cbc4b9fda0417ea0966ff09bba00fe63bdd43b429675ad0595e9959627f8f45831154ecf623b6114c11561daa2f758aa61312bad7855ca08ee2f6766a6af5b1f42441286e4e6d2007da59c2a9b8201904824d04de549447a897a0d50ba839ab3d177faf47f3c01b4026d1cd6c71481f0d0388af347f7172704bf0208f2d511d0e543bf5ada08224e651048f1383ee481b22588b774d202f06ea94fe56025796fc1aec6d6ae0f0064eca32ee525a056571d99a02a39d44932891b6b763d166794e798a2b74093af8ab8b41d6a06efdfbc58cd13dd3aca950fedf28287581640394996a95c4fe9b57c2cb8f17169cc9259a1f24e24485b690b57e11dc405beff1ee2c41d319694f11008378fed2940038bd5f4df3d8e9620821c7861273876a4fc1aaf0f4d80a7b3707345db7f311337604779505a8e31f3ed4f179dabe8f16b66240533de01a90d035616bcc8e388eb26f2626f1a5f86bd75f43e70d85a3e1a6dcf6b724dc00e5a307c08b2ec2b4bef2f33b26975e4845c38fb0cf79097adc2ff15da4f326b930fef1a8fafcea0d2558a11d58c6a3817d04e73e1f8047e173ca9ae612fbd25e8e6f7d64a381480869a3c0b464ded087f12aded31a234d16f182f47ad593923de1add4d061114980281e4767d2a542ab12b738ef9b4d26864940979acaf0be78e9960bb5dce57c0053265595f484830421cfd84d6d42fc060d516ac6377610443555e4e38b82d999f05e4d5619b04e0582179978850792ebd14b5ec665a742f9630f345f4913843528f554fc20d2a9b5f3352efecbfdc44128724ef6f303a8c5ab4d01fbd0ee1a2d9a5196969cdcc3f4aa47ba13494c1003a393ca1fed3a8a14df7441254f4a1afe41b9e98e71d29ecf6af7eee8df639d69d61b18496b98b3f0c7eca3e3924acdca73b50608a3b2b40c03094eee611fc8e9fdf7de502c96401892a8cf951612c42e6d29d4e4429453f34752d0d77fec18067339f0d5554d87c37097fe5aea2aa121f4f0a09d9afe3dea492759e2b29f10e82dff57294c08ed068fa249366e992f1be1429cd75b0173384f3212ed32b5d9b3c59bd889989516cf2ea95d381f83c048c7d1ea9d6ebee117ec4eccc0c55b79e06aa56eed4b0f67e0daa7e6c32fa7fb54577c12295a4e7bbb0e71e5b4603716cb38c8b488a64230858223a9ffb19ce5520f8553d21bece66c0fb1830e7ff2319e469d6c3f679163f4251d94b32e6109d17e2c5c39488b56d296356c16201437526dd105247c162a0a5041dc1021370658362aa1886250b3edc2d47ccc4a450174adab423c8bcee5acac6d970a52b34680b9a4da26b8e53b65ff461d126bed7d59850ea25061001a56a22ac38aacae4268216265b5ebd1ad19882625f4313b761490e83fbb1e8b5579fe2e873bdb978f48262ff334be818fbc7e481ffd294040da117a22c97a1a5e0c75df798cbf1db1581c9354f008b1f609f9dcda2fcf4eacfd8b1bc351fe9aa804c110706e55dee8bea47d0634e12b0e9a8983c309a75c758cbf99fc0e6b43343cf40ce0f52ce3f8eb7690408648fe865ee323586bd71a2b830eeaa21192e05ff0e959040b93e5c2d2a08432e97e5448ca7b53abd98eed999b8cdfc0fa1777817a8e7a5a4d8bcb5708c59441a4b5db0f01b92548271547ff0d9c6269e7abd0473f5f21055cbe55948fc419116b30ab838b70c57e5f5d79df7b9bf54310e3253247c3dce72628cebe0cbb2dd2185bb905c9f0568a5f605f5d8c8d043061bd02493f68401b9220c43bf0414e7792e2a18499682c15ba877c12453f8cf07899de84a5518881bd78ca82b0c60014f3e8253dc6d5708c8212e68fddd3cd55c1c6fab20001dbdb7a448aa496da12ca17f385d6b1e44b8a3ef318f72ea3b05c0d7a5a608da0dc50e7604b889b3d31f0520cfd63a51050352574c8228dc15d38adc648689538bfa613a941133cdcd6dfe6d192665b438592c4d1dd993a30b3e1ad7e6e5f1fc710c2799d2c92e97b8ba3a6d9c3becd9c8f2880565db98a5809fb78299c937026be3c64c7f6f656c54138f52051ce9483ac4a85fef9663ddc17a7596ed6f4e001a25d983042b9b6840e36b2b0bf14bd7a55a2e5280df922c469d9d97740a15d54c6cd3c1889d92703c68ab58b35f7b7e1f94d6d49ca4a9a5d1ecc3747905db0c8fa206261c7ee568d59554f8335d3c10379977ca9a911795e05b63c05109e08b7283a88cae69f61b7b29018765cf9f9dbb0489d8185b04c8baed583756b20db11ac0115923c3b50dadb7ec109ba7877b4576a969f87b79e5eaccc225611fb967296b064c1363e451f886026d5ff5201d5c82f0e1759a0b12c838f54defb1fe2fc224cb73e89f6607a6e7b6eca18597e11409a298fdef0b8cb6552ce388f544c8d1dbcdb26a31765d13e920a1a4b1457969ad2e391c728a80ef0638e126f86483c309b651b94a8648ab3d044a36a6a1ddbeefce9317f7cf23a50bf3b9d9736994be637d54002f4daee0f28ddaa1f8c1258d33b0b898620da3fc8d9c7274e87a49a4db7b1e15b115c5ddd3a1adb95eadf465318eb92d6e0b3693b39c835cbfbc5b4d2dc58b5155b2db3d6d42db0ce2581a2fb2f490281aef492761e2557c5556da82e091b8d959454682e46841789983d81c145964806c7bd622d65b9a67500b0a78b157211fe5b24c29c4f5535168bb22d9086bed8a7e6b64baeb7cfe02d1f11cc4afdd0e66c7f03e27b1667fe96594f034a38f363ede30e5ef788751ca5e34730c6e23e1b3fd5f3cc9296ee57aef6e0065f802e9e3f8d08248f7feaf0c216897c5698f1833f316fd63f7a0e5ea713a7cd69bf727c4dacbc951f307e5a54e7b14852e4070daed7f969b8bd20327aaccf06c482d57779da9fb4ca22763ed28f65a310c152e64dac6342d1772c12d0844590909befded77314691491dcb7d78b2921cbd00a990b76d850a0d429491a6b4cb56d4f1979323d78c6d8cc29c0172b44300bc7d1392818b8da54464e7aaf99734b9c40598d7be9ca995016941248aa344e2cd9683554cc25717b78faf87bd93f98e4d13a3320e370ded22c24028ba85fdcbf7c1963a5494635bf24961fd29a0500d5448454d6f31639ba309ada8cac306ed383151da6bae0de3ebfe2f7960de2efd1f43eb31fac5dd614be9502a5111bcadcd7a3cfffa261a1a5d43930e6471b29ab7520c05f6369eb1da164ecb74bebcad67252e871a3a3e4d5639542474c8408fda1171ffa7e4c9812db8527e169426604b49548584ce2cfd53c1a7d8b82525de3628829d4dd8d5a527b7d670134f82566cf05aa6d46cd22224e1fc7bc84a17cff7a5169b8e5341e4b103bb4a9bf7006d20c56a85796f606c086cdbb3241ab1bd576178f65bc24911a21e9f12786dae520e21e07533c0abd7c4831dcb227d49df0e438837432190eb2329a63724e4c51f3eccae914cfdf9f9babfbbe4f2fcc6ea74d69fc5830d3a24966e93ad7d2049b8c8936159d4ef6d12c41263c330d48d944ed826c56a75e2583148e864f1f9882c8b4fb26405f9586502033ee96a87c1c7d395a9df0ce313b85a8eb6031c2a37942173266476e1e592fd728a8f3d5af48000c05f69d57fa47f744f9c9a6f7f04cc0e98424605071e5a22f5aa46a14241df66bbcd38f21e9d6764678f7845915e081b64cbbcb3ebabd2dd1be9eaada1994b0975fd1ed15ce40514f91161e1d3f73a0d6e9cd6297af0d8b7968622fce29d8113c311bb0944bc3cd8c8b886f0ab535661c239bb1e9ab7dd2d926bd243261301c1aa9d2c852ba882e5f34135ede3fbba180d3b67c80fb2c92355570df7a125ec5c3ef1609020e3746323f8512595fae3ddb8a052c617a57f6131878024d6f107551ff80a5c72845c3025ba0a83bfab3e9286d5c04578ab8e8a26e388230465448cebb8e6c64546ec7a02ec4989dc2dd84bc2dc82f21d7cd4a7861fa07b45c6177b5c9b69bdd5412b6586ad865d5219374db988403c2d2a5e2b0b7993c983ab5b49f6759b7e7313b5d032c45659edbe4d294016383fb77203c3601ce28015aa6577b76aa24545f46c57a4630e2736b9a5dc33b378deea398ddb285399ce2523f462901527425f3f68de71572a3e5046b6c99a8b1878a0c460ed18dcff8a8632ef5e1e966a22789cc2da793b4eeb2adc1b3ae9e54bfda18923a5c38a009c0051ffb1b47892a0166da4e90d69b44e47ac7b4132ca02b8b0f4ccc67ab600f7e02ded987876af2b10e13b57962c0807e691b66cbdc206b5fd11a1459b0f6f795298250df61576fd7c001a25aa949791af92ca5e730ee9825eb378f45d6ae545c0d939ae9db20d22e7e1e7d62424d572723da5fc354556695d01dd29c6d324676dbb2bb9732ca393c64923416b91ea1593ce9613ff4e4e2600158300f1f7685b81e6abea9f3dc0ccc2ed238550ebafc0305ce2e6a80089722b11cdc348bb0131622f49d95467155218cdd6bfadd96c2d9b2544e3f9aee96671deba4c6220468f18dec0f75d94fccd1b8e837b5678807d7a2f44da96d8a8ea9d1da2c98b2cc204698e1839dc5793b0c564bf73876453058a3799379644a4845e95b9c5433ea659ff6d21170566fecad3560ebff2ee84631254aee7df170f171340305be3b18c738ae3d6fb93f32c60d1e5ac481a98c1737ae03d2f9ea2d18a12f67e6a29e7c64592a3820882a3bae86b7217e212b225bd142051ef6a132ffd5b887afbd1da489e82d39a27e2ceace6639443d57c009d9e81d1b937733bd9d7127b548e3e0b36f49dbb7bf6ebd96bc5f716346b66727342c3ec5b0f54a3cbb52149431523aa672e519f06eb4479aa5c7f23bdd5f762e91b3cec654984044ee260501a09b60d641d1bf902300e28458c3824a89c8f5bd9178a69d17572b4461f40c972f09281f76b985f3c6fb719c3e654c45b171163a70a16ce92da9af65b0d731740bccb1b17484999df4d175532139d2e385723a2aaf45b596edadfed79ac3bf3a0c5546a9da0fb33824aa06c85d54e7f90b984fd031076ec9c92df5181e3b904f3a51dcd621475ffed7ca70e6097c363dfb641208ea84568c4759863632a6fcaa8303a1d985af45690f46650dc70d8479a5ac2b859cd5c6b59d9060b255ba7445583d203cb2da4b0c03aea38854d187ef285376174b8f92d5aba0532cf2091bbc6e99a047b22d08b18edc88859a1d65772d537bbeeb3750d42056bbc5d320bbf49dec1f8a45b3bd79e532c304b0afb14227dcb34c29fc6090594f6f92186469289b2bfe0a03603f7bd0d446c685be770a7fc902dd6d184bad05cad4ed3839d5a7318e42268521584c2c567fa75862546b3a306ecf9f438b72c256a075397c1cbbc7c04ccb1c0f5967a7f46a5a5cf8fe1001f8eec203d01183c0f1e22e018bafcfbaa3db6d079843a40a9556c8e305030ccff470fbc43b6c8a289ede23deaa4e0e9cba9551c86946bd834fd6ba4b194be041fe1a4c5038429f51f423a9ac0f287010d89d715c1dbc0548de4d11263f3a824c4ad82ea8fbd50602074f1e3c5b21f3001b1bcd4756db850cfcd4da2971b6b21394ad6622a2cee4b36c448d8ad81dc87dc355c1614bc50bf589db4904ac374fd9054ee2ee15c1e48cfa585e42e11e75de1329e5793ad84113a790a9935ed672e4a644b4b61c128bb883d6b49f2aad4599a40b13cc93d69747c9a4779221062adf0d6f47d656ae3885d77638cd952ebf5b5c491dbd56501d86589bd14a20391e1220011ab1acb9399a6c1983243255c080f46d5ccd05c8b69b82a859aabeceacf40168bedf3011f5e0189d2932a0bff967e1ff512aee6f23b2d214b9a6f79578da491d31292c4f8de66e56de073adc4e42e765a85e8452a5e3d10fe0322a0ed7ae2d30e63c8aa11af1935de5346842f25af27dff2e74a677229bc310158065b824ec2e20960098b99a48144b523454db88dfde4235cd2183926af44f583852d7a2cb38c8d74d240091db6d45cd7b7dc2f584d7a3f34ddf19068c21fe67d8b46c4008a4cac57996644c74bc60081a3215d8aaf1fdc5819f667228bcc7c690d924ccd6b775f5572f13eb1f8952431095e2f151c6000ce8fa3dd800b150fc063417c923dcaf2fc628bd4da","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
