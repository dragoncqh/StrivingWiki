<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81f57b3abbf6163cdc7ec21df26f1239f4437cfeb7a7e2575180fca31ba313612f2e595e3bfa990d599678e13b0907917384dbfc8a99d80ca9b85fbe4b2f96fc4f464ebf4c61ead701ff92db58e8517a34e143988b67ea4ca9105d8db44c14620fe7f1da1eda8f8e36f246529561fdd5b2c873067190ea78b395e3e6c1a3393681aa90878ee358796b454328e6870527879530273dc9b4725ac7e11d143eeff40de445d82a714de1c3ed89f922d15cdf78836b40a656e5ced3ddbc5e1461d26ae40180bbf193f31eb78e9485226c6bc3eb1ed3bb7b11b109a99493392e6325b3de02abb2f42d494d1ca5f57cf6dc95533725b38b264dcffea63baa604fcd3422a6383daa1e96102dd94a775b5ecb33af74979f9abf769ff18e2886070040188da6d161ef1d7c396625b73e7936c591fab550335763f440d773640e0d85e6619bbead3f11a413c3bd7ef466d0cbd32d4cb779dd405322da16bad7bf0199d2c1812297200053e8c89f6cf4af2a05f145c57b19d0b6ec4e1cbe64d8d86f9d0bc36afe059e4b1406b4bdb81bbfee1bf92b511a88cdf3a4032a47a7237dc98f43d82d73b0c04a4c105a1dd3c3a5cb1eb221602a1b9cc63b2a8b19286e53de7edf9d59c6ae5ff0d5832521e403048ec6e4a45115e70552737aebadde1e3fea476961a04572160e678cbd98247aeaf9f70c21812534962d5bde36750abcadf3a97f121eda46803ecb1a1ffcab1e852896423fa0e209fca68b58ff3b2d27449626048d0d629c1623a05e19adf75b0a6816e35da257348f16ddd315b50cca17ca822397b993de278f2856e374606ca995a681a7c71ef0f16b4e43545fbbc58f502f04a5499d5fd5d3b050cde55bc189b97bdfd20ce3d1cd674f34ae692ad300b16ca4bb463e30b586d74ad0761dfdaea427adc270f1aafbc9a3e6c621ba4d247cc1ad6bd3ea97b5eeacdbabd1658536c66ccca4302bdee60ed641fc207924060d0bc12eafd8db27a746a5e5e3cc4722c3169e32619f37bed959e83f42ce199919961e42fee8c36a195ce4df79fd6f36efb58761b1154e4a624cb2c79da000e6fd853b9d6a6975a07132d073a90d24e962af8d27768068fdfd29ef3857f5e639fb7a51edeb7d9dfa8f90431985fa327eb106c1e50761dbb8bba8c46fc4b6b94c44c82ab8d591c96dcd3ab14f062ef33ef8ad437a32b9365e3f4d25fcdda875d102074cc7b03a92347a9efe5531c23a71d19e02c394bb43b1f18016205ecbd476d9d38003e8c9b56d9f4e3c1930a35fc7b10bd1b15aaf4300d25d9b66d77f5361bcc0ad25e0f6b2376eed7657fdad6b63cde09f94e0c01243bd75ec60eea7aac4f07a0ed6f3812faf3884f7467f05362a7a744f9a792eb277ea34dfeb60d6f101b4afefcf6544ec6c79f266eab89e7f2aafad6f9e72b8aa4a473e90cdad532bfcb263b8fcec178ab7bfed48c22348d6dde507ea6596bf35d0635ea11a262ae919dc89a089688817f4e8780dd88cbb2dd9b9cf65b6245fc30f47130212f7770938b661d8f99b70420d86d53bcc28e1ef26b29df56e56b6f2242f260e7be246d825c37a2b54f4562e721762e517ae370d2df6f85aaa04513f4f44f942f936c44405dc4bf4376849301c6082c0aba69dce058d31463e5473c10e0a91ae36f5d4b4e16f0664ec263bbbee1e8206faa12ee7028b8ef71a047f89210e5a766ef9ca2297f3d062cb6005cad01e3db29f3144f1dd975af695db10fbf3850e89f920cee4f28c0d1e6211a3bfb44c3f1f4ed0689d7dff7661d5c935f4b4aadaa7ae217ddf5e2988444154a1fc9e455a281bf7fe4ce1c6966fc2e142d4928b8fcf497093336b97ec0162720a2743a87791d6d2561a3eaaa2855351e18d19d74efe794dba9f805885440a9a7a3db0ec06496f70c8745d0210beddd117996a53bb0df5f2cb0198af5e6ee8bcb11462c95695a7ab23cbc4e668583a161111b524fec18571e7546e53823c442b2f6d5e91f03dfc8f4dc8d67d4560395cc791cabf112398ad2e4b9476d5df6c31b55a388a40cb55782ade78cbe387b84e5e4a6e735cb30aee643634fe5ff37fe077817f064195ba69b00d02c53c14f1ef397d635ff9916be63998579b557d3fd00a16c93c258aff4098e0db3215158e87d2b6ed0edb855828a28a8d1ccc2c1265d8ae627816afe9ca221ccf21c4bacff9dedd4651d898014bb0591148b6d181fe0d7edf3805dd461fa0f6fd0f61ba232452b04f52a8dc6a1a132ae6e7ecf03c52936cc878ff82adb51e0925b8924191ff73a3cf72cb34c14ea4e1cef12d8305f8f76266a2493ee38a66251f56edeeb26e5eb0212ea2136a7ff28016eccfccad37dd68deec27d100288b30f3889677323c8293839eab25ae20b069b706c3c957ddbe00c65d765752818abb7bdddc1c66169606bd0ba4495072f06e3f4ca5a49cc6714da0692e4d5850f1b6db9af06ec9f055d4d9421a21590d65415210dd6f6963104f4186c805e380a6e65b8f294186dc8584bdbf63e9379633f428b72e761560a31028236c855d63f4fd4eb8209cb50699accdbab7b9be8cc497f1a60420c1541f5f8211e02e983c2abcc7976d4e2269c92225c299f3204735d47bfcb0f813089e1a22c42c90e695cd6515d50f40aa990db423d8341e32d362f560783639bc95e194983dded8c488207ba7e8a0f3bc2643dbeaa809c14ebc9053d88dd1bf8b43b5585396743102c5c7a06cba4b3df6f902b063e7999ebb142a3b853ea730f4e2228474ee1793de10320822f608406c668ecc00406fedfdeab51bb9d48d6064ae913d9a76470866cc5c4b6fd525a4444bdca6f38f6a6bbf3b17ea430ef7e09e161fc44ca49d27e4a0478fde80c8952415bc43861b639d0a5052394a61fb1d8640c57253a4e9cd73a5ddf12e1e2c0d72d1b4450db86a5f65614a8b2b045405c03efd2d1434352940dfa81888486d52227f6cc4837e120380647a8de46d34e4b10a1617283715eee480f8c10dd0c39dc21c2c2c969fde3d69c06723f3430d3602bafd17f6fcdb02340836d027aa5af429b887ad9b65f2dd068429780305e1c09a518372e81fe3500fdfad80eeb7344216cbf80d87f0cc5509d7decf56161741a30730d7b9ec6409025c5e22b30502cc90303c4c6c66e0ab5a80314b56b6f0602a688f86cdac2a7865ff6c0534c51546e6e305ad1271b14e3d6645a0b10e81b6ed24989d688c56b11b20b07e33062f3e368a1f5e497ec1b79de2f2e753feff7bf7edb270e59f08f55536a7a7e2bc9e2f264de924ce8ba920732f00cf80132f9a0863debec820f6b8341c461aeb0c070bacb364fb96e67f6183765ab9cfe84c585bd47f765b1ee29e5022e0e532ff5a404593fd2889adf5be9e136bfa43bab523d2ad2d25b75ac7e3b0fcde7bb0537f16c214410778db68dc191e8051814a4c8501b9fd3eaa9549c63ca438992dbc5af61509e2df84fc8bf9b567db71e868730d34ca3153e0600e6650c1349f0b2ea67153f451019c1faccad6fa942ceacb3947d1d7c95fb66fbc04d5335b77deb2bc3b7bf4676d71e58b83c4e0cfd56573791c3361b2981e660b0f56f2dd7eae2fdb00c0b776a551e0655e3679ba3f10063254c18520bdb18a12cc07ee02f5c4a794ef51c28a947fd415574f2e40f67a6c578fd5333d9b0c0b674baef5ab264007ff7df24bcb28a01587256380f6c09ec0b2632b29a475d71f7db3be2b09a9b38dddc45904e05bbf0b1bca67a6ee536469fcca7db618647a36088aa560031bfd2bce6480381430de8111c0ae6301591236f4eb53b004a67d9ac676b224c95e123f3e86855440f7a472af6a2c3facc7fe9bc2fa3e05a33715c2cfc1aef3008683d3ed812bd7074731861b1a4922ceffc23e4ea3163af2d7a5abe9abbe29c6d3f64b718b0b9509f6c48773e83f874dbcfd00b346c9add8d9a70b819e9ecc8c126761366d48df6ef15c6af8353ff9cd04b00f643231f91ee7209f1ba477d06f2b2a129885394eaf6bcb1c006e0be3d63cc2629cee84f53288b866e765c35285e074ef0e1fe48c1ffcdea0bfb978c6b24cc13da26eccd5971f07b4d19937dd05f002a8aa1f1aabc95bf257a8a2ce61c648b50a43b06c160e973f23f1d427c16238b593b3ed9bac536114cf638e2ddf14c774aaa15cd3b784fc38aaac6be8753e2d913cdd30f0f5d7b4b3052b5d2e3a80ccf59147951bafefe2ff87da150390e4081bcafd20e2856d15107a74f1b81413a8fd06d80df0dbe44c88dcd3bbc1302edc7f2076b0e995e432c9eddd4dc12dd8a6c7ea5cb09351e72eddaf6293daf74e848a7a72d3e7745b6e74e1aa9601ec8e9f5164d614c69b93b4d2ed45420abd8747bb7e0ebe30680614d9f413cf8a01a657d04cb9c52946ebbfce6160252204751f33374cb513080d8eb6dc8a9cf888a2571ffb4fff9d739739cda8e5f6213a9c13d340db9966a2763c9f74d9fe2374c9d45de65067500ceddb0271f6318900f6215d75d45c23180078d85289dfda0472036c8faebde58c8a10e7687b7cd33984fbe5c48cbf2f885bfd1cc535c7d0a8fbc8df055e85cf1738e9d4802faf7b371b09f247f7d1cc26ce68b0b236f1a710b53437e8a5255027526cfa4110bee2c75a3b15df5d42cdebb256d073fb59d84db51360f9f8adc0fbab1d29ab987aa1faf28443dcc9f8d74faaee61bacf455ee702fd4c3032b85dadd5619cdf079bd484c2c78f8469f88883030d13acf3f8eba87a0350f115593b0241b661d721aaf50c5fae442438d44d7c1cb3de0a114271d8c843e320a6b2c66d55c5f1a6ffb0f8d10cbf656dc2d193ef81cd38de774b84c9b0a33a6fdd3dcf094927c8945b1d3928e65bacf6a58d2f2e101756a8d8df54250a85755fc8792213969d956a8d1e798d91935aa0c31ad16673b46d05e49943f3c51774eaecbb6d2bc06c7fe788e0def9c0fb50150a1313541d6209f7141e475643c71ab017a844f3feee5cd9aaf7ff1453e0a6bf7f2e7e6160394d7e793110d7405264cf25d6a6ff9028f38990fa5ef13d8f4a49bd17e8cafcf2a2997c8ab5d78aafec8c69346274f88271e5d52c2e9144f7219012a20e3a00f01311c8f5f69ba4930feff53fbab7b84373f69729212ed86c030b78ee545655101027adff6f8c7fead1c0769c94978e737bd2691deb4dbba10dcfeeae5eb029100d51339a424da5f123b4fb267c1254ea3b44dfbb680baaee72404da1c81500c018cf67996f0635bf9c8d00f6eaa9c4cbca3e1b93cb617ff4c09a0939a575499d9c8b25a8254e80fa0aa0c3672417c8abb596e123adc48424a84fedebf4f2e892c1eac02e60e6191e0cacb7d1846773d1bb5c6186e59cb0ee187f552fdb0cda79c08c9ed4a261ec8aadefe0b0de1c9890b86bf324a410e0c61706a535fd2408ca12d3bd7454bb755af0974bd03ae05f2ee0adf46317ee5b3c5aa37906f6908c57edf0bdfe8952050959448c02563c937cef52a8eb1c99a351cdf5a9618cfe73de2a639e636dc4b931c9c8fda27492a8c424e0c700894df45fa48954dd9592cfa75d572114489cbbd552f5846b80d62bab91efc76ff4ad83e1e9c0c2c5e07cc0cece86f0ea9852fb470f112da7a893caefb7009954cb5d664ebefd3f030a3d09eda4240fb70ca32a4e63d145563e06492d5a339dd0cd9cc2105691a61f79654968d15f1db0d62ff2242d07648386ecbe7d042f2a6e280f1346aab3baeee8825c19edf6e2382de31a633f1c3d95d49d9dfb618a8a6f8b984a44ff5e7c6b1e4afa6d5068ec8fb997fee3968e67aba7058a6d6e2097ade9fa09327b3136f771673b983e3c13d7647eb2284e9efd562d2bd12806b7054d5bd04d1aa55a090dca1884a5ced527ba9367d7d76ea4089bdfe4be19569a9306fcd447a4beed8cc2d161141bc16f3680fbf32d30cac6044e97f78c6f01bc1fd3d3beb61be4e53e2a60f4356bf79ea5122a4b3a80a12e034b390823460d124ddded3802c5b65d167beeee5c43f4dd31d480d63895dc9d395172f0b6c45d590b8e1d37768a218d8b12863a96fec7ae28f6d0f42580513d64e8d5d4efcd3c68d5a583e16e72bb8f10018676627cfc5683435b7f313402dbfb59bf4dcf230866fc79781c18b45fc262884d5684c220ecd74393d2feb3ad2b37c81ed4058bd11101defaeb556310b6bb4342ab2319ce09947bf674096d948b439fc8c1f374e973f24d3d7b8287ba0fe3c17716becb45593d68395c81734c536852977a2a7b2f956a84ebe557ccaa0d713b833345afb06f5fc56565a3e4da18d85618eb8ec55d5c8bff2ea2b544bd44c4d25fadf30a2abf819eb3bae3b6decfeb36716a45e37af806f01323f4498b4ffd9101733ca98612c3b6fbef399faaea7cab77248cb868e13c8257f59356bc3ffb400a32361e03550912c2aea12545d0541a93c427dbdf279fa54529f974d8eb1a6ae03164804ce060bb8621cfe1ed0e725d24bd87ddaa0674849fbf35f246a7e05b42d5c2087c999f6bd481299ada3b17ea8e824f1cade1a7ff796e78907f7658e5db9ca00c18e1bbfd604dac2d999a3c4516da4eb71720e473d42778734bcc6e9d36de90a990932a844ef95d8fdfffa09a21071d1a9d6d1984e5e3455c78bd1e43d51281c949bea200eaa8fdc36a43aac220f126cbcdd834e4e076c706d17ae2a2f6df169a13b3418c7b0d0218852c241dd4294d0f5ed239893bbbfc15b54c1c9c68532481e5b80f5e3129e7c9cb44021ab993c5b9d7ccf52f7869e53108f6af98141ebe6a5b73577dcddee07324c444ee4947bdf78f9f9003658e3faa4377d728f0cac61f7e3cca73506266979db418493d03dfa0d96e9eb3423f6df9dc0d5677cb1c50d96ee583853c704501f6e03fbe1ac19cbd49f88d07b8717b892dea587e5f907ae8241cf2b66b84335b40414ab895822ec29c9030284ac649ee38c11dc5cc887e856fb516794c076c72ca8478ef80a57725d2fe50365d7933cb5196e05c9860ba6bdee16d242b75a8e62f0bcaea3a3e746c0a1112e4ebc326c0564606a750935771702bb0ce09ea8b9a81b8fb4afc5a3474bee52c753afcc21eaa45eb2b1c325299e71bd7f5fc6084819b6c3a8dd2e15dafe328d83dde0b49fb03cce5b5383157f8e0b955dde641841c47b0e1d18b96865cde36751a4ef78202b756e70712c4f6a1949983b8596699786af4abb0075955ff9eb6cef8bb669f0bed97b5db862189af96ce7cc4cfdfff9a3ef06cecf4262c397d48af62f07f9625253355248983937748d553857990019ae0da21f8b8afcff74c413c251eb384736e66bd2be8751460518388a5b733120b68a74d3619fa0beae7b24184853723655470f4ee71387de421a2cd214c0a1b1af0b2e62123f6a5ca500c06be8cf65254ab69d9d187e96a58f5585deca0245355c5445cd1a509140870ba16cd0ecb045e676c53319889a12d5867e857a918e02c941714e7233489f62c9499a1689be38649bafdf561923a02ef7cdf37e6331f6b86205223db8bf7fcc726dd5b8d2200f716d792a4ffac3919d7f34b6278ac5ae0daf46251be1d9f4c22106289ec8533d10805dcdfccd42758c74a3056014aaa01d5da883a75d75cd94f610f640620f3beccfde310aed2a01ffcebb3e1e65a33d5d36f7cb3061b5c90a1f9b96109c57be53e5a0e1fac78f72b802f16cdd25e6ae3f1386208b3cf4493183608e416905e1008b4f506632a3abe06be80bd0a294c01595ed956940750b7127bd4cf60408dd1bf73ef993527ab4357b28e5c0363c9058b46785ae881303aa2aef7f5c3417491b164f97c4db6b765b457568dfb27900f4aac5a3605a45799ab8ab813b3698d7f028d9234bb4293673f60db82274214e610403dc3504e097cba43b1e501809a640660a9448dfc0c50ab668eb5ad7651f8afb1d69888a8a15c14c5e36d9034d8baa2f24440119b415cb5254018f62c835aed12a0d81acc1818fa7ef617a0f6d3300b9f6f4688d34298ef9ad458cb2746cf1e40fc094488db5238a79adf1f2cf87873806e5818e9e3dffc0d0b83bc9ac9a312329e4b5912eaf61049e594b544a2e287a32681b33e3483b15a757ada0124c046fab31d485e41f07a9fe1a765b0ab491224c79c134043fba94e151176f0f1c79429fdc028da1916a5ef02f26ee83111b91ab163ba950f3daeb5dbf6e0abadbd0b9e80f53874aff9cd0a6a42c0af2fb8c62678108c95ac04966a1504869633c1abd5223246f8dbb9203ffe573b3ce8e800fa748cf2e04d3161d771d4a99b65310daa90b0f6c9f2f9c107688753d706435b807dd937b542ee28603d00ddeaf8494db2ed467d305364ac8b2dd9aca1722cf6f3ab2cbc719445e5ddef4108faae7dc6537b769ea6240771d91a192762fc0dc835313dec85742a064b861545480745f09c19f35cbb19fb8ea333386d0e4f5264a0001a980023101d7187b3fc453930fc7c47e598e2e2cdb214867e235f7d48c7175773eb0f716807f25bb31de19cf65e443c5d22be63eea80796cee423ae290fb64dbb69c5cf4008146a115f69b767d4b9f3f3fe7fa62b0717b25af0000c260f8e7cb2bce80434e63983e7069416afb6a11b94cd4e4b7d0b4af1fc3db04162184e053e5e787a9987f937470ec11d0cd5892c4f5386b239b1db51fcfa77c938ce2f6fd2773316f745158fcba8a36c9b4cf9dfd4a77edc17a11f39519e231cce1a28ed50672b8c4ce5b27acec931b1e274a69e1ac6ec294057a34c88eaf4ef3485525a621b950dbdebc7222e5ab8238f191afb6afe7942c5c56c8914296232aa048de3002e29330e067915ce52809e757f3222d31eaf03757c95d3241510262feef223bcf5228843810bfd82a90beb996dfcb6b1144e0e182dc63d141100e29c4ef3917fe096f8920ed7ca8e247259f424767a9e4477e7d840e7e11e0162fd4171de0739ff45d77c7cb000a2d7e756d631700e6a88313eace7be7fdc76bd226452164409c329eb0f22f0510ac81333ad26d7e57e82c4474469481304df1eec920929f823c6bf617c3b71a64a94b3c453aa2c800f5e83b0fa8eeeb15b377f7f428ecb839db2b04ad346e06dbee7668becce47c1b28138defee307c0f712c52187fd9c5dec56b6dca342c5949fccbce652f1f8185a216c141e06e7c32ba0f63eafd0344328a50a8e6a03eeca65c3e07e94f783b8a89ab79305f23b16b8e1c3973948beb2f3b12c79e6d2dcedc08d190e21c8d4c503a6d1cd281f1aeee6ad3385557c349309620dca53b72aaf6f310c3b52637a6aa7c879f4f3c88c45c5c40ab25d94aebc9a85b1b320ee56a72adba028b2ecb9eae7ee9d245bdbe803f6ee4419a005786982489bc5a229d9dd556d35c0296db4f1d011a09416c824d87b451f55aa4fc8977cc52dad597152a6926eca2bdc8d09af3a1c365406cea39538bd6545796d378348ccecfd07e7da53c4969566ccb05f18e3cea87757d399d0724a2f5b4072dfcca4ece9f58bf4a85771100901042244780f1ee9670414e5b860c6ad9e66900e7a2e6328a3e300d6a0fc18ceb97b4608e9ab2805d093c83cd9592ec648365f924822d5a9a94d08dafbfc04fbb0a5995094df5e4ff0c0eccbc1e2ae7be9480d310657ea0f58652be0ce504e48e1c33069544e51ce33a9c73ca6b4670094436f18045d8ec32744139698dfe597cc152b0cd0f03a9617a8deed9583a866a01902c7f225999dabf13c95bab28b5b69c35636042d22d624285232536e90fda16ae1d320894df996a46ae147da349a47167cefdeceeb29e09877ec413a95b8570d24cff851f0420b75f363cd070d7560164eeed19fe4a243e41fb3be164164d42a8148942b3dd29576d7cadab2028ac48279dfeef8fa28e73999165db27d43e42ebf72959869d0d7c07f1fa86b75bb55e0d0b7ba741e1a72fc02533195e3da368eb46f8de044746bc97a489cba1fc8ff8e48777a40b5583c51f98ac5ae2b8bef8a19b776a78ea8ca06d81c2d878e1475e80ae4db287e9fe22b7dbd0782c7ab78bdba4aee294ce1d23c021f730652cb05d2c9c66267a92796943bd11e631d5e708b88fcb98dd50146dca2c98e7ada061272b55798935dd3f171d626fd3ffbef4875b77523696ecbbd6db24b08d25cf28f1c78626d9e54a50cead66cf3ceace748581904bb1804ea7730a0eab7c80e285d2aa0be5b90c7d27d7882d42571696b07428356c7c4319dfd59a1e3908290f2e931645f90ea5b5c5af5ec4ab929a324d68edc089af82436f95a45e75aa312817f55c6e4f6732bc10a6e1dc95c7f9c17705c7b13a71766b6fa9f55d236bb342d75f2de7fad6bf53b0b60a472138ebb9d5256c98c7e5392e39622ac187fa2981addcb993ea265ec387224531f15ff19cecf3131a9ec4eee9faead5cfd7c2ae07398ec29c68931f904ec8d83d11f78bdc5662b7032b7fbe5dff3c6ad3330bb1c9dfbcad82e009f411f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
