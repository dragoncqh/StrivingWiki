<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c22340196b7eeb42987f78b59c22929a0b084befc68b81f7a9fed235cf128175e44a47a3ccfffa0a40d9735f92efe8e9a2ee0c96cc0c88c39f1c24f8837312dc05933842f579311c045eddb29ecd95be0274333acf92d07119cd3878df5ef0fa217c379285cbe0e45b95708a32b5e6afa5945a602c276d3d3f0c0cfc64bc5636297f9ca54ab22168bfea78b52aeabdfa1edfe19ae947ec1de094ff932ce95dc1c44798ddace2014f3ef945052cc4ae124a2bdac2b8ba5b2d6f5f464093c80d9a44e693fad8c3674bf4a531f26633f443aa98ebf8930dfdff4c70eea54c8b81ef045316762c4178cfe430571efbc3dd6a7e7e68f092f8b81bb1449962ae0a38ef359da3f2ee9fc4da20858fe7a306ef802485cde653515cbd7b9ce9ef6e338c500b7241ced03e0556edb014b58b89b612dcf08ad6b313c6aec16408755b22aa2b578524f7864e9da600b60c4fba175640b71428e27cc6f13706abc52c05594710728ab048650931bee9b3fd551014c0f9a0c47a232c9cd67735745145b4e6bdb77683eed27845c237521b4f74c6b2806c5422fba71dbdbf51195e152901888eea3d9c47e71fb6eb1d87cb1bc41d678fc42402a42f391a8cabe9c7bcc550c0905bb5478d83dc1cc7ced7e3916ea648c4635f89c5c4fdccc1fb471a3b7a78ad3d470a6e9df1aac6040b47ea05f4210b746dc44569f1e2074a680aa7494d91fffd952256b0e89b0d35ef540d058dad696ee617d17ccc692f4077d0cb05b535649f995204646da6ecb2f07d3a4ed0feaf3ef00da9907400d34e577bd430ddd4b6c5116084042eff7975b177ed9a071125c90b31fa88e39900a97d39d4f29a7439db3cd9c2a9af665e1f25c4d7152f8490583fe079f490de49610d4c4a5983e4df8b9131d28cfca0ff405aa09eb0d0f33def58a64c9aefacce9c60f4b9479706ca26e96fb7e7be9fac420c94d84b823e33fe25c3341bdc3a47e2d7d45dd82b4088c0969cf1f22d1250694f51e015fe5a4c0b4f6789967babbb97227facf195ff66a16106393c030737288f2009c5f22f99f79433b9270235342d9b7db82bbbef921875d11103e5521e54c5fc1314de2f7e0101f10cbc48b716b0a413454a6d41fe2aa3b71eb3217442a3220fe28db15624c9b63bc6327bbbe896a90ca2611a177d0375e791d6d8f603cb20216d5db439def646ba6bf144a19be785365d704923ec468c35baa050c3f455bc5782267a1042c4db3549e739a05cf1d7748814c1fed2458e0584e70141e7ffaaa231003a9bfbc7a8f183f4d959d1bea47ad4e4c66d23d1ba7c1e3b3c4b71e09171f34a08daab6c35f62d123e9b2e383c9652b88ea8ba16af4e19f8c96e41e1385553d4e019e478da8118aa286ac3b27629c1a7914ca344fad5279156ca0e37638f104d317c63ec45bdf3629ac83d2babcdfb3f4a948e6e9f32752682525b25191c3fb63eb4b7a276ad8d8d600d37c0633c41c4d9ee4a8c99fe41833daf03680d52088b6d142717f7cb4bb23e1f976fc4e1bdef80bd958f0cf61ed98497e0b6f64d17142aacdeb19015900cf5eeeee99b276cde518958d58287969ca4619c0f37e455ac33ca2730b9741b39bd1a57269b7adc8689292cdc23f89de02a79e79b50bb44e009305446ea0d43e35c775f884fb895d472e0fa5206efa582e8132f883db04f836f464321a32e6af7521ea7d15234a221ce00471934205e9e549bbbc105b39385d1e5b7095a2994a1efbc7e802efe139e872d4ed8c9e53ee397c9ec64d3508915b7ba70282a297cbbfd94b363367e35d791d28e9ba4932eb3f94e9758e4b3f503cc1bdc52e261d1ac4abe84b5ee6b2f6446c26a20d0a0faff190de01ba486376d4f4f7409048c56fa6c09618c2cb5413f37307bb7802db4df7e22a7edc98ea8d152a0573e940c1ab8146d720b6f792fbeebfd9a7d2fcba64beec1e71483ff506d755f6ed11f81faade9d4ffb6a8ff78763fd918d784ae9de9b6000055ae3ef4db43397c4a26942c8d8e65c5731bad4ca76e95f4b06c3b3cde5e776814412aab69c9939e10df72ae15ae9534459bcf8809951dd4b3d3798ae0a1b6246f5ca9736a1396c0640dbe5ecb6f5714921702465256b025617816640a0c0410149a71ad868d5efa71ccd9be907ab1636823885fdca93fea4e156cf4c7d9765cc01a817d1ce2953aaa9f44eabc046120004d9537f58951fd29700c73f1644e106ad56a74bd04f3655868805ce01e80f5bb9be5d940bcc4dbdd54fdd11cfc2b754524492bcc96b4690b7aed5ca3da6422b82a63c7cb480530ff02ec5ca50baa82a807f71c16a43bfe34562859b929a552eb170f34f8275b288f1a3b548816fe3f48e1094b9ef697e6ee666d651d1ffc2b9f518b082a953932e884ce1ab5607dced8c6289fbbf37c0c769c67fba28ea02402943e7553f593b9edf4905299122e85fbc7a0fe7f5892274d41d76de41101e344dd13cef6cb4215fc686c6a2985b8565b3c128bf65d8070a898d445f441ed806bc44df8cfce1f1b535a8af3630b94c5287d21562ac81494358e0607314088653ecc4b43cb68a7d6283095a715c71755ddce15ea4c409305a0d54d67ee34d69d3b4db478662a65943ba98fc3d161342b921ec774325d556df89e5efb3d27992afe97e19eb88500d348396d936b8bb0520110750190db5ddb0f93d62c2360d57471ef21adc64cf23ef0d3d5dd424e1c29d8cefba3f42b7400b0faabaa63973c54bafff669d1e07de39d9b986fd937534ea6e51d57363383fad73f70b7f0f07ce6f7c0c310f1367e000ada45c5cf206d673a57a704a2c55bd79f48215816b64bc70aa07b5882bf9089cfde3f42a10b05a68aa90eb11dc73315ac6c1d5d9c05dc6270351bdc81892d9ce782ae14c790b242f396962483673aa79629763447e7ca27ba4d32f7647d7c4b65ac41c4884f606d63f217a7bac32cf7278d6d242a9fcf51ebeed7217d7d831fae5fdd349f88d902d477d4c9147cc1e157d2df084463db2b63528aad1ac158336e13493d7a30d111b8c48014658b0798b8a1fe41cd1469829c50b5d20f7b408fb1bdc05253897df1e25b83f67313c2738005404fed8e8d6dfcf4c9ec67ff6462d0695e50856efe1b1f0bebd398a9b287acb7e9fe05d67ad947c8be54486d9e446ea57102ca15dbce21e130aa11c86fb677bf1fda63a29e394039eb81895528f7fd2069270375f50952e5e602f38af19400d0431ca3cbf2cefdbee00a325bda203c20d2f08f2fd4ef1688b64fc950c9d5e8830c4277da61be22f67bfcc31865b8cebddf748918c555d89aa3b7f2a541086d23426e682b8cf94514c5817ddf63072fa357136ccf0694cd8a639299036c66348cfb87bfbf155f4104218b6a7e873b7bfa2917b3da6fda8c8339ac5d42fbba24d1f94ea3440924b832ed6be0f9f3512ad5b9de5e9497ce82d03eec4ca3b648f1a6a34385b4967f2635ef4b8b1d034488a9b1f0f74a5c7d2b6de3afd26b9e3e097ae6f9701589e87e6fc1df7b29be1ae803c2040db24aa93de7c1c3d03f6a7c2a0818ab15d11608b00a24ba7af59d0ee9a91103791120800fcdccc594e29b9d195f08c3be805cf76408d4095b3e22e4eb7c2d77435fd1bb2af2696b7896d679973e5cd7d17412ecad9c03774868bd4d40181d656b595f7ab8547d009ac6c1af5fb9aa63c616d8200b0cc594ae93a1f6250fc4c712cb833bac4b76efd0959a88141f261accdfcb3b0ee07010bccf588c7666f3b997dcd8d7459399faadb42688f990acc859ea4b30405b6b58423c3105241fc7f257ea11837f7daed4ebe1265062d988b88bb76ccc24c78a5fa1d09e4a0d4374c8d102adcc1832871303753da57d086bb211858911be113c98a34398a2ef8507dc40ac46cab9368cc0f1aae887c81b4594e3ee9b66fff90dd982af59d5864f94de858bbcce0a5f6d479ab0baf9facd9624abdec3cd75407757b40d00e9bc26d2b336a345d9ba45e8f0ee87b6f14fcc4e1a5c04967e9c851a6ae4b25253f2308a2f6af17d1dbd167e71831e9ba4d103a3659df0a3d067013fdcee89a69d9fce70a4dae3ac52bb5121b48773b7e80a70fa5e45443c20e6fd6eab7cb6d7d7ad546c02ee5531256ce82c1507b26afe71ee5ea3b8f54527aa97ca6d74b1f8b9a692e75e9604e4c5721319009af8a09a3eb91ec497acb3b70574604946dee2b57e978ef1b798a84d25768ba38548cbae409b955f0f5d2ef2039ebd04affb9d27f893c3980a90f87553a20c08ccb943aace30dd251030915d35f21ce012f900d29bdefa8169ba29128aa23c643598f32cb0075ebd6f0ddbecc28737ceb80c586448ca8f0c43a0f1e0d2c5b5a4a7d27941f0bf6c367552acbb2557f57a99a4201dbfba4a3fc8e41679a33b63cd30bcf685f378bba505e34e589fb007660594d4650330a41dd76e229b077edef9d0166dac6196cf1c21cdf9c23894824bfa1e82853bf31bbab187428756dfd56b75e01e0a58949c1615d4c27dc744cdd8cb21444484561e8ae05bf43c102a9122fa5acc748a6751da45c1dcf3218c3b799f98bba8dc522a21a5544ae61e2d2b4dfaa67adf7e96471c487a057e00707f823f3977851193f8dd67c95f65a683c20812d7ca0e2bbdebc3d3ec0093e9bd572b451f17286bfb19160c8d595834e678ed5ebacc6949a8360908f3ab1737b1cd33e7180e7c7dd0b8f0b4b8076c765081008d7c0070648693fed569612d802ce9c956a731d3d1e7d6e45e48254bd58672e9c762fb9ce189e469f3333b56d885889c4585c66fe4ea6b70b5a149bf28cbe74e4edf46ab3785ef81ec95e1df64bc6bb32653441471e505a53ca391a177b5f382ea71098e1c660eb7d02d56ba12c87d27cb145a20ae9ef288623b992818e23b1885063040b0c95d75a5dda377501bd219dfcc09c873cc0f2981e21de38b05946d608ce0a5955d3c2329148e6512157bfc63589a3495c2a5f2d0185ca91d8ff77fbfdaf79159cf61892816a65569ceb40ff511565e039eb23be4236d5ec4448d942b419b770b6ec0c560cced97e212ec14c69e0ba8bf2f76b50464fe18f5516eb7a1114a6ce70fc96109b97b2e50d7dc65090cbb09f04e84d7fdb4f1e0f11ffda0bb3c1d43a8baa57036cd7e09b4f7a9ad0f8bc19f0484d6302d387e763d2c1631a8f84b0ca2237eaaefc47c3305dbbf0ae1ab9e22abbd90fc313e7e07ed8c9c7bf50aba0856f43f20c518c32b0d1a421ac5094e7cf110ff91251c97eb4dd817a25b622f4c34362ff1acd5d323246d36b36bff45883119b0783bb79f673f0196438a12a9105d33a9b24dc2db1279780347a96832ed40e4c8bec5621fea85146b1d74c696fef6902c67d9443438400c4f83861ae23c55af14ae59afd4f28409a51a1eee62e74411b83b49ced36d699d312f12189a280fef359f48a1d59939306d57b443d107a9bd9881d6edbc2d4a343194716ff5d6fa034ba40298a2749a4c2f590427ee9012ada4c1f682b5c903a922cd4038d75c57b0fbe24a32980c431b686ea8959282eff16166137768192651a30e48923fe6b89b0fa02539c0fb799475216d924f62e369a896f2725abee48b3654b8f4f355c6ad5c1d7493718b20599441d8a8e7cd1b2ddd0424d42eb247069cb108dd06cdaa4d821715655310288cbf555838ed3bba6a3fddbb1419a25d2183fcea6e8b76992e4d224d38fbc2378605733a20537c6ca20bc6e06a2ab442d115f9663821cecfd067c368de2aa17eb0df6781d7c057c5acc667aad3f359ece968738fa36c893f3e85e61012b6c6fbb77155a464c5e4053ad8aeb874c871f528f3af2e98bf0bbf607597cb004b8a3df645b3010a6c24374db191e26833b9f803ffb2b8378272a9bcbde6d1ae766d8f85d38bb7a91c47740ae660622e9408fb882b08955fbc860caeb64bc83e981b74988ef6d93ef2d29a6680fe8fa2aa3613ce4b3cbc5e32208f1151195b36860672ddc79429fa8d264992a53b2379c1ae43ce580e2b9d96f82d13e3621093abbe18d5388bf6228deb2b5a44c30ccb54862ce2efeba57002684b09751ddb6f3002d50b97aa679f4b95c83b72776f70766f0392a01337b6e500d0cd0c5aca70948f873b6fac2a481ddfdc57a4a19f68752174ae1e2c4755bdb86b59516d7023a335eb8abd46edadfbc7e03847cc47afdc8f317f04fe95e2806686da8575a80959b67f216d35d40dfac304860acd9cf47ec30aafe4a5ac335a8713e8df374c1cac04937de9cd513d9e1da5fde2587b3db0357f3a3674769785b9c8fa508d10bc96bbfa84f896701a15718186ae30b4666726a3e25eef613e647903f77e63722b60aba4c0568e5c7b5eb89ab1148db5980597f8e61589e232ba33499690b9285bb0c3ce2b9c460d86ff2318d53012716849386f13b5532b84f5ffac18c7d1d3593e917f941aaed31aa54ae60c5bf8014620f0d03d21cb5c923ea0ce361d6b4b711ec5df31588255bb6984b6e635a6a1294496a5b30acefa6e23c996ca9bbea65f985366ee842d5796838395dbc270d6b4f7e4b3e63a40c716de858419322971bebf5230bbde2fe85b046163841fc0e9f0161a415948fadf23ad160ce2bae8b9a5acdc3d59a1c7c36e71266e2fe83e3d276393286b35fffd6dea8d664faeacdf345887f423046a552706dfd9d0696683b0f3890f20c39f35d1b1c707625774357b90370a5604b9480690d8139482e07115b61fc4792c6ad38fdb8f0a67b3f38b3c6d82422dd642ce8e3a9d4352774c1e6af0eb0db42384fa3f2bc06b39903f6f278b991e539119f55afe04317f4a99d3fce82a45b6f5a1c1af5deb80129d63e1c82dee3e9851109b4fe19c550e9348690d5c3a58b805262ccaf2fd3ee5db46f80dee5716ac04fd1a364500b672cd50d3476cf45b79aee024a8217fc6fbf2364b233160c73c51483571dd4a53105bec1d485eb8a72e8876b90b5f63cb2b814b48303b65ff8f9a45c44179172c28e5b65dd35761ac624c0475bb737d0cd6b6711e8dfb78ed71b248114d376be105d445cac1287fd17222ed5ae465e9d52bff73dfb527f50450eea92a7c4c6328e64dce09e2536b9d52f9cc01cbcb2ace50d483ac1a7f53cac3862224e2a1441e418aa22c00f05c68891b95ccd8ac899af594ac7b5587870e665263ea57b1353b00b90adefcf48525808dc55f2a26c4eaca45b5b773f905836aec8fc196db989e9347a5a714ee21162feb4d346ab3130cf7d4408ce32720142656db2388536f740be88d92654d0ab1d0d80a1e5966fd7f07d6f38635ceedb107d3b292bb0b6edac91919bd9aa85fc4b9929ddc20828af2643e2e64bb3c852998a8e7c6c04297b213cd45b06ebf3a640a1dfce2b8e5ba2ecbe0b47f6bfbdbb5621a69ed80c12f0b5c6aba537ad0d9d8af54acad825987101e50af669e77ca63516ad475e6fe5f7f26","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
