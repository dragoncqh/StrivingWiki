<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d2eb3ad4ec8d95bd7ddae735028b79aea1a9845b3211130271bf383fa1cb624b397de2c66a32d5b0459a1eb28d46e0c27bdd15ceca38fbb396d9f9e57c29cc9293b200dbe4de8304418b41ac7894509cec3430bab7ab2ad52e7de240d3418db3f7e739c7c0f02024efe6d3a770353d6d48ad16cb8b23d31df74b89bc1c1a2cdef01850a31765abce17d7f403d4b793be81df867077047b279386942f68266caf7b3346c806b64e35654de08afbb175c98672b4048269370ca65be2ad457c193b91fe8071c929f212224f0a556324eb94180d02b14b1f883fb1f8b5ef43659e48bd4346b196933c539f7519147c8fb1679735c9bb915e9cc21fc425ea3a76725191e756d9563879755520d76264664c971bb9d4797e6af3f6e26cf99366245770d70e7ad6f295598e95b0e656eb82105217c1a2e1afcbb92edb6d8cdc2289ed8adc9755223ae6915375dc75aabd34d1364fd74486bd0a89b5e3871d8a196e53a9b5824dba9e34456b8c3022c8610697a338f2f7ffd43830c8378317940c52c1304e5f4daa10a5c3141c2dd7a2e9640eb0995cefcd79064174e18bc546c8f4ff20a0583b0f744bb7e229945f5d37e2d99ffbefcc52ee035c1aa1da3505304c7873d4beba3fee4deabecb6e79dc32b95eed29b39fc5881c429678c6dc00ef3ccc9852fd441c14152ff97fb2f8978907a5049d572dad0f9da4ebab5d90b3daee8e23609a9f8c8ed12ebdebd5ef3a5174708fe4f95f44f226d22fbe46d1922c2ac313aa526e71e4f35bd1dfea793c12130c7e73c5157630ba617241436f5afd28f5576ee5d38edbc93b5971b0e03b069af1fcbee1c46e4d3532cb3754ef65384fba7b100cfbf7636cc1e922c278ec2a69a9121118e5a4d50f7361fa0af6ea67bed600e3c46435a586548fa8889cce896b95eeedf525aba79cf7855f84a1218f37097adf52b3cc800bf1a5560ef09037fc429a1c7804296f6e0a1c2c398c03340d1f38271a21d51e6afa04a714b8de9d02aec2d7be9e99ff95b675dff5289cc658366be9bbb972ac02d0c4d12bc546dea6a1b11333b5414980a7a77e3985afd59409540abe1a797021ba45ba0f2789009d9df479de8c454c3f0298357821d236824c556959a3de6d7de61495d444edc9bf0706d51dee1f877b4622c8e228a37fc0799a0ec39b72e619b1f1ef4784912f1212ee24f81b97a1d26912072ea14a00584d5f901900a6d1c1d5844751e9f75644c35f7497566501e21b90a3f4f71ed5fb6890d6ebd619f10a23f25f9db39925dad40d3ad363d665ab1dfda9eab747c7e55cbce24dffcedea335cda0f6db2633efe03bb23c2d9fc6574b09b22689c3f5248c283f9fc8964a3c8e912f2a75b42f94b303a5955d3b03daa03e9627153a8e1cfc276e5ee2fa314a02ee583f5ecf546798fcad9bfd1df3624da2b49da2211569ab58ae5c906776a7c70eba48418c4fc5ff3fcad80fd30122f61fce3d5059af86827af54c00735024789515932546bb4fce2a3700cf7ce591d9848c36365075a403b97d5c319badc1fbf2f29f7ff96c8c28e7bbd1d1bdda642bb4cd044b8986cf2a905d2f6943ebd175efe03501174d500a785ed32013553125c87841a6f06c28bf44693710c91b84e7d4dbe1d029650db0b390b4dcdd67cf87080b30218aca956b8eb38acbad6df5d83f4558e4165b4d11dadd2cc95f53434ed5996799591c45fc3107884bf806084a25b6b109e95b1f8eebd44ea5092581da8a29067d5cd7eb40af74f2eac93470401d1fd723affd2a0635c19f000729f73e9cff386712e7f882a72e86705f523a4d425e1d73c43b2bfb3466c09459361de02564a16b8767633efad9d729151e88aab5ba2f67be07a8f9e7e647f5e12de07d43f785af1177ef8bd7a1d2a65e255ab75b9147dbf409c01cbd854838423a6f19352edb56e4dc233fe447dbe44a366960e40521b18c23ecf110a8f84fdc68e5b533e248bd8776efc68a721ee365e44a4993afd662091165b1e9e3cd235c2c75cb1015bf8bb6fd24152ad98b90b661fe6a668805cd25bc06579f82356cfe31711d5d64d99b0a58eaef9a64155c3e4595a9a103ebe6ad122a96b0da72bc4aa18b7e2a012525363c838087662700c35f057c6b717aab0f36ff003cf9ec1d9576de415508f9c1a7ea13dc8ab8d2b0a9349d0ff1ee5702d6927c1ad54b605042592b0446829390b1f809659073c84fbcf7598854fb4afab0df0183c6c41c323d31e8a14e37c78a19577b9c478ad1ec352e5482c1343ef5791704556498b2625a46df104894a8a5781b0e4eb03a1c08dc006d6a762116ccc0ffc112d07ea83b9d439f47bcf89eee26edd68e1aa70af4eb820a17930f266d4de4d4513fb695caa619bc7995a8b608389b6398e1252f782bff356495e3b6f4fa72de61b14d15a7cc35206589f06be13bd732fa0fd8c506c37ed04e08a63b62a6fec71839fa64be4115d30ad34f1b76522ded17d1f3fc5a2de4ed5733af1dd69257e8006187459ccba339f86bfe87ff68a0c96906c04da612a52a58c92881321b8a536d63c9ec86787d47d8d1553d638873a8807406703997b17f3a084ea4b365838cd856dbfddc7d361b1e8cf4991810bc3dab397233e63a160d142ad35f660b54b625cfc37f73e46be9a7bf6b7379700c59abd6f90e157856faedda215186b5ae288db013b778c4704f125bb6d2a8c746209dae1d9451b90b6748cc0c328b53646b20d39d87e935a5017cdad5665d308443798bd2ea1b25942d1e40679639d20601d3d0e1433b0b163c2f80474c99bef5c496a0b937de48124a152b82e028c33ac37e22ec3b231cae5cd460747a2acf5e5cfb3b22994cdbc1b826dfd6fedd6acac0bc7e4d8150659151d69eb0af578ae772ef0a21af6de19b5593f4d4db2536493a5863c6797c8569821012e5e332c2d470a0d59b675ff45961e096b59b2a29d7342583457237b95b8feafbb1a1d444d964d95014b2e95a7b23fb57ea83fd527e86a9afb5752193b322dd2f768427f697c0bfef25486695074227364cc7a099069f81866fc40f3a18429225c6acb5bfc992b7ab7d7b0644dc43cd1e3ce61bb18394e5a5532a91b1b5303929f5218d33b45ed1f5890aa7788978b628d91652f9a0c111ecfd6567346ee6e7203c0c0355a50d27df42d048ca062303e1fd717f5ae47a013e416529b8139ffb25820b11be324790a42d1cb4b1aeb9f62da0eeaf190b6f6cc04ff1f9d858ee1142b10df3f92af26a1345cedaa263be0833d06df50c61c97fab3dc285e4798c82b7138781d59935e719333171ca20e98ac0076134029a81f5d9200aa1c0a7dcf86c58bb4b8d463e53673051971dbc6e13943ae0d770c8d69efefaa524af11ac03ddbf517c42a323d96b87c42822a621c8d97ecaa366aba650216aabcc8a15d4f50ee52e89f94ade3755899a2102453a874797f86a3a52fda008eb3857e7867bf998cd5ccbdc4629d96fb944c77b6c4384785507d7eb129900262d0defbf6798dd5757ed2dd6d8163af1e194f368e1be9e8d93cd73ca34da106e31beb4fb8f826be5fabd41bb5854b2ffac562241639bf74c65ae794275e925e34b12ebce3df8717fcd76356d67728b3fe34d3e9daf6278de26af16da464fb2e8d459a7fb98bbb36cb8abfa4769d42084bdecffd158c6d536750f2cd8ae1dff679a43c061f1d6c7354144953f5e9e925ffe6988c9a68af8fca4f0307ecafab398b3e088c93241075c8bc2733e72596d7e2046d06f061c7aac5e769056bbf37dfaee4791f7c086abbfc501211d2bb29c7fd78af9654545292f97ba35849fbb3ae23872fd7eb54ca587b7382f6457e5fa04befa7556b37d92b2c4a643fd96920cbe70b938acc7c3ee6e03a7c1cfdaea29000457454e158bcbe6a07e1602d583d365b64dd87373221369ef740cb45542bef7c45347f21c881bf20c858d653b7896f6f01cece1ff6021139ba5884c09422156abad1f88aa5bd4ff01a9b921675c9d849e2139d9b0e889baad681d21f22d13aabc2a5b8963efb310c10e8fd4e74f7c2fb9043b32e670d47e85caec9030f8b579e2e2eddd9e9496e82692532ad2f2c749e1d02ffb9dcb49a568155cfce82a8c5a1b0efe43e549c793f982d45a4bb092350527b3e1a66dd3acc8b436a76cac710e1f076fe50b3557488a89a50872de4636b897df11aa6400cf91081737d19ae685ebb17cdb8d70df75f76aaf261e0e88365f3a746f75f803fb7078377d8930c53a20063c6e2ee153ad266aaa888182418930ee16bad88a0b514cd4c10f0970ddfaa69514d71583d6b40cb66be30112f14abc54a8d97ed57495a85c64b955d8dff898fa8cd91d6a7acfe2eef7b69768fe0d76ec9f797c1a6ac06685cc51c92f7256402d4482b9e742be2a5663e6ab5480f66b67504271a1e78d35e990a7fab1c439e94bde0b27d3c453e3fbcb6e08408b1ffebe97817fa0ac0c58692c6dd1d1c383c98dc5bcc6a43223200a4c02f2f5b6774d2f937a402b251f390c9e702154c4b005653fc1baf6b23d25663355e2ef49b9138d79047dc962cbbbe70b2516707d93035a16cf0555fbc8d3d382dec815bae82523b6cf494f69408ee6a0520ba74aa608c7a905e26b5c82b48535410bf051babbea9b2a63f7648fa2708d4351b381985dd81a5b5e198b6b0ec8be43e06da7fe5076ded5f7b203f00d892b2b191a9309d44d22c39a2e96a6e2544c5009f1d212771d992c20e9c4f56f32c0b8f7e9ae6edd363fec68a842f099bfce4bb1717a3411644f54d6acae1585db351e33ff0cf177050d2637d38e2f4ee12c9827836c804695d20fcafd9d23daea3b1f1cc5cf82be7943643302d3f2c3b8648bc35d53c9bd97e70f43624d8583ef04a62e53e731fdbfa379833bffbc7872931ebfee32ed6b3b738a3372db765f4a5dda9ae9d24ba6c2a25052f81ef38c7c267aa4dbd3b3e3c78bd88f1797077f5ab88c2ad05aa621c374137b8471bf2c1cfb71ca812b48522667f2849d9c4ec233f199d79b4cbcb142d64c7de30e260d4d49fdc978bb3fa9d837cad382099bd00ada717e92a5b7aacef71cc90b1d37a1d9845507cb229300b7dab3919e712dd97848ab11df5e409466800a873ad2865da3a394358713c0f925ef78c140d05a712263f5e08bc717da0bd02d2bde4076462254316e750851fc5ea05a1b23785cdeeac1644529a4247a3d9a42d44100c0b667d37bfb6af9f623715fce999b5b15810601fd9b999bf3d5fdd190a6c1b85bff248d25762f36d89bc72bb087c89e25fc5adfb32978fbea3d068563a4d44b00f69de25c13267bac46fb46babc956d528cac7fbfb33e433e1e09a56441a8ff9beba444291a9f4759bc16d29defc859c562b48b6e6b09d7c66a948cee7719d24a869a15c1ee991886dff8bb4c81b93500adc36ba2fcef879e5f35de9e0b50580b84c92975eb4303ef4d3fd65e191a2926186007d36d0b5311beb6d28e949998d09bdc52fd8be49309ce347df2d8f8311e50fdfb9268fc1dc72311d6024506f52cadeb59f3fb2d2bca82c3570ed130760d2da012587728c48e4a591252f731c7b501d9131d8d0233b7149295e4f8c1dc1d5819bd0e141d30cd10ee18550b813723b05a5fccb3ee282464c9163a0952acde034e4e85aa583238e30bc97b0902cbc2d22b8b76cc3e18021f7153daa895be28e4b5bed4761893e3ceac5d6c4b88f77d22142ae3e1817952df20d10c006d2d850d84c82ee46156208ffb03818bd41317f7a2256e9673a00070bc9643051d1d4bd8a2a547905889150188acb19520bae5f7d3c346d3a64f472c9a8d61adf5fb1be93eb751361246c1ee8414e5982233ef8b573c88a00e1ad6ddd9ce7dc815d9089c79840efe062a27cab5fd138f3bdaed5697150a7a60af12d9b11e3cf3b587e4897c0d44db000820306a13019f141bf9b15551aba79d166b78a190835f2187eb7c1839c22067cdbcb2d209f7987ec18a7673e4d0d246d21682bbd54ec11642e502bd3b2d288c8a9e18d1e87ff808c85d141b961ad8fa8bfb912e24320326d1cbf057bc25e210f50759fe690d97e67628bfa321814ad42bd085aceba8c053af83da98f8856b6323b73d59e053529e65dad6a54929d06493ca71792e263bb4ea2810f72262da5529981fd9d6952aa1e050e080b05ece0882b56ab628847a451bc986283a19259de01a6c904b88ea4b5f1e68df170452dd13d50a891208d95a9192eb2e57ae02fee50498794f2e73da71fbe74fe034f7e4c35d44c37d1111b0e2651dfb24d7ba76745e6734a20847cf2ac50e5877ab505a40afc112fb431b9bf96bd6d618498382ebda48958c2f42c51f10f257be9007730efef3ee89dd5af14c288263a204c923d506ddf8fcd9778efee2e25697b71908135dc76ff07fb4ab35f161d993ed2b7c247b91533c58953d872df1052fdc03180a5b16d2f031b2494fca77d729cbc13c2c3c7c233df15a14ea8f3afb7a817b31159cf72db0241cc57222df0ce960ea07fd0b82b72088b572a32463dfc83154733c93af9bb07480df725a917ee9fdd6c42ee2b4da6d36320ebb45aab622fb4a7fbcfc5b9c1d0487c04d26b343c2aa5f24ff76b0326284a8ccbc240be175031b259ef077d37ca49b7d5799f38c0a44b201b0987ccc55def41157f6462dfb2c8670410c0bf74cb1a871dcc00af489ed4751d2e094e5e90674e9911ffc31cae71ba2feb699f49ce56f4baf6de862ce7efeb3bec7cba3680cf87aeac3abfba910b1dc8bade075d8f3e138ec22a947e4af04082a4ed1b4160fc34a6a190222aae431f245e195fd8a84dcb506a5d014d4064fd6e7d68caadd2e07922df22e869e37ed1398a826b0c3d37b524cddcb5c900375d7debae7415d1ea475e048f63e31dfe387742673fbb1d81809464202dc5ff9e0fff092bacf8f04071b5e359863155e952c3b6b2c92cdf0c1e667d6f54d40059fef131773db2736d0c08958bb13658f508b15916f95808164cfd5fc68e4a7a2783f0a92139a9f41684a1445a7239461849d8959d8512928b5eabe112a6098c08d0fde68d0b0b195f332ab6b1e8302321d653ddab60db19e442461496c2ce93f01d74cc4deb3e742d3707dca09f1c4e3453c668978f9512715e9c23d08a0ded01f042852f3db9c27795c8fd386913ddf49c14dc7d035ef5f635103ac56547650e10800b3d17b1cf5d4d77e9115383a92af29a9f05ffeb66dc465e531f1b41450e32bddbe1e858d1144f2ad9b7abf88eec24bce95d7dc459e91dca2a7a47b32fcdff934b20734198c38f19474bbbcf55dd2ade1d20eb98a9e92889287cacd8ca3af4a67abc41eee97419e4ccbbc1ef90a0cc0f5dfe8c12b051e5cbfe915d82f04e80bf59291573cf6589f2754544b62a754f9afbd5cd52fc1bb03c860e1251d2f76109ffde55e86bbfefd4e6b78923ca9d41959bc4a03878fe148d6f55eac9d9ac3839315cb9dafbad17560825bbd1dd73ec453127840ca5b4ecff596e6c16a3583816958aec814e91d1cf68eb7479bae58e389bf81f36be43422b346781672825addf3b568ceb01b7d8fca8f7bacbfa10af1566d1930d4e6d52d8d837750001ae277f4db625ebb9b97e4a7e6348c31c43ce8e76244a05745e127e4cb54b8378721b4bd8f0daeb02f6a88099314038d7037e3c68d08508f5931754616b0cb462012dcf4c019deb613fbd8295a700b348d3eb4db93e63fc213654ad097cb4aa5eb7b4287cb3d12358a31c579748c795ed1fe70c8e05fd42dba06ea08f6f67d089c5f8554a5d10be6fabecfc33405727024f94f666626309bab543c45302af8061be24d5c1df047c3bca2b37b45728a67f92b54034859f298ce78743be893720d1d339e6974a55a2405580694531b2c1e353afdb11db89f5858b0d3327c6afd944de863e93dad80e30d2705966b3687bde36281f08faf8d582db0e796e53bcb2047f93c4c5e32b4b7185f4fae04d417664c798f703cd36839b41f7cd073b14422fef07ae545f4560c7fe5e8879d1ab1fef38dee2129f974a5d2cd64a8267e0003570ba92dc2df6da93000197c1c7239c5e6b7fb67ad9b35b1d2ff6d9797d728c3f144df22ef13ce3f80425c2229550085fc33216e5d67c51efba9770d4269d7fcf6acf9cd140e466c423600c7f54f3507ff282fe8854612c52952fdc5fe5945251f44ce5a5e0c33bdb4eaec471374f422928713bc3785c97ebb2c14beac31191eaafa5c2f9dfe6532b4310b031b9f4495085d966a572c12ce26fff54128ba949a30aa95c0957d1ea63e1e0bf9492485a27c7c1241307a27c24f7cac9f60e041757de7ffdb25bebdce93e16a45ce29c4daf8ddbdede549912f79da42c76cb2edd6e61db79f6e66daab556f069cefddf3f7ea8f02d756155a3a42b934aaed576a0692aab7b00dcfcf6ef11273e8191474646af5d4d4f731d30571e867fafb4f0d9bf918ef394af643f3466b4497a52d0686ab3c4d9cabd7977f0177e80146110bf2d955fa24a97a197063924552479dc613d96798f5de321165fef3847cc9b59dc4260b4b846f5e2d544ae430dbb066df69714daf3da998e68890e99ec436b46f3e443bbb1308c0bac686d7e48e55315d5b2023362b44f433e34f156bfa31e02f852d8a788dfa2bd4470f5a51d188cec94fe051cd7eecbb8754b0e8da4c13c4e2370080ea448580eab617f0f872539594543e6a224f75fa8564d753bc05127ec55b122bbaa0b192a2ae852de4824cdc48cf05907a3364b614791de06e01b31e9437365a36af550f51b92e8357850fdfc05fbe3ddc8742f57cf9e075dab8428ba10980e64d4cc1315f1276f4544729ba47ecbddee3454d81f2cacf1ceeb15513e4d631d9c6053d985218da11245ef79c2fbd3e1e15a87b6e1ea3491ec8154a24739be389d4b2e627dea638d6b6d94cdfef3632c1a37f7061b26328711a5af255119f93f99b7f73d230963c9248181db62c5c76eccec6eb60cfebf687ea4a02a14cba545e198203d3ee0aac8944960554fb7cfedfa4ae60106532b8b59fbb99d5f43dc8dcc2e581564f99ef33931f1010001b3ca7508f8af8760d06619a580d73903c1e5ed416e4dd890676f78130ae6ae0297a399b78d1b159caa3a25e688aca01a35d8d6cf8228307a05538a52cd8a844eb30ba4deae67ae8f131c15ac3dcbe4218405d18e27578a9f7d028eb7842361dccf33593277f6093568ff858ca43354ab21dcea43f4933a4ee9f7b266d5cf0025d92d904d2cb54c7678629be3b3197e70e2f04d2623cdf553d3316bbe6c3f8c0d8a8a1e18c8f56e91eccd7c879127843a6293342812c72c7030299592456f14791e4873061c95cb481fda7f05aa0351eb3ad3f8a7b1e57684e557e353adb2c06f3932c63bda4ebb7ed67bd67475e0dbcb466a788cacd562be1077de471d905fd0861a0d3543c84d8d6a1476d40e1b0fd58ec73988c0d22e63a7180adfd0c6bbd1ec5d99e6410a9617fd5a74ca0340116be4d5393ac697a532945ebe0d3e19b6f5df9b299021d362ea4150e84bbac08e8abbd39d857fe6a94549a938771e952bc523a99cdd518a0c9c4fca3477618d1615db627617bf2aa8e58975a0ba6335c05c6a5f9ef340152445419f152fef5505d8403e01e474c07e35b77c25476e60e6e6b28609ac0d26237d6ed15ccef959c8ca8aed276793ebaf299bf1c477374a72fbf72102ba71c40e0519ca7dd9a307a41c468d67859d4d2c8e77292b755038b546d94be5c3aabc8fb645e03c6806c48574b40801322688a3117de31831e74f39e4a7c464deb24a36a5b32761451a46cb82676432c2ecbf8ea6010d94481663d64c8666f05aa1739be1e2e912dbdf09adbcf0d8e1c2c8eaafe98177810295c95515001f583259c8e606e84e4d1e11d07c6adb73889e179c412e9cf95d396a667ecd2caed0780cccbbdee4a2adbd2fac621783bf3403e074934af0d790029f8220275b4c423c405794c9bc5cd6da164846cf79fc0eed29cd97f9133482741c00ecab006181fa15f0f767b5ee7476eb0e5443f945de9e1fd5e92e61b63940d612c34bea6458a8a609ad01ebd54d92582bb138a16368144c9468d2bc9faa11de2345fe629f16e95d607efc7fbbab14e067787b7143dfb34efb3154d07b153117b2d1d003d3249951d6c991c007f7c4a434fe41ab403044c27b7fd7532174865a7c63890d23b858a66bb0ae0472914e4d61a5ef2bc218f16bf42c4f24410543aca1765d71feceaacde9d6a03657bab78825d15ec71773d6e8cf5a88e626bb1f9d8ac00a4ba5062cb8bf2d499071d153923463791c65d0277458a07f7bce2e28aaf52cdc8b9af1b38802f5149fb107db58ab8e8f8b4c5a83a9a80f259cd88f53fac90681ae2fa34fe60347f73804bbabec49c483fddc85ddc87a1b4a810d9d3a0ec072c82156c4b18f942efa35f8a227bbe75bb155817621b12c661947ebccea5ac56fb7ca182abc5b032a7de3e2971a876d27764549019449e1cec91ad12bc4d6fac331fbc776f9de5786dce60b40271afb164a64e143874b38a8ac97918c606a3a20f201ab3aa4ac7bb21c3769c40d6a66ab13ac663f9b3eb4da69f1148945fa04f241253ba46e0854118af931916049daa92f12ba6d7f32325ddd19acde635eaab30792c71a048dbabbd116f6ac454174fef943b1f6940b0ad0b9aa43453e72dfe95b512108015567d15454a918cf02ada3e747f8692b8f4e6b901718c55a8ab244a919290624f56856ba7874522fdf0f2b6755f989994fd65aa9215d2daec37fbc9e016894dc2dd469f053209476f92860231f2710b4fd7a3c01560fae9da1a305e67ed708a8fd71851de65ca133543b5f129ba67b18ab26b52f66399674740dcc5a5924268cfdacb1bbf606d526672d1ebb605d882af28407f34ddb63c16ec1405624c3642ffdf864f54d0df410929afac2cff2987c0256162bfadbd07f35c5f114541f2a3feb4d06ea6d5e0b97b9cabd3df073fe8ca05575524ee54f4c33977b27f17108dad067230b99264a5721b817b3b2feb2aafee3b4b193cb55b0b55810a9c2a81e1a3e23dab58446d9af4c291b2958accb5eec6d5c7812c15b8177c3cb85276e43b93b94cdb526918651c9bdf89297ed34cd76013a88c5344cb7f39383490710f5ad16a6258b16fee9ea935e7497cd08919736b7d93dc885744feee3b67d7dcf8107057b99b12a6ee51c1f01350709c12ddab18e6d6cd546e9b4a37c3cfb4744a5de0bee2b68f4102f6329e0a43a3dc1c28b1e9a4c2656c19724bd84905ff6360018a715eccc938c8f128411c8c21c41ef2a33cd87d7c6e9d6dd09aec7ed4baaae0cd46b7a8cac32aa429e8c26d7eb14e87dce132132e4bd256cdd67e89940dd2a2924010c783e5dbbc25fbc83b5883daa738a211a56ae5b17e7f9ca4cb6261c6c88a41652b9f424c16dfb0c3a83f60c0f30675698ba2792b129d1f5021dfe29276ff94806ddab66875e320d982fbf9c8a6818c61805c2b09adc5afc219df257a747f20795798ba634c50204d438db33b9c9231263edf91369bcbd3df717f6d0c2e1d8cfb18f193638d69d0df0b79965b0117b8f8a7383e8348e2c6d57c298fb2cb8d0298a42460e695abb3407eb930783948789177f68c8629a6590fcdbd83c6fc1533c6a7c90b88bc35e5be66313d2e917a79b5558137c4e123c8ae33c5b547fbe323282c94d0c1dfccbcfdcb1dda1086e8c37985a5fc0979a54d7fbb1f260df386839b08300a5f80892f6c5e77976cd834022245144b3d9284fd99342e1d5cfe84d4d0cc40b20ee13e16c2fabe8880eca0124c83568a14a50499f682c9f57f710eccc43c47b0997cf7e6dc028821e5e809437804b2018795005549bb272176334b5ed0c28212b83a9a301b9001e6beafc2e57e26132f9854702d9dbedffa0f44beb9a50d3cd1ef7030f5cbb797551223d34735fb358fc0b769213dead6167bf805f02ba28fc3cd5ab1c9f94bdfd52dc27c24a896df6dd74309d15dc136cfa0d256c4de8d0274149c781f60d14fd9a5be96040d1e3c323c8d06e3e4b4622046a1b617f06ed9e956eb8cd2ae8f61df6fd4f87f3fd4fb09f15ff09c862c1aa89da0f7dfbddabe566f5aa9c24e88f9c7f413b0d338b6fde1ef9efd27d3c5919b4d22a9ae31bcd5d64b5e1daa8121a69f496daf6f9d26d368d0dae2e1a4da8ec6a3bffe68fb67a4dac44c6fc43b95dc9d2c5dfd6271d96e7d41038a7c3cb27cb0e5bdaf303e141aed101a151ccdf2a8b209d9ce57277309d006cf2bd19292b1bddd8ffe1d73bd7f3419bd75dc892740a900589816b971351fb4c5ecbe54830b46c314a471daf73f23cc99f4625a45e82ae104e27b79dd6676066c8d22bbc978ec0559c83dc68673820bceecd9d7b9b2bfc9d9c63eca115c4fd9d89ec455f9a8225eb0dbda14a61eb0c8d04a1902a5b8c482c4f869c98c8bc820845d7a7e4ca10cb60f1b7cad1ff5c9b3da354133211aab7840f11597cad9928e4af802e74f9e063808d2906728047b114d00263ac67a3c7d755bfd835b7db946425a7bc080b964b4200f5fc6584636631d9891793abec0be1b3b618b679ec866dd51161aaef6b6416d8578aac52bcde2e19fd9b2ec23ccef1f87455903244b815042f076a45d5754d795a25ab59b1702226db723566649755d2aa4b6694b811cfc218b435f20ad7fcda665e8e4ce4160d6a5ec7242a2d1dda53d652f913da31f53c1195d5d8d33913c08885e36510f79b7bf4b296790a4bd65f77043aa4f6cd65eec524f9135851844bd6011f3acbb6836747e860307415f7a33cd35c4327566a09b9804cec71745d0cedcef55fdbcdc20d50835cdd27bb48aff4367952fb4b1615842cbafaa7972566a9ddee44435e2be9e3dea4c5aa3749753cd1d7a6f8f8b78cde4ee7054781f6626ac296400d233b609dc4c3274f2e7568e876a027e8850d78c0927453678f00d91804a3a5d5e0b54bbd87bf3a62d29b7ebc2b6c5a016f772dca6becab3d5d4fae8e31a1e7fd9d64f77479345d0d489b9cc083206e3b34b4e523d1698ddc8b41517f802771cd53e3b01d968ac80855dce7d6ed5cb5caa609dbca8d7e73d9e829aef928b9614227fb785e952410972d39c1193214747a58c105e2503401a351cf175a1954ec375789209971729cf995310542e6255fb6e2fffb91044cba3fa07d137f94ababc4ea9cad6c9ee96bb4e29b7702627d59da11ba8a21dcb846e2f268040befee88c6ddfb6894a90fa9af096528ee2d5de478e6e15f51eae7c5724779b78058e6b880a1498610ae7fb5271e0bc24abae744e5b5c3df5208bfab89b3abd8d9ef66572c4c3032f48dd4b4ee4b772e5fe26364f602cd2def430c8f8f7eaaab9a907393bbb7a70d72239bad101d23f7fce812283d56b385c2d6d81c5c7c483a2a287c42c18e640d72d07b1fe431c86babc567022d1cc18643c62958e411cd4d6bbec5ea9d64083e9ea94597d95d0a708939952f5a98ff9b957b98b7413673d8e33ad53f9c26df52103d60d11f9176ca4a3e65c2e5de5281034672e78834bfc27eeab87c4d928295c4e8d896222c67381ac73b89a26c8ebed90d9c5ac30c20b15f5b0f79c22fb41ba1ec8713f96337b4735a5a001b074b76a5f638e0b5eb854752697d95c32e8c73739c9a97c82a16554a8cdc106add72bc19385ae59470d8a41cda0f10f713ad5ed1e8fb53ddc128322ae89e342094b18b8a663236819ea31f9756f5e19b281f2111f2ab0476b2c2dd6788789d8f82452c6e6976deb0c6f4feb9c7ecfea1341cdd3fb335ed15654df0603be8bec4749ff7fe679b163923be30866f394837f1519bf55ea2f9edd5f87cab1b1c9c52e1451ac86222f0b44e4f04f743af07d3d49d1f0bfb0e4fc8434f77c86305f2269b566168f87278e5fbcd31e341d66947238b1205575613e18bb353e87d78ad4affdcbb8df83c4ddbbcc532be5ea3e36f2fd1fb10ae65992bae95d6f8a905c377811a279dd3d1ecbcab37706641c028cc0ffaa9c14ef466906134cddf1cf78bfacf5052f4f12e3c8cc510fed26c6b4e30e97876e85fee15a27234c0429f931a4c745d1ab9b56a41e07fb3a07a1ec012b2beb9511412e411f483a43a685abcff0043cb3b9a4255eb259972d80f500e0497e7b122574e1a18818ba4d92aa415387be0048e29826f528d1987d5573903db9379489347110dd2a3b7ccc185690c5230bceacc53fc28a5326b06f1de5b8736d3406b35f4e67cccd35450896b91147fad78c9b5b6b3b2f87352986e203c02ac18bec7dbb57b312a0d3afa5897934d0c38e7efc04da23f63bce9c27636626a53cbc37fb2327554531ec9dae154b002dc286b9e19851174bdc5e848ef0384e20a02450189106cc357839b25f49e6ca57bb7dd183706919337891a04b2b46dfc716c5a4547bfea156a303084291c05cef3d356627b796298413a2e2d02b9d713b14a296a30c277185b633fcb852e35be27f978b5411b28bdfd0efeefd651b371ac47ac057d6e32d2fece7044488e1ed54833411c5a07885a08001af7da92d08c308c6df4738c9e8e218571d12aa98dee866f0b56011c2a3859456e28c1716b01f9ca77d4fcb6b10bf61a1c103dd10417ef447d894cd7dd23c117f18bcc7ccab4658361504ce3537966fa40c6ebac1d07f6f015d0664ed5d47b7eec83906835539427dbc5050371640e6a04120b0e7e3cfacf2c375a4b98acc7fb040cb6b488d489a25bb9edf0ffd10f735a240a758257ada11ba94fe688eafefcb8b6a29ab7f48eabea5945450d5deea589775416a563d4dcd2dec39bac7f5af445f01c8e150b3c8551a4911cf54ab8acbcd67727f90987cf889f6033f5eb8cc1d90b3d3434638e98287955c08ce2ca491dd57c566729b43d6d83a43ac4294008aaa5f79efd97ad442b80084587e1822bd77bef9f0c91e2ac56828378c0887ea153f9527bfd7a82830d3a7dfcad40b8138ed47c0450c9c5f014ad66a795a96c31c1ebfeb0bbe31c23b30c045e9a4f040f2ec5a0df47c0ea4f73598db39ad88ae589f797dbec2d7d15f07f24641659e24d4aa4617e434b8390c1df637c654decd733a85baa68c44b98104c656bd8fd0cee7bac8a69586a2ba9bac5c34b1811fe8fabec5aecff4af732e732e1e455ea767a57b737319eb60ca7ded8cb4d692b6ea0dcc038cce9487101ab28bd950e7db2564b38bb1d6c54c12119e6dfc853e56f44ac8917b8a31843ead116dc3fddd634ed7007171ed41641585eccb73c58a2c3ccd8cea95f948bb047e565982e45a2802de2bbdc83a2dc0497420c286a48c96ace0e7608e4d7d2d0f67a26a4ad4f45b5ace80a3469c9e1df098a2c306141c654e88e32d4b230b9b1a68d7c7854896156aa7ef3b4e914b09594a927bcf989194c2e188f56e5cb5cc535dacb486755066fe8c908bcaf3a83b964a0e7c6ceee22003f3957e217452f84a0716d1b0894638c28129dff8bf45be5ff080e51600a5bb2d91c993f2dba01c9e0961e77843423d831f8ad0a4e63adf67c834af107849649f650349ccf2c3daac34b14d548ec81a3a3fcdd3c6ad2c79b4a46bb7ca4f43080127960a62b070b1550f838248fd56aa9918c827a87d41a8e80dd512947c82cdec81a9f5aa01ce3169bc16b9a61ee75511e7f3449a59375db81f83a14663018fa8f1cd1dcaf7fd562aee437f7e16b1a24408f7d66c6b89c326ce160fa40ad464c62949b13798b6b467df5cb2e41479a27d14a57386e9a68cbddd0a9bb3c7c58c7265b80af28448584883e9bbc81d6a4cbe0bcf52710d6d19be3e13b2eb30a6ead4d5cc4666e4e032eddce72185587f4a86354e24804a796b13deb9294ec818d0501f67835d2879f512e78eca4107c16dd8c39683709cd18212db1f9012ffc83f4901b1de8dd8ec311bf1ddee9fbcb3ee00c979b2917050f2cca35228b94b0dc86d0c767ec03a65911b85b0050bbbdc60c4e533cc4823e5fcab1d83f52248ce086dc06f278e68d5e2f4d83e46eeaeb3a0d57bf37549722a8019cb989b8051ed47f386320abd4417a5af47921282297a7095007d46ae0b0a70e76ecdeeceaea12b6bf324005f251cb7c8a90df68e061b7dbfea2a786231b15c0a4a9b3a7700e50181d68b11e5598b5d4d2187bd76fcc1f2f68ce7ee9523809ad9be44da07f0e8aa8732226735e166dff23ea4a38507b73e3c5b623fe132a4a33aabd08b7236a3249c6de07d912f8d28d51023ff1b27fb15d76edf41ecd7cea55ff0bc512f9c93d4adf62630f3b4c54219de7eccdf818e1d7f38d0c98af727ff518ef4313831e33ebc5b0aa2ac94f4c6d986f49081dc421290b3a14ac7a3033069244c0fce8d18f5fc1d9ac7b1d7162836551372a8e143068987655b3e612b44add3a34b6c7926ed724b308854d73ecc8f011d7643f117cf6d48b424756dcfcde047d6ef21288a7035968885b26d00190a7f08576b7e5a857de45de24db860a0866db22eea2a33e34f728891b3dfcc8f08a0452cfa73b9d4ff8dce04a1eb805a757ce9e233eff8a5b32da437d7b5dbf7810d866b07142f98507e14658d1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
