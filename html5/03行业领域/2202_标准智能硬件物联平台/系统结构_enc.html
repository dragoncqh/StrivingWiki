<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f22dda09e67248ee482a9a9393787e39e90b4d451b0ba76919f0e19b9419d8d2a1663a7d57c7fd869331e8b36d3bbfddc0256d6a7df5570f0aa8d75384147de6dc1f8287c6d60b6da38e9793630b4c5beeed19f553890cef43214842939c91ffc346484619a9e58dd41bbe59541c27441d29fbafe7855360067e9fc8f5df57f8fc453e1d1458ed5a0ccc6138f83dcf629a54ea831432576adf2fd0b9f94231ee0e8599122490a0d5e4c4ed76bebcf05182276ccdf2dfacec56de0a53c3b02a4d7bff46a023b729e5170aa11c5e9ce508fc3c7eb06d3d3c6e74520955ddb97f9f14b9ce771e0ce669d8a6aed3fc6d385c635ce3d413bb9668a778a301d177faacef35bbacc0a4d53547dca0b1e1f6cb64dbc5ca1adb91bf0b7634503aeeb0ac1d8fca643fa140f5cd7641e13c466dea13aa602842e083d3d8874d5f2515c6ce252a49bf6c49aeb7a74782cb1c9ce0b7c3b0533f66aa1bad8ba0a44d99005f3330239c0564752ea5572a345e5fb0040ed4b50c9f89c6ae9a3e64d5b36e9225049189c75d6f4f254df83d6f8e841ea9a6bcd42e96c760bae23615334c800ba6e52c998e14f06aeff626da3d2370a1dec3b72c5abfba05c3278f4ed416cb87bdb0b47ea3836a06157f21180d64fe5b900067d97acada14640a4ff0df574f9584c570cd1428a358c6aa5d2b81f4748fdce7a0c56c8c7d0acd0bf3781c5ef7825d1880a10ef17a9d8f29147d1d3ba2e2444f32c582125f62f0443b41dea141a12277a275688e353bf19dd81decde2d0caf5be535788eca76776f0c63d13346ff2d7068c69d6c750b15d9d54055a17d9338270aad8d485dae404ddedd9961e18dfc5f818c7c5880feadae6a6044b33b665f7cee5c2252f0708395a7227747d98e1ab92fe9740961b648466f38bd4c9a31dc5c76a7b8974c42e1f7ff1b979253b540468fad292504ca7b71bc977634b7a227ca35f18b3cb0d290ca4d28585e93ac0849ca0e8081957a20908ac33050fcdb3fac31f222b442b324ec1d16972f31585b834e8abd1456586f69e20e676349b772cea5db3a817f16ac1d4a2fffb773d924dcab812c3b11076cecf49caf2254bdf4050054db6b2db29e1d328224d3e705e272b1d3e28c7f4fc36aa236ec2ae062fcb610ccd0c9091e14a2373375dd69fecdbe23392e24d6382a3490172601b0ad694fbd351027c0eaaf1799eb62076f82c2e3f887d10b70128b89f5221d2f76fefb1569624640cb6aaf489f754a2b05208babaf275747151693cac638b26d3f9f4e4722ebcefcbdf151e4881760d764dd94393b7cb20262598783fa311061bf0cc009b93e0da72ef9810181f361c32a6f7c2823314e0ffddc18252d6bc67b4286a3105caeb6b5cb97aaaf7f3118df67feba6ee444c9e6df1ae4d2557c205f4df0a519c166c79b037f0645535f3ccca5366d234e0b945566b1b50423df93d1877b97eaccda5f8e1120575d8fac7917ca524ff537ba9d2b331c20cdb1050a166eb678093ad5ceec29a72851fc5a3451a267dc53225b00657be964f36740eff3c043c11a1a95de959c13b0d3f2d7ebd11f3181918120037181b5009035d72138a7fcd46978b50f5db5ce7d05f35a2252988a7a7551dbfe11b162797e7559fff79ff9a9bf55f18fa4b7af041850d0c1d3e826b0ed3fa84413a3204a6c55f48c8a43e4aed4cefaf86f1ce48abef60b5de36acadbf13c34bcf0a447fd1829ca6a8cb818bb0d08f8b9395662611ec9813360aac4b68fbbd70c4a0234f704fcba434e86eb439099c89a98d324b1ba313d42b088b4e8f561d066c45d7e693ed025ab8fde14852ac2a128bb605acdf4a7a99960a9ea3223d7e2d8d810fd6312e2bfdbe0c586e82e1a7ecc261994ff455a3daef7bf3f3fdbefdf813636c66fbe3d48dc2a58bea65f79c6919a7bfe63fbeedb70d7ecb9f129e83817d341ef0b3602be86bdb8ca074424297276959ccaeb55f2cbf87fbade2f8e64c59e2f9d9ca51366dcb9f1056eb776648edd80589f65963514ec904aa852f9973e264b8d27309eebb7b46ddb64e081a364100570cf7a45a6b24e6b01386a01812d88b8bdfdf336e9abb081392a6007aeafb3f561ca0e96002065e9627a3cfd2546023c051a625ff8822b3aa90993f3d7be683f6fdafa8cd319d1c692d873be56688ab79017da1829faaf2036d9a9e8630724806a831b56f1d5315ca4d6da7d949e22e4425cf7c21d31bd86f381a7e82088c81a5e6e2d07353fe3782dd574a31b84524217784912a19fb73937722fd4938304257b289e7f792d5c8383b05f14cea7cfd5c0db6a56fccf3f752b6dff4983f64a66ea04a2689fb7fed07c0d85c9fe87b2f54312d63e3d44d1c4b112efc2b18025b23865eaaac695a30dd849f71dd24f9bcb206c3cb3f62aa87a29e0fc1b23916cd5ae3736031f7918f31152ec8fa8df4d95aaf854eda53fe3020716086d71be64b563f1d26320af9b080204b362c3ab423a91b12a507b875eae8d54fdd3582737929cb2b6c4f5f7719aa1265756da045aefe307f4697d2f46df2f416cdaede21ac23a0cc5a48f2063c3bfc62bd3ccebc9091ca5566ebd7faa8e77a5ab038d0fcff0e29b09c2b3f0a91bd41489adc7112c20ae6d20c46277126a447115f09ba099128d33de0f1a1405d13ab289fb7ecd9879c8aaeead18d360d968cc84a824e0eec289ac20769fe150e10cf7074bd63a47373701560ed09e520c93ee00229053ce41399197eca2212167a9259c4bbb93932f14a58dd6d3cd1ca57dbb46b8c36537fd3cb459f5e98ccf4fbac1da18a819f2c6c314ca364c275e31dd259a0d34cf2eb667798030beb8caac68e12f88244d326e206194a1a9281e6e4b7ed8659752e2e9b0e3a733983d1d5210b4c08565540041d87e4ab757f37f9e63afbc7f594a21aa9a54eb7c656e8f6b70e34e3d0e71ec35cd71a1a9e2067430c0d339c87306febc10b5d5b2cbb335845b5bb461d188f9c96ed1c8f9c3c53183882a824bf9eebe5c3f121e066a04418fd5817fa19b2412e41c1642258af1d7773929a0941cbd13f5b91f971293b07e5580ebb55acab1f812b1242553e4d0c3384d6b1584e629319f404315401ab6df0783d5f0dac72a34defb3942396d13655c26955ca3a312427e7126d0e125712b526e40e207c0d14074af4a41a6fd37860a4c33063a3ec9860996f2c819c42e8ccefb907fb360b71ce0d070574f8478747dc73156c75f1765c5342a3db3b4e621306cf1143795c5645121fbdd06b1f5a4b08e7967afb52a46fdcf594a0e396c93cb8fa2fe36c68e67a8bde9c9860162701002e4a41afeedad6ee1e3f25ae450ed8ee68957c3ca42b622d31ba5959697efbefb411b13a993161a3974f4ea6714272a278f70498c4d9fdc30f5adbff6f78813907c590f1e73ccabd2899173ee19427d0fbd284796534917f38ce5f63febb88049b7ef90f4c300d7e66f7444c6aa786e2999a35a53f9a59b78d9b03f8ea0faf592e33e8a3accb59d06c771be071ce70f09f7387bd2ee715f5bf15100d797dfcbd2e81cb45867ba184d1fca1337c5005130c602b12da3f8e83b6daef68f15002b05f7497d894c73f452fc9bd01b0960ee7114e50efc3e8f179dd0d903b979cb73d548f62d2afe4b6d0eb34347859dc089dc51f0a693e0bfd0bd01e41071939f2b6970d106bb25e8987ee712f1d9d8fc5114085d23eae608592bcf9d5bba656d11bfee03d06315f3afc6d4ae9e98f977a28b5bc22911d03e54f7bcaefcc53ec0eba270282c86cfd985b39c2369554c7b159834d6f0178fc59152e8a7513d05bde14a3239dec3f819b4e398578ca801f564191f85013b26aea8db4c5a4b1f05bc12a6c29adc012235ae6fd637253cad1426b47c39fa210cd680952a96383069fd6403afcd14efbf7959d0f44ca3ed47ef7e21251d71c3e4618164c299734d5527cc8712b741858026d516ffe9e120246ccc78f1ff4619ca54179c29b4828a628a103bf21440b19b1fd6eb3ab546fbf90861bc45596047f1cf4042ca8a3c6223827e8a0becdd35974895b0da2924462d8a48cb1250d81f7227de146cd66b9540f6720018b77acf7af5b55b93c3e093c6d499c58282cf798861f1d56095b83860b6fa2b12623c99dbca5a4b44e9e2aa22d936ef5fc6edfa199038b091c18fbbcd00dcc139ec22c71b82d823bf09ec6adc02ef64f2f1e2baad33c97759e22b41baa151e481d3b241b502f16d2ad99fdca18bc81d0b48ffba784cbaebbcc74d7a8e375a50d8318dc031556eed9c0a0ae75b063414c091f7ddae0066775ca7d44c1b34fd6492ba41c520c38290fb47afb53b874b1c4da75ccc8d3a8adf0f6b519e1bef71877b656e0f3c994173ecf288eed0976bbf0bf7dae8902ef52e1440c80d674a5622480bd6b916d9da83d829fec742909970e18c76c8782daf3270b9a710bbb09df85391126703e266740cff5255d26e21f347db09981014c127f182324e960d98f01dc665d49a67b47ad48513cd58658ec1af98410210b6cffde50c72178387e70df05acce31ffcfe53dc1116d5ef502bd32a5ce672f3c529691fe4152b58bacf676f01ab0f1c24d3cd2885164090ede50e9788c369de6a4e12335f7414609343d1c0dd1cd5f90eb05158fbebb22bc6cad2e2432cd8ee431bb257c77b0b3038ffe0c10442bfc75a9597ca11ba69b85eaa2ddb8cf3625e1ab03dd0d96e9564a8272bf81645365028d0a11b163f9677989a20ababd3a7e46b564e2a15819f29253b7cee1e6ffdec63fdd242e5e1c6ee8843eb427e634f2110935e032f7fbc72e98db84a89fd355b662d9bfe074d4209a27b8fb482390044e72bf2df107a90ea8c5631b6d46e2a02dcfee4a2174f13712f4c09ac12c884e5fc31a077c94bcf846d54b42a536b22219e289b7647e859b99e2e678c6d2fe3dc2ac714b96379db48708fe6a4e327aac7c546f0be701774f01e72a3d74d31432f7808a9b883d4f19b181edd7689ed786010da98a965ccf5b9168cab252540cc9ae7a57f4a2efd65b9ada47ef903138d450e66ac3b55ea7970d3311e793c85ccab2e612c516eb73734106d55c5c054421b336e87528a99795371aa7f5bf6e41fd5d1eaffe02d10bb7eb1383c2db104dceee7591cfd9dc52917e9e9615cbf991fdcabfeeef545fdfcf8cab8850f9d3fe01a40ebc64ef265abc300d14cb06846685f13648b1c33dd76e3953615d7b9004f0a148db5dca3ed10a626875364eafaae67e0128c97b369032a80d1310d47c3d8256efd5c11d843627e00d1f2f8ecb801fd7050e803401fa0284a744d207f1332d4c4608943b20549ed6c03854cc4134f773d62a7341a4c173040f61d4b191017b996de1978afa996ed63dd89957a17bf69c720ace8e4602a8cb67a53d004487f7acb8360c88fff7933d8cf7b67aa1a768baf173ffce4d0af27b991fd64dbd716ea717ab904d2c85e3b20ae8c2ea8924c3bbbd943393465373b8ebac5ec579decbec0f2f86952074ce47d0c9434c5fa69b2cd848f1c97cc748089cb5cd068bfe16b32fa5388d00541cec96e218c124c3f8d0020de35f006d74fdb0c353b9535534671df8583099d6b8da66b9b927f04ddacaeb36b7d3bcdac2cc7159ca9ab8102d2c6c44a06118d83919d200d94dbc605f0f4bed003827056fd2ccaa851dd4a45b95967f5475b4b2f1b51889ea04b4dde2657a19d658c9d727b5c7ccd655fe9d434ff84573b73b5d990da3d8d3deeee6223e6aa9c3418a42d6c444c3f7a121a625e4fc708aa7d7611378bbe344cdde5ca484ae63f3953216c9d3ff4e54f3a10da1eee5d01281289db1892af35c17952c5999fb3bd09f91b8cc24810d00c5d66079af147df2b103385e1fb9e7a11879f7cf526a31ec44c39661807c679868aecc008b9aec097b26a7d8a40aa991e6dda2f75b61fcde560c2f77087c7f19bbd95c057d47ba5d171470f602311f8429900266bac95f3609f56ea9997043c9c710863c1c41f3050e9bdd5891255a010eb11cd168c39cb47984a16dbc0a0c3f2b8989bd249e8449de8cf4ba5ff56e04f18807d7d619116ccdeff1227229132f9acae129845d9435b46a9058fb6975ae9e1aaab8927beeeead65e5c3c62438551192422443cd374a4d11ef3d2d131bf36634bd35a565771973fae7dd88a762c1dc8f1b2218142dd0ad662a918f10fbdb2aedeecda541aa832e18d002c08acc1e75741517b727ce5008f25b5d7a253ce69cdcbd3806e778ce42eba718b55857f43ff3cbbc1a8ab86c1965f87d99357a987a408dd0fe9cce079b4a51cfa146048a2489f9983d88e68f063c790f074a233a9c554e7ce02ec2f90932cec649cb3a566267c705fe7283562235b7519b1ac3c2e498733d6346fb8f22ba298e19d90706c68c92f2be83071c3119544f25b50bfc03ee5799a3b6e8e65e340c2fc440b1ae1dd659f1e3131cfac96da3e24629011116ec8016a15e4178f301a6a8a25e892e19051f5694aebe21689fa7c663c9a1b2847b932b495610be126be7aeefdbe9a4f33672d355738c12a9efa4b7bfdef2d36f04a6ad8d5782c93759db041be0511bf396137d76fd0fd387a9ccfe3b018d66f36462a78d6fa5323cf954ec9513e023f14151dd5a4954a0d423c732599bf122be907d93dbd2bd4e793c5d7e1f0b16042aead980d9110890d0c3518831f24945b4fb8a0cbb5d775fb24dafbff1f50e912a7c5acb37960c8f358a6f6661ae8922346ca6b9cb1020015dddc328ebcb0e3fb840f0ebee4525c17001fe6d74ef9bb82ce94974652dafb28ae56beb67c179e343e9d522d908802cf0d211e7406ccf01a9a0755718f3cf8b7e462822b8a70667a0d9f3ca2e131a3251ba60cb2de8aa5f191695384b93e7534ac682c6b82cdb1602044b1c0220e04663299e7b95cec2da44ab04ef4ac23d956117755ce3d42ad7d28c1cda69d15529f1bbec4ee31512c69f9cdc2d83696af1d0151db3e968d4a06e6c65cdc11f29f72b4db7daf83c76e5cbef446a63082f5b91341b00794d28019ab10ebb98efbdddaf2d9609c1cb4aa34231c76b25d9c19c4a38a722b88332d44ad8c6111ea3ab2d38a1bf1d83e0a380dc4f6df08d1bb33e91474338f96466dec4c0123e9a2dd055a1f2fbd7c7a97192488f6ab644b7d8b479c48387f51147a81521c48b82f9fb6b0262f111f1db26bc6f5b1e6ceaffbadac1a4b1fe4f4851de5cd94578fe092e5732749dd8a85817a0017d1b240ef958fce07ee02608df1932ff51e3b4cb9606fb92a24a3e4787c79d83590704a7a0189ae540ca15110fd93e995641081293b602970c2437b69db75e37201d77ee0c408acee8bbc111d4220ca1910e22c5da1965461e57705375956675b11fde661d04e41d386f0f9e54de7e59e7dc201a4712a47d544e0062d64023ae824b39bb181400a6ae2d0b59a50406c521eccc60f45897fdba45ff06313c83c4a47837237a41ef988e07b16ccb2dfb096b757560016e741b06f07f06ca11bfd4aa0315112309fcac33edba0d60eaacebc96df9a02d059fec5de4ca17f02a6f8051033c7b4d25438ae2f1333a593a28406f7ccdfbddafde6de1ac4d33b4c9fab3265559c25dbee3a07a6f5112d45724586fe044e2e95bfcfec14fb6569e9d4d5426366694bf2e6b15e1d48f4ee87c5de14b4b6df21c31298a67677803233160ec8b628eb432868575981a522c84bd721f3406ed2435831853386699444ae99baa6f8076a077868f7f46d2f96d13ce289a2273545988ef9edb4764d42fd75073eb9314af0d64571dc3a3d3b30eb95e3dd9a311f62b43fe9f2073ab0193c8e78d61a5af9e0f68fab816565f7b61b0381a0cf7b3765c459062c4d340e6f8dd6292b99f6b6c717964a243326f2be1ed2413674dadd074c61fd3c4f1ef051e6b7081ef4b7341e356eb787513f7b71b0b708d3e7e90be3573be53e8b5a377a6baa8ee630c2681bdf7bf0c449cbf7c3ea39faed289a7d8d78006859e5bd7888946429fc803233d16359caacfece209508cd4b327c5e0199499b3298fc1fee406ab446ab22b7a5e44c0ba93faa06ce075dc41e07b73ab28fc93000d98fa5e51e54dc6f14ad5c8e6aa35e19e0676bdd393e0867f25c8ff277f3feebc6f5583c5b5b4ad04219f004c48ad4df4c5f2e7e42d360ca05f191ebc24b58c8caff4f0ff0f9f42ae93b9edfa12ba04940ef95f67d5bfbdc6aa682aa20cf825d0fdf2d652a6d68289b43c2ea32600da8fe4287387c42a04ab57be93af3e9694ab1a326b8531dde969d7b32a2aa9662c20afe179ada98d99d696fa34b0aa168094a70d889bb7e0184a385788f36556b90b6515190318966df927679a628b3ac220445d611398a05c2e193f4d0f7430909404935e3a1a7fa79c4a90ee2fc2dfdf4dc144440045690ddd94371996f32d2a8d2df89b7a934b60d17357526cd04f35c1fde4061211842d10771e353a9cb05a213074b2713af298090b6340e134144a421fd6bec30450f98a3a5c6175a5fdcb8ca2efda77746e236fd9ebcd5c18ec424a09862e7c1339ff0afedf873a041b6244bd3f05ea343700162b37c3d7713040106e45f5d6d8a68ea5bc0436046fe6b8e1ce7dc26ee854808f8e24a96531ce7d343c88d4586abb66b0fd13c8ec57ded36fee5c985c8e8ecf581e88892b42d0ff4da80d920ce39be3bf7e9109751848ae42fcea6d3b1eb58d02764c5d8ebd6668c855e6fa634341f28c9d29802911687211f5854e207f4c2fefa02b4d92b3647c704694d339728155f82c0275e62327efd35f3cc3aa0003503da55b96e66fae9598104e4c827d778c982c36d0759883182ce0af4d7db612e86de42f368a5fdcfdfedc8a1a609c3a93195433e1541af6f551f08b0a195235397b788a093aaf2c0f126bd6c670bc4869f9266217a29bbebdc9454fc62226f450040f652c95bd146dbd773b5c344c725093fd9d75f15701b7ca97aa15149d53a44413ea3fecefa5d9f64242c7e99c7947d26776d9d7e911855a73f1975ce53fc89f72435b80b282d958ab9f66e5cbb6cf50e8e3aef966004fe518baaee875100c632238a7365338bda38bf0eebb203758b59e9aab29a11b68e0d91022780e24101ecfc59ba955fea16fb9d61a0be4b0beb2db4f3507e218b54c3d6a2ccced5cd41a839b5a117b9130d355ccc8869c2bd922311039f11b42127e69532634c5f70c8d9e79e41c9d438f881c4061509383d01f9c2378abb4e7d8411faa662b0771ce5adf24bb210a7c4b38925a80b576ce75c297199ceedb7a19170ed48669e2312e7c9e669384750cf0bb3a36912b8d38a4eb00660a58f9a999bf718847ad7ce1d39b4ed246eec7f1669707154a72a1a01cd1ada4cd4b171b7b958d866f594a2df974ebe490ac90de6fda553eed8dde7e4fd75554e059b573cbf49d98e10a195f8f2d4a27eb9ec55f78e3955bbb7065785e605de2770427ac0bcee11f7e0cd320efa8860b6b319287be25d7ee10651c5901b45ce95b5e576661d0378b5e96e0809ad31cc3bbc26ffaa53c2870f718fb970f886deb9fbb6c9ace5d38ac3f66c5c080baff9d9d8c3ffda8ea4eb4f0a9544b512f5c78d8be138b057a80b213da731ad6764eacaabd143a6a31d98c84320739c842ffac0a77e03eb0fa966b7be2be58da10912803b98e46ee7483751382300f886f0a0b071ae197a755a29efdf093f587ddf70b7137600d6fca26188488bbf52936fdfc52b7aa5070381e9d92879120415fd9912838d18a0990469a1d1ba24507bbb8db9198efd38264a3ad8eae453468dd7ebe5a05e248e7c2c6dc30bf811da0065a61b509c1ddd62f67e37b8c78e327286a26bd38e9382024f6c99853d19c6bd6e29c9cf8707443a91d23cb42dead540b7d728569b51ef2a588939597a06534fca4bcef02af496fde2414712ff872d1fd5b0641efce7318c4ccb8464a996b7fc0df4a6c6fadd05fc5241f7e373061b49efe7eec3b54bb575754a3f848f61b48996296a3dc6a196b5befe81241b88076d43441f6780337a5ed3312d6b0fb5a190dc2678101d127142562712949584509ec2c010f9f19a05c23a90dec4d6e588afa4d636c758b8c1f220e2dfadc2a29cbd0e9796fa5e938de789c2ebb4ec88e8c17c5825160ee4e366b00d22b4d9ac225e64812ce8c1b69a9a9462bea720001bdfdc4683430d6f842bbc46d7f87c7136d16e7b6149af8f1ac23e314fd07a400020b05d4fa799a81693dfb91f74be0cdef4ded14e18fb3ed84cd6e6f64fce65c814ac6f11c5715bfb718b7ec79482bc04d0f7a1a8227a77a044945b3da680fc041879e23bbbdba5668e297a9ca32bdf09f76b515241a88f29db125756a5149672b136f1f38f62c5059510272e5618da6230602d60673bcd6a636cf18827ea72d80517426d53dc237cab9f53280d51f1e5141845eee72c4de98f56344e23e9a9242670d52360cd6445ef79d89b0082d0360d47fc58b36dbed07ec96be28ab2565b0465269c4f8c904a6b9d71592b624aa65c6d165eb3a168e97da4e64e43e46977bd7e002b42a5247853c296e0021efe420815bbddb527eaf371a446d461198a75e51a6cec7cb93ccfe60647fa1893da3588383713a27e0ef17384ad65d2c5135eaf6495995db87782bf3fb97c11733b8c24e3618ddec73ed020674d09e32ced31c843b94332e8ee0cda8e7a973139cc29a09ae98f42bc5203228460142a6ea53d6df70e35c4b65d6f73e562ac20c45842e5d26c77b580a92e45a600e06afd586be50ca83e9f72bbad6bc382a095415b2f7d2a40f1d78b99264bc9f67b22e3b62e3ac73ba9b405d5ffdb28ebe74efaf2c0bfd274e15ee32017f9d29e79e076b6fdef827a6edee076666b9c1c09cbb5864b9b314ce6a1bf004d147ae7c475cb4d44c7a1ca4aec9167a1efd11eb0ca554ef1952feb0cc349e531964d1e4cf6f4283355198b57d80d4a2667670d3916e38d948e02fc4b222dbee4b3d10b2008d480af187f8e1e50bc84711a389411ea0475e6c7d182812320d33d7b3af3f9d032f979f17b6fdc6cc683c72fd04b347b608a8f927e8e2848dc13a49a1e59cdd1c6bda8e43fe5e3aa97f426da6def4882fae87a67b4ac1a9416953e72b280c1e9fc3ad0c2ff8721e8beb91e209bf4fc143d41d981f54bbde7c14ec41bf77574327bdeec93a6957eafede70193d370cdf034b4ab969f28f5b234321f50407bf2ea12797e043e3acffaec022eb3cd7d668ff33ee9b873e4a4217019d89854605ee5738e2936bf80e88b8e85ec2e7d7dc64a200f8eef496fbb4a26af605419bc36e3c501d46454b0cfbfdde5770c7a48cc34a35b562142e58e2cb1f40e1a39a4c8430940aadd642580dbe7b3bec04d52db1224245c3e648f3a5eafd4c2c1f195cb1e59ff92d1b7dfd5b217cd79e77002aa68211b80300cc1bff9e30ddee1009a3fcef0a4e477c8d0b137b8a07cfe3696aef5c2b3965527f4493c7f225c30f32f8224f42c493711ba7b98084649a765dce940586a25ac4bb90db3964669380507c68ef2c9cf3b4d559b5d8017ec92de800e48f79d6b94932e4b0ef528ec54e3a7dccc790f8eeddeae61abc6c820c8e1a463a8b81303d909b60c4f4b8b415d8c3a0e9f45820a4cd32898e5e79dd939341060cb4b09b1291ff7c6f0c29c797d2f5e5447c09e99054ed9fe012f5a4d47e6850be2a20b06cfee4e6b63dcd7ac451205af214f603ca3fd5b970e10687e98581a6bfb71510af9485d988631b1164bebf2026f62a45cd748ca5ef5306d5aa13f866c86c67b1de5bba2b7b9e6d268d6ec8899e99e71d64218895258505749149b98494a0208de75419e45d97ef18de4e1e9f970f010ef45e1e9255f29feef68bcf87521bb5ac6593343e18cd95fda6828626bf4a5325a11c7944880aa814112c428da79d68540528674424525df682263ee6ff6519da87b52b36dfaca73ddf9c7f23f1842b86e1cd5670b33b4ee40fd773ba66007bdd1c346da5138e87a63663a7072720adf66715f23de8afc42f20903b6d1ebe58ef6f8190fed1d300e7e8a3a3bb10ee8ffa438dadc88b01e18532a88fa78f90097b560140ae40604a015f07099322131eff2d1df0d5eaae691914ba37e8f03b380eb48f921ab52a59030a92af39cd6ca80cdc5d0f69184a64248794f3cb2c116bca75dafce37962808c9b8e4ffc258f91bb7862289b24765422c77ea3743bf2782c886f4ca152304feef705249006843f7e988c9568a7ef7a4f534e178585b59ff6ba784245eaaa5cb3a564c12a2b99cca63eaee42aa44aa8fa4f2532429fbc7a2bf7aafbad46aeb5168bea8a2b40b109a5bf05c53600004d0413e622efe1a2588e0ebf8b8717a8e49d8012c83d80bf94eca06421b1b5d88b3d617338c5ca600dda45ed3d1151463059cdbd7e3da69319205414f23ef2a11877830880b2df3ee0cdcf66f38ca3edc5b1948ffd34b6fbebe2769c15126a151e0a13b49d27f8c7e0536fbf3e770119bcbe195ee3c0357fea9afaa58493af0455b2310a274f421ad38bb430ce4d2427811589278ee9f4614c027df4799fb317f214d327098041e0c0e1a57ab8b58782888a15dce5e1ca2e0b457e1a83ce8cc36d2df9a5f6ad5611e62d34e5bddaf13b2e14b3802648a3811ef1954291e12fe36acfa68257d1ff4c1f654ca3ede1c047d2200bfbee285b93cd0e96a063ec68ad898f4b6606784b68698d5284c209f835b5bdbef5ec498382d803614f04965e84d2e25dfe5d46884ee11f7f7b13f74f4e3475ce38ddbca1e95edfc442188327e5612396702b3d2e3ece00f6d2eb4b72326baf673fb9b7fd7b9d4a1f3fbc831520ec473611cc588e4b988971ab674bc22877b5b797104457e696f4f9c380f7d30ede6d326e80d790c4c81edcad85b348b48ebd91fdad0f6d80b68695c7ebd7d9979590c9d6e1422ba421b7733adab93ca99bcb32df6199e7bba12d3b116c29b89173c806ae2cdd2e3a4944368aeb0b71b203074ff115c2c0187adf6b7184c762ae72a959049800adc9aba66587dc3c2fd201ad993e8a532708a17af4c8c60e0a016ea6e8a4e9aba773355b021cdbc799bca726466c741c91c442df4b7a1fe9c4707fa8b0e109bd9caf4dda4224aa499f1c2a97438e6896780b1b3bf7e94b19685b4f7541a9af849e9821ae6ac8db709878127e312f25406aba20236f539ee3710e34c0b6a403721747e4b61fd29a57822a937a40be55a7336ec47e64329c33e64552bfc7acf601fc5eaa269cee2fc0dd5783f478a3a92c0a1a6e2b5b3d84e0f47367c3751e38fa97a7d3b703d6f64dddbbba8f43c5257023fcef360419383ecb8d252c2c7aafe83f9d52ad2c13f432991ba467ebc431d4516e2106b1b79829ccc968b48b726735a3469acce2d03233fca5402c965a7e629d22db299d731af3968bfacb24d3dfbd250ed6ac0695ec6e5c14e6c9d5dde26671c3a4e17a59d99185a91eee62d9706439e24747edf2e18dc48d204bc8b1581a8cf639c2935602fbd5a736a2f201cb72551d913d02f84521baf0746cd808fda19d2260f05fb512523882ee2cec6b5d599a2644af7eeb97341bbca8ebba5f8b60091dc5180ee9278c5d1af2c4da43f6aa631213a42e15adb00123c1e3c33b662fd34004c1761efb347a8b6345cd5ed5dfcdac32e216bb704acfb1a2843b4c79a721d0acb6ae221b4389f4d10c7b12098409183ea79c4e5eb4e986eddaccd8987624d67538581e5b03333c036c434cb4cfeedf6660d0021d4fb0c24694fe8565c771765afd0ca3ab9b0450b4bf165cb176767987748d144eba3e84cc87d7119cc94c5d98f16eff7260f4b6eafdb1a90e28fd746969bc8dee06cfc9b8b98097f985bb7f15047c4222801e8fa8ec79c67917980d76a140c1fe22db288b4ba395c3d5eb4b365d94baf90ee52b4033d73e5548ba5609f93324736b698b9fbf32c908df36cf3d1ad15265a1c616176be34920f910cda9be08ea4e57bd375424f9063c1dc4a2efe39fac4d301b55ee3e2c166e82f65c6d458c16e8d40299590e9d1d6357549325d3f6bf591fb142034f6a51b7a7aff885fa0287d5f606eabe5155ea3baee12703f49dc9ff08a20f6312ce30b08917a5db404f0703d112e6c08750a4f257bc95b53aa41d41d2eaebd5579f6e627354543ac79a295fc5a04cd6b04ef8b2c9d46ab9e13fd44461e2f616f34c78bfd02b72dcc4fa302bb189ed99784d5f267c9b800a0ceecd2f8b288254104013134f9d9cb89c0e2c01a24bdb017b87e5d6c1ed2e646a603d3ff3e16e31612987b26ddb6157ed1f4ff631440110290b8bcd2853537565a1597e018f3d86b49b82729bdd21908d7c10e333ffbb7e620d7fe1be77a38fbf562ed4165b3df79f93b001d395857ac95570fd3cdd2178769f4b670059fd08ac9e923a63a95b1a8a7dc77beca0ed48951b1bb56da85361be0799b4607617c40a47a288f71426a4986fd942701c84dfe10f55f13fbfeee67bec13051f133ca30ab9f7552ea4a63326769d3d67b26ff24a130f31b19c2d8c1ee06cb2484ec992639441a71d52281e4efb2910cbe3c2529ed0d5fdddd79c0821fcb06b2335ee34fef461f70e01eaac7e683eb64de0bc3cefd7113f5d6f1b611d280c847e5cb75eff1baa5b114c07ab5623a55b0b0c7aebf9781b8cb58f35c991adee96bfe7d62b7db3d2137ab997441cd4d56b9cc2007f77a4c8567066e2fdbaa4ec7d61c79a56ea3bf4393f6c458219d76df77e26b87f76ad33d386c32a0f97b7c919ab4bf4cc8e9c0ba90bd6f6248f66540a8e9616c89e96da34822dc286057853530d6abd0bf61ce90c1213c4b212c55975f1f0497fade0d7ccf5edf4a9b34a2cbe803629974a4e49f1fad388ee03531f541670db81d955d24f2771cd5b589a99ec81a020d93ccd82bbf103644d01f1d6d353ea6412f2e7c42b45601d33a83631c7db788dd5f0f44b47ac51037db5b84b1b2c6650a78fd5a97f2cf8d814d4c19b9db9d8998eadea23983c2ef46dee3056f6a0e41cbb376160cb5d75bb589db6079f5b7031837fa692b918bc46b7586f054f58365c73a686c67eaf19aaa720295e68df293162f441ef6fcfcb12df7d756ba7ad0202cdb5d8b7d7a7d4b479dae1a07a4ec24cf2be64880ea0076105afaa3600e8d60cd6caca4ec51940c724944991bb4951fa204268bb005ab8d1583817794ce56d2333b5a9286c6adf11c18a77939637a77cd89ee7e540fdd26744cbada768bb41432affe1df772e96beee021365893c593fd5472724872731ab746e4905fbbafcc5bd165ed0441fbc8cdb494acae2199c4c524d545b0ce442535da47c7bdbe269282433091764f72a83db811569e2e8ec1ff5d603b7d5b34e08bb54105cac82939054cbcca8ba4c1d165ae649a2a1672cc9478b6fa8fd53a6fb43a68d735f6b236f858a84abba98d216cdee11d854f012f41e6b9720652993e2b704d9a6c46ae4073f30cbd075cbe7d18544e86f6d5a7eeacd64c801aba9df05d65a11af92f5ad7fda773a4d3dce31020ad444adcce5136e3343c48520962650d94054a6c03172432ff79fe24702bdd3afe0f20466d7c211516f0c72df8ea0f6dd42ba3a2999694ea151134fc12c798efcb99c4d9a0bf6e659198a147003c344f972c00d6c0005d53981985bd661062ab89cbd347950c5ac025b36e9638fd1da5b4fdeddc84eb83bf625a5ce334edf13c57dc21e25636dfaa0eed5690495f5cb649ce702d539972c575e197c187c28281e1848f17b0d6bcfa70d9e33531744316eb2d14ecad3a6a32dad5dae233846d7dcb3cfa3350f17fcd9349ec64e10cd8b66b2f1b58dbcf6fd539cbf89f742d002a95322a881d14501f050b9548ed0d4df9715c54f57113af0d669f45617637289e089d3afa6f1ea8fd4c0f697a7371bdff64ee977f47836e023bf09372af5e2dca7673964915b0fcf3cf03feef425f6ce7ebfe6ae4d8625f7b86bc7ed9ae7a44b6f6d112c2eaf9652f5e246a21d141650bda68f51ebadd2a1460e6a03a7991bca5844e8cbe33d045d91557d173658a12fb7ab84c41cc15678b64f118530314ccdc4f8052529d4271b81c5056d1f41c466e662239f404099651fe4f28ebecdbaf75c8776a447e94c42eae4245834290540056fe4cff863c24557f8a18a5b831c1ba23b0bf7f3b8c877cb5473fe2a12d0cdc2722a81252ec09eb1e796e06fe745cffef5ff6da81f990784a648c14a59ba44b26ed54a7162f447a580492fb50268ed76882cc26046dcadb2f2fc1eb53ced9dc7f83a50c546b5323444eecd75f20cf563b1103c56571ae25659125528afd0c9bbbe93c50bacdd07c611cd81e5fa595215357a50b9e4186739520a265ef88eeb1cedfa7f3def86958d70b90d67dc333b58cf155d9b69b48c67a1099cc99b14b38d33fee8726b707fa04ac8ed13045f1bda45e24f4b881930d2518319159af0f09501024ca9c47ada795d71f78907ce47fed16821efc4a933fac8e549cdd9a90d70376c62b9387dd8d8a5c83c91ad8b12af76a974bfd7cff353fa04295877f6f7d61e9d7e65cd6c5e499daba83a5daf7b0e67ef86d5cca4723837336ce3f37ad98f11668ae24f6af3956245bfd530b81f3b512f69e3075da1fd7b7cd9b49a7d7f2f5e0126f58fab963c86181306dc3e27955308eae24a494a439c38c952e229ec7b6629fb2d33a790b143b9002c95db9ff02ae7ed72c7eddd2afc165a5caca98da639ee77f2badc1e981bbd8873ba006ae01d82ea306a177b95e34b5bbbfe5568bb1d1a21677d669c4a7320597652c529a5bf4b7bcc8ea8c98d8cf895d71b91188d97e11c8e211ff9db714fe6524194f3e9370d765789fb97e8afe640823e6b00fff30b2b20e529bac58b0da47078b84ecd0f531cd12e29e90532de83669caf1e90d784eae7398afc90b0a5738d82eddb366a8beb0928fabc55b542d5e23fa1d1d7a8218a03a660b3828f4b537dbce9fe657936e23419019095b19e5ec82762e59be41d0b47ef476e0aa475ac6826d7a89ac09afe90c0bd568949a625e88a8735cd4d8c2cd9597605f4f37e0c4a490703796fe029fc124a36249e9f77d42a4d9eb7bf434f8bdb4ff16bc943e22a1af578daac31e03f17f6cbcb0c88ab3c8683657ec967f6bf7f522aa001fc5b2197fa239dfd7f03b0fdd147ab0cefd547e43baabf234fb29cfb03fb955b48513a0f7ccdb5a359a13962738abad27595f2822e8961aaecb228f71039e66f08a463a051d83d5ab46199db32abc5e1e4404694b2e847024c4c3fbb46972272232f18ecf18660120b08156f97c3f521a9c01dcac3b483493734866ec8fe6c587fd6c388a42c315a95cba761c19c236fa61761c3a4a2273a49c746071696f6c16d89164589edca4bc1202ba9409e41ec27664a61c1f0aec33579ca554864ec1efa5725f56b0f24e13836e64ee8b51fde9db538a2cd390bd9941352648813d8e6c7271da5aa283adfedd1f8b3fba248f5e5fc41174b55df88bcddad9b951efe2306eb19d4e11d009ffebd23f759426b91d691abaac6e22a8158b37bc3088d5313e655802bc9bc0e3877f29799fec5da44695d0eef962ba6311acea57f72e76d40af884a7483f96d86a0718bae06e528fe3de4c183f68ee1e167675c4f7885092e1bd5fbd799d210819bd0034830b57885f25fbb8f8b368d13a5884d83d3f40be826e3683e0ff68c72c40167ad3697cf2cb1a50390fd3a980ece240bae0bc976c1d7181829b7ace3621025913d9e312b8dae279b88b8ee0f76d3f2656f3c11ec07841fbcd0e2c46df183d69e222cfcf38bfeb40113f2810fd7eda13b1324f0975fce9fbaf2c71a62ee407a0155849e5dd71e3540b40b690977de8ab3c3b6b1e547859327e2f72c0876007e456f3930c6a3cb639b34b2e248e3f34d4adf221f9c9c06f17921dc9b3a0b5f47040e81bae637e9a7db962811a444391e64b5386aa72bace2e75101cd58138f1d418971d993bb1ded9dd362734b9bc05465e32453d382494737d398b2ba4b559f210059f4591b07f436589d1fe934f727e9567180cbc2b34334c95fe70b46b44b45ba6c68c422dd75f2baf588016153096fd0868f472fc7ade81879d69950be6572456e528043127864a4c38f04a856463a97dd159d7d68aa7126c355ae9959795a9404efa064fa2237f0f76a6669769a1357698bc79248d8036fa655353c0e3ac88a52da2079520d0e63b0b23dfe738fcd1bfd22e1c70579a765a02e4494476c1f78ca6f640a5f7ea1be0c0899fc784703398a789c529e8f88c7cad55f2814687d06a3e04dd91db7dae4f6d257104a24cc4857731fb44c456507706e97cf422d4f771bbec121e08d058420c5108be1a5a6d33a8f469a8fb78434ddb15dacff5efedac1be4832864560a19d84ae7a4ea8fe4608b5ecbf81e9060dede26f342212e8260765220dcdc5e20605d1cfd46d3a696d4bc4ed80245c7a3ddb27b04fcdad889d40dc5f7f7313981d32bf056770959161213f8815513056954e16e9a4f75ddc4899d94c3846a2dfe348d4c7650a0cfa29790176c3286a27cd678dcceff06725c5628319237259e91213931c8707ea71f97d34d6807488b392f8d8c29b094cff93e18e7c14d81a790f56e488ad830b410507952a9833a8c52e2977a640f85dff8af865384adbbbbd4ffcfe0951ec962a1433c9cb20481e732d6c6724c8be0031098fe562e275a0754214206849353df199d67982d0aaea059a2aff0f231b6b25a5f51008fd02eb462dcc08cb12c4d547ff7142df6201eae2dc6708aabbb1a5d0a6cdb0eb5b5c089ed2f6c0540832d9fe1aba6d5d26f9d640e8d29680dc698a0a441944b8b4dd81360f90a8cc62f9f51bd120f88e0b2c67e6abc8d0fed164a3dce9894a6507d6c22d480ad0122c7ab256a369dcdaeba0ca95b76bb05c4b7e3eb97f84116f61ea0e1a4ac8da87b95abfbe5767fb39547aac25fd634ff46f8b25b2761663706234344b26bd3d326cffe80f86a7dc029f3547a195d114edaf3d5ecb5943b93b58703421049e7c3e7e1e6065f6bb65bc6d5c012a54bd9a22bcaf7d33736f14eea63ce8cfe26bb84bd3623bbb200fc722edb7712265a035293f6f098c5d5227c95be43703c3e0c7a88d34d5ddf4f8c477694ba52387b1bf5cff57d8896475329464b95e74d43d80f2673211d0191ed10e19a22eca83140e9786c06853456392426a679460fb1bc87701129716c2d96b83c471e7a77051ec8a52e5a2cf634551ecc07c9f87609c0833bdfbd8862eb1d548753b24609d1aa6c7ea0641c477d7d53dbdfb7f029f335a0a6e535635153690c793ca86d22c18806aa640ccacb7cf33be00075758b2bd1881bbebeabc6639fbe54cc15fd406daf7a6c546c21a8b1d807654c9204c318beb9551d405c48639eabf25127721cdee672be12c9f8af842554230db681b00dbf3bb6f7cc2cc8ec427f5004c9c94b96855c537e9a56da9cd17133f8b99c589cde42a2089deb8a2cc08f55844bacadeddd40e2c37bed803aab54068d87a9ccfbe1703508caa1cf2952f3804a8ac80308c7551241add75bd8aace74e9e9fdebddcf3928173c1b095065e3ea3c1ebbcdda328e76b4649de6b3d42ad1aa57f12dbf06e1283bd0dfd0fa10498c1615bcd1e70a929bbb124ae8b85dc505a51aa157f0d073e9ff1f9b690c8c51b20797c81c8c7cff8d61d586decc7f9e83b4559e793ac1796d9bb9578e3384059c725713d146b1495751912fdd45de199a84fa731d756b601d2ed785199dd1b097fbb65a8891eaaba1dd21555a09898262b8de170e03c1b638536deed47459f93e91a97729719baea0829c679e644ec4ce25067ff0d10fa528a8a68ed08f35624b18446788ed2233025bf6a069e069a2cf9849076862d3342ea853b47b962f5383d98e444b77180466225944e1491362de69c5c6bf56da94d3afde42e2ae80de660dcfb5bff6573fa8ac7c097a45fd6f90af7ec2a334b8a9d1129ed20d52115f70b9032670a84b3dd99cd3c8ad2f8d2e770cc258a59bb85552ebce9192b3c3c587b4b3cadddc856156740d7065bbe23a0118c31daa578770fcd6a9c08ace7261f1cb228a8abdfec4ca33d6a41eb19e31a434d4c54a8e20dd20da9519cdfe1dd7573a9c8d3b8f45ba8b10318c7f35c67918f550222c4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
