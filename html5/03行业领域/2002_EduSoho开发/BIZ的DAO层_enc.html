<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f7f29884795ac5eb49ad0f1780ff18496c277b035fdd1d92bcfe69a293a54a017dbdbe3d278798dc13785010138ff866c696d3639e9421dcb15a4444162e3abf5ce6c5e4295ae40d313eb6cefcd3a607dbd60c9bb53d891c59193e26c6dac493ef938038ead4df599b78f3f2c2071cd0cb6ba414daa23558f9480558e32615559cd2c14de6f4b2ec3741dc9c9213bfc1271b74eb6fd9f513808053e592bd4a4fd1ba6a7a7352814a1a3342f6533a845715108bc90781f57719893d15be62854a80ecdd629e98782aa02dc0d37cbd742ac6df175ecf6bfa2cc531b15f94ded6a402407dca15bd0e3805a23b88d2c0ee6447edf8c4bef2c5daa37761d2b9b42846562f6315d866696a6408a83e0170bc8f24b7aa95683e9f42405ba6ad0fe26a74e350763c920378110aaa96d0815dd9905713c6c68f403e8aa778db55d5d49736c0269ab2ce91eaba5d77519c9381bd49d9cb9dc732d46dd97c09393869bb8b2e5e61a18a81ccd30e3b3028d9afb0cc86807bf3c0e46f73dc4187576a1839bbf4e93f2de3e9290ff02964ca5da8d7f9deaaa1101fc300a343281caff451bb3d0cfb6ac9f31da7d8ff716f9e201504343f8d07a0802ac4b6d971536fb91cc977c997c538137db0b7e0e613267700ef92409f75300d2af7923fe2fcb8de2c2e8bc94c5fd6b1981db268de7a8ce1c3642f0fcdcf80fc0a57fa9a1191e422fd6648b1f1c4b63c5a4b6450a4feb2e3a557ef6d94b6b13a678f2b4fe105980577c3a27b6dad30d4628934ddfc8adfb162ca7f86045f228ec856ef4ad2693ef880f8d0e4803a8c5eba156fda1a02b1f4508bb088eee560ce4bf7ddca62a6617d7ab4adc136e6e0f3d010998d3c5328f13ec1e4c22b5a265d0b9228145984759399e7152578552ddf8199208889301fd7b6318cfc30eb90438248f2333fb7586ee44fcd7791815ca185727978766ccbfe57db6049dfbf3255b775444444cf9b236b4e9efeda223e660a9230c574554d51d2a5d7d70b27964ef16f05c7a88ad9267c3b82abf664dc954f21e4b3b22d1f98d92db338c0d0d471d69447e0e2e9f91cb7cb2ab7bfbbc4ef6f0182de4052d2e89cc674927e93a4da0cc6bc67a4eeec986dca0ee7e60a1b8b388afa3c06baf933430665260f90e2a423533e5a23057ecfe82d5f20229abd6185565df9d5c53853b1430c72379d7597455db47ecfeb4a8eaed90c571ef47d93ca95da6e7d064794c08ee9c93d1eb97ebe6b9bec271a3d27e5565f01570eb1877e90ae727cba6fde0da1c4e93436895aaae92bcd12de9b0f36303dfd700db69dfbd80ee5d39d10b19fa5ad88c3e29754e31cd27aa318b6474000ab2ebf5783f8e1f085980a524ab73df61fa9056c3c34f13d5631dc17e5d8bbbf286de377ef98825a51710d5117f348c6726dcfd8f052395b9569d57227602aaefb3888def74ec2bbb9b9afa727c0e95abbbb037864d7dcbd15ee49cef1e98d46a8447c60163579c2cb557ebe012f87abb995170ad5bda84dd74e7ebcc9c0427f979ce00c6f282b0a2710c97f69f65450cfcea6f0dd09a88859748bf9d81fff64b8ae3dd07287120b3bb0da84b040be85266eeb081a312b0cac1fccce3c45db2c1f0cfa800aa86fcbd973d988a01fea2495117a627ae7fd0ecfde3f4cae13e3fab7dda278c8df48a48ac5e6a9a2adb10fc6b75871668aee8fe1d70b17c1cf513407074e89a8e07ee9f293e57809b23f2f4157be9927584f1f658e790cc6b419fa11d2a6407226718abe53ddc178b9eb26b22dd2489190d0e33f44f5a03b34a21c7eddc4026f213060aa1e037211e8d72f2f13bffd5d085f8806062d143cc37e557426d76d31550260ac097df356a4d6b1d97d1672e579b47cb07084e9e9e6e5da727056abb61f3c5a879c454a9bd9ace91b66362e8de3ac6c804ce3cd05ff3c45a815e85ee384c3e5dd7b962c959dcd30692386029aefb2c4053eebcb4751dbaaa8d0be259598eb7216b33bdc3e7f34b6148d98e9183ff900d6807b660e18591021cbb3203a37f26ebe71573baf8c52202d37a7e9e3dd759844ef554f6dec04db1459404ab02265045421e28dcb5e35b22a325ff3b03a2f87fa22bedbfbb5d10eea14d86b614582ea0a2d1e372e7fb5a85ce4ea5c52adda3932284d5980875436716c5c0dda06c00a6f23c5fe2358fd2eeae8e8fd5812dcd19a5b2bf24bf6a1325c499a8640a920d51522a8fa5302d0755f498aa6748302b89210703d4b56b51f928ecdbb82de55a41c695be4401a02b01759a139fd8637613c68f92e673f3180ca12208f5c8b08afeca4a59a3b1459d7cd23aac25ad93dd86fc9d9d710c29dbf2545aeeb2156ceeb50e619846545498b60f1afbea0605e09aa9036d9c3159bca818c4a015c4057f9788d8d1f9761ed6e1e17be391adff0fba346540fa6ceace1fd7a9d8ce3a75cd01920ed26b5d563d3b472c0edc5aac627419ccd70f6f763a5eb5d57dbf7dbd18c8e3c24b0348d79b577f0662b2f4989645525696ae9cae2e82a3a69fa22e129403fc93c62f490b2d457f7d749195d06e5a1234963323277f6a0f61a87b98f54531fa18112d4f7ea2c74af1145cadca6ebf92d67314b930346d2f6c0d5c3082dfe9adb86458eff2113c73ceac3c9c3150b683d89de1b9090b2a20aa8f5e87558ef1b849699ea74aac27f2638f74e0deafabc1296ef6694399b8d90bf5706fa1f767c1b65458bd9fecd907b1571f0f68919f6c427a606984edcee9029d27aa4c62b57cdbc4aee43515a746f331394de668f2c68c4505bdf64fbd5b2b8b0e22324aaec783a88a9ce891b3f303fc2f20de29e1fd1d7a3645da253d351f866da5565bd1c0e6b2a294fdeb87a15cd9db6393d8be35bb52f596cc85726ae47d9ec4aafa42a2cdbddd35eccbef312cf98ca1c4b38234e0b5ca0f45ab5f24eafb96901e7056ef168763cd327c3cb2f222254165300303a36e41f36d3a18909ad0e9026958b179d151846b8e36dd3defaf81d0a8bcf848486877bfdcb5494267c4b5aff944591dfcd50f29a038fcc814b3180ae980e7194b502b4e217ec55c8706fcde870ed13659567911578f32f938487bac9915ef8811d6d2b6af24f37bdfc5576f6489481122065341d9d9089a7a0dae5f350a632627a7b69e4d0139af73ce8af2fc04db49a2d8d2b222abb8afb3a53b998397d21501ce6b004806e334b2affade8680837105f60456ae641c86ba1769a8a4bd9920d0304313bb01b603d1e783924d94ac0ec6743dac2847cc8f18735ad4c948401b480c9f430a1b101fae3b70578de95a00b39ac709e888494f0dd1af4fc343591b048be8ea3dea44540f1343d35e4351c11544146559775320fc96c529c613a2e530a9b1fd9a79bfa6b2d8930b67ac7fb5298acb4ea4162f285de7588a03035d56204a87a80648760a147a2b4e7a85c18b93357f50492b74fe1b64a3486d5a0eb2f189c43eac08d50a3138f6b4b02ea7a9a0131804feb13638bf67de31623aba70445b83044a603b14a922b9845f105eacf9ea2847a74cacdcc55030b30e3283b22f6f5305c89d92038fa98f669078908420c3e35de5aceee11918332916da04e68d55e28ef0aed72787788a52558cd885f463815d40ca05d3f868653d094be7011c1befaa18cec6fc5ea80fcffd0e7419727df715f97a8829db14e876921ccb95440ec2078434f51aa95f287575ba6c311a1a1532b9f1b89fd096ada90ec9e7d0c0d1088643ffab50c41d8ba52175335185a84654ef3b0749d9040c38d79025875f6917790dde5ee4b831359e7eb78c51a8a43eab40391760877a29b0d44e7ae3d974411e9ff4117a3c483ac1bab02e3b3dcdc72cbdb0e4b1f3c2874e9d9393d7368df294876b6524f760b8c2198464951c66c275a81bef190df858b64b09aad994dd0fd9ab0361a52f8a9db93ecd50840f7985e1d324aa8322007510af9ad4f22aad4753b73514270a207df5def71ad54c9bde1787339a57b17f579a62a92a8480e73c56aa39e319c5d0b308a8656b308eb497ba97d4c1f57a9671ba7bfc32cda3423d3e8e296f052ae7cdd9cd326c8ad4ff4016db0a9c4e55bb43556652ab2e5f5568cab5f769b1a11811fee6134c8dd4de634c643653ad562125953c8f3238a523090862c4f0e3101c472f7ece6e2d913d4299f3760a574dcafc0bec0ab6a0e158f721a40749997eed23122f251b01e1afff00c39b9f5d891d0e1919ddb6687712d3b0f1f601c4543ae48752d20df1e69b4fb5cd7a621e8d87e522371839536caa34e7f1ca9ac5b4d6df1e8162fa620db8f254db15cf2167e5ba6e123391ea0a10e12baaefd20bfc5925729e695f0e683323dd5f06a8a65eaa535de48f91f6b4ee4f6fd198e6430022f1a156de6b40a5f66e4b0f4fd70b71106c5c9916f976599560090f981d5dc815b0653f1cf952db708887e02c2d4a83da38cc3a4c0abc25e869f8e69d3d70090cf86a4af2c6186e8aff93ccc95a2666f330fc24c6b7d2b2253f1950f7913470872f4a813691ebc8c35815faa8d0741292608d6e1359b53fe3495b3cc4e1b6252c8b44e08f0ed15a55b41b3d16f98d6d48c6a717bf66be744bffab9a7266719f9382ebea3a46923dab023dbaeff5a3adc0114f57d17bff1465ff8720cb13438bf882d7d4bb52041d1d8f5794d8f7bb53487e5f1f71861b4f8eb440eee95145258bfc9a2526b94a4950cf1d6de18664d75ff427093fc6f45bfba9a169f0e3b9fa0241785f85bdad2960e3ed98040b8ffba0b450cd996aef073061c9b51e1d05d60eabe85a6fc80270e160b9066272d5f38f879e0ec74adb454efea983b154711dd355680e08aef732352c6a83ef025da001e21f338d463d4ad91c8bcf043741201916227c209807be832deaa9d69fa5856f907c33fc2c6d8e1726aa08d28a373f7db0f05ae67315e11068576728bd75812df9ca20bd420a42db956b4bdbe789b76fd90555571f3f62087a11bacd5df379275723833fa16a3db0411c0d00b3ba7707f5564a00a0d8f689322fb56a2e3db98b7eac996f0528fa10685fe0cfb2a111d4741c32b01daefd66b397c07d3a4bd5d35c0291894250f801d1d6ef419805c515eff14b794c16e944187c79709c29386404e2f4340d17b260241017836fac18f9685e748cb2cb690e0192ef0a1f7e464d402143504437acae4dafe5a55a73b2c54547a453acc06b5c98e85f9ca153aba89138cbc1d1fc6c882b5365c7ea9a949182d579c101d769b3573cf3dfe85b13c5a2941be7738f530cef671be33396739eab4bc2ac11c2990d533eb65df6dd11363b877345cec9aa3bae2a77a2ddc62432fc34d91b1f6c3b3c311cdf8ecb3ce181b822d5e441aad532ebbc169a1d457c6c65f669c7d92fb05ea1e0f3bd61245bc70841b534027ec3bc5e398f63e5e363c511ace6ee2f47c351af7ca79e1ebf9d900c8140c271de21b972e17ca4e271aac394d14847532209d9632e2a468c3cccf6e05d20d1b79e8343c221f800f764a3ddebaab02c28b775c35f83988e04f9856f82d10f9492e315a65ba0c81976a6ab038a50bc0e1fb53668b1d2919239057eaca116f8de3e04ac339d437dbae38aa9aec5d5c6e19f340085b1d710d3f65d525b13cdd81bb21b558ac71a3e0a064b7b856108dd8d76e23344d7085329d7cc1ff9da2d308dcb9a850cf4733597166c624f0a7d8cce3465c044467aafaa6b4dbec0d02b1efe4b73f00126bf6c3e31a0291ac424b3b8764581f895e9ddd2bc5481d8281e5fcb8f878caad4de9ed0c042fdf8bdcab5d828e048e30d2b8ad2cf28692b2ab1eca57174a882b5e4b7241e93f1db4cb1b2207ea955e5422800d2b550123448e53cc08d0b9f35e6d349f82525350922f504fec01672c7c260ef2c6db7cc9e04c6cbdf5706955f503ed3ecef633f01565bc038f8229221c0ec5767ceb251c4f217c130ead55a1206ac96e08347142aa56dcef62a8efb4c78c97a5757de8b91f5d92d3205a277d430032f04991eab9c5a86bb8dd6e7d85a46e016c88ed18e82190b1d149a1b4712d6fd142093ea806436fd00c5edab785fc0434f23ee774b83c68ef561a6b7cfe7e8d4287861888f0870fbbaa3acf0580e207dfbe4698474583a9dbdf7342a3978d5d438f89a5e515595b984d58a1b7a9a871ee9bef9bcac10b9aecf2d90ad99a1834c7d4ea58734262a5ad3e44ef4d8e0e89096a32ad8740ed15ef440db3be1de0a06c58c6c9036a62d4ce92d90c76446d29bc166620657509449daa54daa5ce66601e86cbd3b822e2f485f53bb890fbedb7708b5c5c3f09c9840403507bdbed4b2c664425289964d61d9a22da7f27e671095188bba81748dd39bc52dcc37985c8e61758921374580815b1916335c7fd54286f5fe7ff3e58e9f0cbe9b12a2b5e95401d5aa432f321d8f307f962d3be10b6a21129ed8831f73adbd3c24963b68c91c7fdba2ad9436a86fd08542a5e4e67880d182fa1793d0960973c393e31e304afe1b634be8a7cf2d4811aeda0d295ebc5327f52c14e47d2deeda853dd25229c00dbfb45a0c187bdc31318953a51e03318a2122a1b027fdbaa8cafcc3d2c31695f6b201a80c9f12d6eda1df8d2ca4c170cda05e49975d2dc34b6784c2a1a1fe0298cfe6d963ed1c20df4f70f6dd42334b9d894b6b41c868e3f6c867850936e53117290e060b778341ec7101a460a7892d6aedb0c887dc302feb41b2a46cf867cdc7a065850a765d90e2f946d47224af5ca10f6bf3707051cde2ecfa2ae0cf196aacd718ae12747276126e3ad0eb3d77ac65a5d181b4524b90cf54c404344d8a71be3f488fbaa707a0e3fa225db63a5a3fd963802e7bc8974d88ae34bfc5d3f7f67e49f39a59486e89a0327106bead7261ffbbd4fa9e9c4e67bdae5435059329d6368cfa1d65969dab78fa8e2da15de2ad240fefad2693d4dbb2b7ff85214fa170bca693d1dc29553d07c3c2d22eb21e232d2c5a4ca3ff44dff2669a13c71e2511eea311dc8bdd8cf86af1da2f037b2b2fda3a3ef4e07a6c3e6a7a20cf2dadb9c32848a3fa3677575ab0f940d57b943cfc5a8b948cc0397f4fc0cd84b49667167ef5a1c5633c6e65d3c9dc6a1830c171b324dfa5387a300c3b3645806de4a691faab19e1409c57ea93088027c0f38f3e43c7a2193e56e3b0e98dd24eea3b0215c1d1d24b73a057270a52adde373334f4be59b1c82a3ba94778bd80f40c90575e3f38f5442609089f22d0444a18d56e4b8522cbabebc820efef9c1e160d627d8200a0ea94a2025b849aed8777f73efaa1489a3639ba42a5c21cdc594ab17274a4838c806feb203d40edcd3f47b7632e124b5bcc29d536339b5004dc96e834c08c794673d41e00e7ecaeb575476bda608454ddb730b7caa8523ccfda71c1d34da307113aef069c1ecb548644b6d1c4dd2d0a9d8eec61010c0c5f84c8d17e3083e46ee02369a0c212879fab0d0491f4035ac34d532ee763e9650d0127ccfd12367e3fc8ca1e5db904274a1f39246bcf8a2b0dfef6c7bd58a5dadd87388743ac08c8ead97f599ab0194ff43f6921231a4a3ac6ab8267eb6b6f671cd6baae26e812b933096f45e69e8fd6cf8af62a8f0d45c70f4ab6f411be0ded44c7b8e28d494f8c46b6d6b2c743cb3eb1376098365a1d7158dd634bf8cc6a1182dd7991d79ff7187255937d95e4e803ec8cfde2b29f22ed5afe79d6c8fdd68b7accbcc00e570f5966727df6a96d3fd17580f9840954f5e64f557cbff0a3266f302e2d8cc40475d03f0218a39278ac339eb76c564c6bdb391d153a02911800774dc7e80be58b2eb4d98e2b896f455467f8a07c33a3454667ba1c6216ea2815a5c243a49d02019b38d36398bdc4b9227a16977617aa2d99b9b18e0adba325a6e5cc7e98a3a0d7ee233e95d01dd242b975b8da1264aad043ed26d3cb60a34998e82682297141282fab68fda3904b2549d643bc8a9c974ae1a93ac80f898779277875509d07719cce1eaf93f5d89d5a4371ba303855d6afd7acac85d886408e575dd70430b5562181f131ab314cf7c7279de801c6c2e7379b439773a14d8ff6e408aae6eaa1caa121a38a58109c34e0c023a4291aa4aca0b28fb6a08a382ea2f3aecfea3bf21e18333a3df9304e4402d5e4ef2662ec8e49a34210f4eec837932ee4cd48a920a534b03e25929cf0a741b714c7705526d0a9ae9ad5c2419a7aa109b60a1b34766f7113cd7eb0b0a38e22b51ecb59426945cbfad27f9dd0a7b0ae0f24515927703b3b9e6e6ee8930d06fcfa273c9663992eb250678677f89f7bb773dde34500dbe4962fb2832a2d66860ad204863fba759c0446d20928f111fb6c16fa33f2b3be1cfb5a29479e6e7087a2b365a898a24d529b782484b94425b1bd05b1640799339d3a8c1299897a1402abebc7f49111b0c12d5d3feb9bc447760f1c688af3e65a351962b4a31440d661455e0a819d93e21532810071b905dc5c155fe986520d91f3b1930bcabc20539a4e8c8a6e7420d57ec9158df5b3b63b12915b2c8ad277ca0b427a330c3104576cc92ddd7551a120b3bdea99a30423e04ce5c21d1c199754578ba2e48086651372d5bd2e4381d0a4de8b756aa5746aed4acbb305c92bf0a5014b05204ee4b7349676b272874c5c4c8fa82f23a9a69d6c19b7f18d59bd38d3341640d590d93227b704203e35b23374cd214235b4508d795ab26bc746121166d3b9368ad1ab1c28eb26b538ee59ee710b73d2647691b84f4ed576d6d3e575a6082de896a1654bdaa93e5af25a09f34e4b12ebe1e6650e95dcd2238479e7e4ddb8c55d2ed67f3d5d69ff54802830a48179ff14bb2de68299fa0fba754dd247b5a60212e551759057671d065af0f23f53f5fdbb862f98e7f85e24ec95fbd00f9ffead1f3823974fc94b1abd0fc4a93636115df8881314278ebade4b59ff3527a997ca0747ccc93e4a517e3f79a9a8847f5ad072383c980a69fe7e00f59d5fa9d25035643475903d66e7dcd3ddbfbe238cc26f2b0edd19af0180c144d0ed0ca1d4ff15b4a4ace9c8cbc95d20d1a08cc9b7238aaa06795656e929c35ce6f198d03e418e4c97b77b79939ac61579f653206a07de0304885e65437ea1ac8b39e6a13198aa5d12835ad0a75cc0fa948217546968c7f83da655e62da80bb35874ef6d7f1ab9bb7e2fac334ef4d9cec660bf9b679f36135f4287018544e292207b4e518a06d602933b79ed57a065d0dcaae0c622423d1999801512ba4d73988c756ad6a2ad3dfe3489401e0e7e1ecb63bd2e73994073d33fd66ecfd21e05ab8222551d1e3e453b4b96e7b06949dc13d28f3b55a59bbea084e0a5ae8f6493c40106b8ea9bcd0787be719fef5b220830a69adcb71a2b73f6d7ea9ea4bb0466ed22f6c3eb8e867ba1b964331126532dcd94a4e1d6346b8b5aab659f1d186015d169395cbdb80d6cd82b3a4fc3fa2a62d4712693262a6c0e7d4606e77dad3e36dc35f04f4f88ae25e6cf2abd0c462f1e38790eaaa098c93f252b155c83018ac5a91e46a33fb8ea31a7f3cecd9b1f6a704d4cba344ef06a256097e13f5a0d2571e54f2bf14de2a7d23680ec8fcdb306c72b57695763c087a8e9d2140079e3b1af24d923d4f4d10a58f42e53ff66a7e7dbea6b141554f34dc7c3fd7009659f8c1096cf30eecd906fa99621926aea7e2467a02f168747f423d00ab83cb486ee60f0a481e8442a05a218f31f4f91d219c93da6536fc664196ed4935327386c15ad421bc768a2f9373afb08f0da887b107f7dbad17ffc086afae339ac413872bb87841cbd057cf1d10cf9c9d5814f337169c2bde846f5b847e40c1ffb4c866b2523b0168b2fbd2d3f368b2b5e5af43b7d6c98f6d2f3bf352ebbbe94733dbeab1ecc3e667dd4e50024630f8f994e4bf315c65d974d549a21e648a2ab22050f7cc9c440f9e24c392da51713da52e2489c4a2918ba2257ba46df5bbc9efd5430783aae07c1879c2a2513d27373528c4d8b6733ffa469881759330728f22173026ad9a2e9dbc7e05ec9eb88ac38fd47338257a9d7ca0b100360e7b260ffe4d3c79d4449d97096b95bbc0d3de02e6bf329b13430903c3f1030de860765691ead6d4633e685867eb13478bf4e509d0c37c16e828dad027e7080138f40bccd4db439fe3f0ed1c830efc119824c58f048da37bb347715ebf277473981795ddd9c30673391bdd4d9b08ffaa1606450414364502449c5f5ca45f6db280b2bf49068c1d60a534ad22cc1a7a97f9526f58032310eb3c9ec0dca82418fe80c4129fa6e728a47e253d3f5edf794cbc49fe369108dc0b7ca4ddb31aaef725f623d0380ae5774ac93e969eef0571c3c7203d97e6b79885fa277447a34e8dd053b909edf6e91896821d15d58d0469f6579dd3eba385acb3fa93b255996cc8d484b2a94190a1598605222b5d9201728e9412a31b38e31bd035ad3df2618abee5e24a6f053924002f41d6b4e9be0484d2bcd4b129d8ecbca2c8764f56c37c7493551b5e8a1fd02ac5f315befa4a88555f41e54ed7f2c0d015a62b096187c2b42cf520518d7330c3e962c83d62f89900696257624ced153f3dbbc849b9c4d1cafeb5def798248a30b43973be94cf3157c3cb6869f0931604de69c6599858abc4cc3665bae63db1d7e67b9ae18c43e55d04fe4f32839ad7a681759147221724088cbd8529a70f4455117b9ab83134ff00bbfd45bdd7009f2669412b12447d871629394914193ab484ea25a22cd6c833ad6dc35842893ce6e2d0d025f4a0c84b8f94eeefa6308f817a2d30388e8171961214e33017e80ab67af0b884107a274ce97d14c54c8c8d113da39b8c8780ddd9164b975346a73fb2c80309f35662f033d0ac249d65a4d8a1d1bfd7cf3c2acc5e45d020fc3c993781823951288380bda29dd3351463db3a4419c0e0b7b9472cf79083e9bda7509c2deb912ae498e428ead8b526a02c91b2189ab0f9ebe2e8dbe2adca240a42d3b7a2e8fc87ca26b2c75ce03a923f3376adb59c2fb4eff71066ba83037e804afd535416dfd603f4aee554ef43f82a8fcbba2d6592b1b7765143ff8950a194c5fd60f99fe751d01e856c19765024c30829c6c15443ee26a9aa2bcac48d3938a837878f559ffa9f2a5c5d243da491b056a09d840eb0f003c71d724b02291ddf77c6cfd0efe07efcfce9e0f6568a1329f7e51897f1e05e954bf77dc7869fc59ec24eae4670e1a2e0b31a1e7be4bf4945e257255f86ad321caf36ee5044b32e2e6e34f18e2f70b05a0cbb690ffaa509ad911544083375836a941972abaa989262d062d4f51475fa79365d7bc3c6f05bc403aec147329e78f9738b0158e6946bee3dec69b954ae56f4b15a2c0c7038335e66466e047c2dd4776b0370ce405637a1072e1302f93bbb37efce5f8e3cfd72a40d4fff6bff80cf589d24eb276b4a6f0143eed5e5a610865db6e1973dd5d69a6fa46015b828f3a5176369cd722d67549c2f0e845146519b3f11eb0a09c8bf153be95bd43d27b5430567c2830d0c5898f00a07dffde16b71ec987bcd4c01f9c2bb3dfa251f7d0ba46d85f4b09dae6fb253cc190efd0dddae27a37e50913339648085ac79895a4616141266ccf0b3dca920202b41edb1143332fd5120c4b1f79aca5f258f3564c5fa5b39800fd677f0f9b31e5f78a7641fb86ccdf9f209c5db57e6fa66b4a778ec3677f97ef7c1cda36f71d348f440c798bd61532bc2100082d4b2c8bd0f60ecc70e4df5c5896f67e141c2d742ea841633b619decee2fac7dc887f4fe323967ab242cc573981baa718ce356db88e379e211d8f49dcc6555c4741694b4869c12dc71b0bcdfe3da4ece9b8d4bd1e51416b805d346873196d9ecac8d3ab51787fd41202be80caeaf7fb541956160c1bbcce61ef39ccd631e9f161320fd913023918b3f657c0893206370cd8fedf9892b88a13a73f4eeaa95043ebd04bcc2886c12c8035a4ea984a1c060e2af201d28eafddb09e59105a435dcb7075c594ae790dfb72ae39d3f9e25c280ee6c9383792ec983dc7b18c57c0552715e7f6b909f42905685278c6dc1cd8319cff2748a04495ec6907dad2414040e9954d82a60613585bb60a27a3076cba4388b5130271b4149bccf29512b8f0be15e1cd154a84cb7d0460dea1c836af6dea6791b1f511a2fe624b30ca977df132acbc72afc1f2d4625bd7df2d1a71285d54100decee068a151de37ea8373050d2585620081800607596a9623f4a4aefa3a1ab2f14584d62b76abbfd6ccaf1008db458878db742de0c2dfddbdf2cd115227495de73da68b1da97a6f7614e2ca048729f0fcd1e1e846d6fe4ed356b393aaef516da32f0aa96d2e63b5b72fa1ce29a30a28510c237fa5882ed1746991080610f66696d3722df32c95014c9926fb9f08a5ec3ebf065d77ce353d46bfa6c336065039801dc4d53c15d5c0d6720b07b3445245c5654e03057f956f5260d7ae4fe7cf0f4fbbf0a5f2ca28a9c017a4002efe12ab47212e3ba32cd30a2ecde71d991bd4ea8c8e0de0e15248c11dbb17dbeb2948810de4654a1bf405b43ce2ea1560ce0b998bc9e994704748e8b996db732866f6d12186d77be15581c23035702da4aff3276ca072266a223de6174f327b72b14d002f052da50a9746fc642a4dd9209e99cc891593472b53bef5ffaff99cb0bf313abbb4912afd4f94c379007589d623386744d6dcd54dee57530dcf17e66ac0b4161b2dd3cf5a7b9bb912af17d62fdea4a150fb25f73988cfb290558f3ad4dc5031d2dd595c9931e1fb24de65d965d2f85335dd3a71ca60c45cdf015af0e2cda50b7cdab9b578c101d53ca12a39eb05dd53515a378a5f47e7177a955fb2e95a116eaf7053a2c8d3a8aea9cf9b1d7eec91becd0948f1752320c4d1899ff461824266b1a0989e07256f9427eecf2d95b5b363045fe438aab71e2a6d22dc8a6234d44289669c162b71b8460ccdf064874a3534cd5401036a81051e415d272fdf4242cedc234aff6e4773cbd9b531f3bb8e3d0494c05618152347aa0044b8e922d98fec539fde3e80d81aa9642ea4e2f4ea37032e14842e5273bbf4a3687b669b2756aa4c06770e8e331df53d3a4f0bb177205559298fa52ec0a66c4fa3ce99e7af086a9e58adfe74ea7b99721242ae6e6071ca6bed83c08985316df4ef8c2067c2c81650f1064554006b0143f9938999b6dcb849f6447eb6c4b48d9d9955e777c1c95351eba62f9a7c8870075804b3fd9b54a240161db7c05b31bfb33248de751ffd0e953e4a8b7d15824299551011f096100f5cafc9fff46636ddce491466d919e14d6da4319726bcd6788e5cc2b5335573118eba5820ad1184971314889d8c8a4b7ad2b6c62cd5d71d39d9d3a86aa70c51d69a31ad724ae4ac4823810acb0d3a022740a3de9d31ba7b22adf977a5f0ffd934cd8797987f71cd167a5205576ca9870ad441210fc37d6f06aa612e2314f16fa4b2cb85d064898f491c8d8115edaffea1b61413af079ee73a25ed99bf89bf5815587807a2e0ab193aee960f639653e0e56f63a2d5b581e94e7d89039545d5907c6553087894b3d7cb6a6e47a3471c322f58376a43695b1c1a469e650feec34ba3454e414b08f5bbe2bf4926a01e2f55c10a118defa1af5191d851dd1309307f788b385f0f20bedeb8020524bf51672e6db338a2ed0ddb00e9f87fca3cc840c938c20e14b56595f33372c88a0f4827655bd0e639bb8caff2bd8e896e52efc3dc7855b6d7645891e90e038ed77694fdca2ce210e905ef62a66192735467a9cc9f1d761d0fec48a85871eeec103a08d83a1c62b973778cd4c302fe8741b6c32ea2cf46699c6c8fddd1956a0b7c7ba32ee30d781b8f6439944f58ba116a0e903aa3771a6327320dc15a410e456f52e08c32beb5b90e83cf13413ffc89edd50d4cb1b544d1240805297ed60d053372bf0fbf242b8c898636915b37ff1841d0a2d474c74811c5d45a39172fb97c5a6d4ea168aa156309df789fff287cf1e47396e7b5b4cb7e6ed412dd48dc4d24f3e7ae044a56204fca066e0e1822822e281cec0a1aff1c2e70f7f9f3475d9df3cdfee346475a8e81874ee0adc2cf58fb35453e4687e88bdbcc9cc972d4adaf006bc10758818e5eacde1489991c876b5a900244befa103b6ee8ee440e44a95c4eeeea7c24dbeb994750384cfea7624093d5e4fb75469c05ca8d0b229aa3b7250a7016d2cfe35ef7b8f271f9487336f3a9c62f23d68b3ccd5a59eeeb5e2fe1ebc1eaa3059d4f16ba89275d4c34d736686033a8a663b5df0f59558b99b0e757d91bd4f91b24a49bd3d1de7363e13c44ff0aa3fa3e5d5a5ee1c6206ce885b4067d26c5c5689b42583b3c16c400d38b05dd3e4d2a679fb225df4675efd39d1e9c947149eb3942cff5c308efc4711fd83cb2bcb58d8ff804d9240c0b279949f28c9ffe182b84b790e5877c51fcf12010fce8b99193002ed274eba9811d5e8759877fac937f9e38156143af53bc9b65233dbfe504c4ab5726652a0e8fdd0f9c6cfda90aa26c30653d501a398cd88a28065aba8fd4212f811e509c585768c411b139ca20bc2e37e3ed09fb6b68c3d3e8c18ff3c19f9f935d76f94205717962746c194df3191e253c8ce8b20f8bb011875b7ba18e0d74ec5f26ca87a6b54410f78dbef615d488577bb333396670c13660f972d45b9568a79f9411a16d8cd0e5b6a5cc4f696951157f35aeb15929ebad462001f7868c9b1e67c12ddf5b562ba00977e521a48de42","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
