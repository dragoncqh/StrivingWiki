<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8c0334c465babeee42b373ec494f9c79690a737fa339c6b98b8c5715512d9a85a074330d73a4c29bba260dc7a6341bf46a2d59c1f16200f291ea0a0d8ca6434039222e5aa81033cf94d17af19d95301e0b48c57bd8381cac647ac679fd6344b48a8ecfcf8207100de3e5999fb165a368eb903a21d522b98de58d766b0e08864a739fca050315cfacafc4baf5d56fc48056d2247b31de3b75669b34ff36d5d8fc9a657409130eb65b5bb0a1200c0fe589ab59200f7156493b9309d5b11b20b1f9cf34728600a0aaf888baee3917b8b4751602823700ff40808c8cac5826075b36780d4cb0125b568f7e0aa57ff4749e238eb1b7af4d1fd628608fc5e46795daeed06eeb22e563e0edcc559e83cb81b5a9cafd3d7d58a1b71365c599ed1c87265d9ebb9582797e69a2b53650629c89212462bb71b691b8ab7a15d35b94a9b486611d9004786295803e0d023262bc9301c8af6ac4be6df9fc0cd17b44d773dd4f26d77fd9cd0befa18f3dde91143e962d413f8169adc331f6d85bf6d7e77012bb9b10ea55bbf8a5c59bcccca63279bf1d27bfebbe05d6783223cfaa53838784f709c1c4446b771eec364ef72666546e4f6ed0fc15df53015cd55f2ee4dc573a7615873ad3870f58beab16fc84c284a386f2bd1d0b9f4a4b361fdc23645a8a0ead456e7c5e28daedb6a01d6d7519d32852fbdb850c9b4a87913037cbf23189d7b0c1c420496d2054150b455e7da5249dc7c4bcf0a2de312199dbe4710258db8a9f7741439bfb4d0b3e3fd0092d20c484ef0c2f4d250d2d8e0fa0ccba05d2e04bbe89ff50466a7f3d14da0a4478031db2d49633554dd624595c1e656eaf0d81759f4efdb8150710d3e2a67147a79de1f8715f9b8075b992e9ff3247b4698d9ffedda34426187f893621f5efb667173c8644c8f30aea8c65c61780f92284a94c60d6e4df68073311915f072747b9f441879170a6109e649d7b820c59308088dda03928e50b94e65de3984bb469acbf0b1037f1d6f816678befc9065d3b5be16d0470dc056aa6e6eff8e9121b2e73d1a625a94dce3cda20d9bc528f3a4019d07fbdbca90080f990cfd8683b94f8e4853237a5cac1194e0c6315e5ff24ca8dab84a456999ef52f43a946b1c87eef872280bd959628167b1e96b93ab3e2d8b4628ac23bebba37d8ca97369140e240c29169ed932508a453d5acddf6470cfebc66ea876ca7a9bdf166cd9b469e9115b9c870046536a294737df924529964e17d28ce67b1f5ba34810718f19c7dbf572cd3848b69fa703bd74c2fb5671a3ace2a83edfe2ff7ff70f8b025f7ecae8825a3277e01d66bf99acf52f5413a83fc1815e7099b38faf51e1871c480f6cd9fd9895765f04b229095c91e1b083eabf49820ff7880902acea21f45de0fbcfacf4fca7ebe0410496c63d34a984a5a454a7d12192625627d22cf81e76ed31659103110490aaf436abd0db48bd663931eac5bf90ea07d7402d7906c3bfae4265ceef7f7f27a7b10747f4b4b4f0f3eb53d50ada5251f34a4809d469a2db575ad625d9f68445e1b432c4a2c43a1439def0714f09e114ed317638d32aef18ccf8071b7d5ae0dfa1fd5a8905054354e70e7b9b8d6e7341d1dee04ce3571aa9416cdb0f4b91074d17c56dab01965f182251b5dd3ff3cc83a4b3bf74b7be3a2d442e6eb809f85c2d3f29293d5d9e169af4d928a023d5fc2e34897efbb591bea74d0c613f7e02fb845d3ff19307dc5235ac0fea755da96865546fb413b9c5742c20ac5a43415bb2fe1a94c85ce9fedda4c3106213b1afc88602769759bb51a219e338e03fdb2810f97c6771832f5bca7ada7b95f37e468bc24c69056a0a2fa7cf8293c9eae220684bbe0e127d81810739126b515bd63602b0339beea6ab988be3e22d007c64f000aac51669c50c87a8f793982dde9bca64f0ffe223f4a6b56bd8e960af0531644e887b043c7ac5c0c0d82d2cbc26788c878f8ac0c3366d57c82511a20171a5cd14f2d230a4b324730d4d6c1f5262963f588d3e36d19b2fa7c2bc379aeed5e46dcb3aa58e77383c77319fbcdc4abf17f43e122569e8957ba78cec4c5c797c80ade95bbbd690a8761bafff94d0d02412cfa439a29d8223241e582729cb08b0295280c5332ab65355dda772d24f6ca744f7a30762fcb7edae1c85b230c393a0859114c8f2898d02175fead665a9575a3bfac1dddd02413f44fb3f77783b5caeb42ecab33f251b61f19d04d50caa5a0a11d0a8143e8bde39a9f3f7e94160d8e6f93432571178cb20791a407296946f212c6ba89c3b0ed0d9a45f356e87be52cb2c62eda7245552ddedddf3419aaa7425b23685418bb740333b1d6b51601723ab66644ce822d693df7f7f20cdc7c07a4d6b94dd1376610ff3f0a4b3818d3b04007e81fd954e1133a0fbaa0adaa6d016643148cc00bca52ff11052af24377299b66adf9e850d0ca87675e6a4171f17a82ae851d3915ff4dbd74d2e24dc2593079e3e1602d58153d47ae13a65e91b57b13a2e5e90fbcc79d0a3cf0e9c4b9e37206bd59e9874b9c917d2cae2edff83f3da22442469e77a397409065fa087da6acc9f503f1eab98affc967015b48bb17cebad080ec2b7fafa3ca498cb2c9db1168c8d3637545abe65fe6b2e113d09040569923d5e3f1b3834ecdff911d614d7e53b03eff79f4d3af02835f1bcda26f268ad5539f2b7160650144ee7e192bf1af772096ff6c49ca0f4ea7da8417d4657bf2f41911e16f930a97e9cdfc8325c769319c31c587d97ce5273671b510668c2530d42fbeac6160e6a8fc0cd8a7483419f3a880fd71fd01be8f9352a1b9345f0c7f057c493dfbad4c4a1fa3131ad02447dbe0ad0231e25661537bcbea5182daf1f3849f6092769f57152e9704aad7c696bf9c45c79f4e0f89ea30fc8737a5022236ffd4d1933cff19bcd6963ba9de89a1dd11339200af6426b388091fe4975b2e2840e8f79e046529eed703430bd1bc632db5d536ef3218e80eb3bd7b6e89738cd1e30991b7d40a14950ed5bbca90b1d7349db2bade9ded654ffd46ee1ffc474a9cf19753d331c618f7fb8ef574d274ecb0e8083ca07fb0fa841526093d1c8af690417f8eaae2f399f0c285dcb5dff5e2639b0eac34d79778e38671bb39c58502499ae625d69ed668a815bea8287ddf1579669a0abfe214e51804a2f05169edda3739e000c2879e035102434f7aa87b5bee76dafa2cba61672a1da401d7d5599aa7ff54ef909714afe97ef24fd63e12a1e62755b84652c6b9c9d948ebd34ab287118644d435a44385b5f121aeaa1930b9e10467f40d2fb3c2a1ad7a6c3f70b30123ca6e40d6f2d0089405ae65742ebe229b23b2b3cf30cea86351f0350474ac9b45c59f8cdb7deb0a83c1c5ae1d33037f9648eec98c5930dd38d387cbc1f20935547fbba1b54504e33f5e50bad0f4cd029e0e28171b0f3ee16e7e9cc09ab2274a5b64f4eaae226bd53f0f4dd83c4ab7c2079588a3aa3ae7dc07a5c2a516b2c929d3eea885c73640d355d6df056acb0a85ffa2e4ad7d5b377ba5f6b297ba3be28547553946c48f5843f8c136d10b1052b2b68b0c75a1e5fee0dabe0204ba1c9ed6a5b14d25b390e3edb198c4bef8c1ac03b0aa104e265b59ab5939ae2a4f286785c03e0e88a42eb54c9f5dba6e6beef3868305ba6232743abaa9edf070360f6a881b477a90474b8a8ab93ed48cba5c1f63566d522bfd2ab13cd7f13bbe2d134f2cb463648df82f31030d7bae0644a3c4895124d78387b69ca1a8476104b354bf9557e3919d850e84e3106b8f8846ab53a91f0e301aa9efa0c65912919a370a5ee8076d2fa425294bebb863f8a54f8031be110943d1c0c06d25fe37443a495ab6525cf7b8e97333fd664ce7a154a8271035a11948d79282291bfb919478ef63b562d245ff7e23720a9bad49478c5575e13305d5765e498939b0a1f144398b0b20091775feec395c3264646af067f4747bf39642aa7cc2991aa3f1dd497f9b2fab49371b5aecf7e45029665618693d0a87febd55723813c18ab0ea5d19cf4bfa6d76d59689d6f6462c2f0ab1fab72a987b19d4ff9c23b23f03e0b45f326962b1bd2ca1d06b510597c3521b691e170c0b28cbf06cc9ebee158e2161c7e16933fa22c75b7aaef9adaa33285eaf05a9043d71d227275f5c4f5e879e88af86379f90bd7c103732f42ca21010172e05408dc4052f56e57a6bab9b3684f46bf5d8e917eecc7ddfad9a14bfb9e01a06f02fb7bab60988db4af5fe968d6440e1e409e0e10bdbb645f4a3197bc63f90520bf927e59f4734c37ae68bdb5b692c76a29748aa435287f1680c018f2adbefd42587e9677a52c793dc28da4359db8b6cfea872be37679be8a724dec8c84dad501f3678fb50e351a44bb48b28cfa71ecea31806797aac5dde27bfc2e3726ae135aaf985e56c3969134439db4d2f86f609002aff17cf3a298b1ed90f2e8f803648ecb581737f20e90c1d02e93f250491c211ea257550bbfe2feb002fc2369521faeeb2dece7395b680ddc24b1f54b6e4bf53f4f9d7ec8c3f3d3918ff71bee8b9cb828e252f1f71286e7ae1355e29b213e6b583a3a977487f4a751538fd474a4981cead08fbd1163285a86ff7a3c02de1f0a508bbbba75a31f1f7710f1546a5352693f488b278037b45c08f109d35ef8464c8d8f9b7f97320253369e70d4d096f943f0bc3d9a13864cc3a76548443d456eb79cd3fd59c144e6cd3a52b8da36dedde9741a98031e2ebe42e7280e0d87c7dd85d6812e74408143eebb4b95585194ceda4e6ae01a6f34f3e1717e857a7bd5e3972fc392d31549234d81bf51e91f8e2f3e18a25c1058e6aca8c224d86fbcfe2042646c4dc30942c855a591b424d270280473fd0a4f3fa6ea73430d909fe2e492c95bccb97b6f36718fb45fb5fdcf73aca1edfb036e4f12bb1e0ec79f4a4c794e1cab810034bc5f6668b6113687a80f0b86efc0d88e37ce72c74687b33886280ebb33aa9377ec908446c8c0bf7f2f10ff73558b2fa59af1058247c1d263f3f66ea83cf19789ea461cf87d48e8dec0cbf95ba2d92e7adda25552cbd41b97887edc8dbc1a934f07362f28a5b04cb7bf455c655e390d5becb8a313cc6dd3d148ef63ed069183b3b7beb333c4d5a811ec9641060a3c36bb819b6a73fa81dbf16c6f6f20d41707a369b9261ba27e62a4b0b0aa7f68b807f45a7768ffc1f84432db5bbf3f4608c4e1f31f2137475456f3ae02b230e609cb1bcd1d4e9532478cc51d4e48b68b774adf7c3b6e080767d7e549b5de990d3daea516d68db4d98dd541c739e7b9512cd96c60bd16d81786048aa5f761329d61067c07b0ccea6dad73a9c6676bd55a92472b205e59a1066a8ab5b8d448cf2cd3d010eb2f5a6a018db183ca3d400cc9e0b4142f2a325160d08e1b1c42d3a65f8cdff16f0140fbd809e253e2d9e98141903af192697c4f6577952e103c7da48a79965d010b0a2ad307f8963d620f4c70070940af9427491cb4a848796bb7fccdcd1d410430dd35bff24241fc9ab3252c1d8822784bd6bb3e74e69c0fdda545db8877700ffc6e538608746715c7c3476fb898a25950158b5f76c975e7c165bd262077cd4d1aabcd0460a7c25c9443fb6d8a73bb3535c09ec689ff8c0df70627290cce5ad89b7c401c230b7c462a11f9e7f88a81fa14d12d42e2fd2db793f4741cb0df6be1db69bbcfbedcdf4f0a5bcf79be6a99b05861812ab05f6001031d1977abc1ccecf92f2b9f15142595391cd7786c7e446c2e6fd391f241123b485758726ca9548ac15d6c30e8a085999b15e37ebe12d5747b8fd78c17a58d42922418e5f2198e527f661731540ccd094d4f3888533fd8b9aac5355d136383ce5f9b5a77652ec007528a2bf6a189b8c70f336b3bcff3bb41bea42010560a5e33d1889bdbae3f04009a8ec91028f96bfc7d4f7a304d294051fa4cf5c35e499dc9e3e35ef0022960c3723dd1cbba36207aaa9edce7705d27ba42b0d9c18c3ce26774e604f11bf3858199d53b9dff15c34518af9f01197ec1d48144f1997124727dd231e86378cbb0889c971ffcd4dfebaa8082181255595e62d692151794f8560236f95cc396117d5d6dfe2ebe7e3958fb38bcfd05b18d266a950c5ef6aad25dac9a37406babcdc5178beceb8584bbd5fc32bcaca76f042bb116bac1a9bb93c18286a8356eac9044467c345dc548513b0e197f968b122068f9cdb093a02e57b6aa0e464031fe9a8ac14a5e1ce519415a0b766da3e8632b18227aec91a0f8cb1967a3f737582f89c210b0414b787ad722bdbd7affc4d203c1c06490df95588b4ba8552a84fe6d07837b10d2385c821f8e939d012a76c16577f19735f289a3db0ded9e7ed02c5da0ad4bfe1ab389447483b03d6ee646f9d561d572cc90a08034281a64d91c944e2ff348e685f5aed3f240ba87792964ef50fcbaceef0db8895ee904bd063565bfd35a7b135711d2001fd684156e9c26c5a2e1fe52bc96f4e98ce04f7ca9276767f08ffcda081dba5301734c5a7965f30a5fe3779d8a70022f0f6b70b5986397643bf19848632b5d0a3f7ef869ed70b479cc5aadaf0d58162d61a040bca0e457417328f641404f63d8e6213681a5341418ea9a9447e65273c9d8b2a2e5bf689265bc65701a4157e4e7dde591a45927908260b4912e5f8f767d8e8ccdb9f2eca9a922910e6da4dbca8517f8a11d6ef06f8c27ea519cc79c41680842a88aa8851122b3a5b93c9ff269a2ad20acc41cce1099ed146296535e925de85b20332df6bf527cb96c9bcd8078c9960cb936c334beac06c1ed999e2083042a7a1a96aab5b0df362728b79359f8340e883c9180a4c304c8d4990230e46a04abacdb06cc0deac4e12237e6ecdf04fca981f67306e570539a47b46aa1648ab37ea79b889bc0704418fb3e8bd39c0a7ad1628b2d95b10d9a952aa7567c1cbebc2e1d97d0f1bc9d650033f19df7602cf896ba40723793891fc3a8236d8b2b41a37417248fcbf42cfacc95ccc5b59f0466463507c89026fdb6933ff37eaaf6a4c83939c80db0cb306e9452fb6d781a69143ea7b6dd7a1456ab580e166c2f86d6de9092565cbf28fa8f56c74fdd5201f4535eb87759951b0e3ed1c65fdc173922f44c7735239a307cdec66ffb3242d3c3ea2d2fd534250a803def24707e09d210a1c1d98be7588ed2369b9178f42ff4332b506e34683bfd1b588ae309ffdb9d867206381f48f884a2994b6527e3647f906e95876e146d6a8af0766dd3313d42b91ee9a95a6edad6887e46a8319d78245196f39cbe663d266689bb73245985016f3b599abd8bee9178608cfb3fd1be576e44f637d94b56fa1972893ab0e65c691c70064d1cedc56b2c1ef2ac455461c7eeddc6f608791515c7e2a00c9fa51c42b36026651b055178decab14dbc4611234196964f37d6ec1cae1ec4fc993bf5389ba4627644cf492a7763a671f9925823510d715ee4fedcd6fd6583676013ab48b2178920e2f7a7047d18deba101c02d69afbb710e93f44dafc64963bc929ef7759dadebebecb11fa4098af9af4a07d5f9cc7375958129e769aad651f89ff52a40710ac4f631915f917bdd7ba22ad8f8d5f4e4c2ed3f79cb3fc9f8e0dc59434076f0592fb931bbc20c6c84fa521e0ed6fa31cb441c5d5e4dc9e1d9dbc3cbf3addf263ab32a1ca119c76d0ee28f4e3dd6f83d2b32b9067a939f5dc36337256333997ddb849016955ecf50cff9828fc80bdeae5641ab782277be754fa3c588a72c27c614db6c6a429ded339540616701510996d09649fa46d85cc91116232fbe545c6c654e91aab34c92a70bab0079c91df18368c13afb58713db8e3ae2ffec156f26471041b863d887c91c8f7148281a590cadcb3cc9a3f6ca6d0d479efb4269043e7413dc66e7a1b1f15af573f5a0c20d48380d9950e629c7db2899e63077de4416cda7b25c9232b21c4e736654750c0de5733fb794c861e50e58ae7ef59996fa8cf2488da849049e232ca95fb1928cac6d87bbef3ddb7102e1ad1902248bc51eb48c2de54dd8fbfcb56dfb3949de9fef416459b0a37191fe8d344e28a828ffb242154de1045ff1f863fb3d28e11b210e8be99fed718e5b2bf22c98709d3d47c326ff5ac4d4f37a379bed3488103f5ace53c2632726c535565c1e675ad43dc224635dfd3ad0780d52c1cea71567a74e4ae3cdf66014a1556ab02787bf2cd43e6389f900ef02b816c6e80085a171cc28593614a5d5cd8b3ac187b48096e81fc31418482f7e3adeb580428765c621267f9251c42d589b62d3813da002a5d3784c5f33f46a90601592d9d3d9ed11e702c23e29023796e2016a85b3d4e239e4551dbbe66fc9c62b25a3dcce4fe13ecf41bc1cebd505e53d4d2236c399a41cf6e7dd6d5316f3d63fff23f759f392834b74b1dceff9112f2f4a8b3112b03b192b856f60f77ccd77538baff439df710067944a465f1714f11712ac3605cc3a8e8a6cecca3047f672e0a915ae46d71f36d8e8ad1b8461b7fb562b11d40bf30aacf3996b48d78cb09a21f6418dac8e42e6797f913f81ecbdfc941038a55b3fa8610f15e85abd3e1d755c799d7fa0e6d1dc72e0070f7877011db6497612abfbcdc596f520eeb92740ae848c2edab759f0077b02c3f32f5ba8d52a36dfbdc70e5483431a22866ccfd1dc1e5a0a6674e4cca90643a5f52ea7ce11ef53d52bcc4cf2a5d38a969e179b1cc0068ff1a9dfcc1fb735274cc6cc87a88b75ee52c1aa6e39efb5433367930d454c837ad56c09c731009310c6995cb64aecb981c32e36ffcb3ab7a07bb29b373dfe0fecd6db4b4f0a0fcb93c6c692dccf8b0fa3d8598b6fc5461cd4b30bdd836a82168332bf6b60563d640c3d0ffe97370b0fa97f97629ef544663fc2f0faf4f3cdfc7add7641fcbcb3e864b02e0f3abfb40a0ae68a927884f482263c105222f8fd3527c274c680754813433085531f2685e723d566f49df909e9bcb3817934d248b68f35b92f850b376a020c4b36c4c7b99c6386e9e2190c8ad0144b8c872bf8ba8966830ad96017cba87615254e3275af0d6cd2ca48f349495125db505114d87376d18a067bcd14751511b4f68bd2dd3f82f4818f15300b73d98d653e336fd7a86f28252e9c2ec3058e91ef3d1764153d9a6dfe1e8011b3ff9851877ccc8ae02504a40c08341186baee4f92cd771bc02142788b66c5d0473ef43de6b054672d1c33d16def6b03c1cc5ec1d62baa9ee9ef12a33476be6624e73c18503f6b8d77826775a3c8b5b37f012fcb0f87187afd95d662b30a5abe2526f1fd4c4af516edc21f6668af14199f377bb9a5a9e612d5cd23b7cf73800eb3a51f93ec49961f62359636cf2cec2f06ee6a41963a463c51c1b6b1dcbfe1e8efea7cfbeb07f5119241e44a1102a94a0fbfee4abfe92545d5271339e7a890f8daf21501b421034c77ca8cce601eab2f059b616abf258b2dad1c8418778e8daf9a8f843cc2c10f77a55a2cba0f1b813d0cbca12d9bfe063dbaf89b56f893d13f6c58e6a509f4f102f1fed544b82011b96650c8dc53057f2a0d92e1104653eacd02e7a5ed8c665d1f6351deab89e614ba7e01d4ec36b2d6ab707e31a743f73f14c11746c3e5ca98bf30bd5ff95cbe6d76e7d99b885847c288eaa6ced33f69047c3142fdfa8dbe4ac1d8f93e30eb940b4cdd5a4c54dff262f18e028fc5f3789d7f29fca75d57b1de808d11603accc689d6de39ce301cb93fa9612cfc2a4f9cb10529c7846162be1c72a30607094c65dd4e780eac7b5420d85536717fd54a63de546e1fd15f50a465839667bf28e13a44548d2846a9e07d9d3502d911233bc8e7cb7143b940c0dec1fa5d280749318699e0a0cbf1936d088e50ec5796e0d6f805ea8c6fe7f10cdeed9b72418f219b21c8676edc5fd3e33c14e0fda80d48cba874ed651ab96262567b7760fe0fd0210150924c3aca7ad8ef7a3f943f1633583e3da25da43d06340392707462453e3add82d6e8072d0f3667366bedda66b5edbede2ce3ab76ca0f761be8d84f77b6284834b5b5d394bf88fc86815d0454f1de4c70442cd3ac03277bbeec125bd4784db7097f9bdb948936ac3f7cd568e5286149a4d6fc5cd5fa4d8fd9462d132df8ec4213d547f008771adeb0cb4ede98f3607f8f8b2a9e739352429900ba7e626222e7a6ee95e2079625bd95c26f055e88099c44258fdb3ef25ab9e6037a16f6064356229208ae8dc4a954b440cddc0da9dcb38308b75c50d95b627663eb596126fbefd543c6406b55d53bbe2f04cede47f26729db8e65d80cf8a29b896f85e647000f58b30b604c84468ec21ae2c0936a70983b3bcade0a1526129bd4a9532d6be314b787ae4e51669ce35fd28740dc48674e9c66f1ca2a63084876882595968985d9a3cd4a34112fd0e25e569b717375af4c122d17c6a30be8c4ed2ad5e23e25fcf365319a4f6487545419a1b688f93e6b370d339bc09359a52f0b5dc870c4596ccdd4de319ec21a329bba578d7b968ff11ff2f18d463c15f376bd6155ef61dd815106c3ccc3db5264e321c6719b61b1875f5fbc3ff137056eaefe123614ba44bd16a47dd62171033d8f64ca3c9504657145e2bba28832ede51ea0f72223e33dc910923f9084454b260128197fbe147141b9aba8922caffece9db0fd7293fa16a9378009147c133e0b9248ab5267218695924fc24f85ecbaed96b23568dd360ed5612b71a1e627f87e822dbf0f5239e5591fc51fcef8d8a7ac8965a55c9a2aea946ec221beacf6f74e4f6f00f9485c1fcc47de421f30043640df3bda68d0db8528373b8c803327453ae5acba478bc8036a3b1bc5351497d96d869060f0807b1bc00125f56a9d71bb25118d3c520b6b6b54ad4546553d69082c6e823e5bfa83d75180b973b70d5c43b61afb6bf32af590ee0f1efeb4955a259640dc1d00e1684772cd8d01aabe2a92b90314ae68c592831c3e8cfa5fe941e7e3cb9c410371384ecc5402a935e08867fd53ff7d6b1f7e1921c7c332e7e7a905b2a51d2e456fb213ae322f689a031d6d941ebc485ea7fc3291921dacf9bf606d580de2adde962a07bfeb4dd3474d976e30c929075b993d8fc0af8201dca6b5689d6adc2893be575d4c91ac71ecdbbc01ace0fb30c0c5abef138","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
