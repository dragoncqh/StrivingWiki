<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e47bdbf61e7e48285a57834f302517a782b52fe2c275c7f0111b13fff984ff8be0acceb2cdfbe1c89107d42111edac2bf95d799057c1fda6b6f609091c3f52e445d8cafac6b425f9da8ab79d7bbc39234d554da9eadff9f0c357555928336ee75215cdbd80903f2f0e9e373acc05cd6da0e9206ca7e208ca176e1547c50c2fc3755216e0c388889969416128d63ad1fd6cd2306b135941d5d86bbe42920cc7331320d491c38413c54885271dfcf129deee50ddc63a1a28836ac34ccb3144a08830dc3c7068a1d994f687b4dc82bcad521b7ae201944891aff01409e5f049f263d93fa53905c3815f838e47c8c120f2f558c40c8b21992152bbacd56fdcd3252563dabfb072026aadb4d5d054f7a8003e90431739076cbd7385d57ecf13565b5394cf7de925915878f9bf55280ddc42fb767f59b72a185502bdcadeeca3cc4cfdb578099fc561a7947d7d2d51a34d7c74fe1e540cb3da413665d3971c70d0a9f77d630f5c99a8e15d80c047e9220087316ad19d47cefa31e3944f2cc5327a5958d7e773c4ab48d20178184badb24553bc145c3598ac425e3f94aad90781bd7c0033d071247f0e550e1e16596483270b94f6c74564def43ec3a4ac91fd80c412cc01155fd65698b8f8c29fdde759eb03b150385aad8b4a3c7ea50cb05501c698f5e47019fa61dec2b846636188680d24c0b970315044b842be6b51d15a9eb76a3b37ec4cf21adca2521ea2386dd2b54dd4d47c740a5155d8c4c71638e98d0b7bfb255140853529572e03f1966da421ae3e5fe1d6256275c43ac961ebc90a98cf12cc4c751f4e91ec9dd9e363b6f4070b6823e67aa30b317e7e8592d24574c355e28d6dae441c4b176903573c088c3cdc8ba4590b312da3e043872a27d57e9cf18c82e1db436e6ecbbe2887f9dd4954bcf53a408bd765adf6b820334ffcdad072ff95a89fd19ef283f0ea799cd7ebed9e3b95dbb022afa63b7004c379cbf35b3f660c3b82f03059cb1533af39e4b5b3b612775de7dd9ed909bdae6799bb16ea1e9d640c2a52d63811cec0e9f64b149aa4b87bcade5f9380f4ece3558decf253fb759d5d8028aa92e6aeeb2d1f33400d6ce49288d755f3e543d8dcefb63332dd4e579bed1eb4950cf48ca1a00a6302644ec0e2b00a109ab861ab34c2787517115d1e6ee891d95b10bdc28aa1f36625f84742c5532e3baacfe1a5bf57d59bd4b8e7b4dc1ff4bc6b3cfcf55bc725537dd5606f9d650fb99c4c74e8f679425b79926f5478fcb6ebe971ce533f48c51a84e9f10da6871fe79b7f6473d809cc17b60c65ff295a2c71e6f05f798283529c9878fc8ed64b8d987a2ea55ccd85c570b3eb5f9e4d634e3cc22732cef5f1a1c166cc026a39019f9b57fd14f8e87e567412f2a6c24021f78dc965da9b8ea8daf1fee926cbc789122a671b6dbefcc01f23a7481e975a34bc304014d6553bd893a32ec09b1550ec5b413c45857a1d6de24e123bda9623d1205f3565efb8579b6f028bb7f5799f703e4e7426b8e7979aec0c6d7bbb8f1eb1a170275cd89a62f13c828a7a725de6910618100fe462db8c1557d71af20a8decb4a45772453ec89fe0f527b7596a4d294f37e47023ba2c261a602a88810c4f836c292def1bc4a7d8e5d33dc2639decd28b2b6afeb62156bb8875c4129a5274a005836c020cfcbd6c2b7cef37f8d0e292f67183e16d7f0cb51d90030163b0dd3d2b767589d121637447471c08a09f8ae876cb0bc7bfe7c9d7a44e9d87bad572e2a72a609569d279fd9d9ad4dc785c0493a750b3d1d9177151627e534b11717505df6458f7ed0c1cbf4ef4e04148713bad74c8b0f42a4f365724049c63e3cecb27c9850565b3dbd80c5ec61379428e5e55ebb0593e2e3d8d5f123e3d670d7ce825d95741e1e41f19a8cbe68698b2b336efd810e454f42aa041eb128881dfc4a2b37a570ed8f3eb6f487710c68730afdcec331dfb72bf5b794bada83841c9d2d32ad68d68b1356bc084a31f12a91db0d77c13486d56f70f66dcc72190149fcb80a6fec11e0797c48b6c5ce6d5ffb18ca0ef7684e8ed412c44dc3b0667ce9c69d3e547b3008b7a931cf46554094a2fbb566004c405e9b43d1e1e17c4273b3ab0b755de1b0ead864c6b53a126c666e898c900328165db88709c7da0e4dccc64bf229da04c815325a415d164ea027fb793e3c17e20163c78159422fe062b41edc01c8826efd0fbf693246e21796bece004b174a5677d6ab83676550ce505eafee106b60f48e12144391326f92caf5c8e6fb1313d065c9b0d80529a3cdd626bf1dd61fc93ce88da192aa5749bd5c6233bfa41c6ec9cc3dfdc32e8796ad81060e2ccaa4f1a89b475a06e944433a9b4a86179c2484b5946e11a934eb315d0f4b622c53969dc8737208272481cfce699ec141af0729c44df1959a8245a4e23effb4a5dedcdeecd1f010e33f7923fa90f78d1c501fc3cfbf6d7411630c304dcc0f040ff3a1e6b37f27fdb512a9f5d932539111c66250f2b680f958d633ec20479c0543e46c84baf3354b9aa5cba8733218aa6894065f2c3a300d5a8bc7eb9fc06d7dc2763cfddb5fe0748fa484861d22983bf448a9a262fce8dc354e73959d2300450d5b395d75fc45be8015a99c423334226e6a0aba4c4c2dbe7af6cdf56ea6589664741aa48a993aa7d1a8fe1b0ea9e91336cd1bb38aa8ebfbbc2478d90b6d966401e3a97ce6b159c790914c039d75bd87187ff2d8ef8040f0c23c1853e6b62f2e3520f46607c2ce19fc3c858c6aeb4db377420aacebec09b94ab728f590006517d089a5d5625ec758835c83c3706f93e83bedaa9e892687b23719462aa12add47d9033dc6975521fcafb2c716fa8393eca8d95e3d5ce756befd666a3f694142af2c1174116df47eca63371f19bffc43536425165928d0b9c9f3fb4730946790ca0c45e279f1d8726f8f74dd7f92f32b72e651485af412d947c10725c8c958df23ccc1e069fbab8fa42141781cc2406c6a6f56488fd63c660664cf319f3dbf3d3c06d2dbc464379f19fc94532e4f85c067ee035179690306b56d1fa1b69a20cf0121c19d7f07bda40c0a52958ebaacfe040faaed93daf4e38c9775f3f4d6aa4ff45d35b52d95e54cd63d4e4fcab419a7cf440c66224ee2f5b402ffbfd2debf9b15ab8aa6c66d900ba0823a8c5c95b0b40ebcb9d4177501dbe90b82d300d7e069ce3d266fa17eb718a5e7369c4fa2d5c4837ec90de9edd5c3c457dc2889a935496b973d3f3449796cb851ddd355e667d8c447d8c526b030a7c22b6ecfec857354ef8e5f10aab6d484fd87cd13fb7d39f71c3affd88e66ca4e75b5ba0313aa8e257560547d9d9051d6a2317c8026bbc1585ee92734d72a5a703890fccc1e4ebf75318b161b135f078810a8bd4646b8a45c90735c1365361b9975b0f00dbc0548c656e750e9f372c576c54fed8cb9570f09d619a33eba0a881534eb0f40fa941a7ee942d89c4e75ac4e45643b9ae96933b2370b53747711f3ef1f0a6f22987fd8acdb20dc82e7b1c750897244e0e0f3de9d1456f327f1fcf3bfa0b0d57645d0bdf9fe809320de247f9076ce5aaa4b207c53512b7b5723ead4486fba5bf15fa929d18d3c21bdede5a9953702ffb0738a081c22cdb3a4931fa3c972db7b4c26484274c55f57646b4281978a892d64c37f6070caca6ef96ceb066db03900bcc9f846236f398da68a0337d4194eaed5473f0bd92da11a6de64f5cee56c5d9a15aad4371605d74d462767039d8f575e51ed960bede0755802e51bcb915c804a4b88aabd48cabb42678168906be8ee7ee376a55268fde74f8802fab624472e7643eb703b5250c70de0685fca6ae07aba1a42cd76870f47813cf36a753808056d4ffd9c7670ae251e1abc43df2403f0ed97b8c952c1f08f6438e1846d1a7cf83b3351eafc160d19bd852f80e693271ef3ede0e19140ea5a56b30c0439279928456bcfa2691891912b157a862a4055bf6ed19db18188d72407ad3e0c1a8303c7b06b8b7a04db4ace8c30cd740a3800913de0c28a6ea7dd8b8c01189f358df49f3ca8b0643d0d8f6d6be545a9d846b1a7859012db49ecb414e9455fe149ab48010891167c3b86967e3bbaa6bedffd847123c4f76286ede98531cc547fe18bf52769172e71363745b467517ef1234147611c6aa429350beca8b515f7302f1382253e7ca9f9611e1812dc9605418e96ddcca2672ac31106b484b8e1188f5bcc312fbdc5d0c964619f2fe77b890a7ad3cbfacb84b72663c9abcfea9c3fb26c081cab89ba90bf434f7a0aa2ea1451c74958b421f7bd808ea0d92bc119a33ffc8ad24df49adad1e44ef559280251e56625c66839b679d2818234938794954b253e4dd8c97660e1377d47a17a7cef9529910bb3a44301e9342185668f48ee9a1b21cb48b56164b4325983c9e2f06d8c9cf21097684c918b622a8f1ae9cbba1ae226c085af30135980e421fa6ecf4bcda6ecffaa0bbbac5df6dccc968c2d2341cb3078c2f9c10b31c1b12d76cacc1fd0bc2f272d9adf6d337dca1efa2c8a87488ccf5dfdfc402a93f3a28b67aac128f997cfcd8df479131fa1c04829463605a17683a2b12b449f567b083c379796a908c2a9d3266e3a6e7ceb707997c9843f3264b4ef50e2734d55b2e93c9835c43ac467bb26a37b89863e98b236c9cffdefc78bc87caa08079ba98ab937908446f97179967ca234f3757b57969b70ca845e00f8cacdd725e3ee1699d8a1d4254b3433b3dd58c24b3a00e0f4f320059f3d9be9bedb87e9109d9e9b5d2ea99a9bcada19b3c2b76ce4f9d9570178e65c346347bfb0349e878bd4cc63fa337ba3be305f2a5c9caf8e57a1043982454ee1b08391eca488f10fd226b08bd2f1828ee8c284a35d1f4eb7d9010911b80aa12c6568378e08516ea4a0f068610b0464557a121117c96ae098cecc7b290cb5a5b27063db78a3111456b50cc8aac76c6bd1fcc4f4afcd3b5a5e734ac7422be0cb4f6bcdaaf08e4a47680ca8b36ce9cb493de3868adebababe72aa5f5888c32dd7e55c7b6ffab69a874bcbef96db12af88e055623a668094890918aa44f3b435b227d6fdde00bc39cb7c9ee4a8209a8b2384459640baa4e04fc6dd64f4120d3a3168f7d118db16a1b9ee2a446604d441cefc7c6e94c3a20faf0eaccbff98481230e23cd0c495c48610463069cef9c1de3ce6528efefa3246af134ae7105df6d5b1b6efcfff261241ff39f818da097ad72f005095e669251934ac2fee292192d61b7f80a1573869a12eb929fa8377189dc00833d2ffe21d4be91b0e40efb516643e897d354e7bb5d51749ff1ef90b4d96918d7ad4aae6514c179df506dbb925d3836eaef45571c0f56e2e7892c9819e873fcd1a4fd6e53d3be23d98cfc4403ead05f33b4a541e268382d9e184fba7b842a2220f3dd02d8c6216044f5ff466d4b41b00e8acd924be019f033d2042f6f270c9b25ea883b16cb8611bcf16a4289dbd3d431d2e2df61647a802498fe5ff2acf8130b6c8c3863b83f88b41327122a604528a3f61c64583d33351946741473e6552d2ef1c2a268a7d0f29a9437b40d34b1439a870c44a4e60c6b7d9052f1fde89e7f1edd69044440c6d9a51d8e4274de5b36552e2dec00d35ced4f7f01a4802645cf4931283be14caee56bd995a8dc5517c01cd3d98e2962843ad5a3ceb93740fe59e2b2d60b7fd399ea59b684b168d837ef844f4662298e37604b5270b0fc5cc396537e6b76b22cd1e6caa116e723b799f4f69d5c5c5bf89eed7fe9fea726223a28476a13e935611f2a7a6d35654bd3357d3c68461d9553cbba98fc21b584137d16ee28e8021e89af3da193c8a77a8a268c35ce2d85cb9928acb92623ca34233957df12accd485d5b92e433b82a5483988837e5e4c87e104665814731c5ccde03f21352a68cb9fc860746fe53c002c2f45362190cb9c903d995ee2b1b6dbecaf5f3db3e049ff7d91ee3ad983031aea0dbc1396497272147fc2c1272cb8ac037618e9f2736e4e994d33e949f041079d64d3714083a427fccc89645257f5ae33a4767b1549cede43e777a31ef01cbc4b01fedacf4360447ff6e18fb22188d50d60a88d8e94906f575c4003d28504e0f12fe33d041588ad5f99495e35f45692490948180329f9c499bdb488d8de8311ed9d6eae8679c6b98735ac99758f2871137221e23db98278370c333968f03eb6fafab1f21690a464d7b7bbe6255e34cb8cf9e562dcb3bf7e8bfd6028345197f1588f715a4cff09c0e7ce63d8ce7a6852adfca641b7839db69ecc88412c244649c6066b9e7882ee6202bbcb5c6e3115bebbd9037cbea421a89f44a19cd6bcd607d11aa61b04776a5f3cbff7a11d877ede9c7b6949d28a64b3f06ff516d40199887a6b98a7db78266bb589944d556b1da84bc37a672dbb69f957a819236a7da22ebce1c6c212cf7b10cd16d4af9e097ffe84ebc2b3ae6b92979bce26f6df646fd8e5b6a54e4bbdfbe9ced6155669e9d7e14cba5644c1555e129330c7c3ad53923351d750eb1162d99d39f097656f52ebd503c1e8ed1f726904e51ea3d86153f27ca425ef8c55398d5ba1dfb3f7833f2b4f059135c019d107ee29f15fdf26a302a753c3ff5973c84fcf79bc53a8ccecd446c8112fe7d8b62fab6e153d71da83f4b24b05f1d8834f76145a47864a2f6777b7734c23d3cfe63c0e5820155ef54eea4a8a2a7fcf3412596ff761cc2b53f4b1d28e5986ae345a21a514e09e5eccc6ce14e975cfe21f9620026a6c4aaa7d0bc85c304193e6f24d9836cebb7544048cc8e3b7cc085c88da86de7d39f290fc6399a08f63bea295ed24642b16ae89f6bc120dadbc90d698808548ad0c1493f09f0ae3820bdc53044e1aabf01bb5c8e3103e6d4623a8ac03b9c8485a292be2442605573efcd3792a30d7b0f6d1db78472c0131c3edc6779fe3d17fb387259c0d9126b7d62d486e4e22c44c43d917ff7518d612248fb2a613066bdb94a9aa3619fd4f5c13c7801830f0917497c1694efe5760b365527b3840647a6f1d5e7617a538d05cc3ffd4320887e6a822024bbd6ce145d44628ff5f105301e2c94e8aae871aa1178761835571706a1694e927171b312e3adf86c510b233656a7b8f03b3eee0d509cfe0ce8f473483f647d484c1f48a8358c0caba1a0ad427018379671f41b395f9a9fce1f686239ccfa5e663a7105c4793355d1be208bc4645be9df9de5c1b2f97ee440a28f41569120e61d33e30bf10dd52d3677dec391496c8ac22c1e77e658766a6a3f5da86970ed4a288578eb462b0c2fa074008fcc5f71afecb40c3c801e07c628daa8f49d61b1d9bb28fa548dc69ce4ab1b1b236f087ebea74e863c0b59ad82e05b7adbda453fc5953d92ce786589ac69b5c382ab486bfcf06f95256d21df7dae24eddbc7eb559740daaf875d6a894d992d514499ef3a3249268de22e35e4c0be1c6be4d1129a31d5fd5d9f4f5c8d992666ce3a75fda0801d1463b4b840940234dfb3ef15983ca3d71f118946f583ef826e272e982236ebf4e44ae3120027e5838b0f198888a5c2067608c5c24ef2761f01770e16ad3360fb2ed8212254ae5ea3cbfde6413dd88f3f9a0eda0b66a131d4cdab94696dbc5f258eb75c45dca7de723703d23469d9247883b8a029738da1568dc208b657a41ea9d292a0d53c89c593ee02f71f817cb6f505ab7c6b74e4418e28f08f321085749ede5634b6c15bc941407dba585988874761fb95aac719e0d6cfd61adb3aad1425ae73e6a67fc721796137d0ae70c92475176e6a90086c78f05c5f75767833eb0d6d091c053ede53bd144cb7996efec6eb0103f1b8b809c30555aac2e8c2056df1eb6976616d90fb2db9ce6303e59060fb1a70c46734a7fa827e9c692753e6d60d00b7bc573399b5a06dd8e50c15124f6a5fe9d10f234808e37c5191afbdf9da632ddf31d8c2d6295f32abbeb158051524eaaa8475627062f919af3a473b0788d9f510ce1b91f0469961cbcda562f94ff6e5297e9531319cd60c96a2eb0335e9cecb96ffd17b270cb5acbd92419c0981a2880738a84d996356ebf7e5e97979fe7289491cae69460c781047bbcb5512397610d4aa76f355f0da9a86f936268c761daec2e1ded1d781959c34a2fc1f0d77b93368f156da0800dcb5e859a451cab66be0c1e10275dd833d6c40590db325270f2346f12144e16e81e14fb5ac37cee19424339130520f6929636e7a09f49704ee1f8154efc53180290990cbfd0c1b7255470b496a7e7a83493948f5e54b1d2b38873e918d84088afd28469f6caf5648529ccd0dfb82abc3602a5448f47212f9005b09f2f713e81483f88ab0dfa25e50c9ca4536501f11dcd2aff9eea3bb9cbf7fd1fa4085d41f4ba5d0d06fa00437433031719f41d84960c909e713c1714ce55e005e382cb4450793a6ea79064ad1170b611f9b582c2e60118c4f2f79d6ae10bbfcb2a4c00a9eaf3e5c0f0c8c2781c53480b57da717de100ee269b516ffa320b8e34b5703e7fd2af9e401e70010a1133173c4399b0a6e956891b9aa4741c22438bd7a8881c19940e1b1621977f66e868548f41e55bbb0e1a88644b6e17a1719a5b25bcae06421bb7638433d2a295d05e1cdf8042604200d7ccb086b49030c08bd69139f4540e4b0e09f0acff418f2ae79d8eae600be3d790b23de3ca78e848bcc61d21a80fed22a4d363a7f408074cf0a6ab8116a9a4ba5328120453cfa3c88fa1fe0b68ba8379bbeff2a4df9c4bbdc7e2c9a58a1f1f005e138e0afa801d809d9b06096f86722b6becb1bdd89c5457b4e26fa9395a56f248ea6924aa349941509205a38a1a94fa598171ab4e5be95c985b844101ee4e7cc197980ba8cfaab74eff27992923cb8d7cf28a3177b97960f7df85dd98cdee02b8ae1268883a08aa1ec0d840f5649d57ff79b6414a9bdb8bd955281089eb31890083f82390a5d29b28e87461ed2785588a8424a2ed6c1c04864d7da71a9a996b0507f732a929743c2e1b87adc3b7adcb78e04f45c2251c0ca37ee40895f9645fcd97fc8b241cabcfb768c4dc20b12cc4cc8c337481a3f646743febe7ee47e54a740288b9c78b1252e84dc88c4914f7b4a513fce3f19dd6bf2fe688c43157f1c1ebdcb57c57ffca2f027ea1c8d434f4519433e8e30e92b1188077ee0f2b30c5e70f2946c4d67e2ea4383c6a464a198fc4e0e1ddf89076645969f835a01560dd9dacbdc917564bd000ab3cdc53c5908dd1c53ae8f40a43c989d90855fce653d3b21c3c60947d6146844aa6996723f196f9e3290ae5215db1508bd792f3991905ffaf72cdcdf2021a90b32fa5df92683bcfe87045765f1e4de188ce1db82c0da01ed6df565315e5bebbd0288afb93febee73a30775c5d6b5660ca249d852aa02259d1a981dacaeb5fa3880cb1960bcf59dd1f394f38e98df4b43e719827ccda538810d84400658ab04d77023f3a49a14a5394c5ce77508fc7db17fce9e2a9f5172643fa2119e1a4024b1f95cc5e3d79958a2320b4160fd02ebafee504fb5b6a77455d4b886ce8639976ee5f79b61b965161887a2263613d7bc26e6ac4a542868e3c8437628f1de687d8d1adf37bf7567d7ad545354b79de2425f1a53c736783b7156104e10b20e95259616a322b9f3b3ec03e1eb969bff239dea6bbe1b16ec69d04c8df07513d9133e017fcedf968d875a13e997ec98a1d131a983c3622c50ba2056dce713611be890434fdeb9f681264f6cab2a5c0f37ae759021df88baed52282cfe620a43a6c7abdf3fc8fd9879a2bac0bf430d03267831d1d2f74a6d003725700ec38b640e18b46b93994b80c18340039bfc3582e22d59c6e97090bef03d5368dd92addc6be04d178c9341d34c669ee10e9905a098220fab54018fe689323243d355e033d1f919af26037690f502949a002171c04702f2479b375a3e02b8cff6233450497abd5494bfd1dbd561fd95f63584517a785640932bf14b3a825d60bafe6f2bcf65e9813e39ea142c106ca410363494fb7af56d97d21b45312ee75401445cbcf552d449b085531a572a0347542126d8b574eb783d64de2e1cb80c37a5d4a08f1953b00f2c66e567c3a19aa82aabab7c35982d512e2926c15ffdcad28b69040738275554da33bccd2ef25c94b1360debbcb182f7c2070729167691b909b0031757a70b72fa6ca1ba55ca72959e940a0ee01d33ba2e3c9ebc5411e5d8efc7f01a8485a964768a5b185328ce9d3e34af47e6d6107a2e0107474629bb9d25881d7882f62a39e287b7e304d1114345e8a598e303094a355519dccc0151e4e5bf45a81fdc0e3c5938e44f2a979fd080bbb6950f6b96aebf972308d30e8dd9ff78064132b460e7a36be9fa1ebef6286246a9fb4689893a81d413609e3ac7c76f4a725a884c1b79800fe2278ed88e3ee39df75f56ab99e7984c7564f15c294ffe48986e110f72541e0c35c9e3430ca05c9a36f84057cc172ae367b6ab20b7dc587103374e64a9f63927beeff4fab8b827241cb8ff6a9fc1b2fb2694d6e6d36b7fd9823a11b22059c98afb7b7643e99d993660b31597db6222b88637f675f6ec2f6de765c1788597f3c5d965fcba777dda7c2bb1fd01e7e8b711dd3ca679d0da46692649116e867b5f676b0e342211f8c5fba33211e8988fd67db5ff9de6ea9d670750b2da35860fbe7dbe54eddcf77d923f6e6164fbe4857c4e1a0726400f748de3b25017098c78ec65026c3a6ade201f3a90cf7393d3fdbdf223930ee880c885b68206835ff30329e2ac9768acc7cb4d28b4bcbf3512b19d43747a0cdee36206217c13e45fb3da3dcd3d92a4355db05eef1d6d858adf7be9414a6a801e34470bd9cbe6f371e689a6410fe343e68345bdf9993ee0126881cd6f414617561605f22c96fb0d70379799e31289aeef59fe27c7e5e55fa7974b5839ae20fab1f3b56f62a8e0e8a77c7ec95c1b1b152c9d4950ae7781c9b4877f0d5dc8c2ac3b747679faa6f1b7ab48fc470d18e4ceed99f6dc5b6b4c5548d2495c9e63a255cdc8250d4ba3781db19df4140115be8a465e195a8cfb0d1ad5df97ffbf0d89200cc47a7e6be394bc3844c07e78e8b8550ea8db503b89a21b1d993c7ce94e683bbca5f3fbd15192b7f1e6081dff817261794dfc29fb33a64ff4c6be8cc1d21afe1ae335f2bbbbea235b7b5ad57389638fd93a2a54af97ff63631e7ef885172f1c1d409772919ddececb4649bc7a6fee3faea250a397643484a9845848821222a7000a768f8db19b047a5ebd30deac7e62999074a8a2dbb3567f2b419bacebe2c405e0d05afe82ff64093d2509416cfbff4b5e9db8a28fcd91b02cd8888b5de37947373807dffb94ba7717daef96a00a0053b906be1f6e4d6a4834b40441c7959ff60416be9226912a41fc34629808a0aeefd921a3b3610899138b167aa7dea309c66ad64bb1726182f4d8a9f5e68af82118430a60bcce1b138d7e30e36395f7e7988c3a14218d4759598ddc88056c9a227b5dc82273632575ffa0b41aeda45457db6cd4e7165f5c381dfd87ca138cca7b33a96edbbcbbe9c6b7c1f2963326b43adb29dc9e0a6b9be1a2c710744beb4f9caea1212505a7072e8607cee274ba75d42a7bf3b73a52fa46c107012950c386121086599e5c86a60ec2530ede02612bfd825191f26edb4efb7cc54b6db8e607671384fe57ae627a05994d52d71ddffa9a90c94ff542a53d4627827b189d9996511e520221744beeeae4617420011affe5283bdf7ef585fdcd715398a94788db6ed193a48495ee3b7f797881ad1e8f42b5bf27e1d426c32dbd770448e732a63756181c3649809851a72ac8b5521a43692ed3a6779d21e99ed64213bb5f3980d17552f5ee1d42a444f44351a82c4b12cf52aeff4ac972ef7214165cd76c860f5446827e8b9442bb960f21ceeb970ca51913ffd89163eec7dfcb344ecd852c2295ca153f205d9bc2742e0d1173fdb0500edf49407c0e70575fcc2733fb7619bd8a3a726d7d4e3b161529df5f4159b792ae5da8b28dbe2ba21a3e885ba3d450826bb0d34ec50867d92ec7eb608c5c8c61798f239b96f67149ece0287ddc85f9e13964f84d39a7b15ddc76edcf133e58db40c1ccd9f2c04865dba515c14cee185882016398cf44ad48389ac99670a4022e1f3bddb16d48362fd87d729491903c398133df282bfa95a525809a0fd7f3cca6273141eb2325ba9d1d06062f2172c3f69fbaf2cf0e3c09a8f96c4678b124ec282a710e8ce3453cac9f5e7ee5cbcd63796ad0fc3c7eb2c5b2153ca90f156a4ed5136b9fd6e1104b13822d918d3d8d16620a2e9d4ba034afcb64c3cb155168c20e91721d0587e86d7b8b29a48c3435522b09cf49427bd347345cce30d695e3855c20ecbf4a906b8cc6f847d073bba4a7b5a9f40ac4251cd7e959710073a10d7af3abedaa9938498169287bffc4edc0fb507e8d79de09d6ac70e5842fdb66c2568541bd4515b0cf9c4e0514cfce6d2752f4b2c9ac0e2a567b500","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
