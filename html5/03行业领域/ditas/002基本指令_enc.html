<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0993b5c9cebbc68385aa7fdaa400bc5bc0d548a956b6592081ff320e4e3c3a77882dd2c3c761994f3a2475c24198b9cd8bbb1dc8a754672741d55d9126a79395241f3386d62d9866cbe4d8068ca823be0ef9def7dede554c2da83a97edd02843d4a62178302f6d5626680bc64f1de62b3af99108b3045eafe3c0bd197aa51984ea7e9c07b5a02718d6a83ee9288d234f18dd149eca40e52c32efb92067c225d9e7e4b3513336c16e10c08b42c5e1e464133262bae2660206d5991701d6a7187a2c971293eae928fc6c9e26fa74b7c6b99b316a97f03e6afef7483d21b7360729bb8b764da91966349d75e90f750283012af365b0a3c0298da3aeeba7ebac33e106dec24083a53450eab2020f481e75bc5c45b7ac6fefc4a689be01c083bb9c6fa35038bbf5275f5cba92a1a44b141f09d5446b156edf9ef07134c3648bebace85ac8e22708f68a4b8f9bda893fd4fa4b111a10735e0b189aa5361844e6d633ba37d89e5ccfb1292432a8439e9a131464493afb9266b667ccbb0e74b5962bc4748c7b122953e14634c85e7b88b413250b55342f2e1fe5dd87a75db666b1bc3c55deadda7342bfc252e7caa9a3ec02ae7a5d2236a49192de4cf34ef1e2ec0c51f77085787aa3d51bb84e2fbfdd2f199a9babb8ca204a5a51ba6387a657fdd7e214a904f95ccc1c0cf18fcc1c9ea84726d8e543c7077531560ad2e92bcde5fbe383ed58f0ac99bd8e03f981b9ad3c08f1c7c5cf97464a181cf8b78e0f6a5e40e96cc6539dbf41d4df3f2da11346049ae7cadba6124ec6f0d9a236baf0fa522053c546867024f9009a572bd2aa5d972af13000498df590b1fda80770d3ae9584eb52b7c153a549f8e4896ff01df42ec1aca748ddcaef485b7d1105731c0e34e58cbec59e9d4e923648a6afd639008887fd7025394e53cd45379635f00b146d833aab4250e586b087435a0000f3d7904267bc20ecfcad0880e8a5c9963adfb11ff18ce2b03b47caa31f9441ee3586bbe593950e036f46298421d20d3a1021ae4b346eda10c2cdad41b064c71bca5e029bf888f412d749c1fff10f8e0e60ede45c72690478292b916673c9b5c145d5f550b7408a897cc0ebc194cd8691d17fb1fa16915c13de108bf1d3d3b27ddf6f99b8126627e23b68ff2d4b3c20bafc0a03fd06a4eb331ba1970e28e441318ffb34e51939962afb9380232b26a18e52dd3ed1f3b92ae86ded0e0ba6eb23cfc9dfcf13d1a2d1b759e4012a521d9ae299da0d57e9b5260df533f24971d361f7b391da11d722c9028cf45fdbeb6ab26eb22dfc8287b8735bf5aa8a3d67020226385898d03233a2d72c33778b6ff82378cb0f6a8e32e35c1d0d0de37acbc99d62242e593804fe5d0a043b72043c669bfdea39d6f88719eb9ead49a631349400a097155258b61821a13686499b7e19b67db5eb933fd3d37dd1a7ab2a3540bf8d61a4bebf49cf00917858cc6c49b12e3e947d8b6804c3ae5c85e33f06deed3a50a713ec8a004b3ac0f72562c18a941293e9a1e15eb3c382bb2a8119a4ac97fc023ddb6c84a691023c19260521ab18c1bf76f776314f193bb2ffb97fadf1fa9121991c9ed598a55930d57e706bad1878e968093c11f092e22a847cb06972294d5b9a5c4468f27b41cdbf42c2183ac1f2dbe241a3ec6a07d60a9aebc81ee6ec525eb95a7bb931bdd5a2b601569f93eb9c38a79419b2bf58cd67dd089feca35a475b3a5a4661b44fe29ed77fa9efa8329c8c25085ad6069154cec7902b4585b31f00f985573a82fab7b17ede049707faf41c5cb5510e2a9c93a06748f2ab12cf082e10451e2d2eca591cabadbfc963ad388b2aeeb24670d2584aa8f70af16c3969acb4d485c5839180e772bc5e884b3a0eb0a8045f1327816ac9a8899ae76bed6fc4b4ccc4ab641e466c89e7706c6236a81d5c43b3a63010111b3621ffd7a86df4728928001cb44fcd3a02ffddce08484a10ae1e6de217affd6c07303e42cf0a79ffe19a41d0e6087741f0fafbdfa0ab17e5f3abb7f859c6198590bb8a5753d9066059b4a35d1c5951399673e020f9495dbf8495ccb381498bd2d0d98f095b91cf3dc84e03907685fd5ef25da246ac659ff3866d7b0f5986d254495c9650560e311dec2eb5aa3a69470fe2f00913a004f5733fffd306b15f76d5ec22d087c39ae19bacb66a882898e665acb07fdeee5b0de40aa1d328e19feff256561b935b432edcac780e277b4254b678b3f9e7bfcfe0676a977658992c8703d68dfc11b8affd5177e44d2307562364eaf43a290df73a33ae85b9422fb1a84581695b292e156684e35ff445602acce9e6e0b85844e6d893805a9e2680b18284b6d6c34d1b3212b5157a1350aca5c124e298fe698f3e01aed723f390e2d889cd18be7b5fe3db458f2612af0fd95ae3c8fb7393747e0e16f1c388cd69bf1c7471e09d46f7989efeac02e491845014ca32c396c8d2fa44298b656f701d1e428e458f034b81a6f8e6248770cf6b512844b474cd1c87ba41ac1b6e3cbf4bdeea19de0d6ab87211855afecdcfff0d90cfb1c652a4fb4b08d18584450df108a6e8e165f04f5cd423520ae565cd729f96fc3c67f6b3f8944d6d96cf99837a47ae86da21f13347e6048a00b94c3e5be62a4ce1362c5407019152ffc366b81607b21c14c7de35ad19a6f2860916347780e7f665d663a14df92c5ebf45b8c7c6fe5e83f67a84f429a28844e8785dc638fb895fc7fd34bf99352b9c544b5b707c8022bbf4c7fa270cbdf8576a13aafdce53ad670de84579b74918ee09c4d26e4c5b029642e3a52d0238e46e65d55e20c927fc47c3db95e3c1883f52a5173409fc240ee108f30ce36708cb99b1874036596b37b238966ba8f27e7d27e4cffb804ddac4823a554138170ce6767afccb87a88e29013c1763b1353a9cc20bf040c24a245ef8d5b0b22aae7baf40722163f539d324b9e1bd02425986396b72c23cc8b11bdac0ab4e5ff057b7679cb5f23ba4b83c863f8ecd64478bf6dc64b2f56a7537d11aafc518a2745ddc63193d05da3fdeefc5e8762e86a1d8ed16a8648b70f7ad6a1cb549cdda0ebc75388ee2efc5ea66440756f82fe833758ffc2bd61be32180524170bf3b3058ef69a1f943e96bb9a4ef0101d4c60e5642bbe7912a778690ed1c69d6a4c1afc4635dfa6a9e3477b194654fbc3449be2822e20f3b15bba1d7c387930c25b457c896e242db8631b2d5cf7b14a95440e48079cd317de08ace8f67343df36ea9b2e5a29d8a3538c36ec12acfe5faee5723e869ae213c765c7d4a016e1a40539ac0681d4ab79066e719d3c98318a46e531405e7cc6206302cb928075c04cd6e6339ab2bb9eef7ebd837eed326664f0e90e9f9391f1cd0f0720d80900fd9f448464640b881dbb8c4677e70436d1a7b89fedc85eec8c335bfd23d588ccccac9ec2001e1004da1eaac67ad169d9435a40fbd01c0b4def8b31669287711cd0a064f5ce797c4eebfb98524ab1d1d1cd8b607d5d476a6996d52114e2875b41b4bf6a1fcc2aca21808ec466d9c6203b1cf7f96fc63f61fb0bb1b2cf2a340c5fef8919f2dc75834b6050066e531f3ace7ef97136b690ff4278d8378b2983c6366522a4b7fa782f5013875cad99ee4d72ffb5f8f43b7c0a80531b2c87691660481374cf4b09fa31e76e2ffc4dc2dfb83b58b7ed1c569ad8439824155b29323dc41e200ace0210fa4150f68e9791c965dda9ba8786a01e8499900a774db9f7287f5fc213a743dd276bd5128108ae8f318ebd32e48d0900717f7a9b5276ee0226b25520a73310df593cb557992bb6a4e02c8b2bfda9f2322d63b8b9756b2e9af731d777baaacee465de7702234254e2ba98b3cfc96c8a76fc2265d876ac8c9748337bc0e6d8d42340c357e116f9986e5b84aeff32676912ca83f4683062120dd027711556a3ccffd5ab2066bf91599010ac08533c0c6b1a67dd99e19fd5f031b83fece51fd5f7da8aaf9980b6c8b515db70a26fe2a8bea9d54325f67bd0b514635b51239bc3ddf921c089f0c31f1835b31d6ec989c7149d64613492f88bdd6934c004e03d5eaa2672fd96ea4b21c18714f5158bb5ffb34d7387cadce8ab33c81e13cdcb72527f9aba21631a405e0b44c69f29ad624c6c3fe8b115874d7b8389539dc2d8b6fdbfbf42f84b1a727f1eaa2453a4c4f22ccc4c8fc11ad96437128711d4692f88374aecdf624473c8ba387c1bdd8859aa69b930adfe9bc9446e5b6c89dc7bacefa5c486006054860b7ac5d7b5412c635757fa065f39c9350c4fc748d2f744b43cc257a2a60cabf6b6d7923dba01ca178b0e1daa150067e368e9428eafe381543b450c9b0fc981e476f0fff690cf12ce802923c102918f0c6a9fcf88783bda38dba7607b9040c3b2847bf07cfa201b1a36b94724881bb311d6d74f4e74816b7431892d4d2af4f6b8c1ac757f2ec10ba37ce3f56f9fcf5117a134f7e96e447c6648293c985eee9595afcc07128b6d46eb636843a407ffb54d65ad3ed45efa8d269a18249b653aca717e2fb0f8d03400789dd41ff31db08f6adde362528deeb359c3d4368f3ad3d795e502c0635869b27c327db065ddd9a8956766b5b36d3d81ecd4413b7dc4b938946f6c9bb5a56048911b01cfd5097cc404f53290aea3561145a247d962377dd273ee922f07af3c47679c0515c5cc721bf4b7dc020fc98c3a25a9dfe15e1ba7418f61e6e3c812255fb27072c08552082d8827c7507e2c543eebf41d7658604056c045826a3b61f90a59d9b044badfe67cc93f84547af8e68b5e6485eac7d3edfc2e18f33b759fcc078c0e2987e71bc2470c1529e6e0e961abcf1c93cd2b62baafd0af8f1b3f4ea34c7d74c34c53ca4d3126ed08b2fe377fecc253b2148aaeaa36919167fc6d9e3666f69b875b86c21da1269648328c398d73b09f5e5b2dc7e1b61d3004fe1f58ac531e2e449a9ec2233c315534969536e806ae4a5b5cee65affd91c97730b895b31a1b2b2d9c6e96eaa705067869700ecd995a5d4953c82cf678c9c192666911d172b6ac0a58c7f7fd0300227a87e0470423bfce0b1c740fce52036fa1af3e1dcd17341f4a0b94a0624db538b19a3c5e10fc0d6f4821d68951e4f6303c16bedf7883ebf6be31b9bbc6353ef36e85c50e3d42057f6d6edf53a1e76ee5dc6570ba53f22e9a377437d738e1f3d22f864c059a358505f066a85b21444ef3e53de286fe32de060801de5cdfd6c8cb88040aa259b932346fcc31621994f60bed9e450edd8d1001814ce0c1dbf20b02bcc4fbc0b6340c52c39f0cd1acfabe2c84b511a1b37bc1805518ccc2591e962083a9d2ae87ba22bc5cbbcaad21893cea9e3f14b46b0f99d118349118638888a776df54ceefae01e3f57826b78010d0bf1ae268d6245e21f98292d544b91e18684e8c19f6ec1fd347e3d781472d22c2de0ac3d09755f727edc38de136d89e30e3da175d03f542302a04172cf49d6db95865275378b9a7c21097118c0ee31071fc712a9f2e56f4948de7d4e9ac54c55c07583e36217a76415ad6d2078ef0986781c69a14e959aaf6fedc21740dc727ff42cef41c20055023b8dee514c04f0840da3c2a19ebee0fe0a220bdd18f2a2f71c0d53c3a6eca19aa32c90333f34fac3e45bdaf594c1f97b1a5bba7734d70caead8287944b99c02e2bf8923d7655dcf10b139fd015f165a5708a0a0f5905ab9b13e5589748d0b362d21b0d15bbd01e8c2bdf4e64099b2cd4d73110c0f9268cf9b56f8f704734274ee793d5dc988b742ad596e7e2bdd62d1f3f9a2e49f5146a1f7c442cfaa5e55f28ff9b22de17928055a64e79eff0f8622adfc675bf21a68fa4d1e47cf40647a5ec0a746e98a59c058ce954f5eade1b0252f799534a5c858ed24e8eaf7f2e94895e539bd50309a74bea6c5c3d9baec6c9a2660be174a0f93ae07b7eb8199b1bdb540fd0f3499c48b90ffc461ecd8b3a6dca6d6247511b7e878e86436268067edd48a460f7c6dd3e2f7a3632954876340775286ed5ea0b4773bb0197ffc14d28f30d687480cc779f02ef5c20bcda444e6d198967223b21f12892ed03f46f9d2417420aea9fb79c7239071956b3323ff6eb51b3a885a2dc09d48411f937afdbc309c6e0cec2b0598ebcce99eabeb3489496309795dd499c7e14742f1d57521a730ec429116f9f7c7876c4e48bf7fd6871cb4f06cc9069ccda0233dbde717a43d92fbdb63517f007ec49abfb3d9fa2f70d382c9d25e15a97716eaec83d651faf14d9d471002eea0d93fb328605785c7fc69d4b4e9f88ad3fc7d46d310816f94d6f04a1bf7ca3478510362fa64ab6f7da16fb8c3f3d83696af40be70176b06c8107779a23886ec49c33616b3bcb4cfbcf9247463fb0923879c44632f66298d7d015ddaecf37fa912375ce6418a1c6c29ab44fd81e5a8cf08ae610dfdff6a0cc7f17bd1309dd1e5172565541f09ee153907fc63fba41f7940a654ed377962882a30c2020458fee197cd0286071edbb585f087e0c2ca87b057ce4b314eea2f7e6f2a4891b62fb609ccb9117cfafdf2b8acd595878687474109ad57ba76384b5fdd2836fb557f43ef68cfa9b0c6f0774d0e702dd03ed80b1f4daa2e223be45b9670b95f752d98400ad5a7188f43f8eb5aeff6a895c4965765520a13c80d50e7a64819395c8e73a16fc1c6247414d8816e97ad5ebc9f3e936da1eb7002a8656d42c275d42f35bd82c46b9c357a56aa9444b1b6b234d1ff90399e490a52dcd278e9ac3d7975f84059e01e64426ba59ca88ab4c186c4cca9d7f5710613b7e849a89a5d128dbb9c9e07422c15facc7bfdd069248177a8e58acaa2f086c24fccc321df001e6b23deb726d77587f03de16d720294f7ec11df26c273c9fda1a1faf1ffd6b5a09d28a59db459020d84b575ea1cf86df6bbcfa05a2ff887415df7b758299117d5f0b5bf3e680bd9c88bc3dc96bb625f2aee89c5d462da6ee069da84f615898c5018d4f85405bdfbb4329d9280bbb151e501ba7560cf30cf5fdc05b91b80e2300ef618a384d4eac785909f104e320be7190b0c113ac104a1ed51c6a8d2ab057a4965733c4f8ba55fc440a324759cb4098fa91a69b0852b3d4d8e908fdf0caf90df870680fcbfec1760c71ffa1677b5da0a1a26216c75155df41da36e1034fc6e14149e9ca2afc9ff0a3a81f6fbc4d0e8907b1877276ac9d3f622752b2084d901a80ea6e9874b2f49449d5d105163426ce3f4b2094975efbaa763bc597a26d214c881bae5b2a0d7e927c17601638cde3da6f4c6127e7a59bfc4740b6a934a1be685e122208b10d13d1c6a1e8777563f2701cc3730c376edad2fa3b470d15692adfbe6dd6e2284fb48b53c58da1b0cd9e0de0f2da387f283755f161d53f7ebdb62563919510fa23e34c1c7133d2ee2317ec66c7bfd39b74f4c4147595273e846e4785985b17daf906d2e0cad1839aefef85b2c812af8870e0f76b82d49b2f001a6e9a8576be3e359825bd49fb23449e90b3023cedbf243e36e8d9679ac39a914b21e3f666cf98ca48f2599e6b84d639c4329fd84b966fa0abf0985dd9bb7852d545d0953b308de1f0c0011cd85d7f77672fe0ab561a2719c5688b09fd01a2fabddb38134067c4e5f314fd9f2b82fefb6e9827b966927df67a45d9226f179f5e41aa65c58ba460a03ca2ca7f64c59f29ad439f0c2e601f796b9e697f4d95e3c06a21f400c708ee6b5769c4745631ca9c4a65dd95b97c9137bf90c28108ff671141930421eb4ee967a8c3b7b78c4d58c8826a73f3c0bb16e11c0776d1acb5c80d12dbb930dd6e4850ce1bb460cb510544768c8f5ced51b8dc6768237023a80aa535f470f5408bbc446022925cba460eaa2d075b2501fe17c037ecdfb3a9d7a38beea0047b636a918a2a6b5e99d65d9dde8d0d2f4be947a912116b55771dff5d778b3c586e34cb2db3e5b9b523aa110e4e5ce4dedb8d28051bab0b28e167aa25fd6b60a751c7455c753fed57ffcb91316efc9161debd8a70db862402466d13e5f429fe378c1231fe0ce93b2f162015393cafc1b113af2dd8cf74add075081283af02493428eec5642caf8e10a7b7de25dc8ebfe5e01c90cec4cbef50196aa2ffc6af19ccec11950021a45e744b10b9909e0a5d1eb8903493471cb6751f8362a81c3db2845b059c3418b93f6beebce45459822938bfa9f0a3bea4196f8ca522f36dc8e2908ff34adfa268c3c03dc52266c9303b59deb5145afa032806d02d3801ef5fd6614949d6517b37e0bddd1e73e3edc5804e1ee36869a276f1a0107bc3f7a81df922a7e3476fabdb850e6ef27a28dd7b584398ecadf1c08cd1e048eaa82f6aeffc9b67cdcb6f32459d19b112f55775760f0a0250eecb99b930a58e87ca142f25fe544480cc7e10f0d44927b47b05ef63ee4f9b2224d6556d0fe4f9df16a56a307fa405a098f5171acd9ed7e71b4cda458462fb31ab4c27636977fb023050b0151e8c2a7db586b6493281e10d2e388a64266f1f6cada5dd788567208dad7467e9a79321406ec443747b61df05047a754082eb7b677b0b839fc37717baa8ea4509443e31aa5282ea4140c71d8463f410809972ae7ca81434dc657d7b2c709bf3895009a3b3df60ab392e0a57630f088200026233bd86f77a5973fc8c0a619f720d9e25714e02fc8de63709993a589df31834068e3d5ce415c00ffceaeffdb9bd58231e563ee159ca2012277a9a99e59a2d0df07372d64b3e164e53af4e579b750836d57cdcc00bdba153ce8d51ba4ccb67ca47c41e278121551a3b06b5022885d4202e061ad4def7de8a54fe17d84100d3412ab1f569a125cc8acf46e93c3d136691606cf7578a289a6efefaaee08a48dca2646280b2d57be55d45de6abcf3597e5ce12d4ca085cf2552b8518c536e2f11e260980cbeb28959aadd564cb7afe9c5a9f9a93610eb30f5e20313c696d2da8e981c495512a941403cf04bd4c96a9941d9852ac51b42a9d349d050db8390ee4048b4b2f50153d735e615d6a4fb239857a63695cf0cd2b4a4147c676abe1cc6811e18b4e099df93dc874e5c262d9e392344d9c4cdab6501b30b337c5e9a86c5bf3a4a167e9c13b16b251b76110b80c347f07777b0322ee712adecd421e332a2ae108f5407daab4d7a9af112e2b0d92d222b3cc190c957bc79e7eda6810141d250621c68b10c966ecb36b172b0f2feb16d80c85698e8f49f5b398df0db10d0ad78baa9cc3753c07c23dbbe79a9692b9f156206a68c2546345a3f9dc3c9ed0e980172d84ad3d47f8cbff0af45ef961bde541663956732e5451824b7d516e25e66c9a76e885f824b34e3580295b52cad631dd472aa27d96fdace762059ac68aa9fa7c17ce24a84ee916d55296c4f7b6faf0cd6def2502e6dcca0262f41f68f66cc30e5182d8fe74b66dc7ff3ef81f7b85f8f762daf20a60b1764fd670590b0569d4d65ccc70c29c2ad463abd1abe6c34571f58a513fa1a4dba780eecab033237c712c0a6439c0bec127d3e808d71646a4c9ef7f7b3a026f6d58a53e52cef4bdea301d03be2a20ea81300e1e6f7621f4a2249ad98a4a153317e53e5f4ff52023e5ebc1732d192143f6a9d73b1667c3811b5b3b8fa6ce51d4817ec09923fd163552cff4b5420f627946b9a39d38af4e23814891bc210c9a96040f8e62e20db930d7c8f2824fdca54bd6a5c7b579d4753271c7e2325704085dd62179d17c605d7fa05d6a758d9c3da9da158cbd63f399141ec0c1619d1059c3e20aed8933fa9501e8603b78a5836703fa26cf80ecaca322185b0e1c0ad2288dcffc46128a22223181fbd75733c80ab13aad41f29cc63fb2be6f327f9c8bce105922b56f40cb53041a13ffbed5cccdf1aada66894dc80852a5904e2a2563e996dd703161ef51acd7385d26f30cc421de9a349686fdc5a2f715aaaa1ed96c1110b89e9ca5cc292f0f6faf599b1e63f48b8e7cd8d9fcd1f8cd91366646ed23fbe92aad609971c82f161e9ba8773b941557b25d2fa66cb7eace0a72d8a3230f87f4f9be9b789fd317513c4c1b1ff0148c44d64f3e1d76b9a0421be6d44fc7dbd5b4df46c2ad5d83cc5444b590bca53f1e0cd2775134d5abdd1fd1df604a1dc88619bc44814a0213983b131631a624157e3989682f962aef80b7e8d34557aeb029c12adcf46687b5476cf4ad2b0ffcf09dd150d8da0f25642d059a2ad4b89e546586c9005dac30ff8425719fc7a12695331a7745e4f6eded466167dedb9d1c6b5998bcbf7e28c39de0a641c74c99b0214d1c3625ceb8279a52ee801f00fc0db28d391811250289e5cf57136a1cdaebc966d576750520bc3e8014fb0176dc3a06d4d14b38d53a83f9d193f0a842e912c445a3d8a96fdbf822595cc7996a9fe445cdc692b24906eaf38877b9a8a920eaed5d0a115b0c538ad761b8ef12c38c739be88fbecb21db3494a2638e3cb7fda138434cd1e8e49b9eb176625e6115d1e9bcf26e730c8a9aa6584df941ef5a82e7d74421172e0669b63139e6c947925cc6de968418b199f193a436013e65a0fd19fcd1a9a72a65a0f07055654406578d60915961a2b157eed5f4c8e4879d4febfb00c3b1610c7604cc3c18e1579238d49c7821f255bd152ab2ff4dbbe88f52f970f37879a23d80129abeed91a4c00af177afd29bdbabff98b69402e762ea0652e98f96f903acb0c84484ef08265259e2b335f44826fc771d8f415c0590f4acb0357d43e01d4100ca07f397f38686e1a3b2c1794b6272ba40cb69f509665d0ac6f71f2462d079dd7b64539e0662cb78f2db480367870f18d46c77d2f8e6a901a78ca5c95c7f4ff5118630653d2ca6cdf67b8b21febcc749d5b345fedc8f4cb5c7fb21fd553e5b2d4e3d3db9075661195f4a868ea331b73aed8c9d73e9c51d39873ba864c6ada0ec67735c5167ab40d5cdf9abd37aa20ec128c4d01e6426695b22f273c982c19932954f22f5729cd2bd7d1d9e8998e50056dc2927b738b86cfec23e35e76d78b1c128e8d2a8c70c2fdb8f79e508fc00b2c8da424411f79d59426c7509f07247cb3d06cc5ca778e6e34912c3b40c1ed2e36977010c0b32878593f7a2b4e299ff428976dc0a2b3b1a57033544387889aec65e30fa1f22db3a177c8d4d488d289d0926ac1dd0e6b871cdcc7c01737205a0e2eda8d9eeff17b136ec3c52b2f4f3d1086279c615b8e7f572d62f6612309eeb55b787f007a50fab4b07b69f6a3aaa3d94237206dd6aa9188e7a6d441ba1c58c822d2839fa4f49fa7de85ac2ad12eca4a380ea3756f78f4ccc5344c5e4dd3b907b3266023f0f04fd4ecff2f699e3fedbabca0f67a7e70a905969ae678ed69f4884cd4816d76e89451f848122bda569fa9faf8b44212085c6f94fd91cf55123cba3c48a7fb0d574fd218a46ec9bc5fb7540b1a58c37a2c3d80b50356a506f293877548a5c1e22ab82cfc26d7bc6dd9fc764ba2fdfc867be4f00229edecd5f044c5ae53905b58ce1d8f2d886ead59b3c7a30a34b51f30be871c2619a7272d0bc25dfb311637996e19a25c4c7a193b37d721ac0ea7f4f00e90c0f3e1350ad6286838d18b35019707d5e11272e1d3550e71","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
