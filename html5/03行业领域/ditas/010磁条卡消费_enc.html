<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e5bcef4c8c0f93dab2683768b3d31269ca1c9e4f7b071eb48206523f20cec95f6698f7408d993e8622be347ac0d2170616b45d453238d4d2d426efeb57ae3048e52f6d89a03646787e896b7a8d6e8e5005994f313b0b677be14013072e7dddc7150a2afe6d0af9d26e5c7772a0eac9416b465e7e0b0f3052da9831e5d97bac70f9d13ae97e2d5d6b5ef7c7d26fad7951f2dbeb9c4031aefb6049572ae0d7abc069e6d6dab873f121aa33117a3851d31bf92735c1cb03b7309bb8a0fde370d4f5c6646e4b92b64a7a73f2f9cde744a0983c89c39c8090924d4e21d653c3252d2b66970574efe8ae0a12edace40bb1bbac2228f32ff804152d48c3f0b33641497a03dd779315c13bfd6145028b85c39bf594d108ecbb9698aa5691aa01090fcd4b5e2405c8e7d0105e54c63bee7e75e0387b4c8599e1c2963c78c98751857b49e3779c80a215296116038e939db1d698b862c7bf4bd70c361854848e74ca88ec5e316b45b1a94ed6bfc3dc9e011219acfc7e2331dfccb7f2b0ca65498de40b33aa0443d1c448517f26e8492d88e73b9078b1a4d46be3e8d929ae66b8b11055091f95645a3a8fc7431ee9297df76a5b1a45103e092d9e8102da2fb3242f7628c0ec6313247d3a3ead5c248c4176c36125d2c7e16d3bb22c33425a6610103309b1a9d08b0fbc3952c1c26456dfd7a59df3cae5d05e5717bdb45f41d637edc03574f5de6b5b24d87ad38be12bdab0314c9dcaafbcb75cfaf4c3878a5e2188a61b8dbb751e908e74c846d946283ff2b75afc226ed25187769e3566921f7dcf9a8d7eaf99e6de2e0819d96f0909137ba03a9a888da497b162b360d99a7c43c67f55f6aba49ac3ec044ffcb04a5d945bf1cdc45d5476e9d19b7d5066151f142dee7934e3e9c3f07c5e592b8d56ad07623f63a0727ab7337eddebc0bd846c1bb1912b388054e6216b70ab6a064f265e9eebf22d37b7a351e44359ca7eb7f87935148f80ef891a9896f021fcf67fea7dc3c7c24fdefae70219f33fe5d86845474b4607fdcdf7948d8b66134aa16feaa9472c9a4731ce5f0978756e1b5c76fb3b1478d8b751f17cdf6e2c66eda72628b6dcf299bd1a22f486140cfa1212a5568c3a390fef49f20f429d4fa70a07e9177282e54f33caa122a341b1d61298ed3a2487cd254c3cc153b42498d972541575bd584327d8f4a5dca0ebd264c1d4921cdaa536c1c03e755f3f3e2917c8bc5ef9d1a8cc8f69e3c19f05fc0cb3934815643919417946ee48ac76ca17afc652b83500fb007d7c7cc49c234acadbd34e4383949196b7fbccdb7328e61b9286517bf85f702227300a4b423f3aa04e1573781f61d8c73ddca943d4354d0a93dc56ec49818d8d0f623c06ff7edf0f2cf43b35d80b90eadf0ac0dc05da47ccefaaa1fe9202325077921524d16291c3300c08a6f5b1e0e8a42924e9b028d84ab5ab858518e9b410eb22b11055a009ac47f6d2abd8975726da4b311c89a80560d147746927f57153d56d252bf59389f78ac8ca123cc0f6fd977f65b2fe20a617ebd6be0537e1b29f937168daa122bd2bacf9dcb33ee9856e668d1ec547cb4b5e91ada202717503620b70021ff06e39021e8df04c37c7c489e5fb89ca5b3ff33a3307cc42826fbca215a626b30c5eb6fa35b87550b11f1d269b42a16751cc4bb9094622a135810fcd80528f54a6fb44fba9c476445620cf9836683c0ef3d7ad67894116d9b059acfccac8f9e43f9321474f692b37450023b00df31a93198157cd7d0728d9ccebb7b657ba28621eb8dc556f4985310a63a2b09b30bbf4ff9924045a56a062fc6d462a32622620429b2716ef6659e110c4e5811773fc7c7373f7010679fb07f202bcd991db1e254bd3c72f42b1c043557d1e31a771c9f251505446b65b2b45f6c5249bf5c439fb47158aa1053b5ce49bd93d5c2e1392d4aafc180f76fb9d9f472da4b81937871ec755ddf9d501c8769dbe9d7101b46f1f23bcf8e85f3fb3327e55940bf6c94239ffc1a73cdb87bd43dfcd3b0d3d0684a6738d363fabaf001d2d7c8b7c869a4b77ca5e8e5863ec0938664bee01a665424d4e8bbee9ac5f6cc519e08606d9a6d8dc07341fa381e9611b36ee939a457b4db693853af743a19689daf3edd35dba38e9fc91a00479d67a12932ed125fce03dbd91360e47d9b589410833c58bb72e4c0059247e647c0d8d688949b5107edd1e3f6ed44e0476142269c1be5c8a69b763577d5377a6f49582c1fde030e63f2bf184e120df2023acf0d74492cb68939df9a167f03eb46482490ed634c4ba35a00349cc3598f177813176371c5490941ff2ac4e0022eb639149b42de160167517d74c5034fb9ea38f908c64ec2ab2a39203c45cd22923f24da9b4d1efe234d4ed7bda62a910b087ec254454c9c249ee685723efef154b536dda5e454d2870ba85938415ef30c6019f969d570c054e2ff3f11b2fc14ef52212c6fd10d6703b5525a0284f227f982538ccc1220f01312d99a248732915189fcb66fa5bc1240a14f2520e5c4960eef949a322a10fa7cb0d1030e4ef6af94d5a9fd755ee9c5994c73ad921ca29f44c2b117fd295b5e6c4367511af7de2bd2ffb1036e30c895457f2f585a159afd1e6bb6727956af70db83adc5187879051953add0c5b68b9a278eca7a04c9d628d454f810c40bb3609a22890e5cbfd4e20dc24cb346723c1fdbc476e34f182adc054c1f563806860d2d75025a39a4f783cbed02c07a0253f5db2b85ff942031947209814351d3c40131e699d7a1eb4506da75bf481d15bcfa7041fa13cced2f1c2fa7c9ed0c547c7a8db62c7c6669bbcc531f8cd1403566daf9273a089049e0dda162591e83831fc5d18283d511a5f9671a997b9b1214cbe087f06f4dc6d8e6b91a802a8bc9338a854ab33f1331e9e058a4b42b92b962750c2910d0dd7c5c2d263733f58dcecb7c2524f4f89bdc0278f96358e0e9fa0404fce4da7d69aba89641740c5d310a98f5445486080b7c4cdda83626f00ab12eaba5099ed57ef0eb850e1b1c77b7dbd8b38784049c33dab2395dbaa31533844e9f31249deee17c07e86c079073a645f3137b6cf79959df35932658ba0516b49cc46ca75da6b8b5294a69f1e5acb30df660ceda41a2e1d103af7cf2263a3dcb6f9009c8e7a3cfaba48c759baef9aa5787e3dae39a898a16b29124672b8dacf9e75ed258b79b19fc2b8fc3ffcc748eda69150ebfce24b8cfb3a8d41f74516bb90972b6cab77ce8546c7b8203897f0cdbf04d1e3c54f0f6da9a9bf460cb4b26707753ee7db22219cb72ac8f575db055362d1735cb058b1a2e638161505137338237f46bda789137c52c882a6ce1f1e9608bf7601c7d2d412759e37ece97058a95866300434cadf694b8644bafd7f51c14d0b08661ee963a16b19727b05a267df57f8de144bb8e425e0de02351601c82f6f17d395d0d9072f7a5cceb147b69a8048d9d829f8e75f954121c7a2b202df1e602b4504baa59e384d5b021b6c139b3cd7f810dff08ae487f575747d2ef92d3e05f0a69b5c50fe69cdc0040b4248d0104086f7d8e65b25a692f10dc7485d7a727812fa15d6f47c1cfa902ae2bdb373fb92144ee2e49621381ec43401e7a7784bce527b90961798e3988a2ddd543adb78aa4a742838345b84f19b33de7a4a8fcd3261cd3f811c48f785f85682e825141f82b36bec77aa2b2959b3d4199a7cb4ffa2634564c17f6dec73ce51e7a2db7c51ad90386b938ddf0b6fb03d5813aed7f58fb9ca3dc98861285b835a46590982e83523951cd5b18a070abc1c32eb53fb11afc61c5ba8162cadb73d3ae6b4541de590786d5a32aa3de4bf1ae15f67fb4a0b8fb2b4a956ca392dd924a86ce7f86ca3f5bef395a83fdf7336ff2b9539dea58212bd0b3ce473d89385995d3d641e90c7bfd82357b828a9a16aec60c7142d35c558d3709dc9ba7ca3ea7e35e22bb08074a874412244925cd43976c0a172d3ab38dce72fe634ebf0f6c59383d139ed718e348fbd2df2f6b8e408a9ddb2116979ceb2b301148bc2fd172a11a98559feecab7b8a3887bc5e597a026508e32cecc5d8bc082c100558bfa3a61650d18db49ff2b5f9725925a28b6867a0cf8ae0666f89cc8795154dbe3da9ecf3d19c0d2cf5bb839e9c4de0d1dc97137a7ee731de0e1be2c8b0acd1de606b4e850d483f07c1a6e59309119e4210baa9e1278cb4663c854d86e29149e89489081070960265d6f76b4ffc9369d1cc892255603d913844637123ea2efed62e746ebbcd8092bc8716cbe5ed7d1746b7d944d2a1af7289b6899fe02358e17be592f1b9fa9767fe6273765c2fec044a6cad6bc205f66c5bc5cee216ae1ffaf6c1ef680127df5a704c1ecef18002dec7606649f67a0d1010eb52b117dc09a919e7c8a0f03c2997eb704a8d9bbb2a3e79b06fd7ab7e8998705e0219ffebe528990bfe66061bbc9231edf3b1e60e80cd42e3641917643969a9309ac6538b4bf24c5d03aa5afff5fcc584aad8ed97d34da8550101ea626ec730b8a72573c3d0d3964f04519d9e815979e252645ee7661a25e3c5d6127262b5a307ee72a70cebf5b9365e7c7642a1e175ffa59e79cb5de5123e528889e0a77a4bbf75e8e88786399e1363cc8db08aff87d7de5fc5e5495ea386164fdc3be779b26f9c900fb335a32a79e0f8b420eaf980f363ffeb7989970295cf001b965391835d242346d2ebec6c37e3b4ab3fe8102c61f36d58f916d96d50f088084bdcf2bc2e5ac1e2ffc85e16af4980eae8a8a18174cea599a93a532b08c6ac6971527e8c30589f966ec91d3e2add16600b97e892a7db3febb19670ffd5b3e9c7213833ff8fc08bbb4b5093340f3a33a105ecd623aa14dcf101115ab15dfea04b7a43856ec2e871fdf3c359d2a2c973e16e72fc85c0af5f3e42729afd49fa785475d5ddf1610cc12312c15182360974de2cf5e13c0634ebc8971321e9730f4ac22af24fd0861648af34c7b87149dc6baf582058e110aad9f7a2ed36486fbb770ac475feeeb3bb5740f1329ea7d6f94992f094dfe56a1fdc54c07705bb615d3a23f638306a70617e32ab2993851e220e0c6250bcf5df117f8da7cddc4bf142ee2f18287099ef03267e696d474970ce6224fea9d775ae502511529027d4a422e2022e3aab183d1d370f661372754bb3e66dd81c85d82c3211c78b318dfe504af8df2245ec7adf929733fa261be82b79f0050ad622b8995a4b69beab58a052882c6bbf7a621f9f9ed38ce7af539dc4ceb45b0ba3b78918f7485cd473d56636cad0d4ff7f246ce13a619940ca193e7dbffb1c53aa22aafe38fec9b281ea441a9d0946369273207420d41effd18f154509de9fb7eb4194b0a270370b9f788fe42e37bef02b1aa7052f7674cdd17872b01cad4b8f410f32946ccef26ca7b443daceee30648c11dfd0a097b06b40c42636401b09dd667f97c78ccfa0193d646299dc6af4f56803ec23f7ae3513780695202d347b968de7ba8352def8076a648e59a237585307287310be795627b7cf5747ddb9bf66e43b1b9945031be018eab7591c57385d60d7a2f29a5bffebf1d12b5aefffb3a1abacbf3714d7484bc9c50b954f189b974f8f01d0a93c9c08cb4d49e2757a61da9cbdfd3b41e5f773d4d4757b7c7545d484db7fc2ca4d8b9be30b36c86a56b717c0de4877e3f503dface0e16cdf35356b5ed6538378a50e2daafbcd48bff2e747a58bfd3d7b5f23a1baff2a1f7e214acc4621b4a66b6e85390a6c7254cbc9169e0ae705d09f1f024c435776e852f047f37279f9ffd7b912353b0f23e3b68da8293f7249b87ad394fafa0b47ea230c51ba99f4751cfc745057bf5b2101452ef13b249c1f7a0aaead588d605ef24f90b85753ee8c847f8a289911f9cab65a1d583e9d7b01bb3e04a28928266d2aadf6db74c721c82ce3a41acdb4ebc4191b9d772479bc8264f48c805a33182857ac2d68f96cf51f65712c903a5dd89e0e0020cc1aa0e6ce485a3fbbe1e3bf3f7eb9274a1e2e3822a89a380ce87d346690e2b3efd372841f1d3e26dff10286c83c1133557853634ecac4e3c69a969b60ab17f256f189694ab46716d2243f179f87807c2ed778b1eb1b572f3b636a2c693be55cc34258265adc105c5afd132d241f5fd71ee8fc608f26938e45a6ab93c6ab01445880b7abe161c92a6ac99edb71e4a83bfe94245651dae166c417cd33c0cbc014dd3a0c8c6ed1373deaebd57cf7b090e11d36905f4d4748bcc1e714e415a31d1af2e98749e7977cdfab91f6ff82387ae85005b02b4fd0bbb9b0c1ec1b7388ece552741eff5deefe808c039296f29d1ea3947b198eab1d35744ea2af995714efd6d4a1d9c42da953ea2e3925d24e27a77f7c4f25214969dd1554b9e5ee3e7683b9a661e33c1000217ada2b178a5683fd0c97e8cb1989130bba4bebd48b7518bf9475aca35fbb7b55c89923fd31475d021eef3960b96bd8278f4dedf75a65f392a324fbdc81a16315e248b5ae7531b768afaeecf7e32bf2c7cd12afeb162b911de05cea486e443f48374293dcd9f5f86252e6b5651bdf663a2bcf0f039522383d2211b64f07e74a73d923300815ae9bded4150b06121310bc1fd4ac7fb3a517da9e827f08ddc20e953c81a22be2a81651848a3dec3e98323ffd2c82c22a3c8755af77d792a56a2533d1a98839bd7f33a12c6d26fd587f12859f6ec978b6b4f53b8b6cfd39ce3a23d8758a3b36f28a3cfd0c5111daf4ca3141c3e39c6fc4cf78c43e28d0ddd03a3eba13a7c60ece1236d84dde422a93ad004ac9f7586785be6072e11da223925f9ecc58a6637455132da35aba0fa748532010fa00cef8e193a53c0debb90850b7fa0d4b1b4c79f1e47ba5692e9f28eccdd6d0dc9e1ecf5817b28565e5caf69d1569fa97892b55ed84ef11ceac0226fd7450feb0fb858d9e0a0f40ede306640aec5a6b98de72aa5a77f378010e192b59f2f0afc412f66d1602ec616156b79d0a0c0aa2c84c357d2b411e3bc7c57ffb69bd770ce3b18bc4521201ee8136a47ad35737bb3137c0b584331c9f25b00a680d0bfa9551ffd8957418a98185621daf9f69c8b52f6dfd5cb4307c328bcf626455cd7ab4e2273727b57da56d350b11ebfe43a12e7e31f518fb5895dda1989e48b699d4b5ecdc7da58bd3b1cbf1453283740d5819745512c4d1e680c69db205ec264e60b6ef2cfa317d0f59c8280e56338d96a305a4f190c7191f2da8339475e86f109669a3f66d38182c47557e8a098d1ea10398f5b2c59207f781745cf4fc96418c6aa6a225b515c40e0cea50602ff533ed9e37df1fdfcce89b44a53e0dd8a8d98e03d0d411f48b6593a83e35bd52ed8b60234c68f9337b61084c629cf05e4740372981fa8724adee4400bf799688d879f6d5478e240d8348d5177e4aa38df9975baaaac79e0adef07368dbdbf377a31420211b0f53c018dff92d220c045156b07e0b99222df1c9cb013b8df487ecde9f056b7515d730db65c45a86d603b37566c60788f2d868d34cc7b4b55cea20cb51a5c08e5393bcc95952a155c20c587e1623d83efb2071f388bcfbf5ae86c2a7f5956a1bd99c3e43f4efda360ac5b62169f32901091057e7a0408b0c575d48e2e128ddbf0166c706788e5afe893c54576b96120e12d578fb514e6a4a9aa019633c85a9ffbd4691846272dcae23579da699f65c8b4eeaf3bf6ace64cb671f96a65df72b114a985dd495633b1a1ea5339aca7eae4a283c462220fe21cb27637aa1055b12313deeed4263f571e1ee6b0992f6d2847cf07c3d95ad64a9642fc5a4fb5600ea1c4b8f4450ce8c8099dcd0ff04b55bc12540ad720f166d00faed47e2be5a2ac60325965ad26b0763c225d686a62760f89889ae9147ad972fd8aa35b92ae775f3c24a067db9ab4f16d33a4737b207f8e5dd0bffcc839c371eac70347178c13d79f514fe7e9f47f7cb9527c2a6630c49c034ad04c17a4c6192309c93d30991716e8112b8cfdb5625a21310c66254bdcbd365bb926b7b88139c51989dda13653e0133b94a220bae981872dff4e70b9bb19fe5d45515bb2ef46a7e5ab7bac5acb6a24e6c09673e2702d3f2bfddc6b4973a4fd9ea2996568163645d091867c6b7ca3f93cf128233b7e9876b22ac39c22abcc0de92a6f03cb34778b845f4fc9d2dca8d1347ab089495def4553d3a91905aaadf55e54c753a3f2c16b050bba2dd168d095dcf81fec2e7bbd09a7234c99d70034d2fb28a531d630bea88c17f5f709f7f61bbddeca344079329af9a86518a4610247622a189e9fac1f58ff410dfa8731540ebc27f38f23920d45e88cd020bc1dbd4dd0ed23f1a2d0ae12c17510c7fddac247f7635d331d6acd07de210d8d76cf91eb2be144d48a6e4a9aadbd32c0515d7ff96d119207d98b877381c2ffcf3443336c9791f99408cd0b97d7b315d56930306cca63e262b1f4be7452fbb66e48ac936a7f9f67cfb86884d5b976c1eb6d793ecb4384e1ea540a379c4cba08493557647f42f1c1d4330db7f3b9f34667e3fcac46f1ed301dc24447c7d92b7fd65002b1e2f66e7b9e8d66612230df85c41ed831f9a78653542e5961cf4c757ce577a8f9a8b0697a50abcda7d755562f5bba009364cb13e57a19e99056177b6ef5928d8f88816b0fe2a937b0eb4c0e02d57a659548286cbbb43b7b5749c837545874ab5fb6d7a14c67cc13a87064c46e22f9f9e9be6dc082d129790726e3e14f6a7beb3f2483e6d5fc1dc10e9391c87c212da69b7b12ede26373cd533ed3858c34dbd4b45a0c1bb04317d8e52141db9b158eb02103f46000bc2797ced62dff96a84b115d7cb3561a573c9f761e2faf349e23a283f601c4aee6515dc53ff398fecf2c0fe17e50dedde1e1bd8c194669fc5f9bdd85fad3be942507b9ca83987e48201d15d2fc75db45f1f38f8ee7cc0d1b6b1690b768935f0eff9b14a636d83b20ba3ed5103a5990815ea289e5b1479d30537ff74f6bbdc6086d2e1b597b84766602eaa5a35d5b7aace987c84979cd1ee1bd27a849ee529f9c121fd328741be109b2ede8e72ea3ba59e836da0b5dc0a08284a24d41dcc3c5be11dcf7f217bfb3ac9691c3149b2d53f1bd55a34abe809751a18d5b79499276aa7bd6624f57de72e394f05bda4912ba199269a58d79a2870a937e4edf469387372458ce0144c772c5fd81bd88f0f250b9e88fba6a851099d2a28106f5f0ce73df9a14fc67da5c5287c36d19046bf6a1cc5fa64f85d19f28e68093de9186d5c37c924d02c489b038f51b1fcb00e570864ea1416485b9c980f86c50d2bc0b6a51a06802a9d7fdcf4b124b3d487ae540b7ce74366ba9a3c76a2d29ba1405d4f0f3087d89b51fdb9c01e6ba0aab83f095460ed1ae33199b7dc6d35f57a9f0a9fb8bbdc9a0ca727d5b6eb585ab98aa62a1f04611edb8e6d100ca7c975ab57e0aa5064961c200c53fd95ddb9da82fd4b15301f5f05d604b7a1ef50ee368cb8ec32ff8e6115412c1b10875a1b35b2ffdb978ef69e23783ce9969dad45d5f84cafb8ced78b7f03e477ab1d5e51e138c29bb72541d863f52bc8d1a748764395d2f10aaba86d9e80ae1f80cf9a6255b3363074c5d9f9d0922588f87ae6138da44bf4c4955ea64d7781fa3c42c2068565d0bb8e701ddc4ddcf73d6d9ed2b219c471ab2ed08e5c90d3e4cfd64ebe41e40449282a8a119d4e5c939ed26a3a793e8166de7a446d8ce0e2442096442dca30a6066f675c5e37f529d88670536287830bf05769d4bb2987103d8b8baefb2b78cf96b1b3a4dc05e5480c082c9984382ba9361752ae3120329fa2a0aecc270292031a471221c5fdc956f5a9bd821f24666db3a1de63462842039ad86af3cbb68b22b930f566e2046649bdf6a4ea457bda10c551e1a870fe840f15a42a59098076d18b1b15f115f2e245e09d470fa443a142f3148177f76a7782a89730f1e269f63a6c37de12167d6fd72510238734537f1bbfa3a8025dcda3d4c2f66bd19ad9584f8ce85d629fc290b4ce7c062ef61bc4efbbc1b6d334626940285bd566c5e097b445e21aca5c2ee873d3852586025e82a89e87152eb5ace07c67191a658f2157858e8bde9b189fb9fcf64b8e129ed74ed34771e5a7b798994ccb395858d4615113182facf140218af9cbf3f7843a473662dd0bdc9c137fdead7435ce9ea1b48fb138bc2562d167e29938d4cb526012984a82a81e4e16139813adcf358f190c6f90836205a3477fbe9fecba1df9ebca865f36c0cde8afc32231b4355723891bb8a031a10763b142668b2d72d3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
