<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34a6a685525937b676b2261fa7d2060a7bc50418d6947358feafe223c60247de7e18a7ba3d4435b3eace84ba37c156d09ab0a100ce0a9d45ee5d33e810e346706a74584f01166aeeec5209e0522c60d2e29a37dfdf460695541129a87f034d3e3e4c27d4385074f18655d418712ce10b3443fd328723a0acb274f29789635ba9df28d45c807a7f542ced16acfc83499d77a7f99d39244936c56cc8149c7ed12eb006a60208be7fa82373dad38f964f843f680d80fb14b9b70bd00c5639e61ec72540496da04731a2003632a2008624091003e1ea5cf7e47a05a51831369547d2994f78ee3ea74f0765d9457393d62966a92f9859e416439cb7ad335f1a39b2c3885751e1fe250118bd04d41c4a73c1035d2fc64acef2800d6f0ba54d05acfd4d4b04389a40a09ff955d10309958a7ba99a66d2b1a87a5c32dcbd75d5b8baace8c50ade42477798cf2d28ddef858ecffea946eb110aba15b87a523cd8dd2a7536dad40ba7e7d835d34913c17fbb65e753aea3123ae241ecc40b49b36a79b1f5e323e3f26617f3ef8c2f3bff0852f1231108d5691317f0ab1afe5f9a3fcfd482086adaeb1e365a74222c6eb251b4644c1de8698f01f9d21f1024afbfd0954d8faef11f7919b6154ad2cee69904447739cae911e77f4eadb609104824aeff7bd94c39d4435d77085a03bfbce01bbdf48f0a1e2438251197166ce0ff48894a9846b2c2bceb933b8762a12904a87d6578aa1942cb0b3048f2633f80eb6fa7960517f8b7e6d91cb0e1e3125a81c24c1be2edb4c45544433cad867cc4b0eadd3b4574ba0e13364a69ddc8aad9a9bc1b03cf1e13289c2b8b71f515f0b2601ca10b2d453c7ed12e75a96f8a762deb354c8aa648004068343ce91a63c76e0c2145d2636f9c211ffbcb2988fbe273dae92317b6e565d537ad23ad8f7f6f735cb8ff78534c7b97a9caf5d0eda04337551fef67492dfa6a4ad26719c854a4eab199cebef60b2236e3902de43fd328649068d1494b2ed6444f7d8a16e94c408b4fb89bb7c9fcc967357279fb903bdbcf3b870e6f595c72abb4d8eb317f22c1df56931a6c0f2632e2feca737218217e56c4597785d296781d67b4ecfcc12759630653984fe8c46e6d4c5b6e35d49e29a526cbdc9ad310088e64bdbfe63883024d4430a8d28939a88caa045bfcbf7e7e402ee314952442c3c7c413d013ddc2f456328e8bfce4a80778057036b22fc4a20470502a9a23185ec3c95bc6bf08fb6f72af395be41e1263f919afa75e654aee01f79f3d55bc10f3d9ffaa247142a566182137bba8a67073d2f31efa3589a730fd991e5fcd1e814045f61e61484b829b1b03c6acb406a38962db096d4c89a0cd556f4fa778f4ceea985dc45d31bec0d6faeaff6b33d3412ba20cdb33d5fc8695922670566589cd9050da185a878c7fa76b41448335159028215f802bd507cbb1c59d7304e3add604695937da1be1caeec042200b51a7d61fe416b774c1b6814f9b3b27f166d99f74afd83e10aeba729d20a8c9f134a47ffa00ccc57f27a32846fb407bfb002698be340488bcec868ef1b06362155be10ff1e16f6d35431f5804c7a7e5f9ac1f2c055187ea21a77ed30e72db4d9638fb532b9e80c09de19ee330c21698f959aece9480f9d94be877ce49484f9e16ac52143f13879a41d84c3f50fcfb7f8e72743b001641414143e2324f39c569a147d2f226a6754eff4ae5b2a32b57cb9099237a986c82eaa8172796529b86a4c88c7cbe5f31a541d2a50cd837751cdf1a9146194cb79b27e690923185e174fea4cfbed19449c9b7660b957cbac0afd4fec60d0218a6b858f21a527cde98770f03bc85d40f82364e7b02e6495c9ee136c0e3503d27540d2b32e9078db0bb9de9c09178dccd5dab0395dca89ae4cb3e1f1dd158e0a028bea7528c09125b8dd043c01c100053360cd26a7b41fd0c3cbab6b663e86a90a71a22d8efc34df983d086cb67a7bb896be8565b1970bed119f8087068086e8a96d6529c95155d210e976162e5dfff6f8c0b80a59a50bbb0e5cc72c2dad9475072aaadb7b70849eec62af9af81744a3e3b56c756831758acdf7313aaeac91b66bff5f09587d07a3e9ed925aac918b76e9dcbf71e35b5244c70d71624bbf3fdadd1411cfa73bd58d3cad9d32e113699faf96b954d3d43d7a86906e5257b40f44639f38f7b420717a505d47e47cdf1e769735b857976445f032200bbd52e174f4d526502affbd7e7f20ffae1cb4fd75c8cfa12218015ce420898acef94739a4fdbe2f5867904e98724c41470bb9693d1a25066f5ebf6818fad9f5fae8440ea95bff8b74368c4b44f8004a9596486930598103c89bcb5a3b9bc2cc2a4c2cf659945009ced38b55462e3be4ce9f131c89f0c2b4eb941052cc70ce3dc864b36cb299161555f43e3342a6f6454ed86acb6420a6f19dfffe630cda20de26b8d9697c4476ac5807a15c3190ad5840d6854beac42f846b723b32a0dc5be585a5926939b742a5244f4375b218785e5398b4bbb2b0e0d4ca294bcc9bb2c610cd9eb1a152e0fb258683c8ed9d5a1154952f96388b4364a346b129f2986f6ce254573d79d28debad6b60d507eb23f60fd9a23c788e80a10a190e9bec7c9164515cf12f3067cf87f9f0c6cc60aae127bf8d692b6993e3d9fd18f58bf9de27581cfdf1f229496084aa91e47931cf681cdfb67a25484fe348628293c513b2c16c027ceefce95bed4043a3a4134c18132379d47cc2041f5ea32a39d82fcccd4832f3b1689ca713e23185750f4acd510cf9c792d24e2e1a207ee13efe0a0d24e7a3f253813705e8071f7db9764bbd64eb5a8c32be6b953455be680ecf21710075e61a8d0da9cda9cb9c42af96fc992e7f1826719743fce187c177fbcfccd46cdb4c82b0b674fa28fb3d9de35779ad281a591a17322c14eb07b28939cc244d64774f88b05e05b4cfd63f8e79e5ba111d65eb1fbe675b8e6449571a00e743e830bcc08b36cc1da8466568f6ecc8029aa48bd4405f6347dd30f022c5c0f8a251c308ab2ae6d06db812f893050ce8278118360e37d15a15a0f15e53f32a1c4481816a08f60327904f8e0083911e94afe2f9b47e15bc3f17048a50f45158bc44e82d19a1fd165a8f8d04db21858bde4d18c406101daa7e530f91f5d77ae1d2c1699bee70160ee9d44c72e36749ccf584e7483707d4bdb85b10997a321745927118e3912274c48a54b69fef89f4f8cfb8723d9809645a61b00938f405a7b6ccd5c251094afb8fec7a9eef69d7e8f21230607064a12f8ae84536240ecc8ca66b01dbdf6dcad1ba2d6429b6219d3586672a5522df96ac014dbf8a31f56bc4d0c0cb6fa955465a52addfb0c78a6a77e2f29c9958c7dd09fb232142804166e55c117e27f9dc1cb3c37f979255d4eaf83d6445ba5b91b0e310bf487bd2d97b5325fe38e4b9daefac8a4782c696651d75ddfc266d3836abf4dff20800f4b8ef5a472a7e276c090fd2d91a15c4fb3c84c72403df6d043894041ddb5234c17cdfa7d4d083faaa195c3c0b118c5f9af4adb34815e356c3c996e776a6d917f8e32a04574ab5a96c9cc5877f3fb25fc1502fc5844a8e6b62c8373640ff20447019574e512f700600da0c5dec27e49a838f48211053915aac4a566e1e739a6221b0e0c6e3c1dd8e0c4153ff7861ff95870bbe76eb0ed3d21d62c0dfd0fc418ddaa91305c25d21d5840382e0086e33f6d2d81c2bcf1de4fbad6950bb9af5bb528ab448897435143dc49403ad1950d99590f8ec50a56e4f4e356d08c6ffa4a93632d5e84089add094dafc7efa8cf4ddaab9ed7b98deae6fe1d48798db942766a08faf87f66c6bed2fefe591e34bc1779f16c34debc2b1075dffeb76e1103b27ab732e980ccee18784d8e17da0a0f49f2a8ff1351a5ac205e5e04d6a349df16d7e1ce8beea9978bf52ff92625b0110017e6d90514906aec481fe376962c8ed2ae2da538d95e9b4cfca8c5771d2be46a8f107813636c7d68d246bd78c3b3f03b6f2db56dbf5d28e8998c5e787522949f570c83723363e1224a461028d2512821b36279f25f719d8fa404b9017c88f6a8c6030e65917935dc933d6254b01e78e1ee9d3940ad592103b02f8f79eddd89f0902165676482275fd0d9f855934963d79bb84dfe68c2996b248fcf4493e9f73de3153c3c76f5a38ae9b7ef4bcb1181cb51eb15b83c5755f546d5c17b88a3d71ab0acc1e569e8fcccbfa23663695572032389ab34c313e9c205bf63b2adfb673270e910150f3eb061c80bfbc437db43d98eec9cadc0f2a8372083ee51d1202eee0e94fd3eb6ccba21b6931948acf54d8c177befe55524715f327ede8d9d007fcdf0ee25614ca51f424654f0ca9cd5e377c16c3a4c7960a6a9c20b2556f13d67a8e88d1edbc9347cd435b12a6960f043d647fdc2f7fc5485d797b54dacb255e19beb770bb13a7fa1acf8a0a2e26a8a51c9f291deee849fd75b30270f6ccf0017291ccb909a725bdbed8ff984d5584f59180d48c6767bdef5964c74a2e93fd7e5771409bb805733663f961fff02ad6d694080bb681f3a88ba06b18d4e9190fdbb5688ad86550090522d4063359eb26029a271523cf943efe2bfaa5dfcba98925e609269f35e33b9cb419e1f0ea778551e2c1395f763c523b1eef5c2c4992d6ed7fa09cdc661f9adbfb9ac47e233af20569daa1dc4619dbc6acd4d3a25d2af21dc68cb782cebd6107e2a587dbd440eabd199a0d47cdf2527db376b097af8d1e92f7744dc937bd47569d32a25febc03b693686d86cfd939c0ac05119b31fc9b3f27b1aaf03a1ab2104371a305c9cdd7c4ca53e2831284d5d125bc2cf98d2214098b1212848403b2f61a99e94e6cae1ce683aeee2c277299a82e418fe7fbd7a2d7f2226c087e78f2055194d9edaedc01e8334fc1fb544f9fa4f0438cb5a3b228e001609bfcd6cc4dd9341756a633387c254f15a67e7c9a5b8a05c2bdd81496dae3891c7a799cf5dc252af179c1d66c2cd6e5f804ce4bc1d90722c4c3f2782bb535b96a05ac0796fd26c9235a7a645b5550c46cbb08e12cb2249b21de8f18e5700090d2563b429df0fe6048895ad185e885d77984e18f5a5e3059fb65921a10a2e53e12c5a84cd0f6278ac7a79a142f03be85abd21e8e9b42d6cce6989a785ba6459a883bb603642bde60982f651651f14d108093ca64a5ee4e044b4168a892ffcc2baba2b8177f9695542d7e58134567530e81698533afa785f1b8f714fab23caf20fd1bf2da189c07885a1cd620802e8ce09c6cd5b3eba971149ab58b7df58dd75e6b7dabfed8dae238716e1dee3c9490db17584686adee97ca5c1f70c0a3207e4f56b12b1fbdbfb786e00bf7e9091a671ad8bb262863507222d3246b7825fe848a86ad127ffcfedb28331eee9a6fd33c97988556f3693967f3b634cfba504f36d9a42bde83f13242321466ef333b0e53322daadb9bae6fe76c8d8d98a4985f030e1c0beb4f8c0e4099344772bb7a6d09b2e48b50cf68875fccdbec804dcaa375c0a412f2a10669ca3aa9bba49643b334f7be8132cb7fddc721b7de401118da9b86b5f07bcaa6d56e28247f887c2145dde899038c3e43cba2aff579ff4c156dc8fbc6995fad4be87673615360455bfa25064ccb89012dcddf9105b206f0f08b575021fd00c0c732dd1d2b2fc392ce74f754b8b876c38737c22a6a4843f844db1cd8e0e7e5738bd534f051e7016bceb9b1771845b5d2decef5c57c32a22f1999aa0cd682a604efdae727f2bf54bf9b4f4cace843a096525b68a0daacc38b5a6cbd465d2153dc05208738c0b25f526c01946fcd021fc58c704788ca6c33ba3153be090538c771dc5a4a494a181647599d9a28f333345590f259b057ba76e70a4fdb4404addd2169dd155bc9bc66fab91abcc3ec3cca2fa929af6766af0ee49285387cb64cbbd388067bf290837c71fec7bcab6c09d57226ae8d92213023b02c216cd39f0b9265a1c1d18757cd599aec0189dc6afb28d3bcdf78366af1f58de1657cbd988dcfe20e94cff63958a401fda8bc8e31567917c46de6c7b92beae84eb7b9676d4899922a7718f604abd843a4c6cb1ada1a68b64107d3d8d4218cc5064c029bedbe5c1d3f5ccf32bd16938626fdc42ac7ecacbe42ad21e4b5034b9206dd96ae831b66503619d5558e7687b48c9c0c502a30c5a0f2d3a075ba86cc81444b6877aa5d429f6f3e2692ca9b1235a488a53b594e089a35e48be34652aa938d243e2e08e12ffb7eae0c80d6af50ed75c1f1fa898348ba4fbbd2afb2a2dac7c7bfbf18dc586b299dd25038b8d0225585c4212098ac0a96e49764bcc103bb80ff2f10cc4f248ccb5de3254d7cd2cb218307451ae45db74cedd9a031a4f8a04ca9e8fc134f9c0b36d83fdd419cfd1edbdf5085711c73abb55a1789fd03a19d838da358b0d6d6b312ca3c2cc8a60848ba99b4ddea92fcedfca1f29c2094d9c6d3b35cb85be32ddde86f218f8ad0075e0fea710f33d33215dc775b88b01d00b3fbf64b61e9aa191367d8971e88b6c5b22d1dc2e934a3b5696583017282e4089b3002e5554297bacb89937801a3413b7dbca6c376917f7524a66ec6188c819bc1fe704b1f9e516252b8d2e330314a8c8397abd94d8ba14706c87c6751ba0f9ac10265f9a616f8c5b4bc3e9a5a2393c86c1f9c2e4cebdc0fabeb12407b06859e720ccb6f2716cd86e41f9579ffe4131fe46a3dc47ddbfa4867d5eef763705b9758529ca7d36fa6bb87d6f84c664ea2d0ec2fbb6f8147f4e46adf0933c4d0f5d676f10702f86a9dbf81cc665d46469778394484c86b7952050b3dbdba41a8042e846707606e87941cf9dc1d830233f67950f26095481d193cc25638e924802d933b97172e32f56a4853f78f820d3d2f9d0fa792cb2bba5ff22d8f5fc915ed9b3862ca6a365292e152a1f8abc725112eecc766681c0849aa188435ddf1e278654a8a1b77f1e314e33def3b97bc7a43ca48ef83ece49bc613bd25c83ee61e8a1a9deea6d0af038ca74df77db09a2ce952ab39a720ebb3b3ea71795df98b7d494850fc35d340f305ec50f5939fd5174b4a19367d72143ae3f3f814c6cd3127c3863bedafc95fa63a7b62770baa102945841b6eeafa3a23e5e750774ac930df67d080f563a47532bce6619669704e20897a36291ae3b4e951707298c13249032edad27067f3a83a28d359823d9e114442b4b5ee2db8ca4c055b4474a73bfb9a22e83592fb580dd87192306328e9ea5f1ceac9743a7d5be889ac83a51e058b1f9be115b70b09350ae091dcd34c02ea73361131c14d6dafc822e0ae1dfbbb08d0d02b4847e913d41ae6f34988abd05a27119037cc6dd9ba7b3400a382a6dc63259bc03424304f7b31c81c34aa7a8183983551252929c0230b9b00254446a3a34ba118f43547d4302d53c0ee5d14d07f2bba0b74ec034622b45eb46dfc74dd30bb25f07fcb2f933603aa1b9aaeb7217a2f42a555485f8296adb3b3683452febdef2d62922f46e3000b1d95c71dd174d82948438de61958cb3371c99f15e6215b4f53f86ee7594d01b121c8fe2f3f8da658f753e809b0fea5ef4b52047fc51263ce6b08d8d08195b6f4122e3baec0a3551a7400077f2c118d45fae851f1e67c102690eab4d9682ee393462ad38596f11d2d7f3d96268729f13dbaf2c6ccca0581b3b0977f7f02fb7807668d5651e1f119a051804461021cecbaba3c218d550e5596cd1832fbb21a675e8862d57cc5427325bdffe00bdaa8ef34caf61a8e65e4b1de62caff79005658485e75b5a9c46a09fb31a74c3e0553a1b6f7328fb521dceda60ae9c7a3d20fa7fbebfc0a01628c67f4bd6fae9a1828f6c93de59653c6e01f207645490182bd31a5f924d66dcc8c7eed36c5199350fd767e2124e2cf9f1dbb0c4e656b94a6c83894f27e58d1fc560d185e4d96091a3e22d521db9ac670f61eddbbcd5f3ff666aa7131cd68bf7556776b86d52b8f45e2bfcff2c603fc682aa06dc1af94c3a1e22552d4e78b34aaa32ba3bbf6e101bb7c5bbffc7ce13b6fa7e63dd5e1ae430996bdd40079edfc389b0c895e4fa05161f899d4e985e3de54f397bfe47176cc1a7e81e98ded4b70cf840c25ea0a6e4cd426a90e50ae03db566a94beec3a12dc6277f84db0d557ceb0ece96fdd6e26e4b119ed026b9c7f95384cdd3e466194cc508616c672f7ce35553c31665f7bf6b21a059616a9a1bb0e2500e5b2a07a14ceb1328109ebeedc4ae978656aec6d5baa5449d09a9f5d91b2690557f47a31260d09c297eee33471b33a0fdc02a674eb0af622af1e3986182b29b2c5b13a49ec52cb06ee89ef20fbc9e1fff9f6ee5a1452027e2685d78e3a86098ee9734994e7ce277838a015bdb56203cd215d35bd5a98bfc641ec0addd125ecd09526584216e6ad2e1ad396d1afbaddab7861ab03de0b1005a31a3c52b895a49936b4df05fc2c830918419136310db87a1c0091d52e84fdfd75a13d6ce34e3a01da1f4123b13e19e283b6dd1cac5a3479ef31c75b82009d6eae1fa5f67baf89a68b1bea2af885c487b1f1ad016b2a083527503d5fa1f7c250c50b5cc731493c3c0c45575133bc5ca24f2712724fe56bdbc70c739fdba9af636db996e93a9903be2daeca9b2da6d8762e41e0821307b368a98478f19f81dd7421af7fdcf3cf8d61e04a10c74cf9bafbd77ff33b3ba83ca4a4d94b163ac52db38fe2cb22afae6f6a42152049c1012d925ade5ecc5863fc6981b0e3f9faaba9d9a8ee1ca38c062fdeed854b9b6b2ff613230feaeb0457e1b1d72cf888c97a4069cf02a9392386bf53e1b54e98097c045470f9d66eada5c5cae0c63937c830cf633bb7c726a181c60d13e12eb0e74a926e563e69563166c5de508e126352ba305c12bc35c12f3e713d33baf18549b25b5e0fe8454fa304c6901ca0017df05013a13372fd45105f826e6b349d925d41eb73f9ef20c04c65fff13ef6030034fb95682c5dd25b8cc81b3997ba8ab9d02d24f6327090bbfa3a2803e6e1fc4976a6621e4e573e8f1efdac3724332587eb4dfecbfe047aba24f0c172c1e2c8d616fa7161014fa63e06a32fe0684206c665f877c7502d7473920d3fef03bdefe36b181566ed90795630abc5752e2f72ae45e6453137ebd60e31b7457c438f025e8d6faba47a4029154efc9ac0f25289a3bc71cf2d6909c0b8c25d62714031a5953ecfe1804649af23324a8a947cb0b0adddc537b40a749275ae375b1621928f7515573de3d36c7ea12b653fa9298e7d79b98eea8e508187c895e7974a112a347086c6ba80f95404c84c1153df78a2fd47ea2308d906bd790964195abf640f66dd078f3c75befecc17029ab64606091605ca98c5f064e575322da2e918dd26100ba872853055b1da7f2805775a2ea307ddafe3f0e941532d59b920f5bdefc475a4a4cceb180b8a05bbfe9d4714281c3e741ddd4257c0a16f1b2c3efac799b9e53f305587d95ba57b367be3b16c62e50ae6571dd729a89ee82fda4d78eb221a306cc2f0a0c19c036de1ac30ded1fc717be77f5b27855ce5da26175cf67aeeb42bce36b124d9a207e31c42fda063c4db757b8f56ae94087386cde52db0134d61e89c8f1efd712cd2f0b66a0a11c2abab005cd95eaa72de07557277074603a8820e1e7ad00b56477ad867c0df15fc0d19172cbd87f44298c538b4e7f8f14a555f5b9099725f03d27953f7a17d43da3721b4ebf0d477375aeb8cd9b4a99c93ed4b6648ffd9b892d90553f2b28c991c2727ce0fdd2baa1491e1d859a4b7b97ce82120c4903db1f4a84d0510bae17344e1b1c1fd401c968f8c69678a46969fa6a305a29c2d82fc71627cc6b21861916e19250269153a4015fb1a1a6ba05dfe24cb338eb5730e0f0bfece9f92cbc1dc8bf88e40ba8223c811ef7cce6853c12c784f080434d576e560ad0114d402470302a6554d1be2ad25148f204ec4f757f81c84e0da1c40d464941ad06153cac2abd3113b1b5f7478416a026ae376b7e678185dd35478f95ef06abea70778cb210d983d290a7dec8560ee9b09f68531c3eafc52250ef2601a1e6db8f95e26e3de4c02eebd4af3512dc91d7ac955d88cbe648fb4dcaafd937202e6628bdbeda5ddc8b1f746a1ab837479a1a1fc8d56564da96fce2004058ad3e2728de0565d3a2585d395843bdc1bda5cc2f09b4a6279839ee2da2e3c31261165a804609bd6efdc8eb05ba30886cd69e4d16b813ffa57666f8b0d5da4302885a9761f6e2cc03dad5a09f36a6960c371ef548e7bd520badc013f7ccdd63e09f4cb717e51398823c3c005d998cc4aad90f4bf50d1234d992791b508bc308cd0e6f65b3e33b5baa6ee0d72dd0ac77d75b830d3649c8473524c136ccc7b211b94d18e98c207232f65b19ca7f2312da58fa03e666721945b9cfc95e138ff3429635c746715dc918e1b296df779f3aa2e097bd8b95246781aee1b3cb9c0e5023461e3390d4062f92f8874fa7185c3c742faa6e8445438f6eed2d86da007ddb5da1135f7f11c9706282d3d39fa48df72505bbe097a67f1a63b701cf2780efc1086d98b283b65a19f7683c41595cba97d4d1241729acd4c8c1864e315abd303c29df8189b38431b7f7711623d67cebaa081be6abcd894a50b60bf2b37eb4fce9221adb541eb25270f1af861ffeffdc28a96955db2b60d03875651dbc7e1f4774f1a0d1641589b52a8a65994a891b53d5e5ba58ff4511a7e14be59b6f707838bb9e5ae50f970b88830efab284a8bada0682fd70fabb9706f484a01c1ed723fcd2cf0f878c111233b4b01214588c0947f43f7dc4ef8bea9531e976f12adcb851b4777fc7cf1b2521cdbab3bac7247ff80aca570d5e722b1e678a4ee84affd7c9b36cdc15c1480c9eeadc3a14cf0122f6035b05e925f41d36da1c02ed6ea5a3714e5e5651e9ace3635ba77e16987701ec0b0cff47c257f1782f997fd184a36a1a3b346c601b43b99e64595ac85bb618a585c22e66d8d1eacfd15e9fdc0e774c8689780a0055733bc3b59322cfddad0fa0fbac98217f7fb77723ed562fe5cbe8186b32df12c0eb59ce0780938518cd45d6567d52d5f7524269da25977a951960766b91a7b475b9d33dc7ac23225681a96eb639d7d1fcddcb20ddadfb05faa7771e767bd756146b46b2734cbe85ad9f2d9424be01a6391019ed84daa58353f1ef4ad83e306c0bee2165a81a1486f2a941281661a128842774e168469070b520492482e59128743a2b9133e21adc5ccb009aeb5432b07382c35769b22fc013ea9863c704f0a584fde051f73de16daf2528e8ce5461b8ac86d42c20634dbd2f84c0ee61e2bbe543a394c9da5b33add3fc03572bfe1caae83b965b8f242dca8528e6694dab19f5a79e6b5555d54f2b52572943356bb81500aff79d6ad35532b69c12abcaef15f02ac2d16ebd85b76f69fd0dfca3bacbc211b453a3e922e8116f43467478a12d903bee39ffc05edc80b38d6461db465a43403f641f78452c4615814ac38bdf1aaaf9eddda4eee1a441a5e5bc59277067985e841f9d1274616aeff5818178b2dad33b4e99975a0db23a1972f774a0c959606a723e0c5e3c9c856396e40778ddccb7ecca24a9071a105caa8d4537addc5e5819b61f3a0b1de00be21212ef9daa45ebf9e080cc421c2755d52343c2a64690ad6ae1f35c6b7074784977a60e28afc67b05ba58f95d4fca1701d3da121fbdc828c8c316fe0f770c6154380c5f34c5ec069ef50afaa656ae0e3a06aa6aaa87c8203adf173ad19c73b192288d57cdfb937f025f94363f80275ca2d4712dd60a9bd7eac89b04650096d09d365e3cbf050deffa274d34edb14fd475d4f58c4a51cae2d11a21ddf960a17ea5f1b0ffe53ed37342aacfef405696b8eba5acf8f503cc182e7121f4897c8b8bbb8271840609cc7aa540d49b79cf4a518d98a197ffd9b45d7cc8a00e7a246603991c2d315ca6de7555c5f23cb3518151860c453eee9f673da110c0e501f87a6a49092a029c0be0e79bb65fafff1aecf4ed5c3e6c0c55829224bed04a87f9d65a8eef4b0d56054b0c284b8e7c595a19422a2f86f43088787330b78ee62f6b5da39a72f88ebd161d7e5bf5280d5991a7f327007acbd60799564bb24fa66a527b1850f26f287b7b3910e09da5e1e78d77b65123a4157bbb0dc630ec6a25e809a4454d6929a90f2930c17920faed6108dd1b2ce058744c056264c432cd17ba04dd06bd938bbbcd92f22dd1dab2906d3b7fe9b7759459eac05d1c6e69d235d60bf5dc71892b5fb99e139df31805836b6bbff155c0623ad5489b1293c7c1a7928c7bb4191f9796e53fccd1414636f36a4e37c80bff42a47ef2f62edb35d34b7472f503a483a37b147202b69150e3fc558427abec1a8cfc89e418bff74729532f6d8541ae8019266e1d3144d2bfda46b6e13533f52ec8a61196190fcd2fa274a1d1aa19204e83b7624247a8cf21477d5f089e831346d0691885772e10182ad8b21c909992d9e2e3d1d7874dca1790b2d42c3035f929916ec90b450a81ba15ac40fc88c5977be01892433f96ac1560b90b87978001963ab1eb0f5360343cd6bef832a4a84ef62f17d3a09e22da616252a92b937eead2b31fca7355042d8dd63c3d1e7832ad2332acb7471ab873d0a024d7a175403a9f0a4eb8b6a00e00897925f267a4ed41873fae71620785dd8db0c72b68eb9a8043f92f376d8982e4cb176a997820d497e2f108cdf609a145b5945bb69a79bc16c09a3b08bede6390f759bfd92605a2bc1fba39a44e432bf198d9c27d9a79e620c42212fb1837c62027a6394e81b36dd95f1bebf7d1512f0fbac68ed88d86e8d1705da3dabb3a4460a012e526dee759f30ee5e6bda9ca47e28b2d3a81aaa72253096142afd0e1529990c29633ecaa02e77a11b9f59fc4da228b4102109a40bff82f1343eda96b4b07fef2d2becd325a725511fe05b2f49ab7034927d948da1a98e0159b4278202d04022dd37c9cb43284e9c483df43a47971e59e0100e4b6b01dacec9dc7f53d96e2e37f63d77d82d5c75fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
