<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fba51f4fc93f55ea9baaf2f72f7ddb6c4e7c85e70aecff02a0c444b762dfa9c9bc1cb1172466604ff173651d252b0315bf96899a90a09e6c2183e6f4c235994eb60f95f2e7078388e28f74c0091ebaeced9ce62b8a72c744b22ae5f9925698ac9ceef2b276aa15480f24d59aa71be7c58b18f1f5e855a5090a3e38440e653447aff9e508f420141ae534203e17b567742d2991c741d8816392cc286adbff4b2a81fa14a9f5cdcad10d5807340556458835c6906dfe07726631d0ddc24e9fd311dab798b0c2abc76c7da20e7b80a5b43e9dd85b8d32af6bfd83857bf2b4cb6ce197e382549254ada148a4ded841282a5d42322fa3a5d30dd96bb3a4279c5419d87f8fe84d270b8c8fc0b22827b941eb3adfea7e6985f403458c658fee8113829fcb1e5080908bf6c66c904a51ab5363710fceee1e24fe7c3f3b3a082b3471f97ec442a76cdd3c4a8098b8635d2a6bf2117ac2bd01db51d774b8d5330a5ad1d9ff2690ba60d3dcfb7b1bb379ee562a4d2f889e3f7f5a48339584499cdfea8cda2a7c511c7730e49fe6c6a25108005816e8eaa86574748d3d43d58fb1349af94dc69075f0358a0d9c05d597c38ecd83e128b50eb2cff67451ef8ad5ab1bfa18d99aa06a3d308f523befcbc0e50c2a6f1412a7d49716fe735992db5f6177956a07c4dd170b52afc6d01621257d850d9738051de4a2f822e7501e81517a576248f65d2d6d8e3402b5454d9343df57f4868756a7a6516c1ea0a90556ed279712a0ecf8edd7e7df22ceb4898268fa270846496ef58386d4f33e055f56853446271a336ea501751e486b94ef7c5103a1ecacf3533515743cec55d76173bbb5e12112ffe0f06900e5ccab565127fe91613790702022379d31a91376019a6a867faeadf8407d0b64ba5f1333a4571cac481baf09e4172d1e1d7f54bbae55889dd7620d392fcb171b4471c63cd3e899a60d28f04f5837e851db273dd4c891c5767049e598ec73dd6a2ba437b5b442ac63bed186ddea56d37852277dbac0256cf66ac825f870c4cd870a89ee459e51b741231993cecac9e2f2ea5ee6d54ffab2556d45da81af9dcbef983e04115f9f84ed354b3f978f7905077d3ebe4bab1000525eea8d7d73b4347b93e08ee3ce4a12bca8be174be928de9cf1d4c0c6e523afd85f7636b47c2198ecdc3237b0b83c363ea3b58aa4aa5c1594b4370ca9372caf14d6ea712fd0bcd73ca2881a66bca93b1e1296bdfa6bf90b65f5832795290cac249dbec87c29ec8ff88f4f81c31867a1640a2601385688348bbe4aed4bd22c372dd64464b70a42eb9ba8e6d58748ab18d20e300464772d570087bf060efa7f4a8e007fa10d8d85960feb44a08523a2497be8f38d4e620d53a23ec2a9556c176a85a24eeef7b7d41a3568e94925b10b47fa06c637b2df868e85c1c2dded609abdc92bbfe40d7ca26b8a6fa7e52074afa018512759be32866f78975aedb15e904d1d6561935ac3e1f6f1d13f8aa7f8d99a80320a5269942a542cec44a372cdac108b896904dca4b4dfa7e06f648b37f080e1a6b0ebf4a0c3f2fb7a331ef21022c898ca5a5866b629d7cfbc71a39c50ae7972db3107589fbfbcf52b9737c34606db58ec6f35b78c3b1e5be3773219fc2d84fbe084c7f14e535860842a299a983ad6ca284b34b37bcc4a7204eabb53e9e0cbc71c4aff5a65c40d8ccb66e50cea892752c199558c4e48f0604d5a1613400c0675e6a33a293e4d917aba1e014ed31e110fe98efddf57f3df1bd4ccccf839c7e9d6625bf133ec6a34b7928323d7d5c3601c084db59394c0c19603c8b0f8b555da2744f05a908590af12d965096a3391b85955893b518b2f474f7a8a643dd64ed5bd629fe53552774f2d6c94697b12b21176e57ae713d7668747bfc973a7d6bef17599a3c7f16a8838c8c38c6c817edf85b33140bc4480d1b1e49ed5b1111abeb4b49e27dffe8d71df73bd8e5c77dfc1f85bad932ce9c231d4838afd5482b380f398ae5421f108db9175346ea2928e7f51bd2b4124300d8680f6e0e50078181729abf585f8125c8aa333fba7be6866711846338b7c06756fe84c62d78949008a988761a327dbd41750a631739ae35c751b2ddabda45a5a923520988ef68c6f5e1eb314e1735564c2a9a8a34995e0710ac56e3b05dca03e0910e3dae0f120eb8f40b1a1b7430f94df30f12d0d85fb41b0028549bf10871592235ba3499612d1038107318c3a3b39776a77818ad7edf7a65297152d8671bfca4b0ce50a3f3e263eaadd083b94615989e9215e21656785bdbfa41c82d78e599772f563b9f486ad4ae3d736d99e7f10409f8e6778bc88ba428b7054418880b02a18c2b1ce9beb7d5232d9d3986ebc99bf37c14bab784d06688674040ee8dc6218aaf69282818771086e7ebf4654ace275358da9019712d6de5da261c23674b170a8a3d14305057ae29c52d7a6c555d229c830e9dc6bc0719e1f36db5c52d6194f1f3ed6f51e6f3813737b929c054e20be5e911703a4d21c107070b3c6ed234ba87bb1b277daf4daeb220dc4027b3f7fa121a464afda6fe68bef976c5ba54c14ac56f5dee5d60b3d9fe2e3d4b125a63aace0275c6b3ed19f993c565a1600ab5dcd3894efa580b9b461c0f19e80cc75d03d92ef695a8e1ab612c2701e638276baf5467cfe8e0ae85a5784ff297d230dc5cb7ab09536ab5ee670cb8a8859c1cd6bda44fae0bb59ed9edabe9fd69ad473ef6c91f856856b2027052e26b1acdd20752477f40d9e571648d1e35e37cd4c2b0c724c3d72cd3bce76202d85b3c5a25c92eef2783302cd3d8c2940bf3a7c202785b4f399373ae09a9335e98ea3709166fb73ccfa6f1d56cd9eefb2b5095a590ee10c9bcd93bb8ce060236200e7b38b86ccc1b093c0c5c6a30fe21aac7bb9617f372817bcdbe004988b9de18c2b79e15d4ff6994b66b95f43ae319627609790c670bef4eea6692a463efd02e80e58a4169567297d6f3cde41c20243664197b9212dded7f642e3bc81b3eea60b6de96ab6540c7a280f77f4f568a1a78fbe127511368bacbd145c087a8944cfb22070075b2df0cdaf20188e967f210bee38ef0638738ea32a3609ba23bf4b1ab3ef532dff17ea24f69282b761eef02c0ebe5c34b9c87e07feeb4c09832c5112133638235632da4c30808ab8b84c5cd031434f1161479a2b47dc4cdc8b2661fcaee64e066c6e7941ef843807119f798d7b2668dc71c905593dcf8bfbe0e42377dd54caa134a797c2c68ad4fd729dbb518ef10017082f6834d03f08a60e766e7ee9a95c7b74833ef3bd81776f9c39dd70a953184061cd0b1253871d38b9c0963d0b87a3cf255d8f7f5ee23e2911507dadcb52433964eb2db20c8fa17ed4b3a40db842b489dcb5f076be8ec27e63e5610889c24cc07fbe184b4713ed0ba080f0f5a38ae73a91725d00bf3c1c2081366cf6bc3905c07261477bfe047be482624b0fc0883d8b5596407680821eaf40327413d097bcbb15db5d88139daa763de28a1a72d97e76785a79e205705de996ae8c38b545b8bfa54a3bf961e7ad4ad0636f9e689d03af40beb5d4741128bd8679750a0e31e02f3bee30c94f5384fbcb54b526b3ec8e1aba2ad09fdb03be754766b7bd49725db62c8ed836f78e36d2f5f68f92f4b6f2bb2d54c51bebf4da0c2bf68d13197335ea993a42d4484d95bcf91b182d166176540cdcdd2042aeb36acbd411f54de135f91eaae4addff15629f373270063a5c1ccc71a5c0c38bdf193be5ef3b3a67ebf0743088b36d2b9316f45a232604c4f0fbd45f834950dd72f2422cd36979f1dcf9a7d3d9268ef0d0b4984aaf12f8aaadf3139b433821114372fb76c5a248736051a9a1dde3af80b448a35c79bfdb66eecd4873f03e50efc596b24a8802e5776d1b0f3eaf41ed0bb9143bc3f692c2e0805b21d609919f4033640bd7652f0ff5e93ced2c4ce76e0f21a33b263f362e7616f93cabb084ecfc8c40353aef64e814d8d057f488c3d6248b3b55318d1e478b384ebd69d21f5aee856a51bc9aeff4db2fec85f156c39c175aaa753f307fecfff9653c55187e2528f48e34962c49f3426f390a580d09d0e7eba07709a51dab2e755a826253e2dcbed2e196ac63901da1f1c078f2502c670274c64320c22435befed84023bbbf390234b5bad38d3362e46c57500d8e1dd8afb7abce142395ff10f0f50ae7b3d29b79c9a564e2085bf56653bf34d34dc24cdd18270b814370650a224df15bb7b9c2bae0cfc30fe156786ffd045acec85846b0f381f0dee0ed97da627a34cbb39cb0b4d86cb229f84f086230e3db78dd8b83243560489b3fa4010b5cba0eb99f20434347fb3f0b979d2e696e4b08bce1102da35a38afdcfcc1b1ccb8c22bbc251c71ad92a5b463707b2da76a096b8522af63d7e082bfde81a78d49db5afb96e9b52afa49791e89e940017989c6caa54f25537f58f7e80665f9cab5cee39b498ae89c6017a2e5121d8ef505f8bfc401a3a72d9183b78c95d6f644b1f179a48590662fbdab20443702cb6166390e4076afdcc93aadf6a41068976469f7b03b88213f4919be1db4ea47ebbbd4f5eb05ea2a73fc39cc70a9d35e752c718ad64aaf92b9e6e0a27fb8de3fc27f37985c334837a277efc560a13a34752377e8761b7463e0c09092a52318e990d6327c9c0694fd8227fb819350a20a40904b0edbb41679f3c5d4d37ce3241882f0c279eb9e52e95f8bbe273bc5006a806c808f8eff3583c8370e574ff52efe5893842dffbbadf7141789828ceb87084f25c6a91d9e5c9fc961c9ecd990481922dc1cdf8875a5d2b9a8c758d87f7e2fd46e9d1421d250ca7b9837ab35ab3419cce2431526755757a7542bd752df99bfbf22ffda22f46dc2a847aba84f3b12a7d09d55273ea5d872839e129ac3d65c51f6df184e3ea238fb587e3eedc881d5686f1275dda748c7e377eac63e50bef77a0ae87ddb7a67a3c71f68ba997c7a6419111d11f11fcf26aa1dfb209672bcbd8ab7096d5054a3633541bc1c0660d407e23eb00878014778dfc2bffd6c980c5290984563d0af79327b22b71cf23708901438b1f932b1914a0db7691e0def616bd3ce643fdea50060b9ec7bba6cbe884be0fc60a4a3d163a3440498679b9355c649367d1a849b151286f34591a1fe4fbc78bf20091320e7b36d3d77f77ead1d1ad8570d97a08f4a67e8aff7ba8e06038d8df14d6a24f6e5ebbb79deb3b82ae35d98ccc5fbf1db0c7100b0dfef52a6716b6a75b7335e9d39b28872be1c72fc7f7b61f37bf45a9788395ce5366914771526ad24e0837934e73e2fe1756471337b021900f61127a6cc07178ad3db04d9f9523c10b8cc037017209f9fcc708e62b3c904b0e909f6396849d2cb8151dc3780d775d6631dfbb1f3514db2d656be34139d1ac855c43f3ef825d2ede53b96f19bde4179db374098afe185a1868a73b510e765a6663b6ecb48cc31d01e01fe4b2901c7665b563824aaef7d0e27b59927d02cfb851c313b01cbb0f44bd75f608f3fe761ee1307b44aa1cfd280234c6aa9f33e88cc9b9c472eddbf99463e68a8c20d001b99c6796e260762ebab712f919c2ad4ba75c8716e9fbfa522604f980c4abf93bada618fd7735d1da4408e09294a1a8b104e48bf29acef3a116713e10e11fbfde1cb4e00250192209e97e192c193c2a92d5b55ca674f598a30f356f54a260a75270d47c203d11c4a3d85364ede53d19b62ab7adb9e8ef568751b2931530e62adf1a2a752357666e04f41a5148b7c79490c2f3b394c7951a567b0dfd23e457ba6c3949733244f56ee10a38e5b92e4b274c77531d9d760771374c4332c64ea5b7d85762ed3a4eaf055f69f986bc3c89cf8b52f6e0b360efd97e21c5c5df293f5b05f4e3c27da6ff67279bd99b24a98320cc910b3323c1796055b28899b5a87027d77fb8140d3951670c2e8cebdc29474571cdf83333b84da897cdd9f295b1723b945681dfb8e27cb7412830a76a2289ec861f6f4a689a438d576939f3215e137dde013264ad2ad4409a695d54facbdd1cd0078703687d2b2dc9a4a9ee4a88b9e969c82d5d78306fd7619284ec80319197cf4c70c4ca76231407d07e1cefef4ce0edb3487a947b82c1edcd2cf60acc253a5aa683506541c025bff9a64d41e4f0c95892d2537c4d0ee0ad61d6ce27e7717a49bca54f890ba5764d8779060f0d24c57fd0a582204d35b654f8cf7826ae6615f189b3e1d0e6086edc806c14b4c583e2fb85089bc3ff424e7fcdde355c61c8069debaec7510740a8386319cf3470aeb1a3c5729179ea6092a902debc5a3ef928f33a6c633b8018a5a546c45a8325542fe5184fba4ee3f611d47f184786c7af9cd436c87950f74b92b74fd3a3e306525dd1001feb42dd2f82a1102f0673c86270c35749201ccb2ceecaea288c1a4d997405dfe16cc90c1db48c57dbfa8542fd858704f8c2936ee9eb4e1bd63132cae3de1025d85cac8eeb3391263911f2a293c5c1cdfc46f7cd2c01454a05b87d95737aac7becbf79dc57593b3edfd92d6d660b01bf1802eb7755f32b50e7d0b71a43347e2251f8f429d4e7f14fad1c3be090a4e5e03ffe28228d43639d5db94c62821fb9399d2385ca94ac2b0043af2f21e5a289924872c2d3ed08549cfd3d7cf43f83605511a9a9331fa8368d4dcadd2dc6d769a5d01df0eb5ca55488f0cba53a8fcda6b83966c42f8a6655d9fb74315c470371358459e53719eb746526fe6d09e01da9a559a9e9886d3214cbaf96451f9a9cc1e091a984718efdb42b0ab736c8777ea8519ee8899630b97ef72d625b3921b9e842ebe9c2a775d69092910957b83baded8b98d643c5f8c44e6290bda9f028b06f8c5e7849dec33e4f1153f0ce418289d725db37d7c53cb1376f11e6e24a0b42d4f410bc5e4f6aa78aa7f5e5a7e6017ca76ba62cccc28af662ec6f16a13fdd298d477c5adea4ececeeafd0f7075a872c225715c9859d5f64f6b1fcb643c022a8041289636699d2076a6703a771dea851d84c9fe234ad537597f70a772723a19d82cdf386fe2be973ee578c4d6a5ce9741af8d749772598db1db2b079735278b21156c6a331e0d9f601179479cfacbb324a9bd9ccf78791fb1f110cd634d159b740a4a0e798be5af747baff75194f58581d5acbbf0ddb5b33024920cd9169b1003e652cd7d0b6591dd12cde9417104bdc425e52260f0c89faa9bf829c63c033aa064077f4fc48f0d825cf878602a30da53558fb80cff9b1090a6e76776cf2a4f62b4d7c3ea3a9356edc348894330136e3ca52e7e2de577f4b9024619afc939245dd8a26d617a36380dfaa0d21b221911a55ebecbe70b11904e9924bf70e4e5c55bc8fa85159befb1e2ed45f1023127c05d9205b25d85aa9fc0dfaf258d85003d6d0444d1919e0eb4b331861d9297e9b10596c1507b47cc45154ca2207295c87043811262f277887ee107d8c10b4895caa0e588e70cde243c57ca4344cddcc7797134e7a3d2efed6ec59410ea266ac5bed9a03099b84cfd3907be2b4cd70b46b5dbda3d4c7da92a61a11ca4a2c9dc3dc28b27545b43770a693a9f5cc30333f7f6c9f074ef3060da78a3f61dcf4dde67b76e4d674ee722aa0282ae561b8cd28e55a3c177d2da477b04a3f7e93844fe82e316559a582ce967b502c725d350e83afbc574af0a21477a7b1fc50bfc9fb74cecd9e9bb8ef3baef1c60afa979f8f16fbaa16671c82b1d53b879aeeaf1101a5b07683001f0ac864833e3ef4fbef61d0e3170974ee524dcf9fc372a43cfaed58c791b76d30cb50fb6091639d9957202d912d7137b75afb976ae180f3bf3f46d7e05b15bc6d14c94d09f75358173266c05f4074eea5199c44cfeab0b88f5dc515c21f8a90a12296b498c5148b84115dbc0b953ce17b52df851d26cd9798e3d3c8fbf0c75cb48389802bb66e8d86210be269df38bd891e098edd7f60f40b82a9cd7ad3da305b15f65e7583b4a500e28f31ea9f79dd38af4bef2967c5fe74d0c89749ce61ec5cfd20d0076218bf1caad8e1ca69bde27c79da52c421155648d3022cb7ca6a8cb04b2068932f80b6574acf23927215263bbb0b39366841527da38236f1062c8001f2d0fafcda8d94225d9d54da7ae90dfd26faceb828ee97a5dd449718f91c26030762fcb5d956274d8987d5627f6876586f02a210449d6dc177923af65b807faf329364ab0378bc2523a757c426d07531cf1a1668ceace0552a4fc45daa9b3a020a2a72e8d0328a16d1250b42f44fef3a979523f63bb3cdca12c7f282fa7d76739e10ebb6b8ca165b3ffa2cf171d053c69e813ede9737690f2503c2f956ef4df6782cad8fdf134429cde5cb18fd1036cd36efdde2df2bc7dedf9fa230af31b2725bbfbe9fdc1dc9a51856eeb105710ddb9d2515bb5342e456c531355d3f7827e40846776f5cfd1311b6349bf11b2491299b683d490739b30f5b66f2bd5cdf2e9046b2367867ce1d00639d910f5e9ef6a2b91c36eb99170651c503ceda551adc020df87078ba841aa8cc02173ad293f8a2cec6375410ec565cde483e3480781eaec8bf890d5867c6eda88743d7bb9aab42eeb072a9bc857ca1328f531f2d1ff81a1843ff35bc392897135afaadf56c7f91a8a3f9df2fde73de4c1aaea5bd0a1f556b0b0529a998371091510b2fa18aa3472828a8faa1b0e37bd2b65726971edf9626c4a84d0fe35057db0ce20a9db12fe47f6ea53d75cff8795cf44472579fd4220545695201f5ed1198496d9bf2fe96a507c0795eeee43fdafd82d9efea217e980a2d08d5a625d7f79506ff5207c0394131fd66618c1909f1bf80a6747dfa0fc4d73abf9d863237c0a977ed59f6a72620d1fb7a9e5e78733bca468961cb8bf5f878e5859684876e64b7c9f99c69da529890bcdae55e2b12c6100169e1a0b4a8290dcf7e12ad0f24f2ade74067fb44911bd88b0138f8ce186526ffb1585a8bb3946a07cd53d383dbd11d5a9870cbe7ca08bf1bd6f50b313de7f0d5fa239d08a4353880ac36282b594c5c3278cf99247934dfb9c4aae4d41d65bdd7ca2b49b09494625a4c73afa7a0f0aefdedfa749609f94e4b2bda17037afe4187e9d2d471cc2a9db988324ba1bd5d138aa4db6a54e74c7062f41dd458169974961bcc93257bffa03b721c0584d7633a5361fc5210d15ba0dfa1550c1743adace37facbb67fcb48b5793b9513ff33a30b97603a0a2d19deb0c5d20d4a933348c49bd061b22a77108a6fc40c33009702e7662f12e01957817be41ba1d1f4dd570afae0b33798a8ad3d455c6abcee550b7cf8253fafe61bcab52b6bc6c6f9789e2bb0d2ef3d51e810022b09eb30ebebecb5f603fe2fab0813dcd31b94b74fb8730c8b2c771567e645b0495b315ac648bfbef59118f34dae74d221330b7edb94d7d34e9eae3e0c93bf622a8fbad8859ced3429df5610b4423a02937f18385655fe83734bb9176b91ba283643bb83a60a287851621e6c20e188f1cacc67d8557141053ebf6319b13035794b239c83ff480d3e9836f5e4d699ff4418caf28a8638255ce8642a29691201779f22fe96fea492d5ec15782e2579b0b6c39e8869a238006d3cf396ca0546c0445801cd2d2bada3663461d09926d8ba5e70f1795a8070789bcd0145c07bace995352b8a695bb0d4e7dc85790c19e836c365085b4e90e6b83304ee0b3567acc76f4d08d0416fea6d39aee5c93de947bd1b86de25aeeefc2a3c5949cf93e156e792283f119f899484f020e6416446d6df569825a0bd0d60f700ec30522572cec5d92419d57238988f7e1737153462f0d7415a3c8996db0cb32dae75928c0a64fff19c34df23c162e5ee1145cb7e56f93d0372bbb96bfe5a91823424be3c7e22e9764cbcfb6578af5083916a52b2b93b70d51de897b9cf17b140381c767b23b2ce0a967f3ecb13cf00f616329fca7a625ce2112ca0b26e2a8266e9c73d7b4c8a21ef6a65c9cfeebf2caaad4c833cb014877b5b12be9efeeb062756419e3b397e32331af5fbd7f772b7996b269523b9576a36cbaedc36378d424142ba3c3d4186c0ca906aba4d2888527637ad2ba4d9b150d68521d7918f4fbc698b52136ca813d15697d3d92a42cc45f6aeb1761a3731f4b8f2a4d9b99b0ca25e908f1fcb861e547705e70c9555a1506060b80d05cf1cee383d2517ced98999f4bb39942ddd8602bcfa0f5ab4b713dbf09ffb9d2c94ddb935ce1df48cba7a0bffc49c2f8659dce5046e7fa993e801031f424349efdb9fb771534d1663c95b5ed1af3465d508f84bd2f8b3f743b6f448bf511399c41be340282538ca3cff04c1d9f9160e571b1ed9eb24c25799ad82618f1cd0ecd23d733d6dd3178a86abfe7ea9aba0f4cdd5adbc842c8220240694b4e3e554dfa647a4f2e9a84cb0e7ae39e92db7c3681a1c2d296b53f084c3bf7f546c46dc9a70d8fdee067380a327809a55c689f0b81da4546d90221f9376604d27d314091133b80aa07ab43e4af36fd1476bf5ebdcef29ec87650464290ecd13efd84a3a4744f0e63fcd1fd3359f9074c21e51eb1d46d27c53c7fd48db32dcd987f68cc15d682608d148df3dfc0ebdb7e1fc0283fe4773ce47d64d222e6cde1d782b2c785c019de84d9bad788f843c105205dfb8a8ae20022f2ea25bcb03bfaa963c7aba9cbceae59dcc206259876b5b4e0ae56c3b19a2405b016bc399a98b66998235592f1c522e497225fbbe39811323d0b124aed74b01eb0e1c2fc85fca67e108c4fb6acc7df7982d77eb82df873eecc375dd15ccea07fa8d45419e4f486006a7e87e2a0b7297f2d1b7d1461c431d2b0a04c05ca0eeaf23c7616e1b707e288f29601b5825cd34877c9dfda4cc8a95040935382e4acb10af9cfa86a6baa197be658fabadc1217491d214b0267f0629f2af082e71a5c149445aec6efdf982b9c3a41c44c0deac45f6e9505ee1cb24bed002ec04a3c155b17baf19714f2719c4bf2193ee3b40eb643fb1c73ed11f078f79ecaa38dc057e7def69cee1229cda8494d4567b5dd9222011f266ebbf525d2a5489dd76e46e13f16cc08cf1e9e2b06fd62ea841c65a1b522509841fa5a21a979f6e14680734b5fe0d6ef7eedbc1b06cfeba38334ce50338ba1f58e2537e37438bad4bfaf1195ae9f420b97ee1cb8f44ca299d997bffc851f7209735e448e0c7d3e27261ab52c148bd29a62dcde8ebbc22cda3400bf7a6eb732b5eb6f0fe6ba01985e72ee27dcf08ce51961a22e0fe24df22d22208e5618ae32017cc58da4959b1f538055eb64ae12be0eff064e1a9df8276338e9eb049578fde8a1da0a838e564b0e541d0f9adeea49e94857d106d85dd2d21ac8eabb5165920e50b2cb50abfa47f2fa1f06b86c3803394284ef2008977c0c7c3e75e55111ff302170ec1d93c6f063db71c858439b0793041ec5276c1d83a8f08abbedcd28ba265ec27e1aa225c631eb6cee45af8526c9db6efa9ba8a7374c396946015d2e22dda5a6b4a4b772b719b8d107b8ccf63fa743e3ab5612a246c7f13533cf00dc90ef3422f407f2d70eca7bc48ef9376444d72b112dc3e754a4f505529a6268d229f510578daadbe2112df505c93a77bf5c6d85a47eb805c340f136b1d1e906ab8af582c0c91b15ed98b12c68e6c4f7146620df6a01c412854415204d780f0e9b7fe74521216fd6e9a0c88e6a02f4dd7bacfc495577e398f7d5b75c904f146a94de819700fb43ca1f7a806feb29a83ccbbf1026a10fe9768eb7b27044295511efb055f4516e0ee25c9d62062964d2ee997693489d970570293d86fe1f1610344269e29a440a248de3c210e449a2671272553caca34ca619f59693be24b4ffd0784084e50a829b5801667373ee8a120f967b4904cd99f0561ab32b1e79bfff8500bc8593a1bbd99bb27e5d874b5bdc9272a6d0c61239ac05176d4c6dac7e382d3b0b9c746a9e56699a415d9710218b8cc7b316d1f28b6cdd0dcef6d9dd2018ccaa130d594fb5cfab88b70c836f7af108b3d3cd85f8206e3e689a2c6f4925821518ef9bd5b9f14c4dd0a065f1b2b23d3d0f23cd616cb3ebbb4b30cf77371d5966e4d6235afb934d890469bf1d22ef6f5911679069788f0ed47611da40474a11e48bd6c6276e55cc1179752dc0d989c38899af077d483f6e48595d63fb8b18a9d2732c710741e3c25cde76332b549c62ff4e0ebe5ee316a108a50e020021d436cea4816219b4122d403fdd4e1e95664117438a91d4b7bf082e109a7ecaeb6a364724ced5c654b6ee31ad0d520b9715ecadfe4f987dbfe22e708385421e7ed4619fb90ad6ba1ce76f3b34eb5ae6f90cbba740332ab48ed66e0c0ab049c29be6c006c1c6f1374105bb59b74a7dee710645ba100e826c9981927420da5a85eedf3ce1c17444315d181af97e78c502b8bbdb41749289ae850443b1a8dc23e50d5c4cc34c8d7b6a4791d9e73e71c809ca3513d0bedbe3fd59d9312fdd9c3fc0bfae4982f3ea5efa63436d2d2bb860a098e9931f717f48f51f9409edab0eed7938d5429a62389f3805b37925a18463198c046be25b9554aabd797d4208112d30580d29175c07f5cd3126868a9c892d862a615969e566c5d6726bad1b484d7b85ecd182cb60d35c08cf9c71e2283c5c9f496421d4f8f0f3a351b3d14ab254decfa79e1fafa47ce02e98f47a9a1f8b4513d2b125c0daa7f6baff2205e30913346910d554120e31ecf7d6dc617d09d87f71c025878e9f2ee99b20d4827e861ea1fd5a79224b921ebf169257acd92e5e90d640895cba45f9af7ce1b08268927b50a17fd4725f7da9b15751d27c46927d60abbeb87af5d0e180b9407b48a619836a4ea4a1a18a4e77923c16762d1bbd648e8f85d4588d5a6ae1ea588e3d2264a2ab4a47e8409a180e262f1ce28f53574fc1ae52e3bfe0eb9283ec6714e4af657fdd21143f27cff77660548f9b16da37174280d44103971b920959d2e95e41b5637935e073d605de183e60d8994ce48888d72d757dcaff6d861584dd959e48569b1961eed414c901b23a2f8d0c0a14854e3e191be10734d52933277ef8273eba442bbd99da8dea2d34fa792c404f31ebe799cb9573f0904afefeb68b75ec84bb9cf017b58bf9439e0cfd0c36966cb71e2b61b2a99d28428b90d3d1ac570f2a73f3ffecde11285cf91196b871408cd25994d58a330e605c1e18f91b739e837f423ba8988687484d6d3d84cc3c715e79e1ba6e86191afad02e55375e8fdae1c43b527349718d99132ba7460e6763aae519954144554932daa30b0f2564c552ba91f3e7ff392a08271c4279726388fae6336a0606e4809fa103b414f00cc5be1f6bd0da70cdebff9d087dc197f3e458b2a31b63afa34c06384306cd70818577b7e2da1665343ee4da64b3670d17e3eaabe0d9153540108dd81adb8069b7e680be39af71a729700f3ba56eea4ef9afe4f6a3558c4aaa06ca1898b0da4970921828fb3700172479ad6ef6f6a0fa94f7265034970a694ecec0fb5848b9df2c3bf98b2ffcfb3f8ba727697f03b718878d8041af28ea0fce7609d92d94cbd4da5bf60ce4850de12230110a5e417064d515465b3b488d017faa24bb22f5e73e6b25e14d904ec4a264fae9935066fe44c77ea948ff669471631e0af6d5b31f81c4eb31ab30eb48dfc0502207863074ef1cd6318fc402e815d7303ae45e1b42a943faeccf55f6d88e53052bef3c7d92e78b0bfff67900aa7ef5ddb9382eb4aaf24f48e9f9f7b3d4b29e0168fa1496dfd42656d9fe351be4b46b2d7c120184ca80a045bc46033649a0394b0695c652745d6b2c59724e75c316ca44e46e52beff8c72f00f33e43bccbdcfbda005b95791996050f571725bc0c08e2424a0b67ccd4a06a0d215f1794996d0eb94d053d22f71897ef933f34a0c436757e59bafd5bc8ce1c6aea262809434eb5b7469c411b0ac795b4c9d26ad427765195d4517a96c1bce6396a4ccb84bed97278807496a737fde107e2dc631ebd19b1a99a8f47b49823e507cb33383b86750e4c2c673ee7f845a4acbb8229a077c24af663b34fe86b4bf08408a168f77723121b7e57e272fc2f53cab4effcb046034edfd5fbd4780b5b0e2439728db763c5c93954bfdd6151e721664d9e62f5c86fc7f631052566c1634fa42238d94e4f5df9e41ccd605b08f213f17581e86baf484d0b17ac816fd40915d4a4131d21478f571261185003bd99f80a74f93b6701e46ecd71b666245fe21a33279fcc08a1783cf7a62c0a4d24136c2086369407e739c684ec410e8699ea3d1c10665ab36e36df6f94f8e69c4cb0bb4a74a9087292c66a29fd903cefff8683cc89f69b57be5173e66b22b508e2c7efd2451e7dd08fb07e1b3415a4d53311a2a3eb9be9ee2e0d5520ff4a6fd6f294ace691f8f5b83bf7d311d59b3d95eca931a24b75cead400a4db6cb06637180dcfb31e1d6de703e27fa253282d00030f6a7c9b123c6a4dfb5e663d0a13b39f9898d8540f62f23f8d85b6240f576b05d953cec7c9530c2d52750fd424f34b2680b70e0dc0763f02030d25da2e825594f8e84d1fe1eb3f9a3b3d6e09370747ebe7c60516fbea71feb4b1282efcade4e7cade134ad1779eb08822be69570d03f6dfcb7d48079d233adcbe9e89c7631aa494ca7d295b971b8657368dd2f47a2c1c8bfbcb5aff96b4b2145e80a7d88b865b5de571f7a516888f1ac33d4fd9868d9c22e5873aa73cf6a406fa40f4c9f55e0f2c94c1f3be97628286551378d68b4354be7faabd48f8e638a0241db5fc2e551f05cea962842529ac030b08061b4953bbfd946fe2a51780aff276e85fa361bd32e8e850184cc62176a1928078b52a192814c7a4477bed060dd22755b1e9dd7982650672fadbb9b21c19126b10c456270b4e0e23a0448a0dbb5bd5a764048ed1681388d2e2239dd9543c58a05756af519af92358da39a1e45397a902d061a7e6e62a58ad7ab9e7e75d0581518cbcdd9ce075e14bee90784d9ff13e93d432260f3102d989f28b9f880dee06036708b7e4eae4e5ed034fa04b7ad0d129abca97b159aeb1db248e25de727e6f5968a97862b201e18766fbaacd3807be52348633da57cd8e6411e6c466020a8ce384724852cbfbb66726dd20367c93d8670f0702fd0b1c476ebddbcd7c9c192f3cb81056fe989e458d136cca4453e14246711b440d8ac8d0e263170ada66bde519bb763a8c0174d96a98310d2fc4c1463a2d684e01e4c2472e8632808b89d50620eb13d6ed063dbbabcacc1fd918dbd87435f2c74d1d4a607f130fa119f91182f52dcd7a87f6fb6289d1d2e637946b4ecbd34dad3d88434d8f612623cd510b17e170d0ccb0a6716d7cd833b0aaafa49b2f6c5749572e7bb9d191772811e21085f6bbca05ec7cbedad967e3ae2167b564036322d5d73382412a66e606392da9014e9a1e1db64a1f13b9cb8cb8967d69adb51989880255481269d84f575f3724318ac473578c8eab03a90b68d0bc1c023f5900f41df4a793f137b5179fc21dfe13bd8b4e0239c789ec3c0e0318c556f63a8d7a6b958a76497fb9ec9dc6e6fff6e9808bd3da84eb54da44b6f47d972633fad3debd19f4d3c2add2251e916e19bb6a8de1a9d8c1e1e34ef7822a1e293b4d9d9b951cdab4b5468b5050fd2268f6d397e165aa3fc6a1af9f15ebc2d66dcfd9a060dfb618f2bdd32e690f93827c436f82e4bec49c49540d9c73d5ce9f3941b095bf903cc726a6611331c59dab5487db4d84b8210026805efdd47498d7d61cfbb0e5119fce972739cafe3d8b242505b135b14961dcd5654599350cb2ad703e32d8f9970173c48c4982c6ae9f05ab32d20c2b42ac775c6975c16b20593e59f8d7e6356ff24a7b88b0698f177b058d4447e4040f1bf25551daebb98f5f64ef4bb253e18f9012451f13990bf493275bb73ebb4018ef1c1f9a1cddfcc6e45950fb47f3f9ea15bd7c1a80a1ee6c1f4f39326c4cfcefde45a214ae67fa33605c5f9d2f0c95c3976f9506800dbb0b78b5de3d5f8a4e773b74b03c0747fb46d269916b2a938dcbb112fabea9a22768801182b89b8ce6512d284c71ee22c0888d7e890f3369530ddc7b827905f34ceb3be6bd635fe656b51337b017867675ada7c9aa1930a3d29fa280c597457ae281bff1dbc3b70f58c9d1c5764b4a464a5d7e38179fce9ca3597a775017817ee8a0f629117b14cd9f20375046ee7fe1ee210e992687c44a74a1efb7c2a45b8f091ced726c6f22e8ddffaa98eb954f0139d399835f777a9fa9f54533cdef3f7d1bbda32619e2dcb71217a3493a8436d394b583fbe96652d19a0297b95fc7ada42df60f39ee77dc5fcc6222973c408450ad069a0a85534fe027d48e47e96a445756d252188d534c39bf5a85dd82a49614f8a7ed1fb6ec325a5f82f7ae8edb62a063dd2d631ebbc9067edf8ffa619573b14b96943f64a028844fe3784411e53ef17ddfafd9b29bf89600d772a7b76f4af974614e8fd638c6d33443dbf0b64eb869d3f60bb9ab2ed525e381063ae6d5a54778077c7992de11e3e9728a6200a14490197ceb8ae9d4ac7142c544df67ba0f3acaf4ca53f5a9750adbbbfbf74d235c31acc4bdf3e45c9a92b7fb62fd9a9400c3440ce117c56d3aa6ba585a7c9f453b705c4b3d385e33a4d72658ae1bf095a871adb95d053c37b8e6f0db633e2edfbc5ca3fbe6a7373cfa6533948052a4e5a913f2f1838295d9bbd86cc7ef1a30d662cd7715522a1d1e3747fc5c2481247a096042f337666b0151f0d46b8c3f25436db494e395937b393ed1daa892deb664e945035fe81e952b5d7460191f51242aa37b0496ffd6da434e6cbda8bc650cbd711cbb46cd63c6a9acc9a2cbaab0ccef3f1f8b934fde98847c56eca40de569f718a86a90cd26fec2dc38f9b66b70928f431a5f6045ca1c9967db14396a66d623f2cec4ddcd509e1065f9522d74ee7e2ea59737491a5e8655fb5742d0ca47da44672146ecbc875aef68ad85fc21e98fad4c64958dafb633f83b70eef3b517e2c34377ff4ed4b0c0dab8c12d44c6f86d5b29983356145e8f5c30fa7afa6127248af7c239dbfbdffec8190f09156ff1f8b61d7a01543a6879f8429351f05d2bc89ed65f4f8e8935703637c8c7aab69b32ab82d98245314618ea4608bf692aca6c56f18de72eb167d5ec029645116c917430540977d499975f7b85e5d499939fddd6c4b6db8a463d373e2ad3a857c4c9862c74156e16bd29acd37f653417d7621797d9d2876f31528bbe9e69b25e5d5a963488171cfc793d981a45dd4e26164a4d3807c8b49d924d32a7ac8307d324823ed10df085afdbe53f79c7deddfa931687472e2685fbc21e054d0e43f9e8ae7f228d05a1375fbaa24746c1741509f44836c55b675f3d0dfa7282a6ae9637e2263c9f49505c935278995dbdb634f7f6b9bf855b74b7e02e154a754a9c1eaf80f09ee1073404eca6b0708bacaa393e465d8e4d204564291a1f595c4d53f72aeaf6bdbab134b0e7f22377b6f6083db2c7495981102cbdb04ea6914ffb91413d6737416e916c526eb7e0a14f6663dc028f4ab9e6852531fccd00f68f17ffe7ff890d2399913eaf13476f6d787ea73bf0c574f121a2e79de5537a3db4192c16b55ef2ae3f1dc9c89d85ff4fb8a4c6b8a86df685e2392afeae924b25d2225aea2895fd93dd217d599a9e6c0b949904221fa89ddf92f8f4dfaa72be430dab6a0d3c40329b6cb7676554942e616107bfb466ce7d316596dfe9680d96a8fd8d9409d5671dfed8d87891e5eca27620fd869e05940b2d6a089f54bc9ec70e4fa9ccfbeca1e3cddfa9de531c373a3a74e3be5a5443dacc0b032611beb5f48fc7a9426e0e5cb960e41c02267cce0b36053e0c34ce9b3c3218c93aff313124e7c581e8423671180f983c8338e3b56a8acf3859da71856d79ecbd2a7726c42cc70737304c5e55b61df91eefed819ada77b8b468f6c32258edb106f98d093c37f8734f4e97c709528f3833216262f2ea8e417a2192d341f2be5b033a8bf6c07555f841ab3f506dfd14bc73257fcccf88265cbb7333068743d7e68e1b476df9e7aabd951c1c445bf47597d20552d78caa9f54c464997d5efb9abd12fdb7826d5a8159a7665cfb7569bd0a7043957ad4650c4031c7e72e1ad88b1eb256ac2cd4135a9f395ad354c744e431a70c995bd3aef89d2a30be28150f322aa72a137733f6a3f2dfef0419d9f8a9052986a169d03e9f73bb38ea75c01aed124de6a52ccf5514c9175814c081df2368f0655c07cc6fc1c3079f969090f73d52de8b63f24e3a8bf97c8096a7bb1d1c0fff39ef7263f370468e6d843009e479d30498e6b2398d3050bde6e2bdbe93a325506bf0bd82836f9e98ed6705175a08e92e48e37fc08cf773392c964d373c3b4f2f15c22e7c535246140ca3aeb587a532f204b60e34332368e0232c00d549ef61f6592458477957d90a96a8fbd3a5a34d2724b794ecb532cbfb18f9ecd2a74e69adb8c8890743802fdaea2aa485f9fb089615fbf102c6831496ad4638fce3379365850e0ca229d3ba020503eedbf258b519a7e8f8da06961afd7a9de1a995574da14a0ad2476b971ebcafc3bbb67e1f87d6ae2db94f5f3d63a89c6e8e0aedfb6483efaa0bd8307871cbc7b828bf96956d2b168eeec7eada8fbc892bad3d0d5fc1e8624da88c382d264268be7d411150b53bfe098072c5b5f372a282dc8e90aa9a99583a89b1a408fc7165aaa8e6a5ee992959585eeabcc6ef77ae0f1b9e63d294f21eeac9461a9965a4116241c91a14ec427df89c6dd4ad721fda414a4e5925cdf27caf6d4fee285733157a1ed3123e95b6dfbffc9564729e735503f6ff5027da4dc9af04c018eaa32453c206e0846945cddb25b65dd6eeb7048b4ca7e57bc9881d806bbf3b514e0d8f09776bb5100effd4eb4c4d241b85dcaf73a0be81ececdfc39c8400504a8ad698705b476a7b0e6fc0a83c1f06d2c0da04d07fb5bafa5f334adad66af69f32fd691f39e7d1ca763fc83c1d96765b87fdcaef41a0d1cd270272380ca33216b15be72e30dc8329f0a48da7a25ce618e256926c9fc00d5d853d59c93f55eede5420b335547ba9d53b0041bc0e57294ac27a6d7b4c56081cc203cb7aefa29bb27a57c9acc676a6885949b49a18abda36feebe932aa305daf18085342039b6e448413ff0fdccfeadb5818fa1422b3e4b77b092aa959d237cbbf504a64ee5ba871cc97c7bd93b21d13cc849e2baf0a1248fad0f46d3c1cfd630bf66797477d1094ff56f8aa19422a41198b56e1cec983c3fb6b3a6eb47d1bcfc1d536f52c56adbf9bc7a2dac0deeb60d392d596426644162d05edeee72d52b76e80171a8328eedfd3e109fe2b6a5a9206d09a480986580b9c2ba2dab97891ae06e17ffb76c2afd044dbb4a091bdf162504ba35ba7b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
