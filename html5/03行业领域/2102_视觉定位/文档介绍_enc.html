<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"391ec860c8670c1982da51c196031035631e1765da71af8f999e8813a9ba1a56a39d80548a33efb94c53ccb56535eae31c69b6296a9f25695d63ea05542d7da78fce7b66257374502d5ceb7a2358cc1a4666f2001e939b6d11aa996b36d73e62647c065b6473268b0887af2fef8a2ea59c921cbc45d3f98275b1171649ae4f9ddf7ff8d6975e8598eb653089282f16b8b99efd2fee9c210ce63f2491b26b584be38bcf3545eb5fb1eebeac8e35fe771de4830263c2fb4fc2c4642652ad09dbb1a0750996acfb9a7a5fe5597518b0c558dd4e0b1377872e131e9a094765ea498af495bbd2673cea751ddb5c637054c9d3ee1f2b29317d2827405c23fee7b258421d420508e354840adfb8ddc5b09d65d883ae912d22c309d6b5f3dc8633f0e31198629a7f7615aafd2b2884d8791365b78a4bc2e2def3b138155fc65babeb07be1ed734b95225f0fcd3e797bc375ae3037c1315385b0bf174b12806fa9354a3cc24333bc400465f1075a335308dd3195c1921ab46a656c02412819bd7792fd397350497ef0b9a824b8e9d994358aadc6af26e799e9ca08834f048534118cf0a35d14f8d9ec7f7e51078a21e6067ab8022836af9c83f15e6cac5881895eb7b44a2a3b0898ea718160086126fff19c40fe86dd018483ffb7cd28bc2f3652792677ef0efb5c5de8e652b9763a99810cc2a13de063974134d7f13d66a8fd3d06a10008c2f8e2c18c7c0cf9262bcb49ffac208050a9c19dd637e2a9c178709f5601057a529484b37a00f58f8c318a1bd76ba4c11902c355f5edb7e4fa19aa630a8b6e3783f878308ae1e43ed46fd16f7ecafef12abd8cdeb6d2e9e1dca8b03ab308a9d3ca4cd09704eb16981f3b590fdde533055dfde08c0e2b7991c63ff5cfc35a830f5eaa90bab5161e240a49dadfb73e76fa483369392d07ce2d941037d348db60ec2da12c4fe2bdeeb4fb67cc9d5a0b8d0307ea518c3c3c4f412961d30fe142b5390c3c36de2705c8b416c86c25be2cdb6b45c8ffd0127d64b5bd528040cd796045769b355ea550ba9ada7c61973f84a2691d62e102d300afa06df03bfe25db4eebb66c747f280c5bc071ea09d8e047955732b6f789c8be841e511473ac9d30cef0abb8b3ca273d5185dd853a5055439ee344854cf29a0b9b1251624045526dc89e127229aa323af77a0a80cba8d07ba106a72f601dd6aad47c90eb2ab0cc521c77821c0ca4721ec92cc7770166d51db3ac840063d5b16458af30b57fc85b52c986f18291526f0bdfa9b86184c1c1d7cc23503de8525f8e0cf86bf663eaee33a668fa645841df5c767367e4a36936fe52f8395af6381be01100ea4a3598c1cabc7d51e30431741c8baf39444a2e7e95b81f68b2d608cb56526479607627356fc30ae9e81a7468001a706b24e6d2b3edc97ef50ea5210c9818cf7bccd8bc829db58e2aa04ba73cd6d9964c0194e027f53cb1820d68245122e9df4cc141e2dd6b91f6fc2f78d8a190687dd2183de3055ebfe54dc33ecfed46d931df9b3cb7c06651dd1ce49cf499d844bf08cf5be1124349fff24223f82f3520dde33b1bbaead2807482adcd21f246269cb2aaa58aee24428a38881104a922da02203ec6ae778f34142ce6e3ebbc3f5c135289cb61826625cc70c010a5f1f3473b3aa95e051f14196a645a9f612b7d8a8e72b05d0e87a99e2e444e93f4d57eed2025a55df4b30793d8592d6dda5389bde73f8c476a2ddaba16648020cd8d98095d8fa73755fb405701e7c98fc743db750ca03f5d44953736db87ea90d38c4a2087055d2a6c1ea4c89d8778db6377ccb1304ed0b697c4961e9f3ec4305ec668c10ec74e882f544e72144c0fa262333688fbfbaaf28ade892f0f447e8650f417a18202184c82bc55751a161761a5f57e26bb88e6b701d213180e7e3978bba55652da3843007e9dc624e27769204ea9b4806f397ab13cbaccea0930b5514079efca1b94cf09cbcf23a4e0a8067646399c0456e77730cf0a203c88214000e97307ca2afee5f75607d59b38e0e367f47784ef70cbf09cff922e2aa15fd2ae45f20e85a8950308d9b6367ead1cc45e36f6f883869a9950c8b9ab53defce221f9d03a7c1e7ba0104e06197d11e153f672ee31ae99511701250351b2032bdb0b20b8554c6bee3aef98dba6daf5a5b0222f4fbcc770744556ee6010e7fceb942927812efb70d1f294e1c852ef9c114d3eaeca8e661b7afa24ed4c92ae966570a5f26329df407cb9442a8167a1d95ccbc8e9dde4fd5bba225515980587bb79421c45e775d07bc871e59180083ee082c78ac89daeeb7b6097b621fb4e1f829fc0bf365773c039a86425a9d31a8609b07044e1d9b3f2e1bc0ec0edaac2e82baaa434a87dc42ec0d27b9ac189bc1d52fd266e887abcbb11940bd3eb680b7441ed6d2b51b8f6420531bccec4df7781c74ab8fe117d26b8168521befd133b92d2f5d7fd8adb55b1ee386b5e5651c90840fec83c66e7cb4efc17a3113ae8cc2f50839cf298d0f2c2fb02b7f15b89790173125e917864db15f842fd63698a2189a1de7d734ba1e0ba63ddfa7481431ce52445ae4ff905204b3cb249c3495478c78958201bb060ac3231a86a7f03880f60aadd4abf94fedd66786ba9efec9515b1e85dc37cd352fd928082e6d2e40a4360bdcc35c96b8c5b717d1f3c22915930f56172b5c40cef7a5ad9b6043b925025dc7e964e77c60854ba0c66eb94cb02e9b3f86ef3911bff54baaf43d3c84b4c19e1c012229aba73b8d9029b41378a405c19f8320687a27345486e6deee85261077be88620497c193b20f9f18fcb7b313491696e7cf4ec42560ab0e3ee2cb3160d294daa511d9f02e8efdafac487004c44cc1ebdab914d42dcf6165130e8b84df7827da9d24b34524069bddf49f28da2222724a2265a1d4dbe1a5efeb663db9e1889f7f019382b3a6bdfba056d3f62248330a4c657b68908e8ac0d6c9c28c9a798d3b2917f05024c974680bf5440178df38dfe7348b2322209af8fc96803234169794d56b0118eee4667e5fc5a90d55e5fac1890e3a6a343b60a3d8a35fde17901d5b3c5711756c9b0ae2ba8b5797f79debbc50befef80c6f93ee6c9727e79e1171fde1270649980b2da4d6927f650f5b7a7cb3808fc13eb4a6fc0691d0a8f5c84b4219a21169efe86e900a27b3de0aaf94048b4f16f37492d013b2a7a8b20947856c1400a5b248a3e8621a1308ebef06320ed723ffac3be82be89b1db2ab30ee482e2f64aae3b35ad497ade0e4b5f5f0c54f1fdc59682170cbffe4ee5e1c572b676234d5e2e33bc119bbbc8e1516c445ed9e2f236794d1a6f04ac088f4a2f2e2cc85f57e384de6b7830e8b018c65cae0536390ddc010b5c9db4aba116c4e1a373628fa5563d99b15f788836853e9dd4aed9df8368c94440e26e04049ba81ce87ff71f90b1ff5e0c933403d5dad9e327d17c016d6deb92db6d88c7ca38a7ae90e1fddab8b6caf31069e5a7024df59e7d4a9c060045224d37157b8479034d8a6503fbf158d2db5586dde558146207c85b08d53db355b67ecc882541bcc3b1ac2cb5769e523e32d809ec03b785712f3f5669219f7f9a757ad7bd043a3ef11eb8450259f1b31a8564aa586681519fda0606cfcb743f417fd89fa86debccea4cb2825d553816017894fe5255a4d01ebe93f937c3bb733c2c3069d4ae52da61b9a31f2a0e2e6f067aef39f05d99f1c0628d4ebb05e08f074ec625c1e33e059f5dd502c3fd5012fdf4def72f011dd86381c7ee0781121e4354623b96d971c7df9cac85ac77468f2dc5b9c631e9fa407beeaa0611313dcc2484873ca5968190d65cbca610db81918fe2b9ef30653813c3fbe8cee882c303aa0586e2295f8a983033d12e6aa29975620c25c1c8b0001d85873f942d3ec929ce2b60b1079f5b2008b8c29ab3ff0fdbc73011f72214e53baddf59848eb4b3fd8e21a57b20eeef5c320aa93749182286ee185658a15a74c40239dfba0816fb8b30f1ce7d1449bf018dffe2ee8697c834a45c0fcf01a36f8136d22aabdeed48143d065e3bcba68ebe406146dad64acf8b8257be329b8f3a8a823b1c84de33e9ab5a29553ceaace0ece5b808fc316549ebd4f1a357e905c6ce036f82a824dba913123d90bfee843e3f3ed218edbf3aa94ebf256a1c102cdf4e1c4b4b8792d50d18e1bfed46016db6606009b009df0fa5ffb105351c246de15005a4075a35db95a810917c7506b2782014ba097ba00a9951e5e1b9ce8450eb068b5aaafaaaf3c1ea2777ce26b48163bfe04ab13c7c67c5bb5a0f9f3b726e3bf531670c004d3f1a24aa4f9182c41f6b37ec92ceed8cdab459cc3cf953d3ee09a4ce19c7f1cde2daeaee717b15b0380fbd8dd0ad85ef7f66a1f21048e9716f21f3ef5f8b907893baf733580ba8c15b3ff4b00caca893a94763f6115411393e2c91181ed77040fcfd1d1821364bfdd4dcaa42459b0b8b8f5332bc4023b983d1192a6034ebb85cf33e253373974a35fbca1fd214933d46255905a5f89542eb30d73f049514721f4b227123d65fc921a2caf624ee0bca709cc011eae34d7221f48a7c65af4ead5bb0a08faa3d04129339f3fada5d49dd91234ef9cc4aed11dffbf8dae335d5e0fe6dd67a84fe52cc3d7197b60340f9cf02d623b0261478fd4ff2ad583fed5f1dacd1f82f385f5e5e5327a9fe0c0ddb3f537ac852a6bc4c90b68bb7bfd2bd997936a211fb8564664a36faff5dec26624373e4b4c718d1f5c911708417330449ccfe758c1da3561a05b6b5c5a4b3090d412a23094467c298f936e39a49be2173cfcf7dd40d2dde2ccb44ef1b97f49ca013f46968b79e3eae24159381eb112823b3f4fc5293d9ea166534b99f482f51c7ee125125d119a890beb4dc6b9ee3c667b888aef81e7168bffe40463a46b4100aee01bd3aaebc21c485e4738dcc3f0cea9278a0e255133220e60cd875553ff04884a86cc83a7efa90c52f63eefeb27be94c63a1c2b2895fe2c8938cdb88d5368b73ed43f095c36442ceaafedffe8cf74094607e25382e3e5e84a911fa72e8439ad9ced8c303ec42636a4a66c8b1d6012b91297f9bd8d8150f8f56001f7fb04f9c2e20db9b50a4300c2009ac3e029301fa912d4a4361d1a82a219e5678ee2d18dae5c9ef9b2ddcbbd20f087b56268da393c4682074ea6c1f19b41c68a055187ae66a59a967d360973ee1e9fae40f3fdd3765b150e512e82941612788f7372308cececc522898fe8e95daea2add84434b7c26a8fe4060ab2f7f268df713ef666da71c506a26a63ee800c69d220a9016b165d277dc970042e5e692a5b5e232186e01cbc6134c7a97f7c952947dd5962c963c527581ff0cfd206b04fc048f61c4c96b9208a8506c0771a78d97d8bed255ef4a8507aea14563289a3819fa924034da3acb2788aedd5aa73a83ffea4f85f8076b39dcd042d325a9854967a1be8036b9e51c35a10afadcf3537f6ee653b860146ad1261b4b93387a4bef90f1babd4e05c237709fe37e8dd71c5b6396e8f4aa63fdf3cc0174debdee1625e260688aa3895d25bac6ee4fbe2ea714f4703547c4cb6865f7c3c2ead4f009a13232da1b5ea365ee57bfede347b373cc25be8c7f97411dd124ae58b13fc448bdac21ccdc504cab302f8a0be47df55318b5796b52651f3160ab45d373587ddbd1e0e8de6b130d8b1e6a7743059175a93d92a0a3869f6e4a0d8d4170ff940290f090548ff4efeda9fcd73f55348f5f62d22971b1c0a4b039c64a9aed2545c21d83b6356cd67583c7c70cf25c3ce01a227badcc17783f89672dd70fb39fcd49c2e95a2aff0a33ff729ba01a513ac716dadfd194b2480fa44c78b7170b02af998a1d80cbe149f952899a34f4d600a7f861c8d393f3247179264d69efff46aae72c72b275474c9a5f172ea91cb7bea9220b56bdf8ed408c7099d991086978cd851a50edfdac75cea6633fec590216a110f4fc0e80001f0bf71a60b9377aa3a83881ed06737a27aea20fca2eafa9b7b8d4291bd336231fa098acff7c0d55a1f0b34ab9337a9d98b4733759badc4cf69131355f9a222a2a0341e7d7c741b6bc2a674b66b72afa4f321bd96ef2b06e85be89c4daa4a5554a73415132dc0a0c94ec82d919e5daa9242e60be5084cba91719bc222e3aaf94c002ea6be039ed555a421add4cca0068c7bb702ef2b399c8da54bdd324bdd086bb33640b39b04e73e695e5371ab6dc7fce5dc4953e068b47e8ae13b26188cd549ba748d4128d21459f4f4178951f7c6463bd2771f9201bd1faa1fbe7f0dfd4a518d7a63758f6bc9049ff76124f9027a9629d24a10589a80f63dc97676c488593ba20a2efd9e546bae70265b63ec4a5752e1b27d5746be6b1ec02cae624df7994a99b6f0885e23324497966d9791ea935d56f1fa91de169c6f9c661daf5a5df76ef421f7daae5ebc1cb9563819ca5d842eebf8b5fa4848cc76044bbc4328b995880ef9f1f4c029e3b213386a27985ae4c67b13a727679b79b2cecc6f19add58c03934406a61c6d6af02d9480c31a801ed7fb42840c74798216affc70b2c46caaaeb42a78a436fe0bc65ff8a790058e42316407d5a22466d5e3b882d114cfc4ce97ed9ddec7b9ddbad34a966019d264e37b8cdb3e0b0cfe933698249bb89aa1a5ee21f70684099abc62447dbc084cddf11a7b0081d37e9c80a00aefdf5217e7821640900654ea31f16d4489707cc5d8ba3a95a0c716ba8ea66d487ba9e0417ae7859632a115134bcc1eba7ec6bf05f9df81672095cd5ac1384a00ea49b9996ca56acb785791a4fe53f2c4e6dda31bb5d9faa47ef59f2468d8e8f37152f880810c40f409ecc6f6a278327dbd0c3d4e1b4d43877760760a2dfb9a98d7e190ed4089b2016dd51ec3d545a691ba82c49b931f4cdc74bbae909f0d9d489267baabcc99801f3a4866ddb9a2d69a91a3792eab1666bbd0389603bfdf8b9630aa6452345fa9f0af72b2413a7fdfa0057ec0de8396ed1e2f574eb782b66de5741c751a4bb55cdd202b554f77378237c5dd1c9d9493f0418b965f8a03b0acd3325b1506e9fb7db6843b21eb7274480ff3f0481ae60baa8eaaecbeec6fde54cb307c6a8ad97ea9ae1f8ccabcf412e7b9957227788ed6cbb2a84fc5dd3454b456cd1e2801fbcc6b026b4e5bb9498383c0b9556ac1e2bdb24f7080cdd3a63b652c7fa488923b18e9f34d96394f3f4b8dab9f9a9a27e7fd6fc6084b2624373cc7c4fee832879eac8974f07ee8c7e20a6760a1635cb335376bcc5217f61f517a69a7ca7f606a38ff9089e59c5d47ba14921de65761a3d8850550913326b96291462af3f016538dfe621fed1968a9a88d2ef8f46c056149c61c1cedc3c057f588b023ef30a86f790839da9633e471ba6c2763ac200eeb04a6e8d01d13152b474974d678a9d3384590441a979adf3427b5bcde58db996d51dcf869168ab6cc7c8c419110c348c46777d7c0805298e3f676b3e1aacad7f0c85aced3a8d2638e3d0c437e730b199cc8e1839791e4bd911215209e19ee56aa5748c51c8143ffc1c4ff86df78848f9b0c731f2be20165c8743aed32cfdc015f58156c683fd4957bc07bbbeadbb778e024af7e9c2080c9a058190e3dd936f00718bdfc94d4ca909e6ffd772e29b6d342a75209e399e70029789edb82448116ce7b6fcb5477edcc2f50047f988a0c2b6a0555f8700770d51d28ddd10d668027b78e65982189cc9229644f448162351b0a112b599802bd1a6fa60231a01dfe3368b5b2a7838664dde342446c27314c1e7e913cdfffd90b775cd3e3a9b63c876b96ac3717324791fbed647b7b64dc04086db4e66428a03bc8a3561cda2508fa3a40e7aca8a7500e6a0e5de681ebc56c0480920aa460cb55250cdfd279b8d6158f7799d6ab169d2c0c92f70a5471e00c475fa7d5963580de0becd9eceb21591a4e3026f7ea1c8f5a0c99a4e9c23bdad10b3583e7a99c816e17bef6ef1cdbf1780badd209a30d4e750a7c828435da85c4c50660c8b11a6b2823485ef931e7ad86a972990c4f973bed8fbdf08963b7ecd35757ea062f6a00310b111d6c22242f26e463a8a48206c9594437b6e27493ec63e964225736458c4472ba938215346438eb57437c432a4d298b2c4ae55fdc12ca43ef2917cc983306dc19be90475f190473356b032550f49876216add579b16b258fd641dd6e2e0b380e62f7d318f8d8e65625e8238a98fb715c5b8bb4cc1f208ffc3310c177fa9743550e7ea3244d5f4d24cd0ce56a7104738158e25fd95779abfd9ac372ae247140839100130e8b006da072b82bb2eb4ba061e25c9e667d38b1ceb301d0ae4a30b0cdc41e7e8b6370ac432d77cf403b26b531ca898952067dd442949218548d11f6df2c7406adc9f8b635c4d215f4c0750a75b543e60645951b29af56563e24006d15c34ec6a5940ac17110f21ca522a3ba99aeab73112087c587ad867cf27bfa0b25e8c921f45b832692b372a4e02b2f572edc77723e367f4573143b1e2a26ebf9e6f9e2c6467bded34a97d696334065d340eb89e12c58963aac1931d207a6f721a2cf3888e1c23483396a3d767d6d89299ee2d8a2831b30803981dd7e9b4e0318be06d2310ebb2aaa1f6bc9c338c188aada78fb59663364e157819e7cf629c44c5c0893cb32879ef997897eb769bd255ae49e9aec082a507875346a045442994840609e622b4fd6a6c4e3f7a7581b8e948425532d93718209bb093aff8b5a12b7597eac365833c404d8e7fd2e670b61b60703a6c281f8445050c8f84ba16ebf0a0db1c606f32a449228b10cda80a4cd628cd9c93d2ca4e0a542b70c036bf808e9f73466d80d0baa9b72bdc143d60f651331dc3d7862b1999197422639d0ea37b17415fc57f29739c3bb0a27c8128bd88fcaed8ee97569b7f0dbb6a1602f36471ba5402d4b68f41d8a92c10153340eff3b266c1c745d5c7488be210cc0e44683ba29efa37b3bb4a869ae40c6f3e6c25ccb09a3e820527e5e0502959c912419a1b589c3e34613e07da129288aff28c7c7420e849f7c0ace167a80c3535523e381ffca2293765619f80e869f22b06fd7a9c1fad1121db205d1459220788b14199b2a47594c47f0fc9d956e4d23a22aa1d3a4b04c90edcb2b4e451cbe9747219388d6e076fe2f03508db27c4871c902359197327c447b39ad97d2faaf25482432d229157c62da54f49866fac58741c6a1fad907a577fc13c5ca8c2904839fa444e4786b717c31acddb0e7e9e92df4229d0787f4d3a5ef33c4f093bdcb9037f12badb38d7d02f4ec7a1fea8024acbe8ce3cdaa0fdbda82e30db9b27e7783b420956188dd691ef210ef2542eb47fcb2c45e4fa46acc8d868940ad07c1f962d1b1deec9ed0027353d26741745a9dfb312759b0afc7c78665185d38f0279388d8a35c6bc64fe36fc88f9192fc3e2130712f2ebe1bce239616f3f1a45a02441600dd4d545411eadc319152de8705f992ab9db43e2d2ccd8c9749dfee7316710556d68fc192bbdd4af9aea7cee7bed43d47acb49fefdfedb59e17a95ce15d84c7bbea4baf5a177f873c97fbc9e7e3280e4b1e922cd545b45fd055ec99dff3bc8241193a717e294c289a1b271b4fff942e4e3d222018fe3cbab32b5edafb30eac8bf784c38e561e623bc209118256f694c77cd3926ac57fb71ce30aa9aebf249b3162360efb5dd83ecb3bcb125bf50f3b57a2ef0b1222d5e947b51e41695e82351dab6bfa174a97e9fbc13d9af9c54f5576216705a89d81129fec868c24c3e7df7e52c8be8de8f9c9d9484b6135d4c0a728fc9cb98247ea716352fdea38eaee063a33f7a1ec576f7b2184b4493fccb1d2108128f3a511facf0258c503db535634fc8c8a3e1e88c393c1ed662249c9ba1183e21db5f3cca95c2c5565347fa3ec2a1f0c2548980a8983e94b156808ce8a51e6f845f427be66dc593bbe1f5423f6c01ac5f8ac6b62645804659885bd97b58230a9f21bfa91f69164f337d6c45775d122a4054d0ffb641c9ee26e68c78afb8c00176ad628c90697491a6226d1b89eca1a89d6e6c13f90b9a946f1f69666ff3c82679cfa4a73086a9b54179eb1cbbe0f5b97d2898403f4df02e6ca4036e5f03306e695fa6b42d863ea2ea3648c88f746126fd1ae3c58367f0d658d1b2c03a02d3e14b0064ecb6c8b8f63544c034b590eef7d979cd97f000d21f893179293f35bfefd58740ec33a81837c1bd62af8a75ad58378fa4aa28d9c7710408eabc428206f6c579f793e8fd9ec5baa9ca17d86d60a652205d88f2516556f32104e2121d14b8a2167abe8ed7f60134c8e854de0a1f1258a4ce78be79e5e2f824b1e1ec3ef709e970b85a8b99ef151a0fff1f3d4938cff2a7a045238c1b93354dc3bb63ebe8de5a0d07591f4ed806074eb9a1bc75619605ca4d328e585c96962cd251aaa6e5160966f98f06776e9cd5909d7fbadf7a30e890f3829e947e883d8ab110f2dbd2d2841a2b2805a9fe9fc27d1067cd350f45e3bcb71918c7e6042a375d546e72d4e3c204dc57d3d2816af16a7afc84a7284981b68071981551f59e48ba136594fd5b40029549e9ee9ecd05f60fdc1cbfd152ce65243cc42b3849813ae86e7d0c6dc2d32ad378211ffcdeccd69508f5b74106a4b602dba33277a435fb6ddc30e1244b40974d2e7c1e907900a1f5cd5dffbe39e6d4cbc3b021062fdcae42de6bb5707007c978fd624917926682cb9fd66d5e6f6a52328b8d838a493d9ffe09e6cbc201e001c8078403cbf8a5e9bb2786d1696076b21cddead3740f94aabfc49f7dcf0eb85f20de4dc09dbebaa2a0cd9d04c6ee86e42f129b1425d0427957c3eab797639a996a69e0d95433d0b31e89047a9cf0c36bb4bce328512512a8bf31cdeb8d84dbc654dcf852f7232289098ee05a06cdd6e771afa5775cb700db65f6e37530fd62240a01cfa57d96465640f75242d58a077c24a0a8d1ec9f7b7d009924c10bcd131747fa586e420fa54a5c2a902dc4c61404f03a19c6514f2e71f3cdf407ed25c892d6dd33ced2983bc78979618052bd0ba442a44f2b264928f2c0f3bdf01306ad6fe93b5c35e891da3034f1c709e97745d3f5134bfa1d6dca0f253cee1088c5b708925c2138b7cefffdde5a547671fc881c00d8d114ab2b5fd78102e3245bdb639a7434236b072b77733b3347ffc0a6e34ab3b00392aa97a93b80604cbc58dc7e0f55f02a66c03ce7663541859ede2f7d15970d6b017428a13790def5ebe6030c7cb229248be5856260cfd4530421471978042515a1d58ef13ff3b82c83343a922fbb30db1a49de855f92928c8b30532fd406b7a776b7a0d08d9d167e45ba7310bdf712d0e5fc6bd3e3e99a05db747a0c6f3a58995b4e50f73e288fa16a998645bda27099412a7c6e478102cb94bc011c3e93cbe18b9f6619c9127d7c9947e8b0b6a39efbfe09135ad64aa77fdaa8c56b2df5e62d6d4e17a8d01e4bd5338e9b17bbad1d4829ffd7249c9514d8f05379fd6d5fe8ab41c852e9e034f33e22c710455cce1c2e75b4e72aa700481319366d41278ccf77b81935226c99095c25d0653cde08e283cb53fe0ed82e683219e5b22b977dedc15f6a5a5f4fbcbc9b425cb5bcfdad83be37cfb7387ec9fc8b7d9e022655723a1221ffc91c1131e60404f34eb4e4440f64bf7179e24e719a20ba755e47b810bc8754331cf3dacfc9c409f49ba5de0df47940f8261ce44c577b8d3a70b49d800707fce0a35be58cdac86c43815dabc8f10acbac6b477ef7c68ae74d62b73c7573952e4a814a7e3dc95a6774abd88ddae529477648aa2234f7a42d857c757196c570da630b0ad2b1aa0e0018da283792bf82290cf9e25a5eeb46da0bc9b836ab5ae708a3a74206eaeab09a7f60a395caf003f86bd965e72df200df259e519918296a4e04631c09f1220fa6097ec7d1688045db07c3e59d71cd55b82520eded2c17774212daf9714aef2c0d5b26de719e3bc1ebb78395f3306f8c1e7926f529708b6ca96b5bffbe25b1b2e33ce8943936db267532198f4226d68c281c863e4bcfd18f1501f25156d824a70c8a198eda332fc2108a2c8476b9338ffebab2afdad52b7b264aecb846e139bc7e47fe4c2e95f413aa3116254f4f9f05d5117cffa5910d608890abd0af213ebc8781dac1e81e0ac78b21ba50ef966fbbd460834d18fd8c0db9afd397048001d6f6d6983eee75d471421d8ba90197232182dddc3a50440b9bb76b512f923df232b907de250be65ba250cfea5f5b37066778cc746037761f6eb23224a45358633da7253329efa26c63287a09830ccfebbf92dd0e99a1194597a52a0b81c9efdafb050055e6faa24617fa584c9bdd05791105e73feb8d21f5122e1c794ba80315306f72303d4f909a7260c00eea4422e4817aae77eb1f13cb9be7af9604b7c7f615ec149a42108ae44b6e1a252286b7c84072caddc161b466df5182d2b1502d2ca01dd72c2cad3cc9ff4261d7e651774ddeab668ffc23e772336b6d9e43e4aec90b3f69d5e67a5e2e774e1194140b2bede8fd072b06e72cef3fee1ddd8314cab71dd4ec48d65fd9750235503c833b19c05474aa95ad2f2b4d028d4d314539061e7f865afb3beaddaf56d669667011c5bedb9237fa3af52db11f10d794ac6d602d5ffed512cc90eb4337fc4fc78a31a34468eccbc02f598f423cb5a6ac42f14b267b945d813898a48f7fe56acd2d20c26fe3df8996668070639848b7ef7c9bc68d885af6f049c3d217ad90ec23c760d5beb186f8776d8a17453fb0b9762f5de86852709ad4b7d58820f831b7ce72ff636256f6cab9dc577456a7ad94d5e1c3a821f98b59acc8e42673b8bf3ed59d6666469c077ceb8a279b5883b47b53b0c1112d8358e916acebfdf23cd5a7398948f4bdd23c1aa11730abed3b5a1442343e6c72cb6d7acc384548ef7c885b1e8f73dd49912d64664acc70f6c94d2e410f51d39e383dd464b3155189f15618d96266bc945e2aa3bd6f6ae26c118f60972857726f2a4ec52ed2513ec3800ded29b629a5db83adc47d0c328cbcb65bd0058f178a04ea7b0202400f1d446982fe35a9e7739faa0653f955e2a5eabc50f8d4e2ffb10e76decc1ebb80e1e2726abdce878c661da4a3cca7a91ca6229f655ef917dc645c74ce228711cc96fd177a0aa19b083542807cd6c32919c1ac12b51755f9d0f0aa149e81a384222809eedda3e356e5e9d017ba27abea17c2fe15cf4a516f53543e52e23e4bb9a78b42bbf7d43c0c6587c39185ef907ad4f7071a86b335ed01a500b49a3ed048b03918886fa9447196e1cb0277622a969db5c433b6c7c0a430c030e3f84fbcc4ad7d5243eb579fba9aeb950038b94eabf6efac1b6bd37764d19fc70f3c3d1e242ef145208644fe73dea73def99dabe12e045fd5776e8cc3460ec219d1569ba6fc61ef03ff101e8750aebb2e9643f189388e82a44357c0d861b581901d887e9b0ea5aea353c725effccd2db58afa0f5e260a1ddfeacb35f82aeb9ad679817dcb2d55e14be676ba06cd519872c4e2cacb87b459ba50fe82b986813d7adc3783f526be7655f3f0ae1ce8bf93200d2505aada66b734a44411","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
