<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e06a46334f5b25a7585541972303b42f4ca899cd2c4df86f5684389c8228c7216195156affe234b010282525aabb20d5de29e7b36c4081a905903d4c2c1be1691bb73b11fb3f94f68384823d8feaac7c4d5c11370c71ae3665266b151cdc0818fcca4ee835176dca78493dd197f369e08f067f569e40405eb83e89d13a53530baba2c40ec77c792897dd55fdae959543729204e7af87445f43a8b09761f93b873b4e5e3511e39b26c3e40865fbda651ebfc0cc4f9ed8c97ed95c6993a2f825ea671eeea4fa429e1e334603d715d44decffd5601063213c05897bd8cc82d725877583807d3ac85953129b8232473aee66bbb5ac028817d0dac3e6070fca4ad6b809b1817407491ccdadfec1d734e17f9cf6ffa65e9ecb33933e105acf20fa281467d67674e5bc648d7c0280df5451aedbcaec6be0c78c7f3b1f15c7c7f6469e09cba8b9062e0aab8d21cf82aa0cf68ed9287a1b07b849c156ae61e587ace95ff3cbf19a9560ce8005827bbbe57940c398bd25dbabdf71a626880b88abe507490cfa571c42417d512858d2ce7669194f776964fe4884a5fd4f5bbc85d46e169fe49b0fdc79d863b639f782f90690242f1d61ed3f3c2538fc6416899da77b8eae97d50200477b4cf13f1b0c18df6e6a5665ea8f4592dc6974b060483c179bbb074174bc7824fb77bde4ebc4dec7a8fdba337a01373391afd88a048f1636e06810cfbfef3dbd62bd444e55e89344d6b9ff02d288f5e69979c8c662e9daf699b5bcc167bcb6cb47058dc89021cd5c1b54ced0a7b54d01beb930853afd84075cddc91eaae5d8ab9cc1971bd022f0bf817a758bb397efb90bfe6bf32f15a2a684df75141344933bc19f1ada9cce9d30dfd727942d9d406048f5ef22042610b4163e20ea9bba2ae18c2ab832cea3a03653c91799b4d7900e25ffd82a50ea415c4e6534d140115df4970418b724c39f54c7594c9657da12fe03cb97769c02c5efdbd67009472de1fd43545d7ffceec57f7212e406a270b14bfbd5254642601eadff8e54454407eb64a38858abef3c1769cc3bcd2a913ca5f0a3c105fc69db59bb0d4c0296769c3d4ef4388e6098507728fa6db3df6870798a21a852470b542c11a06441b627644297d40c3acc3c83e64224e7a409b83a62a336b7b7c2df0cbdd13c3dad21695db1575e4229c5eca9870834156e0853414e787cf9d5846d79f56aa49d174d31cdd8115309ebc674964b6e35fec9a56032244aae734d88d5d1da22390a1454ba4dcbd49d545bccdd5deec15f0d41b22f7c22606ba642a8e89d1465620b85d035dfe3dadd52e3b27914b6e4445d1937ce8e337a697397a32940e6fd59d19b36901c10222f999b7f51b3f93791f5b3dcf2cc7514a1d385544ef9228daf0cae3e3711b994e25ff1878b56660086d361e920caee0542f93dd2bad0761ef69f663c90f4674ae1bece2364096bff102dae49fbb3ed37149d5abf01f798bddca9b03849b2fa27f9087045123ddf455af7b748400c7dff8ba85ad4a453693bd814f71e9c6b121a54ea42727a709802c8a23c9428d8143493622794a690c53ad5530b3cf5981bc4b0d59b2bf50c1333caec7a02d8129a7f71861daf4192fe0bd79edd5e122c6851dc83e8287218d8c64fb042be3f8f6cb64a223cfad6a72aaa52b79bd49677aa5dd78f3c012fe06aceaede6f8e7378cb67925daf581157fa26d8b24c28d67d1e42937aedb59871523e2dcd0a930f01186ff47da9ef5676fd494b7b002827ac005f03b8256417b574d69effc4fba03374a533031feb5c2fe48763924db07a9c5ec611de2bd0f76980026cd3b4b397b4d94335130fce76b9d3d96023ef8c5c8ae4048fd907bdd6a44a1f0fe7b70336f4295cac160ec835e34452cd7b3f42a41f0fa185e39530ff8c5545bc1df26b820a719463171ab90651e30ee2425f5d773a75395fd8cd5f16cbb11511e363ab7e1a6a247f55a62c4458c2f97e747b55e18b23b40fabdd34d5c5b5016ebdd6298d7450f952d13349b73d342fd6846e7334e51c3307e7949d933f7b314ecb9a12c25cdb84c353f2e4a76e35ecb00d9108a0fae57af7399fa991292628685d99fde03e212da5594e622040605734125b671085345357181e04e1b059e9b34099a513aed1f90d4400e4cce4a74a7adf3673928e4ce086ede531a385709b11570f767552cad2de64f3293dccc259b1c9ea431840a86f6186997c964255fa6214c639bf0208b5764c4b32d1472d6b84045c5ce73bfe8c287621cf3c3ed31f44f61d6731f74250cda828993f10b4fabfe2a1919562a04915475811079ac06e9c54453edb20d8b957092bc16c055903e53578efd896177edfa7e680d8de6c0d6450d08f2a75777c370dcb39c02c32a60335b33c090ecec28d32ca2acaab94a8e520b50c7d4c4f9013c248d6035a586986b7e32cbc4a01f8c39f47e9c50eb4e7d342865b218ffc421967f77210fb38edb6a8f52e50ff89bfe3c00b39a6080ae73ed99df43aca6438ee85dcf420310c9c845ede68096f4a8030bfc691c7cb6ca1d25bebe65bd298408bdf5984bfc11587ac4bf0be0051eb74fe3b2a3d8062ad9f958963a2c44d287c4b4f2b88c7308f7d18d4d717ea985072595a246de6b7e7796f1cabe9c3abaf2c9d5c65119a1085ebb004629c7f55192498e79ac7f441fbd276632d8f0ef0df97f2813f56d7f2b3f3cba810889dd22e51aca0fee3a9afd2ec5140dcd75ba4550874de45c08e24b6b5534f811138e432381fa4506b3dadffbe5ee0997d25189a391a3fce320ceb6174e729cede738961270fed35cafb3d6c53bb7594541d035f380df255f37583b5dfdfaf9ea11b7b2044f2aa06e9f107986e75f76554289a47dcfb57074452a7d908790e85f712b974537f77f76bf6f44929cdd28b4cbc8db1259bb42c6e2427ef61d444449080ecce1a4f7fed3bbadaeaa03a59e0b3cc5cf16789245d4d18adef992afc48a38ab40d923a7262227ab94a77e0534f8314310073a2dba10d1186ab733becbfb0be51ae6d16f5390bc79a063918f33806a3b0771dfd1ce832d38bacc9c46e749dc9284508768a60565366acc8dc14b5adab398a7a0421cf063c7d212f1cd5c8aa7286e75f6f919c4c9ed3c26bb9fa4c204216903f1f158b774eefe01aa795a18d581a26ad266b95a48828323f6ee46652738856c95bc4db4cd949104e2925d9aee28c8fc0607339fc9992d3f443a21181fc9cadf57d9607132682925ff401098537fabd46fe3985dde380614e230be5411b8a6369844b27d490d4e85938b0de44038ec605e8c343e6cbef28e531aa5c539c07076147283db5b7613d50054771d7f0b12e8d9ad852e4e0474c12784586a1b16110564c226a39e20f664d0cb2fb27e01ea66585d7046666f7bba34c1d19f5d4b4e87c0670ebaf264f9a41d7e22872bcb4b2b1722c1e9aed27b24f90e2f59bbd246bea8111133727820b66dd3abad8ca7346b585a526edd702813b3b03646b5baeb71bae75b6d79e8e5ff3bf186b0452f8671b866f88097198168124778e095d14637de77d7c3a3607b3c4198f83ef00c8342b6d994b2d89dc757df02c1e43a68443f738c6b39804ba8ba6b869e8b32b14944721d916e8d11f402973e85705d34296023f02aca8e2c0f1bbc93b82ced7bb7a3e9f299362b51c6b255a0fde8e01ff7e60a39669df52230952f384787c177549134a7285bbf9dd5873d350a2c414535c31de075236f96306533f9604104eedb6f52e7693a5bf37996c6967beb62aba112326c946ec4e6f790f377209606272fa19c28c3f2804894bd8a168ca9a3a246b4f403aef076db2b8d1387143fabba0f82888ac4a776d74dd0dc450c8defe28af51a3d0a546ce16c6c15c0a25a9092c9fd9121bede28e5bd3fd995878dbf5d8e39740bf3549795f2b782392e5080082ed8c01643c55059e6924d055adc05af900e8d1c180be55e2b3bd6dcce040d6e7c28e2ed941b8a5eee57b81a3193088edbaa872f1aeb2b120e0c410ab200f6e453edab35093c324f64daf912fc27c832cf5920ffce451df07da6b930ca51d3a9ae241febd325eb8d35bbaca28e82c8d51e7b0a3f614ef801bd293e549e1fdb856fa3b276bb4cc4333132fffbbcb42342114fa1094b8f03a1ea0cf9eea128f15db3fee534b4d75b91e66b4e0f04f368c83c3d484e06be4e34c022e0081e1d230fbbfec0b2aa7f9d47ef37ead43a56ae16609f20d2cf619967a3d07ff5fb7dfa4be9eeb240d861bdd6291ae4c2d8808148bc0d4070121f5419db9bffd31ec82de5fec079e0170e0a48281122bddbd52c9676a60392b944eeacebec4c40af8d272bcf57d658f6c283f494b25e1b4377fe995375015b984bb76feeb6a2a8759e621dcfecedb726b452ca4925e9718aefbac623806407444f81238e04cf21055f64a141890a3dc84a4d31a65c57fb7f748ccff075c8cec8cb9063cd7b0a83b9ae27404c29f00c565441370dabc49d8bf692609b8dfa8993745e1f33a719ea478c84b8b4d08bf750ebc4032241f118b69c6ef1af59d88aa67f930cb9993ae815603f76cdafbef7b4102e32ebbe3b901817822381fee5399bdb5afc5f85844a04de1d0b3a1c45e6abe3097890ff48d12146d4e84e4724a3d1f517ad56770e5ce14d3000cce85048c6facd53d14387b0092ba9b7914b2eaeae148fbc476da6af6e4774eb6213b6e722460dee3c60f1fc70fd4b711ebec7063f74dcdfe82db6b6e19165205be4a54aea49cd32cc3b31a8587cd59586480b223559fd41a9f88ce18e6ad9462603f01a17272f929e65a57bf0c03a1d74b45b943271defaae4fdb94b94c27e8f0639355954b4e3a5abdb5791d221ba5eceaff5a04fe0eda1c595acafe6343b96f7e48ba1fd84084068021520de92554d05bc932712cc6df6f86239d489fd6e474dafd684e6db0f723f8cd25d7568d003bac0c857e69b79018e3966a8a85ab8d299e9c679b357ecdcb0d9f8634abffd9b76592214cd3e6f6562cba655527def98b20df68e3df5e55abde3a92d9aa44f784ddc316f3d6fd1c517071811e0b8bf6c8b5a03e2ab02c19cf054a52f97d86d8d21411341ab1f702b9a2ae67974f7a4ac6a1932c78c1287fe8e1cd24785545c197323ffde00ded70836d4b8fad74a51ca3cc9e3c61849f1dca8d3538b9ab6364abe3ed7dc79523921c2b79408ad45d20febc0095ed4bb326662d78f2ed374f4c2cc2466c911f4c27b662cc57cf225fa42f2d5c9665a1f35e01bb49d8cc8bd8fb5ae2368de561b86674a9e5f225d0f66e1c5116d0f29e5dc73d8a000eefa9cf0e3244513a5ccf0a5f8c03a8d4dfc82d5def5140cdf620669a43e8f666a95d91d397cd1e8b096121611cddd2d8695dc864b60921e8ec4b88105af0c66d7386880a512f752a31826ad5ff26646d237a256d6e875faadd96c483cbecefcb23d841a86713978dd4b3c7cf00ee5d4f9c974c1c0980529a13e1bb841cb8950f3c9d86b179ec0f9a5c2983d457050cb0b990f4547b76a325bed10f79500e4287aaf48a6f1ee881376e4dd74f454593d8691c25f3dc8c263b39f47315d77ff42882afe456c65ba3c09bf6bc39b2340c6bc53ac2d34c7621fdf4bb1389c44c4beea09e6640f4303dfc840178d78d7e7a6437e17423292f7f2965f80657cc6d7caeb0376882c9388e04157dfe5ab23c588d5d76f6f1a202ca3ba517aca08f7f4221212f6c2a6c7c95a7b35452e2297b012eb15acf2a74dde44da819c169ee630e58c564d5e8f7221677135e7cac47465df4fd3ac61e049224b959e419ffdf04360c17bf19438ab43c4619f3b874e5284db1a044c7e3166fa1072231a50d9bad6f1f97913729c331169d3dbe3c1d04c3753a15c64bac35a74658dc2f9f4c29ba8b60caf634cf5e94296ddd409d1165173daba1690d3991c5f78097d773e95208bb0af971652d289042730a7730a5af8e687eedf6613603af69ca2a1c50957a2c5fa51713003bd7cecd965eb23768ea50756a5cc174808bfc59d8e087f8a4ea3b47ae4689b3d3d289ad0f0dc506246ef262caaf6d1eb9d5f29bae4cd6a6439419e8006101d4c9615accb384a150f7671fc5d6586b420b834a9f93b6dd78218ed867b9fb5e0976066a74d261398120535a779677a44397a806ea23d000fff5f790cc4c859e7b1b93515cf78f99bf526396d7d454177ea880053c5736c13b7a3061a0bf8ea9bd78470e6247e5f40326fcc97f7acea41e1750518aee77be18f812ba26ec9c194915342e4dbaad8c3e645c82852485cd49e3ef1882e3cff350dd42b2b86f22da9feb9fe69473b36d043d5e9009cd37904d02138942be8d06a02d960273c41aa49cf4a2403030d445c7dd23fbd6f687842e842e6c9951d76a3ca0a49c3476beb1f2858469fe2c5011b894519501532632ffe1fc75e94573a41c9108b096dec578ddeb55d0fda29c5b47cdd8812d1b558eb4553829a4687901a9944ce9e6eec111b0a4030a1c4b72353e6769fadeaed1c526b3c6e2e0359436bea9222333df77da523a1b5b911272073a0e8f24051f959794fb5367c0061458c0582b6d70aebd0a84e9e070a5ce495a81d8ebd82f9f08f6b62ce0e6aa0977d59a6e36c46e4b0d7789bc921ab1cb5a49c8edeee996ce6032ff1ffbe9e721755aaa765016e0023b202bb16ec3e93052cff217038b52a32226316105a12b66d021c76ec0b1c8d918e088a04aece00bd6a5f393b9d300322a26eb3a856a2dae0d30bf0e770f475bc187b7754c32f14fe92235e888d11cd47bf9a9c8537fa83a94b263cd22369f7e69897004acfacaceceace76d6a1b1f70c8f20353ef8872298b45be00f45e158cd75b0fda55ea34d622f4ce2275a988a902edefd31206150a2f61229b7c474fa29f014b2dccd866731c399a1abd21b167adf4a40f9b55f9c5c22a0002570dd8ae0e58a688ef749b1095e2f96d8a4854623a0a23905e0c7d5481cec39a22a2d107eb6b821daef338ba4f967497281dacf3f3e1df15b7131fb3cf817a1a9d405e81a4193010607b014b9b7934ec9cd2d1fbd0876a69390b7ee03b422a57d91a1ddf586ef4bd16cbaaaba51b112521d425cf1804cbca73d068f1551b04bc775c47dece7d2d32ffa6d34d385ae2c8cfab65a6e270bdca54c63a53e0c21bb03e06e8beff655d2147d424cce70404a3406dacdfedf081592940550207a98eafc9c5662f76633730684d338be83e19fdcfb16628c594befc24353e90bb79d57f792eea31ec069a0b995b42c284257466cc3966c7a7d9d5ca814d2f5d29bd7f86457eca4e623849ecc38efd8cdaa4f409b9bea977d68fe433ac408a0ee511419cd8b45b278a93f059edfde41c5d34ccf6dd349393b2c7dfa38a521c38129b4cade4f798a01bbe1bf247c36e408be189e29d0cdfb86b6bcf963a3340646f7db04fbe3df3f6279ed9178f3e78e7701017a9b21363fe6b902092b40ae83150456c7bafd19b35ef3590494569383548651b557d88e1df8d51719f7a876a3f0f742167eb015aa08fe7284e00cab658137ed952b15187c24d446692168e921bbd6293d1e98bdd3652b8307ccd7f76fc4a194a82f809d618530f60715ef29ddd1496eb084bc5970da15a05f7de75c4da64d48fe05672cf99aa37594d1b352dd88c3b7f9dea298aaa5a7d5d4558a36dd5575922c09aec564d2ec12763e9564ac41f743cbd375f54c0a1e83b2cbb077c83a8525ac5f0a789da8d7526195c0f78925101e6599a2e2c210f045f4968902ea4b2188612d518c16dd3fba351aecc08626cecc8aa9e76d9aa9dcd85958650d1578bb49b68795367751d2367d069daaef5e4915a2098b7e58edd9027b9c75f143c23c03299419bcd2222bdb8f58f916aad91c217e5431390de75b8a60d7d7eae1b1ffd5c192f05d85f60f4a034396615b18644dd7f521a0a7965953035190d8f3ef005615cbaa5672f5ca2e664c828c18018571c5669bc9df1a55affbf24b318e7654b084ab97b61ebdfd02816e091658dfa5bd79f01f3c02ba06bf756238f6377b47aa3bf4f3dbca81f5796d4a7e3f2a4e6694655dc58008a5a8e500f966208b184dc1e5c4d06e173df839c6a57bedce7ea30a37eeb463964ed07a43793bb5c8e14f4e055745c2816f433c4e44f73d2ba466c1efb546a2fa01895335dfcf057429bc2571657e74e78bb24550d47ab22685f4dfe74b6b23e5c33926bab895557f9fcb91cc56a9b1af7dc9a788ebe409a1103920849233395536b5c7f028a8d234a9d4232f4ae197037093a4a4db4fffd803b3ad94f5d2f380d22f963f4843b7d6579a3195087a806a612e25435deae14ce5e663ed507ced49331bf9544d2218f745be7249b309161a2f9b2b5f4252dca746ee8cf064d8f9d4cc51c94d39883523054a2463aa751acbb925b9ab77fe2637d26be2425e3e0f7ccfb92c2458b99d408b2255f945baf7cfecd8db98c1d973bb0558567198d33e2ef559c6a27ed4401060383636b8cdd4d391dfbba471177ad2bdb74761b716feb24cf1df4b27aaf45065774b7966e66ab93619a55a5b3697b22881d20ce5239c3b818b37a990b44737ec7b8681af20ffe966df112f9697f7cfbc23626445b537172abc7a3b717001a5f056f04be864dadc486c457df7da164bbcc167efe548df50cc8b4391d0c94d793928342bd5bc4ab2af21082fc07338271e32f87e784b3246f844c3ea6516222440671c42d6c6b0912dd752a15487211966d7b4e29619a421959885f4d72b75a249c218d86c23e83bfd446a0e4406a725a97f0cfe02b14e582a9efce4d18b21aa4d05584c52a64b3f125523a51157592385eece9cc20e2ecabce6e17162917846e971c4c395b7a857a1ab4c7b4b78ec84100c92bcd5bb3aed91438abba402743fa96d860fb7453456ea426d2b949c452886d0c6133ec15578a9f74c6252b5805c1173d463dab182b809aaa1f48f0a6c662207395a8158ca84a0cda6de7f2046a778e22d07bb40114690479f169035012379643cbd33597a46811afc28448b52956b6ffa80ee125fc68f08c101f8666ff5d45d2c167a6fcd1f53bce1b6532b0183e9ea2d171061eb0509b856de2d07194569c5d9837a3374adf05940c602b2baf6f93f6fdcf2ccc5c6bd31c1eb7fbc38ce238d359240943950e67a6e01d9491376a29878acb53553d0927a0b0d962c8f5cff1ec5d7586d22eb8eaed464744677ac99aa8f326b07ac35e3fb6132e673497bf74cd590735b77f8aaf1d771c2fd41bdea7831a50b50dfd60d3dd096a545f29b96700edff2c82e5d77f71f55207f8a847a9a305bcc7fbd2453cd7a782b57762f27e9f0548ac7e9dbc5098f962181a45a850dc7b95853353d5cfffd9b67481f24ace73add4e6cf496caab108df0bc02c5e6f38d894b0f8d8e986aaa33ae02d2037f2aad5dc16f95d18a9683b689c9ce38661051a0b0ed908602f625f478202701586c0623d61e4a8a185a5230e8939b821029cfaccc6d3c4650924d09f5e889b7f2fcbc762e6cefb4d69438f2020c319563d8ef22fd3f1432723925d006e1b071025f2d0941a1a651425a78ab625f6ba588a8580afbd19ec2ac1fca741e281f72c9006bfb52aa9d05d35d2f751d4a1d54e65436755f9799eb5a58004177ac98955c28e4499479adc660db9458ab4a99a1fe4a40a67dc0aa821fa13d5ce680f7115b1af259f11e4d0bdbd3472e44bea9887e7f2de11ee3c9e3c05b98e6bccf13906478663e25a787139b10f40872b87aaeea9a7e68043553396375cb86bf12fbf03835d38a99b94b38f6660082ca2bef509c5c524c2314d59a240a8e964ffdefc1aaac49ec8cd7040f9afada7ed78c4d4c0e9f0d5691da98f24e0cf1651a120a6bcbfe078451279428c27a211ca22a600cf1e728db1d4ecf1dd39470c271914feb2d6ec369ec4a2380e16f1aedc32445c1d5794c041a98638823b5f96283d754fb1015e82c367f55ba3b4c6ed28c8be488fdb3b118ac047112f0669c2fc7516a6f45108b0e560b2572f665825264b0aef09330a1828e4e4ce6a292f5b40e12a4d0c9f9877c6eb610d5e8797c8f6025f3b450d674481c470e2bd58185a62c37260b4990216900d7d3e7b37da48ff2e4b5e710e6b3362e2660a4018102d09e977e24bc9ff4f1b70bae615fd60af9688d98c1e979b423f272547c0774d74f7f261061a651b2e13c42e241848a3bd3271e7e012d58fab9d270b9c729fec83b360acf54f7f27a87d66a960c6d7c53e40194998868477b296156fd3a52ec9a75bd0f333beccedd921167ecd8a979d2a3665cdf541983f5883e8fa8047f2cdcfa399d856b7337f6bf16c82dfe11b3449ba6528e0b573d96d38ca21fa412dc4a5ec04345a2dbe403011dd23bb956f43176b60ffa31a41d12f401237b34c8abed2cf2ec7ae7a10c381773fc6451cfd02630ac05c8fee3c34cb16e9bb7157dd95a1b898de50a7207c1ede5234bc78664c4d6d6f30c5c243ea2b55d04c8eed172965181bcea9bbd7e8ac4a8831717884e9db5ff512cd67599217b83782c00dc56c9b9adc41f65885e884e39d5a49e4fe384247171a67f0ca18652f940316642ff21a5d74a711302ee1ab52b6104510bc760ef0446b7876cfb6858662be80992c1f3c4c3dc7dc9ab8f59393a5625acd876f632f00b2d18a9a275d1b7ad6c5930ed9efa275b4979440a13303009b87fe744a1543b14cc8cbb85f47223dc5fb907d9ced65eb1eedf58b7d55a3f77ea39f7fe841f71344650a90232f956accd617b0b54897c531923dcb869f2dd388447c4d4c4f48c90972e527596175fb9456eeb1c528f9d899ca9f6beec51f4ec4be4779cd5ad76a788e5c99e881f6d1cacfd1d2ebed469c2d8017124f19b0fbd72b9e745fbee54521cc269565dbb4ba77e13eafd1246f201edffb4d312d2375dd405cc2bc3f8e017ab65f244d264a37ffe00d0cbd97ba9f05bb865642f51a5b70bebba8217bd18fbe15ead535754292d89a32e582f5c689cf50e0561a369a8e2ef8bffe06cfa0968e5ef7fc58a273e9c31828ca3ae506652ed0069af93ec44645070d6697d0d278269f2d6b02d3c3fb0ad01cdacdeb6e9ee455a88c99ae2c0a3662fbaf01085fc91ff93ec633eaba8b042f2b75b450a46a35302f7126ccf7dd31abb33c78dfd37a625419b3883dd08316e22da99dadc6fd975e793a29aa3dd58636c578882e1ec7ce2351d12bac9cc21d65475cabaf7008a58d3fd0f80be33a1d2bb844453c7d1257c073ff77bffb7ea34c9ea867966ab15edb6f50758704281f91fc0b48ae863fe5ba7c55b0435ccccf47ba84f74af5068111609e85f3f8e0e45a9139d1e0f7689dd3063256fb6877038fe19a356893e1c45e87109512d2a7fe6fa326ee215a3a781862c50d56750e4df3791c61730d272381fa3292922bc96c2de8390c467f72a8297c9c464f5e9d4a24810473793134bc07c6564a6d6ff4e9093c220d5580c94c2a506187bc9fd15aa8699bc528273ea9b29c9e0583b2ed8dc8fbc45a4171cb132a0884b7a5f4932535c787d5235db63227d007326898a54d068339c97136fe9c91f0fdec81b22c3afa37ef1d198660a143d36426d76d05e963d67448f9e3e2896845e5459de8796f8179b27b0913494e657b416c28d8ecb86233843111466fb4267898419500e3c39e01ee18e13b8448bbf34ab725b47c7f5a5d7086f538cf0197ef9bd162cce82fcf4588519cd924386369fa7ea143e9f51e876148a76e7d5449ab0cbe4afb3da46fc385658cd9f1385396ef36c8c73af041b71d13c4dd8e6164a660bb5c46b9241b2e2cb4031f857b908837f31d7e85c25c7b20703c6a0f9ed834d64f7edf2c9d9f4da70740ff27cef0643edd9a7da0eff4918d8eee57ad521fe186fdbfeb5a99cea79d451f31a3de5694a6c106ac1c32ae6161b764c743e1b158fb56c6c1308f924fbb7ed6cc6dfd09a1ed52a3552fecc8578cc376a5604050b017f244bea82e9393c3c8cae0c21a3a0b37005a54b2f513ced2f93e690f0fced099cae71c4a25d1ba8dd33fbf48917eab926ba26530f324f0aeb2acb2ab48516a36c0f069b0b6f4cb5e14585043de68ae08540888b0e405ca85ee4d6589ca18e80bf2108ab92f8718227938eeebef4101d3e15fa0714af946cc8b5fc544af552f13533101cd0f1bc5feeb2b0deb6cf7385825d66b5029cc38dab46963ed5dd04f712cccdb9669493873e39cefd3dd610b303810eff2e8ae75c7b72d13d44488f1737b02a73c948a9ed03269cd2b8f2f3916d0c7c0e84560060fd2c96f8762de1fe9576093d77794dd24f40eb5e6a33fdaf72e577c3df2fd1ff2c353f779ea15ee9aaf26a806fc3600f5babccbda959ac0074fd86dc284e685dd520f12bce52c89d02548268ad80ee51dd55c9e20e0c39f6ba2d26b8c6e021eba5333a60359627e6301b3e6dd5ebd33e4d96cffc9f4e7d9817ddbb88e994905d96df403a886c00c64b618a75f84e82c9387fa4a7a42da5f2d9400115ec19928216f7bb17e0788dd5c165af6f35d7fd442acf97624e846739ff07ee98d1405e12357f11873a0b6302d800a25c40a4bb2b4cd6a37f42be0ee17d08a7977bfcae502a7a92d9cac51378cae0527e4dc55ee8d1c3b4fbda9bf37d97f2815264adb6455bb93df29adb8cf27943c88989748086f14891ad7a5cb0e54cd3575f64cfba2dad4c2ed87ec344dee0291b0f79aa6947ec025b1290ff6215d75c610728892d60e6bb92f34c580b0dda74165075f4154cebde4f262efd74c74c590ae2c7d09f8f4279bf7b671dcf27e4d8aa8868b26b6214878d746c4cabedc4be14edd31c0df179e57caaa085d3a655b80e46cc3ec9abfe91eb0ee0dea0b7eb4c99a57e2b14749f0be37838edbba77388c94fb3c228d5b059b14b38420b5cbefedb7f63216a2706e37128844dbc777c1234cf9d78781a59302a85e47dd7c44ca759048b8f8237c581b49145a19bafb5fd959d73d1aaf975acf5fa7cc8d1c305a7c95f46174b4aa58ebcc7769abf79fed9f733f584e36e8e1b7661f51cf193ce4b1df5b9ba4efe6428a84fa5c1ddf83dd335eaea2bec1979b9d530d2d40e1fadaab1a4fe327f5cee966e25675df0187d39a74ef07d581e8f1cfb576beffd443a7d28d2d4748de8931449dc23e2026240f54d64512e45cd75dc327f4997ca06bde7617c084a45cee2033414dfb798a7f08fc20d42de1c19153b1eb3f06b1d5b57cb478840010adb813429a17a6ba4fa06ec80573d53545f8c5debc6d32ce8517ecbc621511cc140509715da010678faa70b69b24e4c702579b71930cd2c8bb9a9cd7363cc22d9b979bc0a860ef3fd96308751e0f78bb346bab4796ad880c5a01afd3012cc25aa13ea9fac7521a00a68b4655b1b5f1048eb4150bc3745c05ec674543d1b7fa9aad9e5c1a9372446330e63b0f6210cea1a95ab92843a0c570b03a2d71a8b9137020a2b1e625fc07b19725dcf748b3547e54517a0081c6edcdf1c5eee8ce0dbe702e8fc5944a392ea4475e0246cd1d24c333ab283508dffd42ae3496db205625e977c4b219e90d564d19a40e617dbcc9d0930f9e4a9af10006baf560238d039cb974bd700538247f4b2b991ec53c707a1ed76045860c04b8cb0d73e731d3ff09dfbdcd65b48cdcfd09239cbe265310dd859bad748c1556d2f1ad73f31aae1b9c3d507bca8ebb1f339bf04ea519f8f7811580e7d124a119aa7dd350f98e9d46a3ff90476b52d4636f8d64af4cc2959b546517b34a1117cae6aa13fbf7318dd9680fe412a21479369a5fc13076dbd91de1ccc7adab2d252876dc6cbce3fc59df71d22c14b005d0c740c44ae758303011681bb93c2919cb719621fed01d7b13eba556f4628f8c5bf2435eb6fac53142ee57c64ec3f801018a462b519f366d60dfe83aafefcc6f7992506b7ea637f9512108fa78e8a5d0a4663a03f48553578d5d712866a8037","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
