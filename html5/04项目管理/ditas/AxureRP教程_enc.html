<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd810213993aae541097458b3c09a499ff770f575c13faf18565b911b7b9834c38bd521edba0ee63ecb635a135886619c652d62d7d2535d8070a97a6649c3016449f5ee79a5f9dd39d1bc452dcfb80d146a1162dd24b3f6fa0c6bf317b56a9f59651dc5d4a8398571f95db9f0bb517c3225641befc7e683157a3d9a311a35e178d60605775f59ce7480569c7236864cb95d7e42e22a2a327f45781afbe899ec003c21aa3a8a9d31e4dd78e05dc19e884a76669ef888c04c49f184e4d3407c8ac992941336496476a2878bd609e338a0f1b3d540ede2b2036fa719adf109fc2643e49e6ba60fd2e06e3146e1cbc351ce9396068ac53d8439fa08d9775b3ca17d64c23e6767d1a52a6eb7123b84733ca7a6d9981769d780651bc2edb51682fb1e48da8ff0ca11a8117a7326d9d08acd01725ebe6ea725d128104b9a24c136d9f4f4ecefa4b3c4c0e160211aa37b24e0860f50b78ffdbb77a405794f732c2632a7eede06b78e04a28e64a16e1e2ea2b8e19974af55b2a801be66a786f67ffa950b1490193f84c28d8163d27cac35de040cbff1f32bd1aa43ad36ce99f8645c0c31112b829b068a7e3b90ab4f2570b9a01e10ad8ba5f251c37ef851baa4f49d425648dc1c74655ae4188d5aeb614be0ce9df77f1f1df2fe837ba42163213d07ff278053d590e660fd816311c23028c332d5dadd122368555084c5077444b134efcc155f0c0e6c0583037ba1cfb96fda2b5c337b737f35336a5a48d5d8ad93cab864dedef788854a9e127e03b196a73fc9c58f80e4cabdda4a7b46d3e70115840507b02fd53a005f449b47d1be572fa57dcbcd6ebf628d18cb5bc0e391dfd0e8e8224495fd2b653b560fc8c9933efc3b9f349b1164c28246b2dab6bd56db37304196ba162ee7936afefa43bc6cf50b4f795314dc7192b308698927a8f48211969aae5f9a15c1b4f3929ac665415e9ea204f20837bbae77d2400b06b9cd965c1a151bad133223c272649989af75a5af934b086b013806805a7da80b7c6fc9c06b837b8be86c237dc01003f3ba590c75b8645c58a4fba9085f51f1d44a5d20542369f59bd6ab06bd50a6c23b0c8fe13a629b23e615b37d93e9d9c4afc802f1f14c4d871c940f8c64cba02b7af298b82a176c3798a3b95cb7c985619f6cf8049d8f6baae671994ce99ec2c587ac958227ae0b9b1aaaa1cb7db2dbb1ed2e0b7a3acb841eea21244a2b6c6e216826c6278ff7a0d734b8852e85ca2380324178640ee20768061ebc11cd7c8acfa3910db1e2b61b44e4a0069194314525fe6d141062611b7edb0e907b8491db0c5f80c08d7f324af7eb9165df571b564d5a5f62a16c3f5a55edf9141ae20f3471c1a980a07246ba6384cf5b9e9ade53ee60d1665963723bf9eac3983f734f53e71cafddf8cea0c88e9c2000c9c41f24301907fbdb58a76c5ab93a0a11d003e3d6f9014a5b8c519d9a144cd4bdb1db84a358c040136e3444dcf13ec34f27538c80583b02e32a20fa2606f4f446961252e0757f62a91cf0ec9e38025aa41b2a00613dbb8c1e9c10458118ea6c1ce35b7cc915d0cac6e17f286dcf8ed887b3c8d6d135d98e5ba9d34642f45b9996d559299073405f440f2e87a0e4d689e59bf680bae4e3e03b2864bfe69d26e26eacd977222e042d568e818cb72489a7a8fedc5ef34cdbfd634978a7e1981380d7debe04c70abf7e772998f36455dd080d961feff9649147d0c5c3b661cbbc61b225d23a1f68d684fb3b316583b2fa30772c50395eb48d1841092f5448cc3093481aea0118c7f78be445aa23f5d5eb506d800e1120a5a958b38222bc05228442d2930c9a352b629aaf819316be689895c10edd599700684400c9dfa2a929e090a1f552e65c51d80f81da5b8b4343959cfdeb38ad5f4e5d18a7509e9440556437524b2db0589cc9e5e2f04e18e74f51311a5d7ab1155a0a8b912ff65817b3974b6459150c90f314b55b39494cb2737c907c760e50877ca5fa17b3dea65d7d4c800943b75ed95e6fb52829493128490b5236e76c075957e79bf66664eba951900e4ba775a8014157368d70bb5f1e32b6b2555242ba880c7f96bfd46d9bcbb0e4add91da4f7f8c5e8737f508303a8951c0161b90e5ea32ec095e7ba5e4e16eab8a9987cd2a71bf924599ab86008bae1efc070cac19fb01134d763c2ffd67d2251f9d0cb734483401ef5279f64e4ac80a31fba47cf12b6f327e0c6a9edac83eb76b67eb37ef2c966c9bb4943a504b9eeafd18cb70614df6375c3a48b3f9d6692cb01cdb6eaed7a4a8f4917d2322e23c26a115bbae226c4defe00f8a2de7f7d190766c23f0239dce1571ca0922f07ad498439206f4e59d4cc414b58df89ab34e36a5fc11a067734d08b543b4645ee3daf4fc5805ada515af9bdc5bcb251044f0d6f33b3b62dbb173109f12382cc8dd5bc0b372b77fcdea5d16af22e83fb4e63e059816d828fd7b2044c7e334284cf22b0223f7172052c9ac5fce3f52f4ece6cbae27f56ee84f17808692008ac2e05976cebcc7d765b5ff0ea555f11dcbff0f58d57a2336afc042aa0f2c0b60f71566a33e7d26173fde6b0e208d63e611b7b59c76a628c5f7c26a83fde0d72fb7d97a074b5eb4955f81213e17e35428ba07d1570a6cf64784c703c16287fac87d41e27609f947b609ac155a576d6eea012ced0bc318722a525b22c71c07352dc2d86d64316b133e6373317f14f1ecd874ef746d79b4a942eef19e478fa1604d1bd3fe6891f7585432c1941116adc85d2676047994eef9f17ced5c25cb5d333dfab837d5748f1977cf7c25e2d96dd268701e71fc6c0b8a304912b5ffdbf164fc438f88ec862907fe871a905f23d5dbe61b3082663628848e8e9724ac335ade207522cf0da99becddcbdbfe1d36e67a221571049d9f88fdedc9b650d06474a6ed548699388394daa29f4a2ab9bcd90100bcea938e71c53c54eee59eae9469c7475ea1ea497908c16e61ffbc2553b20e00c63bc1432ee47a00513b29c4228ca9da5b00b8d769b7f837bc3b334660324fa3edaccbaefa68a76c91a844e066bb54eedfb1e430414abaab76d97d7847eed8c2d5bb13f011f50b8c5751b4971a4e484878e1aa4497ef7ddb1a01417933cd1c6737f0ef356635d4555afa60ee7f49cf150855182d04a8db6eefcd5906b7c371dfdc469087de6e2ef57fc8326009eb26fbb2a2f8f3cf0c96d30b4c5a9877ac50cf732608012f53743952ce514f84beddc69e2a4e829793bfa2ba7d802961344b31ffc7bcd55311e75d418e4b33f5490d4971d5e3c9a0990d39ba4caafccab146f33429c74240fe695c95b54b139b684df89442e6d40154e351a41ff2e4a9ac05c55bfbfd62fe30ed58420299eb4d8c5f9d7504775abf4718563ed6db414e0206b18edeabb3da44d13d2bb33943188b59c39dbcdb90147741a731c08368381516cbb54e2f3bf64342a5861e9b435684d9395a74eede4ccb59a344c85ea743d1ff988fa674ecaab7752eb37f2c174dcb38499ea1f0553e0b51092d3281d9ddc7121d38091397b54278f0c10260d2ea23328c653db4b1ccfbdad3e21b0e5d57316a57101c17bb88c54691c51ef689d42fc5ac799804d8e7dd7ece597cf0b8be04b40cb11c2ac789b4e5f4245166e926441b7273f7f8f2e8a663a6480e6b7cdc89cbfe4a689d00fa1e94a7bf50bf7a76661d8636234451a9068f8ad6ce9e5fb0f651ffdf45df6f2ac4c30737e45f9966a573b011dfe1f30f3c1ac4bbb55ec02ba07b2535ef20e0919dfbecb5dcee0120b9991b862fca9d3e0a0520b76f439343ed93a317c82e6140a575b0e645bad4e375acc78d1fef2b3f5356c421f989f0ea88d7b84a2e3a252cb4ecfdd765bfa6a3eb199ff52250f25911263619ceba9b3e1a1d83027d2ac0988b0db7a8fcbfb18a10026673888d8d1e1fcd921836bc8fa9f963262ccd98796d88908cc381b447c6082033808793e25e0b743f3d047a50e9201fafaf02ccda0bccff98fb2bf4522534215393d934b573c3c26c489b7c1e9a48e24bdcfb2471e994c8da488050ccf01d1ab9d3ff05cd4eb74c24b73e05ffb31d1d2a4983f14f24ed35bc072520d95ca8c6f30c1404680cb5a778e980a02b350de59bd692d3ba3850df39f172a7e091dcdd4d147cbdf6bcb01a846f83e6e7fc9251de9d27e8105c7774da264d56d83c067d6014b43230af302b002558f2887222a130697096bc4c76488bc21c3a3a99e5146ed3f286c6f11ea46b1235a89d4de6d4a976136dcd65e6c824323c47044ac97487517b9e628d867f1b7ec34316cb5209d06aa1adf9c2f7088de7473dd3e1ca85dd4d8f52fb38b2276aa78ad0f7149f533acf2b77b48ea600e861213bde75a2c5502ba4697149058ddb74b7c91061b29a538db27322d6460e659a7e4fbe6e114b05304416188e1a46f5d742727257901ae445db2d04bd350316eeb11d1e039281d9b164fe89ecb9ddafe7fe9fe8a0bd0b92f643119c83b2d77d4c63c528fd1249f91d517b39580e9577c8331eb0145e60417b6f32faf992fc31a95ad909d921cf347eeb6897c115568d8f4132b5d72ee673d2d9d2f5d25862069713e0645fa660b1806613508ae9b547186aa59e5abf75b4113fc815117e3aaaff3aaef1c21552121855178b6595da74cd3d3f44d0e941bc62f783e7f90d4c949be14fb68cd3f62c07805ceeab178706021a658212d462fe4c61208c7af54fb2c0264f6e1b593bed8d48f62746a25879e56d1f8d5536a7bf26ea7b6dc8e77210000139b20d0f4bc63dc2c1cde218fae71fae1661641e96cc1c0049221e3b8c1a96ae3d06e0a3c22272e933ac6ccec0893239915ca378d90e21c9d7053501a768141b67118f5bb16015b5a133daa48d52dc2ba8a7e178c8bef642f20cbb175ca7158970800f1b1b2ea45d86794610cd5fba18e0920adade71fb7250f2864c8d213ecd3864675e4d17b4d313c7a8891519612f61a907bd2b68be33b0a59c85ace76848f2e931bfcdd36c0bda5cfe9148900df8804ac57b456fddb6e476d7d506ffe72175a4ec24b6fdc031cf69b496f56065ff741762c192f4fa843cf4ed82235c70b7833a68ad7112352a41e385bd06d63549684339924ca67b6fcaf45fcffc9ae368501a447bc4e35a1110550cd95f704b05b8939a9b0c9a5c7da167319162f2c252d85c818eeac44197fb9fb0410e5d1e1a99e0dc1792fdbdf5600915131a4f5ba15ee49954105f4871c8238038342ed7a07dad85a73334db4f00a7593d3d7af199a885fe603a0aeaff6f9df02fdfba0bad8461f54c9fb93883c268259a6bb66e71efb22aa7d0bf4e07bbcd3952cb13a068663e02aa300f1f727c02508c8f54ffa5ba4de6f3b66fc9614c4a65307f8e8d32bb14aa0444082f9a14b9d2e9d94f434e0b8c5f283165c88abd63d0c9a5156d9a96813f129c5380e3a7ee2ced4e01a2a2ef43645cf159fff4d65602d418220c48254614830920f121b1f03549bb2d031436e9c646c0ae8f04524442e553368dc65c8ff033b7d122264ce852669e5c5fdd6e713dabc197c169da0663b0a6d6c0bf6d02ac0c3507ab75391d17113e2f3ed79753cfeb42ca5c9c1630912263b1509102488b942fca20b14f54faec4d90ae84c2dcbd268732c02dc7b5b89535e577fb7993f3c9bd392ee5170a4ab3cbee6a0c5f30589f44decbe3f43709b9d91c637f096f6a976a85880afa4d63c1787acd7cb6d26271a43d307ca212ed39c64d6e80d7105a0fa29340faa2c8512fc8bfdffb55a55eec6908c3fb6e9be0aab81715d81fc1a06aa8d49100317f9cbf438797c24cb18624d55b2e08e6648267e06a76fc6c8ec15143bf72dd527ac236a0bd3d0a9f57a3bdac4a9d1315513ba7537ef3f19ac7be62a115a6cd67c5518f4306938c28268a338be0c602242e03af53f24dee5f114450e719436aedc2587467ff534e821570941c19629ea02b4b93eaca5d54cc1951a75044a2d4eed665323cc8d450c86b37324a637afa87465b57141d1d9242d0b3e5f5201da219bcdfd8a95cb2cdf08c7b4c494e66fd56039e011997f54bf71b6ad77652d7abe0eada16bb5fca3d1bd67cf0812068a595ade9573e8e9ef308f5b9bc0fcdc477972d962406a0c9b123e1a1e4095262920b95ef4b6b7d2f71f57a96f116d44ac9103eaad84d49861e674fe2c8b3a185ee5d9cde57c849e9ba471aeb0fc6ac2d44d62cd0b2028723af8c0fe266b69b6c3bcc5a11012a5a1a8ec18aa629f923774d34438f127bcbdd36bd951d2cd42bf1fb91fe98a7e3c18c37f1cb4e9fc0614c7e3656af83e11cde2b2444719e98315ccac7ccdda184935b14baca24a675494dcd216087cf7e65c9e2f3fd3c97e058a34b857fd25bc3bc234c70fa541534be426a60ed1f38dc61851e0df039518ef48374e99bd91aae35cdaabd4de677ab4194e5d8b1d485f1eed2443895778beece9e00563ff17ee82a2c603e55dbaf6ffdfe5889269d93b50349affb83dda97f8d389dd146cb507faea64f04e963f30a60ad39ac76af37460e87f4d1cbc76cada358eb6a151235421ea6f3d23f44514e3ab83faea22a91c18cdb57459c60a6e3489f97d22f6ee75cf9ed3db0e66b9a8ce307678892a53ec090580aa206994b4bff81773b27fb60bddd30053aa3b1e248f5080ef4ae2f18b7315fe4af4c618e73c9bdbdee57afae43930d351bdd94ee4a285216ce50ff78e834c82e922c5977937ab0cbc71380b42302ba9dd05e813ee4995511c6d6c8023779d78695c3d103b10e88cb9f812c2d4fd1c7bb9667228f1caf00f204280281caf522cae791d1ce7bd98ce6f765b4cc866116b9d7ad3a93b915ade866b131d65ecaa6b66dfdd128f84aee4c5c1766237b34f9d88a7544b3a4e0fbb67b8c3613570df209d0b053f5d6f0b3ae96972035c6085786b0f35ff4a2c37132441e19fb62af58f8ac262cfba7e628d30c61dd34521582fdd9eb76c36eee14e8ac20e0c4015f4e636ca1b75fdf4fced525cdd4873687d59cd0d85fd976fc35caa1f00e9588ff3ef297f0b4fd66353b4248f9b093fccca454a82f9171ff0e4522d10872fc6d9ed5b16cd507d74bc51e7549578bd6a12e5155fb6273f654a5e4b6ecccf86b575a192c7678964ea758aab42d15941c88f0ecdde5601f80a74e5efabbab38b1f5ea0ae144fec938a757f373eb3d45c1ae3d47ccb28bad9df524deac1acef249e40ee6c4f79319d1ca864d0c61a67782c6cae2079ba3f94b56f0ec9a2620176338f886353bda561dfcc1f1ad9575612d5658a94d3221276369a77992821917d7bc0ecb61888dcf0546d6accda479ead968b732a1c5c188cb98c35bb3253423f19a1fc06648156db8e5d243b55231f7e6f8b54ceb41414be3d9bd68b6d01ea9acaac5d964080536432fb5efbe5a1b56518347c0e041070e2ec204e4d4ad87a05302642af20eccb3f7014424b90927034ebbb5615c15428823e69e15a7458cdf9bc9f0851bcce1945fc301762b5cfb7a62e8636477a4e713e5da13a8d9bcfd10714d28cb687c8d0a2a1cd62d8f27db05d500f78ab2c16c48b0c2e7018cde84c351e3b53460a90ecc2c44695ae3f1d75a3dd46beb94af1feaea328230915d6ea125f07a694478e9132b614dd69158ce87fef11e8e670914e3f5cade02653394ae6bcb39c5876f5270438477224bb74cd51d55c0570209f9dd7385d11c9d489f49c5879716108cb1e40766e5375d2cb3b25571f3bd18f29082aa9bfedb4a156b0c81a60e7f4e3aba397b62c3cd15855838f07fee425f3ae7a2eb47b2f6a2fa8374b1f4ea97a405bc75d1dbb4a46cab0f6dc22bacbd5cf79b416879addc56dc8432b80bc404457a0da89b10abba67daa9a8aec13fb701fe6ce8fee5f9339496e522fe18d3235b7ba1a7c099163cb16f57d1e2d1f4d92c4522b9136bd158b7a86c1abf83c002406f537cb948f8a5e3ad3f3da83b290c853adf79c334aa4ca4390256b3d1b3dfc72e94b4a7f46b5e083477cd7a68ccaddb9278e394595bbd5558754baf23dbc6ec87334e5f294e921a3951357cd442b8c5bd477f475526ebdbcd83aa5e1a92679d40f76ef3be69c46ad1ad6fd67fa207ede6ccda77063d351451f207833cff7a7fc437e0e2516e268447ae72394825e6966b453170cccc509741906e33dae7e8df37fcf202a38c536ab578e5dcbed23c7cf9f473951016a6fd52585dbcc25c777983c78d2130398546bbde41b21c6304264cd01427a59bab782305db14b6857e1d5f439d87f13f31fa5f2a335378db80633892f0f446b130a209e04d121b53d6e04adf704c32d51bb35d3b8e0abcb42f9f080f1b5d57f1b1ea80255556240011207b1c2a0062667e383a7d08a5242fdfe0c0b71b7c6bcac57a73abe761756601ba6e5bf2c58835e06492cd467c27535f5ceb0499a5596580cff7b0c7c53c21e5330ff17bfeeab3b6d830415af9da13d2acc2ad3e8b646eab4b12bea00439d9fa73a2beb10b079f1c36a296f897c9781d4dc3c9ffd40ee978455b40be8e246642a5b800b4b909125d30f50a9aaece845dbcaba760114e7f54641b55596f3da8c4d6a08bf5f3f022b328f94d407e4abe94f727a7b73d5ca90726d9f29f60ca4c7140374a1fb8c76d14cab3e9ba34d103abf69dcddf24d3f71b717546d6518149842adc32d3b53d80aaa3082380cc483f09cafcc8f8ad4c4fd2fc9b851aaf1d8b82f5450d942023f140f3763b183584297033dd409e9321ed35ee67f7ee702c7b1f94aef7bbe8a892e2d162280282582734d96b2f308cab8b8aecad5bd15d40dade945a657ef37baa05769afd52483a6cf0f5409f0dc4301b70a7a9228226d7c99d6dea5bd9338c888186f28f7df66d382c3580880af7a8a09945683017b64ea1894e36634c6f54674785c81b0c6350d7191e39184a70cdfad4cc3638feb936cba09772cf8db361b276f8699a2153df5a8d83ad128a0e14fba3ffbc2d0e976f043cbac35be7df1434e9ed59b4973a5f0565b2e57dd1dad55d3e7ef477a2b0c2fc68dc6420480adcb8cc9ad9a20f6602e22af3c40e71aad64d216ba5a40ac65d40d06b719a66cbe30772e2e3680e134e75e5b74d5542fc92876496e49e91070719c0bd55e23188ea6b840423583a1a6f40b2dc5b131a20f730db263352b19c77e03b380daf9c8a9b09311932a96a4dbf5a62da2e154e0a8ecd898c1b882af2542fceaf05153c8b1d553fb0f5546db514feca8675c0e97b78bec460c6460a3b8e4948ecbecf7541f91f43ed9947d2896bdb044e3fc0934a2a311f28854e3c5f5886531d5a1ca8baa34764de3b3ea3111670750c18df4f03cebe1ea175cb4af213c84c4415a6ced2cfc6ae31a220e2c69759b8f6e90f7d3a63fe91290969dc51fa3f16da3ecfe227eb1a599dd44097f1b28772a98dfe05e97f93d0b345f7d731a98d80a1e4b8257a179d067297b4a16b8e6e50cafa5a8a39ae9f64b0b6dd1a1dad8c4783805df6c9c313307e28088cee8ae913ff50686743675a245e430921868a1454fd00c0e8858c4c2eb823cdb3391aba0cd0e6f6c49b577c6fa95fa3b8386491074382438d0b567c7db6ecfe61807538f5359ba5968438e4df08efcd748a1b67135e57960001f0581330d47bbb0ff8eda0c8e2a17d1a91907ce0d2042a7a55c967eba6fd6ea60748e2dea0b99fb6b89f83ed4bb932d46604f355fd6a23f0beda65c6c356f0db5242330529a1eedbd0197654e0f98bbad4db38a136656f25dc39a0fb4d22368b2ff0443b1d9b652af575f91a2ae44cc0611113afe48b0e7f22826ecb581ad615a5bd5f5ee3f4a8c5ea0ca03cdfeaff7a76e9af4888bfdf89f2ff34e3bd251330381d492bc97483c09b7029d819dd587a57b745a4093775bbaf2a815aaee4579de825c72401f8145e802177a759ec852572d66bb3a8bf5f1d9af7b391573ad493a2303fd5647e107092de4e5bf0845b21c6547a9900a3c968609d78557106731f2f94c1cdcb554ec4353bc14f93ca0dcce20a7fbc82ca052761e98c52b93d6c5ff2147fe1d08d386f5c996f2f142d4e0fa14aa5b5693d9a59900c6633ccbe484ea3a76807eaf693dc674be1cfb19ee5c8bc65182e35128b30e370d901a501d4811c72632ba685629ca99fafd345e089ed38236db03464c116063bce0cff3d885098b0fa8a3c2aec999eadfe56e0de60379ed118dbc342fb861eafb20f0205b5fe56b9401d202055c0a8e24446d198acdecbed79b009692cd05efd8095737923761eec423454abdeaddb470bf5e86f3cdb2ebe0358f0095552b99e62b789b07d6616d2561f001e825abf413bc48d2242b2521421eee3b81605608a964b77cf596983e645102791f679c120b3ead972520d9b1ef93041db0761f008d4c2ca13db242520742f53be48f361d76d36f2216328b140fe1b43278a70d7dbf53ff7408c3ac9104bbe37cf7bdf24bc647f4cb74c6c5377ef5b3716dac3f692e847722bd2ad97b84f5a14accdc9cd37731071891075f561341000e7b657723dbefdf0d6b6a4bcea4c045df317145d58b0e01e7abf606cf75f7c99c12e25f82a0eadb09a0e4b0f4c9ba7775f72906940f2567a01e02282598978b2d1626881d9f185107b88f99e1381b12957e57ad3090ae760aefc7badc3c4d591f2a3aea11d250d70297f0d9ab7354abfaaee174c6c514738d5a0e8b5c79e09a78dc50fb31f20896f4d5083ed4d3b06983b147204667a4652c1c2e8b9f6d44b31666462d2a47a2cfb9e47bba87839d342f98581e184f0cdf9ae8b29853f3bfe9605281cc89a167c9a203f2e22577f67ccda2a42012c285971d1230a0b9d62ef9bbbfda5fb04e25da80e4898d17c650b5a630dea1e3c492e62ea3c686950260327c95c4d4578b05655b0f00e6011849c39c2eeaf5fac9c63c530ce5df3937c3837d1108fafe6c0d4419f78d49907a023cfb2f6f0ec841edf5b447c44de8783656b4838f67e9f82348aa9eb0ea266e4c72bf8bbc66074e1ca5c22ecc6f041be9efa6457396439a9f426639f7f2fc74003c177f3fa66858007444fa09cd851cc15ca1712413d04980a926bc564a3154e53a30822116335db17ec60792bb620fcf1b53b6b9d3ebb3bfc2cd7bfe2a8d76c87f0cc438d23db35dbdcb911bfb12124dc6f084e7b14c7d1bb571ebe89bc77fd9bd1f18ea4824510a0afabc47e0dfa56b987df2f1392e92f3ad56ffb09a509e317895b802bb5fcf31dc44c7fea61f2c6b531d2e8c61acd25efbdd1271950116b0631608f184143548403088fa22e894e89693896ba4ac651920524c4aaa60471fadd124dfce22aa2709bce417116d8790787b21c91ab11d72b2e6c8dfa65232d841e1ce1591ff7b050d6a68b8cb5b970b95417456f01328066e82f8dcd775c10bf395df96a6fbc0811b47236164b7476b1a4b29f2995e9fb57cc2b07029489614401bfd6e8caa89aa6e87299ed59f79abcceccc9780892ea6b3c155e5edde48a372b3ccb83ece041bf9ccf535a513807edbce079373462f01af39bd3edf449a02592afb7d73894f5c8c1aaffc155a4f514f90a1d0780e7d068d15763ae38d88e1aaa42231e8e88c69ddcd49de64fa92649982b765acd1afba03279ed41f1b7158a3f83ce39eae19a8edaa3b492263c28158dfcf66667a56c6f6744996213e5a699b5da77cc9cc5fae40c8d25ed42b863d3ca8421052dbe1b978631a82cb57ed70957c4e08c0be6e50033d17c46080a24a679f65a9982c79f0fdffd448ae667986e81988b191e01a49bfcc61e90d9399a936751b11dc8d5cfb208bf19ec0ea3bf600efa8d764d708eec0c0aff2ce08cc8aed2c185f60a2a7ace01adb5386801ac1c4d5c4225c5666bde32cb6e38fd92ce32cf5963787a1de4e9144aaa3ba7a1f1582f452e4a5698d53bd09b5778abfff11e3efb44e3d59b4f6e7bc90265250c69d49a9fedb72e9a0ff0e0e39b09254da8f6aa7a577056c6e75af6085046c806e81d5143edbc98ab6eda962ab97b9d93eb05dda25193520f101d19f6eecdc517be032d5497f48c107ae419ecfbb1b73f10c41b2fbd66a3787e03ad078ef737cc7565c2a7f6f396319eb6e312a4e8343e5648f55dcdee6906db69a52bd91f41fcf59b85d5fa12ca0c17a5a7bf2e44f418521fca11efe4bea3dd8f65b544b153d1b07d1df6e470745f261c7a4aca867f88745ca8a4ad2d788b6332b0c771803b311dbdbf3db0827a466c69cccbd097598455fd414a8fe5dd66c97a996e9191a4e37cd707e18b947c50b62db83e6371f70b27c359935f56f8a0b23792feec24e81aa5da5831a6078045caaf63b566c90cfce8801070bac1dd19f18cd1fa265df22d51f063d37a37ffc4cab81c77459dcef6434c58e2f41c57b0525207342b915bbe1abb59c01e2d18b318df291c815a877e1a0c5d918f0cb8ba73d3f7e5a5223f7b6ab1a23741046d6076afad481337992d7ca4dbf95e5048cd0c0bae0baf101d18cadc010c7882b0e54389e29e1b3b03a5a565e236bb242d84ac9c98e7d31e08fcd6baaf4e43128d877f82452317771f285a1bd7a611815507ffc625472b93b7eea549ffd3760da3184908c7d87e34ac70f0e320104395e4169a9d302cc7dffb6b55953b9cf57012e9cc638552a910c104b88c1e8c3e81b4cf00514658d746383e04683c19dd83086cd0358b67a98236c1f3f4db5cd12e98c84d8df697e82da5b66c68c41e8435a31033e575f0c8272ba206492a99d74fcb90de5d46b9ddd504a17b32c49c00fe7971e9d23130aa9a729dcc58bcf06b384257dd0a5f7e680b00f061200048e19302a0fae06e0fbccfb40de942c626aedc39b7e17953da4c5ecf6e1fcb5784b691750c41b6bc8394669dc4aee64d593db1dcf10ccfa4e72e495fbe28925e4a0e2007605f647c1cdfff97a2f5cfedcf556df5fcacddc4cc78f775d1a83d1a6e3f56ca5026d5dfda98026027e754b832696616f85fa75996d586deabc990666e6199966d07fd961bf9ea0e37d400746b88e9f61ab111cb32018efc5c9274f1fd4c50b92aefe037c8454265a9297b9492dcdbec5065f20dfbc7309c757155ca06eee9ee073f85f746057b6cf0de412d2ca9aa9a0e5d47a76aac148fa46c98f65c97326e152ad90d6e4d919dadaa5f024e6aeb22bb91dea1d2262970a0644ae63dce5e0bfb721e20b4bd6505648ae6b091b407a6145c64baaa63b59c7648c81f761a1a8a6fa7df96d536aac9adb54fe2e90b1c66c0d7cbaa3380f8350ebe8b8787669e710e3845cc951753d12bb60e2625a4b0ae53c415dd85a62dea6b59d313da11a22621c0fe8dbb8df35490a045a79fb0861a2aecefc7994a7a179b52cba37d0ac1ee3950fefe71b922cc16c8c5eef5fe8a798ad1d232f572ecea783f23bfa14f42860c5baf26eaef72f24dbc91cc803140bacc00cdc706411d793254304eb3a0b7a2c70525dba6f9458ae11ac4d9973ff2fd918217b7c2f9b55008f986044a719adcb199efddc142f770cdaa0c03f5162265b44e5736d7c8c997a254f5949c1cd60fd13a59ebfbdd40b9e8fcd4d0a19370b723e28cb40a63108b54c412e21270faae6ffa68442874deaed9101452dfd1dfc830f936f921e431cb81dc7d6fc0ba3d128e432697f23361535131c121403f1e11e86b52db90f7328a276e9f9ef83355f4ce34df19ad7312f39f61eefff87dabc37d4d1cb13d11b38d4bcacc19eb500d72bcb6a9cd8ca72f5ff1357bd269098186694df714f2fb017fac83779234e857be9ce8af41e088eae8d08f39c5076c9ddcaf9f6dc29a69e6de35214d8100f830517e88acb797eced3a938e9b8534a8640a78ab59ba434b31b19b453692eb906ec0ba64bb783def49cee65733ebd9abdd372e5190819283951c87fdfd1b70da3c128304d057c4c6a3f58e56ff29d8c13e70618344ba833134ddc346c7c3f936b9facdc1cd6cf8ba436024948587469487a75618ead1cc00789354c4a0e4a3b96659f0ea73f225138583daceb37d7d60a0275225973e4196580a84d1edf61ab470b42537ec506aceb75c74e5cfaa15751967b321b98761cf6161347670cd4c6cae13ecb2e224db25969ea6e5a1611ec6a31210516fef386614bbbc70ea98221734f1744a9bd6b5c8d6ea4f11e27235299a219f41327bf4cdd17a838ef062829eb08a2958b51b5ba06ed09cee3ef5f697da4e718ebeadb3f09dde7b9b92c5126d8be384ccc05403ba387a7839684135ef25f2fb9c002323f869b68a6abb05160c4507543dc74e50fecb44709c9174d545bc4aa4bd92308392b41250573f70dbad6937bd2924473a073be1be8bff68692e7a3d663636f960a4a8b5d6eb89802d9904a95465c0b2810b8c1acfd9821bc767158bbdc67dfc666e16cc2198fe310fb9e93065020287da45540e7c3598060044e4aeb0528f5ca369f90b8acc74e065e7733e3746a90dd92188a7353759be501d25151384ac4944c884534ec550e0c2db0ddd3693f8cff65de309e89b803764e49f39d5a85c40c149d2980961252c163890c8c4c1415382b330e16d204559a9f0bc74574117868ab2ad9c0d2c356bba95dc546bc870c83394552cc40005739cccbacdb4667de677b75191dfc1b2ec7548b381b6b50e18c553b14f2541227af712e1dcb591b42471caf383aa9b1eae27a83298977891a5cd3cc0b888efa986aef623e75a325ff55f5be379128284bbe5a44f6589b532a9fc5ce5e687075b4031259a28a43223017bbe5138d67b8f584e3d75569101b2a4527a4cfc5b13719b16b1ddcf66343224d354bb7ea635467ae3f71db805aefa0d35a0f8c01cba19440db6a7a553e6684b662386082c0c4d98a76d0ddf262f81c789d4b0c91e53a3ba764b6c38748a83aa135029d5bb374ae9f2e69ac012fb95112e429f93184b3ca0224514faa97f8fcff54545e74a856b932d324ab4c4f2a3af92ba902dd54880ee88a757db1a0d1bb290a0cd69fe9fce5721d58ae3d22394e06b1b08b28e089a5919107537f912e2fc5e1037d238709c0db8dc3e1563558cdb5046bbda9e8effbb8ebf09468f83b0fb9edd0122e6a46e18c2c732f741efa376cfce65d81b9910286843adc2712e5b649182847400ba51b99a9386785d704493a4f37a0252af7ad59154a77a2cf9f5819195e03ab07c79846846e2f2d452efe1f0ceadda49acb14ba4cc7f9e0617804910f8288aa88be755dcd83803e6598cca5e77979003a47f4de2b91c012201a07fe5304bf580b4be5334f75122fe01d180485609eece3d02452b08fee4fb42de1e52a3976cda3c1055528e7a5d07eda1a0026d56ade1677f0c34b4f75feb9a968ca65e48586d12c7284b54896539fc58e3509a130a4a60c7ad167bf968d4704fe676340e5f6e046868681117179c051d782d28c08cd4e0a602cf6057747d96683a6e1f3dd39725fb8713d3bec8bc0b9926dbb58bcd543b5bf18e72b836be01f5a152ffa2b7284b75a02273d27b9dce37ebd69ca624873f35639873417a6ed16423f20d52f57cc5e42325ccd5d35caa5e7403e48926b77fa69208ecf084c457755a1520403376d5400a69f0ff03334a743ef3fc346efe433fb533c18fcb564df1ade83ba8f3cbd579a6dd8d988ed80d5a12539d3779e7b888c610f51ab5ca50c015748ecf80974258814de5e883a74c6c83d10f221957dd8d9a066549b2d59950fd52d60d871322509e97c13958502bf3712c120323e63d8282c3c0abd9fd3c25926f2eb85b3318daaa4a08eea404be63c94128ea24f250301bbaa957c01fdf5d120ff6984064056802f7cd00c4060bfe86549874457c71ca2322d100221a018378ca48522abf2205370bbee80a508e30b71865bfea04d2f754656e7510f96504b3bd0bd7616c1c8208e27576d1aaa5f63112e3b7086ea0d5a0f04d985f09856fe97370a13446d94da57cf469c317e0d2daf35c5f36718fa061b029c5674b6e1615733bae71024e1c84be6bee6c099e1ee04f57d605c4b0d5f7bbe31592542a747df6b8eaeda41a3cb597af9fc2dd3df191f6bf42a355de179859c473b2852b905a4d1fc88df42e066d05fb6ab8a83c98561663387f0fc429aba9a299da1e9c305d09448676deef84c3a5d52d98c2985beede2117f3c651f25f0e8c78dfed2fa3ad2698b90795deee96ebca964116d6e85fe3ed61c16854253060282252d32f2d1db5c7269721593c6dab833969188f7575a5baaf98e6cfc4853cebaf71b9d1228a550fbcdb04da13a7cefcfb44c28dd6628433925951f196459cdcd33fd96da7b2754699d7583e705b76d189f0cbc1d7f0ef50499b361c9645f6d6798c064063a3c89460cc00e137ed8734806b1b0f0d7ba4557d08d54c71c0d9d4b7535f8b639434534b278d1d8308220e16f92e629a9bee7177ced022ed3d13983a1f2586eb08df3960c84e24af881a59a522acd480847030428f0634b9956608750f6fb96f309bd07255403b919e037891ca613f70c10ab2e638ac56d05f9daa81fcf9db8138e234fe31944025310c1be228c291b59f2859207885bad8778da174ae308267682a33d9aa04282dc1c23797d1bdd2efb63c5a9be9e45547f1a60c3f08458777a6e3efb5c65f19fa0b32ae1db2f7bd74bdb2e592a18508e1475e72067b3174ba616c6b3698747db0dfa6f5cc18d1e9297e48032c2cc9bb27eb7d60ab8a390f0dd7667e5164e9e8b31db209648b989113a7304f7618238511a954297c76ac979ef9bfc0ff8376a02c462954b0eeb9377bb322cb2af0d1d5acca9b63bf1296b3dcbed37b31eae50526f032290c9e24818fdf586c0deed86da05ac34e16c4445b859276c68eaed76df245c902aa6988964aa550787c53cb0814ead88b187f3bbadca8bdcbffcfd32f6d254bd817f1c2f4c7616276403367c4d4c66a3715a973f95b14f38f35f5d5aa0aae528a5ec5bc4244ab525e3f555cafc83f418f37e63d6c4468de7e4f4098b2187fa4d7857b9e349ed2ee1ea4a65677c02eb1efdbdfd4799ebfa5b4d263924bcf6df13302bb78cf22dbdc3c4141d0474f8531e04a5faa920a5ff053cb06ab4fe0d8516f04460cc250dadb2d4136abaf4a572e0e8a59461ea4a228af181789f2388f5778c40b329e0d6c7aa9d6890545bcfa5b057968e2f48f5085f9d68abdfb50b6b1b2a65c0d29e755127fd42658db5d9ff9a4b67992c68248267c292d4c20937091fb65f2e0226256cdf84d50b85ea70f71f7fb13e70d11863c65982bbbff2240ff2284fc9f4f00081558227f21114603c0fcf2e49e3b06c97aa6a4d372bbbe3410e12a8b1d8f56e816a3fa636b96360d368be23aeb2cea99bc4f3b3ae45922732f48d6689fa70dfb735e6460fd9b71582eebd15fcbccfa8caa3b5c071308a7994732f448b20bf73ae0b4dc189dab7c9ff4a7710880fa33d8011418a3e0aca1e0d98c868253e05cde4aaf02bac83835dc50c0a420ba39c471a1409fd16aa5419bba84ade48160296ae5fe1b950b24b254dbecc875b59c9467fcebffcb344fb816522d55dc838378cf7c6e5f8cd96935e7247f4f144929ff590766201dee638ff1e1fbbbb03333b1ed1ff23d490f1d1fea216dd5000f9c235db094cf9f9619712d3b147e4d4ac20dfa01f7a31ea4defaa5c0866c24abb5134bf7de67c6a42d7e34ec2078da2de5f24f203615d82c28abe93bce98903c68c0312453c40c81e0cfb95e7990cc9e8b8c27b059b4645a7eb576009808bcc643f5c4aabcefa4659cba37457164446d426e95e7d35d6dacb57323c77939e60d550d98230bd527dbfac8018ae11887d094a94dcb5ae2e9ea991c40cb8de95e8177d76f8e6ffcc8e76d8f7d80b1d8decdc60c5e9054282b57c7b8667f56e9d7479edad92bfe5e2f5177535af0023f0228b8ea47ee54f273480f88a27dff3cfd2eb73a0aff62e555345bc202bd507099b05c8466516cb9692c5d8094867f2b1204b61b821d888c33a05c041533701b5d938d08bb8323f09a69a0acddfd255b10514c163ae6cb8f90ed5a2d203adbec4ba619a534230cf2d33864d320356895c6c4760f68746c0775d6631106e63bc83a3d7d723ba652df528ebdc9991e747949f41018b602b27ed686d0ea6050","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
