<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"18dcf3fa0ac4fec66a0e3ed5356ee2159187704b089da2623f118fb67cd9dab18d5d3896a5e025b99371a8322abb90f1a9f789568342aa334eaf5ecd31f68f1cc6e24f8acd53c5831b65a75fd0ef3ee1b6563a337ebb464a3697beeb61fc6f43b80cd6ab4411c86f0d848e291ff416d1a40eefbd88aa76a638c3abaa683ab9a498b76313a0164103c06dd8b836c7267bafa7b6deec16474a412a8c361de9bf11cd2a5724abcd7a3997f7668da0de1f2f484407b32af30094276c255d7f7c647daab5ca76b28225937321f9bee5c13512558f211866641a9a584337297ecbf039424439d78f28ab51d69213c99e1f2150a61f8965e093f8a4a3052407bf559e87e599893ce8fb7c8a6ee7d8ed3c775f24d280165ca864a06756e5ff3343eb9e2e238c6178cc3e5b183003fcf442e624ba7d2f95cc6de9fc94a023300eabab5ebaa9843dfb0656a7b608762f480d06527c7051c6eb19db2d3cdb6f63cd44f9bc6aa43422a42f783daf34843e74a3ef23ab69bd95b7d7259d8220ee60b65e7d2a762efb5865217c5f4212618f327408e04f598b29c60bd1ca66d96615251221692dd4cabedfac3a739cb71735b0dbc6c4038a20138380ce8766476a809775eec78ffebe88f0183c756a7b797a26c765c1d54317c8e1e1bb9e023089ba2a812580a4caa7b196b19d06322523e831c6fc93af450937342b2be00cca8bff592db3132ae584a63ad9b45fc9a5fa01943e61150ae558f388f4fa62137f010a9c330c1c4b7c92c691888530c09445adde3060984fb91d4825abd9ce7015571635d3413abdeab2956a5a2b46d79d3dc6586318ac0a6e23a78152161a5c92956206bea61ee0f4eb930100828ebb5b5b875768cb8688a2cf436194800fa635b4c81ea16af4ca3646504f5fd251c5238560d45afcc49ae14e09b10c903ac444a72d163854d6df5a1a7c47148a5f9651fd3323575a62ba8a3a4f1554a9f05dfaaa5cf7866ce439a925917c23c0f7b3c432e7ff8067b4d1ddcc749eb4bba481a85888e7fb05c4483d4ec5a3ebc533fd7ce173248363acec23c9106c623a816fae8557ab713811e0e4354f170f2d538fe2d95b02761770840649ba6d2394049bb38fa57d24097a5c938c18bc9c9522e23e02da5bdb175a03a8777166888435494878c5abaabb90af2ae0fc12e7132d6bad0f1b146151a6a9418cae5eedbc73a144e768b7579a118b4451ab50110e3b8211a96ee5104ee26559359ff325bbf62d45e155baebc9e45c86f3e55983dc49975d4f10122108a0cbd7b64c977ec8842ebd4c40016ed4879cf98e4c9853cc4e1409f432bdc2ff72ff907e4d6fac1e24a8f7e09ac0d5fb001b73111dddbd97a8b2a641d8ed1642041b87003b8681460ba201ca9e05804a2e887fbd7aea7b09a6e8b955ffabe6bc418361b5843cac1cdadde9e8eb143e4f3cc62a8908dfceeb8ef0138fa7d8e6188c83fd563afce6a88942bde3115cadae33cfd69ff2bff8e55e165c678bc431f7b242ff0e63a2a37e833d88fcd794e243608abc725670375402f227a98474b29673df002b8bc67bbc04b645bceb3fcdae1dffc39b26aa900badafa42a065b0fa0dff0fe5e176f7a8e68e33045c1be287631bb7dd157ebcfa35db3daca27d8dbdbf26d8caf68f81518691dd57be966e4176ffdab82d8ad910e9c3cb6d613a919d2c26d510f4553cc49e7cbf73bcc5e1351a653239e08e60a144c11f7dbd337869d339500aacc49f88da4fd018e7f691e63d026aa1294ca0f3b0d6867448e3a88ab9c94e7bc979d79784585955f45e16a822dc12182e8cfe13765956a44771494e6651f5e24f55ce68c6efad19bb1e019f0a415eea20217dfe5c052e9186e98bab92b98a8618106da074121a389711a167a52d33c1fd9a8c7465e64071774691049c0d83560e7307877bbcc8d5667a967a51a60bbcac7d94b7daa63c8f878faf450e9ece35914bd12eff9c079425178611320850bc4b16c8eefb811534048c94741cb6a6d68b1a4f1e8288a7f5c9656012c2950a2ea45213d44c524c32525e7544d934890a67eee6764fa0c4b2867595a863c34b0b89b2968d23c0e9858937260a2ccf49ee39ce17731e38e1cba31960b634f180d2f142773ecfaf2d017b4690b4a7c134d6dc1b66d7aa735b5dc99dac8d306953ca70f813e06c9897deeb2d65afb53ffddd756a5726c6f8c476310539dc00e581de01164bff818a4557aa7eede320c5a2d39d844944fb3096d086c061cb10133d9bc86de6472977df41b67a93a4b6f8d7717db4f1280e65a040c69151b657e527e952469e1c9c4c07dd5adfbf9562d3259ba28aec177d7806e2a30f4ddfbc36ff22aebd269dd30a57ab6fd6a746bab4e1f7ea7de149d81957cd20bec5fef3ca71547f0a0a88d3143028ce1c69e46ae37d0310a3cd3de8468067de486f6f679730553c87b004350b7d030cf82398c6544faebe324903217c0d7e3ce5e183180a69423267886316bc7ad2e4f847b74ede53029a92fdcf4271e8b448bcf103d183bf95feaf1731fcae065e7f1a266c63387a5d28632d6a784876cb5f92618d11249c97724ed22be91782d94fe0851a6f1aa23a73d133574b230b711c6efbbe0fb4c653f5df559b4253e6beabc5f07fa86ecc1929fb98fa16e3ba710891a8de87b8aff40364ab53d3b32e560ee2fca0a1e0cc4760d2324fe82a4756553a6a9bccbc25527bd5cb99cb8527bb1c31ea6136d0350fa835a82af045ab3bbf81a3b2fa2b016757a887e09d030a6bf74ff1beadd943820f5516ea8902c56a91b123bc3105ec050741d6bfcc7701e9680a42d98f96b375b5c06c81b29a3cb07653873ff0efab5d1eb5f7e365abf934eabc8b80371e84687ca0f093cfdb3ba692ea7c9102e505a6a1744cbd28e7ca1240730d9abe9692ab77153324625945dbe422b8fd47a2639df748a54212cdc3f5b34c912d9b139046417a0a3a57bb83fe938c3c3f5da12bb320a94b2fb6d206043717f75c4eb8b5a8fefb1c1919639fcf52329f081a8d09e1d175be24cb8661b86fa73c7ed680ab763d630778a14870cf0598e155dc66c3eb21c7c2d6929ccb3ca41d0c53aded314b3dc2ba517bba6ae1c8ce6550c5581f0d037d67d0f9730a3039d7caff7023fbcf16121e576877d89c779e371cc6d774c4a64b24daa75b61f3b65686b7d558ffd0a521474419feb7649490891188a4104414f1a3cc10c815f3a98cc7f057730bf8b0971e2c9885f183804b712fa4f0a6d51a4b9114a47d66019e5db366a75a31884f7272e6d61401648ebebd363e5dd5dcb9faefc5984e1418cf49575c5ce7ce318d16eae0625fb36bf354b8e8c0e921fa52d06ab47f8786f4161d1399526bc6b08e9acd472ba9f999dd7178c2061bc5cb847802c9d74fab09e3eb0746848e5bce6a90c6fe09c64fb62a0d4dd280e65fb6644667ddd77398d1bca29682b059b667ba66d0334096fd2c17f507dad78a39cc515aba74014e25f564a4753db554d5f6e8146234bed59fb722f097f8adee06ba42e3985c5587aa4a8b9961c3ce1d0e3b20cd24a92559c6329ad8dc14c2707f8c26d521637c20cbb7ca4f54612ec458268b4ccc679c0a2814bb93c5cc890b3f4df41002756670543f0020d4666fbf49c5e3b6cb9cb52e4a78dd4a61ab0abb3983eb42635dd7d141a4d5cf717666f85eebe8289c27ead364542d140abf4f8fa34aaf79608d72679d913b50e05c922fc837aea99efdbf6a5bb9453cde234e5b68a49de6165f8a924ed072af9528ce3a343de27152587056fef8ee515f33358db98d26b87f0b6a2eb1d62c4c80f1f0b3766502cb88569325353f7bcf200f96d87bb82bb5193a1882f824e3612aec07ad1af9aa1e7b7cdae0851ffc65064490edf2cf3df28e9cc55b20699b39c38e2d6068db4c4d062a12494fd24a52535e8a0f8292a9bf725e79faf805164df7a0ca9ec81a434a777fe3e1881a5beff8c6ea2402da1255b6c1375b65a8d9e102ca47032b321a31cccb34b48d65639e6acf27dda8ff9ac12157868eb39915ab0d15653a0e1f9f21589186a46834942db20236632ead14bb25f374392b2fb5ae90f499f00a872c4a4478b569d114344345a28cc82727b6471a4b734be4bca70957ec2a3cf1bee9580ba619129683f5c172f0504e86bb0da6639c609dc8ff6a8327ec1cab9059b59d364823c501e9fda450e1f897d0b0be1889f4607a7e52493f19c13a27e20122a01d371914cde64a9b8ba7fe66770369c7b434268f03d0a86b4f64e5e49d75f22fdbece42e313334caf034eb4fa74738818bf12eec658526319c218d3905ee474bd1799b33641ceea350262d75342fa28f53aa7a0fd3160ad73b26a35a4bd1e94b5de99a4e03fa17126227fa96156d11b879456759964ab4d841761ead97e1ec34991c263ea44c58d51844be169e3ad94c5195e04687a09a3ce4ceee65170e354cdf3fa472ad57774a4b88c0711a0bc0ffe88a51a5db8125b8d193b5a55eb4c6d693dacef4377aa6b22b31dff4c2801f4254afe3b45f901819f532030885fc861c56428ce6633d3b2c3881c2c08c2e2569380266d6db2e5e624d862ad6232d6825b23d51c760112fb8b925b7f48eb9959ee9e7d326942b86d2d5843166bcd8c2ef6ffe14fe31452c58f6cc35b02252e440729599e71969f30c69b35aa72051ecdf50096a87c467c40cbd4284af1dee9c2ce153cb8b19ede6a2ff39faba135b247de2539737302674a2dfb026ce732009977a0483f4f5151f3b48abce9d83300926efab46fa9ea26328bee3f94bde19b5c2a3fd68b92a31eb5d2b509a0bf7410ce2a3572de644d17a9eef5549b99e45c37b7be8954bb0e8e1eb7890f42cc241890aef9868a614df431d2921adf1fe82f6fc6bbe04356b73ab5d6d7d1a361f40c97b0ae3a7c80d9293c981d8ef44c2483f09c623f08e0ff0f624ca1ba7ef56b47dd5c7ebf97b98080256d91ceb1b673da3fce4cc8e08b8d9120e4689ba9506cc47ca37b1ff7bb82c250576a60138652496adc9ae9f9d4fc0b2431ede4fe6fb5e86fff4a66db4d9be0ba8abb8f47da22e611529f860c0c497a7fb3884482bbc3b18ca9ccf1e1f05727aef7eebd6b498483bf9cdecffe86841de4051cf0c9add431f7cf5611b23683907a174a45e9237276727f53ee910acc85d12c50f4fcc86f67896896f657a3dfadfdaa251d8c165bd7234d5347c474ef023363a2987aef62e73e41b7189d1c9e200f8ee5babaa9398e72b79c9d7e0df53d8fbf932a907c7c4e929ab1b9bfb20a40a94604f9349b7bcafd0935c18779a4ac4931110c8d10c31acc3eb5afaeffcebe2f7bee0d85aad0e0e4d48e43b4a2070c017069a68ecc14f133949f74fc1200c51885d9eaa76e35b2dd918dc8d337f1bd448ad2d4a97648df1238aebcd2a54366bcd5f9e213ef08400c33a1ca2cebaf43622ecfd21a9264e0b27db657fb82fb443b09e5a419d28b3e72d3c45703879230d940d51cf5afb2e26eec3d58495b203600d5edc36972f744f1a6af122bee101a837b335d851dc279eeceeb75890b7c3f7f7b93bef18d1d3fe12db7eab6ca1f528b628c6ddcd1995e5803689f2285fdd5993f9f23f7144b36ffbae4fe66e7f7f82da62b7aa12586a2a299e038ecbc0460a8098f843c9571fc1ff10fe2736074199603298d9c5b73e07eef7e55b1767422af1c9f0bff3bb9e81b24f08cb414ddec226574ae5f2e23d51d9866b6e24d74ed41c45246beb8382596fb3bda835073430f0106f3118e01d85a702605bdd75644e9528f0a521ba34dcacf006d79519b429ab6e7770c7b71ab3479455abc856ae9b4b60653e0f2734b919d91069ea2deac24f9f84d8704120dc3041c2d224f9c917faf16e44cc3b62149208998da25114106d60e9476352e05f73ce54ff1e450253f1ef7812a7f2fe41dbdf8b9f29829b94eb82e205ea2dc227ccbc9c6d479e1450b0f525347bde29e28ccf7bd664254cb84b019c9a6ff8b123ea2287efc8963908e1cb21a86ea50161152078b5e6d6b4016f2a5f521486fa1204d594f827b761ffb315c9ad28c2a6d486d33ba7bc5b1b1a24949e536f1ce5bf5b1847973dc5c4239e80cb8a336c664d08477016b675ba6edd81706848aafcfc383a5f3adab409841ec57c4f301bbceefa660fe4d692aab3feb612f45e3e53d9dca1ae6bfeaf884048fd2f673151c2626f82cce3039df411ba41460f655bfa9905b4e8a8e16f62603ae5ad1f5970a7217f43e2aa5ca11e8c4fe1d1e0b7fbce5bbf3264c279c30b6afae01072edf83252aaaacbcbe3287fc2020bc0430c9a8f9f9feac9be888b000073da2298fd1705aea9ed93d638935b408cbf331232828e876a7ae7f637abe07ebe8baed97ff985df600cb77398e0421e2f898d6f8f86a1429db2e4e132ae9a655d6e816bf802d16e0f942db9619ab68c0658391c67b623a50cad7f7940a5a03e16c10ea301635583f5cf9a446ada6f35135d6c20f9e7b927a0bc4f2c4bc0e8cb7faa0ed647fe484b98e41fe0378e4c243b66af0b9d047889772080ce9d870c96853700f81a813ddf718dca2519b22b03d509d48764bb17f2afeda4a34e125d07be4c036a486056a75cf715a9c98ae47ab993ce11ad1a3db9e2f78783691f936a68ddafd8af1d868764d8c694640a0a3a60cbbfe6c76864ff5fbd2a2352937e92fad5e2f58a1cf2f5e8f50edaa9e5b1aa1922cf2c1fc167bb479e54170769bb20893f870a5864c2bee2f144fe8bf0d5478ce2fb426975ae0939e5ee212f27ef7e7935aff78cf3a690ffd7d008177df61da80af4143fc4c8c637589041f3e0c323f7816a4a7280f29964ad077ef4bcde10219f205ed52e8f6750266803e94fd02a0ac87bae40818eab13d5f8f364b8f065aba4fd3d380aff31b6d321762fad6f999a645c3391e1433f50dc944921a141ceafb7d17bd3532535dbab5b4e660a3406e88b87200b914e5118a598cacc4c97086b751e697b9595e2d96b84d541fcfc22e36c2f31e4890e7564bf15aad59ee1999872f98ee523d7d0c99ca6e95c1ef3e5f243933764b42cbcd80ce1ccd2ef745019cf3e6a058955dcee956d74113c07e511875a735be5a2098012427c4cdc58c98ebead52906d10fe2d1411a5ecd044841459675546b53f838a6db570365e396d67dabadfc6afd15c7c86479a0b8dbf864a6e32f336bc1d33d69b74c9ceb1f65d2258b5a433648313de76c430a87d2ef42d92297a42a9ba655bead5318171678edbeaff66e162e2d4e0b3b05f79ff921e330e60e9c09aea0ca0629449f6f944be1e7ff653163c07c9242df578d7d502bcdcf802536a13949ba82809b8dedac81b2dd24fbbbaea41acd9df012b040a5b9f1e1029e608fbf513a68632e1e9fb4dc2beae4c702de3698c7365c4b77e553aec4f7e108fe5428ebca5801ae3bad73ffb65666e0f29ce2fbfb3ddd1d177cb67bfbeebef4510775bdedf88f3dea85e774f002e4fa01dab461bd44cfff128634bd74bfb620150ffc9f13b651541b82d1e016393dbe8f6d1694bd3ca9b7a4a9ad618639ba98307471721cbf99e9a44d0b66dee4cc1746e9ff50e3903d1324303bc8c1c5320013f9bd1c2f5bd00e4a5a110929ce20c9f6930426e4e1175bac8ec9fb7e9b0ec5afd9d190decd269da75e521940af63e37c0eef0dda73c6b3c076c7c9c481035006b395e805e95aa52a50ecc6cbff691349a2f99e4a74f66102d047cf663f0eb8899c34a9df5416ccec1a29380d4a3dcd33cad0586eff69b4912e4df705c441bc7bd18ec913cfa020d1a3e8853cb834eb43788fd0e5e47c106c7f4cfe502abc4aeb947a9ec8e79ac82a134c5bb0fbe3839bf24e45af1e155131fd777cbcd6dfbfb9e91d24adc74312fb2ccbcfc5e098ac54a9331d52bdd881c81c2335579bea174539d634b4e4bab6524624f929b879ef738cfc1bb5acb4cf37dad3d8677f466c19b9286d8aaaadb521c40b26a8c2422a2ff4443e32991592f7db7fe0d993121e10423edab8764f6a645f47c1ce8645fee343ab3aa1a6c0eabdb85ec0bd5d7da32e0ed4262618900f778ba4d6ee6f14e750f274da9ed0f2a75b0669c3d622bdea2c6313a09c7ce77e5ff1c14ed500f5e6418bfe9dc33bc5c80e02327c478c933d6bb69927d506f2af075a096ae36daeae162a04b870b67ef28f08d45619ff0123f6868727f5526efb12ddd384eccc641c42f2947919518b97e816bfe2769a6bda2b20a0be2a9ac39c3bc0c7136144717af25cc0ead529cf7312f80f3b0b2c796fce37df9fe35c86519cc306919a40f7c4f3751fc9d05610fd9753c5e07907f85785a85a0e571e88d19dcfa9c0a75325c0fc9dc272a7ac5168b2bd361e6b0fddc99b2de9aca1568dcfe2e8815dfcf115d5d42d393ef3208ad642cd4fc9090496d1f54121357dd4653e0700db99913a28157b16b6fca62c30a398bbfd5c41b724997a0293fd7b649333c0f242445d1d4e35052d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
