<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2924036596864d6acd901ddd02bec36e7d812d651293ac7b1adadd10530cdec96884edbb9a19db11474458395f5333a92301a31a9fc96d330dd58f39a8a1ff510542403c5210cf355fb6c55b2e3ba1d26c8b89db4ad3127897f16713f5fd90751923a9357eae3f0329170aa3c30e8724f58f39a39f333789648634a5994acea3a5d3b229876ca8902a14a215732e90542b3c599a87dfbd09a016508ed728d9eacccb7fa7f3054cf8bd46adc9283c3a8c79f6f2131deffb90be2d63642672988e6b677229c6273db7a128fa730bc4c44389785fb70b30e901e19e995da9632ca4a92c918082e927d03c7c4931cde558488aeace06952d40e3408675ad040ffa24361aaca461ce370dc7231f4cb305fb6a962d7316cb0025d75dc4ba170a7331bd7a304faf3bf40fd9669b1fadc2e198023c03905a50f139905db67828223e53f4fd8c834a670e8c0688d282e6ed91ede1be2ad8a42b757a32b69001b6fbab27d7118fd480b21eb211d72a0e35b8ce1326e46b8ad5ec0fa848a9915ed197f169f79f6c8887a1335cfde0896faf9c8d47a187ee687774fb6da72469e78e2f56c910635bb25b802639a4f81cce1d49bdd71dbdbd2a1b37bd3953ee2a0d97ad39853dafbe2230805153ecae2deb362bb830d2718ed7a86168ef4ab524bf3e4ef956ebab46a74fb0c7840a3cb514fef22800d3e9c52d73f70d4969002e21867c9402860373aa813c64d67a5d71e50cacb66b46ccb96b1cb132a9538f677a1907a639ed5bb287c577d04cb8ba82f92142e2fb4bcc6c6fda2612cdde5f282e3f88233db6f604c6744365fe383fd8a8c2a464ca10cd5ac4cdc342ca71691684e69621bd5b3f7cec2a216abb28fd616849b9a9659bbffd86099aa60fbf18e9ec8f33744a8e506f3d49cf0712922041deab7626edf78a8c33853331799145a26475124d5831dbf110f2e501478e02d4863670c444fda1199664ccd04cad7ff41c42c5e1500c793001e994cf6092f443e2205db2cbe9f1d397a369cf64f5fd11373d5fc84c0904fb48bb61647079f182bea1145d390c4b9df4298e5c9d6e734ca3a95f909e1eb146166c228a0d6af5ef0f9041bf34c0c548dbf5faf4122564607cef04bdcb74270b2128dd3e8f6ee9bf26a930edd4a3d2ff28b481d5487a5aaff18febce7f76fba69923f544eb58714a31ccd5e803f67d144ea0997be3f5693d04245eda331b3e9a1bbf986e73d0d1a112aa20e32c12f53520fe3924170bffe9b38c266d552a425cbd458d900a85c7bdb70453ce55a917be7c2b7bb6c9cde48ff636dfa1734e1362cff48315889a6cc71f362a027b963e92f7016d84b89be2826d9f52b7b1c198c05658723db52c7b11970ecb8bf1275c231bb678e5751fcc416e53a33465db93216782753e943c57d1f5c351ff8582535f8ee18450f24af7c0fb3975da66a36a9b431a0893866a82e6460d1f4092ce7f60a19a137d892d60e60eb21932c5bc325571c1f4e6e6b0a8eeec064c51c2e582b8223e9f234b61659effba6122fc5dc5ad3af8a7a4e5fb933cf36c31f5d18ce07b2bdedd4ad97fc3f72f50e4f810b1cb433e2ecaa2c47369caad08d395715e9bded5566ee1625f6d6e4e350e6aa85e320dc4292e635b852c709ac513dd06932c85a3f797acd894cb8955532d364ce1f5b5c3f010f278b28a4885f4396667bab8af86217e352827c3590e9c6d25b3aa28c626866c516729f48318e2318ca4c268d36905e9d8c56a91c4932037a6542ce34a0ce53c41c2599ca546088ae75685af5281d4dcbbf7d3e8f7414686d39eea43bdf3698ff8dc6e62986e1a01ca8b4a86da02a06296978ab839d2408e52e3758185fe7defacbf2031327d5a8fae97d5c75ed4de1ec6137bcf3f726adc7f8afebd74eac933ae16ff6bb0deff59654d090da1654de52af4f8727065e259dfc08d1a6fc8905d2a436b85eb599ed3eada07f2f931691cb3376455115726ee9681cf7fa0765614bcc12413c46e92f8cbd5784b7693a621cdb8b3e0b41eb5460e48e1b2d951c7e29431117900cfea9530568d3b8f867f68ac46719be12293a4e9c3b004508fb46b643ddf0f57a181a0bc9bdef3b2f1b1fbdeb0879fc54dfc5e0acfb03597a00a4aa35fa3693ac6f3ba99baaa2bf919cae990d2875d6a905d667cd3e5fc643c0d6c49c16e3a17b351d28357dc109b8e94c0223545dc7473d81296270948e5ef32675d637303d3684aafee8507af2a0e65cd9e6f6cd51d93b30e75fd0eb1e5db6d75ff15f6af163171d2510c7f18e0d1355bd87a896d11b436d6aeed03a7d3fdf927d9b0cbce5376cbf2791bac3d9bf6a73e00c118c56c71c234320490cc0b472a4921d62689d54aa89e9606f88fa62801ddc505eda698f4ee4390c9632b34118aa25761e872eec5e982724370cb2410db7b8eda1ff98c073804d7eab7f1584d59b92e8f64c84a0f73025421303ffcddd7003faf1a09f59ffd015a35ac7152caaef837453f255fd953a6913441e64001e8b72776df9a4e707c77deff912af57827a1dc927dbe143ce8d54e998ea5ada1cae4ec6a00ae56c2f8f20dd9bfab8c3c24a715014e5303fe3fe563da1f4183909d44798d5dcab46c927f9e05b7c2d039848b6666d84ad4c1879a8de3e5d59b290e0dbb6639fb61370d711ffd633f137f69ca2964c454a76f5b1ef785b178911a50074676920b74d8fbe0d1357308cef3e61f161cb5bca54f1d9a6935edd299657eae54fe9d06a2c095c762177744a973cfa5c16effe791439716f4d7bdaa0f30c4aa534a5f9ac8daf2d413a0178b4bfc7fb8d3f0513250d2fa40823de4e918ee3f2935703c9e6a633c83e1dad4ae0bc57bc5bb04760cfbdf421644c4f97df287863fd6742a6bdf03c28071f226cf7d4a1e193b3c38fb99a6c4e227848777aae91adf808491a8bdc2e2fd8eef7b8d5b126e6a00319b943408dbd8effb21094f4c1ec3274811c352c8ae100a323576bfadf7993f64a6535fa5d9ac88071e7a825dbab76af338c2ec0c3c222249e9ea7880980bd7f460802adc324c5d8d2fbc6b19cdb2f76b259e60f390321470bd91d05ff96d9fb04cd97e7fbd483be45f2600d8a009bb81cdfe579a2391bd506823f40d9ecb7ea287b0235ac0cb7afcd03e08722b56da665ace5d7fe106036582e0f95f1648c2442c57922a2c8bb307bdd30b39c54373d76b4722e61791b84bebd5bc6a8b0154bba5e0e58a3382389b5f265c201c351b9fb5498e045a17715dbd817b5ad39ca45246b91c27d859eabdba18968ae893c5a0109d328a536616b57edd040fb5924833bd7c598e66efd9453ca8535cb811a21384d13c7996f35c90d337460c1266ea4f32489f6e4a023f2a988151952dd8fd3d726d98650a6cc99a4eef74716bf5975f427df55be496a208f889e941a6506ca3d6f011ebc11d2ba26c56d7021ecbd264fe5501c48d921590e4a52e74b01dede6f79990e324fd25e625ddded65cf70c7d3905e3ab5cec9201efd09e9111d5035ed25ad64f05d9741ceae79dd3621373641c71c20aa93a74228fc290f83c22f3a955ced7af2337ce93628481fb31de9b168ad1a22bf073a5a2cf7d4a0ae041367c09de9cc9c426d2728e3e3d52015a2a4df66126c2c57030a69ea1ab7c1204d8ed407e8d34c59c8f1bf248c9b46a4a9bcc391f485731890ab79327e7c6a6bd0cadde9c6593d5529c7886a6e59d08a98d0e19c023b81c94698f50ffaf7ffe1b8dfe8f429cfef8311dc2e1f02edd86b91f3f7b4227d7ba9b3b4984757a18e6633664ee048ae6233cdbb4ddba1349d60c6aa28508d17d23f72249b8964b42d05cbd86274ebb422aa780d37c7a45cac2f0a33ba15f40d2203fdd00a9595d3ea8fbd3067336a56caf475bd505ea063f8c476c21ffa47b83897eb81c57609f8748b0c1da115ea2dd97890c2180589a2daf0367b4c485102a992a4d8b10be4b08b32235ac9a4cf912dc1a674761eeb04f530d74f0adb614742dfaa001254d5a58dabc632fd7fc0bb65b8f10fbf5c594f35149e082a2ed785a24ff50fad7ad1413a8e7a263959bcdee7661c1907db8e3d80f3ff393e288be5a29ae56b8f4b2012886ec8fcba738ba55cb9826cf21f857f662aa2394f19647f000bfdd4da5098b065769b641d3f091ca35c49e6ad3f8c5b8f1d3fad841fbcac2dae19843732ec5169f5d9d3729670ff9489958207f4cdbb2318ef4a8b6705a9d6b9049bd65a38481a664d3c00b50f0ed6bf0ec1960abb5d056535a77dec0c138b5641960d55b22173f8f1e521f436910aa738b5c34c46a3121b7dde48fe8409cfac460eb9c0bff92ec2fbad0e296c728ec6e72942a017c01841a746d8e8bbc19d715be07eb31f239d98a868cbe5b0b8289a1c014cdb72303abed803ea6d798e13e443cd60b690632dfdf04dc8bc9c6ff7d0a83a7da3981e6e11b1bc0a354fbd01e08fe22da2bde9fcdb5b940fc1261abddf80751d886dcd77ad7c39a4feb98ac1da76fb2c5645f84a844f46871ec082f5ca1dee1e3a2fd1107fe4cf10b9e47a885aa333b9b48fcd7cda8ed4ea56a2341c6f16aac4ec34f7b4015ab5024a05a959931c693d582c93a8c8f895bc002f7c65f0a23fe966ed0ee2265a25d5cb30d1b41a6bae21f7288fd1ea47a686e80f216f8ebb3bbafffab43bcbc07d70a912a05b930b3102a5f9f05c80c8d648aa78aed50628ca54e9646c2c2d5a62c3b95984e05456413b3132ccf8e2c7ccb9ad31739e42661e426a11c4303f70c2cf1b08bcc0238c249b911f1021eab3bee7da84eff392317ff19550bc4be25458fcf00dd3a8fef90fe150f7aba91b0e45b7e6bf3d677a969bf098db9604b04e98b49113b4176277fbd5cbcc106fd9f0dca2fb290519f4bf203213f214f0c29327ba4e89a4892705368dbacff95bed74ea13a0e7e19fa1d57b4f5cdcdc033085e8a00b7ed11a79f07269beeb435d7ef36eb39e39f2dfbabf09da5f843e0edcae76383f92fcf838265c147f4c072dfabb315f317e1134454612d93fdec7ccc68a261d437042d6a17c16320e1957f5781afa8bfeb6e9ad35d6e9c9e73bb46efc4c149a143a70c87659b921e029bcab0bbccd2bedbdef0e5787d4586d15a52f014d917b464f0701ecc7e6997199b6e89ddd3887ea3aeef4185d95017f0f027950ee350092593c1196eec4b97fcf13d05c70fdcd654900300d5129d418c660a6addce508c15015ed89c379d04df26357d246b4b241c72af2241bc65af378f1deb20be2c0f9272c06b02f86366b872c9dd57cc6c5494f5caef3e3f1389f56a73f42cd6f7e956c0336805be7aca7105f42d43d9fd93beab6428d4e6004cc08c175b18e6c6ab319d44b9552d23afac485db41f7e92782bde64747de2995ff4ad80cc5692ab5ef97757d8071b7e37034e84f5fbf437eec9582c2ccb5437728e68a80f0f18bf5d1ec0355f793402aba33b950b6a7c39a58920534b6c87d895b27dd7db7fd2e4b544c77862d040073791a9e1790b41fd36397d725d58185b0e011e7fc0d70f82133d1d66381ef68134468c81a78ff7e7ad97ec636e989babcbd6d586714bf13536a67dbe61346b6199ab1d579d34be8563c5dffd4f29766b6be3f6d5e7563b423bdf3303118b08b44d0aa786cc983d8fc377b2122cfe66eed57315a32873402b8b13bedbe35c5730acf5cdef7c781dc06091d61642296ba8483319fbdc2bb7ae219e04a59f632d9d074298b09d4487b2fa0fa9dc38b5042d069a5cb9869d494452eccfeea99578f2c041fe95515fc590aeb92f41f4c71ac1a142ac000c9d5df66f133851bfdd2002361444bfeb83b9ecbdfcf566ad781dcef9998481ff25fa69efc051bef00b9f8dcae3ba065b0763d624967539caccfadf716448cc4dfe4e9ba811c92958f36323224951e136ac393635ca46de65edf482c753909d324ef31220a6000f5b7d9a841705bc6a118717a7c041ebbb2dc6e27fde1f15dd7e66f1b7e53eb25a928adc0f3c9cccae563058b6e367659311ebb6609fdc4d1b75a3d46f8ad10e2c4b16a86ebcc5abd94b89a72e2192085ed821f8f81bc965b76a04311b092e6171ab497d51dba09efdc936967085625a5a0ea8617d2b62cea00413f1cc91b7a5c8e9a11c1480d68f12912e4ef94bdcd8a87b3c4e9eef70d15597faea7f6c24f2c3b1d83299d9129967a1644d89d3e9d1dcfabaa4536548810e96700b07a7e8e4e351bc5d4628a4bde270b182638255d8970fbb956ae5e4ac500ac6613e077e702f31e950eeb9253b64435ff17d4edb86e67face1ad09dc63d3cede38b2821dec4ff9ebab4ecf102c18f4cdd287e2e2c382cd657afc769f1ec988322bd2f2c818d607b6f92c5bc753307749db3e9f71778c8f7eb5862e293b48f692e7ffa3c292ccd6482962151e949581fefe4e1050eb539f5564c291d993152d7a90a6f272e7d4bb610ba50cce89feb45df6b20aa5aabf65774920730168ed49e10c0b59e73433b056c46a345fbe7e0c65b6ee3c926fad19c1f68150875b8fde7edad6a88ae54d6fb0507fc4805ce1100bf5c8f49b901ba9a2da66d052df7ea029a061f22dd81aad41c9e25acad14bea2768ef63a8db8e1429d7508d20a11f5e1915684e825aac4dd1790aed8095e01f8cadfaa52ed608d034451bb8ae73bd912bfd3362d16af80e7e80cdd7ffa033986d243c6b0b0a68a0edbc964cb002dd99c2086feaae525991549a550913d5fec3e6603e9af5c4b0a95e8eeaec80e175c15900005e112353a48757bbff912a2a634440b2f11155e33446a10bfb487f95ea01381e4bd6937b6232f98c83ec41aeb34b87f09456ac38b43a7d5310c47e827ac8bcfcba64e045068c7ae5bff7fc057be4a8a819bc3df1eb3862fe9ba4a283a53d49d856a8e548892c21f5f3a5ee99c5f999d0aeb2d8ab4fc34a85e6dc9de10620a7e1aa65d0d5b179a9b0ac5f9b82a1479d1b37454a65fabe257599bc6e9c38a4ea325e036744ddfbcf5deed9beb159ff5975ef1e2f0df34e2292cdfab00ef98ad98b566a3b9f2e1760da82d70ffaf4f5812e03f10b81f85e9ce45f03bd6d4906ee53aa191a88c9157a3417e50ef2d9e2e249aa0e0cdacf5f47539a7049c8bb4344523bb0a87c8a623973ae83d90a7e498850a2256eebd3f0e5666da2841a6b87458dd1355597885e3ad0727e43bf46dd0bfa8f396f4e893f54a0dce61b0acb0e5d9674331a37bcfd5e8b6b4e5f1eea3a100fe61527223787971c001abd091e39a6e41ee04bf6c35fd7df97cf89604a1368bdc8e6d2e0ce274c26d74d12a5055408cbba7e6ce4cf8a52dbeddb1b29c19a835abe4159b74d166d42606c0b02146a1217e9b770139dea96e559fa5b714fd2fd1a0c9d0a79b54ad514ad392a21b06f0b61626f01ccb7c5468b2cdd7a3151349bfa371bfbaad2902112c12b6e9a28f2e58d76727590fc93cc9a841c367b1a66c80b65b9d90e37cb1c07819fa8caf40faea50380ef7525f564356d555b412b7c9095bbe313a156ec502e0dc2bf530e191ee454e5b992da270bd9f8b4354b17ece51552f54b64001a8404b307290f28339e923fb7bf6fcde64c0f9078a642309736d92400e884684e205ea4cb9e230e784d714e1336a0fbe57eafe0538cda1701cca008742305f26d42a81e844928597e95d4131eb3dbf2a2738f6d93ed69a53a81a98c0077b464919ca26092da916ac9a79db4effca23795564f3db4303ef357bac2f505255944422bf7e820ad98a0d150e969fc6a59f8b9f6b6cfd8bc46b683046f7e1e327fb4d7dc5ad7faf9fbea394558ec47ce0f90444563a15975dbb9e16a0a74f1e920fa5f86d3aaf79f37a1752253d3ca1cb764b9601758f51349b4a706f173cb22991d6d1512ecc46ed62da0a3527c5394813c850d2e40b931948255bce75f4a8c68a7019967cc885be13937515afa62c901c862df8bcbc3aa4584381ec1799ea0d6dd0f3190fafbf1e9373fc2f61af3a697799deb4470bd0913b490cfc5775517712d1ad1b6fdf5165b01317330d837e5f5ff84651d475b97cc835e50dfdc78a8c464aa90c627417208fb5b438e9ee6552dad549d711fa2279c00c8a2f997f9fc0fc532b8b9ace087e34e825e7b280ee7fb59dac6416eed35bf01c89793492d3a5e3bdec6a3a31e4c14f3c20ba9c2c3ad8385f7fc4cfb445e05e42a40f7fc8afddd5a5931312a3035b264715e3d9d836dd1a205682b02c3c9bd5de13e9d4f6bd4e1f4d9c809b2ebec6d3b47b355cb9ef11efacad3417e517c2b1b222cae0f696758bd85e14ea4d706a555545a2f34ec286ff9a47bba23e70a5239d504ce1d977ec0a9c59f17a2e4dada2aa656ed38ae9c9dfdff08b7dbada6ca25339776ecac9f2adf5b884b01519993c45e6a9298cc4ceb92e9c723ef98e26b3eb8a91febb5f29f9efa31497d76757bee38f1333b6ae7d78a6f01b2ff123425fad390d5b4d5476056b05530d281a5c4c4a41f261273d7eedff1ca2581c0e8a5db9024ed37773b4f0b124644dc76e9145cc0be5287f8f429c74787e25e2eaba1aaac366e3c61d4fc0f73c80ccfd00cfa8797f30144a934401e0038defe965ae4f0b98d82bd1b5b747042482456c587890dc09a1ef6b49fee74b1129573df7923194e744363af73e9c333aa4797c147456fbe85f6cb0977dc9673aa6ae650b3f91276a8922accb3813e7015f7637fdfad1c4dd3dc7a96b6fc0bd2fbb65dca2f110e52c713e5373aea8ab91dfb1e7eb4768742b59191798eec98fd7f11754bad56a995f44b69a681bf87dff7a5aa229eca204c46628616884f8c82c66878ff5a2a6733f4107a1ee903f9c85e9c321a4579f6a2a3210df3101b8a55d887f576ace6f33383216bb79ae3ed6e4bc914e904f7fa380c5e2954577c96cd980a2729e5d545f072f0e8dbf51100c051950c33d27eb25cc3e8f7ae183d2593f0b51b47cedacf71320759a8ef3a45d79ed42c69ceb582695268cda2264308a00b5f32fdf9ee5e5041a21375be9abc3b50cbf5f840c80510e72605bb8012a12ecc885d671847018e7535549a605f2ff5c7e24a6bb4aa463817cd50f96e46a3b227227caf88c15e7b24480ee35a5125cea53c4a1ffe04aa394fc8d77f1096100297d3ba4c94717d34713918b2bffe5095c06bac797eed2f7758f08c31704afc9a766cba88f12ea4a2364c8b178d9d5703ab0e4f3c0089d69ded3e0118c78ac9d06823b4008f7d93977a096ef72534f03f5848fc91c6d7b4677ebce5435086e3e34de9ee687001197699dc401efa5d55713ce5c574f40417d0b37abac67c2adda76924f3ef1c6fc2858763699eaf5643a5600ee4f96e8d0301eadb8f7b62dc1155f7f5fcab2cd1cb9a5dddfb959fe3d9cf97ebf030c98b8c7a4587a3af98d0532b651c6d0d92352afe9923bcd2ec7e19c7313f26d06113374d482925ca14c524d046a4dcd96c23f13cdc60b60ac26c55b9a6dec34210a1ee33caebc935503621a79b1c68aadf76f840825562156b625ff2849ca3475092a0a4e3838e1c13a1e636ab4f2e6da8154de11f0ff7df7b8692e5ae181dd76c7bb6fbe6271e04548d98d67a270fc902bb1896e7badfb3a5c883a5882b1f36f0228a49fad7921da6cecd586fe87db4fbc4ba3a33afc7290b4216b4e74909cb9e6d711d8bd9fc766759cefbf6a13e13fbcce92eade54862f92a8f777a215b6643d99008409ed3f5979661f1b634bb2203cae837ca66c5dcbca87105b5c1f579c0b755dcd450a43e8d06e0b6ae9861615fea905d37d23630b699fc37a3fcbea84004efa86174c2f86c9b1f6eb532a4fbf74d0bd52b0a70bc6a895cdfd0aec34af0274465741143dd2fdcf2b0fb16bae4fd524b02501e0a2b4a51d0e4e2f92cb38c8781eee44218c2d1a8edf0605c00","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
