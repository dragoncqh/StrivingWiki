<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd8f859dcd138a4201f4cc3c18d588257ce0374d63e1ed0dfd530158db8ad8399715386701460409ec59eb1af832f3ac99b28818ae5e0232a1c98f0793860588afc10ac9455e13bacedcf3b9580f2a2c8f204118c59a40aaea82a77d4826f0872cc5de9d80e03af177bb4aaa6d9ee21b04208ddd39e2c06359b96c2b214b14bbd8023c811c7a3de05786d5ab2bde09d570586a81563275d1606328d504ce7b99e453401055a31f0e348938064155c392aef5792b87631670836c6670629cd531719043fce4f8371a137890472f306ec34e515f6053485dec71bf6ae8acf9f8a0a20a34ea5646a727e8ba7814ae5ea0de946aeb815049cf5635612a60b452a9bfddf4a26c00051dfe14cd6ae539801369d54ca7388f35d1a1dca3a387725e03aee64b6575f62c37d2796d52ff63356f4f08d89a0e39a2efebf166d1c5811847e80021eb512df4a6cfa1348ecd553575c63cc52c17e68b04704966ed314446ff77d6fdd64852f3bbc83fbff4777740c60244bb2b9050ae5055ddb952300d937fdf0edfaef5e92942bb0985191cec3984104ddd68e24a85c19f63ce501caabaa89b8cd271da1ad23829c57d612cdaf07e3c775a21ee6bf106d34aea3f100f9f85121518908ed3668212b17379c14ce79332473f99cc7e650017cf7656675ea0c6f6f4511172428527c5b3b97f815598ca196c55b07a4afe0f02b0c35d13b1b622146d05047d75583a42a41d72c28c4b172ffbb04f943ee5d90a748da028aca03a42bf745fc84e3ea4ff13405d5f9f9e1de9d0671a7bd7b33692378998dd8b6a266c70e9921f4f6f2f4a128f88fcefde4c475583651d1a7cc615ecc56ff48ee79690bc39cb9bbb6ea9073f675a156681af4345e7d7752b487870b3f0ee5cca00762731fcf1b446371a2bc4c0be85bddbb25b2ce81563a05226c59e1cc37720e8ab057e6742d00c44bcf83554a440624c0d7f817987354dc72fd891e30b21c17c6157e0a1811e63ff7502a289a7cf930a04f21ac5c50e64bce3733e750950a7ec0ccfa11574b31dd807d71ebd97ce563bc5dbbc77385ac9def9372f735c6533da52704fae12a3e322d2e8a5475f7b368cb9d0eef8c5abd080efcb624542e094ab470fd0f49d49d1a526dca648fa991bf2192b67b12eb27debf28d9e34ec885f29d91138cf0b6f4b827e8c4355611afc63a037dbf2b161782ea704e8ba1118014b677cf51a4357fad636fc65419a4bde3db891a6d64f0b21a25c6e4cc74be487e30a7dd39d1517e23f4232c10f405c6cd43da423fa9c0d58f724a3654a58250d8307b9e1d4067b5f3df49a1a244dd2a339fe062ab7850aadb8f6276e40a69f420d2dba1d2ca8089b35baa32b56724e540c862d8f75c97caaba422e73b21f55bec8b495cbf9440c17d037c154b53ae5d7f46b32934df435f73e31c7095f29187dea4dcdc75eca861717628ec5cf890a09dad30c7e21a4b6f676dc164aa4eb3ae66ffb5217e2d3d5ebf3ad46616ce37633e143fa65d23e99cd72fb3b1e6eae293cdca6c78616e7785f2794295f406039ac56d9919ba43ee979e1ae49a15d57238ab78b8eea42297ba5928a8049d657d556c6d9ca5500c2ce00cb77116bead9787d03b48aeaf15973b6e81bb043295fd7ee1b6a1ec07b9e2c30969df81d31b4c284adbac21e9349f8f9f2d0e90259b1a0b088214803a2dd459d3553672b50357b91edd5e4e854138b36a686fc264e18688e34bb7dfe8312b80614435b1c2c5560b1433265478afd6c4a25dd3913451383847e5bb184a25055750b3759fdee9a8456b7ebd5e236daf28b8f84fff78690a3a5c56743507160dc94d6b91d2c90b87f79e9095f2cc6ec691a6279d35455ff6040d9a012db13fb65cecfde607f1632bba0e637daaaf161614375d0984cb40b1cbd82c4c11780d1e8cc5306d995dfea5f570eafb1f0bfb514aa807e0e0db8238282c38e4652bc6e87df05c459aee82883c3be15dcff6218429396272480a7396a05423fbfcfe2344264ba54131a6903b537462b343a2d1760f1f2346b29e1a5be1d4fd9634270c8c607629d16be4e4bf06d2f6a6b3381be53692ac70c0197771ac568df63e2b1101b4b60797f32abe9f1ba205c529f643e23e54cdb843d36d73745648fc18118d2cae1ad3946061408cd54a07df768a69a4f1f2fc9a4905230836b200c14c113d7e163ab30ce386b8bb9ecbf4aebe8001544a63ed85a42fdd712a669066ae2dff0ed627a2ab6afd7314637b9986eac0133eb2e32410320b3a5b88b0afdd750ea15258e4614738663a1e90f840a3a8916f052908495cd8463b4104d31be9966d7d1c9f640db9b21554ffb4b0d5948f6c00f0ae3009746c5daf1c584f5b05c1fa9485fb56218ded7114331b87c5cde3f05ca03290de212f3e43d16e1c685358f4453b49a29d4ab7a4c97085cbf465430b0a04e59d9cda7c26d7b3eef6baed9425b1c2fc631fdb663c95b0bd9d6e6149e524d905fb47f7a92fb785a57f64095b89f7e27be47a008dcbe5f046dae7ed4a5c6a7e1fca810c2d5497f605538c817907142c9ac1607d10a617fe16fa57d0cd22a49000d3d5922d31eda9c951b4b1f560ebab6098731d6bfca2e836d4adc4b1af819b870048354d248893b1695fab1948a3031188c3d548e0d77f88c50e79c8ccf95d8897cf6e71b51ae86bcf100769cb3250153789c1d035523983d372866cfdb6ff5df3f6c7d96fea7b0aa26d9dd40f41b2ec75e33e58128b320ad651518bd1dde09bd67aec4b955f6ebd597a64519dc48d65500c416f80c7e82024a2774c2f31d7824f1e376bf4609142664dfa6aef627d9d7487bb1d8ff81e426062231224762d00ebf65278dd933b2251e1698688da9073f13f95c8e87c8b5eb9c3187745053fe5e90cc9365a0e3c3abd737b2bd70cc085178efdd788a679761ce5fcb07c7bd10381876a1cc3ba1ad83739a4218dfb82658cb4bbc10e433ceb492b447f0e74e7290b19a78b0ecf28d45973084f71524c16b94ec3445385a5479dbb56e41ab7e5fb73c36245285ad6e57f1d1b18511a82c0df4b789b4b944ac495b86f0288b4169e131f7d16ffa11a9a1e012dd2d017c63e14203919757094bf001597bbab3defc859074f074de749e640411ff602938110813ee6ca2abb9a5b213fe49dd2c35c1920aecc0eb96c44357ef7b5c59011319739a091616a33274a7944fafd63bff54a34187365b3a418c836dc360f3f413c03123694b9c0a6c500d5b6f3bda8c59e77031ec49876109e675ccfccb73edede4b35deb1a1d9050854780fc1583a0e544a1c0622660d42d415ca379fbfb424b58481dca342aca73ea5aa2320af9bf686030e92d3246c0b915aef1ccba09789039b911a0dd1f4cbe160ca0df613897cbfff7aa7a05b44b55c4d3a76f94407af2aa3aacfd2c6444840abd716c769df57767821c8e6bdeda60ba29a60988825170c2729ba092e2326dc1b5cdcb95741b7c953b281f37806c5869772f0932b3f384d128adb41bbe7922c77beb7bc90a040cf90a6d1810ab246866afab990bcd86432ceea7b3c83ed4760f4c7edd6631a286db84d2177abdb3940320e3a04fb0bd34fc3349c016bd0939eb3040ebb465dd5aaba4a3e8f36558b9a25cfcef2c73c7eb5e2dcdda9334f21099924d1b2f20d9aeee7322b1aa0610a820a7b985071012a1f441b748af2603883cf20a37747cca3b000d396db4288068809627a8d3878be35ac8f89c92e9f011bd47d289c4f5949fa1599171c4b9c54dd99b53c6e055b580e08768837d6a87dbf618eb200fda05c0c79ea971fbeea05a98dd7aea05632a9d42e231bf86c6fa48f32d0f271fb3f6b01b31e3f5919baa90d4f3e2b9c109fe599f263c0da57f242294ad48e398295407cbfc821304aaa9fb6fd7a3f9470fa3875b1ebeb9436328fd43f0e17b97dd3515c5ee887658b0051ed77f8ab57cadc54b922ef1765a8e2883ace8c9cc1c4ff609a6276dc30ad51b736228597b0757588bbf1774baaee95623772ac28528d4a2ddcc88f48df3494cdd581da54c11f1bff17d49b0d907366da5f9fab6e98ceba99b46eec290b9b360c806c1ffb03c727213383544b5cbe7908b9787038bf23c2c6af996bf525f8f779e202b06c1c81aec0554612cde0aebdf75c43345e1255a2dcd460db3be12cff88fb2a6be5cdd9e6c44351ed2f0f4f243fef4ad79f553226d69619a1d8f414e6b50fa02b7fca913f28705add15a0ad1008f4cc41398fc79d329a8f348286938194652c04780d170303d1c20565cacaa075f747eb05e2c00cc25eb14629d1d9597bfc6e5f969b30b8f0cfceb47b63e6163e5abeb7ee30fb6f69fca4a30779bb10d0eac6b6463a2f6c02647e7e5fbc0f5b4223c6b0c6e0d57c0f13dfbbd6140e588830cd9bc8aa3917598c8350bee3e416c89e0f702f72c1b9e21c662c882952e33c498d55c4f50f70cceaa441411cccd72db74eef381e1edfe510159314b1796e360126c31a56d48c8bdc4ed5c597c766b60ab02d216d023ecb64d2ef6f6c45790948def8dff48ea27812e090f576752292b3e93cc89d070f057648b02ef39eac583eda91919091642598a0f9c8aa8a9a0e54511860bdee6fd9134f2194215b41b687cfdc2f3d1d2995ef54c8053aa9989fb731b91143322de0d8582933fb2ce437602c7edcec658227fa9650af940262b71d99cdc126b4ca4985d676ad28c7a074515840a5721771f2bb50d38de46f2e73f01a98a10bd44107ad06213e33a7a6bc5366d16006ea7aa5902b1e1cf3c42657723e37b506136d1b03509421e00292eec004005de932360fd0d00edc13da6e23869bacfb579fa73865d68a21e99b13d9b271194dd5a117c7cb4260906782167bae6819e332bb5a9fc97500b90eb857f928c4deb75bbc1d6aa796e8996964eab934f87e439c35d2d3fbd5320d1db6c33e81d52880d69ff48eb08f8d3a5fb0a9091693628f6d02da79b8d19e2449200e2e02e38fb22d6bb58452dced2fe4cfd2f202dcd0d1aa6b66336c5189872879942250f577cba86750d6034e7722339ce6cdd7ed22feb3b8b6bae0e82439e2e161ede37f53f22c409b4e38ac2873d2f18e75b4c918f4890794a6be806f3a55621320af5bb397e9d3fb459d63652eb52342a88a07cb6670ee947482ce3deeb5439cd5f9b9d7305f38d89dea38a7a19d0fc1faeeec1ac5f618ea9d4ea6bc1e3ef6ea53f9e727c163a885cf0c4dac7f39067d403f7c5637599c946490ee47264d7d145ceac9f9a54df4381c718fe4b8b36af02ad39de06a85ef718b7a596999e93c5c93dcc52eb1cc214caff279c4fe4ba72204aaedf214a0f04caf95a96ebcde9498e51ea7aca6caf430ee66d04cdf1a4dcbd6a456b416c74e674a05cd1e0557ca2ecc1d2e326aac23415d82a47afbc81f1e6028e1d4c9821c5432f23ec763c248804ed2d9d68ea04da98b65af1f7a052cb1b56636a47bb2a4c8c8d17d9bb455f6b4ab98e2665030199b60e286217ff1f2cdf1b3582b2097b502db54eb2067ac020ed742cae87a6a1f59314e454ecee110f24c68cd60aa435186d64e1fdd54eb53fc01b1a8ed015134dd98b26d7c20b6e1d63e33bfd8155339cab3869d5bc8eba98a09b39a75c492154b5112714e49697f1570e4e84e851de8ef2b0caf6a5b17995b8e40db6efa05253fa284d75d6aabc1ae0353ce985dff05c5792277a07bb429b5ede70b371972b724bc951fd0f6467a390a012e99a4f74f62a790672be3ff5b7774719152acaff4ab7850cd00f5806e32c525b6fdbc57d7c5e486e14c8bf0b86bdf6b01e03ca9b330ded7be10cba9340c61e8376624e0ccc51cc251ff505b30b5a365ef106dda35caab117c219926727e0145adc663bd9d306d1bd96ce8df3b58c7e75c8324d6497dd63c4e92806cb3c9524a7560eb960b98f914d10854a773c09dedfd58980b67f8ae7071efe96839e1d2d3f1fa4fe96aae44b6fc6b4081b20ef19e7fff15e18e17ef2d4f111dfbead03fd7366d30fe64563afc85ba9c6f5260f0356ef702dded270e8b99a13ab78a854cad533707e82f6d29790dbb6a9969d623c724a469cccc1160d9876622dc315bf43d38387ca08f26d8b6a76f50f8cfb1482a0d0190cc6de2cb2e9951cc921a59fdf5443322a48bbcc43277bb55e0fe8f8288baf048409615e848351e2d94ae1b2449cd0d838b8b5516a538ad0f58ce69e86391e0d8b13010a6816d6e5f6f1356bb3fc04c3830344dcaccfab0f4a760f8dce8c7f920a6743928bfbf7fdea3404e2265a260031ab5a1acf0a348f48113ffc5106dfffdfdbb71351bbc3bdeec5d8f3ce8eeac7b9e825e9bd41cbec58052609c973650f355a35266ec98bdd950d638acddfc74e4a3e5563cb5be46e274d42382d3fcd0afd84a1d1c1e74cbbc0b37dc68cb82df22ecb824206058a719c3297277c1fd4f5295b5245c8bb7c9976a46b24c240885f89c94c5dfe5f807bac94b0a794b50000ec8c2c2ea758d602856845a5307af49c8b5c8c138b885200e01ce6694d6c08eecbffc36699b74ac229de546787b7f6313634701d6a8abe225b98ba24784b59a54aabb4da7f25bea35005691da7469626042e1ce11bb4cf9debf50b6f52cc16b8b43bcf79505f46a35cc13cfaa17a8ce545edb3242e098864274f45ae8ba8ca4473726c89c6f464680a7dc00bd7c457fdd6d10bb254f26c54dd32db04b5ef32b2eb887acf76f8a04314ecc401b5a97d4e798c30aa0370551b50f2c407419eb4b1ad6cfa6efca41ecc12a785e38d2cd2f20e10a36164dfd5b18e40faad17fe1ffc35b8db2327a688907fd98e039eb208e74ad11101d4e661fd964b589a2416d0627a2dca6f01befedc87e5937bddaa22c62d1db9cd2b5c030979c2970467218dddc835c482ac6553abd42b18c21d36428e6c9a5d6f19e34642c2cc1421179b96818d9385708b8532e2052a0d30ebacd9cd40645438af8aa3a0890fd2bc811a24ed4d20d2d02445acc7a99dbfbe16477f6423544631bcf408bc41277c62a11603946e6ad483f2740cf6b4783d178dd32f3a45c890c1bfbc082656cc44f9dc377301b89e2318e5c14a67793c6bfba35888cd1db376b8cda1ece182323a56c17379eefc9be45198b6395458f08c8fdfe65ec1cb570f623b2f8d70fb7d46da69452bfad3a9f9c40c1eaf846bc2ea9f6099c69245c5dea06c7ab36426865f496200075eeed182d6d3936d96ace9768e68e407ac5824572230439afae7c46bf076b0b0e70870894faabf5d709e3c3732fcd08568a1d458b24fcd9807dfc2fae619732ce43d4202caf423b11136d1e85277423cacce1464afdd63f7c3781cd462953cdcd5f5c16d2848ec6116cc354c44a86017bbfcf4bf5d3e2d33080ea48a9b398c1e813087f00f1e649c0d8ccb2bfb0b2fff0c1ea48e25e8ee0246560dc5f12d12f62a0f4d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
