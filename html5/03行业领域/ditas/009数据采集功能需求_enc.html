<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d7a9955a12dfdcde8cc4a312bad97c4de5d4d5c09d8fd4bcba29f603bbb1c1cac0001cd3b572b6c2b4a4944f9041eee2d4fe48182e99a328a0762bf7db0260f48668c9ad025784defdb6617ff9968039bbfbb499e836f8afaaf6f1a905fee85577a92a8383ef3f9ccbd415a4ee939b4810f4f53f35e81d01e4e737387b435e44d63886613775f29c26db5782f287489aa5847093b72550637db0b54264a88825491d37a7b7079c1c5958abdbaf274a72080646408497f7c9fe13053e7f71b32e86436f68069b74cb0c247b46e4947cd23b8d1ea5c882c13c2b5e7c31a7b49e9ea582feeee7419c437746ba014a10dcfeb7d370864bdbe40bccd411aa4f2c15d57e4d13f370f5be9c807c62c142ca96d6a3717c145ad450c9ea71c7e783ed6b19f4959b80bb7dedee074e3382dd56093d6b3f1ec73d6bf5d3db221175de93a94a9d1076c26beac966b6c47f5f32926f174ce510791aea91af96b15dd1ad1a5f36950fd93a9990e7b9443cd0f42243160d646577e27b42ebefbdda4b477596a6cbeaf491edd058c37be18189c4814a236376d8273d84c7b17021ea7074cba268e131498197211ba01b43d540813ddaf6c06338c44694bbc20797aeec75bd4244d28bb3e67f7a513ed1d3efff9d0518f573547ee9ea4b8fd7d689cb9a4da299e0cf540cd0ba8a8d6c2ba4643514504f7825076e3dd662cb86339bf2e7c4602c9f3df7298c71bf0e52a8875bce4783e5f70a2dfd0475c1dde566d1aa73771afe6ba89930b409880317ab47d1642a35abc5abf587e613ee0eb261aee22fc8a24f42eff672c0d38a9e427692cf95765f714472ca4e318be57db4f5bcf28c7d6a21037a0033727e209bf008c7f98d78296a3b8f3b4b0f95c0f3fbe433d52018de06a9ac7ff04f391f952fd145d98f563ec3055f0953c9a5222aec19f971abf613189c1be8166d4d3cbbe7fa31774dea8caf9e67fab7df2bda320c2822265a4b8b9c5e7f26c8aa636288f0f3dd1ad7ea00a8b0ab13a2064eecc4ee131e4c81360bdb985d93df175144308c541555bb308b9766b5b6d12153ff29c4f9305542e4cada84c3bcbeaa4a4d4459f2df88746aeab9ecd947aaa3bfa0ab0d36a84cbbd1583d41c2bef5f20abb68e1db0109a2e095df0567ba05df9c55e6b09d48d5836e79685e1ed7a5f263077812ddb68ee82b9317971588fae217f666341c11a48f622f84b71fd070c540027143eb96c1f48a36dabcbd41dbf43f1d63b9a6fd80acf724f860efe00f8807a7489c450a932d11070279dfbb8c80f7827c4d62db8cb4c17238df8212ae53405ee0fd9442f30ee14072a6742dad7c5fa464dff1894db82a3ad16352278f3a985d6e3f276638c9f7e7d8d1216ed544c115bca7b74f0c58926c0568e1a42b08c9e6032269f6eecbce51cd7c61df60edb49e28c41ed3a1b45fb21d502c849d9ce9cd35232892deb4bb2d0e8e515d1588eb9661f6b6c0ccca8f144aa39a749aa32cdbb20df4d631ad188148e3d6cb87f15f6ed8538344a8f0c944b6d6bdeb34f60fab0728a51eac134bdff094352cbb5d016eca6bdc20040d39b48102760c690b1de487d155e32b3c3973ac79c7d6a408a61b6417134eeafbb5c0feb34ee4fc218b8a6ceac8906d793f90aaf4a3e9bf89234af5e92474918305ea092385c01a20430a371658ebf0c35be8e65d0786ad77347a11b2d6a5e861436b0e5ae45c18a9fc51eccb3f0cf8131fd7d5eb374b2863bd8e377d8487c81c827af7a9aab5bc563e0037a242774faf6de36875982805074712f7a87d167352f3bd110e0a847d7196e92fbdaeded83f73fef50afd0e8b39fa3708cd6e8dba6cdd6134367d994ae4091c752ef87c142a7f605502facad5f9dbc012f60db70a8d6d3e2059fd6ab35fd730af34cc9fde50e3b7c685a941d66965a907eb112bc0ab106a470d7798e19d8845540a3610e7c498d47be1c98205ea27dd007eff79e2ef28c3a53401f8fdb440f7eb3c0b0a4d0dcd1fdce3cf9f8cfa40369bfc50d48b304f44f371eb63f9871886aafe5429d06d6980b9658890d108808d330102f76f120d888ee659164c92b9e8c2618c8ad402e99c10374ff4fab742da31953b64bc534549c091df13a1d0373af5125babdf26e6c8ab0d3cf109b0359391361dd8e727b4db11a8fc79e4bfdf786e13202ddc5835d87f96c96490e980a01b941699c92e3442c3bd38e5b773aaf43d8f4c0cb1b01aaa80438fd038ed813c71e232f76ceabbedeaeb430555a6fa670778fb689b2c43b09ef97e5d5a0adecb281d6a7fb64ee3b489b9b7596b73930d0a0a1267001eef5e5e35eda5f0de6acd9c78916117c25babc8da2845aaeac9b4cf251513b22f4079c20c662033ec0170cc940c76ec55a341712dd6ec42afd8759aaf9bf94c0be8ba11fcaddce4dd6714366298b22b329f6f749b0fd51e38c727f16b6a38e2e60445deb467785f9a50797fd22525c0c6e809fd17c24b61938c0f8d826532791a6a66773925f55960897b89958ed2db89671fbf69bf5f375c362ccae7afb410933d6c72087b7c4593b600247ecb42903b9179e0b75f95a179445c8ad6207bfc9fcaabaf134a6119a42c26a49ee48eb3a18ebd75cbdd8deb7fc3a90b30e503ee740786850b1352972f9e73ce986b9bfe9e649fab2b1f541515622df82afbbfca7860178433af0e2dadafae9ba0b15f42ac5d3857a72ae9b6de9ad1a55c16299c7c5c212bbf9aaa1d85b8394b7cb1e9ddcd5030d39fb0185e504ebb5534582f48c44a84540a71cd0a38773d68e7a9f730c8e40d08236ef0f1b40e9f5bb13a8e1beda505f2d8e77e3df71a0d2cce15d309cfb75f1dbb3ecc5d676308c7c00a949dfd7ffcde074cc4df0e47e305258afb17b553366776a2814e456d635632ba7c5da3ef3e5597deb98ae4e80bb0210ff937eb6705a88e4d334d9dae64fb9611529d87ab311ae29b1035862bd5424934ee1f2a67fa897984ce6383b63b6f05c895be882a13f145fae6ad07c328eac80aba077a2800bdead344d87e6694b350f1776898667bf22ccd651150602c872dc22b3b184b5ce8d9cc23cc76a08552e775bb1b23233143e7bd33d1a825b3006d7a582d3f04ed167990ad30f4e798d503627777af8813a51dbf3119ce198907021e946f36ae289869441e47b138377c567829e987469b103a1a7fe23d3a41610e4d3e33c199788ad64420fd7e89f4bdf544bd5c91518aa519a5240aa8e9b21853c392150a41cc99a553b1d25b211756a173a5c68a60ae60aaf825dd17faa4484ea4e4b271dcc8cdfee84155015993da9863de17176a4e3f47ebecfa0ae5d1d04c5efb17288f5a5cb389741feb9bf74761a0157d8a38ddf687f0669a7d3030a0761ee48f19d8ab994098a95c016d932d05e15ecfe147c3d87605e7f3e0750ca8b22cbc309b6f0e4078c3ea3c8f25cd749210167421ad20cd7ccaea3e0c728ead46816a49114efb4f35eeac9a36718f3973424fa273d180a0dd693085e807ef8a96890514eefd9933b43ba2491243e143a09dd852b293cfbc97d3156331de320b3de9d24e5030923b92bea0904b760490976ae408c0a7aca8cf9ad41cd64320b767ba4a6f531dca7f9c9453038d958cb6eba7e8bd75a69b683f0ec60969a8e267e83e9b1e2ed481c1536e2516a4fba4695b9bce7d08536bfca8c2eeecaa4f4969ef581db771e4d2908b5e664a7ef6f619db991527a15be02fd7cb7314cfb7c116a48cf35bb4a92fc1249078e0a9e9e29207a3e8df40558ab4f5ff27aabe24fbb8d134113c8f4418c9b967dd69e4caa5ae53272f353d1cf729a59a23a296d0235d9ef2be28fac825e763978f234d32ff137464f4e6b6efcab446a01dd8899b4534e321641c8a1c2761c39f72a5ea316b5fcf42b1c6cd67254258c8fd654da3f4aa3d27a34e89e5dc599d472318ed30ac52570a10e867be41a5112ce2b43ad65b6d8611bde85486e2076b67c7154b520ddba1a1cd429ba8e44ad45fc1a88b9d6f51815d921b3c10e3e01f4f6dbadebdf1ab43afb85e7ed7e030c4d9c3cc8fd96a9de7c9afbb2b381807d4be83d6ec62b394b8c13e70564147eb53926f8cf478722b218361db9e382f2bfc4f7c98ed6c5a36de63e3f38097836aaafdb85494b3fbe86e1c80ebb6efbaba71b017ad4d9ac295ef089235efd4a5e161eec110d18018ca7145ba0fdab3da09620da6491a530c2079a933a2e333c60745d68507b417824de22ef58fdeaab5c3164524040d687eb7e046ff6e85ac74f58f08c6d34812e5ed84f3a95056f747b569354ff8fa21836c513d3dff39c02050a73b7278dfb91791321b2df5f7096c5bdfb98baf691ec8e35ca4043e114871768a62f4469bce8d38dea2e322d160c39e182b68c399488e5052545a4ea27e2024bbf7f4503c624d7e68f9f03d3a9c422410ca902061da89a7b14cab44c881238469dccad93a0bb1347a6881b77c96a0dac1b9f0c19b2700b981f193c61b16e90a0bc297b1ba9d41b6acf6190fbee8dc5009c643c2016c56d4f74f9817cff4a9f90c01552c9c59156b7e787c7c68383190024916774975dc8d7a057711c9d0c03c5a7e0e14b22181e06be0000e7c7e2e9080a07fa45fe4cdcda119e3a713a2e300c037dec110c330a5593648a0447a6e162d228ca9cc9eef62866bba048b18001e434e1eba58e36675f81ebdfbd944cc35dba946768af7bcc7a45d1eb7adb70363e99998f28d9e0a598f37aceca76ebebc3e6c2fafc14b7e77f7d484f4133e34e79f12acf3ade7b40fc2e3183950b5c561a51852ab7e2227645baf092167b98a6c63eab6d5f7285fd913ad5d4b1a78f0238a1dd5421bcd940a0f8cfac88a57007adf6638af01e22c19aa90fac6ae2d10b3f05b8423c3481b45fbf512d7c4901b2068321b885e41486682500e80cb4f624bbac0c1e78f4c7ccbd1ab1e8d09ed78a9a11ade429b9653639572951f78f84fa4676193f76a77c60e638200d23f3c05f69cf8a706800019853153131aa8799efd5a15ee3cdec753e94f81ee4d496bf004cfbd53558063a2448864698c33f9717dbed410e97d1135b101f448a57d75d78a96cb37f547b84af44bb0d61f18da6c58276549c941b60f40f1d48a59f60dd1d10290b3b8c30d33984a91a756a886f8f49775265f8b56748f8e90c1dfc5021fcbc55d02536364d2ddd2345566488570706d7594a94f6e5e61832dfca4085a22a3d758d74d379735b02eb9aa7f225c507f6d57c4c3a1deac1e89e367f880f4e0b6cdb09338be239d42ab4354829dae637b7e3d6482e3ab2e4ce56d4ee3299016c0336d8927a1a5a28ecd431afd4d23486d8ad017953c476677e7f7a47d7d9b026e47651586dd79277fd31e02306dcf6e0f52a17b5faa5161957c517ec27506b285039d5e91577c309699313e3481298fea6803c13cd33e16612f30ae3d297353f89ddf70760fcb4563c1cac6f653c6d0f84b1f4ccbfcdea75519fc45b5d62fe2b6d7be497f5ce0a72afcb8987712ab5b8bcf92aab5757eed4758404a8a14d6966b87adc440d592fda7536bc59000be81db35ba51f8dcfdcefd602967181d670be2563c474010c4a99ac4fa33c3e1c60cadb683697ed468a59d05fe87bc5d1114d93184c2092d2d75f5ab922ca1d913d8e61cb52c5b6cd27a983a03a1bd4e163636c462318b9bd0335daf08c4361b18635da0486e5a3519cb9cd67004361dfe7d5bdb4a729823578c493e22a640b3534a7d1bdff4bd41680c3b29fca6d2327f1b2d46c44b25c324e36348e3f3fa2095cd0541a99581338f9e335f56c8e52a54e25bb4424a2dd207570d2f3f4479ab97241a87b99712b188a99fcf13c64fb37695ade8273f4ada93b6d425d65e79f56495c1251e05407c12cc4d4e44c05e5056b66b05cfe49bb667de24f5f18ca55fa7fa461cab8eea4b775a68833731eaddfcee7ea87f589e15114a15662b853ed13e2512ad228b9e46927a0aed2af1d7992f75eb4ee219a9d6f52de13a520abbb1dd16154232534cd60e05a8defacf9fc9332df9b501af7bb5aace484162d33576e06a335029b5bd1dd9f9f750e2ae0e62c4a0342478e41794b07cd9a9b2947cbdad98c7d7b7a14df0990a527ec7e92fd6c7b9984f741e5d2ec79bcb4fc7819069f9337dcac6cd3b467ed85ad50093f1dd164e2fd4a66c949c1f9300c46f6e5910ebc9c0388103a4f0c03b85d9deceb20ffb723a4eda6974abb37a059023f81bf10f2154c4736852b06bcbfc98707c9262bbc9f848bb038f2a87a836c7fd44e210a641289949d10b6777e38c609633c34fab0a24060493d21deb4a5022d4ebd5d1f477e20efa69cc36c5baa841174fafed1c22d5a8827d9707961fddc4d739550abd195dcf7e52064b1bbcadedf97e3c98a720fd95c96bec33c53357d650dae6a48f57c8178ac8284ced60e8aac28a3291e7aa2333147f82632738d90e82f48704d7182114bfa51e6621f12005e929d91fa6a7508df3c802b2ebd7ecebddace27109ec28c13209b78a06ccd3351e5df506fb9d76fe132cd1a8117c0a1b0aa049665708b92eb1a657d4cc0621d3474927cdc88e941636b4ed370f1e6a87cf0e5e7f485fb92514d32ff8cf73a519c4aa38caf2620eef8ea792b637db292cb80573c39468dbcae8cae3afd2677d8fda0a9c94d4db9f4d5b0b79e3e975f9b9266963e1bb2a9dc9f02949c7f214a8ad0d41c9191852284ce0bf21fd2a5cbbf4ecd73149fdb319e1e8946167c9c72f3954fc0711484541f6a367ef5363e436fe7eaae174be49150df3ce55cbb1c15a2e91cac39076798c99f7130b478ebbcf25b8b67dd930cf0e1a4b7f55ac8d0ca73fc03600f630e78b2ccec6aecf7fa86fbf427c3900551b24bb14cd9cbba72af94c8a5c8d667f28a49be84e96a4ebe94fc2885cff981aea6be25097105fead325eb16a384bb9d31c9db67baceb3c0bded5a8b9942a318e8f9654d6385f8c587a8d9ac78fc491fd5bf5bb537427b436ab85c77d867a3ddd674f119675d35c7460e35c3e5346c444e83f1b32a82d32799ff374505be7dec955e308b88f87f9bd8ed00653ca9ff34ad7b1964c525c2ceb76b845a1ff51e39368bae96116a12c5db07b3187805af3ef0df4ea10ec0bc64dece23d76f81ac452f13dbb7528a9866f9b1d1b11e0f1778d881cb2b10151f08259ac5225b00a5eedd978bdb39740059afc196e0058032cf22916df4fddb807baf85e00b2db1e2d3ccea74369a6df804df59eda112aeb60cafbd563734216edaf7767cae575bf66165df3a3fd86c5263ca08d1e482a8c78cda1fa52e2f3b35d771a2fe8e01728b94b9154ab03d0d0b11fa3b4d5a0bef72e6d72d41a5c74e8a0d2e83113aa929bd48e849496cc95da77cc5af44193e8feca3908f648d4adfdc38ce46028fc5ebed7bbcdba8257f65048f3e8437254f8957c3edb2f6a6f3d58c36cb83448d61aee01e591618b2115a9170e3f6a692e15d0dc4a2c903f1405396ebc5e7b36dc9c686f1eced68d0bc964e46e5ac01ef9e72bc609cdb6dca813f2de5287fde98a677cc4c86aeb0d0f39bc4a50226b01d50a332b16d1089a30820bf3bb7adea95452e9122c0677f1af5af76b219da6e6649e93a7bf82eac90d5a7dccf5c399f2f882b7a644f818b9a4c200f543b462f590d8da511095e89ded4daa7e3536cb18e2fc6c7afafb40303733eb3091b129022940b198c8b71ee28d3f5ba2719b527caca3f69d5ef530b158a1312eadb7d06715c2d2193f03018e607cc1f1642b123b16587d45190f597d04313a94076e499a45cfa1d82fa339f272bf4ae9bf8d2984555824d13cdb37a24d3b7126abdc95f617ebf872f6780c978874c89ac68d726e18fa954fecfce27057372633da837d6c37ae5b0c0672dffc0ca5d088f212a9c9445505d13fb91ed7bff6ea032921caac138a278667e4a0ca2ca6e1d74c28519aef4de79c9f93b6701570d70cb65f79a1c857d3f6a7bbfba75debf728a46ec2c832f7af4bbe363e20d11e622066742a56c14717b02bb6a676bf2a04d80806dccd765ccd2499884196173d5962a58ee55da3ef35e67cb0fa9296766c2e697eb8d515870f150d87d8a83dd839fb42de163a07ded607393277ad3406ecb29ec8d551f804caa498d027bb401a408a68ec70b052ea739e288841a8a56a013e3fef7deab704cb615dd2b12b17adc612b0d3a72e03e63b867d22d98890a2945b0c62f33dc5e1ecacd3b025ba7f9e8d3b0801249b3f1317eff71e131843ea3295786ecee0459fc0589d1a6b24dec5dce6d32062d23fe75eb56099ac6686585c2119e8a25ce2cab9cae5412fe956ecad818b9c4368b16821c62c4e21525f6b109fb3ff4aedb3f9226ab1323ff5690115f4ff3cfc0159f9b4f79ef10e786d144ab78b72734ce350f01a0e0cc370013486cfbe645905d4ab312795d969219afae7df3751f6a9a73ca2b44586491de99d10c3fbf07a5d8c6b330b20aa5ea45f81980da5aa31e5553328974f40643e1eeea94cfd88ac14e4ed02267df78a58b907a7e2b28d66f146905515b6d09803d9448d9af650483c684961b4bfa6e1faec48b9856f3deb1a2ec078c671eefa36382208672102f23ca4d2650830b0373cc70089dca04cb91501f5684cb56e8589bda311585dca97ae111ff581f1c12e4261b05bb9ab5dc82a3f9ad7de6ddfdfcdb13441ba199113248d62196ffb39fe445b71e930899a93ffd037c43e6f1beb04be2c96ee61b1fb18136e57dbe76d48ce3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
