<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c9a7e063946a9ba33bd64e1b0fa4756463deb3f6d414dbb1cac5d6d09940398d5fd8b1ac67844791c9d4036a52d86eb0e94dee73eeb3b752e86633e14e021bd8698862ca52b048da603eb04c1f731e23f82e2f53bd15904b38ac27d61ec15853b2b95a133faf072e1e67401df617b6519de78fdd174c3a0fa0882682b2571f19fa0458aee9d7d0aa4a26e1811f41bda9d09ee1e4352e97157365d3cc8e36ef4db7ccde4e688143c4074514dc603728d7da3cc267207fbd63f21216a273543c52070e8ae6c0a4fd8b8a8e8ec8e729abeeb9e599b7f4d3ec3b27f6e88fd04ffee369e74ac0cc504c098b221f03267e437f7d5de08946801f1b160c65efe9d0a053d6ce317348610f669fd047ae195c6d0615834ab04f127c215bf0e89e51211a69d346a7a97742fc78f074b8017eb3bf584e9b7b4b39d7a0bab34bf58e89ec4c670bf4d19f5bda3808b5ccfb0d33bbedf65b3f76056aecdee9a1b42213810f0528a72d75e280ea42c08e9be602a46cf91dc1d6548702eb4bb1cc7722502bee40b46bf67c4b50eb690e3b84a4b28e0dde5bb5417e420e186630b32cd29890ee0e79b0ad5e15d362bcb98fe54a7f4b44f76bd3f43bd2949e3025139b0f5652d2e87818eab19fa9e41ca221e3f8ae106f8890e4c8fe246b9719d9048c5b2e189366fb09f9cce40806ff9d7f36cbfb9a6eda6ee0a3caff099b52b6af9ff2ab5302fcb9786e0bda577263feb54ce9f611965102dc10b7e5a6fe2bd79fc7da8b8d6da7c80064e3cd1a4689178ee27d28b25b4f1cfd44f7f15b758133f1b37e4293c511f4b07bfe120608b77fe6eee944a5e9bdda02fac2b77e66cd5d7a6cdfd0e54aa69774af72076e5a46739f8e3c4893518acafcf36ffb908e47f2d55b71af389c3dc648858e139353e69d877924635e61ade7776e42823570599b5785d2f116e90d9df5681946d9b1030363f1a576c06bf7806ab1f3690864d0b2f968cfd451de45c959f1ade7be79febbaa5dd4b3b7d66d677380d364b9dee76ce51f15de3cd761b0b19d929eb650a69c5f44599359384414e5df3913d6ff6fbe9245b0920684248251c0feaeedbb5349461de878a95e8e26824cce2d3b7365d6eb3f015e5de65c3c399d0729e5d01267529917fb11aca6b6cd33879af5aa4142a1d9d465c3de0655336db987c1d55855b2e8d67b3559836a5a42d5d468a8c16648a7a6b89c2c290c96258a3854679e83e692280e2cd73523d0b0113f6d212b7f07489a7e7f30e47221c97b4edbee5d2f56aef221e6aa513ae39a6c25e6ebc957871c73bcaf1577a5506feda7dd1f3aa9e176aa92c89536a8d4ee56bcd505a346298bf59aa3af96ff0109f7fb82e86efa1003b6e50338964de5cdd5798e2498bca581c83ea103882d4ce936f5271a69f2e02271daed99ef473e8b9e327aa0d1038cde201915a561e17f306da8933516d9b9ab90f2711bf711d3385d056038fc659feab44a5fa1cf1109133c213f64f838768e555f9f5345ce1f46b58bcbc937d62b60ce61a13de5cbebda5783755e055c76e4e9c42b292de3e496298c82512051f55d2b54129e3e8d97a930592910d83411851eb3183f6a4794cb6ae841cb11610064fb6ad67011d0ccabf406d2865fe9ef6726237dbcf9a2ce6a8e0461e715da4551ae704b572ea77db9af399274da1f6aef954e02e30a7eb57eb6708bd0fbb8f967b8fc18e2afba3a6c909132cbd1c7d45729ad5e92cda97a75d9c7ef75e94e962d55ab6489062a3afbb39812deb686923ebcff5a9b1766cd8e5b38771aad59b8df158c8c408deba2dc764d99b2d556ef77e52bf4fd8c19f0b1453e4272fcfc4cf32193146540e61be56f1955608168e4da0152a6c7cdab16b52b188ee80038f459a87dc15595c3f80eaa0275c23c7de950dc60a3e2d4d9e8b2ec19235493bf3ce62adc5c4f796c2cef51a364a2fb72d436178e92a15e0c076c75cbc38fe1e2dee1e3eb43592b1725ff6266a6964761fb478ff98bc32fd51f7b54d78614ece0e5a2dfa7bd36f8e8246024228e23cd207af676b1abb1bc4ff3ec69929d867bb800e6604d57951aeb9184eed0a4a283fe8866e47d846c57b2da6b89f69ae9182c612b0cddf6c34b13369595d49fb5a67c5c15e1d1095e8bbdb96554c75bba94e88962e31b5d4dc521f94a8f2dda02561ad409cf0c56a07db9199e0b6626ba0c230e96d66c6225610aab340627ff86d5fd7b78ce867d5d985d93e5cd5f71c2d114755754b3cb9b40b97efc3faea7a02b162c2e4af43bc1359b61fe0e976227520cd3d3dcfa61f5900f16422d54bc3b855cf306a1e558c20ff8461eeb1fee54b0a6c6316e9efdf8c219681831fc8b98a080b6d0b880a00e9db569af8a05ac47ffea19a7bf11a10819a18edd690a418b2e3cca5976c58a418851f96f3b1805bd7ee80b6cb9e8697d9c2a737763730f045b58a4af45a9176462db73d492131b862a7301070de55d6eee554b51ca55addc3c8d60d08e92dce0d58a77b72c5c32aa2709f539b785b6a936d53fb64f8a89f05752f5bf04e1af13dc78b5e016d46aa979af0157ae0c890813923cf2da79707efa852dbaf59bd616d0b1b8760279333bc173bb2a2f42aaddd87730c6946d4f0f68e2c42cb8267f4f478742139e6843ae89e4dcef41256c6eda3ed802cc6c0f2e8cf5b9ef0db1b3c1ae9c3f1b0b85881090352900631a9ba997a4eb9df6314b89f283fafa85cfef912f6a5425f635b11e1f1198f1f4505b7b4d1d8e94b5e5d1b29d30d3ebb693798ffb4ad457fec71b559c68b54d7966ba723367ac63e6cb568de3b0fedaf06704671329cfe0aa772b8586b233bbfd1d1d2d72cba9808f33fc590c511dd637dd0c19eeff7139d4f56c4fae85a9e4a83fffa85ed2108f27db83506542a04ca5c21a84bcc96a5543f49fc8fd9bb64f8b299fc4a403ee1230e64ed59590924cf4170c1ce6a1c5885cfa0379c9db82bdc8e69d9103c69b9f179103af802dd147cb5fa81855a6645ed1f99408aeaebd81f8becf49cf52af69c938dc2cd4784501f902f3b5d665a86f7b8ad413b23fa26192aad5509b971cfce0aa9939411b9ed032f96d1e05a20644b6cfe871b21767b35ec17fa2f69875cec82c9ce4a32120c29018261568354e4ea53ba88161887fdfba4c37653145e30f8ebef4305ac4b646df3031be22f3c8c8fd4367ab798fdfea2dc95f6615f183c37f9bea55eefc86150491920aa4a852955ee73f03180d7915d2104a3b80f7d178f560339c7f70850253828967ca03993aa19e0e474c8890a030a75ca897a958f6d21c077e9b69da274da992d58e69d13b929e04c76c5b5a3772855b3bdae7c28c6b3c12a9abb7905644e1044d3cec0849251ced22c9dff4a7b7d6da2b52f38118676d7319244064807db20aca3dc6e3444eda3fa0efab00dc1b19999f2446859c974943606afc7dc9a6899e85e2b82acf14d0c89449f49898247f5ea0a12c3cc89f378cd18e08e0fb26c1965aa199b2da263ee5c36b24a826dbfa80d4b749f3850ac8a7791b2bf0b230c42f24944dab9ac0bd5a1edebdec817a3a79b923f04b51506f65c6f80eb3e6aca9e8092c70eb3e9cdd8fdc8020d05bda113defe2ff8c9e514de98d0652423f6e3d02e1509d26256a959d337f09d6497415c21488f07933bec925b64d1b65dcdc35b7819be13228fcc909ea82bce6110ef9031a7cc7902cf480780c8500dd30f5d27d825d9d0212d363732c03907cebf1b411a05de43b8252e38b93a3159c9cc3d71a579e87495294ff5a5bb355f3b2ad0605cf4e4a4e813d036b030d76037993ed475c45e8d1cd5fe705d886df820a0bdd706d1f3773d12c9f4baf9107a1eaff56c4034fbc0f5ff7259cf6b9366183624bd52881e16caaa63b4907d5f6c955cf68371ecdfe136db76b4e5f887b8fff39d41d21a5801f404d6994bfaab68619dbbcd44bb5057f7d92ce800f5d01f9b9e93954b0cc6f348d0f5d70d88c7500d5382c1f84f80378a56223a7d381ab2f31255924fe6b655f56056558670e2c4c59eeadda218d66199d8f1b2e16b9100e44ca49b1f9b263d75e4e2c8c509503cf3f78dd8ec25ed621c7ddf7f514d061783d9f4c2060a9e842b3dfcb1902691b5fe8fa5465b5e3ca868939afa7f9b4d8035111d3d119011c3cf5e4d7e3db052934d9cdecd588e3c2750b88c12e3f165209696daf425c0c416a67c0732e6c91f4f61d0694bf11006dbcae3c5c7f794544daf923cfd9846453f0eac5f3603a6ac1bcde79a72df675de927ecd47799a07ac0db1d6f47be2ac3cb65a2a23e1499cae5cb10f52a2a464d887e0e889e1d9eb0df348344bb7b5a807011a6a334d142920cd81002a05b37365fb695dc6fb3f7646c32e38db9af019eed5757989aea1100e2a6aa7afd1fe589b3193bf67972536135292b73d6b7e59ca6331209d2ead573198212161ea5ff86e04e37aa5e39f7ec30587c96a8119851ab5aa4507ed20a710940af0e925229f3f2098b1950336803b1d2e545099aaa9d602f14904a8358da38865004b15f25152ca56897dc9f6a16fc6eb411f7d8ad2a14fe57d3426974448ae7a8cc5577556e8c5f75bfdef482b4316c764829554e8ef7b1ba3648c8ec536dd37c076122f7b3675f153e45f12120f8f2775d47a22c5dfe49437923609de84d6600d4a0f11f025e0072ffa2dbc533034a88ca42bff89a0fb02e9bb46a412095ed3d2a051c5f999c68998fd520aa28f51bd65762da9a960aa3006a0ef8ac6873410706d03573f04bb04f5386393783f0c4b2f9d5ea77e28697f84a7a34a8ecd97a5e090b34076e256ac720c4a5dbfc08b6718114a4df8737671aab25c899c175b1372320e9daf80dddc95eba5db06feba018c936ce004e010774a0b86b199f412aa07decf542ba4c5b130a95c5ca70176e03243e4a4488fc3831cc2d426b4bda22ac9f518e1b6050511faaa1d088dc32d7a064d20f39801c1a95c3c57f5216a0698e49ce3b4f9c5b4f539b01bbe92bfbf97f099747d071ba691e0e35f6d48d91b727c61565e08d09900418c61f5996ba794bfb72547b43c9798f873ce340d1c91c5c6544e2d5c265bac63f59e9601f4fa181087939df9a1069800c2aac7f8a7cd631243413ea516f27fd91684549f1d1dba8818dee4dca569ddf6323583d4c4c3528ae471511efa95d7c8788011fbd2868e2d31cf494b50a6e7a3041d021b41d2b08b5fdad44c3cad95ff99070a09f50e70ad4d9bc9ffb98f9c27b791f1abb9e61235909e6a13a805aeccbce57ef0751b1c44438577a15f4fa2541498fe405f430e1f96b1938069da6b9989cba85b476889be9ea0171dce056bc0bf506b5b92827cf2797eab568a2036696f88c94ced196a20325fc417be1ca9d7f0d24952c7503957902a532d4b9678958306fcf8ddc9863b09049ba86291a0452af10a1b82983792fc78967ad005e58ff9ae968c9911865a0d5e94c8f00f3820654782c71cc2ce14842766f6820126f647aa5a77c2bf99d1eab3e6a9c9243015e03e7e9eed2b249a0c806aa1167bd5a390bcadae89a18fae0c44619bf9d23eb1d9a93a35fdb710b2bf1ced0025b20bbb806f7b461ec881f5562dc29e61f617c6bd141c88109fb0c9b65a299d7bcc4751064f902c223108d87f3c479eb9f636e6a621716a65fcd2fc3dbb19fdf77c6a1d75b67a198855127e4ecac176d196bab6cf18b96d8084318be94c5938c6c73e9506b9e6c1094f383320650c2a258282cb0fe4287f2af30e3f7eb4f6d91bb90b8ac6e06e8d1aa3817b9219729bb8f4ec84e2804f629250558ff320e5bce717f107fd86acc2d1f4ad9275d78c406afb66fa807df368c0837e159f63a7f2befd5560153b3d5034b769a2671f28e128e6d4b6c74d1f103ebe409d7829e8b2ce75ccd0cd2babc0c9345598fb2106713b11c7d00f3654e108a32b38b05b6a7921cde91f9770b47bedf2073f5d5ea3ff7840bf5d8302c97c89672a72e981703f1e28638da57a8b9db0dbe4fba303706b8052e5aaef579a86ce12f0719a51467dccce242994c2da6c66ff40317fd694f81218a8c78e79d7f849da4af258c9f020f6baa032062a64d19fdb931fa4ae870749b2f995ecfedd5d37ccc70326f34df0cda990c74285e8f3903124c116a8c8db835fe5f1a94b8db985d3d3d33264d6d07f66035b9c89601ff84bee78620f34052f7ee41a875df838604f6685f8d606d3d3e3d1704017e5f5b16979c9940b1f82503e896f9665aba19919aaf2aa9ea79cb7b229659d2770da87d459da2e6e3086ae9e96cf092141711f27bf93d5ab240d4d20d541ea3559c38bbab22ea1f6d3672a673f450d0efcda49402eee91f6cdce9a642b422abdf55ac707907ab237916d0c7701a2faa2704c67ca2118dabe5de3d57ac114dc3770e03293b36d0acacb14d10eff0884d86d92de21e9611b6c9a8ccabbc6f87923c1782b030f7306b1a6a40362b1a06af4f3682c7a46f4754f6d22279078de423facee3891e53520f4bafc657c6b186ba6f0a2cfde18e221f2ffbfa5b4c918b0f72b57625d0660a69f7f33d6c3ac0a929b92975480846f318b6163aac3b4c3e9557ae9bfbccbe9c76b43f3e107b07b88aa0fa71403ae0d4f6b81bc9c9b289dd958c786308817f60716c907ea8a1a23ae728729eb0efd3395af96a7f2fb8d23b7d473413d3c2e7defe44434e3ffa5938deeff6995475cffa250b14c146744e67e19262eb57f52fefd138e6f2f4ea9b6eef23472c06cec2f696ddf5b7741c020bca034351be58a2bc187f7c10d001b95f77ce7c806fc13e4de8831dc76fb7a8bcba25deaecade531577c5a9acfa5715bb91d31f3c3fb78f2ba0d064b4591afa3bf39afa13b694a6352cc18cf61539c7427d9bb00a9b20ebbdb8a7e311ebff856a0803ce21f8f99da7b3fdf9c448d256d7a5a67e9d998f4ffdd1677963497346c8aedf18d64ec05946876f7a283a788fdec180a4a2f89a2cbb4dad1afdd5f585e66733996a96c826dc1b4527a2512ebf2a474e48a60557371b6fb5f885119b5ca4e785f95834e4963a288356ef7e212c17fd5292994d4c0822cdd50893a265829379b48062159f802dd35a66efc4f11c48382abf50df8021a1bacb6738499d4298d36d094d78fb1e26e716ac2848c2f7945d1b32dc7383bf1665c1ec256bbdd38ba7382ff6e039d8782134192a1cea97c3d5f8afb02b088ea8e619ea607f6b99730b5080fa6fb1e390e445f211b810cb1f569a3fa1ae65bf5eb5d337afb98fa0a870b2c19a41618d66dbcc7eeb424429281d7d2df18c27b04414cbe9c98122764346e45ee81afde30a2da8bc807bc4bc570055130cbfd73c43f388e410fc581fd58f0671d4dce35b30999ac37bfcbdf1c16cc8ef8147af86dd3aa4a1a03015c88b16e9f39fcee65d029035fc1277e0b42fec57d071504e9133701139854c67507363d0c93a77248d73d9aa887d0adeace79bec53dc81b32e785e37eb41a284b04a7167470b035b4fe976dd00880a7b9ef142dbacf5e5d0e4ec6ca71064e25be8726790537cef630231b5fe742bbb8425c471e4ed5d5bf097462b72b9ebf4304833265997df2dd51c09fc5f3af6b9d8c6097de48090c9d0d040412b15ebaf266448740028592a4e2b184f5a1ed497e2a2f0a411f0edefe304ee1695a471b90012dfd201b63c21fa28ed374605b9cd6a2e556f23d3cfda2d43f62073f393bb2a15831763b91e69a39d9bac1e600c3b27e46cdc6bc1f1fe953e12045a6b847850a90624ef62481f34fa6b404335c467aa3d4720f1db8a97231d601a68a5af6a25206e13594d6ee24403bb09d949fdc82addc8a7b7811674f186e5095333d2a1d64a5d8599c42f5dba65c1012f0b1286a29df30d3b3a9f7538819f4523df650de0fa54d7c35de4adcc472aa280409aed9534c3dc1f3b6039d44b21d0110c5709d1eecc4e24c429f4e3d8f33ffaadeb605523e2dff8d5c3a21dc956953586bbcb1032a355cb5b5e4d21c5423428551f8e2e54bff4a2a887d71c451d1f935e78150e18979aa71d2364c32ecc2bcba4fb12a1141a8b00ef9f9ad33602ad44f932c12aaed71dfaa7f048f438f9ae0698603f059fb12d1917607229c5d98c79b62e621a1a289078a525528c128c0f0b5937472859eefbde079d1ee1578822d7c4a6f5c3a9e7a3a0bdc145cc9ee9a102fca00aeeefc11d2227e25a195f3012c5393c40930d0ea4355c25c68249d52e131fe806cdc2ade965c3eb2e8281b3643e38f339735f2cdf1ccabc1d846d6afd31bf85e12b00b4d3110af886e2cf3a68bc71acda9074d51f6619330048df3c11deb47412f31956a62b422c385e51948a39e48ee403e7883a452c7ddf4e52f3b589a156a77bafb7c5b362859f14a472dedf8e7a7e43efefbc87e21d6623180d6eef26d91793be106c1bf9c65f11868ae2e522df7bc068fa6686c29472e6dff5de66057c84c2f1c2f3acc5a298abccc8cb19b39f70edc592638bc24e7f0cdc679d52624c2464898f40badde11a5a977085e126a342dc2d2043711111b9bcb051b27bba77e16e117d37bd6bd03da2f3a53b9ec353ac89fde0428d9421cb0cd2b01fbe4ce811e5d20cceda803c50b54d8209e6d2b923d0cbdf32d654cf02626571baf286ad073240b383b18c10c44fe759740c4269fdd6150b5b68e024f1beeb7af48c47952799e37d985f873f2e06eb1c4c6fa8bbf94a288383fde40f8c022a7558110973afeae0cb21838db3e883ada3fc5863569017ae986b727965c62626fd099a29ba919a5cd5f3e73af8d4d821c2611dc0913d40bb0121ccb4fc109180eba5dc11aed0e7f0c66bd037a8464f7b0e87093c2fd229a97fc8543040d97877dc153df2856eafb69a662d0fc497ebd8bd80476e00b62d17511dbc2a73959986833d39651c4c6a62c2229ddcbade7158eb193f005b426fd2ec8c96982d1ae3eb9e0c4d6fb854976ee5cc233dc56fa932c063357ca32b27d70135dc6f25dead718b183be4b84db3fc28de98239e618c7daf6c970b70f67fee2af87c1256069bd12fcd0924f87fcbfd21e1998e2d4b8843089935b7b737ce863db4b53400bfcf2109bd7b614ebd9b089aed0de70debf56355efc4f6b4ede036a4fcac59d5420a2f5d8185e2b9f794248d5aa92bb5c33f2daa3ef315a4d0c39cca4e78d02f721e3bb88788f82f5b84ea17de2e922ab158f607b341f4b8d8ccd7e8a0d22f451d3d5e7183509db0b8b1ba2def7a115e9e8cf77972fc9f3ea697209dd721f1a6098e7481fee2d6179979c6f0469113ad314f8f5f32c6ee63691f8f8542b5cf275f646c839a8895d631be8904698fb554fbe44df0c7afe362ffb9ff7da9baae0c8354e2b3916f470c17fcf4d0b293ea83a429e6d45fc5e44e85ce7f374c6a0e85d2838af7ced38abf5949abb395693abc01c66eeb0d93525560fc9f89b5e363fcaae3f3cb5b3539c8f4cd66d3b4d5507f164fa60d17c8fcc489ca8319e145e5dc30cea6350374d0fb19c648a2904880a1288b0a731652efa8e7833e5817621066a84ae828450de83eb14332b18a7a50ed38fb90d3c51980323a628a1b8215e5fcff1a23f3851267e57f2359f044d1f4951a78c53061d20a0f9e9571ccbb665f0da502ef460106649e82b751aff16ef730c4f4a42daebce823b5753033ef5cd5457641271341d2bccdedf1e61fdf98e739ca2ee9025fc22446ed9e9b64b307c4d202a98c990bb389eb5a5b3b36c18dfe5879876aeae08058cee7d7ea060624a34f9cd0e45da15ef23e0e0a5b279ca5d99c34711cdf92a3099d40365c5e60c6b7769e80aee579b2eff7964ea793710d00e10f09021a9a3e2986b118fe735c34a15fdbf3707545d33fc03cb2c8a69ab68b648fcecfe5d1ce172c5ff490f18e07205e474b8947ab99caf9c026c6d04777672cec54a374d60bc6cba0b3c62d3797e94318a181f812201a0d1058edeb09793962c46eafaed7a74c038eb4ecae327bfb87d5328d6b8d67b10830f9e62ee67da04abb2d633747c674f64a90d78224ab29b49a375e6f766da119be6d234f3726adab437741146c581aafca75942fccfbb31a4ad9ccb7355c0b2d7bf0b1b3b35fa449c48c3803043d79da696aee92564d488e20f098b4ea18f6d2ed2f95921012498d5e80daa4b3fb7d1186c26fd3aca772f8c512619b3daac18cd5833c73c00c262b913ebcfddb166a938b8e047571c2450ce56bf3464ce40c15bcf993ca92ccc875aa089daab8819b281764fb6a9076d1671d1c017ee7863ae4a561478157da33fdabff3055d2c7027c1608e418ba4ed0ef2e0f8842a4408a2f59aab2b8256d2743c35f70b023fc9f137b22ae6601fcebfc7a72261fe3958e1b8b6928792480dcd06fc1848287c59de8c8c3414608541e7286b60ebc3658d4df02ed697c3985cf506ae3e8b908eedc491368578fda7fcd9168f522429e32b336aa510ed930c2be1b92ce868ea60b1d463ccac1f9231be4d51e8ab62d18b744a39afa9a251a85eb1ef6d0c7988124b12335ff4b9d06163cf938d12ea3e64663b2ca3213547e6d566ab5050b8c4744d215d1dd51f803486f387733f9b438af7f574995d976e7e68477d41355bf91034764a3a0ab9de167b801e5fc7afc3801835ea15c6d0dcfa9a86ff1b30cb44eaa6c80fd7037087caac099feb4a8a112e56288b3e547f1796fa02bcc9470e9289b4dd5dfe558c8742995639a30a5f2f5e4dcaa84024d8a64c641833fc7d5def781ac75f37607205f8dc7b22373e049ebcbb5eb3a4fd8344c33d00486d3a2612fe89d6e99b372648257c31cd5296662f3fcdd1e05624b935d50779d544d103b06ea1947f3a66dde71e6c19ea1a689c96007d5ed86d0c1cb674b3ea88476ea2de8e737ef66435cc94d6f853226f4d7e22845941447867318e3a9a0c5df077bbf3592757770dd3484fce27b09e729f92bdbe5a53ac7ce8c3c6d621e096a9cc51e0a2c8efe8f029f4d9d5c3134c5f3656736897da48b24667154ef0fb02a95cd4e1434aa815838b1cb3ad9c628ab7bdff5ae5a3c7bab061600e76afc543549822ee1859196d418efd9fb8f2cecca77cd465a3aa8b8c724e45bbf60c4e0dd88cb67e26e6fe44d1d9ff2286e365a3e673bdadd7737a529678e935dccb60c240c5689d9b784161e8e60b5cf717226a62ae2964ae5f8c064b66953dea3d1ec9108a80f84938ef7609b6a29f1c81c33b38eef6c0f364ed04ad5de8aedfc03199ce1f7ee33f5032c7f03d361b9c0052106aaaffff1137bdc111310cd81e8cfdacdeedffc578e390356433ce5b1cf2224373475e87fbb9c4f512d6c21b6b5a06f72bd4fc50f6c842651b6e4f072865150f3dd2defc530e26d58bfbe29c117f544262d6f9ce3502b6dadb8dbdd264767175f7da2e99364dd3dc42b2770a202759f7cf50f29bcdbf9e262b151aa578c4e241e40d1c0022741f590d19fde7ee7feeb6bf0e73247b10eab3cf9516a7c6fbfe10efe4f54b94617f40283550e0acd31cf9a2d99b7618a2242f6280253995a1801c93022bb128724d17f5a317f89d21efd8d399cbb84078d11ba8f01119376d451e9a1c1e8bb4757726adefed1fc0070cba6102b115eb8814093f6d121420d32367964605b12943c43a57484c083d1d449741f7d5756732732ef6ddbc40566c147c965b3888d5943d932334090f68d54543f7b1009c23184eecb6cc792dd14f4ecfa08238a80bcf48c66498e95f4f0cfbb4c7d71d5d2bc9eccd0ebab63e44b97ceb7813f0fc634c57da7c373c2833695acecd6cbb6bd5621735039b50f06c293fe1fa26d452657bbfa1afcd541dd7e803ac53df9b3bdf0182e06018391238d98cf4879392d43534b0faad1b917673445d907c211138fb47b9fdf9be9dbdc7c10181d7ef1947c6ad092f6970db14dd71f528fda0ebf3e7cc185ab7edc890634b8c52a4a99563fa430f8578bf78a26eb6a0625ed4758079dbcd6deefb0d87117875b61512e298b6e7e4e03ee3f7f124a1f909e9c57f3b8886b8407f55c6ffc407e5df367c762a8d4067063cbeef22b43e78a32c000daf55b325c51096445d4627edd4b138129ce456af3525b67f198c6ba51b010f766692e6dc4d75cfee169711d947d998571873e0af61b44614b5748001ffe0e000d1aeb3072d95d58dfe83a8ba58b6e9be1334c03480c0de908e6bda0cc171a4c0062d4707833f4d9a445ec7684f7f346e3ca6162765950f99120dda38827ddea3fb032d6d0ed610061abe009d4ba1b3db352b15232a29fa5d9f3d15db0eae0d30a90a4dfdea0fac37c47c3b5c0259a86d63e800a80ab9066e8bca12b689e1747e688779e7972052c7ca933859ed417d32adfe8c202e1c3cea55b74b9c4570b6f4c6a18cf5eacfe446c91701a25d91f869f217361e2d5d2fe7bf422de268a59338a8d0b72b2948eb6c44fa7c4c24d408e5c12d41b578","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
