<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f02fbed8a97414e5a4a3f8e1dcecb58334cf7d3206b15acc2671f5b27897da14e241e2da56b611c6435abf2e6dddd21f5a5a3d815f6dc784dfd391346d8418051eed65c1caaa1b9c0ac14a48ced3c438dda30e457961b785a4b042853e9658c24655742e7357ec6e5ec25077553acd9b70aecaf723df21eee528471b3ef9ee6ee713fb27c8b5243db9aafe3a6d238b22b118f228736f749b7abdf88c551d2b41a54ab92ff93678cd34758f94125e57094ef932ca0eeeae083f188bb622540af98b466182e9daf65b3ddb5dda249e50793ce3f0fea5078e90977814bf2d5012835501781127a3d478a8d9d236889654e25bc61f968e2f5a15f88bed6e9b557f356c27f94bcd7729f04508677e6db65233fe8dca7598df12aa0f672ec6c790a561d03b19bf268625e9e9878df70c02d4b2d0b3b504bd32f9975ded84f34ee14f322b97377b144e4d30a83a4923ade120969f99cf1cb5a791645f0ec227d761edaf7766a0f868b2397f89f65a60a04feca1489d789323bdd09922177c6ae2584cc2f50f600db076adc977c3b66fcc4a3fcab34a6d5e3f7986f244c1412d7d548e5baa9c62496ee9b3a8928e5afa80fe3e0c5528ccb96757953890ed62e298a9e1b607e98ebf9152e54ce1ec78386d5da98f80724eb0a2aae2207e8cd39a83340b6538eba2a1ac908ee931c447b70eb390a3e1099ce53c2079e82d5b4964549a16023effe957abdf9ffe77da3e38180231ee0551bb3f464e0315ce63f9d615dec4ce752cfec7856c958395834d167fefc1e12548adba29966a351bedbbf28c2c9fa369b5658c802c9f2a4f828a8fdf2668d5a68f3e90a5b3b601dd251b0baf69dcf8c6b5b5a6f2e8442a92c386866757bf419686bef9db1978e049017a7eca9b0ea62bbcf215c5f8d56eb299eb86b07a5f7fb509babb69349393b35e9329492c4e6c94b27d2248ad6e5e65c7e22a598d0f96678c1c9f56bfde5555dee8953959382f72840a2db345a00d3120961f2b2d80867fec18126583d19161150a071d768e1a0a29445b77440bbf2c681fdfe4f7d8a38ac52fd6a1b3a8a071553e396311a3ded630cd85af755e8ff7008bc16d140cdbf326834f9115325d738e47b0a6ca2817835bb1d6c924a7ab5146c1d16c8f054cc99c6f38434d2a7cd34f3efdc96b822ad94599c24b8f3e7add4784e74e7197cc4c7898aca8f68a94b5eca944763546fd32ad96d9890e87da0611f3dbcea33ea7c6bc48d220555f074e48a3e139fe713d8dbe7623a645fc6e0aa126e591e6d0460be38405a6143be2f30d28c3d4179524d1f6dc197abc7c41c976d788231dfb85c64d37f5b05cd7734a3c9c9c76fbb73f4a6b81751c8ea2ae0e8a2c277c7de989dcaccff5b99fdcf49b8ad22e8f46336a5c8b585075015b7b009eeabeda18534bce5bdf8aedba14e988aece6901984bc0b7a83307909e28937829174d48b186c7a7cbb07f1955f19ce3e6148e5d4e1e3c491158a79443e2ba663259c27bbfe62e82666aa96b20b5adea8d4b9d1a1eda0899bfd8d9bce683841ebe79be2049bdf8757a8cb6d784914816bc4d9412435dfd0f36f9aa7a7ac2c3cc7a02b54fb96061ef95996a642d62a12c3f8eb4cbd959d2055f0279e0e6f977afcee1e7efa5a849f8f034ff4ee7d53732d863069602d0d9f28fcb40905adaaf74f17be1851e5b69a91330df469b4efd152453e8149c09acd2c6d085f407d6de8aa83e4befd83a52f10d61ae6b6eae04b73c7f43fd50c5d08334be7b7c919d64e3927c3a77b800cbe7a259033ee2683efd6801bc0fbffc1a2335fed76fb5ae5d69f1c2f73076fa464aad0e5aa4949bd3b79947bd05d0a44df6ef33ebb110bbb71d90f871eb9edf9c0fc8472888a5a06d562e56eefb4f5e92f01b79f79a4f53bf2c1b0b51accba1e9b0c9687cac667738b981604495ab638be75463a9c262f19bb80a802de67839df97d1fa6e1a3f19bfbc36cf1d00760aff1779f108afba1d1aeaafdd908a1125df90914702be209b9a31c59dcd03046fd92d257fbac30f6e744b517eb231f84ac9369006cd51c3bb3f35be5e39bd3b5c597e54c4f2017b2ffe18c07ba24c71d3ec1543b11a4a75ed452a1f1592dcbb39d24f6b8b3dc211e9ce5c4e7f1a372ab82f6cec2452b9af33f7a8174b271ca4f1d1a394d332883e5293489a5bd92728258746c674c8da4f800959747848ab1dca0f2e332a1dce45111779a016fe586f6af17b13a66691c9c7546464db587b0607c3f48ed7905f282e5eee4da916048b46c1370c2ccd58923e5d427fcc83f94056404c85bb7344d0b72a542d33a8cf3928cbb7cfde05214972ce19f743f0f312bc5d2ecd41618a5df6788809c07ecf89a454b8ae73836fc89edd8304dda4ad85073d65de9a12eb39ac05a206ab39628913e6742a22ad446f9638a92e6a192886d050ead1d866cf6dc4005e9bdf337b3cf454f8ebd39a5b6b14c3c10322ccc672096cffd6fe4900847c25264c842af867fb00251369762d06533ea9cb202492a615c0fe8a2f29162b6b21f012b1786fb5a56b4e99853bf7379a2c943e739fafc4f05f0955cd049fa0c24ccccca8bb3340bc10919417ffb6e877bc28376d84fe83d389f878714c2544a6a92f413af390f9704855755028c03d2990cc17f1f5802ab9b9ed051454451d69436faf23d3ec5f6f53d7dfcb8b860c4cd7da40a012afcd7a0a064b1ef95398321d217167c4414a7b19ba172d9286a197b9d8fc75e9aacf24d5cca2d8b00a3829013f5e8e19e3c21458a4c87c3cad9ce08f45b0e77b1892f629dd4513f8edd9a56415af90f7f01b70d8f79ac0e1b5b40ce22ab4a856a5d9e2678f76c7bbc0483198d2f83aef6a4e889e67364bc872cb0d273a16b866513f71f756afa672db10749828e90f9b187f91d991be605477f344dbf1bfdd73cd1a4c41884374dcbbab5c4787e42035657b746b71507d56ef83cf5906e7abd865a924349c6e30bd623216f3c0ba311b84b074cfe034cb9b0428bd708cc86c6f0413edbbfd9659fc1389044560c559143b348fc687160df2dc6fcc77b5fa59056cda159b8ce667cc972f911e9b87b4033d55a7be35005f692e7c4df4a6166a2faa9d465f78bc8408c1a7c40bb85c52af7ee3bb5a845bfcceb5ef78e27b60a2085667d76acb52d1c5df648f5fccd3c6397a862919aa989affa326301709f9298dc779bf1095027b2c702b2f56f1842d8bca054e72eb9c96d16efbe97d3effe5bcc9150cbf92a80f6349fe4f215ef1bff77660ae18af921079147e5936b017f359e891d0539311a981a592cc3afb0c09a0f695fc65eb7a7cea99259109a1f3619f2553a38ec634479b82e11a9abbac9ec40f27c09f4fdd3f1a908517b7e1d75d39ae36a73d4ba408fef04c6b5bf7c5293505351fc1dd7be70451848aebd20349959fc65f73046cc0026a2940b2c141749d46e31593bdf31133da0daf8cc969f4a61740fbdd06f235f470f65be7c185d3ce17d8695c9979966e40691fcbc050dc44a90a357e1dc7c52b4b142674517077e35b59c1ed5dbdddb67496f835c0155f5562ef2397f6f684dc3ec82ce9b32e861f64a7555981fb8f8ca1f1e94637e491fdc5410cf8ed2dfff453926019624b2ab86b5af3850759aad5a99addba85bdbd41ec37556ab85775637d2ab333cc0ea3834dc545531523da9cefffa7ce4dcdea02bd1a20e32f37176d2b3a3a20ccf62ce89028fc07d8abe7694d75ebe4bb180c28c487f8377c6118ff58dde5ae829c4236c1818b37d5ff8aa44535fa2e3ea54d735e547554382075511613be3e08aefaee94f57fc9cfb1bac64a33d01767d71a9eebdb661c793b3380b45ac90fa5bde99289e180072d4f5d0ac221bf3a376ea12f77cded8231d9eba89d5ddd59b765eab27d8f436f46851b8ac6499a069d50e464670f4593c4120a4ddc5fc979922acdf79dd4672cb1e298a6263350acd332a8b49a4de6c85055a5ce20e006e190a15f65df4343d2e25e0658ce19c5ee0ae229c113173797a5d0773ffe42d4a6b36278d978b51acbc33f3e634cd8bbde990c154847f47142621100cb8f5b032f2f5df804ae996a3a8f0abd568b88eef0df432aaba94703013b542b7be7ca879934486aa5413597a0815a1b16c47b101b03272d245a77e25507a37655f7cb3fe27608ddbf5c1e78308cf96bd1d7c62fed8c782388aa5486fd6bbdd0d01e107e6124205ddd5bdbeba0e26a4989bbcd0f84788e61334ba100ab8f730ded6d529134c4d0f38930c2b0f1b8d71eb5598e1a22f73345095a589d304176b75b121ebf335f4e5d783ff73269a29dadd6e508b3fc06a8c53004cf9d13130b519ce50ef82e21c138607d573b27d633bc39409ee8afb0906ba49bc5fbc256e82464da408b4f66eff7bcc5cb1864885ec9f77501985e1b94575397a554fd23a59cc6c520f4972029ea7a38572e7a9d6325c0bf0db7c5f8f7cddd3eea8e0b31184dc9455bd1958b154f4625eb3b5968ca6bee05eca23bf7ec820d3fd6d67a943163616e1896d0575529c7ca89d9472fe345ba667e73d39e6983f4fe609750a1ed0f3b07817be6e0b7a312ed42cb23773cd3c5393240f8910d96b2e0d4076ad85652c9821ab87d29f876d677d158fc45e12738940bf67b320d99b4735745fc1b7554d7ad1f7ff274e184d065e1419563c6c623ae592944dbf77def63cc1ed467c9da8f238c89f67f92e362bf2d87ae28a9c5a00e8138823c7004bccbc099710a0c353a5beac911701d956312ff6d50063398ce8e52be24e364672ac26ea3ac0cd0a3ad9e5cc81e1dfe2de808b5ac3cb333e7fec6d9fb6f2d6d74c1f03e85bf0e987c9297733d9dd3337925c0fe94af2b3fbc05ba3870dd754f7c6b1456ec33f3d79a028fcfe70196c88dca50b91abe72c89ef46d3fb22f3fc49dadb1202a8e8fc6efafe286b6335f22023769cd211d53b37a08cbf69edbeacc4ca702fc61723c395e373d5970dd79ce96702cc98a072f96088e0fa53a36b0c1acc924a2c63879c6fbf4b6080b0d1e8a1c47b2805f759491dd2383599d5a6dbb8b4c7cbc7e6669c0b92b4195e1efb2e33b142c0d26dea1a19a0bacf6eabac835ad3a411105724363a968657e4bcaca8ec76470b0d6344e546840eaae749643b452120d03c81a5a44e7ff39a57c2666f3075f0d7993fde235f537013f60c587fefae49a76bfc2aa630ccce39f3f84767a632ef3f373824b12cdca5bf223393f365533c4486566402e7e842965a75b94eafe2d023996ede5fbe4de527752c1eb11897e5c9f79038f1f86ec373f13cf6d47714c04c7331b4aea793edf1d3c512935647f0484c197f9679d1eb29eae2af16793219935b70c03aac2964538283aeaba5882530240e2c578d3e49bc9d874b9b04eddd551a2aaef1a44974bb282a138b7c485c0c32943ebdcfeba751ed14fc4e077de752a8de7ff09855e7e7579f8105f5874b1f3ee573aa98ea6929d08c80551f8cb727e7dfdb4a256dab529ccffb2288ec3e787a589f8511d088b7951003364a629a652834aefb8a2db483b748a88a3c5feebe4e9cb297adc28477ced4029d041914b6041fd9d4ab449439b8fd99f56d65428e31c4681dc6defdec5bb835fd3ac48fe8a1e2c5d9050daf048697a0f458255e882cd9d6d35dc20925af21f7e63d1e166acd999526cb480b9330bb76dbff8ceae6d75f726ed3cf7306830a240b5f46a57c4c3a34ebca2a35a2eb096ff2f6c513d68118c0dc4bd97286c2db5521b0612cb56e73c9b1b2ada7995962c6d22944149cf58554f3b19517e8e3707162fae159f15b7b1ffbc25e59404ecf858aa395ac1f4a5911711182062fcf2eb5c8a15a95b52a8aa3270e3cae852ada14cacfe977f413542b289b236d5b9db8443e59bb7bb5f9a0063930cbec957020894448c5765d4ca24251fe29017b21c179119cd24755f8786def20ea6f9c3c0bd631ebf3c5248eedf2e403ec4c122cd5cba9b7db81d9bf21ed05a3785cdb0aff9a4981bc7be56107ce734a289814f93ec7a606217f5e7fc38940a64220e0407f99fd762e30191982b762651d73bafa0a39746b9b544bab7002eed40e925c025140551d8cd43e24f36085cdfbb9a2708022daf2fe99cce49f1e5c8660a834217df8dc2020f90ca77f5f44d7e24744339d05ca2e32d499d71f026141c8ed1a1aefdb6c50728d62a0a5a2e5171b3a90ee9cef7e8aa10983ac370547150302a0f773be20c9338d550dffe42f7830d9b32e1ca5f4c763ae21b9871cb28d5a9b3e27d7dc61c1489040391d4b6efee50edb5db289652a0d8ca5ae79104fb4a6e629a03b3fb3b515e39df65866b47a21dfae3e0517d380ba90eabd596cc9ea65985a2cd6d1d122099ca6a82dc52c771ebfd3451df4cfccdb82433c14321df2b50f3356061b783ca3d8dcd7cf7b926f7a500568877e6f33f7698ca5d34bd4de325acdf738ba29fcaa30f5c81987fb0e3067c211887fb64fc966afe2b360acd1f091c3ad7493af044b7480a98c66f5b082a2668ca778d0ba2fc6f2a28e48f17ded9bc28d5ffa607315d82ab20b08686042dc0626d2d5e2aafa29ba7151710ff72a041b7c09c221396c30e8c6c2ece03f2cc9b868c546f36d917b7b1cf0889778e9e23f8f94f38a895553ad7e073e02012244bd02901f997652e4bb269fe68d324a180e3b0e2391c4d661fc86a368595eb7db10855427718d937f5e0f53cbb178e78dce82228f0ae58227124c03f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
