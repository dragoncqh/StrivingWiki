<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ecfae0868a67071991e0c63e3f9a30b2bed28f41d7e1b24d716e43af851143d8d2f22df2cd69f3fb9805eef6c355a3bab95c5b1feab1f8e3f950624ef8a6d726e7425aded3c8efa8fc66df91ee882ecab71ecea12f803d077b3f7fb594bf5b9d9001a3dc3a76b0f2bdf9fce3c3d7eb05396efe60e954edfc3e30fa4bb70cb0c771bb8539c71ed9f013e7da77370aeb45d51d82717ad80b4fdd9be3a9922bff56d8c4cc2277a49350e518aa94d5e58d65831c3ed8d7aaf29a64d426f9d46a8011d17150a5a3cea96a20016feac8c30d759a18df689ca0ca8e7f5785c4018a42ceff7592dc179f02f81a61060483695ca27fd1b8d827059ffca216d71d16267317fdea77d7ef8f4dfc474e88024cf303f86ec868bffdcd253adea93e0074729776b0e39b87b18773946033245dfc25dd1b4c451f5c204fed2b53f63ddead08ced6fffc190f24d244dc1d8d937aa93262d97f6f2a8d7bc0c8c6424fbc3272c9cabfbe77959e60f3ed2d0de60d9081ea1d048c1168ed16260d15ae84c41e765acddd22e55732024ba95dd55bb7c36dcaeb60f7a66a8b700e69fd551136896fc3cf9435b36207e6f55ca4f199e9d9fb889631cdc7270316ce48ab419c62a35051dec648128bc9ee0eae6d302a217687ae860635e4b5dab1b48c4953c019817e80864724d646b376578d4218f12e0a554ebdda7ce612544267a52a07151f0063de6926713d74335b5b5108487989265543e491b7af0d1f601fc802085255062a2c51cfb67a31ac4728f5721095c6d53658c9cbd38585ab864683ba4e3bd086d78b95e5415bf4370baa844cda1d088ef4aec9ebf35d2701fa58e00d7ab766016ec591150a67337430cefd81da38c978bd1582be36e104855d18537bf066d4981faf3bbfa50cfc91ed179ca4a1989f4f4bb2facbcae99ba8cf413ea447644c3f0fc5a543c97e04c9334c0113584418e5d3b416544e8bbfacc80fc011b8c9eae210f1b44c111d0db4f7ebd0fee581fe8f32e243a7e7e7a1b8dd1dfecbc05607fb2e98aff51e05f4d12a6419486cb00cd2baa68629656c311ce2c60610fb993f4e587438530fd21a901e732e76079f11eeda3ddbcd3f816a469ec993424d7d0d184f1f3f80ba5908e0f443c9627b8f52a334874a8226dcdcfca00726140a09c738ffd4a66ab5ca16a8fcbacc8300ea384bcae015e136e57fe32d94f5219046a2a316558b694836a52c53f39a7b5f02fde8e980e997cdf25d4faa3397caa2e2460c9fcbbe6158792de905f5734aae382c7a95d269dc88b825766ff9a31e1ff8e71116b12be65169d22853222045bf28c2f3602374defcd12e0c364eeb9ce865557d6d13a52e581b3a5ebc0afd16fcdf80828e79806bc8eadb2a037967937f2b4ddd0b8e9cb720052af00b9efb6100657eeff85871b90cc345ca6098f1cb1ae701af490ce5b480c8bdb80ff3c953f44c102fd3330d1e39bbaf7417e23e9e5e1449c343251c131df37aa2f54a35e389c6c463626a8fb011a6a1503611b9f8d8ebbdf67c9a28a00bc554b2da17958ad5201c3693000902361873cededc77ee43173d536d16e7097a8bf1d9fb1428bcc00f74e0b87441a066cb20767886e9910fc717671d3ea75d6feecb68b510b255bf59f35aa82fcef313e9b5af3599ef8dcc9e0774e3a50fca870e1493108ccd658ba198a7ae583b6401b2f5cbb3203e692cde0c3c5ad78388bd8daf6ddd540f1eae947b1cc31c951c7319b65ee8df35408d73757bd27ac0179c6280d65854546c5ed9f1dd62801b0bd58dc3eb375fe54341dcdedca7311b175695f0c77826277b3c8e7724b9f537ee9bcb9999b64a3066e8d47ba98fb0feb592b3e2bb50dadaab43aa7a6da21cc347cd16efdcb3190982afe14a8e1d14c3b0615b933c1ab0574ef891a8906fa10dbfd0e39a31bb0726d5ece57ddf62686f8b2e7f11e67ca4b20995be546cb360035dc4ee7eed6e7825c5083d2c6c63efb8a07d4912ab2a42111081cd369982f4cb42c5991733b26972bffa3934ebaad75bc25109c4a0a262179d65ccc02121be9e90ce1e5f678ee3e96ac3f669acf459922bda35819e1e6c94db79c1bdb477970bf0ef23c23ef2cb60f048b3653217371c8a2d0ae98155c8a7b0a5256e806a136a1c19b1fb270723385f17a5e3e593e695be03b5e58bb325a25a875561858660477ed625199145fccaf7f83d9b2061f4bf6429d6f5b652e9c353ab0728f1269db849f76c6ba8f97a935ef1abe45cda90527a832f61ccaa8f9d396369987e151e43f300947223c32a333625eef1e61c58b0dce7cd390428b58affaba26bfbe046581e353d5bb80a6d2c3f9c4e98082d5a3fa23469d935d74b0595020be58fe368e6d518e3941e1f0419f96dfa841d3fba0d86ad8791de901e63c76d0195a1b39e02d7793af160302c21725d05c086066790c690aec7e9839c021940f2b0851e9df3bfd03329010aa10e6b35c8ecd22e9720ed7b59dd9e48b62ecada27bfae918f1433e8dbfef4039624301274779f902eadaca771390e96cb869c714d121adafcf89f44e4647fb6ab9a91f39728bad275aea397f20ba5139252c43786896ca746abcff9dc470ee9657abb037dd23d2d59252a23ba299cc122a7ba83c6917491840c00e203e130c70e10d44cfb7994ada6b58f087a2a4bc3838199599de7b1d1e669ff15f6ec3133051a00825b5680af7b0e487c1b44de00fe1cf3c7d90c51ad61e95049a85f6d7b8e987a46a6e6e4462eb4551f1f3efb93cdec36e972f79d9ccb3e54a4481eb3b6e4500cb4894c05ee3bf2e77ad859e13c70b78bd5cf6633772ff1a1f6599a979af7fe292ba7055625f8fe628f559ed50b8cc4e739814c58ecfb477754954dbf7faa79fecb1946ef8b0e9ec782a7130eb872eb0f8acdce03936b1bb9bea8081595d1c1474814eceb4f947ab07ff3d674402192b01420cf478bd14be6388a45e0f9c02c6000bb37a94c65ef7a76ef0d1b9164463368ed2c9e8ac1320835c78f83555d8f21a88b5dfdafe33f2fee26c8fd36d8a9dc9600b79964dd64f1addbc8ef1f243c7d79fdaa73f2759ab430068e2a8869c6de882b544e05d5cb9ef1675502c3425f59a94c37be40f40077d426d3ef4d53624b8e9927f887744f6475d8d8f1a754668b00d8c9ef141721bddedb38d92028315223f5f472ff4ba5f4d1b6a4f5c52dd75a011d624ba1964e44d71ba4ae06fb646acaf8c3a9f8c1ece9b886f6f1cf8cc3223590d62be0771deda6a3713ea0ce9632c5458dd3e318d28c98b89bdde66c9bfb3cc98dc707132dd6b060ab813913bcb1e064c1f963aa9361f0798ff933ae7bfb4c8a73a28eb50f1bfa51449dde701479726e87bd947d3e52c83d0b30f3f0dc6f46dc3ee11304478587a1168ed94db4c2ce0dec356846d9f05f9e7d95cad4b69737a61340bbcf35b7874ec30e03731b5a08701394fce615aabd998130411be59940b8e652d9185bd3ea7b4697e844d8f8a07166af2d34af1acec517a5f6af64601ec4ec3c86c787fce7b19e6b74d608ff8d4f49fa9a65e0d0d8e38023bf6f404d48d00f26832bc74125adc64d493301ee1c4d8310a5806462594e9f981954cd9117de18ca47ae9c4eff6911333935c4a711c37197efb11f5fbf04beb36c99bbf6801a027f5823fda04fc98078814f50ffcbcee6da76d1cd1134411ce28707981d259a311b9c07c4bbfcf3d1ab3af2e1e8394819d043f677632142de4777a55cbffa41aee16ad0d978708703b43cdd71e42cdc3f3a56c3577cba3709917bc15c5437982aab511b17274c51cad9157c8960ef66d986500c11076e23aa29cc93e65e7e7b9dee98b4bac7230a47b31fac82a5c897309a5cf9e63e8d39a2ee7cd55c19414a36d7c489aa2a9b8ab92388f6a74ca7bd9d568a01b895e814cf0a8a08dd071bb1f24820c3e7433890f74215b5eb96c145cd50c515ed064d8d0dea1261a78c3fd33b800274963ce01e01d314fee909856ffbc1221d1a37234db3417353a7a2edc34842e916da92022d7044ece2db54e01a4b66fdf9984f2941b0cfafabda564a10ec70ca049422e4340394767c28c43258cb65da2351db2090dbc4779fe8f5b7692b20a8868eafd6e5f1fb67667a98de6f8f3bb78f70530bbdaa4135ce5ae7905f51ef83b8faa5ed3a53397833d1fd48448b367bebd0b3b125faea7fa6b3c63581618fc6a45dce188d0aa4af9acbefce4151c2473085eb0cc8082408d291ce90fe13ccfb6d787c3ff0bfc9462113737ac0543384ce8988c50f5e8fed5bf1036cab267e2d0370d33cd628b236fd690913640a471bb66f9a0690142cf8f2f7dce4bc44bc0e18c348bbc1f168b89c82fc3ba07f68201d68aac9e22b29a4d76fa8388ecbd35ae5d2066ccf0de859c366fe187c42c3b18663ddb7abc0527bdd5a7f3d16ba419ed1789d5ce7192a0dad96075d0ca66b60c2e7d2a000e4184fb217cce4c4c15a295c6f6a47e3faed62c1f62c2ff8d617c7e79e13c764951a9dc8bdc1981edeb36b5229475cc9ef32934e6f9689b2291dc092e36dda459d497190cc42d7bebdd789b7094687cfd9c3abc4c56c9cec5acb2a350b90549f10d078c8e1e052f05b0121d10fa343ec37bebe3747a7726c19cf6065547fcc382ed79f2c15e5c3245e5086ce9fc61ee360d4a5acf9839bc8c6f35f9447213f52ef0898e96820effe3183ea62336a64d9b79c998032de14ce21858278dfe6a7d587e2608a3a0ed092266525622b863716fa355a2601ce45887df1e8f9047295ae77773b7452acbc2e1fd9267e65ce6215ecc7fcbf8ae3ed9ec7d95a0fceeed78f01f819c6f33b453bad2d64f1e1d82d8946a21a913707a2032b6533f34aee991d48730a75d7242298e7286cf70990cd81b27ba70bd5e29cbde6ba98e3f4d73db2bff55e816d89f05448197f34ae2997fedbb87ee072c73043cc066cbfa030b3dbc3a4b94b2e70b89576891f8a73b4ddc9668d132b9021d5f742d22156be6cbb47ccb0874f4a60bd27635bfd868f9d8076c4c2308325d002c68156b0ffe15d4b6d5d3e5bbeb176eb8b725b3b743a3841509a33fe32079aff0df65e7aa35ce1b4a776ae6a5882451edb0efe6d09dafff5c54c9f3a5f79b958708ce73666f179d4e982c1def7fe9cd460cb56a51dfa43cab0c50690071e3bedb0e9779c63468dcf5845dc32301bc213a265adae4b1db66f7706acfe79630a569123f369d9f94a0ec0b74dab762e90773077133c0415f6fb37ae984a0023fa34abae07c2b754a13cd2765bf22fccf5f0f4ee962d520553379afe89da597124e8b8d32674a9337488bb0acd5d08bdaa8c840c1629fb3b78d88a7edebd3685e796ffc6041eac71b39723fd5db7b2d4045d1a59ece95a794755dc9d1f84c6a39db82180c5f866353718f0522d3fbcc692f0c1181f9a664ca1a9f6c3987d2dbe8f389f7e0bf4b4c39a1600562774ce7100fec07704a1a66b97a2823a49ca7c16c2169f1b52674d5e080f233b146d499124240223e44f89d22d7a29bfff5121c803190ce6243a502a6d1d308f6d9bf62a68e169e980950f182c055cb2ecc409614e88cfbd0d2b7f230e9145564a8fe64f625ffa698c7c578095d463919d89c358feab090cb134578d35842328f5f10adecf84b84391909ac1c67cce1e685b9100fa86699015fe4eba00f88745a3f7855c737f2aa6eeb9a7ea127db3f18c33d09cebc4fa8267f65cb56be8e3cd4ef4b07605337abe32bea9e8adef0e0ee9a34981a4e65d687f0692802ae713818c42788a022563507b7dcc15937d662ff4624d76bbf7eeb76c992c9e63294d3da1e26e12e901552263c4c51ff12255622e99294222156de9a8f890f089dbc3b375cb2aa27b105ee6485546e593020fbf642cd3d5a29b8dbd5717c1ad01dc218d3d7c8ddc6e789eef00e8905207f11d657cc0c2e699823f50c56f4ddcb07009a9f8ae9560ab2ae6ed93552a948578deec7dee364ecd5436bf93d9c3660d5624d53046a01636177f04cf70cdcc1db699ee0e840688d8ecd31162575c93d3ddb02ccd0d0ef979c318ad0dcf708b25a78fcff70aebf3e161d7aef57f7eef434e00852407d51957bd6351228599c10cbdd65533ad61d6f9acfbeb61b4d0a0c3acb8b8e714754e5bc23c14ccb84a2906500bd8713de0acef40f70f59e7f4ba1ef5a21a1ab0c60f2850921fae80a724651c22fa72705a858be2c6dfc43a54bb515fa10fb36cccbf7af0621734eb7460493fb79b63c0a17a06ae73a5973658f2847129fb3da8898f4459d99f303cb64f528e0bb5ce05abee3b2bdc4e25bbd4c874d0afc114ac666c8033fb57042bb980538f749504c76599fb403212e7c6045a7c8e6b8b01d3c15a25c5e6c15e7feba254e0576404bcde70a281bb5df4b03c5368a6cdc10447053c0a3d407bba1a073dd1fe57442e5f3837ef9dc0311f7c2aca9aca4f44ded9d383e10ae959244f53a009bc2352488851a88e74b950a7da49d1e60c11ae133a451fa239dda34b84756b58c4a3cd052305882fb6b951cbaedb8c70d5f82b1223c3ec52f759b573855d697ac05786a454529b3342757e2a3a9d1f5591784490d93dd297e07c5cb6f7c682628909a252265630d0181f45dd4264f880f0877b25c7fd6eaaf59c262c4779061f5b7494b607b7b8dda234a5d09a21513fa207a3a47b98d945887ff38359dd3d1e0f894372cfc4949dc62ad3d05252213610d840f4fe70a53afbcebdbaa6458420cc14a38c37a57b74ce6fed017cce6aa6e0ef2862fd3de8c4f6e0371b2753c6d4555f9cd575245ead565f53470f89e5a4536d24e074302723853e8f5255628144af6e521fa0fd4bf7d2799b84a4f43d0db2778fb76985ca34621305bd153ae95ca2fd3518d4a5c85c3e8018c7a9b30d0d324c68d58a8d9bd5d87b3973c9a6042b8ba1c60514f944bf91b53a9c8cbe7ed4ee9968bc31a5092bdc131cbbd0032c439b610215e08523176ba599d6e0b8e3c3356c5f7cd04af2947ec039eb6ff06c5024ad228c43b42f544c2b15bd57a03977adb82e2dae8107d4db1c483cb4b3ba39c092e5fb7d8bd494f0cb2e54374edef683c202040f7e9329961280b6bea3ee873bb26effb50831a61ac48889fd551fb528739a4acc20852eeec5b40627ce82ca02cda77423a223a1864b3fea1df101dfbebe12efaf1b355e202443b90668fac060a373d226210a1b5ef1e1ae93951433d7034377dc0a40c237a520f60583ef85237b220be1d1373d2db51bebfb10e5b9073739fa4deb461d5218ccb9ea63dbab7b65e902333a48a3dc2b843f0e7a0ea077ce8696e369e5aa702d316dd6eb3fa0d232061c0182d316f9d5a3cbf299efaee51bee7116a305d5e3b97c94da28f35574921143603411844eb3be6a782b62657f26961100dff96bc71f037f12029c305bb7f3b9670a420dca656ddcd8eedfb3a52fe6ac7bf6218d60a49cc7f42b588b16e166d449fa06373f2f20382798752fbd6750b19ffd55f359990f2924c63f4010b3258f6757326d1a69f53605549be0007883c490c96e7da08da827edb4617f467544dc28dd144cc6fe83c02ee39b6d7d96a20e2f3a897e60fa43fe85e330dad0578e4d625a6b29d0ada69224cf194f559377f32875bba0bbff4e7188a3c6b01a1ef44dea31bae43d6ec447625ae185ce3f40c0bab95ecd229dbab1afe93c5d767159b1008ce864ab1e3f828afb2b5bb708dd3341276a65f1156309f2f647208c643453ee200285ec6c9bdeb36503851027f5884c0fc292ee00945b68bc3c9226b77d9d1a25f6480e1e1ef6a4c41bd96ed52cd9192a49e270687361542ca0f5db8601981c48490d8b926735a82895c3c92c5c2855cfb3ff25ec89cc5c194c17a6f87c16c5ab1725c115262c7cdb176c25962fe4e97e66c72d9d7d65c59a6ec434f2f4cdae3a8ecce50a6008a6016d4d21b191551561221bca8ad4d83b292419c5a90c22f06175adb5f462b59d81cdb56f9da97d03a790ff20b1d6e2e1397a3cce54310dc8da04b121a1b0b21f396af6f094c7d961670f180a28aa129dd987741f6b6eff2c60a412fce5b35bfa8f9a3f676bd0743e847aca9012efd1f7354c267746f66cfe0769ce4d1f4464dff975f948687cff5c96795c490e4cbe0c76987fd63de83e2ce876b4e87b3e824dc0b1764b6793efcbba33d8de838b3993dd556d63161712e1db75676647d7b6e9fa15889d3b922fe2fbb1201b09cebc88dce847a33a462d08a93fb117e2cfea66577eeeb795eb5ac1fbc8b888d14cbb69f7f7460803734449ef6e2604645090fe7f2ba0049dbd7ca9d5ed4e189dbdaf017956be3705e2fc32e493e31c600ba472af0a6af177a35233ae29123315b378d3da7195534060978b4d32b9b4b7be5149ae6f48b6155925eb73fca062c14f6d6dc5b5feb895628f2648024e77dc272a9378d6d2fb6cb2c0d854f394541393162fc5dc30d551989483d8f92bdbcd926ba3f38aae5c937b7ad044f6082281536878b408ce49d1b2eb8e17ee1735655aaa494e50331213a50a167685b1ebe12715d187382a325b4fe7151d08ffa6bb99928221bc02bc3d35202cd3c76c55f8f2c9d3cdd88b5c7ab1328adc8babd9a357981d62a07ab58e14f9fd51978126d33cf0d1aad2748661d144fcba0bf8bed40df1f5e6846463c95f6f87b5980d06c02f240f2429dde945af36889a122812d040a194b0a85d6fc1edb98daf1366e79745249fd857fd38460376beec299b4a21b3e944c0ec50acd3c2464fb5a080fb99dabdace7b4b2d97a62f3fed8161ece1382feb93e0fbd028d660d29df872693df992ddca8a710eb6eb9be2fd7796cd69f04920f612b41d694071c8ade39334fd05976090fff9a9f685b5efc08e03a152a23123f2f87ffee44d4d0096db5209e2531acb334e783823ab0884a75eb440480ba06cc3973d2c8498c92220612dc0ed39822c7096b46ef3fe18dab9b14241c01c6ef42cd7c55620a031921327f19dcd710c01491ae214511a4c859a954fce0063196cd43a1061bc6931150d0dcc96fa5b93285b730d157924d2d89fdcc4ab80b301cff6ac7bcbec937322b04a1c7ff4f3682670ecc7da4950044ee3ed0a6fa65f032f822db5439f3b681cb9924b6c7d0540b7cba837dd241580ebd17fe9869a47bac4f5e53b942216e2c8e4d72e3db10c25359c4d75b5bda860b3f9d8e46c4ed485ceb9089df7fde7529f9400f09fb4d53494e29e54b948a3790042fbf32a5ef1c1543f67d4998ad74cf471899db433b2f758ed9e143a8c4a5de668ed1da6b67b596bc03478c85a1451be6fdb32ca25e1b890d02b652b94e3d427ec82bdd5cd935364dad9df932a53b2d8d5f8c2e1fcba7588acb03c7951f84b4709da588288028b8046603614bf055a72478defc043e9929222383794ede80d8b89e3826eead86683e0e66032e0c603a4316118339d0d23808ce60e2406ece093d84eebb1f91b8c8b7bbf24f281f0a6d6f9b2973a528f7e1e448128117539c67ef70e47620afbc7defa3bae5435ea610476d1352532f6e6030c17cdef2a450b17993b3b305a27f6a73db12ed84d72c54d73b6d320a1f73282f3b271b6386c42bba838024d584679231ace99fa5a2fb697aacbca1b158e71f9102b9a62e38dbc6056c5ffba51dc1d1c5cab443545ef6b717c4f5696403341364c551903afccf14a02b0604e88972ada4a3abebd7869b0dd14c7ccfbc4d2a02945e76a2f66aac97d0c522e5186cfb9e25b2dbdf2942f3ac51d60bcc2ef160841fde99123ec7aa8b09361cd78cf6365d6aaaf1f70d8c926d404fe803788b42f55a6a7ff665cf589d7954790f350211e375dae93079e0b9449c4b0fced0a43aa9bdf1ad4df7cedca38a8cae569a6958b17cfbae837cd1ffd30a720d4cf8a04dc364fb28f796c22b7d0040cfe5f76c51d4e92bf04b0609e4557d94705790787833d62c50b6920c8e2d62a857f2c1ca69a0655074ae15424973cf5e9780b493a3cc949d5b5a0b7128a31b3572baa8c5b51feb16c7cdf32a78c122c15cb66d1b20c4f8989395a98062b35371566637f42a71561f4336c146d865843de7744d904cef66f44e82ef470b3f5060abfc9cc88c3cb8c7a59bac5c2ffa5ad9033ff154651524320e30bf0ef65446fe69ec6fd51fd4ba6356d4e9609d8c9138996672954540985f4f9ccebfc7ba936646146ed1e955638f44cfd5676262c549f0ff7da312ea6da757a4bc357d15c21b476c3e7e55f792c2e38a1076e77b06ee68624bc72e917960afa4973ae30c224582306a6db5032820496e9490270927cbc02e0fed73fbe570c9ec4d7e4ecf6f2350bb44a6e317c55c0b9a60c8fd48ea5b181ef05f131b6b9c737e6b43b632fa5e852d52e11867421d644c8aa88789fd298fe3cf2b1d898073783be09e3100cd6bf500922e02ec8e17be3eb9e1945b0320e8e898aa2508b9b0c5ebdd2a54a85fd342171a6d706ff5d6cb0881d74106e6f12e7c33d9929fdf91e0b8718684a7745a39f0f25d8cbdc61c024a2d7e34ab476fd1068744bc27910d7f018381e282da7654f065109a2d3e6f7cdf7019f39198b70b089520082af512a4babef73881a46668fda118631e9cda008fc9e34d25559b9a6c280d1e69357dd983a4bb044f293dd8011af8ad3667da7368260123d4e3f5518635f066c4e2edbdeb89d9da6f5c62b21f5dac42318d3e65d5c1a9c15da54ead4d0cc416b762717f3ea559eb745fc6f4ec354d28d6f6e364d1e8243e172947d3c325c132e5550b5cd4a5901d8d555cc3195a601b1a5407e053f23820a8cc9222594cab4dcf2da52a65367b334a11c5496a83da11c03cfc39837de994ea085de297319f2b2a5dcb82325c7a07aa0b2149f050f4f69e7a0d4de343cbbc55735b27a1b16e667d292738508e22f6be8105b9fba026680b107df357d536854125e110e14ed4355f8e8c873ab96a6093cb10827ddf676f16508859d0a62172a03c1730a54732449bf9640ffff7c4dfeeae00a0484a973fc5ccca5ac05819ccd96cfa4024d51bfc132c6d73576cc519c1668029df7155449bcd4fed1bff1696c721f421842c29fab21d5157378df10e5a7b75d5c93b0d7985b9e26d0c24a5a2652ab2a3b4bc2c46aca4f91d05af176fca102799ae04f32fd626305f8d6bd333580f7e13996c179ffda7b56913a0171c64c47bfb8bff874a27ae33f0580aecee1a6140758236d6f1d49708a9306e172d0a98b924d0f354936b714a9f52974b4989a56b8c759cb0b9f959ab43681d275dd5d9622f4606092cb753fb5ae59a561233090bad261051ed38c72f48fa6f0370a56db7bc8e346b710fd264690fed8ff966e81f0db978c77d89628d9f2d5e58d6ac84fe06724ac7105f4450c58a7980002b4e148f5a8c342f7a30ce9b8bcc5cc1c7b231c5695e7bd24b2978cb9605cd1f2dd35e774469bef7ea2a59b63af9fe2bec46a8a0ac3750944fa9e46758eb34ecf1eb60012e18900adfb024daf70f2000a3ae69b628412f6df71e691c06ccac2dde19e5a6e2bcd92d9a0f0083a8a1a2c3b9838c1fdf214c23f80d9d22caf24585126bec7b48d69d2af60862f05e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
