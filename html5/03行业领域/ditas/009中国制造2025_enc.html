<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0cdf9aaef0f5de0ec03c14f9ea212ff261e94dd3e1a36fcfa22c6e7db9e17f95453679b76a6a8b43f9bc9e6e60093867602293594968c2db5c5fde43b7b83d9b24c3f519ab481492e2e67e5c357ba85ad001efdbeaed8db4c53a1467d0ad8c14fde434acf0dbf2dac213bc8eba191d3828e4c67e413c7934b331517e36e09b58cd05eaf0bd6db22c169a23afdf95c4324296d1f5f50d777eb8790cde7cc05cbbe1f746feda616ac8b5404aa2fa04a34d7e3ad49f64bd13cc051d55fcdbc096cc8a7cd674ca9e143099f38935682f4e635f58431a23570355609738887466beb73a4e07b925b56a3bda21271659061c3e35469f3b4b6d1978e8ce58bd4c9157860e27f218edb679204d4add687ce9a0d6e2608d560255afb84193772f006a6e564ae9ceae945f6b0d1a0ff8dbfd90159e12783c634a973ab404090fd84db5d75a4c301c8508bc7adc2a04143b11137e6453fd64da7a44443d0af6ab55446d408edf4287059f1c1be8c7d14e7b623aef884d57288892d704dc0ee120ccbdcb14170944d7aaaa010324958e02f7550b9b1db8e328ab996b2b48e809843fe2604b632d335441b8c1724555ee557f29183ba8107f616bd668c206406f241a9d92dad82760b97d64dbd969fb7e75b587c4338155c1041d4f2a245a4f6112916e4cffbf3ced93bcfdb6be53a146ffd08b03fa520ce9399d47cf152d925df11a4cfeb36a76433188da1f98e9e39c5ae7021b27584648a9ca50605e00e733cea481517e6ce770b0dff6574c95408c97d7362407abb191665598c83ebf5643aedaced0d604837bd8daa52bc31df8f7c08669681a8db5563b07e6224e0f457cb51085a33f93b40783e3e5983c6cdf3f28a30f11e36bf6f18b10dbab559b4f04099611b0e7ef963a017690fe431bb7c5415d2b52fed12d386d827fd57031691703230dce78262d569ca631333369a7660e2ba6500279afaea0e5e895888a72957ea9bfb45cd20caa3f1e7048070d25031a65d78affa5931a5e2f6eb32538b6d4e8422973646fc623360e12d66342d4f05af0b1684c6f464db3fa49dedefb6b1da4915c9694f29d3072bfd09430072675bd637d43ee98ee99768d607bc330d061a7058ed7b46fc117cf69a7b4ef129e0dc7bbba484355715b2526d74fc72131cff1c1f02788982f34ca6c3e2d9e43e6cc3fad1fe0c6aa0178f0b65c104c3ee7163fa0197c6139e2c3dbb12b724b6317814d3b4df7cb6c91af85d339fc577ceb398add4a9b474ae99c118d1b8e2f775677b968a8503d7b31390132301fcdbf796bb0f96906fe4873008ff42c3c255d56a544bc4d5abb104d7c32d69c4e20479ec99b1f8688320fb5615cd2ee987e101114816925b105ff1c17f13c1b30889771a76fe586f907fe1762aeee11ed6b622d2d76a21feb5f141c2f5fe341d211ea9d383b7c32701939db1c8079d49ae529598bd1f68dfb40547359bc2bb962fd37804e89aa514f76fe7873a9295d35d6dea9d8727daff39812e2ea493006230dc70ce6de36e0ed959eda29bf418fc6cc6afc994483f61eaad5a07d4341453ee74445e8a86e1d6cefdf855548d98036b4bb2573dd461705dc544a85673fafba5b7b585e2476b6f641ab5859aac30c9827c9661a654ed9d7c344fe18396d51104657e119f9f4afed35a2657ccefd8129ea18d4a2becae48499f846bc97ee01c0256a43e0dd622a61c16f19ba07167fda08bdaa8f9b034da691d1101f889e78d3931f53d0a680cb27c78463f69246d306257b30aee8294efef1d5c1e2cea69458b08847d75dff06e7466b87ed199c36181ec290039b1f21a63d73d3fec719aa391d1d99df3d5eb6321d9a66c7961f0cff1209b4b7cf214c0fc6f07e7af854a65ed8b2118f68e95d66f6c451549e7b6fe1f094e0ad09b40afb7fdcd118d4ee458229a6f69ac74bfd06323b16ce43160d5ee2b25915bee9bb7941de824bb848469774a40374f99b75c69b99465ab656a60c4df3dc8c4940612fe1360d6eaaeb0522496712471b08c712560123fd614468690fd810405b4c9c5de4cd0febcd76369f097cb20006fd239fc7addbc11b39f6cdc2f6472690b1d71e6bf1e0d4aa7430bf3a1cd6f079777e94f4f79b3d97d072047141dc4d1cf245c9d7a14bc53f0bc1b08741b763a66253fbd595d0d4b6a6404f73cc1db63f32b32561ab7fea230d6567f52ec23987c4b6046dd1239677ab97f99604107d6735efdc2f100c250878385e0a953508fa5cc9b2064d0dd8579e0ff177fd5fd75492669fee1615ff09cfdbb80498b92a044d795fe5217ca068e8696cb3456979d967ecfb42c605cde0cd374bc97bd6cdda3f54c69d0c5347a7bea69ea107599453c7303a1e782e862eead3ad202f73f9cb811a6ddf12552dc5a4d6a471d0438546b21a342849ec65c785aa1663f08f3acb23669cbba98c70962db6bd681480d8867be98fb9cbfe527d509a5ff7ef0aa1959b0d6635d750222c9c6704a2e4c647790a4e1d4062b2f20dfe3dc393872aa4c3465b29771ef8fba85ba1ad0d67c1c6f1ff97f913ee43a93acf5afd9c3a73c13557466de69a78d954cf5a7f4a6d9236e93debb6b77086eb283e3cb1f5a82989ad474a826032fb1c48a10db0bc73ae3e8aa212f51163a1104b762fcf5e004b189cba2a1af3ca3c4191d5530e167ea0e29fc386db4e03ebf941aaf0c361272ad7c2e2dc919f8bc96e2f34390d7ed0f79c2f54ac8f90c94b67fff739d3470553f81090e0e5898d681ef9eac9d01be925c15a3f4029e9caae9a12794fa5678305c3db9fa0c5b447e2a16f478d3691867a79c0c64bbb72a70f79b3fe2a3605f9f791729fe4c0a44cbfcc7a8423d4a994853ff9b5f11b014738607e8f2b93179a012a6480fd0b5a8b830a342f1ffabe3acc16df31802270db0905c5ac01839bed7e203b689fff17703fec595f0571aeea1d49f05c9e655c6aa9d2b4df659089140f7c03612dd7c384298bc8244e3ea6292fd512034cf4f50cd0e8f681e76d349b628eb9d3f11326da20b8e6056508d2191794632a06ef47da22c3901f4f8a8fe9a1627538007a631ecf3a3877f48894e19c73cf84cda6999a17170212c3c15be9fb12914b90f51dd029f6a28c6fc6bc6555952f7e68c4ade04c6bb0f2b14c7fecd85881f0929f13909aadc71dd73912fbc1af47601c78aff96bfade80ecb9033be106c4da533ce7a965748e9201280b8b02f82c1fbdc102416a107d4fef3f74b4861f5a121e65076b38130c0312dae0e9ecad9e4997d06e89ff630b3eca3676a43c8f66f444598c8e1ea48be7ad95a1922650a5ce435c8118acefd61c58d7237415b6441c947f954daa32fb8d82ad340a76dcbf03e722f82fe09f3fb0ff910a6e5b46c4527b76c063085da0152a7c11d53e9bf15d34e5c2e32e033886c9dfc620625940fde6c5da19781ce03f76f78be133de9822caae127e10e18d0a06195ed2d3f13d883390f108828329ef57666bcf6a0a9c2127ceb6ed3f2923a412e7d1567d58feb5a554566005863052a9f4e0d47c66bda1009f908b68b8ca61a405371f4ee6d7b442c582e7da423045d52ab9289c767b00fd5c0b857af04c828563fc0b4e97b42249cb6636736fd5dc9776fae13b2081f3d66af9eb555f570034ce2fba30c94cc1d6afb73eb4c36ff90bbe25e8e556262145316a43790ae6220e571d66280a1f1e5149ef744f19f40c1ee83cc51fc4a9bf9fe3a12c22c48a224561fa5963f9f9c93d5a69d4076115b33709334b7598bd2f0b301fef2eaa4f0d94f9ff2144a49217b2d8a6b80cefac45f82fb2854328f1fac095f7e54a774dfb9cd5a090fba391e187d21f38fb0bfa50c2dd3278d51dbd3962c04696967a462c58e3c3ef6e7a9cabf311e28aace713defc7c3e9d0301f4ba43d8eb7cc990942f7196e29a16e5d2e3d75c93699a9b094f69acbf99410be46f9a5df0146886fa27e08a6331046de7bff2e04b2ebef51c7b976c52ada6189919bdb75492ea12d1cb0b84a2b06fa68b8ed756c9b8e2eddd40e6687280c918b644e2c6ba0ac382457696bc4479ad167d64ac1261b64a84937ae27bc833b25ba932c8ece29b56880446bd4fdd9b97dc57122b5225d60efa5542441908de76f225e3f75f0e784c761a9070b16c766a7695768adebf4a0129e8ae5ccd25f828b128c860f1bc9443845fea90a49a3884d82dc6b6a3d6d1af291fa0e2d8c537eafbeb969d9686b435eedf5a22b47a50d37a40d3323c41f813d98478187c8dcb7560f717813aca4d45e3b8a82d70cad627b24fc04504f2b1c44d98a046fab1d76c687b1d6d0adefb0ec9d50b6a700c6da96736ed88a1eeae9ca5fa3556574031efb717389004e3d4709f1f1b73db900a4a92b23da388ff109e0d1cf18ff3f565670ece57ac9a40c6543161c1c5f56c925c773342063af8922690dacaa336613af209a27afdac2f43ee29292ddecd9e6826711b9cd39f5fe738d6298b6d6d4633351f140659f7b177f81ec01cdaa1a1a447aa04c3c3237cb7bdc1b8ef8fa0ea44879f9b812e949a2a509a6e649653f4a6d5029505f60e713f034264943d43ff30f4305c89031c3021721e5ca3378dfaf7620dc7ddc30a1ebb727accfd4d4b352880424160650b95cdffbe7a8de816c199dbd81c87d64151719089f187895fb83b12ef00dd9ced7e008a254650ee62023eaa304872ff191c094d4d5b7a8db111047dace2fd9ef073cac8bf7aba785297bc3832b184b1e5ba4ce0108f232bfa6f1529426cb75a34f2dbdb289674f1563132b71a6f95c3d35c3ad194a16d84ed693a721808f9c93159afcbd6f860464818b7a86dc6c5bde82b08952743320ec744c376b2eea06fdf9ecb235489f9159dd5572f2b1dd73276fef2b6c8052be3357ade891933336afc21022e313fb6639945cf9d44e3706a669e4cea946e652738e64f1b94809fa427075f28ce22a60ad1398f93b7f213ab5da0f3bf1cacbe6e61ba41fb0ebc4e7f6e8dfc9d655d10968735a0d33b3b9e1e563fe464f81c7d5a55083db9ae3a0e610980cb06f87c7eb0617a98c2c9e5bff5b014876a913f168db865b338bc9d5ffe232f938d7f7bc3935684a2fda5ca59c3b6d0c1bb3fffc69b3837e38757ae8f0b34caa17eb069acfc43e11382d5f9f4afb5b32e3e74eb85207b3726c6183afd8578c71c894defa6df3ecada146c349359cffcddd8ed82901c819f392cde939a5274aa5d4088a18fcc27cba15d79477e6a1c12f903a38e089762694ca9978059d5205e29cdafe3d39ff2ca90e0ae1dfb5eb1ccad4920ec23d2d8a9a2e83c1bb896cc36616bd5db5dc43fc77c50afa1ccdb9d88ed1f46b786815214503972c4045ab626a871a74771172d7a05679963f4cb482f9f00fed29a12c5235d31b67608904abb47a48ca639cae2e6d31bc89adffe25c0e1de3e91c26768237aee1c566206424b5ec182ff583581cc30eabfb1cd37bdeff59d58ce6dc376e578c26f745f31a6e54a3d0b00f6389f90a9039c6a0b8e2afc9d902007c485d930e63051fc11630cd876a8bf8197cfa16d7b27d533a9c470e6ae8a4261eb4beef9984f322165403484c1d9f7495d882d8bb6a6ac9176d1d1a27030711e89c677a2a0ac527bacd5b25a79829cfcb8256b9cf947f7d68c1625f8264bcbcf17689d18ccac105d1a4633bcbb5cec0880e6e1dcb51c139d2ba622521632855a4e713d3414b03bab4b37d699f164406f0d104cd3e7a339738e8b8f63ad08d708259135954ad8b465a813f9df33f58fe348b20d3131fa90c44e18c4b1bb7199c25d51b24e799219ba2ed67bd631ca4a4a96f7fa8ad4eafcb3aa3c5982c7ed13f4ec9f23dbdfde8b9fb2786edfcd613d9b88302e7f14c077ad8d6ae369bd64a682c9abfac40ff154e6224e4c5eb8bd47ef681b6c796bfe9098f0c086ff70a0eb436cbac7f84e414379f7b5263b4efe21afa4091c354e78b251e6e4357dbd5cfa58353fa557a3240d70599e6774b98aeaa88f0487c67b75366a0dfc9abcafbee3b6b0972eed50b6299619e0fe94756476fc3ad709b4c765471b40baa0347b5080fb1139104fdd8f48df4777cc3d119fd331572039890dc2f0dc2249c2daa8924391b2d7137fb4224b63cbe650fe8a57e6db62226825b168db758ed33ee3eb9f33b1f4401bb233cbc7ffc42fb3ac9c6cc2cf33ea86c64974fc51a447c5eaafe3bbb636101a5568f63598d7434db31cb14b70722d5f42ce5213dcddb8b3e2790b6674ae491b782bf90f23a021bb34cc9b2ad0a54262cb64582dbec6b821880fa0d5c68c237bdedde9756a285915099d3e2f1cef18905149ad77c8897b0012edaf3d016eac5b468371b6e70de8d428ea1509c7a70324d2f95856e40195299164c89b072f985b39c45e4e93e505a761976563dd74f1523b1ba3c2137a17867bdcdfb741e1cf00995fe9d004e70b85162049ac93c8e7996ac579e16e049fb128729eb8e51cd11aed05923a0759e1408ab17c7919ac29bd323654b0344ae69bc77e03c67e8a405e44ca967a34f515a5b540484eb5c79a5ef98a7d6843410a9114f775e9d1c747487204084b7b47001d3dd3cf5add2ac58fe5eb4b401765916c3e050a4cb05b3efa295e519d93d4378bef84e31b3c1790e9bc7c5956f9a7544ed7d00e1f24c683df1a95e555948d448bc93d2a9d274f58029e3acae9606d4ed777f309e9c564d246f6c0a6dfad509ee7c7bd86cc712100918266e52674f7f7c01fdb71797ee0326f014c804ad12897f1dc3a1ebdb56fbf5487a5f23bff3ba858dbe0c8848303e8d48d2ff65cd32d2ac92c20b18e06f984a07549a79d59fb424c3aca4bde35fa10c9d6b6e62fa974465ac997e70b8f8d56f245a18d1fae175a3c0f489876b97aeb09bda9377c9836ddd7221ee2911a15d383a4d0c0cf01cff68d3b12c21f649b95e1cea3d5bf826e1f62882ff9fa416a8aab28fb106b666bdf7f2f51f172707d57a99f526a782928d219a41b2d4fa70e6459ac6a0d87bc56e077bef991a2a27bed27cd69fd117aaf84f742157e0a8bc66d3ced696cd2541f2f7a4a15049f55d8d5f71afaee42b7d54056a2e88ffcb694c5e00ebde836839511e56922744ba385a69470bc5376977ac766fe76c8127e35bc6d94956f0f7963826dc07d6a05cf9f1313c14b2b8bb54d69c2b5760c8f85f17b16aa8cb567876a275acb7962e328cd36573f4548b99ab66802509bfc6c92ae87daec8760f15daed955133a7396fbeab7693b5f0c991881f89eb3593a82e38dc405decd551d80a95b131eedee7fc8589be1e7f0a693a2dda469c3f18042b5a220d4267507a15797b8bb3c1af12552d26e672cac1d53be30cc8d0e58e984c89e4f22cff712855222e537a7ec1b312ad52d4f886cef60b10ba05babf7b84aa8ffca2a71b3bcf3233bd1595c5e5e1775098279a842b8dc6db65e4554b28fbe96ea743f574281c1c1e6e059b429c67d956e374bbfb4f53fdb6842f155fcbf914b0330d9071cdbfedf69d939e592ba62e00c5b9c64ebf86c95577e7f8a00c8d2a41f2b1192320eaf1377cb1fa9e65d340095738f42689fa1850054ff12d3151160b3fd1eb2e6fa98dbf374b4b66e30784a25c20e657b5016409eb83f164d9da275bbc901d65ec033ab6cda90d57c01b53267a44e24ee325896caac4d568f46bda3c52d22f8cd1b4adf0a6d031e4d4e192ccbb926a43bd92c0914af513089497355b53f4009e1fda9605b629aacd13eca85e18b9669f35036e289039bd4c77f15c39593f0e2d899c86efd2450822791939eac38c9398ee8dab567a416c6aad7ac82bbe3816fc094b0922831c8c269f0ed8c5ffa0a11e6dfe2c9c201fb25ec0459905663da50d348fcd4cfcd07dc95f6221a6702d718ca719a550471e53e5419cd061a9935e0cf93d2c8e6fa1582bb1b23d89a29050f9fbbcd22387fd2cdf85aa8f436312669ff9644c3c0111030b55a64c99d65e6b7ff37d0d9fe71c4ef1e533207ddc02b1fb1786c3e939d0c06d792b5a05c3f4e2e4418928bb757e5b663ce5fed14e46c38107a00ce28ab7f82b5c067ba377d66edbcc4f74339cae3750cfae97cf53a717301ed5b7138e577390742934ecb196002646cda1033a8eac1a47490df47b5b46462ad409258a734b08a17b03a6b70fdfc347f539cb6effacb82f3dbb8bc3761cc72c7ab2f5d190055b51af81895df1c71dfc931cb22bbcd90d7091d5592f1b3f9346688414178fb4a1c6dea4387f88599143928202cfedff5721e137f636cec388e90c048eb0ca1564688c855a38e68b43c0195fc9c4d652abc5e8cb871c1ff48517f12b6f51e871e210eea26208b01d66eb81bab146a36abd3e1ee763be24525abcf592a09f633964b87cbbb4dfcc68ffaebac077935d44a9e072bbe3ca5b2498da3e311983625b7afca3e7342a186a203a8a3dd243f9b720494e5a6b3923abd8e6302c09a86920a550e148f941f784724c3c01ac220d50b9e324d2470ce717a5022455a8b8677e5871a995c8305b79dd6a9bf0980bef7a3e69cc33138e51991257771a125248e1a0f677839f8d58a7fd46b792bbe8644842aeadca5705ed034b8858d0b3e0b89381bc65eee3334e397e307b0dc52763edf8b0a8e527718d58978c769ab6fee6ed43dba8d8c473c727c352217650c8a038a74b833f8c9c4465701b469140fc76b310842d26f3e3d7a3bb094f6eec58d9cf068655a9c9856f1ab4750a14b2897a9731baded8a288587e0ebb36a4d93d85df02f143fb1de4f70a8379253f9b50ac2afcc3cdbfd506fdf8780dd88ba7890c18b3db8248cb517a006a6a7c506b0259ddcf833bdf20ab589fd51fa0c282b0e935c35144a1153868fd2dbfc2edccd38a040928d7a6d1384c287e7a9ac8cd73f9e4b182aae961688df2f039bc7594f7f3188904e1e14726c74cf679aeab8c1cfb38fea79318cb132126dfee4f36817d3065b12737e02feac7d317122467d76bc1bfe16d752c493a6d525bcce4b2f910e60515685db26630d95efb8693208ab78c401acf9b2aaba4fb1e12832df06e0bd7ad1004b9fa9e2b93fa3fe424b2c16cfee9daeef97ee93347617eb304be36acd6dd15d98bc4be68424b09881dd7a6d3607adb99b33d15b1ce6e39d389d2b7e380ee92ba5c607b6b638298a1e0a75c7c6b857b482dc682bd2c07058315d1aea9c3a32286dbf4094bb1b206d2491ca79f9cee2b02c03120e8e5900ccd8708d693b90a5aecc41bf4da7339e20c58794997b77d135ae069b55c95cce81bdad86255cefc8c6e00c594950e27cba123ddfcdb51db5501b4795cced3b35b7d55553bde0bb24edbac558de12c9ee42f4c18b7a92ca269ff546f057cc8a59763941c05e1e328821bbb67bbfe24ec4aa4c2bbfb655932096d305725a33c42efda5c009e5a5a9f7da3e2d910d30da19f540d6856e100a42a3d7b595dd7af35b8b6abf8dd483c53895af10722a1887fb31e25eb50c3b61cc2cece27d5918a2550d1dc91aeb6e68d6d0a4bad9a319a9f752fcce64e45b54a2c41e4d71eaaead39f60ca74f6766b49028e1d56f22ca64c360c21ace8db5f66816e09c6fa1ae22cc135abb68d9263b3ed7a3dd72b254543c1e759f2cf5137f5396843d634c51f4e0084a5464b669041979a5f78a6d2a9f33d778bdb1335ea61b487fd57dcd89042aaf71bb63a5071246b2c3ac8c066046a8b227d27c6f45da93b2030fd9c4a2e324ead6554901afc1e764794d9b90eb9acb5775026d5be92d25b662099cecc7281d0c9ab0677a99c97bcd35dbc2524249b4ee70e4265399c8173c2eb65232bacccfac6cf4a93a09e4da6fa7ca67277a91f5075c44a8cb9ba1a7b3bd7a78e5beb86dd6d874c6fd0da275fa251efb6180c319deda4c03347aa420982e33bda352b539bccecc772d1978840ab28fc620414f58b8da530bbf62374e4ad8e9cfc69f35dc9932e2702210e6c53ccaa9db282098ebce051da79a71668d2237b04b549136e9f5940dd75fc737364dd4e5177a52ae527f89a51b4da5face92d9df2f4383dab7eeadfedde1cc516594dd84b003c006c83d0dd439b09ad2601637ea7a091c1dc556ee7134b92511ee15ed16197a5b40e8190a6b5886853a7359cc50717362faea300fa33737483355c14a9b69b49bb2ff9f237c396ab937d2c1c578223535e55701c014e732eb62272104cf9dd2458c32e5c95effce693e088c808eed0cce31b2aa68806e7410a00fe317e1278384e41d17ed92f180afb2ebf4a3e9760b5b1189ff3c87f452949ae4c11be1acf6f1b925efe922ea8512f9dd88f46d61106fe4e1f79c592b05a34ffe12aba09c2126650e639e994e04f50b2b62f64ccee5965dfb400031fd3169cabe41b093fd7e5f5f204a68478fb28b1963a835f08c19c64a9d3814b8b680f93137142e5b5e4c30629a80cd4e3da0be1bfe47dadf24b1990ef27154347453b26448fa8a600bfb44ce85ba8c3ea326d51b15bbd0d098ce9320c702c21b0a47f55aa90a9c83f3f6a2385d3e7cd6e56aaaef0814eb262df58d77a7ed9220aea33c5c73e3d6be0f333a36ef66c306915929ff15fecae412e3a2393ecc3f387008c752a5262faf37cf3aeab5c9998400dbc0e6e009c3f02298622443e84cb47d73928c7b97c83e683b479b0c256dc2f2142c6f51b0b8e08320c033571bc40af5c46b86875714eb091e1af2f09dcfe14ea71180abc0dbc673a02b0770c7ce5e6e367d41f741d412b12b68251b0048c498966988651e00aa9eb3ec08e1a1ddfe9bd43479a118901ef7acc6548b5e595641fccfd547c9e0e16724b377b4683eca90d6863cad8fcf12d043dcab17111aa8f4203d664d4da19c6145b9ea5798c67b2c2c3a3d2961797178bb67625a90459d6c45368ca586bddb6c556c0f4c4c9a7276e229653d04d1e9f26ba3f38a9ca2926274ed79ff1e4c1437ded16d114ebf77b69a00f5e4844da2b7847ff396fd1e24ab1eb4298750bb11990d30df593cf33a4557cf0e59f4359d7ab01c70d78dbc7130d24a4267e1257d2758d5c0a1eb20137a7911c37467bbfbfe5e503e42cfbc822a5c0746dca8e4304a1bc93c7e4c61ab97dfe97e96c81a5b072e8b2a055f52210435f90c501df8fdbf97bde78920cebda48d84248e28115378eaeb34aefc114b2da6de1b08e7540e9773a5470f063eacf160a27e04108146e3c990f490a44398694f59ad3691789e01bedc0f3737e419cff6edf93a8b39323de8939fed4898e7300d8fa5804b4410b5f1a80e7a5ed30f0f88728cc16c1ae2ac40173a0741afa55b2ef05cea367d8ed2b4c8932b18349fb9dcd2afdd20ab6f4c7c875e5eb71ab19bee4d2f5158a2030841e232b134bca1ca2f83e6c1661ad9ec8cc1f4c59cccd4fc40359442cfb7d1592267a08a45a0cd384d0bd79306a13df8d2c3e19dca08345ea3092e5e3312731ed50b90cabf8d0bab6b7647a40d2e98d81c2da699ac8d39320402b609da0a04ad72db01ea4ac30358271a6704fed098e99fbf7c6384472328facf6a5ae55b40039ad43fc338db220e1c9ee0a7bc40ba3172dfa6f4e86578d75c0e2f1e8f26caaec0116b9b421d99763c9aef02643b246379948ae4ed09a89f260639cfc342f5cead31bb6a3bfca5c001d9c70924a4fe089cdf19f1d7e4bac03bd5444c1b1d01d97b7a814b88f41545d61fa0d9564e785a550fed7a75670481ce7ca8d516bc13999b7f7b2aadfeda2496672207380e891220514fccadadbe471bc6bc07adf275935a9467132b1b581b8f18ceea75fa4044315f593c3a8ebbba27e237caec9471d7bd1fe12dea7eb5dcc9e9b1e078374d96c19d5eb42e28c2b5632571ef24fc083f2ec78912f3afaaca1ef3f029e6518869e0876be2b4744fac1cfaaa20a2c4b4a6977bcf16e02fe5e183d5d67bf33fe50641456e3bde33ba234d8d18abe0f64a6b033353911bc14dd908cfa62c6332ab2071918e9e80a54b6cbffc79a192f2505fddc64ed0cce71831356e4f4b208369f31ba12cc6606848482dfc3fe044cf578c2f5660641880950cd95245a69b9fe918149f378217cbb86367eb7ab64df0996132860806ddb568eecf4e2423ecf3e0f86ff8e54145cd508ee3cccff27d010b6b391b75215f3cd2a7d2f5590b9895e0d29ed1f8a53e65aa97de063b4bbf56863d8d0703f9ff1bdb2b62e76bfa544efbf8dfa315deddfd4e3dbd2894ee4209e983baf83eafec5d81f3efd22187e1c517402be7fe7b3fa9fb58568ffc8fb993c78170936304e7d5d33e2b8f5c514ab9a0d8aacaca06c17158731f088f163658c9c07d3b7d4075c6a7368e0506f6eae918e2092196a414ff046aacafd1214771677850d0469735177148719eb416115f1eb738984e4fc823526514423c7130699a16963b2aa7edaacf6df7081141caa9ec4855b7cf908a27aded28ccc6f66c2f6f89aee965ded50624b67e7f9e6ddd35db87de5909e3dbc421e25a2b0800aba448b929359e321b8df49d9f41aa8b1aedf4e8061d46c09c958894ad905f92415fa4077624098d6365861416f2fcbb9f66800a684987aa7e1ffee86c1c005cc28afc51d6696bad69b8e4c9229aa427a051d619b9573f1e75060b269df964d606b355b86ec45350cda3774be1875951544b124070eb6eb363759fbe49b91e6954c13b983d7a0003cdd5f2b5a4b86c28f7ab143c58c47ea5b44a9e15d2a78669ec2361033ac0cefcc511accc1a2421d11ff848bc7dcb1a654adfc16d4e5504d91a33c020dcf7cd0925bcdd999ec651ac55e2b7d46b92b2f4315768798d4244bc293fea3ceefaf02fe046a70791592fa836e5dd79a940655a5166b1550942cd37a76c30ef2591b3a887129fa3af08b55cbea0d5efc3f0479c94dfb396af53a463df3646adaab4e0bca73a116c330b672065efd8e0e6bce924e14a48301e9e3bc7aafd1a983cc00996691a39721928f6730b55e97228085d4d0a564a61d2ff720d5f6723c103e5a639d5843525def55559eee67b8f349d5ed796b3e5bd653fa390276600d37383416b72ee46f869669dfe935045b1bf28b2f64e0f40a07eb83b7e0bdc6cb6d8cb74d72d2025d5cc89141f43eb71fc134d347f55cf9cf829212a1f47253e725746bc66a12fbf7d205e598d66a96494e17385c904202859fb7a8c99b96702d823f2230951d8a98de686a5316036cd73dd035376139b46601e041e66fb37e2fc5a44652b0ed91a55a787a63e52441122b7ba01fbc0cb807d3cfc198db2620b50ecca7a348d92591722379db9e167a7fecc491b1ee152b617c55d812f1413091ce2242bcce33d32bedc82d535db582ddbc2e6acc4204639eb863dd23382b7d965bf25151022a406be24df88a7c5e741adfb65fccf9ef9c850b534c3bde5b86c15e47ee27690b176227c68b4c7204786c0cd90bb21f9b71dc34fb07664628bb22585bae433e47eaee0ee2c81804fa5087b1ac2269d08dd2ee8c2665ffba7c19e34471011522a82cdbcb83d94144105822c995743836ea137f9c8c9e5d6dcc41baf3356e68bba53141b2bb5d334e8b2c0427052f65b68d115a837917a2ca74724e0ef8281e81db1799567e8bb354ba1effe817bf0e1e316c85c91a42c58e7a5873f2150c5cda1ac7ee5df32ff1793d48d38b864032b0586574c013a1fe913117b88fa650daeac77357a864a401609ac3925cb6b1287cf74d85909194aec66ac6ff9b9bb94418e5f42ea21d779a670511e3fd26cdb48d516df10fcc7b06e3667577575c54981a12bc0e1d7b7762d9a79e3b31f504b574a530e23862f2449c33ae694ccfa09dfaa14dbca9a6811c31115d56bc70b0079e72af886a4b874afa3aca2a65e67b6e642b783488d8b4e79e400f97765799e9ca3f19a9156b5748da95fc271e86cdedba198fdad23418c76910a4a5f64e4f1754113c465ee028f3d2dd9e09a469160815987343727979fe25cf4605fc087f2eb0763325428c295740e0bc05de9d6541b1e11ac953af6472c438857e9fcc546faa779a3e9418a8ad212cb4a628f6e140a22f45ef15678d21668b5cc88385dcdca2c18c9439f4173d901bd92123ea82d80e223647b0c062caffb7dc1592c9bd8ef31abb8f5fc73f39622f6a17253de5363451de65e8f49ec5278797895db74ca4ac63a4e263b48880a7ce3078a671c1f77783da8babc8a347ce8771f4867d6fae15a0746770b9de2e539a9bc5ff9592ccc0d5159f279154874a1bce13483b0b6942c65e8c6449517818277f0963f301728be0e23c7c30ef507f624f1dd77d5f8ce10118211f17a6d527d66949e94e834a41b15c4588852a845cf5e5d90799e4ac6cfe90f88c03321ee100924149a217803811cb5415371a4dad5354863d9c4fe780c466846301f72759ed102273cd4cd5e01dc9b2f7dc2326593ca4c2bf03fd2e5f7ddb4443785e05afc46cadece90bcf6e3da09b07094559e57c2ee4e0755b3baba7b18374baa4b13a0642530fb0931e5c8d6d4c6e38b188e883239d9b2862f9970344592062293e4342c66344ee4857ebadfb97e78048fc69de97c8c62e07bbe1fa708120efc17a9911436480e8b19fb530eec59562c2f63ca6822c466b4bafe853e00ace269e474aad9ec022df59764f83618e9efb02a1b04ba0228dbec9d6c996967f03db49076e0579005d3711c2c844ab6b9d12b0a703465db173fdda07f653fb84876f8abb1b2b36a95e27db7ddc3f3f958c1cb536795c9aaadf15f9b2250c45475e8ec72d2225f04f79d9f7eedfd3a5e145d352a0b2dabe7d9a53d766e280fb09648d37fd94c0fea8c4ebed33f5fedbddc4f2689538ec0fbee2d8ee53a505db06b90eaa029dee1e8e4c6bf9938a79973f1be97dc417b436d20b25cc88aaf26c7356a1c063d226025277b3b7d742ce1d53d4074230e4333df008e7b5073c9165db49da3f694cb0367976062470b10443d62c889afa720e407721f8a3d6f1b91d761a147b3676f8ecc0375555be290655ff05e5b0bd5f8f45dc824b386cd7cbb8142edc5690659a13c4f7d1e2092c09307115f3871c5a50b281d34be9fbaf0ca8504ea72b65be52de8fd039117893dd2d75fd993778f56b2f2ee801cad1b4c47dd17c0551eaa8eacf331ebb70376f7bebd1b5664295e127dfc01f232a20ecc6d88f8e812757f7c03263a018649b949c646345b419915a52a2b225515da848b28db96ca3ffd25616c6716b109550f3d6044c20c66811aa8302e0eed2f6ac486804bf9a06b58b443a79acda4cee13617f2a62051b83c1b8c33dca786dc321d850cb2ee40c76c956541ade9dd40d5f3256be5b81f269f1136aca41d4a836362ae1584ae2482443db6599a26186e04669ec96fcfccf1f206488f4757a964b3ec2db71147771d417b0a2969d9f80453a9245b4a5b937eaf21d0475cc4f627b2d00b3ed2c7f61bf94a974687baf91e657e6a8b7afbd6d04e4a0ce03e1df3b231f7fb4ef8aaa71999f25eae6caba4247a7a45edc1c646a5cf332844ac9c313ec1d5ee24f1991cfe2fa8467c19b83b010cfe378591b2abb48ff204f2a3e47fac3a865b7f48ac00c104b2ed39cf4306de1b06e0004582e227a9299e6cf5f087bb3140edbe2012030f88a35c35080311caba78212d9f4741c1aafbcb9566ff3097ffb240ae72dd3faf6f94bd8b48097b59127c9cc4e162026458e97c9863562bb44a6ae4c026c83875f36f54278615444f31c85e19433ed5d2641ec8c3c969b8a2aa98db7288ed8c7e9daaf4a1bb6ef55e9f6d049b6fbaa862ea7cb36e78b154eaa496a5c46b37f9eca996bd478a1599fe0a23ae9ba9a61bf7985a07d39e95f67360a1607991087a024bc43ac220164da6a377d32685b903c05918abf239731f35d8c2c55a25c35207a0a77fa6529157cc2dd86b9568b42bc03f8221e1c1442b2ee63dfd6ac666247c0a290000f06ba188d21530eadd7c568422fe8770bb3720adc2401333fee5fef79bd8915b2806c9743c29361ce4e7383c4e3bfbdeea31ec3f4efd9a33951ff823d8750d9bbfce6f16d124666fb8daff169cef2685566ec95c363145f2e1dfa39647d294dc0e56c79171e4a123297b31870ba3d8f2c75c8f8c041a4e6cb7bad10767adcf181865751c523d25b5b6119dea6234512f14c698c440f3267a8ff6720b1974e4c1445c0c9a7c46d54653fc05ce95856e827829892b416bff14d6a5f598bad5ee49480e04724d386855a66b38457cda6eef662f5fd71fa9edb4359adf3821474824ca405f2794b0d1f7392cc56181f264f8b24d8116c1bd9fab5aaf191e2255bacda3b1a0d2f6a7b480a1f13f727de51370c820842dc40f392cd2e8a7d90a52476a48f1851a40a0efd543b9da877806bce4243dc9263cc41f5be4fd7729c115e420b8fa91bbf18eaa6ee004167fc53397b8992e970556ee88138945ffe59d71535e16f38bd1165ea8f353d18440930358af04f09c36c040e4ae74fa40ab91815f7554a23ed7e46cbc7f1cde12f0d6a92ec965286b00f10bbf900738ca96dc2a4ebad9f7a442b7145d2ef181d171fecd153911842bcd4c30e1f89fb012a91b6f332e384eb1d856345296a8f0bac2b070783f2f1cb19b94485f99dabfead7488df04c5f120739fbe70526a06eebaebbf5115e6ff720afed115fff56a3b82259a16e5c7eaad2cb5e662c08f7b1604fad5880ab3e45298cc8b43968121e9c6828accd8689fce0fd43ce5f3193d1d8a4d53da285009a94da15a300e1857bd0c49fb35afd70a41e47139d5fd259503a85194d3129228d80b54b2074bd6c1407f101375afea239f8e4559dc82225f310218aa0ed6f24a69c1fc965efb4eaf8e7df3f6392df51cd69043b564ac6d1477f8c14120f5d56da4c2e56b4bfc07f65b192227026a6ce0f8da7404967a8fa0c1e0f16690c6d5615df0c3da6809e3d529aff15df29b9fe78d6b283692f8e3979cee64232f670e040735aff19d0198691f68df99f8a46aaee88247021fd9c4b01968580806e02dc3947baa8d85a72fbe4e2458f8123aa56095d3563b857622a0d27919a79e50845bb13c4d269ef1b1a972573c927c316f15f438bea543c2fe73950023d1a177081446ca46df3748143f9dca51fe2e1296180a7a1c3a5be6f3e8386b113a7b6d4f832d232f05c3023d10ba3b275e56011daf55503913cb00cedd748c6d02051436c2f60f71b970b6aec367d1aef11a2e940f0126a6465102e20b999d38fe09da52b431b53015c34769bb75e0c204326bf9147bcc6fa27041c8d5989c96869f6de126d2928ce0da3a17c5b53662586731cc167dc87606bfa65dc0bfe24a1a7bf75c21315dad0759f12513554188d884216a190f01aebf891e768a4275de0ce6ae7f776831a63b3ad1978e65e95c2047edbc8ebe5fa18697ecb100edd8cda0d767d3868229ff72e7c7675cd80f7fcb999a7c5637959a8af1df5275434e6ab9145cfacbfa0a020989304df1f6fcac6b7b44a50c0062cec1cb495e449efcc10dd46551a369337c06076565cfc54122092b31a1423ba1ead4a49e5b24a4cd1597d8ad637354f09cdf9852fdb81d32a0e06974ca0822c71562944263fadc94457c286878b9e1a4c23baee46189116ce13aa2fa17e56385dea41cc47f47f63b2b745e7979697b28008f78f93ee3c23c347a91535f2cf911d05123e508623093aa9dd2b7dce6332ec97e048d20b192f8f84486dde455477353df5fb1ef776f364d59ed56f5d6b8d9ce423b1874fbff2f5f551834a0daa53a3016fb7d1fff4ab17991699955f2575398341dc57a6277d55bbb6c5784afc225a21b5bb03f0d277f1414beab2afca4b6c891d7e0c9939b115d4373d0fb6762df0106d05a02cf934094f03b393f908ce9149e4b113f7a48031698e9bb995f44f607aa1055f8bd795b782d65ae188b8357d9045b0bfe6d87b9b6e3ec2c147086da190a2fb0bf066b846600eeff00fd689157168d83fef6fa145cc96c52ecd40b72dc20d49b4b0360054b879e919c5c4761fc097bfe3022ad182569a628f3a2f17c47180ba47a504aee14d2b026cee685ac2b824ab64e78683fbbdab23c192e9f8f78d909708729d4cefc63cb886062a0709c894847acf21b023012092257b99ba7fa3a95655436ac6646c4dcf66fb52d20133be7415813907ff4c2971a0e559d2d60fcf12b5cf85447b2e11b16157fc16ab0f97b5822ae1cd37f73e00408722120e7ce3c3220d06153b598ae83d638c471b8318addf5d4dc99232b57182db2a492c2ba2b3b5a0cfa529366bf226e5bdfa8678c66d967b17d42a1e60e322ad83d7a4292b56d372bf51e2a194e1ae5a3878ce2e5f639e62137e7c4e3eb35d0ab2020cecabd822a92c20883f8a1339d8c0dd5b6aa5c9c8106be3c79addcb8ef484c2eba775b070554f59df81b3e7cb5358ed213db7a9c586018ecc7d0d24c035f1aa7f7089a64d9d213db5e804927ebcea96289287358155782342834f6937c02e5855c964f7924f9920c33a2e537bd18673ce55a5072dcacd9d4f3e7d74b2e6036f6fea24f04c04485fd080c2d65ae21b5e7eb5cbbcf61943d9518ac951865635ca76f2d39823f9bdc8aeebf41c01d6fc7db258475324e18cb54d43b59fd3383b1f954b0fc99e1ec759e13396308df188d40bc59c897ba23d8072755ad921c5a0faafdf71a0592fb8628369f3b5c643a5781c5b746d7c9e71507c88f4fab67c37a81c069f9fb5aa54843004850216a239cc8bfd0a704ba873f3f1c11d263d0c9ac4adc2d195f2cd4faf3f3dd170f04a32f98d6045862c8d662511b53762079ddab7a9c2922faee87d7af2bbfd5bb11109a4add6a5ae7562f78cefdf447b04bffb80130015f1232df291948ea20052da084e34e014d5da4a9ad466438a0d453de3ae824bc04d76d3b3319c09184749b3aa2e521629cf88b4aa97239ef36d4c7473ff378588fbcb2885bc26857ee6fd40680e8e7a00169b4045c7bc2ba76cebb9944db60c85bb4c92eeea698a6477c1547e376dbb82ca4d3c2077f6864b65dfa160f49a3914c653f6da056c0578249c1317f68b0345e6ad260cceb788d4800492b2fa404dd6637133f6fb61ab7a021887e16a8bda4033ca534e24c3e63cc025d9506a6446d62be929806e0a9b5d96294258cb3606abd4ce9b46177c9b93a75a0a6d2f406f8832313b69fa1b7ab849f9010a050645f465219494a6afa220be2c560e7077743ed25ab4f3ca290844db9c44ad067b8da588b67d244668db7a22d6cbb2f487136b919909d30b0418e4d9b066171e72de4a617f8666f3b3a813f286ce70e8091e20b19e8aa8538355f076267bc7855ef617e19834eb32e19ad6b922334f0c1c473f9583637d3cfdec8d7689c7231ea8160781e6e61df9922015629db7f73245127ac8e87d76fc9bb3560f85cdfc77579c4a3a5f87a7ca41c7baaa3ebb9724a18b8df57d53b967d38aa6fdf40cbd6f04c239426a289665049e29d2189f33fd5136b3a225687dc0388947f4ffe7986d3cc0b93e1aa426c315e7646b3a362d5ce4d344fdbc5ac1138ec99c5fed89ac8b6cc18710851518090365faaec83f5aa226731defc5b626259b6c7ffc7650b32f5e7e0629c0d0210b4db68c2d851cc80c7e4ce31c0fa106e200dc900a3e5e50c6d50abe0e44d9980d71d1c37b5fdbfad443e71ab073378185ceed936c0c34e4355a6320cd958b12eb4e801e87f6c12a8acbd1673d236a19ae9ab0f99cf77b523c0dbbe6d4b7308ef0ca0be65d5de8cf95ae440cc161c1f2225b976eb4c710bcdc57b2b2b9569a5f10553709ac44a0ac0555c56a414e5c5c8ff06a7accf67158af39ed822e87cab52262c4cfd75f59ac780ff617dc8a394e53050c4d89e89e0eb796488e01848acd3498052a160785049a7f7d140a9d8a1797bf670b214e350c472d663d3711e607fb846ddf8624d583959458ab74e714756b0a70311ceddd467e37ebe9f7565a6fa860af15d9c4814b6f77cca61a897ba3a55c995c086f5ce4d3c694860b4421b87fdc190550547a3f7518a9e4a6b9822194fc3ab47a211b612458b17715cbf6460993af8df3274f9266b83d06fc8fc29e9e95f829f713c7b00dd2f09847ad1f8426073b38be5e5bd9d515f9c83a450034497f47c276cf8ad0733bb1536449e233355bf795817bc37766936bb209f16b86013ced312abc2e13825157482be5a0e0b51ad3fb1ce338b23a9640f6f4e0324ed28a323da3a25e8d36de764d9897670ca6eedcc6f2a38a05f248554ce96f7428a4b8a4142210c175e1edde8cff8a9a8f9095068cc5fb4e72e462098fe34d0a2c0fcc07349a6420cd3d301c3843705b709572523f0ee40ebd8869c0f2363dfa1849f4bebe29e43bbcad22e7811e5393b2882bcabc47cd8040764003ffdefa960952f91103637178d6959ddbdc1dbc364911488f25a463a090bf4ff7d2951adf38c3d704db9f7a3c2efa6377e8613e589560090df9340180362b9468f4cf691e221899c39cbd91e2dd791c846d4b083d74dd1c2006d7ef1deb7460935ad7c5c0e5bbff50dad371ad6c964fffbecb8e76d7fc1081ac548bb26d9635bc2994558d992622b99f45b68e6af671eb15d41675eee5204a430361e66933c10ccd3a040ea1e20a78dd0a8a9b8a2c30d3d2c46c6a261f27f53d28df5fc1a78fb6760d64cd9e9d23fba1878202049374c9ded8919992afbb400b5c903ec3ce3cee273743aac49c678555f6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
