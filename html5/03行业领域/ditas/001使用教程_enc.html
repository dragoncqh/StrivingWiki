<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1fe316ff396774148920cc9b5a5df52cc6b7891a772b5047bed3cad1e5a2dd8ba5e83c2ee8a2bd0078282dceb327d00e00c6d552c9bf8f000b27da9c3ea5e2c581ac640ed569a15bf2bdf3332e316045005076db445831362ba496a608677a0c93323ef8c5ed551395b88c27ebcc1b9535da4cb35af57dbd0266445715214ad2db0f41993398d8119c7d7497c35eb28ffe8ca8d8881c54cdd176f06b67476d646a71ba7f386f3e3abc84fdc315eefd33d0c2f0178e273aff3180d239f95366ddb01a4b379e6a5c036ad33c096f6f97032eb0719c62a5aa9af3aff15bd894e7cee3e9052114b82bc12f1e810095ba71130ad9e6a5883d341b3092d92bd91f19944f99c650171bd7f9452ab133db09a4927791d0711f776c35e937dae4a7cc53b150c703fd3ac58591ed7fddad81779fab5c2247d9a75a713301b5128551d23eaf18aa393d289b13779cf0d737187ce95ac81c26ecf7863cbe50f1cac608cd8bb362de11e561ca88e159ff24495722ff7ef630b30bcadcb0a4579f058e605ae7b37e7f0aeee0490d6d222bd26451dac36f3519e73b6b45a082073816f7ce90d3bdb1ed18acdaa8ace061ed54509688af17bf2d95a85249247184efadf2c244c40db8a8de5458a0ddfa0ffe2ddf3cdc7ce4ce509feee4436538295020e0b4578414d58da1de507c838f81b4421f63b98ccf3ba60a32578aa6538a441a884935dbc2f7296baf2d907ef30924323121336ca229685bd06abb31324834b0521e4e4c95ab0608d9db74d63e37a22707a680de5189a0e1d3442ba11a44275862487b3d873e990c42d3626f26d1d070cd7323a531f34d9eb6b672d11b66e85dc7cff516d8dd00dbebfe940aa7c5078b0485269b69244e97e086d1d656ce13281d45989c4166b7a754b70e277d65f3eee6ff72a6b8697a3dd0d05440652317c27a8715c04884376015bfc5fa317f75ba4e3a892cb554d3c191dd0e1f5d8975982c0a9896cbeec961af655972e6840e0e7ba9b884927902a4a4c003324f8a66af6df7d91a4c6ed13556bca4bd6cb177821d9741f123a273b877c45bc267f56b9764db390df9bb28aaef675b0dcb75da407c5870dafa9adf323bd0aaa1e137a53bbcc7db771b6f04c0bebae346ea2261f3cf95358499f9fba127285ebf83ab00ddd7d9ac2aaf11e978ce177a03fe550fdd69cddca3647f2c88575b27f52a95ac4aab074dda8eda143486a3f21072f410bde5fedef5ddb8e671034db1988620f2233f54a0fd0e03a7129b708f2812de04b42c7b48298f822b9792d1130c41e8861f6658e4f2a9bbe224b189bdfe9f9377b0c87b77407826578acc2458ebb298be831c1edc87d939a21b5aee6431329cb26f6805e093442b2f827760640a29e6ac317403a62bcc03a14032d222a8ed43ec1316f4661c41db0500bc4c7ef69b1a4ef32cfecbf07b6d39547d3c6015c8912e746d33fca7415a96066b9dd0678ac576c3d2c833fdc6c827cc35050819e0c29a59bad2047c3ab9162024f544f15557784480ff77b3712976092d1c86bab74b9c7035af775a2e4a81d1b6bd2e09015906f34a348f760d2fc22873149703ebf9de84d234ca2efda424a09ca758bd9e0e0cd1c0484345901495333967b75d73c7f060f47d54960aa3eb17b88ce8c9d4cf646471a4b4ea3ce14f747fa287c9250ef84fbc3facb3841e60082ebaf66a8540e86ace70312bcc8a9769fd0ae773b19feef0f696c994da4f851347c7b61c4b0612b93c2a8a3fe8539d63289f7e5fd0ba7de9e2c56e184465d483bd6b70030b61936f8267cfab039456bebcb7026db29f59f50a0c619ec004c39649c49a46b1520289d7c5a32fa1ae69fa87c33293541ece7ba7bcc18d14d43e76865557a2ec8b8b1d4c202ca95bfc9a3374d7e42f5b34f2ddede06d16210b946b83992d9df3a35c3c7455b6ad7d1d732a4c627d930cbdde034533fca4acc69eae1b96c21d5205efa059654cc8f60f3f666029d2025cf7df6f2b91869f2c152be0b401058813070fcddd42d29f47c685bbc1335ebede3df219eecc6b04f3eefb3237c53dd4d4d93fc9ac13288d3b15fdde05f049f9a02ee9c3c532e046d1256b21e07e7547db10d757793a18f7298db911f6d79f9c3d37b6d4187b71e57032fb0ef5f5db1734d5bf55b46e8252545610a13069e9d806385ba0a3a83ae662ac53e3f423132158e5cae594a0c6fc501ed3425698797b1434b39d7337374ef9ddfd920f7f7c8e92339658e5568805aecfaceccd4de11e4ffb3dfcfd70a3885f3413c80abc9569c85e43088fca8d0c4f3947b0e79300dfe95639156c6961c65861bfc1d3322e9cdfe358e65a0d0efca9ad83dddf7fb5b38fc7b1c47114f48ce9253d78d2120ef882479167c3743a65fbb42daf8e6bb3ef18335f684c4efa4283bc879868b1445231677b3058fb2edd928133fb663e9e47063dffa60b493d441cc2a03c7179248af24e7c5d04c055d58a3683533a87cf6d57e15665a85ae4c18b228f8b2c8370b2aa5cb236d70e1832763b428073c70fba3a7ea66b2cc67e1c0d74a8a206ef2c404bfecac9cdf7d9ffe3e82402b6c52848a031e7d33ea8e67e41268d57a0af96a1ecf977f852753ba7fccffd9a63a9341c28a6c45977e216eaab7ff5a2e4bbba5f63bc3ff09d8f7e647a074888b1bcfbf91b58343dc3930a2cf84517827ac33fff47ba816dbdb61af89bc4ce991ebf8c56b32462ae50059c18570ad521a8040ac66191b27d7af8b9a94512fee9df9d440fb0244433f9e7f369b48b7af80a87a62f5fe317013f0381c80de40c27828cfd09b98b15fc967c53c82b2441e313663e183f3e9b1296c8ee907a95bbf72db95c6b6f99bdc8c60fcffa9539e8f6b14b0343d551a687ddac3f079f1c4caeda6a348a424ced8827629fb96f7a2e963184c53ea062ebea5f17474cb46ee37279701471e57b68d25aec4726b4645adb3e4934e6dd3605b6b3d30e38b303fb4bb4afef01ef14e7413c96f5be53fe7d5dd38125c22e2f0be0b158c2a4624f8c3eb85a554ca0aca273301db0676b58f135e34e4cc391cb1c85a69d311a1f8180cd7b96b91e455d911c1afde1823ec661781f7b4ff9fb5897a21e257de801e0847252a407906e6e616e466736f96e3d316a1c549c4ef43ed204ac69bdca6adfff397b128e3c680df78bcf77d39f64b4d7c025911598f22fa635f1329c9ce3e98ef0bbf9aa4c57364faeb5a84deb27dfd5d385165226468a07a3d65e68482eb1e9d8cfdddb264e234abb7a81707309bc538879b8a6eb173f1847f9b7ae873f63d00d8f09ccaed77f36984c7a005e2c00f77b308d9f6e10efb10e81c05ad1f89ec8b63141f7fb0ffdbf8495b2224676d4ec31f304dbe3b353c854bdbe3a83c25f566cedd81794202826101986349fbbcba4e84d88c94abd2348e23837ed3ae394926a73c5f64f9f672788d6e8ad9027b912c80d3a633cb79befc979964ba4fd0b5678439c567d6b90eb04abeab6b7d401075fd06cfec68ed72c79f8a3fb76d999eaff570d0777d832654da38cea6fceda5db42d6100bf39388a7d191535b36fd901fd9fa738d06fe904fc7779f65180dbc8b3c1af5261226a591157b713c77b0858e05c7fed62c8384c30f96285d242565eef39cddf0d5b5f181d4b5ef76857eb1699d43587d859bc64b08867b03be05e688264e22ba651f5aa08533c816beb2e8cb76d235aa935b398e97b19eaac7811a3e370b77c81b2031d82810f8f97428ec2fdd4ffd2e8102c56b2d67704c4e825f4f308b28dc11043e2052605b4072f990eee8c457cd5163e069b2eb8f9a09c543d56590866315e72c8579e1378db40d0ff416ecffd76277ef21057e62f974366b155b4f663bb9b417c324ff5abfe27d478e493e1eb3ada0813d56f3727566d66ac28fee8b283b37bb56603c769eddd8a68192c01dd726634bc709ee11015e208b5a61650b9ce935e1409d5dccccbce9f99f0d00214641b18b7bfbbdb74ba1f5db4a9698548cb2d4a3cfb23625f046600539937be4b022bcc31d16a10e9df41768d0f80253f739cc72be8e46c4f3e6a55dd55c4bae600a4b08159c91733657e6ed1c003155cf6646e29728e9f73d29f89a07d4e6839a436e6c6487012617b69b6c83f99253ddbbf49151b3b6865174de54fa2786eece94160b116d3e9d762737703d603b49d0a7b233b0340e42fef6032787ddbf0c180d1d12668f30a2b85cd00ccf729e6010c9cfd5ba1e186826e4b944a18580d3fecceb171e066c84aa70e1905e35d75c997898affbafba5d8a406dbcfdf1baa972a045330c1c4d4a4eb21e1c509f2d5e4d6dd7aa2a151254de77078e1b89f73311d6369dcd09c133e62d3b75aa12752364255bec10bff4191f1db30cf8913fb565b32d06bbdf82ec904b4612856d80bedd3a1e1d49637d8d52ec96183931b478d373cd521e18f04f74642b0c3f4ff51cf670c364e88856910fc6165140cf036e86184819f735344ecf5c740bf7e38d2061c0537d2f181256aa869ecc0545f56717b53c44344453f547307a66bb2e5d7a07a47940b3aa00822ea2bf74ada5edf3e2d8a941654363cb0cfb19e8156cdfa0b967dcdcfb81e082a67012c815ec0337e5cd777460a4bd5f279e3406ad300bd843ad79fd3abe107c0c0dcb17e0e69522075da5d25c3acf6c93e6834be629bd65746095dfbe453c248ac31fa3487e0be3e4fda7ade3bfe0e1d6ce2f95bb31f17aeb586a7fc73a780d4fa543a936da8370ec63b8cca688bb171854359c2266e0f4040d23f7ab752a714c9b6a64e33e30a57e9ede3d027bac741ac3705c670c9b2da8438c19b2b2e95a0c8526dd3c42fdae91015bb7e41082bf4947535febe4975c59f5b21a2fc605940662b3aa7bf72203d3bffe1d67289497f6305fde433526f743f26448be02218de5fdc293f897beb8ceaa04ff7508f1161aae37398e48d8f4d182a9ed55748eb972beb3101cdcbeb9ac2237a85d6e651a91eef11eb1d8bacfb387d1d0f2b4c3639ba6d8120d6bf9615440c6b5591bcf8856dc8f5ab6acc36e47e34f79769c8c14923ff4d7380c645dda0afc3c2b7860d055bda66b85ee6528b8fa1837911f6f70b4bb11eb27d52d72323209f58f822cdeedf4e47ab270c19917233dcdce6041e5ef792f85412ecae7234aada409f1139c086268e90a15be4cac89cd1fe50aa0c97f9b2fe863c7cfc1add78948bfc93734cbcc5790abcdd128ebfc9dbf8015b0f407952607f1eb41ccfdc819ee2adf9a9e0d3a936d24077a74cb20a47eb28fc83a17ddbab5b1e729fa0d615065f280a607b3c617eb3c315f27460c2e761103850106fca7d218bf034d92cd67e3114d37537e2100bcc282ead2df252c3068b5725d49d2a6c5a93b654b9f5d95a0d3851f698f462ec6b58534bb9b1c8fb6a5165f94a14e0adeaca4c27c4b12d9ce3ccbc9a1a645a3c514d79138fee22ae5431041d35e530da85ee11aafc4aa5ffa627cf46466f9a899d18f0c2865e2cd2c0994602ed60499b7f1f3fe3a26780e05aa2ceac7e92f6f42d6f58a127f60bc12b45fed14a68ba9cf0268b18e232227823f77e8a73ce0c368a212a3b38d2b7f7b6686226978344c6bffcb719fca6a823b3b32c6baf7d2e90649adfe3abde664c18276f6cec4df600f15601aac1c58572135ea7b276fcb825d8c0ca347515f6dedd214e987119ad60601a47b20e5632da8fd3132bf909732f75aead7b6b2715456a4a28d28cdd824fee679b6037f94a7266ed352581d5cf91d63cfdd98d72e8eb42d97130085bf001d27d81b896354ebc11123d025b2598ec213ebc22ff9d61db02ccf6eb187c130482d67f5344aa984a244796a0eab84388d75e4d6cea35251f416454c312ca096370bc087f4d47c36e7c4ab172148484f1fff67d911c2e802f2b695b1a00fd0a17e18fe19543db274a93f26c56cc5e4e05a77fdd604099cc17e4c2362b635ca5d5d45a2022e017035f6ff0489afa8973d52308d6101d50c0fe740b2063809cd04cdaf6b3db4658b9dfb1e5c22292988bf7250c8158793c8c3b2032ca12c9b3e2f94a895c53eb4f22e5197b93cc8bc28ce5e86fee193fc36a3d3cceb2a6b3fa06726682cee68e90f020ef63f0e53059ee612c7be49e33eef7c0bb49467ab73aed07925e5b872633e7c16de363e9c6d2454cbd4d50bab1f83ed68660110bd77b03c2e8e667b8a261c4f1b9ae274ea81cdc46d84ab559653cb2a9a6decf4afbc8352c3f7f00601375b978c3f5ccbe11b31733133ebc21bb0802b2e4bfc946cd6d20a75925a3981332bbae96ac1948f4d2fb377de898f0bcdf1cfcf6cfd8005c1973c48f9593a1626a840273fec52f6dad4eb033bc73ebe42c8b27c81af5dd39d9a12268cf0e86570a0be3c4fb275a96dc3b384f78839dcf137beebe8207ab3c9e054c78ec41c590a5ac9c65c268642711d0e633dd242871526d2070ad4205425de7cd6d6c5a17ce33f0b028aed103a9301b8cd1bf486782a2b72ec22f0f7d38391885864c7a6b1c552261217ccec2ccf738d7d35710199d96336cddb263fe6e9987406abed274bb8f76b33ec57c027afd1e9dcf3502f4573713e5a439fddc43af1fffa39efceb520eb5e91ae6f90553e8824e425670909484976c546764a2b86d13c795b3097427873526516973e1e8323e129e19bfde4ece8b99047deedf335d320817e01318a50724ea643f51f3592450747b89bef48241aa395c0a5d0f6efabfd4460425e651f384d4ca490d2249131049bf36bf152333ec2ae1c140b9ce8d3121b7bab1ab0afaa505e79c53fcdca28e4c5613ca7652fd1018a6ac7d8992f5ae3e7be3eed3e488b269c96c7fa1913e4d8afb9dff95764f86a915ff7bda34ac6f688e65289b6d0bcaac19afb9bdc04bb48377fcc1210411af758dacb5bb93c01704026ee3fb1d80162569d29cadac53febce206282f69c259ad0c594f20b6822bfc61483ae8925d96acd88bdb5aa164f59cb2982cd621e6090b8e99f35baae379fd0a3630efa0eae06f6e778c1110a74b87ac3413ab0093f07b00cf8a34c06c68ddaac6d1cd95e8394f190b95baf1d905e4afe1a9866a06f8ac5e4d4cbcb46cfc07219cf0373487610dc0d25fa1895dbaa580381571a8e58aab9f80beefc5d30f82053590ddbd51027b80d868ff91c4c2e37cf0eb20a3c3cc2f4ab307fa0cf7b3ab7e020bdff7e8c8ce804b33dfbb511afe361b7646b493cd166342120887b8d10345727f72e20022827c83c13aca1221b377c80270066451a6ba78183b29c9b2d8d700b3df98ac4cedc0821c31b1a2999e478b0093fcb8159eafb753d84ff0abdaa5147e70623d59a3bb4904a426a302250e8561f69f82d2c083e8925464bc706e8bed3a1de3dd05cd9c3d3c5c04d68c7db3f85684fe39f5cda73b1f45a6d74bbf7c5c906c07be249f3c9de2101e433b450fdaf4ab299a78c0abd142aa65ffe2bcd83c64008ff1c30c7835ce3f0bf7052f0cd2b1a8f882c742683c7dd0d0d9841cac1b643d346e91e263e6aa67bf290228af2d6fc770b93de88a70a3bc7b27377a18aaacd1e2fb1395575c785f22dd59a1748485ff38337d0b6d822609ea67d5d006fe61b5e4a01d639bd2499ca3cecb2c346e02ee4b264e6ebb4208afdbb39313eed1dacad5e1ec6ded2da4ac63abfe3290a8be40fdd7991adac3b5c6b319f9bea85e146a62896627bd36aa0c7b4facc609a835adef8a9db6d755b99919881edde97fcdcce283fee8c4fb6c2dae0065f4ae33a33f1b7ac2a62d05330502ad07bc28ed1aea5744ccc7de2fc2361859be686292f5e3ac5442aa9bcf8ee1fa6b278df517d98bdd02707a0baad7901eb661ee1cf6bf6af544c04f7a52c4823ffe39ec959ac0d0ab12bc6bbaa1467450c57aaa8d6e83f5a3a99fb2c38f7ed08e55611e6ab018ee91eef83f05297e83be465f82ee038f6c3352a39fb4cdf209f48dd928c3628ecb87706e28ec5d5c933c23c50981fe5178a7413298e33ea1419c11417c9525e9ffeaa22e5c5490f36dc09195fc223e9dcf5f6680fde3444952a49a3212e04c3ff3e674f984f934fd9d9f92c8c4b9ed8fb1e97f8c9ae9a8f6c2c612a046a36b9bcf339f49db86c7164f9a1a916d36452d7883255998f4f13c4f715dd8bde7be4c76c890b7986987f4af6f7149a6f7d5bcc6954243419a54a6e31101145a8c3ce2342bf4d9c400f2d15f633370950b15ea69c53103b99e61bd24a09c79234d55e71ff929799e3cbccc55e29fe85b56b3807826d41cd39fbc78bb919624106b2809b993332a45156a7c5f756a632c964952d955466d2f45b88aa4dd26c23d64d1f5046ce32503bd982b0e2d2ef451607ed112dabc9d298f07b7af897c063b3a1c23a9d13917d0f1c58daabbc0c92ceb1236cfdbfea761e5a9c6da0478295faec7f0d8a3f06acc42d5a115303ce00db33d0b7fd6b3d0e628d94efcdfef7680ef8f08b3571a3efd337e06907954110e8a2ad0cf153066ae72a0ccda52f30bf65c6d327787cfa04a06474cf40a5cb15e7a4ae7be79d98e70c3f2f9b108203822ed22b2edd78902a9e8d9c5b44f280f1721b04dad1420c85747f4bdba79b1b2c07a5fdff3be1026b9f80bf6a82b7fbd905b1b286815b5936e4bee2fdc5696b438b8cfb50c6daa7bcd7b2cc6ca9e3811f40bbd02f97f9a2a0638627f2ecdf3dab41cb0d9626ad59e5d2588d9b2184347de1e05d108963ac198d4b84cd4efe11c8f1e443deb93a6c198a4b7977f8c3cd807fcc3aa57845983745dcd3d64bed033639c760210916cd4d2307e4b269dc0e841b2f2df4dfb712435d078576d2e2590cdaf1200e7b7fc45f99681181ff72a2a71f57286a22dc29cb13dfa161f93ec309a8e50679e04bc9d983973b4ee6262f5a1b3ad5349ae9185ec768c373032485226475d0116bf1ade93c3853a492d7c4e4f8672d0906b4ae6b875063ac6efe3866f6c1e77be0e8ae49066e7507efc04125edcc6f4b2d8bdb35767596156bfc825f4d7c3835adaeaf035c46d1828bd9c717a3a0a4039af2c1e4485adb81cdfda8ef6de455bec44c4f5dea34938aff63d342b476f5a6e6ab17be7d4fceac48d9347520b3a297c56e0f78de80188654c025e17b955c3e0ab326b3bac2723755867d9b713f0f7d25364805374fe9367f976b6dcb9f451f7d761f1a0bb0c8f41bcfbc94695278e0e43062abc96affaf7f7b981d8031fdf069cf3037eecbf56e4d2c7230cb6830d7d5cea6760fc88da88cff48552dec1e3866c5f42d1e24d36807613ef32ab9d064002d104e835c8bfe002caf9e7f1a94913f14ffc20cfd3bdc2abe48812beac6d19d593f7631def68084c57bbdce0da587c2e5c6c665acee0f845e9f7506223903ec183bc75d20c5bb3915f12f8ccf28a9223a0a654fd90a33cf280002ceead424f5d0c62a90889dd31572116cb592f2b724dc344baf7c3c691605bc6de0090fa19c65ebe2d740daa613994a3e1f14c7380a021b8f7b5dbcc82dae798b3d12889f5eba473935e414a1d17f3ac0aea4c424f5dfa612ba8677a25a6ba592e323ff5522cc89b95e25681959bcf6dfd0a05d4336edc226044453dfd36f97fc8c202434bc37551d04205e6d3e43ddae908121448a18c6f21e5c520f40fa6878aaa58591423183d947b994deadc2811b79442ef0d98d3d87620d30c73813cf1cbaf9a68fe379de85c1453fb0fd045801abc7e9f4b58b25fd4bd12826c8d4497d3d97bb523b86d2194c247920ece9d38d444bde81b848c61d71585bb760e29b04b2d3411c360a0757cf4ac279670745cb3aeabaf01339023d684c223e36f14b8de9ac6943d39231d72b5c4e9551f308a83487a544d00ff53ceb3fde2d982ca31c2049f07fc28efb7817fb7974a9fc0af","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
