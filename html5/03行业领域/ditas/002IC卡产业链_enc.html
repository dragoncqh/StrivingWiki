<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9033d20e96cc61a828b1388a3c82aa6374dbdea2c2f886210c874847706f52f18b8f2b38baea53f9ec70280d6cc51896737ebe51e86973fb5c7451e882d1307a699ec1dfe38a8ca15812a6e5b57d3086be9845fb68e8f2ecf572e143a5f0f7ae136f4b0a1788479fc56954e2f9de8f3931d315dd09275cbad816285191218d35482059f9c262a6c41ee4425a6d76c76221246dfa44c02b98104b310f2c700bd3fedd38ce523847f7c2c7514c380bbe496d5997ca79de8acf845d01c4f68b9202848a978eea2b0c8c325482e93a5b00aece922179e70bdaa177eb2e0a5bf28b0ec06793caf2dbbac19d9203d7947d7d5b88e0510c48b8dd497b19426892cf8fc977f24da0e30c882c5e1cd4338179a9fc5502695a04344a48e85a183f9217133ee7673b1aea9e055cb0f4c08607ce09615977f62c611f476c4923ade48a2d24f847e4e7da67b98f25523f2508ce3d9626a9b052e8b6a93836bbf73c669958a9b84b90c19ffe18b37a8b54ee328b00f6adbc46df71094fb48ce8bb15c384dc72284bcb5bc3a45403b127a365b762ee77dead10eafd23ad0be526efcc16c4f61848899ae36b1bfdc2541fee5846e4f8382f82947ca0ff0f66f8e018ffe222543c620dccaf721ff7942fba46bd4c9c63b311d59b8ff61a4968607e726b4be822f49a735f81c985e74ef5000f9138a537f8006bd1f3fbde6d49604dd72201575ebf5dcd9ef5b975fca32825b20814db7d601367e793a485ad691e9ed0f6b1b9773a944a56750322e28afe8440a9b02f32eca25bf071366c9e11121d7c7519e8a13bdf16a7e3a9f47f96232391e9bec7825352ebc33b8795c4c2af82de00ecd2919d3b9273022d7796ff8ff399ec0ca03cad5c492ea33a89bf0e8489bdfd54b5527ccdf94329858cabd614901b5ce0d50159b56d3189470679627e24391f82642e0d9c296ba6a80b073168572a8e9ce4bc98c7ef98c41af705346df1313c5f7e9076a122c686036e4ab124e4890eedbf7c1d475c19d8e9406b878f67ea4bd4526a48fb1b83cf534958d341c3dfa82fb80297f703e0c80c41530fa44cd65aecd999194223fe83a33393c33feaeb65233435c071ac9ef143f04de14200585b6f5ce3e1c95f9846acea3c121e062a233c7ab5dd279b0287a70a77e159788f871ec1d90d73daeee97cdca9de92d007d15d744afe70908ebd78161bd038a1fec147e2a2212cebd2110f14fc55efc3f809d5c196d0d7c4980ec9c0b0daedad0914d8f6ee47116acae0b665f64177b978c97bc44790e148d80de1ebd4218aa608dedc3c8bef80bd17a2391f6b580fa37d36cc12d8e1a23cce3e19225ccdd591903fea8d65f27655c6b73c5c0c5f555789ade534a46011a7d8f602cc6d6eac2da0426a916e32cb62cc838f7521f4124d3224dda80b47c6114060f3156b74144ae113ac4a4d7db4ab6109d18a652785866effc0dc3d90e967bc74fa6f06889ad9fc6687f87739d99b61fa511a381801b8f37fa300d2eef10e0cf153c109dc311b2a43a1455cd34c2527130f1bb9b826ad7acbb132fb47ce3c99d0bd739bc7f60b493da99afb5783b60f59adf4903fb400fc18060974af30173fcf2c388be97507c9f11c5f7238300dc25917530c42fe797d270ef19a3dd4f8b31819611675c9382915aa045f6bbf8fa19145dedb28bad1a7e42d903fe2b1c29499f0f94fde9b58dd08fe73f085aff1aa00d625d5ffb6e087c3319c3f21c0834896b2605cab5b7182244818da7f3ba3cc02f6d13d0f9dca4f75058f54b8ed694bf6237cb7bad0d3e0200a415efabfc9cba8c5ae299011b6b5a35cbb4d262257f048711732cd6e08059663adccc51c86c5dfbec725d7e0b8e9773335a622bc01a0024bdafbf71163406b905e903818b82b8643ca2a25256dcfe26e3fad330ddce171c49c82c99cfab92aee67348c855b7f21de033475b1c1ece8b5dfa4b808a1def53e81f2df0291b36694b95c67de712c7627eade4c53b376fb7616ddc8d8afd3140b0763a13f738a444b8556afdfd849da26771afe586282151a2c02cde7f5c253023094def5fe09ea71296742f3ad3a2e471e75f16078ae5718304e7c44d704c8e0d3049bdd595e078b3e1b95989f58291556c5303040907c1c2208cd0dc3044186d900295cd9c05c410ca0315dc57651e0994f1fc5e5897e59078cdad4c1b7f4df9d92e059f7eba267aec3e2ad5e212af7335c9a96a250173163bcfb06dd10efd280cdf7c8ddb1997008bdeedcaf3db4060b0a804068cfdd45d39a387c3021734468f63f294eaf113d27c50b1ce78c04fc23cde22812c178cef0459106e265171480c039fd655a2039d30c7aee752a1b0316cdc19a59b6b1db567d28bbc3d6964ce9449fe92c4a8335668d06ceb743eabf24c93becab2a7f3a32d1f92070e258c16d36069f9a3eddf7ac7bdd78c591ab3f6cc89bfe0b6ccadefdc57a0e480ed656585b0c679c779aae7039204bef315c8333020f104fe0c1d45d953c9be50ab4fb547b858aaea2cd261174efe7f51e80724ab828e0f642cfc618d01b3642ec64b24f8d6ddf41aa4d5530fed5cc7349156f0fb7b0c511bb70054a6fe22fc5498f799ac7d1a4f0edd190dc5dcdd57104fd83ddc8c41d1b8c04118a67ec318943bc2fc780c59db50ec5ba85dab111d15b7277ac76ef85d3990e29ecb86941f38e61b86f973683edde4c929d3dceb209fd725d9e01b6cc8aa590d8aaec62d034062bdcf782e27cbd79f8117f7dea0cde62f26888d637bccf5019573a91d9d34a828785da9f3b7f504acad9d944a036994d013acc3ada686840832ddc4883be796499cd3f017cdac45850feae718d8da33e12ba941546e036ae07b03a497ca4356598ea3f0966faa4fc06003e09784a745c73afac3f78c9ee57e9271f901097e952456c954a261e31d88040c32ce11885e8826e0cf62483cc5423c12d78efbed09e5e193faf4cca9f0de6203463c6000c6460287701896980148f54d438c2675738e45ef5df26399588379b0443b7fc3e7eca89280d371a65bd8303d9699bc5e9e3885d2302c4a72ea72199afe36dc28352064707af894abb436ea4f28e27c9cbe7649bef004687edcfa251a7440fa9b3a83a62a2b3aceaa301acbf6733174015253cde178ac546ed847a854ff0ea2dd79e0b970cf50c17e6950cb1cf26f96dac537250ba2aefdced4b4e4b02922d5e40a59fa547150b71e7dc2e4d3408490b04ee17a43694980fc82bfe03da30b126a2d5a29b15f845488e382970edd002c9ff5ed8293ba80dcd3c86f7955e1377a82dca0bbc85211f68cc55c4ad6bf3231f3f82a5a30edbb62e629fdb19ed65446341c06fba8d79c72c7f9faa6dd75c89a677678242e43e3af17e4d5ded82d17b1d617a9f28af946472e48e601c75ecb77de45040d056726e94b3979d79ebb340ff07dc390785768d62b76fcb8699204134ed9c1001c1147215275967ac484ab1a8ff0b67ccb96ff30401fbec83fe388d54365f6594d44a49193ada082ce60166105ec693b3fdd4a9a7bf6a2f2227a3745d058987d6cfeeb98eeb998121de5c15708699bfdb9bf238218bb222760aff7f12c5ffd076309922929ef3be1814171057fe5e0632d58ff3afec8e42a2f9dafbf78b254cd5b16b4c58e68988688347f228308f96b343748e16d1ea50f415cb0dc312a53eaac913dc62f750e30fddadb6ddf94d782791fb137b55ea741180fb054ea5ba446c02f9792fce60ec7cfde368986492c9bc6c667683ab57beee442253b004bc56af2799b30b111c853a1d577fab638e514c1ba8e5ba7d38f8cc94c0d626bb9acd7f48de52e454e069b9dbc5a74117f04e4b224b6bc7c652dfbd8026687b39843df51938bec305cde3038c8e266a0b7707bfb43d5896c97d91befb00f43b048855a619c29c9f09c177d0c1b30e193c075cd0b1d82711f2cea58ec84130f51cded4c72b65bd1bb48c19ff7128903b8b0cd5a08c300dc0e117f30e108782cf5e48ed9c0f1cc37a098c90babcaa4da5e3dcc42349aa899df652379d305ed0646683105730b71790f4e5a690e592c6a2ebd385c86fed8e67aeb2d63634a2f72d54fa09e107f02ff0140435b17f5701058e446d0de97e0224624d4636773bbd744bddc50da24d733b928570df5f44ddac7a27b2f9e91aa2c41f26556daba12b5bf91bb52223f4f3f15d83de9157dd565774681a071a62b3928b94b8019fdc223314e44bf477a2a77afe82b69b0ff6d22e2a6e7b645de24e0f7955e45fb5517fe23bb2797a97c86ad9a43a45e0e939fb4306a8cf2e866bab6a522bfdd7636d6b12bffc9daa8d173309e7c38b9923bc737469e4e648667d5a90e7991c9d3ab85f1636cf3e1ed073f37c069330809a1513f88b3d202b3ceb99e81b186457921d12fc6b7feff1bb017b92623905a96abc2916f20a9dd3631dde2acc1ec06d3a38daeb72cf2e4bdc40cd5effa406a12645ecd692fbbc2962acdc514ce4c7794c81dadffe04383304afe3e82681baca15bb0d50c8f588b317d9160ebceb8de5b86649499602f115075df2e1169ee917c3fa392109821ed1ab31777c762d8064036fe2f039bca25fd4ced3023399f730b81619a999536582e6fc636f4ab6ce2785092b95da2e60a27e66387afd8993d7dd264c07f360bc6f9cf3cfaea733ba52e2b100ba4a170616d4723eb472971192c83b76d20879433dbbfd11d7a476e4992fa834c6230d6ff0796dcf5323e0d300c2a7592c8b7d44347b8f5198010f82f2a6be2e627828cf51982691ed2a47d811cb091051e7acd4fe884dd62a1cd7a4c86d627af918c8bab8f2a004752c97e04019e6b793c943c8c56a1aa4db0c2140cea474d8bfb7df64725ae31197c44f38fb0a072af9ab3439e0917def849e6cc7967f7c6a0ff30321601bce3539721ea72de748c4b44f7aeeee642a9d9f07decb9db796132f956ffb9be1abde7411b61280c8b2f5f0fedb397f26346ddc541258fb22d601a7b1b7b655588dda02c017473c4e7bc09719430d7b9b9c005ed1b720f3f3fba29d1adb1dd2ff4cf6d23d3b3c49d9ac934b7f07687d38c04d1dc422a0371449c0b513e4d27d79c98a29c19367bffc77a747597be703dec6fa3d0a379a1ab5d6847484f795eca288211fb18898cc061658e7302de0ee8bdfa38d4cac44af2bb1b9f8bb7d3ba653420f0b576c218ede278b58d00287449a71202390dca4ed02040e74a31fb4397d717bbac003f082f0635e6a14b45b13ac8b9b25fa5699b47cc82cd039251b2348f90ccd38ccc09acaacde1d6375ad4c56f19f4db7b9b1fbe92598eff149323b4ae6c92a02f65fb1071f027935087271d0325667bdc2e4daef7914d77809b179686a12a1d855bb0cb71c19344a03a80116646288f2420f3772d9cd8f676a5d42f65d360bfab1688ef05ed816121941a3994676766110be3340dcfce0a193ba113c7d767d0a4d906cc0426be878f75a7cff1b5209bf7725d5ca2da7d7002241382007aaf56a97f1c36b2337b56117add2580df07c7605cd0fc3a078960abd84f4898805608644709556e974e30dea9b11c96bf8402f128e0e491cde558e781eeb2e7a07f2ff7554dc56b35c53649cb13923cac8a647df092101168f080ee4c5c767e652f06616db9aea03533956357a5623d2f5a920d48d7a2d047440ab0fb3107facda73629c5bbf59028eb1359f243990de6c0dd8ae2894ac8fe01d7a43b0481a0d8ea6208072c20522734cbd6430368fe1ff66762ec65146c36a4a15081fc2c1e46147aec549c3368d52dfaec78ad390ac35fa1d3ba87b991828bd9f4f95f3c5708fbc3d596b7cd3454f92da5b9662138ff1d899292b4037bf7b0d8c7a008ae6c75eb8ec923da6808b462734cf9003623bfcc1b822e98c0a171497218acb0c86327a3593141254d5c31b362505d565e64afef6b128797641b57e2067cfae85b6c46b907552bbf9f762ab010a42c0e7102b99a3039217ad2e4079671f8e87e0ebaa61e2d574973b75e9c6c464baf1821103ba9596597869dd4a281348f760af3a74520842d6ebc174cd7555d60f8dc07072d7c7573302e5f0820156d2c41ef66ee56a6002232bb38d084df3333cc2c95f42d54bc6bc5c94585fa78f1555fcf47ce7965029ec8cf0d56f188e0d9d6e1a9febdc0303f931c80b9be664574902fab7e5329a4554f18894cdb47cceab33fdb4211c369e1564a7bb9cd49829d8fb3673fa26926632082c9e3acae4bae6c7e9f20584cf167bb79db9c1e27898b9d79b11b0ef97eed8b81566155dc74445f5cd62ecdf81bdc872353e5e5d1ffed0aea69146dea1996692a85417ae2f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
