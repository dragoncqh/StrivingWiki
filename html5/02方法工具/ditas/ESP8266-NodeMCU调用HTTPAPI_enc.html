<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"098a250c63f0abb74e0572d1fa40522e192bff0dd56d23c15f16ea90151e6b9c2580ce1b3ab354dc094e6ce9425fe7f81f6981cf48f2e1869f0bac7305e8343b56f5d4756bb710050b113d9bd0f2dfec92374bf692c8ff8f630c7334d1f76632e92b503b3bcdea31e911bab3966a7ee075285167b47740cdf356fa1dff4ca5bc897e6441ff3f341691f8eb15a96170057fc39b5edbec9bf2b64db78ff37828a8d800f94ffc3031aeb9dc1f79ce44fe87ab7157d609904fec523a6bd36f2e37acabad904bf031e334405205d402e92def0cb2189b5d402d42a6e62d877d05359149e51afcced7362704da1fc9ee9e855427ef88c1adeeccdd70b2a57680c27fc61e70564e94010bbb009b9d537ea63295123e4b9480cc4090cdf038309ccc7ca38644725d69dbda5672d0aa27569f746c81ef1f3b70c3e978dcdd5cb98f84175b3cef07d2ddfd4ee1592d853a0fb7fc34d905326c02cedf0a471a1c62b2734c1a8ec1835b2576774c2b8071536d94f7953609dc2d408d8e8ae344cc7cbfc29f1cb5ebb16c1fab9386a262171574ab261248b7cb5c86d90f380fca3eef9ff2d70f65b849ad8da5e7ef322dee15061562d716e3012b631249e95ba077c6bba795c06b3716248158c2d696779308acda8931b2bebb8ae2b76b8d955d1b2789494d2021231d7f104dbc83e48c0b7735f6b70b35cb8f8d0c87f4dde89775185167d85983884333bc4cb7502fd7be545abf01ea03e4518e7a1c718422254ba9845c428d73d4736303f7275f8324bb55ff49dfc54b7afee535fe8dc6a221c0f894ff83186374087d4d343d4c2d3598d7b3c912ad5a0aed92006bc2e10cc8e5079b825ddc447fad1641e2bfb3c6ca8a80b1d7a2b972eef23e33aff46f4b27b8ffad0aa3d7945d2632050e40a7671c0c1d5a7626ce5fd4d90cdd18b451ad2b0b464bfe266b59f71938b22d03c8d9416dcda6c01a1d31bb7fa7196ac8313af846add77f574665051aaf69381d53157d858be9ae4eba1fc22c473b8d93aaf40c0c10514e0883e7ff1a11460fc301bababac96cbf0e5c26cd0820c0ab7bb17f02c5ad11f59c36c5b2c06c56329fab102ae783725a18e2e53c3bc03728f745c27dbe95c4293079c29ea6f01221a96cc52f0296d63cf6274e195ea3c8eb5782e7ce76bb6e1d59310d33110e0fdc933789de6aab8483b075adb51a8046269b36f88639991354a69f7862b513bcb8cc0ef8f1b21812d91622fb2a0102e77c836205ebc82099e7e4630a1bbd4a991e164dc4bfd93d1b52a15dab64c462e563f433b06898afea704ee231b96b5325ae8cc387b2526f411b226cdd4998fff77a2784d3fffa16f309eec23e2786dd3dccb111266eaf941a78e1f005b9e0cd5213f3a4814f956b188c9a59f60cfe847d29c6975861cb6fb16a13da5e7bf8c5ccb4e1f92a56fa69a2429e423f553bfe076b97daae6f8c8afbb0860de080dd51fe17a90decd4450429b0502fda5a5b4ef4285b1c3793f7373bb729d9c6c6f1be2cf37ec7227f1e38654f688113617daf9e92f88ce815f610afa3728e30e4ffbb7fb5af834dfdece9b2d82362b3ed78f4259b1f31886f122ff848673a1578511313892d0b088eea3477a84c2c4ff287b68bb2885f9b2d0ab2eb81f153d5da311dc69b0756a853f946d3341a39dd89b0c1e49b5b099fa8c5be681b5794305d316f13f354defdb2ed3ef9fe5a95c8de16c7a88f81fe3b1e74d34711d51dfff7ed1e70bcc99b6be0ba45a6b99dd09b60bd01c44aeb6dcf0905ac054e24e7ca7ca52206d357c8df8183143ee154b0af10447ab6fcc33efca154de424672d4237ca867bd06304a2dba530db7db03061082a648c0330300f1d0143f27c06e646db030c856d8a230b24b71e7097a3028925b6c29233ff096e96e0b2e22f564943cd3f5f1ceb4671debcb4f84307be94c8654a511ba172b3af1bd37b2acca89dcb5737a9f29fe35e38943017339e0ddf2937066569250ec56b228d7ef2c96f80cd4a074bf0c32c35565ebe076888956f3ddaf327ddf7e0704c501ca2ca2b71d45d59aca17f24ba23f3d30cfee2dd068afbae8ebb6acde54879f602de23f1c87e0e938c0999b1004976efed3beb5d307cdabe906cc95b013a65eea95deb7875d7e9818a46a2f6c7c8f434f32b4fa2ee00228eed121468ee13cc84fcb1492144b8fe1e930886f4dd73023ea6652b064eca31a6cb84ddf066c29ec3ef7d0398694c16f79e9e0ea3dc03b2977982b2ae5799973ddcfcc49daaef9154a106c2f01c93a00e1815207d311e261df9a677fe51b9c57217483e2906b7be6aeb3b5f487388b5b3818bcbe755723769a3685ebbdae32e837551b8ee736837ce73cb57c3b2208aea0921d34bad50d814e196fec9080aba9bf36d8315ff3e5eaec870af138b2a860d69d04e7d7133ff7b3dacffc7136e42e1e88eb84f0351702615da2741e74678c9e8147bae0cbaee5271253d24fa50e6b2ed6d140c90a63233b879f4d25783ee119b38070819ab3c8998f8a8e8734a7616b27a22db911fef1f12fa53c47ec00c377ee521ba03ec4b2d6fdfab14ec2b24d9090d2a3b953264a1c57aae779c3de85ecf73b6860e4d9af7af2b343e855b441dada9d6a22d1dbe366bb78e34877fbffdca9241cea31b68311974ca339dad2958802c489e8e070c707796d7fd59bcb954f35ba09b41b5c4112901334a8f83505513a26f6256d0aa99ca374e1e1288a8d6618721dd0141da9947ec6453604255444aea3e328949dd04d7d4767fb0a234f1e3e689536d43cb68b68df514f22bb693f759896162a27de99acedd008b0d131a11ff7d50fb7e0fec576d0661927b4a2e9ed8a78368664726e59c47c334bfd3d21bc4417080c6c2c046dba0f8131a136fa958eb76a2ebb9531758fe65cb9e8072b59d9da908e283501cdc45571b1b45fcfe6fa9a70b3c3f3e1ff5073b940657e1b6924e566f680b88314dd9a49884e29dd9ed174302ab1891fc8d094a6a999956106dbdd56076246c47749b706d3c7d8ccf7102aa6d54a87fa403b632e51c5729d07af06edbd8bfecae5f2fb26b5688290578d87b35991915c9e266147a78ecfc69cf9e41125f80fd2eb543eb26d9702f40019c806f9ddb0350ad2bafc4f5fe4ae3a2105082ffac73d50e74225725f3d00063eac6fe78e911c06343bfd6f24da7374fb63f3a2c4ee81b906456633cb16a02838959e79db29444a2a0ce3727765a6b2d828ec162b903baeef89cfa3a23a7f49b5806b31002bcfad6e75ea71c991fe8dc4154e31c0b80142b8a48a3b94ae5061039702c04f0f8dcfa518ea7db173ac9e742e80a54b791705e8f020962c272f95204a34c073731bce9c36d5b713d7a0107c23528a119bd810f7b3c61d55b9c07b06e1292f334f428dfcbfc28a4c64c4d110eca5913c58689fbac990249723e8bafffed6e4fd10aa59aec89eba0459fe8bc3b9e2bcd3774305139a66fc934e8f648fa9492863353daf52bf043eddea7564911f558c032bf65e1861023fd9c6b3d605a32bcd6aff83366601bbe00be68d5916b18f110e8f1767b48c0afa22fa59fce68fb210521f6f4cb37a476cf326f122eea2e157bb9cbf9113a7b48fd71902ad8ce134d01cc62fea95c92a1dab18571f2988836216b34d3a7623c7d86f178ba0349ea070801e591981120d060bcf7ef1001e270fe5f469102738ae46ac2106670658739001fa40b4b76ed62e733379165a97c6add8eaa4973b0416582760da758fd278921778955782cf36aacb0e97d4cd1e6e7e91649e3d28e8ba0ddf5a71e929dd1e0062141e4e76242fa9cbecaf0b162317ccaec6e61c22bca05feb4bd1fd1e2cf95fd64f7799e3eaac9db165938e97c53375effadc899913717cc9da346c9b37e11f5fea2d43805added9716af4c4823353ce5dbb3a3d5e454494e2272917d2bfa7fbe8f24398de85f2cc07c92aff744ac5f9154d7da34bdd337d88cac5846b2f563034d8930f36572fcd5328f9e92da5692c818f0451676d2651265f734f3002fc6250693c36c83052a9dee75bfb5cc2291a10471f2a74214b9f01fe87883743961d10bf064d44589036ffd56194a6c8046ea294e36e5f79a4b38216387cf30536a11ecad8b54a1d77c92b4f9fccccfa20fba0840b51ba5dc382af7bc2c1d51a70de7932ce6b9230dd7151079ef8120be5453a7a9398c54d04005cf6f644bbc757066e6232a130aa9bfe2001fadcb4dba637396f195e33e22a27eb390ee112803c431b3abdbf4dabe3791ad92d5e01467d06f2d1cbd5bd441d5559dacd99b392fee16b198447da69c03b79cf97c2f19fd31447090d7e665ab2d18c750ad60ad29d50c765d456d92e46dc6b4bb4695ef349e95a79c73a96b9d335dc534db8bea0282323fe8635f460471b8484efe40cbc611bb396ca68ede7f5a6cd90993977b3495393f8a815750e7db8d4d068c9f1842e616c7987b485a6519f141fddaac52be8d1685db96f0e168ba4a7620444285222ade68d3505f8f1a2161cde381edd5bce7d90bdd4aae645f32bae6b4e58ae175086c78d8cf45629f0150078bb4102bd2a96dee24889ea3e53bf388adf34354400bd7cbc2ae096e4f5fc4fd76c142c81f538e08f8b5eefb22eb327ce5fbd57df2536ca72aa19a3db0533f4cc2c9bfcb2d3c1b24c0e4da8afbe8c1356704ab25c8cda82f71d7e20fb5c8969a90dc039cfba4ccf5c1fa549e8bcfc7ddfcb3421cefadabc056f237988cbd2928a69e71fb231cbb5e93ba0250f82c00b56fd4ca365ea6342a82fcfad15876c9131e441cce4da47b20b9610addefc8807fced013ad03331f6dcef38535bc660b735c91960fcac99ac5edc4f513d4b7647d0a37b894b80688c1b3a1d2a1bdefe0daeb02e4e440975b332d7946f7bf7964ba342ecf3ce338f067e02b81e2c6480ced3dcdabc972c94415e27b9e8f34634ee47c739e7b079dc86d865dc7da396618735a0f5f70d637246f00728610e9cf8535e0cfbf39fe5ebc1e1414aa9b3e3fbb3ca085bf2ab53070c2a8c39d73edef4712a9ce50682bff3da2cf069b4ade4ad31b703d9a6a09bca4176f1d72c0237382d24b65ae38ae3e148359a7be1bd26c5e2f22998760776ad1b275a0bd66ae0d731bba4a5a807e09fcb80b7d632567b542cee7431875ffcb8292b8d3592722c444bf95c840b1abf730679f5225b1a0df4707133e58256a67a7894c02b596bf0b098211c7af8a8159acf81aad5c0eda64a4f33193a228e239b9fd1841f003c7e3eb7607a0618831c4946a6488a311ec5d7ef06e77e36ab5b81e5ed70d5364fa873f9608612807c8345491b15ae717d3a751399cb72f1be29a09925900b74437886fd8c00eeb194c77c2534789a2f67550346cbdb353f9e5214f4cb35c9a59fce9dfbacf604c6ce756fa388fd4244e67bfe1732f162fe79c6b94bf4c9fafcf267c97abf47e3f94a24330c0a475e58d41a2143378a65ab016b5302c333ef30b909a659e142750af58197e69b0c56d9a75e58335594c69b26cb8979f969a3f1c7300b9b3b521945505a3c2d7cdb492cf30a89728dc62ed8b41bc13788b206e82c45bff6b193afffe8ffe291e1c66016073bf5f1e52b704d3c98b934ece785f5669457fcf81715425cef785f72d2700e25c73fa2fe9b60b9c12c0ac0910e37c898a68c4c9e1c6af36fa16bf8f55e78b9fc5e99bc4573ebfe527304ac26c5a91b2eca4fbabfffe897ed2ed384f2514559fc7e7df6d6ec0d0b6c807ceebd62b2fb02f97439c0a2afdfb3771c019fe663b4efb59ec5a4bd1f4032c6e8284c8f2903ef9dd327318480d55ca9d3073f612dde5d0e43e450fe71dc269fed5a7aadbcfc57bbc96727174b8bb48b3a621c06f6836ad0408730e3a2f06484485116e1564cdfae59585d0ecbaa1786a7840aa8cddd2450ed6c7fb2a1d90671dd1eed39292d3c0e0afc41690bd64ddc675d8438922b95998c3282501f46e7db13aec98e78eb8862e16c90b19966d2527e32b17086d45760543dfe9142510b0c6ab237cb58d54cffdd3f860877ad74181559ed598f97d9be8c34fb2241e286ba918f36acfce1cbbea8015cdb6a40c171d08c32c501674b2c42a8e96d00a733609ae490e41fa3597cf4e07ac84e3349718c76208187262318f172150322104a912b37043a7dc3c41cc0641d359b0758ac279bd2c38891fe8eba88cf193c9b4f07d132c03d330a43562774fecb6709e8dd6558002efb21d5bf4f9290d62c963ce71e67fba267245029ec3cc3f9ffcf2b507c3ffaf327e1fe6a0ec6d78fc42ff0f60f5654f9e781e2f13717e43c6e9451f83251209a0d96721735911d987ff255e08d94f457dd90723c7b03171dc8e797af28b2a6dc1267758c7b50c99522a582350607a8dd81d0ede2c5346e3ef0315b273adb150196a9b3774f2269d82e6c2f28073f9be8093e1cea49fbd7edcfb25314d30cac5de4f37b083c703b8b45b9f874dc9f46caf193cc11d21e0fd3a21f544d89c964dab3434659ddbb9c400f6526a458536015121d58e8b9a21f9e4cb61719de5cd32bd0babc3e9e0186f32d77fb401dfe4293c12d35b1d114f27484fadd9e0f0ca55e676f0fc5bcf5825bea291d55b1f7e2e0c8cb5a781469b03b54718d7bbd6838615099964db4ae11afe6c706a68bbaf4adf019921ef6e584467ca2be8a4ae3160ebf295135b5a10cc88e1279e6c3e0da084a10ed3c08fdd4c8687e89029b53f82fc99470018d9f672c678b5d7b421a2719c0a74f457ea6b15f66c12fdccb685e972a5e21423c13ed8b523fec5dba2472e2a07714f0a6a98487bff91a06d6e49e3933eda47d012777182aef99d0b1efdd285612409377cb07b12f89aec296e6e3d9d638ff5667d5cecdf5969fd5952087297edc8c597ef84caf93a170079214202bc088dd3fad8a97a380b164dbccd44f56aad027a855da821ee5f8e5af86c32cae7685b6efbef98f23c3295b64f97140ae91dc598028e6ed28648570060afde9464f6220a5fe06824932ec1be9640222c3418222f267bf544acb908ae8c2acb0e89e3da0dd24232f0cb2f2c2b0d9c5104ffa4bea4450ef9f02f5d46319c349b137609665adfb730f63fc77736e4b984e3ac6b4217e6dd234c98aae77d6ac3771eaffdf393c164b83192ce68d49ea754f6b3d5b995b3ac0b4aa44cc365d0e8c7ffc7d10e20d93c3aab46cdf284f000f6e005390d92c62e199bf19ddde207b7dc99c8c7ed41d31b4bb7096e95edbc5c45a2f2ac48f086abb5204f6bde0e7dbe1557202e1f573ad893e86740c014dd02b6fa1be698d54779d565d618f0c9d37bab067c606a8001a24dded720b7306f340cf4782116bd30a8e66d064e0af9bf460035afa8c5953cd0dc8eef8272d6451a52573eb25c6d7a5934c43d5c319723636f7dcd92e1f8122e7219986edcb44007ef353d35a71af0fe8e29149ee986485399a5d979ecba41abd09828e978c688e89f8a45f4de3472598d228af65fcb83f80be8ee03c19d586c275bda7c9ec9deafeb7e0f7174788eb642c728f014d73491e0d90f2537f04e01e064fd266c44f352662f3c889f6eb5a9b401f3e5865d6f83c112d3f6b7bb0a93a51a0b3157fea1e29e638ade60bbf1885371d6e66773bbd49c1f1df57d81df707c17a9aa167988db04b5eb102054471be6afa72c02fc69c79690bd16c9b09709bb048f7389aed45b77f90d01237fc17e177e0f614bcdd9a4be3953a5c79f5f7ffce61007b70187f6369f865adc8f091db3408fe1e78486ae30ce05946869b773bf2b56e36fd556471ad3bb0fb6dfe57f60547be401d52b20518f47dcc326de3973ea3bf4736fb3760be0d1b727465b746180f4dd2cf53cb0b22d45ac95edd6cea7626bab0d37114c8fbccc158fdcbdd9bfc4e8e7cce60a60b93d6c585a79fafbda59832398614bfb82d0b9f66695c7510327befd6ddcf71134aa79d821cf3b2957653383aa582bd826023a5b0f7ee9c9040138861b9560730f27c4b7a5ffb267d28cb66ee388a3f952dc96522c8921b516cbaf85cdfbdf8eb9ead704f76f477a55ade9907ef3ee03a137db4d33203dfff6063c8e0318f225b092cd1846c6081bbc225ae9cd1f32aefac4d7d1018ef721ee9332f5348e2dc7356acd1724df34ef483f4c224d5de8351a9782972a802959a7600204aa4c384079afc030b76b722ea3cb2769549fdbd17691bdb2ad937101612237dc7855da81812bb213736c4d02d05f4cf4e445f1cb58018c4215f3c542535c8bb2768cb8ef9c4b217a4c3562ceaebf94d0a3a79350ea6e5b3389d57080d30f42bfe402b938c6518b0fd5e92ecc64ae77a4881278fc0065f7053df3a843eabcf9c8d34c86baeea574c2cf64b23530881404f3329ce6bc75a8aa8b5069cc50a7337680022d894dbfecacd7c116599ec16892232b156dcf56cb2491b69e745faa091267938762ae77935bda5d0304ea4eeebcd4e929501d986a781257d19c437e7279d3f926bab359b1c7eb302b612bd2c461ef57549679d66edb0f0109ceaf6e2889a64f0e06641c52ac62a305c0ee394d37f7e077c5f47afbf779ce1ca7915d5ef1f3fc92e340220f9628195c06a0ff76aae1a6393625d6e9239467f780f995c54f40a60f248b7e71098b3fa2c610aed9e52272ef5456e6d72238959af69336206e9416435ea0f1810b7458a016be471ea7ff89104bf781956e9dc3410abd5991b7bf9978978e85acd50e26f087de8d8d1ce81542eaba38edd8102e9d6986fd1baa9073c699e0e0ed385507e06a92f90ccb7513a17e9f899de098e132a019e0bebd5640699d2ce3bc98b32ef59e8bd70b87041f8cf0c26b17a784254e0f594c2742bd13695b9223d7317559e3af2fe57ff608a72022b36b39c51318cd3d6eccea6305e099bfc03eb9b7c4a31520a4a5078ba55daa14c8bb1e3a5adf5d5a08dffbf32222ece4df414d3ceacfeb0e017ebc586cab85784f6506e609992491fdfd0b7129a7507640148cae763bbc0f81a7f5de6630d3de4ca51dd8bb5fba0494674062f9041ff3a7df8e7dd2f96f8405bb78fc81835296a3ede470ecd6e44bbca93a55a5cbb569bc36247ed33a3c7e2827e387fc2baf7255e74ec2cce07aa9bb6aaf3a616fedafdcaf8301f1a29d15692f72e036df9ecf650f2b328248eb92ed85e55b7af11e9746ebca6cb5c58d4ebd1b24d60feb024f065f64718865440a6b85dfbf1aa8786220153826240aa1c86c753ea1231487044f17ce29662ae9de5e126e2f90b440f9462863fe8950dce8bf5f0d0cd14f148bbc3482dfed8cf0cd0836447d32b36d5c786076887f25df5e19db6477d1228f47a8074fd31c70cd0c586041fa8bb7327656beb6c27c073ad97d8e41e946db43b1bcc1a540ea384153224c197c4a05209d4723ee1fc49e09f5e511fad594f330b296c46f80ed209bff496b4b78a1ee5007038fb309c8b4b11eed60874c53f6583794e9fa8a29ac96db126c4658013ca7a380bba4fcde0b862b8dda4db7d28e1f1d784ca7ffe0d40823f5f0cfa1f8b0a6c4cf2b2e87d16e3f57c2d90146c0664392002d8283a71181628ba435397ab716c87947334ff9964865afa51128c64d2f2cd6f1ec746f54aabf8967b8f767caf023860cbc171f6161461c7ee66a81eb025ab5bb6ad530ffceb2c39c32e7d51e2e02ccac48c52cfe501a5cef116594904d1951462ee102fa35ec6bf02d524841838a834ac7d3f9bf2ffba32c28bc0210f91233f56ef7d47c5b21579c1fb317bfa2776dfa8cb7192c4a4f685a5c7ede4cd39b8364f64534eb8fddafd5894a9a2108ba04a97230190c3dc5b75de50c81a623bef7123afd0c217d4c064288a473824817e9cdd9489de8b9ab7b57096976ac95441647100406274b9b8017faebc723d2a383b47a4b6242bea89b882039d7719b10bbf570096555ccb0ae7733d1f5057f52a0efe36f1a2a8dc9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
