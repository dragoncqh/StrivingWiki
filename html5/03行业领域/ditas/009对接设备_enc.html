<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"71e8149ba7bf296744cdaad2db4d58e43d3ecf9c03a73618d694b5e405d0fcca504b8bd71c7fac7b7537adc35a7d73cb586c869646a6b271adcb1acf71691c1624933221c39de3dcc57a5b07a09e5b2f08cbf1aa2bb6df8036a03444a4c6ded0807eb54f8a7a8de056fffc0a8279ba68a3070b12a4338bff1be85c028135a13c898234fd23f841330950172f470c84ea6f9ba3e178cc3196c2554f3f3d8d07ca2e9ed6282e94b910b978cd655baf2c20fa0226d3b53ffa99e174e2997fffeef8944ac2065bc177e937a83d0149a2f24d836e0746c9e9e556ad99ed3dfbdfdaa56ba1cc8ebcaa61ba75b665b41e6aae894ecb40afa5c71d750fb1ae311f43f3852452537291c2bb1aff1e979889321a1fad0cdccd65aa43a24b8c7f25a82c562d220e155525104f14d626424028b727c4bdb24465f41f261e322a91ad687ce2bf8b324a0063f67ccab6c1d16bc4ba74a042d49fd043f6070ce353c8625f81800024fe9203e836dcd493442cd378aaac639f78c2704a3ed608590290051934f95acabb58a056772335bc345ec1cfa9877a95870bde3027c50e50679a3c44ac34b5e65594655367b0deaa1ed919ff409270c06f02e609a54d83db726d1ddd6912828eeab54673ffc7251cdc81c4e318834647e1919ec4a3564480f5ab9941550482b809cba7bd5a469639c83570e0ea99d550112a2ebbaf7bfc58b27627189167184f60d878184f931ec76b0f85b6a7a6ff0c5b53c76496e23ade35a08337cb25ca059d8816e0cc45d55532bcd5d060f68fe8fa4023ab3532da9db4cd098f9edd1e9fd99084a717bd1a10d9b6a5bb5755f2bb77ca2a686786a8cddb2b27959774b2af71e012e64e8f90ac4f38c9701c028cba0cba25a538e4b2beb5126651a5419901cda0ee763ee3809c10e21e7f2d2302eccb3fa4d35113e22e7402e026cf34176c67022eb6e6640349ee1236d4f2c666cb7e84b14b4443f57f04e9015df0f2f9eeca540c8eab461ce7310b62eac9fb20a3caaa283669b893e45bd118f43d366cb4e1fdc3292027860fcc6a75623d7dc139a08937eb2ea61a02e39141316714795c10a9af326826feb595e78ce2be0aa90dd062589c58e76df91aaa7cba98fc892468c5192a56e83920061394e721f3dccfa662046c13121084913c3cf3b103b6f8d9f27235189497c07b52331786ec2b8b1e3ec9c6d928f28e8921d602ef526f5bdc9019525a0c991238db4a49157e83718c1141a91234a7f29fe5e037054aab5a843dc350a2b1e1a005ca7bfc6115f7468e3ddf00b75edc578903b61f0f8ec364dc68ee205ff5c71b376a8b2fd4546a40bf3d974e383687e06b7e143e80d107b147b3ba4a65bbd1af0d4b16c171dda7eeef410844ce189c69d8ae838ca62466e3eb85056c879ff9cd5c359cccb3dcfec064f6525e11081297a6b5963ce1f185729b6f2eb75ead151d219f198bab41da2238e98a80719dbf6604f9f5a73f4dd69f7fe9636e9de154da0c074124d5f05c1dd273696587e2b05842b7c30489d7b6d0ac54679b64348e47d26d4eace697285ce94720795fd077e19793edee3750b39e9affd70b811fe14ece0c9c6014a05ac718b61606a5157bacd62f9c3830e6bfd38c6edf541479b0cc669edcc9341058ca1d108a0b537a2eaed0833bd44735b3b45545bc2ec2217501189adad8376d7f0ede89da1f964d23e83a33a77dbec0e63242f6b2ac6be6f78adeb3abc66762bf55bcf56039700584357ee6c51098d52ac13417b565ed4ed06a2d8ef46a50d8e52d85d2756f8c7b5f360c10cb387b1071d1c8c5f4f49f534892c1e21cf59fa5de35aba08c16c0d72b43f1a2a6f97427b675b65e4a29392e1384c58c96379bb108b6bc4eaa146aa5cd7f53141a63038265018db99a8e17fe7150d05fc8f5a4c4e0a45d305c449d6bd2e40fe7c3b7b2e49c9deccc58ecc1fdfe5bc1972f7ef8060705c88d54ca8a2c1290d871cb16054c90d40d5a7d74d071186ade41acecdee1984583226fc97178a6de4c7982b3db0e40821856e2906e84b9217e9f559c8a1d57b6c67e72ba74a6825a8a54a924a135f3302e121c78a4cd428cf47e52b58bc4b57c64e638e91bac3721a0f1502b073c67aa5f70de3a5dc58d8ca42272a629372ba914431f4965f96e4b6308778f1b349d962b31d1e52fd8a2cb6cb6df045992e4c493918e08d74a502d4b78295dbc7a09aea6e643c6e3f0e9e008e54126bd3f585fa25eca4f7770ca0a8648b672ffd47c9d8450943dc6f84076cf48f0e3964ea46d9850e86a10045d13248097bfb1afbfaccb71643c22c121f03b4ff9487c629d5e6d01792bc0e4d9d17f0f550ab613cbf4cac729e5a5543514d05675571006e48831004362e31ede349a22fb4fd0974fbbd934926f5f3e9defd8bc209be76d23ade881723baae0e509f596a392a897f0bc11ef601007bbac19c2b8702242c6dbd88f94f334e1b0cc87b37d0132c3bf04a8fd1f9c8d72fc409c86fb33e8c624069c08dee03a5d0504cd8ee6c3838dfe913b705be5c3678ab18eb80e40455734e558a66fe77b55612fcd63160d5444fe5cd4b69e8fefafc9aef13a2580268bd4ec4e9ec3edc72337d092e00f8d5077c9e0aae023599f0b81fb092670fdf1e31e89601e8c127a61fa0f54cb298f87f5dd8316cee2c463fbb87c65c335fe499f60639657e3ef5f356f400771177c5897751c4855d32ae92eb8acd2a36198559dd60c7027d0f3db7af0b9fdbe3a50bf4b7401b38f97220de52853e4d89d42c1fe7f096f9241301032895fbdad73f5a77598c88e06fbda8b35fd94a96416c2ef74b5344a63e1a11787c02cd0773a8bef1348867fc775fca4cdaee04426f98b4f82da0a4acf40bed65a409ddab6fb98c8bf347db91a81524dc0db66576800f0d53fd8075fc4d039d6fc2c3e44a1bb3fbf9b179d0b0fb1c7d31bbca2e459b9091481a1d76b7a5afaa7e0027639913a88406f695b9f32000becc3824b735c1400c91b9fd39d7e078bec9cf3970cc34f7283e528bf2ab3eff34b79c27374d182bbdbbbc173e331d02471a19669f944de0a9dd8d70c4d8321f5e790af9114739828bf973360ccb31bb5c4b0392eaeca21a93a2c17f6dba49a52a6174ee9cd557a117d232c9aa6336fc698d7b605d3739c58f3496ad057073f6ed76fb62b138d8aaa2197c351db6d3eb3c3813f076391c29faa2034141e3aff3fcbc35f9d266424bc562f7a44a0c849b3ee4afeabe732cbc11fdb2d282b6d4979228cd06ff98417447f467dee552ad0cc141f7fc4c498c504d739ca64351fb2d4205f105e7e6400c877e37caa6b4bc10ae4cc07829dbd79d8bd9ab5bcf770479dc2b621f06196839842ed9d782018bcffd8ca1dec8bf7ded38d9f11e88822012d3d5fb2bfe7b692651f3a226a62485a515b1c2f4a1c1e52c8846d420c4950c5dc9b4a9aa8b26a53e722728f1fc3dc3c1f53135b0e7b4c097f2ac23dc0e460a4889bf69df290a84c0581490aab374e0048f31b21bd2e6f009caf567ef24ef5cb16311b7a4e81087f307d7cf74db13b6fbcf5b274e5ab643b0823ed35f61948c1a0127d6e6d1da9d2132c00a54e564b29081fb84a4b3a53df62516a676c5ea5d36a5c13a286dcfc183d7f53af26e96cbcf48c06a86ca1826192f719e1077f6386b3193609b9913f5e65f8bf7f7df13702af0b4917b6cc73d14f9aaa35d83c840f0fcf3b5b92bf497b3ff35374b8e4d84afb946731d523d185ecd9c46d3393c61c5bffd1b4065d53a1b568e41ab478c83abc25a9a194af0d0974b9e9708b160baecf9bc43995607033b8f3d3015f3f0326dc05ac55ffbcf9a15011733faf0cec4b809c9cd622276aa833a2ebec77b2baa8088761ab6abb7926cae15a8310e9312c7df4295c378b7e52e61882eae548c9a0f113cec807ae40c97b11eeba9e527e4cd4e83da2f418d23c845e5f4f26e6aa2b9fa05494aa1fc4596e82327b60eb3649a368955977ddf28060fe931840768b1f5333e68f709d7dbd3f19fd59632523b9cd068cc90c660c6b9060d8f048f05fcf0b96dca237fab913a449121dbc06114fdeded26ccd73f083284bbed35a0e05f72c485bbd06d967ab44f42340cb92ed6538304283437588329195519a98c10ffa72dd1a53050cf53160f01f5672799af7eefa9b893b4f580f8099764fe09d6940d177ade69128e3972ead038b289c08b620faeb0da91d10019a6d310d815e1b9706917a42f4a24a589f751fd94ea7e31284744083972f949880d83c0e817867b5d97afe907b511433ec552e5a72dd048770175679bd433c6f4ea0ac7c65d75186e15da53ec1f12367d9f0a13a8904712edc849528bbd7e9e5ba7b02dd36974f6ab0883948ca4bde376f466361240782f0db6e3b2f54ca40f5547962cc8fbfbf243eecef0eaa7c1064c250987685298cf2c1718d3bd7ce3c3d5fea449392c2bdc45513dfebdbf7a08e20fe2a204a6b15059c7624823f825b41fc5a03e334fe5e6aade66c3e27281a50c9e7625b30f4025c877690b4a5a4f06876538a673557053497f6e29c96fc48d4cf0dde91ba5c68477c75f82baa5312bb2e3172d598c604dbf96544df1debff4626a9a288eb488a07161f46711cb473b71c54e7bce4c1c35c35b53076a8cb6ff8c912914a45c66101e162a8bf84f9ed341f3e824d0d0795b493c1669faffe6671295d00dddf49dd7ac08e2ed56c3f7c16517b47e82a1edf3b22830ff160505af399bc1d6a2b1fce0c4318d4ddb7765695dc10182c00b00dff9a21a31a93856acbe82f7cadb79d380b812f555e511e726d552a278fc5238a03caed1eea887e168cebe883c6b779a9dc1e3f6b7fe64d5d8a76d264951128d4973dbc7d47862d32df5c8c3a4ed98d8309f59977a432c6b7cf83aa471e1a42dc35bef134162c2ad5446dbc4756f544bd3b37bf2871661c11efd867225991de1a56b1e123cab53f5f32a953798b0987a1a667cc54e3c28d120b9f1b55c19dc79f4ece94f0c1c63b82bf09d2761babff806f2a3705856cb0936017e36c457acc6010c6ce0ebe6ace96ae9ea21223ed98f3c67728dc9eb61d8a254c8f77254baefbb17f2b2bb00e9db28901a543901d4513a4469d5ced334ae23c0c013d5b6ad47a8f5a2cb2f47bec28438c7b6a9514acf5413f1a6ed861d654b45788c576cb8be3033934471b983787a9cbdb7f5f69dd360ccf5e00c9a9f9a98eb1bb515040c677765e890ba7961ee114c16e00953d3761fccca777d6ab7a39d562b88afcffd5ec86918494dd0b0e85353ba075d99a7c0070bc67a075e1ad9d58259951076b8693cfabcc3fba5df1eba1d9cd50ef2397e42c6b4e123287b4688f1d0deee0f8b11ab356ada95aae00c0a1f7289e72db6067b793ed131268f3d5be0192da67dbc314646ab4e33c9f87f2ee6e3ecb0d0211904e255d0501b8aca963f816c875e2c80c2080c1110dadeb57b576e4f3bcf033eeb6eed41909464ba4a83269755220e9b06da8d2dc2d816d540492a247d3167fb94a4fadd21883862ed6722e78e849d474f707b985fa1a8f1bd675951b0cf306c9eded485f6e0a512c135481d8728d5b1ae89dee01261b4e7961fe91b7e88fdce12c808784ee92743d55ada794a3130c54f381ef822ebb34d6b11b3967e8a1f0f3ae878a3504307388d9b7d2e8541cfc5cef0cfdfa3e5e0ffa685f65bc0ce5537191f0f0229ea4babf24bbb0c0a5aabae32b6db049ec05392378245440c9cc41034fba1ea021663762db89015a2fc294bf830b56be50e87e98970a78237e69e018c751f6a4fd60e4c8092f038fb3d8682acf035210a80974c7d7660e53cf978c8a3992d0337af67633869e9173e1a9179f1fc3874b9cd2e36a2584dc07065d7d6f1b3e5de98f6ee47c6cf77aeb7a3eba0262e08d1a3f960909a261302e5edbd62775f615d2342faa3eaa61803225c5fd8f02010894250937d3bc8d93e7d84d3e720ad42bd095b311005eff612daeeb7fa3906e33d53f8cfb0503da3cbadb4e7c76cb50babbe7f7120bdaf1982d2fdf8799ec3ec88f25058152593bcb4c8513f50e1fec09d267886d7dd9e4d0dd952661b5a601e9bea5f2e0b7800860ca73f16a505b40944707cd1946f807a302e167cba8b497843c29c8470ddbf146661ed76d10212d5a79f6d50db4b2d250cb484004e49f26b5d0d8361ef7d832e41179994dba2aa50e383f21cff614726e5faabc5ab21778a6411f1a5cad7bab2dfc46c7a904ac789bf8ed44104113378ba763133b2a7d5427fb83d040dc3975df270eeac257183a4885f849be7af04c8006999dc3258410de8ee18942192660297043c33eda6811728ecd25c5e23f0804343e9a8ebf59dd95e0852178de1b4c2bc3b806efa568c0b92beb783f59dd479d5fb272d3e170a0812fab2f6fcde456c97e3c9bd49ae873d69b3893fa38761d96a901fe40ce12e150fee8ecb9e2a36c2ee578c67f9efc45f18fb8a67e30fd26b0ea42b386a9a9a56b8428a6b4f4f33cd6d11e8c08b78f532cef158a9d3a99fddea978e69ef6baa04c6c46438ad10ffc8f6f85a7e3ec9629ed76a0a6ed9727b3d8cbe2ff14751d61b21aa4f147eeebe4b8c3c0c4f4fcf44e3ed85d66b50f715518d411328f35703fc23b1b5e9fd4ee098bca99a7867c695c5d2179afca6a1eabc6a5be81bc75e8fe685b452ea8a0a65a7fea297f7df9ac60f0f1f353325f822e5db42bc4fd5437da6fcf4341e3678b41d2f67ed9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
