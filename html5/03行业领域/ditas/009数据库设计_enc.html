<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a93937ff9b71b9a7550e76d8a98120a382338b8e84d9fdfcf8796b3569fddce202b7043692af05629493955ffa5f8a523af4f10ebd50a68281152f17779be4c10fe717a32660fd492525549a104906882a8e02bdcf0b6052bfa81889383b57f0114075aff2534f8d3beb9e604f24bc280d358b8bbdc5ffc0ca66d9bf9b1d83459bf7ae3fd1a3111b3b097e6bb6422ebfe8bd72687e0077057ead4bbc6745055213db3c511fd0cf8e154d4cbbe4b22383158200809d70d487749941dc36a66c2f39cd00dfde4a2157d94129059ac7dda1835350f3ec2de4ef3ba451f24d15418ca25fb7007cf8db1db07a5b7b4ac40974281cae17b594350cd0a0f0e385f12de0e23d0d03724cd5db7a720300051582fe85e8dcfe95c681414dd38221549436c9757c0f5a9777c96352ef676b90ce466b2b6389bdbc60171e2e1e1abfb86a1608b9e8258a6b9f797f6c3a0daa0b6f592da3f79663dd970bf46375cd375fa7b0286754578ceb39a4049a9cee45a987ffac5c4c3fe0f8ed47267d8020bb70c2bdcc29907f8e5f3b45d682371346cb6c4a3e5f674354fcdc35293bc113993d1485bcdb3104ddc46ee78097c5573891a57e33ea4a5cf1c0051a95b3d1d1149ce2b6e52064421620add7d656bbccc567a00619571e9cf5b9dabe7ae4c663bb2a9c1c3037405e1a704e8e1f6b637cde34c38bdfc8d01534264d459929ec4525c02a0b1894188d78bcdf4e609e9511aa45304929677e400a2d0a2587b0fff206a6a61950bf6438f4085bf8e47aa5a304fec411bac3a4d6b76c02f9696f153a8918fb09b3d5399b8ef8f94681aef0a45df72fd5b17c55d1aaf16ec1eb9714bdb79549c36eea1de6d387645da85731c45ade2a585862e2644de3992231dfc491851d78e4ba3a8bb07327ea2c1a6a52f602c7776597be21522d73a8c282386322808295026217ae7dbe81494234192252150a690189e97160da1bf6bfbf4be56a59000e2fb6f04793673f9f9ba1aa695e2c6beba4d4099c21c006bc8e969c513fa47a11577a80e6f7529c9b5ba1777c029932676f6ed079ca00c79ddd31dab4cda6c0c36fe58b9bbb0ae15dc5d75b9b4338bafbdb44b857a679fbecc285ca616a7e8061c0610711f12d59c5ccc53ece3284faaecb26595e976e9db32142dc672a6e048c62a14cdac08cc2281e4577cb17adb25ae8c1bab18ac2620c44ef1b41db3843668972ed6c864266ce8f16efea4be0aebddc975b050a4b6d394cb625d6c178860f1e8ae97e37f30aa62b411437434a2188a5a2226cd5e137afc51079d14f09db0cdf54980ac21a46c2f36a30e046a5bd1e3e587a447946e2f035181ebfbdf24bacd62b8981a88b79c77798c78deb8d1ae0c4095b095b9b955dd4ecb3a483e41533085b8c8ba76908df253120228749bdbf5b717b0c6697b9470f6f75fd04317d0a1fa302e8131d1b12118622c9731bf284c7f8ea53fd20fbcc2995a4be474ec8e58f469d2b136c2a3d825099a744888020910935f3c2674ad737615918feb248b9778597290f01e3c5c96e99d337feb5b95a7227e6ffb0a8a2c0c8c6420629791c53207596136c8a64bdabe58929665f3c6464cc29931b0cb67d3e5b2f271773bb5f8ad930ee2e1cf2f7f94f041842ffd09761795e65ae05311421afcb71a20c8627ecc93f65325a1bbac8abfb19209a41ff3ffef459d59e76cdb426cfa956de6fe9fce2c1d7d677383b40fe93802eddfc8c63c34393e42e480018d2301cbcece78722c3336cbad028251165e3d96a32901da10958deedac9c38c076a3bc0bba229569881290463e11c00d88437e94b37183942ab015ed7a9857ab72a5ba96a2f58c18422f1b4c0ac0186f2d9f45952570e62b43a1872a06e7eb01c73f0a9e25f1cc5edbeb8c427dd98c25088d3533657ce5e2719f93ad28d46d7898fa3be0b98d426e5180ce2a1e52859a4208f4d54cb06e695fec3f6fe0d95af717f82b04a247e8f0e79c4879a2892e2a3383556168f6f1855706b85060580474fda6ce64b2ba5fe976fdf0720b21c6b258fa91408437d42bd9e0956d79d5a6bdcff885fd218750b1d7ac3eb6ce79ed51862f0c4cd9da06f45c79be4307964f76c2397c9d12a511b009be0f4d6daa171fa82a34746a5d412e0af62fae3c804b21158b3555c37a11df82ced24cd58b72ad732ae6cd68df664110233ed9c3a9c68e3581cbd5bfb630bedf903a728df7a1111eece55e5e6407f22a9f3a050ceefb56f487d6ef8b3a77e694dd0af05e18b804a2dfb075057706b4c681c0d6d531dc4e29864707c8d88b54c555b6db87d0ede9b82f97860faa6d80cafe59fe07cc3aef8eb89710ffcb4f516a3ff584d9db21350d19ee09fbc3b60f67f3700c7104226322864447eaffdf0718b244907735d143a4d16381df3739a0e24da144a2045b74ef7382220006e12c25e2cdc1785e738711e8fe0bfc3f51a1861902d0e060ca5b83a98aae5251d78f830df3f0186a9a99dc4bbcdf0d6dded584bd3d421faae60e905f8c1c4d98b7184ee1a9d557f4d5fb7b4b709450be3f0b733688df29b3945e43a923745c6e5cbb2ce19929eae3e9ca6a04ad85288192c22367c7befcf900efa6bbdbb85835ec0ae8d4f5329d68710743a65f91d1314087259f9d1214c2be8ad22120d4165c50998a2701ebab3df5982be341919600041021cb3a67c126478a0a3554dae4ec952e80ddbfad0a0675068cde1edc91c610a50838a910711a7e14ded8680bca6430eef22a3f710812bdb3e793350c3c19eb24994bf6580ac63d02ed47c9cc5c6c3e73f6244fa5230ce785efc5378570f19a8bd6f0746e9d5a62d82c7961178cca248be184bc3c01addcd1057705d37235c9359acdc15a7993c5d358d369cd0722e176f94af28e704c83f97b28270f70621c2b8238b1ae1f177c8e8b7a7c174e877250dd8ee24406db20ae7eef9a3bd6de31e46b0c009a1d4450a797e5901edf47210a3cb6c96295c85dedc2ae50da8604437c87d7d781dee80bee543d06ab18c4f01cdb4f4ab9c0fceadf82c718f99bfcef08c68f7456fcae578a35af8f9aab4083edad2ca88acf1cc94b9898937ec97944d5025204fd3b297864f1bbb78b61d855dc208df0f4c5e7c1a8d837344b21fe523b01ce0598732d57801913e012e1a94735b07a782581928e6b116bf2f987596050e909ff9f9e88a26c3f7b969d07ab388cf9fd218171db8dff4e95618e416950ba7b1ead02508f02b1ec0f34bb3d35eb86b9d807fce611dc2f234ce86bb1ab1ff5aa8184cb553e9cad917468e38d1b8eeec7b5909da03109bc632d9d619fe20cdb06a9962f13b12357d729affaa7aac881949a9c4ac026a43273708f3feea26d09c0f6462b5e0de09f6dc6d077c0c30da19a49b7b585dd5174e9ad525bd7cc1718c0f4911ff15a540f30a528550643db3107844d77665097f19852a9613c58a05aa638176373a2eae146284992598148e4fb3c319d72faf847a26cc337aed136312695be69f3d9ccb5034996c349a6f693ceb8e694af3a0a6d7b4d16cd5daaab7fdb432a5cd220ffff2d034b653705fa1df39d2a4650d23f21f2e0f1e5344b0234d7a1a21e1c510191430d28bfd659682c0d5e2dbd479635adc5004dbb2262e7be6d85c3ed20e3f38d42f8747b8064f934dabee7e92904d844cf0b2dbb4971cde1702249bcc70310f218d4dcbcf34c4011fe94586be05fee1fef21f34d70d94f4a6d9884b374e0bcf5cf1526fd520e6ee4eb23f4f989d12e3247cc7ba01a1d0dfa41ba6e62719d0f4ceaee72f96152f76690437116e74e2f1a7dfad33abeb1e0457755c66355366f361ed67b64b29e1c7c7fcbbe9a075176a802f68dfe9b068de760fcf50c323b5552ef7c7b7110b9c729dc42fbfbfe238d5c4fe23461db8fe921a67438016bcd9754a2b90a784ced8a8fb16fa9974834b60ed737b0b9191c0358804f6d685aa4afae5d86ded11bd567269d953c12a91e3c67d06693a856c7c536e7c9e93b9b151508cf4cbf5b10b6d679cd96cb0ff157c6eae2dc4ee46eb69af660c227a26ac718d950106096d5a0426323b434948f5aab3dca57b7e84020d3c7535be2b2448e4d6dc98988d7da61068a7e408e131855425e9a9c3eb053eac9205b1735c97543ad1631d3201b8ed7b40104f471607d12a20ae5f0b19967e3ea84d3011968a474b6d6d190416184a15fa817d0c648a0a0f5ca3f17a5185610ced53f1ec919d5f9638b3e91f738243af35cebc7201661e6b3fd2a7ce29e30b237e46ee0a7295ed0e364d5490a33710e998221ac208acbbd21e80726a19300ad105dcccc4296961af72356c625a2008992dc2fd718ca40eb30a4904d977565a951598ff5949b08a496f250e6be9e02530c4f38715f24c2a0a7a09148a1bd3700c60e8e669814601d2504aa5255e0ed3bdd94335a49e809d6172f834f96910c0f1ac9d02004e4df66e71218e50dea454b078566e8751cfb885e8130c181b2e78ffaba819ec977ed064c2d9954f7753e30e5a7a012e34819fce79fef49e0442780dfd143520814c4155fbad19a9cfd4b8bca902dafb8fe8ff39ac67bda4c31e27ced588a258de0d189b0888d99c0ce4f225e765a136d494d914a47bee09fbac2a94ccc9e3fe71202d77ae21750b1dfdf6d0eb45fa826df6ee363dd2d3d390f485cc22eeb39c1bbdeb367445561a18964fff226bb014ea2d6c1b93505ca38a58ccf47f8d9b4491d53166b24b20bbe696ff20063d9f19d26c5c75ab16b0f8060f80f5f374be32ba5a2198cd8acf7b6da43fdabc10f6bac97cf0be5dd56c75ecbd92cdd5f709c7922065fcf86d1478d915742a6e651cd2c8c34e9606dba855fa821b23d781345524a422d88c48bcdb666b69d3510d9c3adffdfff25ccef2f92aa84e71b1b220f8b2546fb62e91660f9535086f3834c1e7adc061beeb1f5eb110e83149a1d891d126e5d1feb5e33a9a26ad0da07f99c1f7da87cdadcb0123788dbf50fdd74671f2239e81b68aad215b7015b9a40d276b18aa2a95d3b09a3baa6ef53938c7ca0704b2395dcac5d66f3c3f249d67a99379472f452e6b2b5fe578dff4ec8d58146ec59ced0eef606c94e2234229aa639fb7ffd5091a7b6ab5477f372487224027c08c77c58c1d5ea256058be3cf409858039494f176a23ed9f1781309c9bfcd1672cf890f15e662dd736e718f4067dcf31a94a03c435626f88f118cf8fdcbeeae8e38223ca2432f9cf430f508d05d33072e70f8e851e261f6702bc179f7aac53d5caa774a7c8d72deaeaa7410fbb3beff4e64607b069579674a72cd62bab02aa681bdb706c9de80beebb79d82ba547c5ed9b965b23c2a6a8f82bc5348b2607f3e792c5e79dfbcdfbfea8b905edc69fcf99880cdf19f53a987497abd9e42bfd80555add5ee3d9fe34f39cf0df346c1fcd6d65d41739a060fce0405e6f49ff3b1069f734bf48640aafa3004c5e8f39a14f9196a3454d6233d3ef50778e67eb172c15642da9be53a81fcdb16e0337f7ecade4fda2779f67346f1cc68c0eec73c950e1be0223167ec4126ca912342caf2881e2adfc6bed176a709996b282257d9ced2da2823b8ef471e2738a41e80f678af0dd6b521678c2a5a092b972582265b8a2c10591e01e06e2e6ac25bac63b536e81a60519d5f65c4de9975f698d96d908e613465a44e41354a3e8452953e3914859d976cdc1c04219a4d2439bb359c694de37285ad4715639ed96ed2f0eb7ace9a18e4fd98511af4d8165fe4b98d5c12e435be28e3eefd4f785bbd5314f4888005ae1a32f01f574ee98e6199422627ea5d2bdf62f25591e1d9625ec6cbc37e5ff16bf45303bf12f6e975631aebf69ef2ea62b49e63e45c47a6cf67761d72b7abc787e88b04e26e583b70042e77d5f7583d1612e9a30ffc879b9124d65383bf4680803011d0bfda98dedce87f66cb6ee3d4bc161734e2770d1f0796ecf77a0b508677f01ab32c9e20f491fb2d85fc709d28ea18683ef7dd9927c01c63d86338c0c3411bb4f59e4e62b35e52074bd5b744f9a18393d15ab0d741de2c385302265862edc2193ffe2ba7c39e217f447acb55f956063acf4b6edf90579594049c5e90c7c81538b8970ac2934f5c1d9b19832a32587a228e7c550ab2537dbfe7e9c764b47ce7bae5ee67a07cb98c236ba2c6b4171f6229ba28f0d976ddfe7e7c7503cfe3d1ca3fa9b298491f513ddb4da7ccd4714d4b4c00fe23e7084d06118f35e28c49aec16d1b8eedfecf478ad968dbf7dfdfea851a2b591e8e6e815c2a2ec66d677c149462b120a9a9e70e86d6e3fe778d4bfe0d61944f82e12bb51a1208e66291ba8e052004d439172333bdee97259f4c702b1d1655f8bdb897fa2d201e9a787a53dfe552b01b624834a8e1e39ae81b31f6e776d5e1fcb16cdbec9de9f1e79e1e491e23dd26de61fb618739d8635abe31ab0ba60777c498dda841169ea8d078e919570d14525ab4065d54b88b9c7ec1f884d0e6c9e4bb018e5bc1f3038c14f86e41dc7facd7b5f26599a10dcd7131705b71bfc00723263f5c84840a5e82ff1873393e8f74a5caad499efac04dfd03caa64a7d8d394f87e1ca74e0dc8d775465c3ab8c021f92aa99f2745c6f48940125ae2fd6627f14a7639c4ab22f8c9465a300ae7faebf6754c71228853dac6545903cc1270cf504ad5cdc7c4550a72b3065e3fc1e5c55ed5ec99ff81e639a7b5394a355f9015a9ec0fc9cb8641129f68ad31d0e7f06b00f8ad7a3ef0436eef0a772a0f49ab6718f39b3779df1189918407356567e6dcaeb342936d70134ed130a2b8e4bf671148a688d2b6faa6bad86d5477a3b40a5c7860111392fab3a6f2cdde228eca4366c2319de5a95fabdc6aeaf1bb64f4bd5a542f07f42ecdd3f3cbe25c236a1ee9912828bb8d54ba06677fd9ed64658420d312df62474734d2440c2d660d15d945fe76373f810c2540c71365ddaea6af9b2cbf0898d4074ff1f857b83b23898d94591f5726ab4ca30985303265798f8880edbc7c52fe765d05eed665f7c711715607807083f29555eee65c49c0676a2c9b4539ec94f5476652fe16e7ae079540aa46dfceea7effd50d1f2da93bb43371f85ca53276cc16f882a1fa1b36917f693cced40d417daace2e688ac732bbdd676d1932781c718bc88fb22c8f50bd17a1e617548e89ae245d535a81d97f0a74df05fa619a21cdd2e7086433e5e7ce9cc92e95e7ea2cae7a9831194e6e91faa3c6eec2d6c2e3928694be5aa101739314dadc0466aefe32bf905714ee6ffb19510d467724bc9e93f79afc2feeadffacb1f81f6eacc31dd4dd751624fb58b335b98d307387a459aef70cedc5c04d8a086c1ba98c59431c14db9805bddcf81ecc567f26ca8e182ff9f9da2a008bfcb7655d2d0af6592dca2c6efad6655a8780118fc042cf4aed4ed8f48d5d81688a304aaa5ce1ebbe532d76c4155334dd802d982bf3b95bf216b1470b61700480da261735a30a09881eaf33252fa954220276ffd0cfbe661716ad0bb6d904629b327173e9c10c8a50737488af1b2374a50056d7326750931f5013346249faf7e820789fdab2c2f8e453070cb556ddc25879b6377d52a23c33aeb3196c31d23769be3069cf2bc83b6a68e298800dc84f2d2371aaac7051ff524a8f24a299b70a1e05e682366e52e0ef873193336d596cd3b15f79e1587095fcf00c47abb41851eac959cff48d02f10d378d49d79ae0a818a25f69cd98508a5dc708ddddc970d31a3e661833176b5596bc53c2dedd9c22da8662fbb2d4deda7cdf818574c3c0e7ab62bbe68ac71891383a037058849dc04af85fba0eccc4e493497ce4e7b03065568068e312bc8f594012d4748e87494f7a543548dbc5a76eadc1afede190cecebcc056777b25b7f0ec9ac51b74e45fd333f4c893b573b5c8cc08bfa0d632680695a308675f7c9ffa8170d17a6704d2d1203fd5fac837d2247dffa34ec6c1397db96a43e5054996ac537243de8ba1796d099612d0bc1f01e683dd542b89160d1e91d563f704db611fdae0299606d44719c6fce68de0387cddddb4f9b77e7b8e0e84c13e12601188d636bf92f8dea89cb7363518615202a13a58c59318266274744386d016268a8f838f163f07b2bc405d4ca6231e8040840bc392ea8dd2a10127d4a77e2d2cf82e4ebb992a55a42e5986f24fcc40c8de4a35bfd86cf7123958300991c65b86567246f963ab4d41999d850b2d8301ece4f60dc2b3e91533b29272b3b6c49fbc19d1515eeba73849e2959211498007be1b79e4bb8316faa85bad1540b5dadf2bee3bec298a0dae67db44178802c48157c02bfec037e9bd37450de412f2d04b26e86cdaf68a8095db9914df213da42731b00f8902be125e735fa12dcc43673d12a0608400a90c9f022116e9e5e5e505017e39c13d1e9e464821f62c55f71f87597ae30b8bf17145cdb58df00378c1113d4abaa478d27497dd795837c7051f9c910b339b73d9c6082d0e337d26756474a29c76152d8b3c540998233f00d632b960af75c1ddd80c2fbbe1f5606a775741af15dd6c101e4d31ef68a3c4d5552c71912bc1a59bda19bf5dfdd945c7d557aca2e38ad4cde6f363cde7dcc3b7d94b8fc8863c05ed13e4d4b9cae5c3c3d768a6be311cd5c7c2991c6c1f9ecef206b661b3f00cf9032a9868da697175dfbf338951c62311c2b11a856f836e7938cb303ae1f6396bac1f49c1ee1b01fa6ca50c688eaea9fe346f77cd1c8f9f005196afce766c656d55ed1a7480a091485d63aeb948ad40a1302d44a483de49ba13213f15dc2a23b34e0d323a08c62426b7103ff7b880fc4b6ce216567f43dfcae7d3c784340a3a13336e1bbfbc15569a1493d3ceba078c188629114a066b5f1003db451d7736a056d661f9a6b400a73068b1f5ecf4b2cd4d35bb66ccf36ebfd95dd19d8f4130568474c7521c6d5fdad628a022a3f709a2a24a7e626703d0c7ca866721e2a6750776942c16da4ba3b0287bfea5bed0e19d10460fd84264818676f966e53ddb1a43141f7ea4574f94d8fb88ade98b827e2a23e37bfbcf9bbba218a0f9a5238ae409fd58caa8b0f244ab8f5e5ff4778af9ed3a1ac5faf965cb82ca0d3d153fd4ce98afa5cfb3876087157248de12256a9d84aa8f6bb19e2a38509b3ac0629cec8eb90d24804d0732cd51c5a673c620d9842b80975c9b9db141b7ed04dd7bfcc68c3e6a94344f1706c3fb0897bfe008c05818f7cb0cd10fd067d9fb0e16255fe9f61a5c13181dc8c3b0cd0d1533a305aedd0798d1b53b14bc2796b88831faddb2ce4b0d253f3bcadbb91e1b89774fee493895a59d9c425494ca05395d30eee2e08d67cafb2ce405200489f609d10a4b50fad1428a33a6b2861f50fe38614f21d7cd6ded66662ae25734eea8c0dbcc83e9dfd58d6e461fcc6ac83a6ea668b40a949823988bac5b2ad36fb32d7438e4309e3c53fb3d89c80154ad6d0b32d2fcb5d757862d038b5537ff2e8ebcfa8dfb62fe79855b167113a825d381b6435b1a6dcad9f9e3eb26cacafa2392c8f4f1d9605e762aaa2a176eaf4599c8e14ac774d06cd34cb76258d8a2bf45ab25831e6e197c1bd4ac16c8c9b43afa1b310e7401a7862a2560de940482a5a1a2873a34ea90334d9bb9ec16dc4843842047df378c4d2ee8cb95ec104d343ebaf838d63f52d9480bf9be1e087ff81dcc2dbdf38f5dfc89ee987b2ce4ee79dc4a2c1f635daf6d4e0fb8721e9f12742588a42a67aaa08d156c7515d23f3ed4ba6501e3eba9efb2056dfa61ef96e2a6943031f86309480dbdf41719ed7469fcb6b5da3684dff66188ccb84d65c8a06073c8f4e26e63b284456669e015ac168b3253093c3d540442b792c3b4963913e223ea232bc830b10b6d9dd7b1e8438217218a323bfdcf31099beda9183800c800603b23a2e222bed88a54fb688c7ea41610fb4c81771588c784cf06e11b65af53b8918d1ba9f0d37bf53c38865400a677cc854c3c5bbe5ae5a636e1bbb8568e828b80a2fbf171c1c2e4ceca3a8460c762a3e9aa62bf1ae1e2b90f6e12a3e75ff920795d05110d61abcfd7abc1c44c0ca3da1e88ecfccff913eecc900403cf38b1e340cb50ba729eba42b6e4148633ea4853ac4a22d925160c4c3581b4b3ebf3a564e698f7f1910aef4b4d3ece57948e31a32fa46fda60c21937ee6ea7956e07c62bb7fdd9c35b2d7399f77a35459b06100443705c87ec9eb17131889655ea1788df7b6f63ab5185c0bd1f7ee03d54a4a728d380c0f6fb4e212d7ec9201b3ffd999a482a3dbade888e9fd3569203257e762d38c049aadbcaec96bf71ef654cd23b696fa7dfe95db92097d5b492df036e03526ed07e532f6a220a1269fa4b66b8a9235363e4236789db9f571dd330121e7c1137bd01d7ee395ff0d544590f87619d432db22908474f67e08664b6dd617374263168b39a2349283b384cf6b27b3ae940ad0a6548d061221c8c50fef90fe559ed5bde844e3efd5d4ecc50c40259e095fc0321dc857df7b8b7254d0058acaa9f3882809adb15a37f5194b67a4395af592ab22d025cf1ba219dfb36865c27a7131e45cc282bf0c42c5efd8d9b8c356ce565c935a62e4996316e82e3d753a7487caf36c916b67de3b5006e5ec383c0332e8b6445c4eb6279bcc27aa76f5874ae3f6d67d3060238209baec104f2beb689e6bf4c5613f0989796c55f9b6424a70efbc2122f9b8a95d55d11dee870e860a46002ce599b81e9f9d60fe6892be2faeca3e81fc7e635c19c3ae183afb617ff505f3f6c2c0bebb1d728963ded04356cca378e612901a884f696efc58cc7ab477f916f5ff454507679e4fda9a5d4106708365b76f5e74f5c95fd6ecb52ec3f706c5b2ee9b0773dff0a7fd86534f60ee8d6e30099cb3f68f3b725cb729bfeb51b8f20f4d36cc96d48eb64e48742b77c117f47446ec5c761038a65756661d0b191112bd16723fc18ee0f7ff22eb358c673f3cdfe3f6310fb9418a2d57dfc53703087b1cb4218faf7cd1e03a05e07c65672e8576bcd5305dd299d24b9bda4c9f7bd52765a98f9d7d44cb63b5da02e6e4a610075af073477a2402d2f36ca739dd2710e9bc17f4f0ca9bea6b8cdbce6fead8469eb4668543ad0456784956870a723d615f543e5acb771f446497deae7b4902c54c9607a7c051704e4f7026d5345c35a2e62b1633626a6add55b07265e9d2479f62bc0e7d63de78a669b59d5d773f011303e033d0076c6c58fa446b12aefcdbd906ff2e348e5adf680557c96afe39c6cb69d3062f59e808567087448709db92cc26d78a0fc72d656bae84dc1031780a94e2074b9875c1604b6354a4017c8ebf1085bd240264db41b0eaef4f7883596859cc77f94201ff732c41d7dd2618a3ab7b7ee2f40d409cb6f815c38f36b9b046532d0653e143f2ed6e2dd40cbdc27278233cb06457acb27a3444d9fb54835e0a0b53c07b8684a0466cf8de0b6ff8741359031d588fa2682e40493729249ef292f816508e7e846fdac274501eec9a8a0d11d6393a6b75e086f3c40a82e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
