<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e2bdf849ca9bc3d1406e14df82b181d06b4075aba324eeaf75022a697fb7f4913939112bec841ca85c61999f6c679afea3c17afeaf3d018272da00d65bde06fee94e7a825d0d5ea009606e98f94244640923146a9d48ea14174213d564183b2ddd88b086a0ae7ccb2e843df11a1a2966235d0aedc6079279bb021cb275a8d980d1000410698f7b417fa685d544d7a3235bce1085744ec96c19af995aeb35d9b7c91b8d2093c216047deeeaff1a3bc873fbff77fd22e57b8ca57cd2c4aa8e37310a1077e3b30e49b1efc33d8627ed6edcbbe35fe592e20b19f9a5da6faf584d79f25dc5785ecb879dfbeee47b7772b657a295027b90d26f62a763032d1ed97abe3140e03e0cdbb1161f92eae4709c14b79a9d759a9578a474ce2c2e5d010b3c88868dbe5fb937348541b3f80a0c4bea33c555b19d01566423f0dee509fe37a06588a833ac339183fd0c27ee13436241038fa3c005052124730c554e1c1595744cfafdeedc41df735d830e27471c0bd311374f29e8dc6f4613b6fa85cc0f63fe4c71714344fffb9d602700e13e98bb3115942fa4eb53ef0aaa3ed0c203d182ff1ff2b0206a0d0cfef124846bd0eaab25f2d4e6cd434d2465b46ecc8b042bf8ebd85f18c7d0ff283d5a05bbb1c8a069a33c318231d8fa9b7e0da05e0908ebfb30446bb504525c587b860901b8d69eb156ecb848c8b3c755da71fdb86fc8254adf386d0db7c23e29e7f4b17c158fa0a41006938018747f5b903f6d7190484f7da9cff4146e9db4c178c6494d71664f63a780a3a737436aed957dd0099e68fcd61cdcaa85f70bcb1f7bad41c9f9431dd573551be8c794893d50b53b18e910b5f58acc4f46450d8b5f56a8ffb1bc97d299404e678e6ef21d55d534bd02ec5003ae1ce82955e7773d3c40beffbeb94d6ef5110f33d58c6f1887776c65532efcf07efb595c92b164df7078733b4be5a0a88cc31d94924730758c0116773de96a97b829fc3eaf0def0d4039750e9cf18d0b12dfafe2c9ecdf6d5a4d623c8b10cd0058202cb8489d4f0c6d8c57f2ae5686caa28a1df5f23bb4655d5733b4c47e2aaba2e8ef0d85b2b876117b34d77469d05336eb162b2fd43faab12c13ebe0d0f49a28823644c8b94e9a4fddbc3a3e8446290706bcd89e44e249121c9e928cfea75c297fec066fe83de0974c46ffe90553d0aab1842deda65371ab8e060f5f9ec10d1cbc2c5661e604adf1af86bf8fa2130fd88220d2b3fc572276468c7445a3bf861ddc236b51a2e5067c67ad3e2affa951e4fadf97105853de71c763e4404e8bb66ac4c2ba031e8a4e8c56334ec16ee8843cffc7062d0688bc405bddaaca0f4c51387d92e9d4fe48f7613763fa74b81b0d73a0483dcba6273d7ea2377b344e2b1f275f2b93abe0087abd327334ae10bbf1afaaa2d78d5d621e557a7a427465bb3973f51a98f7a734cdf443eeee0a7e62a5dbfe5f1dc65ad456c9e3feff3285352a3ea38d5e25f8c61c43919366748ba36c54e7eacc2dd2adde0713b60febb02b50227155ae702c8d45f69b854f5b916c0344ac82c717d8c15c04d126620aedb9436e06b93eb622d79984180572bb17e905f01fb3c001e934325fb9f6506c51db8807e8f1f69fc9a12670f62581f183133cfdf4d6e7e605248c18741e64f81fd4e08d46aac81682e14419178b679425edd3a4c57d19c1ec1f14a53b594283ee603342cb1590745815c45aaf0882cca31c0df22e27f08793f1dc90f392eb81b2b84e7aad473fadb64a852c0eb4218a8e066bd6c20665537771b70b22fda494dd47520bf8b3e03a36da89e918955d51a747a4582c74f07d1bce6f8a68d7cd405593cc9a59ec6ca8e76ed5d02cc87eca34950925d8122973d44fef377bc45158536dcdb6f16368e59561492c376f8624f63718a29535e6c0baf9ecacc938fbd955cf195e346a82fdd9045dbdf4bea3de914a3a65827faf1ea99925450ed7e32d1cd0933560cf6596fa9385ad8bded33e0fb1d4585b975fcdf7813d1246115fc65b25ecd88396d5d4a67b3bde57680cdab33d8a76353f50786c186b75f87b48e731322a41c4172fe2b30f264c9dbc5e3706e326c6008b37e99812c86cb935a41ad2bc66d2f5d94e567d9889580c412f477a555b8b3bbad47ca59acf549dd7f81d1e068276e745555924610d4ca58f240663f29517ead444285759c2c3f16c03d56558019498a9b8e53c0297fd857f031e89baae0a7e7277d56b1b66aae204131ee47d84dc8baeabec10f573ea62933920d29765203e55cfe78b8397bdac937bfcbaa44be63e92209ac0ac88daa2e2c388d81072cc5e9fa8d0db764c1b245e8c19ba821e5cb121a88355047d9df14a90b0baaf00755db6e6097c142992a1318f87de78625653bd303c0645c26c1351dbe275f7310e8a5b7c6efe097a47f4703fd850edaff82d71706e8f9cc7dba25592e0010e0b6723e32fd8b9d6049bf9517798fc27c2f17f04b910d929e70f65b2c81ac79d36b8b6730de37776712d3c26213b1c7fd2711b4bf6e135ce11add9688e6342786bc97afc4dc9d60f07d06015ba31fa28f15e6ec8dbada3411f699d0c402d26618db5df9437a9510096abe354e7fa722cd4b7e8e8298da41b56369947a24c3a5e865e3cd4f3280ace5dc6c2f699fd4843a742ebca33b57a14d393ea8a931b60f41ea57894df0ab3188d3a969aa1b21c0070689d743b057ac3f27e5c7785082963062a7174ef9a3672ecd5f9f6a5086d05c9342a745c2bd261029d41882d4544508966cb3440accfa5e90910b324ef0ec2e23786ec28fa29878cda57f38647c2e77fca1e1521e3c58f04cd93ac69ea121772a9fb099d5a0c6ed84bf511e5df8ab18cb2670c350c8e804b6f7e953089df8d51a4412bc1fb6e421d4913d3dbb140f388d439d3cc5a5b6f049effc79dda9d381c537a150a0122e57f1d9f7925677239f9b8653ccb1fa94dd53386efa19826ec62a6fc5c242e8265f21e1ab6c80b4534bd2421cc32323247f8f1aba48f4ae7985680787180d069a2b402677a350b2d77beed7cba2b6d1234441f3281c2042dee7f8dd101706c592ab7c399d734bb0897cec3d04cb374296e1afb0ede55d57005a8cfba3c31b59f6366b53c9a16c0ca3efa31af9495fe1b0137a27594bc21f537d3d201418c6ae48a908ceb45a1c560f5d6d4dc1176013cf1255dba753c4d50f57a9cbb716988acee3533b4ac214b0cfe5520994624735265124b2a5f89151654ca0048d7c57ee536fedc0ccebbb03b587e1c031f3a513ceaa54c757f9bc7d24f8a5bc451c4f2a544909ebaa0e586f71785be6eba42b47805c10516eed7d9db691f5127f9867a954a72c917844cf23c2b08a0a205f83c650b435d2d36543fa558ce165014702e760012f3fbe82764ee6a479b6d5570ea91498178025e44dc430d991727964def4cf71fbfde0eb74c080bc12007f17d115b78070ec69c131a799c18c973011b2c3a0516a91ad7083b3ceb002572da0835781983cb7820e2006c735c5636e329c934d6020d2e8f997f94fbead9a9c4f37a47b2d387c7c75451e9bb683b06b275a2716f100a32ae3b1dd364eea7fca395b9152b81fc72bd5f2741a0582c808755c86d759f1217168a0e7d55ebd6dbaf64ea33c43c3d73d18311a154800c90d81480baba694006f4ea0f57ebc82fdb63741c781185df3629d0051933aa806a68e1939e415304d224a79e3591a886e8dd9c0ca9eb07763dd3a0d63e63db592e44a52dbf33a85acfeab4b9036902c0dc759122018eb2afff399b3bb1fa04b2e30777c603be9b44291685ac21be0c516f31940cb9664b1610d12ebbf51925a5873be0a351dc956098413376a8f268429b0c0e488b0b736940e3d1d7179613196687a130ed8bc949fb9a7428b1f9bd27501323bfd913e45820f5a2fcba1c01beb121a087742998aee5013d4989af53753e2044dc20a02ae09c19904ba15a1d61d6dd49c99d8d46214fb368e26f3e5ef1fc065c3db17b1750eb99a8300a9aa577a26049a28757b33c353de6a9f4017b88d6c266b8d3dba03894e6f9bb596f3d08816388aca3619564d99e2094425c0dc152154aa6d6aad51f383255bb564115beb83ae24eb36dc3ad137a0364c2f8f79c801e6c8df15cc7ef5aa87840326844c305230559dc95246a12aa53123823b3d251f5451dc522439a3054ae85ee4897856800b3c21296b25da007a687bcc0dd373780d26a655e8f89ec76a46653db05e465ed7bb6b7d5e53f0a1e8d09f23e4dd5239079f1db9ff51252bd8d2c07e2d9e16e229759f5991455f2e26ad68a94a48e59adea725c7b73557a71ee456b9073252f9e70b012c03e469fa1bf7fc846e3c92e77948c71ded03c4c34ef80d86784b1e34c953edf2b186f7a9dfdfc4e475298cd057899aecafcd0ca43e6d6cb997e8f3df9568a8d3c2f554a79c89e8bf317c4fcd89766dbb1a656c4821f485c861a66b062899836c3a0f047dbfcc8919692a86575227b3778a05e917ff082b09f08c262582c25b85c078dc1ada359309f3000deaa9add5944c3ea6764d020bcf65780261e5d9e59beb3a86e7258c3bc5bbbf795229344b4a2f5c6cf335fbf3a2aac6b37a9c23626eabacace7b46a544129caa8f7a8c661dfba45748edad7247e447aec9f3e06891f98e850ac04de8f762974cfbdd9dd6c3bfa8e51971d3a1a61a218c23e50fe8ba1f5bcfd11052cb68a3de7bdff995cf383f4d39363aee1d341381f4e08d1cc8d350ba2022eecde5121a5648321a7a3db2696d14bbbea14964b05a003b1f1f2d840e10d6d2c74ab43899cee8d46602ea1991abbd2fd726580657a9b76250374cca17a3f3cac1d9b031544fec1fd9c0d04f218039a3cca85ac8d263ada01c79f4fa37284bde42ab1266f22184c501e40f0b18bfd68d6f675f54c30c7e07a2df99d8f4eb1c86b74aa86bd1b615e0966c142ca063ed1590b6216805a6030b49b7b285eb068887346ac556c01d6186f7b9de18b986513bddeab314a391cdedd7d97fb6958984e647fb5b3e3555b24478b6d284a6e8c6ab990d4ba4e4339b2ad33df53699e6f7c4a9fd91b6ab91b5c4a00d912618cb6cd1b34e7b7dcdfc103f3f8b60554723f23efc964040262acdaeb9a1cc597239a6c00416ee4217f143153cc774776e14eb39a2432d64bfca3a4cf95177ab9a6026fba602d4cd09d4b45d8ef21a995f50efde3bd55d4c577b0a00c5915e3564fc90d258b24295832f04fbf98e4d60a9581d18516022da050e5709f15d13ffa0835b77c3d3a34008f7ed58ca420aad1700d3fe76d2c7495962913b70319e4cfa9830242b4f1f9b3fb2695833f3ee4d8ff0d9a6240165fb19ffcf7a5a0cffacd1027df663a27de671e1d787a624aa35514ded5bc34d5ae90f96f741681cf7e5eb59d79eea31e41e0d506bbd7a1282d5a79e0a66090ffcfea65ebf1833732dcb7bd0028077846731355c5827c3cba5f8faa12d20fe2d289c6358503ee870c0b52e235703055dc75c4a9277a996fa4416788098e47967d11fb3a2c49eb21a72246aedf6edc0709b3354838f6d3e7e5b9106bc11edcd641c95f60f947311cec19609b13d5bcfb24aa663f4e4bc7880bbfe9df55bee8f7a5c719ade76c63586a9599ccbf822daf1344d2c3bbc54eb975daca251977080672d48b287909aab092e83d96cb832ffe64a24fe9c15a56a5f0554e6320638c4e52e5cac9666a385f76d52608474514cba02cda8d1051371f968c8735740fcf6dfe0a57bcb6714419f38557228f9579349a852a5faf4b66520c98ae7c55da895c32971e055a2e0e7142ae5b8321009fdadae99175aea3159da96513683f31939ddd1a5ca9e6a13a566c2bafa4cdeba0b280c8734d27afac2757de2a9e4f35069029743a1acca3980df266b57132cf08e802ab6da18d1ad78b550359e152e228d16e5e44ed7ccf934454c5966d9b59e7bc412c50e777c02d4597aea2e4059ede31fe64f779f514e1f49fcee7fc11d5f1f40c29e3ab8947a58bd1a17c422778469120d56957de15b46230e5a5a8ea9109a7174620426236285318cac26b00a64c14fe8dacd9ba8ae168f5af26833c8b48421a8f577201f32bd76f344fdcdb181e7fd2a70a83fc3f7413b3adcaf36dce5639f71127364ffdc28305f7659842bdfbe7334ecccb5fbc4b95fc1e6541c386064b736fb50364729a0847f6eb40bf513b58bb9be23cbcd32a45196d879c0f2689900f7ee04ee36fd9029b62ef71d0e10bc45d69e3b82dd4d227a516a972fadf8179e9f34942350af1ac0b82a38b48d7f792eb0bde2f7370ec5e84c396bf406ae56374a5cc545b2d984550f58a49aa5302365503a5f3675b6689cfd041c699041318ae3e04a2e450ef3e3692d857e97c44096d94c316aad130f48d7a08ada8a63b1bfd58214590ec04cb1bd215ce97ee648c1034ffd3301af89d4740fde987345d5179ea3e712ef5463f5942e96ab7d9c6dc799c6a82e138e19af7ce422babd7acd8ce033dea24f92bd4ae605213b7180c8dd45413002a31359f11b80b26fbe2eb1705cfdc66ee335131f2413075b31f2cb29957a001eb17946683bfd933bd2922495b36281406198a4cb9451c9b25efeeeb5e7d3bed26709d9107c515777bef4519d4882fb0e53440c8e834ff8ab3107eee58c69099b9e8ca3d32f811ecaaac16c91f8dd999c1b701ca3366c946185eea108220e6d1e254291371d0039ea2f83432fb62db3943fde5e6154876798248b7fb4b665ea99b4f03e35a00738571533e2aebd9e032ee062d596477be9f3388a4e59aec9332d7cf9b5ea736004bc4589e12a0216bdd6a3c9b6ed9a7ff55b8a265f9e40babd19310e627f77b7ed94fbe8a0589d357c796b6bda7f7f0efd90655ea98058226a6d8008a75c16b5cace34af8534fa92b27e5017deeb654e62ab83c3476a6213ec7ed10593fcee8dbdb8b6ae0877e4ef78b0cbe367ac1190112d15df4e5960eb2b85017fc149cccf428da48b3ae0fe5c5a2dc397acef157d422997e58dc27a33fa393bd5813c8fcd70e53db9f761c12a9f002c57e0406f7a88cff1b98f86aeba93e282a66b30eaa2704d0eb980e108f368f7c44c1be96de126c9ce40b7e0f8ff6dcffc174baa1f45b4c0c26d1aef7863ce25e86d3289aad96643e1d688b741c7408230b3faf6d6b72558992d48306a3977d506f0dd2b2a4712903f2fa930e9fa95bc6954972915b770c7aec9d7fda3b9d92db4ec0f84df3eecbb17a659db3e0bdceedbc821f21ed82de4d81955a67d7a2e13f01e705248850f2b6e947cda742e039671a51e0e4768eec794445afe51fb5055ca6131c67e6dc10ed4ddf5ef0ddb0d53fdb49e3a6e0afc35896f77d6ba7183cfb3a1c0edc2d50d26a5e4fd45cd03a76998de990bb5e7728bb6ba2cbe00e6e44abdfebd567a513c7ebc9a223f8009c8a102042f1dc6195773ea871776445dd5b8c97eba07dda868981ab6ceea18fc0739853145574de9243631b7a41e1350877836edf76095fe0e82a94d4bc5aab3c442243953efea3bee5e8fa0c583ad27c36fe02306ef7cf6977c35775bda115a471aac37a0fe67e3f7a6d88f5695d74be9398f3cf9fd0f6daaae504e96aebd3652bd9b840019862bbcf13754b0bdaa03f3342b106cd7818424753fa1e5b5387c99a009d12a0487dc53df2395beab0f97b3fc13f9c459f3d9a87df8e05b9011f1efdd2b6ca83708db5bbbe291ca8df091017ef3cb87ea79715016c9e57fa058aa73306cfc8bb4b227e82b17938f1a0d8acf95450c9f551d5e37a4a309aa4e0bd6c9d2ae97b496bf62242f70d7078b8b2b514ba204544de91de392a185207169a802dacc36a875c7685a9ac01a871fb137357d07746465d1b3034d90bc8c7c6a7474ddcf4ad807a0871c7421aadbb1dbffe09372acc1415ae8970fca0dbd8116494b914556ded36e405281ab8d52d437839aa357d287d77cdff69d6b5b93c149eb4e35bd1a5c1415c632d19aab6562e7a3f971a8e64b84558ffa138ebf1240a13fc37b2030f5fda8d88bc933a485a8f84f27109def473f8b82146525dfbaf6e134733694f4f210ec67cdc25aa9c90bf15988915c1e4430483c9d9245028464e04d2419f6e5fe17170029884f3fd059a8278f8d7f764aa51e21b1926d091f59810e95a7a975c08ce82085b998924a6ef1bb149ae4a0acc135cc0c974be40e50d93fc0214aac88a12068eb5746b7b878b3bcfcea5ea81ba8fa96f99aced17380aab4fffd74579fc22f29ec4f55c5f179d16712e263196fd6b71baf5af207b55d5b114a8cedf2a0986071d820da23c95be0c7671947c64ccee4f8702fa9911b3323df61c8f71a3506f13684100893cb77c6d89ff927a3cc12694e86f5453318be18b52b55fe082f3627fbd56922e8c4d28d52c8718695089e4aa28e939ad70136fcb95a02b48095992711a46cf621035fb426f5c6c9215b10e4da685892133388bf651c1f4a928f3046e6ac77518550a23ec9df9cbf8e7e295f79f797b2929106f983a8f4a30f795eeee93b1c3b21af7d35c2d182d19d9331a70a0e648e60bcda9876b9d040f116147705b14acd4347d498f2851fee352aa094499f5091bd2106ce34c1c47d9fa581b40fe730e95daabcdd055eb1cec17fa40d50b2886c045be83213ca0338eb7ca0947c80d3579cef7c4aeb63d0a9b934af1f34c9961ca4dccf0e451ec4fb9db25e0b8c240fc59ec27adc5b0471179518ea216b8a3e564be1f97b9827d799340b270ae0ee80c4f5bf4804aea66e696f2e808c53b0822850e8cb4d359e0aa684333f83fc56acfc887ac459e3eafa8c02ba8801a822fbb10f5cee394387a55e292233dbaca4e288c8294f6a1d3763cbf8b1aa062e249ee305271a1b2f9a1b89c75121d05f054d97de2aa645613e8f1b9722b06e8469eaca1ca6cb016546f0d58477ff3a7de427de291de6ece6581c9112bf9e7a46e4984c529f34733bcc0a18088e7417f7a682e4713bf27b4d1fe697427deded7b398a4bb29e05f459f5655987f7c5f1621f573e28a01d0e74de047d6e3f6095f6758059e7322162d222883a45c42fa8557a45b94fed76147a745b5d9ab1f86d1aba8ebaa17daba6ac509c88e5a465e03bbaf48a3c5333d79d5a494bd08b6f64b5db4d1cdfca2915536c9941dde2c27a5ed16a5717801f5bb8c588a26e83745821d2f5a3892f44f833749509893097e2074fb52510da9502a2b8b98fa13203a6ffa54d369d84f23c0fb85babc986398bf47faee36c869fd158c83d768d40512f8dfece9780b4433fa38c98dfd414c4d2eb50f10218f6c5034adc9e2bd07dc6a96e6c83b58c912a41092883b66608384fde3b1ba9a4c18dd88cf77f09bed08e5b3c23c618238fc8c7e4adf3adf6c9d4b04ae319ac4a404605000a7a4a554ea8fec732a388924efd1762cf514e7af284c24128b3e25225efa7a2bf0dd92e60cad60d50fc5790bf2c6038317be58a41ff9e476d35f5c3fb0152af2e24d653595a860d1bc1b4ba84429143ac5f1514ca5c7a2deca96e5c4aed54c544bb7fbaeb76976d6c154c338464eac3b53f85d1c0d4e784894ded2d0991eaed1eb45fe430c9c7a06d81b6f7ac8caa3e7570c54c45dc6880701438a9d219be5f59c3ecb75f5c02b93704910a79b8f16ce2dd87a19e1707f73ebc173af9b78c6ee125c2fabbc53d96811b689af4e5aaee7892c6850b66ba8c55e330434c237fbcc1e0f9dcc0e033708fc22f1e12c3a15da209883e14260cf4298e910256b23c38cb11931c42873aa5ad67dd48c2f6fbe839c16361c8f47b10a15f45fabfd7d92bad83dc0085ece84acc2f5555063313d3887b5666ada7ecd7f4c49b3d9ee7117e0a6aa27e1a44badff3b0c8e0fdb67d0fe725d4b7452a9f3df2980375e7c2dfea8c5f09717f556e9c5c03398b4b2c34cbada64e3badc71788e40de886719db97384a4a1d950a82ddcb61b45032d7f2db5ba2a8a089a7a8cb9d99b255b9157faf18b626e66ab88fb850546c430de37ace498effeac2bc739f0203a9933d3b11c384b5445d1f9bc8d244a78612e24bea8793585f38aaeb511764a0d0655042397cdc5647b3ba1cca18cd78ae4ff6a2a1de58b4e8c2bee21a974de2252f379e00d90e7fea3b83aae599b5efc67e9326d983d6093581d912fe64ab6cbf57a1e27677334440cc9d74a517f8fe73f6998489c9923d4dbdb6069fad4507be3ff401ba079a7219044c9a578a2529e41b3e3be385d4f36fdada89797ef5eac440f236182ee2f4cc9f24acd03865c8d08b8d0ef303c84c33a2d3e4599141033fc321f168c8902199192532a1391c3b3656fff4e86903a9cad2e5b7448caef75cc3f4c3fc808de51096b04b7e15166056873fc5258705688655aa30f205d87c3e3a6324f43b9fd97c4883b4d925c537ed17dcb693fe2efcd317fb168cebb03c2ead8d7484d79b1cdb20ad9eb9a1f4d491deda3093bfa848f9f8b3db9b02ef0a98567a19a34fa7db01d5cc06b4cc11959b56e5b4608c2ed8d320c43045c4e88ffac7acc9279d11a34f7e2da9cc5f6446de20887e9213146a5e9861cffafdf7ee8426823bc31ad5f3e708d7d3cfd5409d6c87b53ec822febcd4b91be6337e3f5815350206a6e33789c55cb28c173f22d821cc4663a6191433298f798d205f288a80e04cd777f5af2287b7d83c2d117e3de86423bd8abd3bd5739fcb9b766f2cd0842e8082918cdb702be546398f227d2a95544bab98a4fd3e10ec71da05e0c857a21e721d0a9245081515c5ffa33571a4c53dcec0df126d40c64dbc52ae8ecfde43ceb153b44491bf419819f920fe049e1bb706149c5b2dda81b5ff9281ee8e10581fdef1c34d6bcb7e6c4ecbb0544565cf8e8a9b0f214ab4500ea1fc01d7d341574d6ac49f19b255b51bf6edf6a44e78733464407b1c18ccc374f79f60ba68f84a0d553e9dc5b27b60402b0a039c2d79bb4010f600b8e09dfbfe840ac081dc504563866cd3f85075b951dba6558ba3004d9f96e015377185b01aee2fd2c0f31b410ed347f7a84474047bd7ee5bb941c74628ca498676cb4b8c410afc2aea98f4dfb4154924e86e7f24a2a9830a1fa39053a88f3c05585c02922157bc39e72ec45f379d145d0a982c61dce7aa9a6f6d70c73a49de299800213998597a0965b2f8ff34f6cb41f0d360d1abf3c39e9c72edd816ae54225f948c38c4a9c544152b1aeb5e2631d411bc9e1e50a662c7a4989e88533b21f8c40672889e42b4a1060a7b8d759450eb1ec156cd19cca2228f0b878f4f7b2aff493f36527b5f9aaa286a7549f771507c6fd02d7a0bdbee3d838fcc895f95c4ac2348c19a9228c3aee79971ffb53e86accf3be6fdbb08dd8b61e8f2362ad59b1d81b2ccbd2f9053a7b285934e9d963184a1a11083d52ab9d4805302f8d78d5de83280847bf284f203a698fcc824394de900b0ed94f3e0402bc73d8369f909bdbe05c607a9da858d13a3283e67d6ac4e59c6a97306eba52a0dcfb7de30c7eea3d38f321f1817e55bf1e18f911eef8f2f03da00751030104a2fd1941e9bee6ad89b23b68bd138bca6c7c9089317a37670e4b2b57ed7191be85fb2e1ca5b9b86cbc3e6f987deb58fb8f0354b004aec9bf6f430397c67ba104aad7ff36a2240c1febda6dd2adf783b67995a4f21a292d10290cf7dcdf7eeb8cfd9e79ac8f825e32e31a2c52ab476592863d873e85c0dcd647879364cd6d97a35cd2b4a9a7dbd8df680e2d8ef08f41e418f906ded888f9fe98f13cacbb5c5279e13aee17911edc148692edc93fe11bbde9decaf81181630d477b54fcad5fd105473a9abb894ec305b4c00abf9e0beac271fa99088d23ff0063ce37732b56e5de3a311a8a228158bdfcc4e1268d6c28a3fc7eb5996ee7d4ae395a670bd5ebf48fffea8bd706e219b26198e1066438380523745164f1b1b83b6c458a2c869dc075646ee738bd0aecbc9812ac3b8370db819bf89eab123f47be263cd463cc1413d2546cf29e9659b66be6c577b21d645f6eb3d006fb97db44efb6db3c1ff41c3e81640cfb482b09b0631bc7e6f2e83d1c09229581b7fcea85e79256209b2e9434e90fc9ddf9a330523fae5f18e414a6bed513addb4a03c31d15f4c90d1348b68044269955ec308df97cd4818bc7b78c505c0c8558a91d72508e76d8ab5850f31dc8e5267a685a82616128514bef59953c12c967d947ec8271a4e432a2c99b2e951d2716c3b9a0a075f8e4f1d00820f9e8533e3d5d0f5c6ff676b4a884c4343918870235811cb70b291083bbedfed280ede5e10d5cee915720ce26ab59adfb864a9963540f649ce2dbe97077dbc2dd3be684a86501f3fb43268151ccf43210797f8a1ef47dc5fd6d47ad034910a2a0459e069a863de133397de80adefb5a3b0a79b0a7e9396ca9435dea66f96361a6020788","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
