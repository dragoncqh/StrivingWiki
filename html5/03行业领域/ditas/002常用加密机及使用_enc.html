<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13864ea8cd33e9fea28076c4ebd1e2355e1527a9edc047c72813c72bd55301fa9412302547c4782fc3176c358fdfeebc5e832e36267bc637e459f15f79b5cfd9440a2c212aedefad482a7ab5fac4d5ba6f2064649c112811627555a2132c72e9cf9dadf06aeb47e691fa23a7daf7525a55d2871b1f82be0ee16334470f21b2e339364dd30f5e55a53e5668b301a308f15e2cfee372749d570e24bb254d41271cc02e711a089463a547c33c54e394d8a05715808585ecdf05865ad754a46b686ceef8064cc759a259c7cd71374672e52a876a6bd7824d302fc0811b70eff319bf829aa39f862d9d81884d056cea3cc7bdf8a34efde79745e77eb73c2c343aec29bc44e93117e69a55b62326a07e2e5c74e796358e6ec7fe83c0695b94f0875c2e46641e4d4509e9ea808f92f1d0171553230d4e856d9698a82095c0704f3aeb807ce3a2bd3f641bd135214c22a57365778dcc0691435ef8b1dab54dd3a6473be08d6476f36994e06063002387398d67e25b774586c1ce757f38064a9911c6faf2168e0ec56efe3c8453afffa583522a1816993486f29b380b64aff39170f4616f8ac0bd7e82a60af9a28f55265ca6f6e535686ae0b980bf0fafb36fcdf3bf6a063d6cb0eaa94054cfab3e05b89e846152371e0a457877c5adaa6a10cb7cde8427811838e1db899fa2f8e576f11790e6f1498e04a93e942cb7073201d5fe1f7c842384a875775a98625b8fb68fff0b3a78914444ed55b0285fb6a61e91c2e2d6ea49063de6c820ab8a1894a89a09c30d78bcb62ddf7feba0723b0caf0c29c7dc1eb30a5bfbab09f837b0365146eb3681b2b6da15befef330c1d4593f98afe4a04d2ace9b614c5bb859adf36ef2d69c7c390341854be133c2a9a451c589af891e5ae525876830f13ead1a0ce9c7595dc9a5c08d0b8df7ed279b8356e9f20cb69db4413e82c08ec42a8f4bd9fc3edb9fa19d7518bbc177d82408b789585e2941f5d0fc6c84abfd6fb3140daebe6b53225a887e1b4b1ac594ef87fe84042ea8bf6beb6cb2fc6bf4ed4f9a0235561bad636cf7addcb233c937654a037b57d7622d160e526e9da03b834c00d755953adee98b44269bcbe33a1cb8e6fff58ee156e575dbfae28e3084470383d4b64eedd601e7be9710833235b25ccac73b9756b82dbc2dc5ce22aa720c45a0f8e1eafc9f5e0a8beea329305b8dacb5d834ac7b9a705db651a45a50fe529194b01b01e4909dc95942315294b733787f1f3b4ba6ca892a0523c179ff2e31f7c7a3178754670e1061207a70decfa6645502af609c750a4a57d2c37143e6dc538920fd40c277cd7fac179b62a462a67ca1269bfc2e63b62c5e3bb5480bff4644b8bba9006bb5b762f902946078213fb09a0e4922f3fe719e6351cf04347f9ed8eb1227633dff76dcaef4e314b4509a7f59f4b526fb85b50a72b3e3cd84cde1913910762d9dc10d6d5f2f4ccec15468c35e70bad340b90ebd29d4dcdfee01a13f21b79909c3a6dc7a343562080057d30e1586f8e396b686231b6dd480a420033952f61f7ab44d6c2da5824e2861836eca81477ba792a084c72df1f387a85d7040aafb6e5701ba47958db72b8dd35d8599790db05309237219975879dcda362bda19b0d5dc2169910febc7fa20f6f113a4a762ffe301a29b83252ebaf6d123d199acbf9d7dd6643ed7abcd62adb5ecd5befb7634ac8d0424c2e9084eab4077def3cc8441e1b7b73049c0689b55dc519e91596e0dc8f075285e7332a9772f7b5fc38e192f06aeaf2669c06957c010a0f7401c0c9d3d2513392bfe5efc6846a2a24b603b2bf07e3e068255b353072494022a39b184823f674a4185bb0484a8c57b1bb16e2c11c5aef9d9c4aaa50050ff760aa3f78f3f5b47cb14d1b5a42736aa3f7533a8e7f1c3effdd01bc60e76b3f996d5a23c33afb7364765e8fd2676b9d4797422fbe303946543ad2e2839bb04cf25ffbaf680840dbeaa93c00bd78fb8a17fbf96d44a534c145a84f29bca2f05e97e2eeb24561fd0209fc5d8e872359dc956a19a1fbc34e229b21b5b753ffd80a79377a524190adbd4306b8fe85e8f2ebd059b33770c67b420d080b45f7c38fd08966367e59926b7ff9427dd4c3a5e507875fd047b53fe0f8ac99ab22f9297ea09f65e8455e2e731330d14d0de7c5ba96decbc673c3214912f1c72eb8f5889b92dc47d6362899e6931bbfeb4d34e4c4e737f69fac8eabd00146bc8862aaaefdc8737a4ee05ce8d8fce64121cc5d896ede112da3af0765e646a0f08748816d1f3f37c85c4669f4872e26def07b52c07031e4e15c5f88721026dcce446f7dfbe7e2db0745ab3cfefc1dcb12765b2dba3d7a08b56fb83c20f1278794cbb4c9096775b5403e6f894b1d7ea6f6ecab4055bbee78895fe7d8b6da6eabe0b751bd575c5dd3948c59ec42e1365b238344ce343b2d0bfc9daa7de3545b2c8cb471cf3f1e7960316dadb21d9f66c0691d64f74c2f24549afcb7a24766461ffd3610135c43e099363030f7d09109b02e970c8f2983fd9980a048e970ec9c7a849af9feb0ab17a36859c76d475aaff1f9803ec8f2f2f9149eb46e794a2be3033b87b4c661d42ab73a025638e134e29401dfbda5d7fdf168adfe9eea11e29430eb08c2229d126b7494680ce6bc2bd505171ad0c42d23cc394c501bbd20256264bed9a122c4526df1f22a28f7094b78f32e02d94097c2e9f44b65b2259e894b96b79cc36ece698f6fe82bce1e92d2da62e0a5d28bb2a98cda1f31d530bfd2161a68dcb653915ede66b5f6f60ea282eab4208412e44f96776b334520e57e76283aff4ebe167a3fe898417e4d836df99d68eaffe40b896d8f1945c5e81fefdb3e9b84c1fd86f57df19cda777fc9cb84f447006e4e2c35f59fb37adee0e94b6b523924b8ee05030a471372b0d09dc1f75627d4cdeda07842db06d174470f28db707c39bb3c3bf0cac682e04f33a801a3b1df72fc3eb8e2d9f151082479882989ccb24b89701bb11f3f598a227f2e5f0b96a4ae6a10cbaee7067b8db524445e5e07137035bd642c0a8b0b7d747ab6ab124928375c0ee50f509e746ae4fc55d52b90d0dc84adc2c7bf8f7e7b141bf8ff7995bb4b005661c2e7d361ace67a7cca96b184c30395d7cf0fcfea453bdec2976b41a8aee44ebf17c9a70cabc32a7b888d39d8c44b351deae2956935a3ad236bf3f098ce1780d73b7aa65b3dfcef79fb6029e2716bae5a0d5713a335c3b7ea1078514d702135a3afde8b26e05989ef46b8622a91ec4e56bd6fc6256de6befc9adde45a3ab3cd72ab71397a492cdb71a9c5d175a601f3825a1378371b02228e35621ff413a97afbaa641d90c6cb4d2db16029c613d3d392a0920f60b7649ed237e590bdf009f8120d172484b1d931a0d6dfb123bd4e3fef13e1a751e45a0ac81c218ed1e264692c8e70f37cecab5645d5a0fc9a9a49189c722d79dbd2bb5aff93c44c27734ec27eaadbbb090b7a98308df0a41a4b5c27cae69eb0d6989d3432e882e84cc8dd81da8be0d501bf1f450eda7e0e659df3e7c4c882a3c94af423b67f878ae2296acb7339ed6c5944359ddd58cee640c5ba3fd192f482e36c04310275ee89f9582782f626e96f489ae0985a098e4f235f7099e0bf0754bcf8cc8857f18c9458f19fbada671b13b5802cee148a24c86ba6755f81185f82c1e699a7d6e5f67cbe7827649a00d6530601ae34a62a9bfe9b35db60eedc2f34de9a6341f7476f5d2d66f2f628efd551eb28d145060c595689cea90bff40361c6b161dbc706e195eca07a4b12ebc0f042be51a1802380953b6648e826d37cae59472e0bcb8d546402a1b4474a6e3b1aae5b5609c1a3de351809aa09329d90f419b2e575e85895b66fe757569a8aa546b07ecb5a51855c01a472fcb7ad23535f454336a14bbf3573db1944021eb3c7155dac1fbcfdaaebe5e497a0c0b99c1a3c0ea6f438f7b0dcecc389df71d28dcde596c1a82b9d1448d00b3c0e22a7e3dac6565366b25657e49793749d57c43bfb7f001263d7437304b61f6537e01c37214bc747e0d1431031218bd9d70a62f15e0d23f90d2acee9decb199e6bcae03a1c0f2e7d027ed9005ddb152f7e254b59d5dab372d50ba1496202275fc0aa92e14187f75e708b0504e17a5234f33a21b3bbcd647d03b0be9556e7b72a0d7f791d4b97319cfa6e77e5bc3d28655904c5d46c993909fab4da3074829dcae75f70d515ebade95f2618bd7ebd99352a2d199dce443732f8c505b82f27f0fe61b68bd714b5ef8a8564a26063360e6f51dbea45a4b8fea1a5d76b7f4ccb1f35fcdf78a3987fcbc0cc3e748a90bbf38c5941a150eeeb873b846257dc0b7a8df67e5408385bb8ed2821af3fc9ea0d1c222b28b9688c34bcf6f8b66409048638588c5e5722d439f633c84dc0029a2279ccc6028536ff8b23539b0c03ad4482a2b7bd950f2ea2f6a84985010a6e2c61812642a8ad6be25ce2e021dc52cc12f02f34cadb6a785a1e58f56b419d1e433d08bf79d4c78c4bb351494784af292d74433e8b34ef52a6e891017dc3219275d890322c1f231af18371b197b58d3638b9948afe5f273897f47e9e994edcd62948731ad07c9699556c7677a00dc2e87d0d6399e96af7b5b8981e4ea57e41b766d972952d0a3803c292d231c7a3fa77fd2b01d0f85baacec02b9b95600d0828a69aec6dff003e6131de98d742dce23e39d33d9b7f34595446b3a57c979db9dbbfb677b25146cbd42a59075a29fed72e8eb45c8d037018e3ef3d4f447f465dfcf907569ef8e83bb1fb773cdb1b78b3dc4ea28086382d00754abaee61ba775b4d56dec04ee8b0da64d73ef27fe50e36e2fb8dc891f37ff4f1c769ec36100578bf7e0842e1f71eb098517d99931fc561feb79e8af40123bf3673b104df8eac3a5c7be859e0f6ff3cd63704333a54886b8a225d218c4d0d4bf5b95bd5c14e703df0232151e769d988913c755d47bd3f860a7efee6f8296767a358d148b885579288bb8b278e6860bf109ef339e5d3fb8b2159de4ba5a5d2efb2d2847ac1e9676c1b81df4354102676a6b54ecc56e7f72eedd7c3d58ddf398b6befdc4bb5267fd4bc7cfbd6387040b852e559e332bcdfa7e91caee8112fdf50bf82c666e1da406b016f80a76ec93e4f1a086bf17841bacc43cf97c94a1d72cb117fa1c0b05620e28c7489875225323a64e8d847f61816305ebd2352ced078640095265815b1a302d8b508ee403007a1e5ff7948b53864fafa0475cb951a0dec78c2174921dcabaced0227d36ea400ec41e72661d3f6a852c338029baa05a48fce3479c9955b4e5062e01b26ad512b4979dfe397418ba339a96d9a64bfadcc65ce650ea1473967da929acf250625a09425a33362fd889fb5a453a06c877d10c8493ce281730d51797f9c9bf7e39eac6a0b5998dd77105e2dd5dd9c738a65fedad1170db9fe5751736c58d99d6ba908e9339f4cd9d3e622c01a745d034849366319ddf3928a62c134ffba5d4a9fdfac795ee4aff66b0f90cd3ef3b20cde6ebfe25216dd6c82600cfe00c49c6680c4ce4f80e35d2b8eed8a4de891e9ed4fa712d40eea84eb96ec611b23897d5e38522e395b196766cc5bdd77f634b8cbf32e7792795975fb8e75302ac0b74928340bee45143db07ba61d480568bbb93abd0bca6fa596ebb631bdc62d8be033066c54976ec49ddd94dea2e05b941df144d67da784baa4e958968ff6b6926a523ecde47f24c4015e63aa20c07f61e66099e52c9822e65ac6ba9a25b223636245bbc3055808d047e64d8bfe62489c4add69c61e1a82133f640ca2440bc3b563181a6e24d96425118cb825fc469422cdb82d4b56fcd5bc8b035bf54b7af9f5bfb7b7bd2ee78a29e068e0d5d076f0820d9ba42dad7f22acdd9e8e1622c08c7be58c01bdd5f7abf0cf496774ec396aba3b36aaf93d06130409ccc2944025feb3cc5c127f32e0e3c1619963f7e9ee5775af5ad9384a6830f390bd6587b42f4ec307693d83e3ff7885115dd4a597a9347f12a9a866ec8dfa4a6728631899ac8d95670f61a3cdfaf27e60771a456622eab75efed178462c17e8cc9e2a30ada94f46bea5975ffd382b1807235f6b16676643dc8ac20d366ace38d706667a18e9492469f1289d4305c00b0147c3a62080703f6b860f95bb019fd824b3fc7b48d1f21f2f8f0ebd4c66afc2d646e812d88f83421374c511fb64212907de72b0670a220a78e73120bbf283d3786176fcf3df40051db480db8f1e203731176e7d0084c779d75cb000ea31f0be21b0dbf607123c860d4f4b2eab69b019226478ae2ac9993de4d025f15c822c25234896cac794e569a6b29789fa234bc244caac81ab21c5b433c37db00b41e4826db376b61a99f6aa4b5fdd5924aeec635d77367a4b6a73ffce9d316b2cae6b85badc80f36682884d994dd5096370a8d0940ffa7abd1208760737112f92eafc76c8f83ecb00df1f5c89e4891bf2a1a4f1091849a5c25a98bd8210e49af306a8552bba8dfd26f08c4533aecbc883d63f113383abe4417fd757dd38ce5081e5be42768e75e06f8ec2eba671d87acc04b1e59d242d5ce32c57958c5ae2e9602e3506d3a5fffa176383342ef050bbed5ff2defbb0dfad5b073e28cf717527b387963ec421eb82c5ea908cff7d9cd113bb4e5ed316d3cf62908ebc43bd8322e54f6a28bf8b913bf00e1aebaa73783a796eaaf919e21e0f50ed89b1b794349f71b81becabb00d54b9a3980c5e361f07d9960e1ef32faaa00fb964a47fa88044c3758f0586eac8ec8762aeb215b2fbf8d99c95277e9f33d1b758d4d53c80bb017248e4a84e4f4b7d39022aa19352f22ea9f48c8d7b2fae3b983a929bb63520c6e84203f99a6b078616489c34bdf57b99e3f63184a506601af5621e6e78acc876d631d207abc79341d66867f86636c4cc5a15e78cecb73cd35bc8bb8da706d82306d472a02bd47aa28c640dc853b78d4cb488e9fea06b6882b8c7bc52c83997370faf4502838d94af568f934ccd024a4df36ef12f9d27f049e3a122cafc0c2dd4b6a8fb5de1069f8ad049dc874693f9daf4848f8c9f87c63dca47b0296b91bf3cd9ab0d77fbf03591c20152501711fb3d54b483b7f8beceb1c0995ff6df640de41befcb4e79dfc3b2a5554314102766860bb8625290074a3df27332ec7fe3d1ba5e4a8d362b7a169619e6458d4d1449451f21f7371e1ec2a0df53c0733f1a064b552551092244a6155463e754f61b594280450b17dfc984a1f77df13a811e18419c25d1032c63e0d7c697d617fbae08b33a366f754cbd18a1914d3c6161a5d5381ff8ad03e0c8301c287c84dfaab02c2eb1d3f8319278a4e22f88a6e406fee17ee12d3d55c29fe230681c935d9f55359f81c1249fb9df403a58741c48e432fb2a605b62af1d933feec3d2302982e3e55807b47dc0bb41fa11ea583f5b08a3142373c91f2c0c5a0519c94452ab9aeec86bc71df48dd151d9b1a0ca9d7adb89c566db892a8855d789b9726b99bc78d2f92243194743b239f323baa968281f9b1ed3b49da077075113db15ffdf1b017e0b8ce989768c53ce3537f8031eb38aaaa2c422d1cf2077852db8f7ccf8f219f182b9d595d3d3702c502a15bb47d3a522f03e855b1a1599a6c49da4a40fc9513e5b8f8a1820b43025594d5496626bac9b30d9ae374449aafc975cc478a3e520ee1fccd7009d462b1460af4b7a5ffae60e20870c2058eba2bfa3578aa3c8f5471e5f71fcd81ecda584e5d868ab4d820a9a4538df115c26b50ed4d3a958eca41164e1a9e013e1b263360af49930091e39ac74cc235f630f20fb928ee0c711d0576108fb3921ad84c6191d5adcf079ef78445fd2731db35d18dfc8eeee270fa1f044a8e915fb251894fb04c6ce623d248c4835dfa3b4a03ea738b5bf70d67644bf0d9cf082f576c926b1ea6e89dd43d805b806ef470678817f3539356c6ca29c3f8dc90b81cc8978aab3bd5c0a7476eef746264b081519a5328d675009a8a725175624efc181eba81cc5d11460c9a264451cbf74f15cada5e16fe53b5d73ca7e85454de887f189c750775220d995fe5b1c704a3dd2e100fb8dd3f7d56123f4f53c13c053bab490b66f421bd4b37346319fde3bd308efabbc6027d8b6b85f116487547a24be3212fdf00bafb020fb468c193a45d37f477904f321c8b67676bc26101936a9019757aa69aeed37e65e493a6aca6f58ddd032a1a9225e8c05d650ca774e3e1a8e6ef92aca542ca59169c84a2bf3650a8ad192837a26a018511b91dc81733afd339af3593eadd7d6eb29212023079cda27d143d1cbdface5c6fa8a7583e5b9ae16b8731479562a86e9f916be2ac86dbed1128ea4aaf16332777eb4fb6690478b9443cbc3ed94f302d9943b93f3b7f42c5887520c3bdf6b3904a697f98ee6000eab528ef6eaf1fb8b0f7f425f1fe2cfe190b6584212c0d9bb349a5989b566cf99ae9cd8ec0433059b21555038e7f435fd3b9c7b0d4c4682fb0c245f36ff6eacadff5f1e9b162728a534f0d81b3ee2108b6e209c1fdc0bd2f969f3c459800d42b88360bec110eb5157dce6c64d3f3beb96b56b805ba31e4ddb1ef138403ab633948db30d5bddc48d367cf131d027cc168011fbc846921052270ffcd87aed4d86e34a9a619a204a0c6d374a8884dde27cc7f304602e4dc8c3b9301ed5e0b7ac10a5263a0fb022c00f5a45d54dbb4e0b5c48c46f731831c59a5d4db23abffbb5fb83b7088490a36246678daf44eed29e2b7c6001c568148b178e3c034a68e1cec7af39a271cc1da62a79c761eea66f7fa2d81149731be9a7ebd9e61bca26ac325f88b7227792f8ce1b7c12ee193834a22b4424231383d2876c5b4fed45a3dabee3dc5f589a1647d8860638022a623e93243ed5867455fde7e5ff9183612ad582feb459abbcf203fa1a1b25f52397b493231324502f1ece5bd466abb71c2f56bb1d5b8c858c805fe9f4cb0aa3209aa425f54cf1ccb39b95ee0cbae5a3ef1d1ccb480b4a7fc72c92fb8af186c1cdd6f1eca5c9024238ca4c0deb6b4030bae79f3e1beced165adf0801edc5be5d641e3736ea1404d82f532403ce27f00bf10112d62e43ae68334bcc17c86681ee9c087229a700284e39f8b42b9f8303b7e22a05699a9f1e67af62cfa36f564f7a3fb8188e12512d4dcb3549bb1ab7963e6e0b6c0348abdc2b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
