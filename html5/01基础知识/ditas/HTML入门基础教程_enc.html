<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ae9ef0a8ce3b884df594db9dec22651df14ac70338e6a86aab5d033f6c0ced2d2d20dd0020c55df51ee5fd1dba66fb73264cc8332f0c2f59179470bee1018247f3207de5e88f49b2f36b5aef2706def584e0c8d7c939373ea2708c935852b55cf84826e4b3b765e68c4c3d973d75745149336b976e1600efe16ec6c98f192683f3161719d319656ade2ee18b5ca207a222a2251888bcc51851f80efbc9faa30a7c19d16743fd4b319dc22763dfb597088d2fbb337a21af643868f7e84bd5ad873a0dab182e5a8d7c85a40620194ea3bd962ce8e49469be7d833285dce56d5384ea616cb730c604ac79a90e89c12e3e4e87916dc40d0964bf144bbb356f6b25b675c66d53c5c3e3b3c5223f5d5e043777063518176b332970b303bb2a988e022feb5508efe9f8766536c0a93194d8995c4bdc5d86783282b26cd7ef09f019da8d044270cbdc9202e72f7f2d05378c9c550b8ca7d9ee384c8b414ce8090a97de3eb34bb058d219138907f962e7b107e535bcc7876e5c7657700d56494bbc7ccbb0421dab784e79821ccc4a93c7de355a92224fc2ea9d4d1ac4d04dc2d9974839f5cd589e1c2851a1a7523211343bc42bd554913a22066d209803fd10c886ce0bc0fd3a8a6c47ac823ac5c1d2573072a132edcd814042f267df310a4026a004da5c629fb4024a6ee72a791c648d37fe3e05a617687bd61e6dddafb67b92dc6e4ea014d8001f326d888c4130e26f27269e7eafe91e0d29265fbf54becf3617390b8ef49b80f52d94bab385232396a891c2e3f54e4537739b1caef3a2b099588fe249180bd8b54bc4526585d4ae79f30cc8bc1aaa4e70a4d566dc9830bf2c43382ea5ce686732a5c7830e03e6167f0bfae1870fcf6ee773ace420de4892e00bbb71483b763ccda807f601e1d90c104c2d1571ca23f06406e4c797f3b945b268bb5248ac944a3973012ce685783e73c4d8fdb19f7db4764c447fa5843f0c82c0c1134465d85f24f6d8e56d7f16cc6b5e49c83e75bb02b285efdf94afb5e9495ab0d4bcef47ec370173b964f1d7fa2a34c1276ceaad0a0acdf7a5ab3aa250c8768bea5bac1d3d2ce9c9d98be396a1e5a92958f7c966f60295a46712c89e5c2e8cb3ae66d0da3f4f8bc50a08685ab06eed5da62513b31f661b541294f2edf54453ccfc8ae14e2482b7f670250f57693fd41502200a37dce29a1097d04d75aa4e811bd4b5167a7c6c1086cd0f9eaa6245a24609b84c3ef2200530408101536f62cd21f21ce6fbd8a30cca88a557ae7b7cada58e39e78080d8f46c7510fbab9d5536788c3c34b35cfdbb9e8cf944a91887301e5806c9fcc2985c3bc9eff5bbcdde2b59932e4c41a5e2918157f25f3adda7500fc16d4f65d7c5509878fd6f36d839a8023f91106f5865e76f9ae1c631ba1c4e1fdfa9a42a07bef7729d01e02f1a86e04b3235e6a2ef24184b40519b0b3e4845c7373aa89ac1491c76dcb4b0decf9f39741a100fa3d824c1582376edab3f63756e3e3a11915fda40f286fb20331491a9df7fb84b0423ce617223743d1ae0e2d3c1a79b983be0ac99276579d5c116f2722bcc3cae4817aeaf48365f976e35ed2320c8c2dd98f93e724b5b5715e8633bf40ed1e980f40cd30471b3aea7c8013497b7ca7b9430935415f91438b9d06314a3b5942602e08584bbc27f6009bc5895ee1472508e1a8043816ecc6de289a8588a4feb1afad833e546892f920c594d47f370d6f6225a93c26431dacf76e8e12d24e622a2b0e4936c7addeb7bd8899ed830ff2b4964cb91b5299657bcadec5524b914b71de256601bfbbfea3e57f8beeac32df46d1c61a3c95d879c5af07d6fdcb931ee08873c724ac3f983828d3c6907f50e7fd7852ee8924d6526c935aeba6f82a3f2f2b343759d83766c329f5f099393d70e93db12c86ba47fab268db665f35bc1f12c96bdb12916faadff305d1444e696b251cc6f23e7a96fe7c5260492c8dd64379906b67edc0607277151da7b6575da47e2bf517a9248829a4d2b2f5e3fe3fa2e6f7ca6d1181bf2bd898378a9620609d1a8c003b1a8ba145dd783bab000db4dc25aa6b5242896f3069475174d0d36a8fc8396e42f1526a1932f36839cbee82f926dd9c9dcbb0c7ef6bca23279e61b34fdb4279cde03aa731a5ee84c3669583074561d19a7e601fb2c2b7f9ef27348fa0c1f2e6fc6c0e9b566d91e872041a7fc5fe5dd888640650bbcadf3c8bb221856e6ccc4b25e35ab9c789cf404f9b0f9c7ba8b4de85f46dc200aebaaacf92d07cea53bbc346fad893b69ae61e801fe33351c0068b46e6cd9ec1876db4605806bfd3c441a61f72b449bf7c5106c8692d81aa4dc88c5ae4bde04bd1f1310d29baf392e927034e0e1414859e9d12c2007d88ec86ced598bb94944182e54aac3173912a16a57679f5b8f49f14cbf7281d3e282278593f07d795582993635613a67a0edf38757081399b289421427c95a7aa3b16b200264ea778026331f35428e391fa59719643aa9871e02dee88fbde534315b811416f7fe1194711c211980145821e53ebf0be90096ade716fe965d80f55d2d978b5567f5b8a5b5e90907c868bfa5d40c102497500d672885c7cabc324b08dacf9a387055166142e19e2741bae9a6823fdfacd317919b927195822e2a7a8a9c72ba596563d0c2508dac880ac649d75bacafc12882aff183d144e436cf08625b08986e9fa27ef4f17c8418e1ad28ad35c522b9a978d2b9962a2db0d4ce48a679e1fafad34f2ebdb431ed7dd0fab4cad9a3c9871079a11d0100cb30c53b2bda6cbe45c4d070d6351d6b1066ce211e3ff01992a835b329cc488fc8a2d99d0896e93dcbb94f88cb6daa1b3a1f1fd083f928da6b8256f015b63da7876bc003a72bf5e6cfe40d510d6c3c111d7160d76db00a2a1c1976b982472ae64ae7f765719d9ab0f74da916a95106c1b1165910008367b456b8b2df7c692d3a71598155336dd68d2b7e83c28a3b72c8e6c02d1a8235013effb4bfee352ffb507d50ca503983a05d96ad2487e54ba1ad73ed5ada1c650ca57dfce9127a4a3b74aa98128ebe8f46fba5a5eea070496ddec5f130c6d3cfe480c2192c88f36fc7568fda25d42cfc7e69cd4e7023088eb141efe1b39c307dec98f8dd2c9ae1867cc13b2c6d59cdad7f343db1dc443d06bed1f52647ef84960277f492841eb26ee9c3aee098629a1737164f31410d8a154a1ea68b4fffdc9d092efc6dc5b262bb71ae92a8531b76949b84ccc045bf530b33dc6569e3f12bc47defd70630dbb75af921f83a7fd7d9762f8d3768db337b38108160da1053105dc8709fd9218b6824536b6e9ffd47a4d6a8a1edb5934b967dfefc2486e4dbf71b4848792edc8659690a3bf32d3ab0e9129ffd5a6f94c0e041a0463e66b59ec07b33d1ec381f6801b4053cd2a03afd43ddd0f0e728f43cc84ecc38b39f6907c4f0f10ea6f5fd3e72e4e59a195ebe929410621a9618a5df517630a39eeb7b71d5d059568b6d6d82d065128da37a6167a723b563ed865f49befb00c7399b3bc726ff34a706827c4544212e8f1ac7ce1e8232b76d6785cf45acbcdba4d182517dff07d4b3ae2978cab956bcbf4b380b7070190d88436f67e72f4287cd2dbe00ec2bc904a49046445b91f8fd78c7e53a8cdfc0c494ef718798128feea9cb3cb2725a5c3e082b0469dd2530e7a07fe09ceddfe29718e945c6c8910d4b7a6a62ac9a44b6c333b22d1e1fac36859cec68719af0c5ce2d3fdb3c4260d1b8cac21d86313042961e7094523e13918b63e1bb0711daeab3d7072bc848e9da37d8603225939a4e35b237ebb3759558dffd37a28a732d7b34916ce720fce9ceb7ef5323a21fb79e572674e3e06c7457832a5402abb76040f0c638537c473e771683394e4eec8c11a78eb71dc5efe6ba75d1016f14b6a817019610a7ec336247d56c4eb5426a49296543f9a998ba6ec37cbe931de327e9ece3e0fb54a25062fced2bc6239a8ff2060fb5e40ff8eb03375bfb04db234c171092414068c0aaf4f289deeb2acbb6eb53b87fa8aed5afdb8ee4e17f09d4f12703d0fccdbda1f29d671c84a9dbf3bb1ac5a0c65298dfbd48dce8b0da084d6af1b878ea2f54e42cca3f5ef327ddba1d9fca0fbd63ddccad07c56ca389693b7b9496d3013cc26a3a506ffb8a2d88893a06a480cb4a0537cd288fe4ed7ff9af121a448e911730ead2c6e55b993ea0db2e9fc6ac101cdecfa2db5a35d321bb56be2b6fa18e34be7fa75663be84b037087764593e8f7fc6092c2a904f2f446ae0b3104dda708fd0a462f4427488e7248a1d3ddfd3f0adba248fdfe7c715d11e81428a6dd3b50a68702facf3a27da2abeb8644f1e2a1e184a702c7166977992ac2f29df69407e3869e586095408c6b3d15be63c71d223a1db4d818ab066fc118f4a2afcb69b8d780573f60c4d0080d02d7511680d56e230a4f2e6e6ec64cf561129f6cb318e1f87799c0e3542a362468fb404353ab76c72f63e04bff89b833a534cb1ccf4c579834d63b9c1c2835e0f7d0a0792ef40a234cd85c834cad3e690f4a80b57f5b1b664d465440484f4d95f079f878d6dff9ccee0687394224e16e88f05a0a2dfa133416bc0ede362c27344bea0829dcd7b7df853dfe4b58f6c0de5d1c76c8d64129e860cb5cd39f3a9506abbbe582309155fb02f4009f0cdea9d2278afc3f17bc91f1ee095a635d3afaf1d733f7921310e52a66118d2dcd696f5c38ab31ff1abfe582552d41fc37f53d5b9ff59457544e9bd32bdda9a49e494d73d2d411bfb1934c5a3765481269576d0c843a25887368dfcdce4fa4b8d745f8edc76e8b0f50a68fa6627c1c5ae6b1ebac8e84659610c6eca65d9af610917d6e315ed44ba0970a8549ee3101cf35437e5be79797dcb442e514966567090c2f4dfcd7a0887d825df4d927787b929d5a08514293c02f9b44f66174ff2d044f64bc72fd5eda41b09d38ab3d602b57360c03e9e232e06469a3d82248e13a2a2ce9cb4b0731acc7389fa304fcc7380074fe7bcc6de2a1bd92a58a98e6a42f37beacb360212ff973f5c7caa21673bf310de865711830c4d1ca072941358f89386493688ae14f0674d6dcf38ed5c3002f90a6c5e10bb3a67edda4413e18f73de34690c06766e4f70314565e1fdf9298178a79ef784b932ff62e050593e2a92ec29a5614f014a2b8d62c010c919a729a92c1e223f510816e52f878dda4c4dface8b192c6b990cc19ac68d05bb6b064b7eba9536e649773e216ba21e3c54ee45a84e8a1bfca52c71ba836c7434ff938e9a61ae53672eea1bd3eee3c7c7c73efcb9ebadd3073c6abbeec608be2fa63503862fa13d290fdc1adc00326962d4a860eddd3442cb58b478349ba589e39adf1bdc982b35f989a55a53685660782f922161bba15b004377cd3c7295d6ad3d772213c9545c0afc066c39490a8bf32e0f452a68bd429049b3b13d88504d434a4ac2e0a82499498bc48e2413ce9cb665cc41024e88889fb151431e119a961a1aa90feccd20c9883caacc896c16cddef61b781766584fb862cbef17d7fb8ccd0ab7c4f50cea9ff32e3cde94ff6ecf3510d00de20862289968dbf55ad3fe0c8d5282f184478d942a85c5229fe4e384395f285110f8f53397d11454416f7381ad088112d2e302fac4eea8f7fca752254c0b2ae784383a5417c04c4ec00aada0374a5fbebbc45cdae8407a4d23028691c5d9f89a1e3f1f958e7b7b02e7ec29bd62953df8f5e1d79598f43fb5d4acbef405030d0b3b074392bad84d40ef8c6705826466066d2ea91d5d164e0c7758f9942e7454d4e92bf020ebbf2b8f6e9b9b4c3d7e8a53d377f16d1ab5806d2aa627fb798d80b42555de60d03d8bab756437f5a59f066c796e161bc64aa528701c0d64517a7a36302a74fe567c7bc81d6bdbacf13dc5b3ecb5c2d5da7de03c17f7bbe71ed6034df40e720cc5805ca17df5ba67f0044a555b241a9a670aca7c4e706054c4142a023175d0bfdc00126de9111be90e8d734a6e467f26a42c320760f2250cf8ba824cf47521e554fb7f2b95455bc5c916d5162312aadc0fd055e1626c640ec20dd1632bed719e8fc1c0e27eca3da1b8aa8e397513c0ade250fce882579ce93b9a737dad1b40f3abe78d6bf2103b29b16b6b5469566d7e0c68d7346d1684729d93ad8ee732fbe5906ed3d5e0aa974b1c951dc684536f639e097f130488a7fb0abee58c95d986ed9f56bde5f82a70b604f819902b7a7d07d760251b70aa8d4f5ce38f2a82e2fd073420f920978d3e76e1e8f2141bb1cc7ea9ac50afe4df438d901824a592783014429bd516e5e0cf35aaee5d47a24e146ab939f2aa999a5b94bd3e008510deb3470023b2aff02935c8fe78f6db91478885d35e9599467d752e27e8db73d405fdafecc5218a4c6d41224cdcd3244f02e9368b4297a9f7b914b788ec5ad615444cfdb83e89153217bfc314412850cc78ec8ea60499954f1b2d4432397cde78434c096b8e2fc0fe03ba2186ae81733aab06fbe28d9f3a2af980569e06888ea6c87ac40d2434b0d0b799ddeb2716a4d27cea2305c202a18151325e86d22e0a3552c7bf3b7bd2ddf34f5f485df4226e47987c29be63827329db62993530fe41d173a4d9f4ffd85aea933b023e9ab30261b03af582356d5a7824cb7ed75f93c1450fd9b40e0052fbfca3d4281bfe7dbcf3278e1b0f41920a8325220dbe484de55dc6b93db6dcee3fbdd55d5c9e02af3e63351ed49d4e13cfe67e30f245b7177f79113742caf4fde32bb2db458dfd2883b8bcf5f44731239cf6603f4bdffebd25232a8bd0177973e5837f566ce2c8afa8ba82c96823e3f218b6b54cf1c98c2ec14374dd3a74b97137ab61dcec1712b7488d94b62b1faa0116804e0d8aedf411a0aec619b3d3966cf4ced50af23c56251334d630a5e40783ea7bd6f34dc8b0cb1651b61a47fb133ac9bd25355b7a1ccb3a7b38ea1b6a94929e20a30e16fa79ac9e251417ce63131fc3d0d76b6543490c4faeb79ed7d9a34cf62e92e29064c017eb2000f02fc4481caa7eb74ec7f52714480fdc0c4ccc1d23e8e71701e52538c5d07c960a163d2074fa0c9d070ac913e0daf94efe99a7e2e12915864eeeb0015b58862a3816b4d836322b64e8770d059369ad85abc3337a88e3c9fcc7058b09d28c4c2b6f38a5329b34c073669c66fae1417343dc7557f4c6bf374fda747647de1a44933c0b6c783463e7bccf2efb61d0ad7c5e352addec072f42d9fb52cb68f38e52f5b5c1bb7a083df0f7f2a4988ef86b25965b2f023f0c7fd1bb1a51793f52c841ce74013c8627fb83aa69012a6060cda7baa2454115c36a2ca9e4c01c18299c1680c3c9f53c84f8d6cdfc790a6dace18c73520ee1efcf3b37c41f9c209e367add5641f8fed7aa1199717e941f1eb893edae58eeb04f3e6ad03398f53e6ef3c3c7f23af0c1fbb84876c6b0f233dcfae7b9c6cdffac68b91e46407c61cc120057a946c49726d383e2df2feffe98dfaf8eb97ad105e0ad7583ff9dccaaa88158a5c6fd027cccc62d0ae7587d4578b23766bfa756cf8e4ff372c0fc90ed4508bb150d1a2c61236913c66214b55d91e2b95aac7954278b4814987e7661f2168351db913a3c3fda3c4da5d648cf5df7dc010b00b076b23dbfdd6fdad30216ec81b98689ca0497f72ade7599cc654ae2839efb7a78a4cb7a5501f92fa404f6712df1d0f8fdfc9f70dc7094b88a3f3c89a6d58343a9e963a0e3dbe0083ae652965ecb05c5e14837f9aa4d237ab660c238794d28f4e4032dbb9530a71e35f58ede7d75a72510017da9fc216296040c35bc291f43c15d0c5e236b3b6af5d52af0af60a3fc12c11d2f8ccc01e80b6102cf4a466a07caf661be1f96aa5f1b93d29a2e84dd5f91392a1ab9eb05f5f8d660ea261e35947d7b005529e869274c3f6917c3e4b74780f3ecec677442582fd3bd05bb702e35944e08e4e57e1f5f3d7ca6087fa47cdcbf80d37c592bb8b04e288a3edf5ed8aa2f7a84e24fbd17d4aeea588eae39360749b143c4fdea086e57823a97f7f406b10ddc2bae4e71cbc41412c4128f9f1c180264801218a501ee606c6b98dab4f61c49b77d0b01b2605225c9a95bb85615bb532b6f123c801298fc8be59647958fdfb3f2177b4e1cde62cd686bf87f1d1a974643542f82fe606b6c1bef7af8b9eb7621743b645cc9b04846273fe03a02dcae53dc188217ccac665f12cd22f3cf796df5381e69f091e613a8150620351f3db6989a7576dca7b9517a9403448b58f773efff4306dc9d156af7929430429819b2faa86df0a79da76903398dd9c3cbc83d3e4e4128c1c050b8c6029614a8223800fdb9c3d8711b719ace517de87c82648f66c01a96dd0a06e6a407a8ac00e1130e6831a1857c570f8d719ad5a4f968492affa2753015038f4f500fdc8d3558d3f7e0eecedb5842c567ddb70b30a65f1f53c690c9086551c10feb8a55d7dd22ed403992e6f879d6cfa59d662ab017747f41541e711df57ef636241ffdd0c3e2ead160efcb57246a15107b83f6df601e9631b06cbcb8b9f2d2c61ebdee52d7e6055c95994cc01b87d7994bef2cb8c533756a4be71d9b1b52f9918dc82edb105c2d5265bc183f0b84ddcbf2fb0ac9f7d45bd78ac96ee388bdf8a80a9964566ae70270225caf7c6b2e1d0aaf37400d7e638426a578359490de88987f1d5ec3a38453bc4fb1873086fdc67066cc2cc1ea8095c47ec13e5b91290156c545676c0f5381c157340a3312cd9d86e933e57ab0b6bcab0299ddbb36846df89259f1f36071edf3cfdae073d501be53b01aa1855e76f50ef214667395485152b6e0446bdda177793246543c62f79cb3e287977d4a283934ed026b721b7117ad8c760b00b6063d063ef999899bd08954106e7b1b27fdcd6b4bb7478ae67e08a733c21676686cccf9f5ffa76d556f0c55fff6e448c7e70b0364c1a4e97ae3748d6611fab236951a0ca481a75e6c9f022af46cd1664e5ef7a22cbdb719d228626650ed11054268d9098d7903e6d90616771f088edd79ef9af52a6211618493ed6e318386dd000ae8ba139773974e1da1e4de08426bda8c0d6424826992e8ffd377ca9499c7af7036485bab8922de45cfc2e8ad76b5509f28b6646103f90eef39e1e5b678ce44a554f5a332e8f654016d988bc1ac89fbea9f3df9e1ab882cf903bd15c9df095daf61922a05ea921fd448f0ec86ee6008637d7d1c18036e62160218dcd28a4171c37c4e160bc05f31dc22cd77c789c0b54328984f36606bbd4b7f64ccbd4f42d0fd4c8a7fd2cda65a5783a99eb637ad49139bb2e11156d444d65ec9ce19722be5f52ef9fdca5850978c727d1c8580049a50575a12ac85c325d0c5e15a0c2a07425f9932dcb356079ff02c2568bfd095e9334ca7162a9eae48f4118ccf261a4225dca5faa9bc77716b79efb82681529d9d1c0d029c06bd4a4aaf544ff7211951905bd556e4c5ce1fb3848bce26606e7ea5b56914c2f023429da9d527227f2f8df5d10b910feee90177bfddf0d1bb9f5753950991d38ca6aafb4028d9c868ff02e21bbcb275fa0fba1a0c63053ed945023284611978a5b36fb5aa7cc1b76543c7e9d72c12f056779b937e4f9928e8cedd70b72b2c7c3c7baa76260bb69e96840d9eb141f6fa4234374ed741375c3e6cb0ffdb62cfe137a785e1fed92623cebb36636a2afa0cbe4604f88564cb65712100bed52db04d5adfa473c0a881748d82cdef61b013d5db68184615118830bede5426ab4ab46374f57fb441b5418edf1458e5ad83ea0bfbb3d44dc7ac0bf52371c7573381842ad16ef79d397286dd4d2c0097beaebe3c718e9b24b3c04d064acf626e54aecf325f9ba56b5213bcaa469a0c507b9ac8512cc3b99d04cf8e819fb50b486975d27a522ef87bbf375d480158c56215b0f3392f17bb2371363bf7b95e6e6cf0fa5467643b737b02514c00957942a630d311f5e88ea78e638d861f949339f8d86ed4613dbb01088a9c9330c76102c9d21fe242fbe59749aff2fb2dca7485524c739686d509c9091c85541482eb0613deaa8fbf1f982316567ef02d6c0b4c2b3ae73a557bb0c3e3b8dfa54c9383dacb44aba7d8a65e0b48c63f4f77f82391b10a8567921e3be6da6af1c2117f550bf657d091bc96ea9051d762bca21db403af794a2220d377895eacf4aff07a8794d391aa46c35e1df3caa9b4c57b6ed71282481c6cbec1fe8729482d04935b686e4225e3a8fdc7787c8074fc0e414177689bedcda31db105d8c9fbb9663576d8cbb21f136b0de93fbb695f6087c75a310cdb29dd3dbcb8dbce841299da614a604d72112870c646d91ca09e5ee4707780aa59d3b5214c7c9fc0e195f81b1079244ca4c508d8dcb673740598b9630c88007e18954e0c08dddaf52073852be5bfa03f9d065eaf7a0007393d719c6f775b3a988db07e775c72c779d18b619a2ba636ba6e7684a19ddcd5f651ffc39b8c23e26d64f883f0b50da71c64e675e820e79ecf8b78b2f6021d6c6a46963bd96965785d910352246d19c7ed6c73ad07c93a6f2c9a5f18718716ccfdba1a53c5493e19fb52db7e5d0c1d697aa9ce32aa3a1d579efefea2f89ed60aead05853b1076a58445999c45ad0de855d95aec41c9d62078f41ed426d07d5094449fd05ead55b66b7caf10abe76e13609f8d65cc87836ecf4e8e8ec4cfd7cb30089a70430e234f18d6203d9737685f151ada31a2f7241e2fa49c6aae8be52fdac154507d4904614b5a64f2884347ec3b78b51526484029c193a4bc232454151d4bb892cdf99d8894382417f67ac30f6cbc8fa90ea42619b788aa08a7a33f78a7a137a509cb3c37d270b3c55ac90b94602df687961e0b689028645ee1ac8a6a2cf7274c03305e19cf74bb858972fc8f15dcffa9d3dde3df6d123cca3dc877bd58b7537027d63f8d128226e1ed08a876176337dd690ba2267751f7a6d8a83e16a950d2135ab87e7f8d0738620ad975deb86ac58573044afc178ca650db961825d9fbb58ac0cca0a92b450285e4c1b363ab9a51032783cbf37319a692c0deb3d92d086e19a4ec9b33f0adc4ecff86f29ebd0e03893883f5db56c40e45a4c2bee9d4eec2843136565d487594f58b7ad8a10bb03f7c5ba6611c2d741976519d448772b2b60091a540bd14c5baac048b444de3819e7f3903464ece4681a6ad3b5ce8a6d6f7829503786b760ceb9dcf0c905f7988118faf52b69349ac2d41b5edc46973857f1b8d2aa99160de064776bab4adca68f1c18e03d54ebf2637b9fbe2975198bfb0a263c520996f3ecae297520b7d89535ad3e6484b3dfe0439fd358e9a652b726ab7b227eb4d1d7abc2a4f7b5a5d853632bfbcb0e2e689f3af9fa708b7807ca2a888e2117ea010673a10c5b31cf32d7c1a132dafbd991c1d95a8945e2077beb0062a0a9278e774d88030ecf1066347ae0bac66e0941eb2c0283136427f7b0ff2b64bd4c5b7f40ffceb607d72a7b36bc1d1d212271f0a096b151998dd8a6c43a5c60fc380969b1a4b3f25e757c8dc2d5c0e46dec9c5e558fc89f70cd6b0143043d1b7f80154cee01ba0a7abf81a5468c5ca193fb6946fb4555f0a5444a61b56b023fc83f52751882a559f51681f1384eab9faa49c11cdacc8d96276d4f24d2a40590cae37d8bb3c9ca6f81fe5d17e38404d4dc6754df153f548e4f27dabba0ef5fed99d295ca46b5ad1b50cd37d067077c28c251fde70557fae0a6ad9f2e7c8b402a869e88db941c1f36f8e119fbd1a7abc47b1dc6e75f345ae20c1b05aacee24f02bc3ad07c71b9078230c34af8b427e0dac2f9101fdfb3144a556e7284963f24595124eef32e8e6ae48347a78c570bc749aa10d4bae83f6a95796400b6051283a6a47dc777e51f226","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
