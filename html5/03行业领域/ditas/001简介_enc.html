<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f846ec0163bd9de2a5fc0ffd4373a822d285389f0bf85a39cd355298638d37bc7e786b0d8deca1ae7f9d2ccb76b26cd6ef717e31cb759b644cdfe5551aad5abee225885414bccf8eb07df25e86ddd7daf2aef14645891ce4bef758119fad0a6334ed7c46c25a157846345df35bf2a3cd97231d311ad4a762031bb46e19f4731d9afe8407fba13d29ea1178d068c0439f47d2c4e4bcdabd02f5a1a61dd7c6ac37b79fa0bc567cd34ec32dedea45cf9729932c2a88693bff5dfc281012438f6ca1adf8c831b6523dac71a3ce3c199243775e99d67403c12973d3944cf53ac4bddda3057c49271ae249b9e4a77ac272bca129b40f7570927f7b3d4679e4149eb8773fd6ecbd2b97ae10434336dd341018be8ecec5ceff47692dbccd10ead01f9549f91d5a319560a02ad9b4ebbeebde5f88d668bd1ca1d9f5cf1f895ca28cc62d6142fe1f36c9cafe85efc5bb204c8e804b5727a45d0d6f07aa99cab8065ee9891c59e2732a9e3d4e59b7897004fae5c41711d5e54e76f12493606cf654c1ac73de627b2ef35482682a7547cf537833e7945cda5e600c3a3548d0f35bac2454911460de42c02f9e80d0748bf2363e9dd54e754eea207ec60e8218325310b962f1d7d84a2130e59a0731271dd9261bb3437c8e5d05695d014d3d9d48d8a2f9c02c8434c52ded4c523ad7dddbe37951815f9c5ea6070c372b700bb8e8e51c049cd463d344ae59900aa91422974f37596c7f986c82f4eaca9fea0a9fcae740b79d09be0e375b954a32bd2ad75ae2da3dcf0697d156cd8c2c1dd526681980a36142df7392fb0f87d2ca08273c6fb330447d182d70f81ef6d305f6901fe126a8a55c1f8f5b9024dfd0b909431ce2a112baa7d613b9b397e4b77f1d765bd582e81aede3046d8d1e74f0139142ef892e68bd2df1827e38cf822306277d79f357133933f3c53b1c276b77459f1189ff5676699f0e7aaff7ae63f6504b1c501446c3aade3b5c6abdcb3b8081628bd752a73faf9309f6c2c6e4d6450f0c19e67787d1e74de0670ba801b38a5437f7ac7e037a782271a956e67f02fc05961620ccadf63bfe2371ae1733823c5ad103eba154dff99536eb5e884568af1c39d0f02b620b445a9b24954f772f3e621e901a76acebc812e48d243200ddb50f0ec4d98bacd572deee5165e85282bf498f2c0082d28b67b7218be02b0bf0f546762eb3812d10fa6b1d0364be97972983776ef6f42462cdeff1e708d77c1116ca005676674feccc13a8d4acfc7eddf282774bb1fa37bd9859938b4f3faedc36d1083d2e3866cf05f72b3daadbaa239f6b4ef7234ed45080f876d430cedc75b99ef8da2d0cba0cfc9cc3dc7242714ee1c6daab7cdbb0572da0759d6d3c65a5d4bb67f5a5473893fa5a493eefd584b9ddf494749ea120015372604ca359a320bd338ace1c7c6448cf33b89d67ca2d3eba3e14fd5ec6d3c61a9f5087514bd11c9f0b3457f2f0624021de2d2a0b9253bcd79ffa9e36f7e0d9f382e5707eed95a4c11cc42214036d0185b51ecde2203a2d1ec51ac08472cfa1f2ff9b45d85440920c074a66adb30bf59b12534ce60b89fe01a649ada097748edc1e6492a3548ded2749e3276fc1d136880f082fcabffd46977f344d5cfcfe94f3d80107ffbef6134f6b32561b32d52ff398505854c07f9e735fef4ab358e1b37990401589c1641483467478f4ac58d9e8a2a4633398596474a53426b52d92a135cc38af2d65dbe053d75b7bcf5549e28742739a8e04a612ba93ab4cdae3ea968907f0bc3e68c2cd4a843295d9f61d66222ebd41b2bdbefbb994cf79f8591cf19aaca0aaa3f66a1e7fe5ac74a7a4545eca063709d3cca85e710819062304644c9c1f016fbea26f1cfee0a7f378a74f4c8341c5b1ef89926cc040bbccf36954726567b4b9c1a5c757e79c41b3fabf446724f23e6eb8ffc9fc55c0eb75d9de70126792da4451bceae286fdcb3c8f2b5dd47a9adeaa579d286907070d40e427128f3d441944067c8237951b3de1034bfd10973b69d305d492d33b396386bddfb2918c8e1c6bfaa4b7fc27361df0cd346e69f223e6e8e422cc55904522685b7da5f0065bedcdfed56be70667890aff01a8807e5d4f6bc7563915e213c60247e630857f8c9acb96585d99f507adce9161779e2dad61bd92c6720fc1fcf7919c5154ffb2c23db4755f675e265f183bebc8841da9fa600eeb8f788fef7ee80299bfd3a0b5617f08992e4303234ebd0763a39d54d3bb41691fa8c70e22d8e313d4bd328f1fd6af4498a202671cba249b1238d718ffa9f218335d51c2cbea2af0178ca11595062caf316ffad311a26768f82e85559d71b7cc197f496d50ce68977cdc3e6913eab50ded70e46a65f4e6039763ccb94751fa0c70c3f0a1cdcb920d73fbd6a3adc4ec69ad16dbebb5826596135c36270a79a2d66659655eb382d2e4297323a56f1dd11fac225ec832d3238e9cc7ba3ff3de0bb7cfbbb8f8ef56faf9454dd9f51eb9fd5a7724ebd37eafefd68a5b3d64e9dae3d480836dcae44783a0e1ef610baefbecb789129e83333434d453352870a58fe68b02e45f04aa7e5c1c859419630ebe969134f80853f7a3986dd5d348d928d9183828b2fe504f7e5ac164d172aee7e35c37f8b8dbfe62400b265d727cb6b09baa48a85f36af3b32e36e61b52832809c2e1f8a5c423f61fe3c4bf1f56acd5a9a96d83236d5db5773e9c038fffc694954b757748e07a8f42c352986790845e16a114677ad973b8c55b6500250f7b31a9b787c2b93cebbd0625af2f4fdb147d3d5b430543a0e73d190764f7784d065c23a6944e844fe5bbb0aefd9ff797faeac944493262aa0dd95f3d7b5e1c038e06ccd54543d38087217f71ca377886b889fa5641c94c9b49b1bbfd633b27195db4c9879aca2290dcf44dac9a192b00a78fbe612de08348aae1ce0822c4cd031ac6115b85e3ffa730ff1d83af4b2b7c18f9d9fa9290559ae6cf7e9aea5ef19c9344f0f7cfbcbb1988d5eaf756afcc5354278d0dad55e66d9e23a8b8c5e501b0cc21154ba8d85929c8fba59d92081ca7a2f7df2d4975c2d041af64b4a90fd9041835d2c99af69c42a9f619f356d2eb552f17f3d3eb5b89657c2ff7a64e94fbc7f3773d6cfabdc2669fc8d435ccad0ae162c438dc970dee5bac29af4cedc9e83a673c6b101d6f61642fc2aee179b0647a5cc66404d8ed4f607c658c221d9621f662d24ea7faeef143f13cced62fecfda8bd9c31beea7f162239914157580272deae8bf98816e611bcb273e9d0aa105af2461b46cccaf4c0e5d62e2ec9dc4a82b4e0dd5fee780353d76440db44f7a3d200497569f2f84c30ba20bf5be478600b85a88df0a588b03495d4aaf48118d0a19b3b853410e6d617deb5083cb60e380503452dd5482c9b88f9f5be861d5f7a225024e4c0477bff795aed132478d3aa69e3f3a2ac75e083b8230c7dce235dacf51a28ce79371bf03f8e4b5d2dbcd5f79a92e1bb0b6962af442851ce354a12338bedc223850b3623bf4d4fb4c2bf69a5657496cecede79edb693da14c3c23126230b1afdba8f134ef5fe8e022b724a8cb147afdfc01a96eb97df041178a9e7debb88fa82f08a6b40d8cc8ca6ec0d33b81aa1128b9988045fa373ada3bf36014cd6a910726f004dedd49617e4516db3a0b435ab401f702462d498536d6c275a239d443423145407fd1eb4efb718cdb6b14ceb1c855d099764d2c8256ce4a950d6e13d6b9b2091e6c4e7a164f4388e76b8431bdf6b97701fde10e6b1484e3d7a6bdd28c3a54eb3e0bcfd2cca971017322c620a716e43ca180fa28285fae1b483c7c07efda0dc23ef84bbe230d17d2c93c9392ad57138939e85f5412ddd548641dad2822170d791c6569c56112faffa0ffe8e713152bbe100cb04e7f63b51e24802ea6c94ef7eaf8a077fcdece83794f9de0e5443d23f59a864ca341882f82ba151f67a28b43c833197e28e4496b0c78d63ac3a39cb3259f4094daae8a1b226fd75682e9fbb0fab625ed99835cedaa70307622de5874bad7a0a5dd372fdc221ebfd15ce72b4ec448605231fb8932e7c2930701ec8e05a8d417855caf5ee4b547db0f0b4ef9e0df3c882498ff60faf0d5bd505c60aea28373bebb3bb7915ab7ec6658d50acfd0bf6fd67490fbb89573ca3bad8175cdfa35a4895f158d46137e11d44442fceee7fae867c682de66f739ca8bfd55a20cda9aa6db3688245656c2ee522e23809f58586bea6575e68ee8110c6cc13f24c99d7785b0b1458ae23a52951753971985691d1540a3d189f97eba9664941c7118e338a1340ef18e21553132aea0733a2fd8e8770dfaa452a90899a1281dc0406816aa39b6573ad70a95d320ff186b5d19afde8c5ad5f07b547b29e4d50b4cbe06665bb1d249787bd2f0b67f2f805b1ccd8b496d30aa067cc05b9edae669dd689b0b0eaa003e7f7cde3b3d1e96c37c131ff77edfd4a4cba4d1bfbc6d11e3d454856d55d3bf299bbf8270045731c5365305884ebb17300398a00b9c7f27eff769176af3ecda48c068a8969ecc2a06d24dcf687e5010b92fc81bb2eb789c4f6f5ed9905328cfdee94d82b5c4d7f423822ae80ea2d2ae7ca750583b9e019c1a0290da766d35ace65434beb71eada36009c625c09539890e3ea07c735adc49aa77cd30675921ec286371429637e35226667f53851b03346c69a19e9934ec53599b90b7792daa85723eae10bcf2649c22331dc37e75e0fc6590e9ae71f8b5a0817143583bed5d6c1ac7429955c14d1a49a41c32015224867eba3f485286aabff58ce730c227c77b16ceb5df5c71cc46dd0ed69d1e9840b5aac5d680a1069389d2a6df810ff675c05b12d53542f0ab89c6a409fc38907aab8862817a4e7375c727bf5cf02360f65d07095e88907588b1fd0d0490f30229f327a49e74531d28cb9089f89fd4bf7e6cf81317d881596f6da9362ab636dc66e596467d383282e212ff0fbc8d13f4086febb8a1986f506ed7475929beb303d3b3e12862b45364ba67bb1f471c24721073bfeb0edc574b1661fd782012afbc03e29b1e22c10ba09270987efe5d9c51abebd3c4e427f25d91115199966c68330d443462e18ab5eae70ffd460a4ba8f98550c7591d33d465e6b74b9a1a771188f86d97e1529e84cac0b60e281f70571e0e5483a568366306057233a05c43c61ae68463362c7532c6c85558cf02f9a7a70c4aced0190ccbd2ed3ffbd576366c0955f343efa5d588ed7c4e6812ad8baaa0feed8ae5ae09a9fb8ed3cb4e7208ede5cae6106a45126dac8f0bda1932c503a196df611166db2843cce8c55fc250a5e6fab3de6296780d931905c6e6b45c56b280b423896a4e4090c817eec5cb1da57ddcb002a5bb7a30b69139ce4e289e0521d8d95388208f00f74fe8ce77631f981d0d5c84796c8b0b9da33bd428c1ab236d46f480f4ffc8bfbd957de6d238fee25974eccc2177619c08209b5539fc59db03c21cf836ca013761db129fc304e267c7747ca3962ae0162b0f8c34b23ac8be36e506d50dd432ff320b34f3331ceb186bab735d18e0f016ef289c1bb7c18a88aea5edc334cc2e9cabbfbc3ac1fa5ba3ea7f20552e045559562b6b808b7d0d8536b2bc5674d3fda11bdbb6229352b4872ac51e4957164160b335ad111e229763112a6adc1acb2be948495f9d4dbc1f292622075c24e8cef22519c31df2055fb7fc8b853ae7da7e65becd5751e95d8d24ddab6697a6e158695b39ca167f06fa59d9ef6578ab8355432b90e9e1fc98bb9db5b784a57e27dfcbdde7fe4995e93a27c698e7e3c59c61c363fa3aa2ef6a5ee22c6aa26ddde96fcf1f536d32ecf13d43bc06be1be8fc17287310ad5640275a2744e79df93f1e72ba778891750a803a5d535e2cc5654834c57d4c5aad9b088d1debc1fbe6fd3176956e15b8fe56f6a3df6719c598c28697e118d3dc3a550a4d7532ea58488f66ebb2e724d124f1d6fb3b8e4d4f82e0752499029f39dd9758064625e757698c81f63b8581eb4d2328732eeef21ae4d9a2731000532b1862d8d6ab066ae1021ce201263440a101334addfc3f6cdd1fd35423e8c02fb9c0a8db01bf1a303307fb271954d99081e3e0429f89825c029d6aa41c222585b0d6beb2be49dfbb5d9e547bd844d81910660fc645072de9fd4e1b00694b1bd836599553b36aaf8524bd22f2d817ab371471e3fe23ca1ca3e0cb693aa46e2d4c4206423e810a992b12a7f1728b4880af4a021a28571e5bcc2af9d000ca2e39c9c070e842e3b4bfc70af2af0721d377edcd78f4137f035ccfe8a242046fbda8de9e3ccc5e813d171caba84cd497489f1faf6e4964864c089ac1f7963b1ce47366fee6a38a02c8f2fbb69b1f428015245a428abd8a2c042f0ec82aea2fbe39cc44b1454dba572fab2de7061c1d6f9c66e868916d5a1f81733b6e84ee3f77c95290db61f2bbd23b462d69d90a263fe78147ec362077208bf6db1df7d05542fe044d7c9419b97140513aa0fa3706be95e1fc56600882f3d19e81ed21ce0d7cddc58bf149c2dee63c54342608602179b54a747b9f5eac6db3ac60d451ae1fe0018637060369e745b4fb9229fc49d25bf44385ac19438280e775462c38aa3bffcb008b5f8f47df87c067d01c805588c60b7ea216e8f42cc4e9b2a43a79246ab12ef264bd3618cec41c49e00245349e8d0ecbbb572243fd3cf7641baeac4cba55a662bc4d854c9d06756c781f3096706fdff0ae4c3a1adaeb3559dfd28864995358d8f11a8705f2c79f143ace62d7da3eded657633013f5ae71ea4630f001bef98317ad0ca8da21db1fc0a26eae9bd945332f85bbb048f4f3ebeb7b3c293c4725acf060ce0cd1cd8a455670ec521c97a1d21f8b8170bb416d3e19a8d882d14e6909bd59534e5a5740df514fac17ccd057152a830d74636778aefdb8f4466b82495f876be807add4e2f73517a37ad5cd9c5765236d9e7cd4ca64c50bdad5c0d99f6a203f064e334d8b7c46621b67fa7d47c25f4392d8b6407d4d70481dfaee2d8a84682bab1afde7183b2c13d65f54080e8752e5521da81e0e89de25ffbb80c5ae7d92aaf71c185f0d1b8d8b5465b5303f73e05cb5327625e551c3bf8e1f53a1ac0f541e9d2fad485ff895e9e447ff7d6211bfb63a0e4beea0f5305832639b56fc526917c9e3180b8dafbff981fa59d497c2e737eb926ce44423e7d3af98bb52cf27f801a1696e45408f4ae1437968f2044f6fc38b4b968a077f05802279f4cc895f36f7a46e98f9cf01af1164e3be76f16b0fa59a40aa1f1960cffeade31c6f14b995c85c94e9bb32d2595e837697178a319cd26e953ab48795ff58b15cd671d399e6dd2ec25066172c44f14f00a5a870aed34a101e30cbc6782afb52c047dcf9ba82746976b8a792420975c08e4a96742d7ecd9ef67cec963c5e3250e24e4a58e1e6d6c341403ea6d999a8d79981cc561841e8595e70cabf51732569951864bd3f73f0e739ffd668459642f8150bb4a763fd793ade78fd9be38c716a6cf947e1ed61653ab67f4fe0fbd6de5530f826277fb7f5acd22abe0d5e86c01e1d1074f96d5026e0e1024be51afeabab735a467f533699dc19d1bf7c33a89d222a40ad3141393b26babe9dc8320b4253b634cc7d29039057c44d150dc0fc2d6373335bb5ef977355ba8fcf7d4ac6dab43b5cac60aa6ce20bffc074f1d6da8914ecf53ee2af513430a3872945084df92ce0ec37df57756a0fc32568e7e424a3414a38e539b1cab7bda48039dd8b2fa1ee30e030dd64b63f82f46b4eaf6198fbf3fcf3a93435fe91378273176344a8354a9e5a15c2ef9aa758e4a31be8e3f2f99015b973cc97c96e35a63d5ef764eba58263ce54f0140062dab341aaafa9e46487d795702232c8747931d519e16d0350ec6b5e723c940cea6ce6713601da51f69c4aaf87d6d597ac16d676ee1c77e5980b82aec90cf22481e88bf817e9a313d7231e972bfac6eda3f41e69c1cfb254bd585a08b8405fe57383d1062900988e259e421ee4f4735a216d270cd4a2dc66bb426a56dd6fe70de3724f19bcbcaa09fa01321d7ecef7643e1c0fbdf715313e55c72202a1960216c298c39954a3eb849685f566e11468b74eba90340afd027cec76fd4c352f312f30d72e53a810af57274e3c68485dde22197b8037476845fb0d0cd15fd897e27c5d02f20ca9334bf63d4107b65082f49b6ce79c2065e8c5eab773e3f3b7f97aa828166734ed6f6033a0315e76e5700f42fe619c190c6ef93e64c7ebaa295a0fff5e0c9bd63a7f63839eb52ee22fc4d6ea0238af70adb8702a8e9f2b86cee8944e26a20b9d3d8cc6073156653e0316a87353f35d8d5286e67c2ff2bc0f58fbe1ca6571552098d3f0a4d22fb9b803d5e0b3236d0a865589d3bb934ce665b81c0d07e03528022ae8855cdaef31550fe8382474fe22cc7dcf85a5ee6ba09f71f761068505cb5bf98f6dc7c55229ea16c106e6b3ad66ee9a190cbacbaa5926d907f4d4fe26e0e5b05e9a374066271bae7386aff36e85a312eb7312b10492e2a66a276830d4e03cbc7bf9a9491773d2637aa0036c4e253d53bfd5bc05091839dbda6eabf4c7f498ee4a3dfbcefab4c77789b8b29130345d02c836c3d01d7fef8d7fe18812e2a52e6286517555550a24414b8472646977aee8cf0994e6dadf66b705014d9f1b76e423744d45cfdf1991f1c9efa7907d8984cf0800669cb5174a9d7dcbd89e4ad4cd02b22366c640b14ef6077f00a81b8a63f3facd16b82fcfc1c42489716124fea8dc61b876cdfd378d8a5078f6f2a868a58aedf2481cc19a4bd4f76e239fc956f7f0783b9fb224039e8187136adbc99584722d53b49568cbc2004e9f207ab6106a52f34851ae05691816a25bf47034aba6948a08975b437808bb538921359c51934df2b9379da512b2bb5873378fa0f6159d26520bda9bbe8082c9197d08f48d0999bae77a9723db86a519c84ba9b7e52ff1a2febd15d881301b5865dc226fb48fd90ffcffcda99979e4f4b008a1dcd18ede7e1e8488e6dc6500613402c05d14a763d54f3b8b9d67584911353f860fa31fcc50367ef09f36eec5cbe5af47ff9e4531bd0eda09f35514593989e400b92d54e2b1111280c48009ec3c54a47408528f8e491b04bfc4d319fc8d2691068cd41fa77fb5d0ecb47d88621376e13a194f183f00216ed0833c73116f181f37fdcd950f56c746685b5aa7c5cc4f8dae19076901f62b89440c9f43c23d5046e4310061ee6b97627dfe9aa1eb0bfcaddfe0863c72ff30b34660d8268b474a050105ebaf0b504659a87f8bdeef14b0542a75133fac3bb777602b3ac1be2a71067cb0409e6135b5bfd0b6f6af95ff06f5f79b8c958a596c89aefbd9ffa2cb5ed2cc06bcf6568c4afa2bec7f05beb32c272412563d0d5324c74f149ca1c90a538373d44609bd117320248c7438700e01ab4ed7959ae78fc035585306ca8076a507988e0e4bf0b0e4f3cc477430fe42f8288f465ea051d9bed6697746c8ff7e35fcbf768845c08c12cc0bcc21c4c1980a147fbb84abe8d5372b6b0ba4aad7a7fa57c8877b399030fb0e32b473ae305ad6c0367a9d9488b10afb03b2ddd7b15850bfcffb0c898dc8de9ced07c191a17772e753277d76d5f7d35f8cf52780ea15f7a7dfee1c729ac2fdbe7a3734bfec69c4528eb3994e123614c8769acb9e432ad791a5289a2583a698630c3680d66e62699b3cd82ea98354eb73fad9c27e7b09e97b93a93bf9878e83ead19c96319b18fc29c321383b351ca60ce0c50cf8504207321655049cf2a6d473e836fcd0952d5480bedb01f27b08a8093b405ee3a765e9a37e4d0ca690fc0b21633d768d8061a24b66336a59b653244a6fd5f1f27172f2cec9a9ef94223df619d98f26b11c77e4a0128d6376844915750c08b528b83bd31741c93122117107ec729b81fb6ce2719bd529d2e10cd7f3211a2d41311f1c1671d5a940d1acac7460ad75f873d3dcbf95b3ca8a3e30a34dde6ab21af5a23b7d745b9ee3100277b26262609f7386e4aadb011053d249ef092cddf6c5ec40bbed55e56861459ce5885b66e3ffa37b1f8da19d91f3d71cfd20ddec954cb4b02eeade434cf879b8e96b71707239383cd247edb6a97653b09a58454ad14c802b450c111835403f708bab633400b5fc3144252a58347df99d05f85ff689dcb931b0d73ad33682dd3ad9f1e145f25f6a8b7166d068b021feb4e054288557c6e516dc5e7d783cf7dc35a82bbed886a510c79b41f54d0583209c3db33fced83e9612cd053005f948f7f2060cbb9a5a085d67ccac4b9291c34cf12843f4f0e8b41a8db20db9ad8ec6ac5dfd1aaede806f0febd2b9611e68954a3e1536921920b1e12c4cb8e8457c34538025d7a9017b77184f3666a0842e97ce49d5f0f2d07b962cd876567e80a552733db5fccdec21f6c694deb89479376f12e65ba4f6b0f662c27d546119eebc890ec25139f1e50d74bc19c95da53f9a4d05f3664a42bd29555f9c648a60b38e9a5769e354891abfaae3bc9976764302ed2aced7628571cab5c1d9da82fb62df8cd852ecf5f647c391a001112ec01c5403591883401bf98e90d248ecb857439cdc57d903c0115efa270482e375369ad45d75b7523da46725d12c8f6b2c80ceb0c4360d16f573ad51d60e9901022c1767819572c60c33960cd2f6305acb5887aa6926921cea4dd6592730b33bafcb9387b65a2f8f0fdd4ab50f4b1304eb6248a68f19d357c031b4cfe91a5fa8723028fd4311849ddb8e57de7a68c90ac98e6ec5894cdda0363b8ae41b7e958a662b687d315fefae750ea9f1797831a7c16d784d891d34d44b83e8c03be3f822114f84e1af6a32d6e60cbb66ac1da6d7cec6235fd33710968af5fafcc60da724c406fb6a6da118302ea8263c52dbe367338e6765536bea839bf51101873389e8395b94ca2830b84d930688ca0520c2359f540c9248baff7d3d903ca44b9505579a2161290e3a0cc280fec9fd27d74574b4b72f94e21e9abde4771e6f4fe25efba83414728fa9ce19a9d74402f2803242a7b786ecdbd1912645129e73dcde96ed0409c49cd472efcafedb1ef35fef01b95f6ce5bde5752454945c416f67e825f18bf1e600ae3278ab21c0ff443d5528eb01f0f78b1cce90e640773eb77ad33905d171d44ea69ba7cbe8d9643556156510734142b3f9ac2962e3471723ebdcde3b6cea878ef640133e10978edbf57a2a4bdd02770b75ea458b7ad3bb08855850d8c7bceef21a0abff6d9920ce512fb92601763784d2a60a5d97c7cbcff9f622373f2cf54c096d0d3c1968b91a3ee76f39cef65a709873f16197d5627b4e88cae843cde084fdcc905e03592553085308cdb2a1310d40974dbb5b8b73e9e3fc99889364bd35d385b5c296a3501281f3d77fcedd4fcfd9e5068dad33d0bf60403285275595706818c23820e28a1bf3960adb7a4c4938cb7ec81c1571e93927506ce39a406269846d22e58fe0b57d4e9b4d82c08e355cc8405f410c0158b3ef412de80498fe5942757f8dab6f27ae51b446cda397dca8686614b9b398ca19c0408c7f3252b58de4de9b655868cd2758fa19e899fba171d1ae588d63c0ce6034cf3dfd0a0c367923c7789932efe739bfd08a8a39e76d72e5548d89c2c1a6631ae3bf666f95a821bc8950e496c05ee8e189b2c5ecc1d3d208dd8f5edaaaf386a0768540388272e49f87dabcc9ca681ceb0c15978e965c2475e6e77cf64758a3744d920191e32921b7c38208bb6917cdf2113083c4475a5164a195e0af29e1c6b7ff830cad0ffe58721176ec9cef7d559ff642f2abaeffd5e08cd1bb05464dead8e9b6f66846a147fd47931e557d0b27061b5cf0f63a931365df829f914f024ff4f33e15f5fe1a37cc44260cdb880035de33102373fd33c823dc36ed1f5101cebdee9022d946f0c560daffe89ea48b1cd5032740b36870327ea388fab4123eaa137dac5df27581ca67c67711aa4a01fb92d166ed085af45edc2187c4240d404d70e4b05794d7017cfc246901abb575983f8a0dc7f25631471475f776afee8e2837be221b8c0f5816db76c34f2fa674908b48d4cfd9c22dcdcfd2703423a19201ed862aae75944bce64d958d793220a633272253cb2b21fc1fe53b607fca849d60440a003a36eeafcecea94364985eda32afbabf00df8c479ec60d3d2559727a6c4f2e14d09b49372242a7ec385a1ad192ecb3447c04103d8e786f5153121a241c0251e6e38112c097cbea891670c537dd0b215e86d01a6c5967fd7ce787108d9fa1491f41774fbf1c5961b18d385745e0ef82bc9e9a3eba9c58608be70b0fcea293195ded2fc539521ac800fcdde72ffa49fa82ef20e757319f9c27ec4f36e892f695b3ea4cf6afdb48245a42bd401004597fa7d51acf893b97286c6c4b0e6f74438324ea3c8b8e04be289d82037344f8a710341d5fefabb71e4a920e158158b0f803390088bfce346167dbc5e48076d2b57776dd9145b93eaf0afff5a625dd007776db6958dc307cdfd6c3b86dc23251dc3724a2383c33d4a783c57bdf5383d76a29b0475ca48f97aa57ea3d8bf8bf1165189ffd47e10265588d1401449bb764f281524c8bddb249085a5dad800d863de35f77fb99a8a481c15047c237bc15775be6f7862eede1a14c4ee44073bf00d332c65d5f3590b524f9a24dd9c656569b45dbb3f4fb6165ee19aad85fc5c792b6d65a02e827872fdf6d3ee22276d3ae87cdde21e9fabc447fcc0cf2d2746a5154dcd268c3b0877af8259a25d4c5d5b50319287ca0275473316e756d0c5ace677bce156212667a6d1e431a718f1844d9acb1ab3449d7bd4cf7a32c44defc943fbe843cd86cf6ce928d50882173b0cd966b6d6b386775abe7f0f06735e283bfe47e1fe5d4b1c23d7375e9b8ba4859773a296f8c56e8c96ae4ecb31860bdd4fbbaf3d48f3eb990e4bb3164dddea0e170155a8e785b6c62c4f9de291453a50a1af6705c0791e48b6ef6659e8b68aa6870bdabf8c6e358b3d23b9ca2d3e177328c278619e1ff3a24e4042bb05a065a6c4efc48f20294859c7b6e52f83a5c3cd5e0cc28b058df067e16f50f6ca125b02e994ab7cac1faec24c79c07ba142595832be8cec800e609c89e5ff1d247dc83d9dedf081bc46319c969e3672932da865ad583cd9a187d1bc72a9baf90e928b0814d41326d8a402993b0937960f2315dee4a6b33ac575d903315c25250f28f083c2f7265717ff698fd2953dff03af0b569b4d8847ad9fd4ca67215cc98c90be00f8a10606af92bd9907405f5e074d0617460984b1c541e134d45fe8487dfc792e0a2752b3f76e79f43206da124ff3d99879c1cb0f205438288ddbe33d0a4ac26d2305017aa51048e5c8e83ac3bc7f17d0965655a978bb889cc516fab479d1c1aa13d32d4fff23505aae513dc5a2fbc6fcfe2a2ef7117b72f44986d40bd573888c225bdbc378ed334744792db086d22da1ee79769defca444e9929840528400fb78884de2ea1997eccb3a1c3e7d06999eb0372a189049910249ddb2fc4d966e6f36ab005b661773390428da1a597fbce86466e2dafc32ca9b9b57223708782d1098b6dbbb373ddde939ba2494a9ac093b9d5aa0a4fe7e875d692a414b366fdd870f7528941e79fdaed6052bf1929e7efbd24631d43c49b132dd42e6c6059ba89b831082b92165aeec2f5db6560380106fcc783066b7b299b2f348b4dc2ddee219bacb58afbe775dfaf14e74904999ed3ada321e00af951b466949ad4821e6487e97007f97a7c482f5fb93b092dc7a2c95740bf346e0e17f074c362ca5beff83142691bc98e97accc203e4497b99933bfd38267288e146c052852aa05efb383ec3583991f0053349937ff211dadfaf387dc996fc4e4f89bfe998e5cd416a0044eaab608c81023075ceb9bd595b92ca3b669348773a75103d25c615f6f9c76455d345771e07b42e26786c4b17fbeb49f7eaa51649a3352ff67112d9f9a9a429e7dd574f70cff0cc605970284fc137385be102b1022cb4d6c31c46be5eebecb6325c26ff9824ddeae891e25373ec0e7053e90ba0829096a2df187ab4c42ab025149b2902d4e9a5b1d8dbf839d3f987973a0edff328ee6d827289392d4d201ae62cc1d7a493acac2da6e8aaf4baedb4d20534d4bdbeb0698d16da459a9566fa046f0080d440fe95a529bcb03bdba6a8b72493ab9ed08ffed87c19956d6a1bcd966652d9db918e55bd61854298cb7fde8a517f7fae9e5658c3f078baed846906e147dc618fc7a6565567e66a948255bb3ace30e824531a5663b8b3461c78416826b9ec12d70ba69284a48fd09b2983d2f858b57732d298d568cca0e114679c1816c6fa0f7def1ce1ce64e45863d9432e007042eac07b959a337eaafe44f2f067cdde60c2fef0f63a50300bb26443664dd207087b8e1bcabd1bdafac154f2c1ec1cd2ffe736550014e2ed5b30f1863925587e1f5ae1c37dfea9cafaea0b2e7839aa06c505adfa974efa0f7b52b8595b408f65e5b9517987eebe5ed21f1581f068b14f132f78dcbe6a3667905ffa83361a0f089b1a77236b57ed9593ebe955703b1c09bcb19c06296ab3529dd94c23adb930b0117227906c92453d0987f6b39a93238b92cba5dda9025a83438214293327e862199259476c63b44b13809a8cc14058a9a5cb071c91c0ada89312995e215647bccd541a080fb2eeae7aa4648d7d610aaf4b45f3e2146fcf3d7d362d141d65ae1a9f5ffd1f67f2b7451c92138dd69c65fba248b65e337c5bedf767e14e2286d23c4c5da27af26d36f91f9ca31c123e7ae16edb3e929f3037edf95ef9bf7a81e6f63314be70cf106ff1facbfde7864025752442e42e5b3534f3649e598586691dbbf453e9d9e497cf7f16f1bb82d70c16f46f844f964615a15a65e7632d8cc7e094d58d600ddf5f291865d86f7b658655e11b8adde6664bcf1f0bff31be3f1c703e5f482771b5c1dab0700fd1730cd8075fe165825110882cabbdbc3a0ac12083a5d92a5e6be8939b973e5b6a064c651712d27d7ac84b1625bc45aa103afba811d4311537a14f47940dacc8213812057366cf87d34ca4f19b09fb31f4db8fc3a9bfaa28df0005186415d175fb6dd71bab55fece5edcf9e5c92b00ad017fbcc90661cdcc684b0cf69df7ee2b00a3e786130cf5ea044cf696e6be1cdeaab9eb6b8ad56d54aaac8c5483e194199fbde9e776211418728c9ba1ff1670d5571ebe81625b6e71c2ac79c5aa6f2202c0f08141a233550a98991a1ed6e18a4359b42d3da590343eb9a9670130a2b279b68723a7ab2e2186eaa8730df9af6c782f8d48bd4ae08c5f0eff1d05b70251ecdbb7160902c38bbb3c37c605a8031be334cc213aa547e283e40e9d5d538910b1ec1448b7e91ddca7c7746fecddee722378617221d1aaead1243ccd6733f1843eb3a2b8273b74d4ff1ecec67fcc18110ca2f56cfe2b42277ea38918ac43ab12ff0490a427aee6de23c52f9a21a0c7e89cea4693d144e596b87906e76c90306058ae13522aeadfeb446652ef8577fadd30478ad65d6beeffb4ce7cc3af00478eb247d7cd49c4e2bff3e5e610ff673cfa610c4c7a7e070f618a4d20905210825b02b50c58388334eec3f829ffb60cc9e5cbbb03cc3c3d39af65da60c043ce1d1065ba1e895a37285dac93fd940b85df539ca5074e817370042981fa8f4a82b8494c57be080f1244bc392881b7572f14b6037406410327e467576128bfdf9c02b13d346b7bbe835b20fe4bb2d3592727f0fe692963d7202125124f331e2dd96e6236d412cab60b458404d9e2eb1d5bf87df70bc129433132c4be9f72338dabd4be3941090f8ce36807e111f0300671ead1709e26d4d402e19436bc5cfbbfb3c33d398007437c7796d395fd221a69fc4458853cc91abb86e14bedd564b8e9b078450f59075b68df3bc563f01b1ae0e538c89eddd7819c845f232ad5df4840b512317dd1ce375f70acce3949f0acf2343a7d0b3520373f25a5f81ef6fb90d149a569089fc7bd43c96eb151b42b0b1063a09f61469b08918b646d58203dd0e542802c43a126c94836c3202618916e881d40679ead3381c84f82fd5ae8b082be283ac47fad3e1ff5695de98b28fb439e11eee9e091fda8c0d442362b314f5a2cf5596cbb5af2d077a2f9153182ffd9d1ad1d6220c7a8ace414ea197c7986829984a889396443884069665eeb0ab0983a946afafab0fa4e43912db7df7e6006f022a888f3719decca251efb413a2413a5da8c84dfa8f914b17d246086c71518c5c6d405638c6c2a4c8b5cb1d4c21002ff95b0a80c2e56770721b8a4042e9a8b8c7d478d92271066e268bb53eb5af475acc047ee87d6c7ca63ed1596fb73ab694438170efcf7138054330723a6ab8d507e495d28fb9b2a65cc6cd3f9150c058d3dca856d3583ea203a11100996882adb5a23a6c321bedba3bc8753c0559e8b2ce10d52cdab49b916f965d71e2c2c5f8c6ab403fcb48ea2371582445cfb7d68d74690df009da55d28a6980c2bf09c131c05546edeae923394fe0b74feceb62e1a4c44439696f04c85e897d9ebf107bea7cd04110ebfba9071ab48bc0227634a0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
