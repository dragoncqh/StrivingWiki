<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b865bdebda2731df92c08eed0fc733d90805b71afb3552b00fff2b459d79a1f4342bc550f8109e35fd98226c5cedd63aeed68d0c64969bd6a219fd377ddeebe98250c6ad868d76966f8eaf05e5daf2e4be912132a22b5a6a0fcee632d44122d512878a34966465327aa8b57f03630b7991baab67309128340de761690196100ee0a7735905df008e0abb246f07c19e11425d9800b6140bcec2054bb29786070ca1b74acacf1050994f35b868686c1347d260806bd69336aa2a7283293893a84dac478a0b70f01221f1b3c64cbdca0b84e6460ea74984f415ee773eebd2735b7be4b8cc7d7f6c35ee008509664c5aa400bebaf458d7df63726d5c3bc14138f55d1cd44d6161b6c1937153d54b6458328f9e9a541e54210f172cc6cd54f9ab86aeeca912293bc5c9e5ae6b468fae22a22455ac02499f9b1544b21500d09af63f0893556bdb8718942d0adb50276e1df78a6510063b58ae64529cc1d9414051af988324f174567fd305b760b7bf9309316aa27bc6b7bc84a46f3a4ab9c064b8901b46596e0026c677cc1b81a1184260f97d38e622dd517b856fe1cd72f302adf772821c3f233c4eb53cc5cbd6176e3d2775e20f5e0c295b3b3c708887d4a2b34bf22d7a410eaa37fff0af99c10a18be454480ad7a5451a79ea6a56e841554c438aa359e176c122444f97d27a7578887212ea5f52e7235bd49e69adbc3768f78e424bdca236ee0a414326a5670a36fab33fcc9c67e84e537a39bfccd207ca965c2d92dfe7e374e3ddeb1fcbf9b605bcb056ffae3d62bd423f5bf654d46dfd09e7c82c047ec61f8eedf2d7125d5e9d282e78df30f3a210a0e1e6f58cebbd1e1d02a97e325d2eb1ba0d13275a723d2bd9564c82dbdda121a4acffacd9ffb22304f791af8d060c4448edfc88f3fabcbb324d69e6dff714b93006ebfe457787da9d32ff95e71c10508e47ddae5c3ecb5b34b7b6bfe06c96ddbbe9999e1941bd1244e9d5f98378c46f5aba862ace183bda55d5282236da9a180f3eedc401a4245ac4a7a60dea1d5da88938fee370db49be8ba7f5244cc4f206b116df45c6de4f80acb55ebf37567cf3278e4e3f9bf67a7f0e73b293de4eb259dfdcbf03b803186fced76b05ac0a9a2841be1a809e155bcf99a219afab99d00595c7e4bba8663de9ce47bd146ddc92f764d482d57bb239d7411c857a6855064a23d5601237b37d6ca322ab82b26662b6f35c6d58aa79aea1b3a57d40d520cf84c5f562262ae5fd316f35a93041f97934745221be6d6c2764929f1f893dcc4fa3f9443e31172f8fe647648c2d838849398d85f89c9edde766588c09bebb922c115c9748eb0ccf3011417d92de892aedd302abae15469901515e9a9269b772354b3b636c88165b05a590629d22fbbfd22190abeddef673088d2967d651e1ec13a14f39d623faec1e07bb311f73cfe1370b3636c655aeb2df878b59f9e7e9f8961a2af551c2be25b57fff297fb94a6f022282a4bdb3e8b6afceea6d7e05e62d492c84111c837cf1a3cd4607ad8cb5cca129f27527cfe378a87187c9a34e5f1e91692ca05a2a37181b1bd0149d425667ef7d5eb9b6a0667a3c8e034e9b913804b176270f582aab46427eb76d2d5bcb71f112f3c93b5d9b251114377901cf0fcc85cf8b62f49760bf367d3f15a59ac455e19103022a49d5e560c595881661d76e7f6342d32fe3a2eb21ebdc14084e1c978b666584adf44f536fcc773db9a9d3e6581437a27a0b9c0dbaaaeba85f6f45264bed014712ab21ac8915f4c74fd0f1db82b1a47fcf4933ac07218a8b263ed0992f0c1ed0d51f4e70766e6f657668328a230d0671b51c9ee620d6ea4de52429d7579f863d0271560f2f39f88e585cfc1ddd1ab20ad24dafc4438176114a2a8c5ab85eb0ec296d85add3d039940ea1193187b7986ccd44cda94e705de6d957283e3bddb02c3deb1d1da3001787a34eac48fd5503312e55bbdec5c0bceaa32d885aec940f311a572305523bb96d393c7ca05d813ae9f993be07613f49c1a5df9f0b8870b0d9e287c35476d570ea7059931752102f4035fd2509794c4526d14d3f5008649b5a7f6e8520c8bd81993b411f52f21e66eddbe176c202662d57508da880839d02bab9ba018077b0ceb6ecb5a0b27b42350edb6eb797343c679b32f2fe4b04edccbb4e23ffb1c4e55605777e6af6c1149611d24011776aadb0ef53a553652c29d29dd3004bca7e708a555ad96d7059807c2e1ce53a2d744d6147541e7ed7c03fbf7b291c057ae53bd3623dec6ae4955fbdc2d122fd5f0cdd6184faa457c5143c3ba2304c0e42232b2f26bfe8007973090392405d82d125616ca6c8034d2d02b6ac44134e67455dfd8b6b06bf09c24be8a31ef3ad6d1e3d9bf3d26835e36423ddba000dbce234fa7cb88d516596baa0abca2e7363d0dea572adf84c6d244c2a68f2c3e0d5903630bb4c02adf9d891088585d161c46167bfb6122909c5582c3e62183b1c518a126978162439193c5d111586be36675051511c331bc6fcc136688e3f400d3d4ad57db2a5bd8edad18019a6a083e5795adb270230789266567084b51e44a9b4b13c65893792c5266f470c00731929c21953583c146c20dbc621fcd46cc4a4bcc5449015574cc81162e2c2cf2d672c1d72158e194d508d6457485d812cd756599881a0e6224734a2e2ab5608ed6969e795d3847deca7c829c377c86bdbf492f6bb2057e6cb37381bc3186dc6177511ae1e9f80d36e51292f281de6da1b5ba16b5dd3b6ae601a4e24110afc3add1badeae583e7b4526e2885ab3908eaafc863a3fb539226c302423ac82a5eaa816271302e8c9712c5696abd145634b1f75f962a99098a23a67fd4664748dab9f245ad0e7c43cd34b68befe1c9d5af70e5ceb3ec3ee942fb51593254423e1911af67f8a7ac13341ee7150a32e899b0a6b4425d72ae37f211f264b831bc1b012cdb820a9d36945c20d8c572737b53beab46166656079b3543b72c7eef05a90bba711c7c4ece695f55f7533101deea64812fcc08ecbf0cc39d48eec45db9b4f402206cdad50edf383b17899a354d7974f94f6d9653eae80cbeea7b511d41d883e4243dd9063d9be25c4b2fc3120dab811c929e9a28a5ba6c328e537b86f77d7ccb53bb2eeaf8c0f9b6f16c083fb8218e9c950eb8b2dee21338aeb4a620a779dce53daf914be4382e5e694d21bc3b2effd2e35c4e20fc3fe79237a1d8f4c54a10a9d84aa82abb1ed2ffe1b9d9486a607f71d6e22f845a92f579be93d795cb2cf6390d481536312f82ab779b731bdba855611e766a728ace897c70afc342ed4a61e91837fa5a7a86ce76dfad4da50b14545af2a5c7c01732626bdf913baec5d16a7be60ebe297715ed0cfcd80577549c32010da2656d05abcb43010e37397dd2033e0f89198e7696f5b0cdf58ab837ccd77b31f33db779e45a6517d19d99a9cfeff071bc9a6ffada3aa4d49fb0f9b3691e45819f84339c26ecbcb8cd4f20303234b80b7a8f06de99e59cb94e4f13be0b821d7fedaa27e6a7626f8a7200fc7cc410b78df71f3c008febf00f994882121546c371367529be0b02505485abee78ee1c4c513c8fc1e0b8d5c3ea08b9a57b7fc7c7a8b37b6dab5ad2e0a396dd7b3c9d2b3faad092b1c22e9325f3dc87480ec9300310334fdd52ae009ddf803331a55f8e59c7738017f3605a13dc9274aeb405c55c902b6b4e87e159454a14584c84097222cefe507226a35b80c6d29c9473fa2e484cdfc4f220f6c63a439aeb4b7c5c0d8b80c07cd64efa3bae68ea07847580353e1cff354444e1739ef0bd905daf34ba9fe5136bbc8390f068a2df60b558df5b8725d0ad8a31a9ee5775899f1a16e20fedd9a1eab72c23be053d0af1d440fa3b68357557f157b58684427d218fa1fead945c7f6ff81e2ed2bfa2c0d4400426244532a741b075b3aebc76221773c03a6e7ebb28ae326fca1ffa34dd172260879202d634840c51ed86f5ef0df39ea955dd41624ed3fd3dfd68d2a5874b6c1a6c8c1e802f1322e3ec83d2508b81204416e6a0d884625f9c22113e847e58a2b8ce8497ce19513b4f7b243990159aefeff2524b137f4df84549d7467827650d9202b4890921347ff6b85002241361ed7d1aa3dcd1be16391044d772e11ddd3eebed7a4c6c813a808c82c9de4c8ca10f88117d0ac77c6cd1c95205a7ee796f33f7f193f75901525274236d6ecc9e697903ca08b2ce970baa2ec2c84a0ad991291ab57498edf426e31c02122f3eb6554f4e423cd7fde3000b7011cc7f7af3962b9f09e1a897cf8b4f3945fdfb55b1ebfda7a2a84c3e4fdfefd642f2dff19ee990b61d6b90c189eb54a826fdf8ace8439fab1748f7af24390a4e2769e3cccbd6b823aa88981120d859e8da6161407e242c795d20de580c8a8da7244a28896573f1fdffe036a32872b67c19c3132d1698513476d7822bd8eaa4ff1c2450777586730ce3c3c7d268222894876ffc718c01b3d9faddddaec223edbcb7e6d9e465ceaa51b769a8f7b49d69206fce8028d9a9db10dd848678daa5f7d7e31c052a6acadfb9b30b36daa37305533d7c903749d7bb6516ad59cce4468984c9258905197a833a2c4ef6f7eadf4c03c68930412052117b1272ac9ee1b4fc1229729f9328b263d34b3404cc8b28f3b78c9f52f96b18a20453ae305e7cab19c20781660fba6a072a49afeb5aa6739349c8920e7d19dfd14e39532c779b38db03e5aafe909768a06dbc7173598275143098cc4dfd0992d5baec340361b2b6f47037fb544f79735155eb1949c80f1b43aff9c3b65c451f43ce77125123b637d8c6ef51ab358d8bf7a2099f2e229d78186c8036da9c3a5e40a441b2df8ed03d290f96fb516ee9c61f40d26b3d568b73733d5b6db2a34ed82720dac272f4d6f1838dc2b4cdca8aa2e3988d74e6e095037c25ffdaa0c16a1cf35695ce566cb0022c6e889f9981d92bd366eb29422207aa02933c08021191c7741b6d409b957104b260b4c9fe04ab689cd9841a4c5bd99dbd0e78d29b472858bf280e96a2a127f0aa2c71bb975d3cf68d7db304161085986e7cf5f1aa089e5423004728f8944cc024863aeacca9ccc0c61933c5ea771f7d011779f905587b2d8b843e13044d25d8aa794f75747c02abdb54c9c70487b4bd97dc60867a74a84264d84f5521d4e9e4e231b876b9a6faff92d80958f11817a8176f035afe5e8787de83e6c6462a5584d815ba04792f284531a4a3b86f9655586285c28602a4ae04b9e218526179671e31a2650eddefd6f32d1ae1ae0cbd979e4ab57278d3d9ab6edca6d696e68e69684aa85cb50882c1b11ece6f06d424c4661c119fbc3bafde123f4a201f752b77890400d257ba97076d46a04931e030d607b6ee66b0fef2a0a422505d9843bc116471a49cde28d2cdbd656e6f870d29b68708dd3a64ac8f0ddd12ba328d4150041e862fc558f4fb8f8fb225a7eba3bc94a0c3e765b7943de17478fc550d44bcc94631bc8dad39641ce5d0c054acfa32a9b99c890f0fbdb76abb59fd99f77b1f9a5b8c4c13b7d9fc8b56fc63199c6475b4f86169e8cfe841271ea45bb72137eb62f03e94e468baf2fa7aab888f519b8cd8d9c1c28a2e4ebbbbed560d8b0059f5008d2b1e542738fe2d3d0b4fadf5aa017f1334486303a4063806c4c22ebbde9082088891588588dc34451f73f49ce44b28bdd86bc4c65b55ac4c393272a0957da021a78abb1cfd065b8c4b810f58d247ae0d7c4dfdffc825d44bf7d7f5bec02f234283d11fb8d074ea3caaba3bc5486925a9c9a9c3cf465aec3446a6aa274e8263b5d9b18a5883f77b0343552a31db66ff1c3226a75bbdd63149d89e6f0c44c3cf6e44cd3f73ff8a2102855ea7693e170975ba1af3a72f0249c2f24db1f58023db4b10307f0b334f8ec68000cbc17b03fdf2e511b0e90f950d0ed906aeb525fbe20ede4cb086d1be929a85c676740dd6d492cce4a0047153d516d061dd63e1729a24f3d651bd1416d533c0d638dda631abe039d347547907638832e4ba8a8a2a74c4f530e63e86f7d702880f85e3f99cbf53e53eb5e2dc61c61b61ed4a0a21623c76dc6e5a940be1ce26144edab6a49a4912c2dc9ad926e2c797f1842a9c3d59d1478d1f34cc5e9074d8ff5a8def9c6e6db4c44aa59db733729f3b94b54849e4d1ea196a9c4b5d07d1437ebef7d7ae13933715953892b97a1612c32fa0a5ee2c488a9cb7c973214efff67cec1389289f0780380275e0e8e6d2ac8f2eb4898919774d525c9723720cc8e99e0a216fb3d97fc5f4e30c1d7e41b855b739f40b29b18451f0b0daa7aa7c019c54e7d837e593c4c24bf08aac4e7d802dbfba3350a95da123989589e322f560898879b6a930ebbe33c5fb1a236afb4d32740061691d484ad75364a5ce9c4391407748d9e3f5beb0cd47fdc1ab4d9aa5566b6012cf5288b040ffd828dcf55cda9916f2ed36e5b20844a55ae60760570c7212a9bc9ca779fb4fe7ee2361d25a1bddfe82c5358b2444dc540d9bf4603c151b5134e563c84efbfd671eb3309e6c67c3902f85a17d2a3cd4f303ba3d69837a4e8fad7183270b099ec634ff49094dff3ab3858cdd703fc33b1c863947d402f252c07f6ffef62c18589a25e910994f1acfb3e8beec737b45925cc61fee50f4c2a65da90725b0aa339a880bc91027af0f8d2734607662a2e9af6808e85df87742082acd674f074804b2b378f3e42cff048eead53f505cd1c9b51817235a4cb981361e4fe458b8951b6c2ff62ab6fa44be0fb2433779683af60ce8aedd26b1057a477c607b58bfc704e943266a0a0d0e5c15c12e7da0f40e3f03dbdf047c4226c3a05f20de8e14a4dc773fe4d66239f1ceb3ea4745f7344608163c2a31e66e913076d23c8404eb01415c82a41f0245a96cd533e93357df4cd27cbfad3e06d379358936a493585c4cccf149d66afac37e52dab027c6c630c88ec8f276f36949d737eb2be8c55b4d14b146ad23267e2a322ff4c53f5847eed251a73e47f05d10f5ab8fea3a07e2709640b056f7396e391138f2a0ad523cf73042fd3b4bcc304101dd0374177099d208f1eab2a66ccf8e9c97d36b024103ed5fcb7faed404e51d529d1606f957fd71338e2e331d6ef4bdf3d4ce82d01e942d0dc9176aa8b013f80465a22e3fce0c6e19747d317fef72645592e747dd924b2280a941208c704064b208257b233d592caf7edd0d374361e4d72874dda2ea9bd45286b2deb7b7fd8145f5020415e73ae27e8a6caef1e3f4c4c4f1bbdc2ba34e2b22a05b07b6814070552f0eda66e1471e629e8a0760c1326973b0d9b4eb342f14ba13474fb6932202aa8556ea77c01a61678f0a288586bb9e48fd84e703f73d1b83cebd4f6d2ad9a026ac9e2877f8274fe4d1857bd725b303a4d86cb912726a9054ed7199442b4b1688925812459db868936091ab592b8f1f54bc6143c374522855e5caa19bec3ff107067beb6c4b6e54f8d6a0b4bc451161e1065fc73a00281fed2c6884ec4cc0a4bf48e503b04ae2c33d8b915e339791b2c34fd51f8dc61e150e7e275561ea3a7ab367472ca32390769cd74a23e30068bdfad38d8130cd23c28f76c91ffca2ffd7838f058b73fbf2cb5af642e8315eb05381e15803bb26c1b3142693e1b51737b8674ddfa55306e85cdf22edb9e4039fb504ae06a065c53b632cd091fcc9b6d1419283ecce87b8ad349b2278136c11989c22bdb724b2a7f706c290090e15e7c870561ba677d31cb5d23c3977eab738ecec33121f2853fdb5b3279164b8bf35e1328711aec1ba9a4052756a821f95aae0f41eca03150f93da6b1aa7a15fdb27ddb3d6aedcb7ff9b115f8a09a0e662e2a2902af42621ea658ac8f7077050e5310dd6cec0d0a908f742d82cac75d395723964876efefd219400b61b677413e7fc6aea9b4626c8c31cdad686e8ab8eb83f85ee1b9e776cb1eca7395c5d275d6d84613cee6951009ca9488c1440d51811385263151ad30159aad9ca7230dc5317f79b105fbec1540b8f8d5738a82c38d114554f365a3b2a1367d5c412d464817f5a4acf3a035e27df1c6dee398d3a6a0b213ce08f925ab77c4bdfdea9d14be4a00955ae461652e8ed8c7cc1fbb51da72ccc0bd11650b1a0dbec1f94203b2abd28de13b28ed2f86e785b4465a03507a1ddc6fd402cff0bfe9683bedba05a0cf04340b6898a47be87b4642c1da63daca488aeb8c65494e39008a6adc14ac9e057abeba757afaa80c26b335cfe0180fac3eba44507ef6fce0393f1883f66c13d0981eededd72b0039f4481c88c1116bd8aaf58d175eafa6ecc02a70df49cd88a993b5675099ab916791d5f874401d092d8c3ba91810ca0220f4633f547accadd977f6f4b51f2cb79175e98a4c11a3fb775a4f8729a79ba88a151e008656d19f2f452a78b130f03cbc3a6bf3f1fa30685df978b2259f895c44e2a34328f035679cabce3854330fe29e0c83abb4fea741ae535774ec69025d1b8e7e5f996bbf8493997c7edd30a411bba8f2cac934d7ca5dc722cc773defc042d62cd79c762d2862b7c7defb4e50ae557308757c28ec4ff915af7d5dd82c4bc5ed2666b591d0e69e79587999bbb60c75074fd4ec5f0bc537a29bfd2af3859a860901f89e2244347b954a7de1e17b25425f64d290169be00ee5ea0e413cbf41efc5488b82ac9e126789fb70e84cf18a74a3e36422bd02e8fee7ac6f2c8c114366236a8fbfdf2f97b8e6c1eed5afd8c2dd926312becfb37bc2899dcdf0ce0b56ecb75343f30dc139a881d8479ba2bc8b0ef470d0f71c60d364b297b4d2f104c541e1215777917f15ad948f2789ca35b1a918157dc12c2b1f41a330bf3886a7893cdf4eb186553cb5ef0c64f885ef20d2a59d8ac15c2d752c37da5b1af89f398e2cf66a4818c9d8015b9fb26f46e6616f95c52fb73e937bd5aedfa01838d9f670287a62d17bb02bb1f52ea7c15b98abd99b53221a531bf42c0dea06ecf74d79fd79641f57cb0f6035c5b2be6f07dd4ef166684175e4f2a4a58a61bdb57f358111e3aa4c1b9dcd4d7b90873c0c8357588790248dde4aa46ef1487bd7827d8c100edbec1a040e10e8cd872dc1c5681f8858120fdc7613dc312088de17b9048e7ef3dfdbe466ff48e6be39ff2798a865cf312e0de06be02e22fab102829935d41c924f7691f9a2cb5898484ff5a25564bfd8990400dfc30982431b3dc7bf9a9024d4b83cb8f8c0a2355bdee92092f7862b114108d434d559f1f2765eaf540e7b44ab89557d4f1dc290a0f606d335fa3ce9f2608be625d14963126c51dfd25b014039629173a5e8586b60c132f545356603bbc35ec751c0991b0fb03eb1c660454b9d6cb763b53fc16bbf572ed8f94acd8f6d3d38e12863cc124a64aa41199eb6ea1fb48aca3662b57cb88b3371291cafd5444b71c8ca2ffd88d6e6149b026d5fa4f40b03d38c47ff9dcd014e86c6c2fb9b2ed970f5b3a86ba032e97718c6da56403d4b141b88163f4d0da8a73b026323178d04083d19c562042372122b18d3d1151da9a9f9895f3ee02c5c51c6f55307ce32ceb2101e42b4146a3a805abebe0bab5e1d7410bb9d79dfd832f45df7d9d7b84ce1b9e19490b97da9ff84fcb375b63e1c398b123bd694a544281f5fecdea0b32eee8b702626988d26aeb37a2133b89ce4d9ef879bdab829e47f5f14c2d48e61e49b58a466ae71fdead3bacb9c42dd351b7b67e056903916a9c8d96d52442711fcc3d46eb44d31dbf6a974c55e09ec5d99367a59256d336e3ff32928c72e83562117b9de007a0535bd3511ab5492c8f0496e4979d5c422579d87c1f842710453b8b84173d6270efca2038e24829a33475aa1d60fb895907661f2cc614e3798f4e9cc78dfe8e4c2a2b53007f0237633788f3c812fe70e51ca02e011e1b63e674f21b2cf2e03bf465445e984de4488bd6f97c0138ec57028454d4a6efdf4d8d279186f7825aec061509a07ddddb892b482e72423cf06edafdbf49a9dc33abe7e6832ffc885b4f8eb2f245afdffbafa393e98fc3bfe8e09004f7a8785d09862cb71cc6483301cd2899d8abd4726e03df4988ff5282f973cab98be37f319ba4ae12a8ad0a11700095d8c81b0c109140e3badd621ad0720bdc53f360642fdbc1aaff1c79822ae29aa8d91b52991108f51ea674ee9e32f857ce01f3f66952c445ae9a2595706e9ca7c69d6cff8fbab550a0aa2311a6b5700d93b66d22bc2a8afae72b948c119aabf9a4627adf0effe73a3d009a14d13e5621cea64c1e9b36131c14df3ab857430243d2443ab6f96782708fc82aca8f518a1ee2015ef5cd95f5750860327ed912c763ce7e6e650e25ee15df2458b9744b1374339be14eddb4d6c495590dbf5d93d9a4d99faf52ef02866203d87455236a4b10670d8587a8776020c7dad0ac55a6c171dbdd15ebd4b62ef5b1c41b5c4279eff29bf547940b0521ef9126d8803fde65a6927b6a3386848e7a0785725762dd0885d743ddbc4b5b318d582bf80802151f8a3e353542fd87437aa70c25eef5d21386e302f5e93d077436099a5675cee0eeaa8e2b47f0468b0f95773319fa856724f8776c4648267210c955cd71c30dff86ec7cf278901cc9db473b9b6e85badf31c31c93a4a6be953fd9762f467c9b9796b6959d0dd379e88657b8efb919e3ea0cdde324f8022850eaf12653d93ff8f2cca3259d7f416ea8dd32eb6c9ceae6670d209bd31ed1a8d7b6ae89834d62500ef10c2b51d78faf0a0dc7b73bf5b12d1c66040aa55a094dd20270f8014b0535c169a5aa47cdcdcdb6f4b227846dc7492129599502a6291cceebfae9131644fcba68f80b0bfee2b58c5f6dbb7d076ff981a2cdb8903b644f09688537e11bdbd9525bb0b0dc4ec28bd2519668da60d3f59900e23e13326f7280c238ad7b4fa4dade9fdb2b8ad50e2358ea31bee98821d2d901c6f38a1b062f3463895149172d19305100950ae4fb586ae2dd656455160b9a52075f4cc83437ece3aa16b4953d3218bfa616e244c71602523e70ae6afeb34b93a13765859dc758d67172a77a4414f4cc035ae1dff8be78e5bda6ba74628614a068fcb733dd377b093430efa61e2e7e892031a61b7071edd7f31a35d07ef7f9bff679adfe9ad55c9bba5251fbbe1cc7ec2ba1cfbe71fe3a973713ffc43eb5b7aab2f8bbc7b37cbe33ab233c95fd5df08b79a88c1c5847986eeade121a4a29751d85a9a55b0ddae8bd88629cd0419b32480e3d54cdcdb04423c1bb4d63fba3759432927145f0bb35ce77bba4eaf0bbf4eeb9a4256ab0ac508784e1e6d82652e747913d416566a2e10c3d8954aad7b168d19f6cc23e4fe85c3354b3b85cf880119e980191484408dfaac548a599bac13fc779b43af4c5ee8103b1aa49d152fd493b52ade16b3de49770e43624bbf10fd3b0a6bcd4104dcf9932bb4cb835ee317f909c54b2dfbb3bed93ecbcb3642fd7ddd38221f3ed2c16d3b6cc3c0f09c162fd0e7fdfb2e02dbbac976c41a9d7ab6a91a5801d60daf72cc49ac2151914216d7979e669b9935e995a7e130b3397ce474082db7403adbdc67107fc06c9debd336d70089de5315d5b9889e6de2dcf729719302d02c6ba050d549248b5fffb24e04100e47576061c23622d81b7fba5a213db056f2b0dc80beadf29d1ccab2e68cb06cbed611c384de9fdb8d0e5c2bd741798c294959a8dd32c74f44c5821444e8fced5d6e5910e4c2944997e122875cb0dab167978b769e204109ccc4c46ffd0b459c2eacf0d888709f16f63842caeea6c8426b927ce5c9234daef8bed9612f8ce4bbb201188c198e4842f8028052cfba41068127240670d278a6cd54818fe1dda5438ba3a9d018e9aeafba168df0f900cb2f06f8783a5fc814439614395ef56018dd62d711c64fad16a082e39c494d421e73318e6d15ee63c4091a5e9ffe133a2ddf81a304d88bc5de5e61465398495b020e9c4ba4ae46af1ec4a62a28014df37c43fbc17ea9655156928aad23e4b62d466b073e0d5d04271a312bbc1f120557da5b3cda077f1a3c7665c66b2781b754f9a08d47b8fa650c39cc68abcb4bcbbc68efc70c4c5b53c7eb292650aaad4a95826b09dc90e9e2c72942f1e728e37da993218aeb98ac71e9cb113ef72a176a7557edc935c4f28c6d69f2d4d5c71290269d07dba97b185c860a3345084f7eeb0d1f64bf4f534b226a77d048fe57de34533645f9d86a58a727fde57e1b1ca077fc8f1614b5debb6c24b8de3d1232c0e7ba861fbfd92265616c6b01823be32864117058dedb8e9d6c7e0ebe629545fa638cf27b0a045d2da4a431c5fc14aa01e1ea3f0184a6d23be5e003a4f8134a9770202fd4f113269e6f87e5c695ae2e9f67009b033665c27eb47b59733bd2b433dbf1b415a414bde497825434c486499b9028f177a5abd14cd904e04d257b3ac564a1ca447029f5cbc37642da3095279a40e08b5153c1f87e18a053e4d2c45b8c8dbba56a853dd6955206d4f7375bb3e76edbea057ae2f2bbf3d70eef3e6e1ec5479811e4ab7018c1f1776047ebc9bfce7919bf29a81ff62d97d1997f1cdd087679398c3c60fb118c45bf6373b5e5d82f0c1e15432a0a2403138b59593ec1bd6d1bcb1652985944ccf73ed250041cf307eb241d116dfd3c2c2e6dc563bb12e952b51a8e00320a8b8107d3fb884e5097b19815844c3aedd28b673f9bb9151e3d631f7d6a68c38a9902ff7bff202182b63680d0564d7680d5a41b33bb671a901708412e4b7aed03ece69171e3882e6961477affafa6fd208c8c2e56afb6d59c4e291c1755b93efe8a3a97fcdd988bd0fd81dfcffbf41205a316195c424a3136c53e264e240c86be9e9a659020147a397d80c9fe1c9c14d97be9b7605d542b65cd9cf1323dc28822394b8ba942d35e624215eb6e777f82cfce4e6fd7134dd6afd3294a9b8e6f6b5dbb5a1f256f09d9bf474a304dc3243db23fb3eb8bc6fa3144c882ea7506f28488bb1d4b293bfc5823fd996644201e753e8ec438b1d77f8e2951a6ddff28e9beab800dcfb2b708e83fe68498c43cd415b32355f8aea80cf0848428218f52a929e72ec26d5e52e1e57ecf3da6d0c9c53db574a35bba1e46bce66f2140e7e24a59a8c2d53701c262471e47ad2071fd4302ed37e84428119108351361bf3e6b79b2d928b22447888f1a4bd48b7d117d225485f94241f56aa2477624524285cd57d9f4a5e5c99ec09e6423fb887b32a5379b48ae137b2d12cb2e3c359ee0b77674e31a7b8aacd2058b3ecfae65a4ccf8016041bfb31b2616a941ad4db98ff956febb46c1665cb47333bf2ae1cbb44cb3dad980dabc0c76c4434f2dd01d7d98c8c8878cbe8419b35c633addb2c3200678868550a243c3be7d8db6aa81692e6f216a28742a598aa961f65d212554ed7e01b22dd3ada02e0695ac578106ad7218909d2634e41751678684a0adcfb53ccfd3d7ad23fe415de6227ad0dd47cebdedecdbd5c634bf4039a2483b9d8a9ba20739176decf77eb25fe71b03e45216dc7581172f1d389c3d738fa97c5d24d68ba1f71fd740153cac7b60dac46e26251d9938c31fd348678c4bf1bfe512dcd4948932090d1d28221cf29afc643de7a0ea83","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
