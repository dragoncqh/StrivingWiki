<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3fe9b14e0bde17ae6de5ce326d95529fd4a3ed610efa001d9f8acf82c06a11f7292571ea1d18c5abb6ce2f609f981ddc7ea8725482a00aa0744954f56515cd0d79d81ac95bf2a51a6b2b98315e07c0b279f16b33ac4f920a96f8a7b01d6c6bca16ed2272164ae57ff340f134be9bfd648c1431556418e910d21c73726f09601903a467dc216f835255d2d4d0fbcbfbf762b8b41a332f2fdf218662d2ee8650f636023f205a1575f3f825c2a46d7f876417f67b4ecb8dbc79ae046689a8763b2b2eae92dcea3aac60f4b9df9366325c22254718b693b575962bf38f7d2c5ed8dc23e530a074c6e044ca0b2f939effaa8b5e3b644f175ef57cef32feeb5cd2e50873fb8fa5dc4cb3bf673dc5938832bc15eb298bd0b2317d467268b6d4cd26af19efd7972130a1c69d7c0ef89cb77552891101bb59c108a49ccc4dddb734a5740f4e9aaeba511c804cadf8c7f14e201fc56ca2fa1bffea2560cbbf6b1bf8c159da3670df2d6a3666ad7cc78cc4bba6a53cd139678b13b59901d6c7ddca68931f9b4b62905bbbd6cbc4704c6ed0b74cb35fe413aa01847787eaf7b0e26c3269ef7e6f29e66ceeb991277899835755f5f9927ce21abf385962058f4db38d8d718349706fd4eaf4497da4e84668a1ff10272145639b76131edc221f2ff4689630763da3e9450325a8911ae1e1ab8d424bfb797064dceb78d994ae24a2a25f823ed51ab66012c77ec587f3f5a861cf429d52ed0c6a0da18e019aa5dc9478561e3c83fb143192c96a2495de12ae157121151e664c017eace0a13ce7579016f642d2edb9eb760da6d2473623ea606aa1f3ce6129fac4759871f7fd2ca8911503460da7e40b545bc0f042c6ca6e47771f60feca2dd7b3ee0cdeba775296c0d7cdbea6e95bfd860d698d8d96f61f9741e27bad84d1d3fe78c5d1e802091649d1eb04b0b4c09e6cf403b6bddedd156226f99f71fa837691c8005625a97cffb209b88de6c7a64cfa4e8d740cf08c6b336ffcc67f4c4242d70021960599fd7dd98029ff854f62cb4274eff068c6507729b9f869d9067182c7873fc784e9d0bf6e569c58d7558f29b2bcea0b8dafe0ff440b8ca3f44a0ccb1abb5e2c8fab6a52fb84ba39af3cac53ccdfffe86f63995f842f65d096b943c5b9a4053cc013201a030afe74f8405cc430866d454839ec6014012671cb390d1e8dce83c3c941a16bc3e890dc98de52ea5eec1725d1b9f8d149cea84723edc2c5a4324dfd0a11fbedfcb3887e32a99bb3a1addc1a6378b8975fffdabf3d82f6b3e591d5c7e2ad8509deb233caf693d735e1178bf0a120274a8e4b7a4ab8d4fa0cc1f2e886ec186c5537a9f129776beac001996226dc173b16319d04ced31f509a059b1f32648abf292064a5de3f9feef90e8720faba71b6b42a11720083e07f9f098ce36fd245b8a84b1b919f6dbaccb95d9959da74c6c2775367ff66462fcd26672e64df9517abbf398884d4841d2bf8c2f2e35a4eac9c7e9bf5383ed063ec3a4f71859b0ed24297dcaeba5b6df32f2b491ad768a0c7c6251c3fd1d64769f419dc38c5b627bf634463ef0590b2cbdfc1b591c55e7c219fc6091d84a00deca4d35014d55c21c43330c24fc109024adf647f1bce74293eee229bc7874254678b1f38cd14d09728b59d25857df3f3cc75fd5741185940a0fcfd06d1b5b1ac6186bcd8563d1af2c118c32b04e18881f980563d2d5bda54e0aead7f093a5e690905b0360952ee8d8f1ed21cc32d933cc52097457f960685c629528b2d5f90a3e7afd39f29bc1ae073b1303bd7b9a5eaa090ad3476731079193c5009ed1fffa2835f11098c6df9ff5de1078e781e469fdfaf62aca7a7d7e0d314db6240544c30b6389a52e1b71928a43958018a0b9aadc7e6a085edbb11d9024feb2619a76285bfc60201d0b5e17ef3be5ef8bb4a142385d5a94fc002f15c5c95b0c5afcd8ab40201ccd438fa045250780723e89d12dbc5188e470fe6b1e7d12fa1c7bea7425fb5daf7b437704976174fc651fea896305e69bd1bd379f5e5a5d8377400186427ef51eebbe17d5ac07e89c515c45a90ba4d5bd0a76a80e2b3993b18bdf00745c13efe60149f78c11e444b72f6481f3975ec388740fd66c95842d3ced4238cf634371214a41ef8309450aa5ff3b3dd869dc2dea0c154cd3f88b1e149553e2f44817b19837f92bcd9d8c4b8bafaaa72c09f401f73d49c0353993cd8a8960d25008b0d5743296a2d6a2f7ddc6435ab7219379ae326f5182ed861e16709f8d37d469cadfd76abd89475eb6cc96b5c6a89b98dca7ed0bf157ce570552b37543328e0ddeb27f4d6339fe85bd750f05b1c9a5306bb5c14d3dbe03884f1b78fa8e5a86130292382d6b762bb3afc9b79546ae767117a8b72fac689786624262822ac2bcba71cd29bff70a19243ebd39ecb9f4ba0a379f2105d4950e3e7e0a4024514ce76e4b12dec3f895ab92e9fc85c1bcf79a2e4aec2aa7fa524def9ba9d0313182cdabd4eaf5f294de02e8d5bb0a70ceae9df765d548d8794014cb4e4f0fc61859bb3ab35a979565dfba67d1e003de8d0cc2b52fb726ff0eefe9f5f05d2d94eb27633a4e41b84253e54c8474aaf7cb1e36e9a5a2b5b0f1b77006e694b08638d28bb665021c1c8f51158e4032a5e72cf01d6539e18ed255ce5592862fb477847b65d3b5d9d444cd0d9eff31192803f4a7b7317243ebfc5be052d02dd14041267a6ce9cc4ce26bb5ad585389107d2ae0f846baf59dd6b903c8c7efa9e428cb7999d66de0c0aab5348816ab1f3885bc7c4eee708fe3bf8ea43bccc37949cf9b6f449b3ac86bb7a47c55160e41973b096e4377513bf8308e6d9bb203b16ce4e75022bb5d545275bd8d836e9e6e353bceae6ef160e8d559f2a9951ea50319c94bd9a2a2abb0fab0a4628dd83d032100f4dcaf838a628fd2926fea0b31c2ddc08fab8a53d62d58324407eb68559fbefd1135b82e0f93566ca227f35a2439f716301b6451a2cc51cacbc02f8645cc0c96b3ec7b683989570c4cee77996316e45bda59d580e60136fea77216081ae9adc79beee9dd7ce07fd96682e48a04f0fce2a71b02ae40568a1dca11ca32533b6cef9308f7d3ec70ff28b71aef0b3a2fa0e2221e3cae01a2d556c9f130539530e3737959e1ecd06e494716975eec3e6843b6aaf5df89d7b870c61874b755eb783f899f5c5d572b55638fb3b9dacc3a68231e6a69cbde2abe6721b4696f63b38d05a86176f5a59a119b8529dbd1f611b89d586a48b1552804032189871099dad645c1026e759b2af6b6770060ea14f43d6f3434d7918d6561d926e9754ba05f0d064a9fc472275c6bfa828140c47d6c4e09d90a190fd174784e99113447f51d23ec149bf0beb9b471221a047f8102c60089072bfe04a3e1a1051c21c424730aae0dbd0f2e6edb8cf92668845369418da2d7ecb5c18d732e96b734181f9f6bf90667d9e0387ea6196a57ef6ca090e43005569558b9eae7e898805034ce7a2ee43ce6922bd4e13da7034a1eb3a0be2c74c8b4fe32629f755b3eaccc3ebd4cb0af7c47fc1c2fc57dfb987d636df395242974e0b40e136c5fe11d0d13b37aa27bbaee934d452d30a8c4ecea13bba021d56547180f944c0bf9efeb90d5b37d999e40f25afc8887b4a91ab4b79d1c80a19c0da9752937c7d7c45bb1de58512876227fcf37a0c5051d744d76359f7fb6f7f474fa21f1e1c63055a1dcdcc13cc15ac65371baea18dcb90568cde685dd9d478d5513872a831ac2b191101f1a85e4c3d591af2df63f06346b287dbd42ae098f4ca6e4b69e3ec0f0017dbadba829d36964cc5514bf87f9cac06a6a79829fe0e64b1520a7b24eda019e34121021b0897716827557dcc9789a0b62baf7551805228d5b5d90f9c100cc83e9ffe53aed4324d6082a2358004c9364e78e4b50e81479c9be6c0b80a69c3ee0679731565d7edc67f2a7e6afe18e229f22359e5eb09be1f8f1e10dde62c88a833c7a0d8fcdc2ddff5bcc9b9347d5c0f418f43e79ca71ea00767d5dd698ae735b0ee92304535fbbae1452abaadab06ac52af0fa2a155e17b4e779a9c6c0ed589f0ebf38e65f41d38872ea0a0657b3e1332b663a546a69a54af17787145a382f88f0fd367531d413b763ae222998f020ca90a53fbcbdd22c0e2a23f2f3d950a00bc05e1044eb44efed28c44877c47f4c354696e7b7742cea22826c50b16fe994810c3f51f457f44e1fcb6fa46a5d857661fff2b934a652f3a125d05de32f9c545dc17748686ca4b98705121ccefd42335517cd4bb07bf5ec2353844fc55019dc9095b6ed1457b4cf08f3e738ec466f40639c9e3b3e2f4d790f13d14cd02994cbfe0f61fb620c070fefa275c0b6041049afcb41c52f41eca99b163c6a54a80a8faddc88c6f886439575a04665d6d5dfdd41e2236fe6afd2b5c44967c47363f07382a1866cfffc763451096fa37f3edcfab97181963d834a8649c1a3a56c5b60a4386faf57e4e9a97c94f440e8b33b9193542f0733eb8da4e510adf08fe15e25a8f980b9d901fd83885b314cfedf60e88b84b1e2c664fd07adf27e5e40cff901643e0add6cdb4eedeeba12febc00c39e4d55ee85d3e9a9e27a1a8b5b44a68b48d5fbe953ad8a6baed1b5b49e352ceb4befa72112a185319d1884800eab7dd9727e19a99db96cb04f923b5c2601546ae0a49cc72aae17ce5eb1e07b22bc577cf5ae4fc84dcac1fe7f72125a276ad2bd5308a539f563329cce38b7b9320304e9643f1e2c9cd4c1857f9df8e54537e0716d5f06af5caa15f9c86d0fcf4b5285f4f9a7d26537f41819e192a14e84ea6d8cb7595491eaa23ee38e1ea6de4fbb1a97f0161b4781188de9bb15f842309e8628865d0f3ef51da27c51195c07ac69927e6080a6a2757e39f834f07b12f2ac87e32eda312b036eb629984a95ebc9028095a70b77886cd5efee551e192ef7fa60c94eec3499eff042fba1ec35d7854c361e072578333b281bd78c05a90251800cd0cdfe8114707654e199801ce5abd3d5c9da738eac96ae810ec3487a7b1f834a6e370328358d174fa15be6bfb8ca451aee42d8a0b0a10c79b50c288a24509e9db4d391e44ab3bc6c7c79f4f5042508dd107a56e79bdd5e4d86b66267f0ca006285c9e3d60f3a3acdc58ca10b51b1a74c96815c9fff3ad9fe217a2be89c0975893cf806cd5140cdafe9abdc7a8a8bd93758544d3ed07a25158bee3a7bee788f3d0a2f621177a73f682c348540dae96404676742cde7d00d0d9d6810bd050d5260eb105476814f4d33a88d06f520d833e1958967eaefbdf0b337f0a24661188e827ebde8324705865f6a56b176d6d3b6edfa9a821a6ea4d5fd66d25c195adb171b140a515f39c186e3b438e5a29efedff754cf13933c723e14a5029b880fe4104bb91b53d4aa50a72375947c483d2d968d85df5aa2e2b40937c14c392ca0fe56ed5e01f803a8627f5e9e0e0a8eaf1e7b33853123c9f916d84d23065b73a2b5311d12c8ac3f3b7d3a1ddd48eeeee44cab971c49dd49ef2cd699004d27f458c1bd1ebfcd0dab0f10de822f43dd6d42ee24db4458dc9780cb13312b4a7f6d7f49bb593899d312f6fcf834c4b84d0f9f733755abdb95f315f8f467b501ea4c249cd7400cf854d8438afee4b82433fc1181a398a5686dc90ff379bbe619a23e48ef4a976d88428351219205d378d3fb880da470e60ffed24b055c42f4f3c3549ca39fd0aa8b0a880af61362bca030fbf27a1a7a0a4b48c53c79927f70370501b9c14e2606b8a7274c9a8674faec672c01a8478e21084027d83b65e5b9a4ccadd2fad7095b301a374cd27ad1f256a9f95f03e97a064e797608ac83a902e461bdc84f9087a499f804c6735f9f3a42371c78e8ee5ef19d49af10ebb45098fc38cbc8d0b44e2c447a55651276307daac03d266a598d35c55f012170e433549e163ee86ccde35cb6970691f8915846cf0f461beb99864c4aadeae310c360c3a965717a0e4bbc422e490fa44e30e05f078f889b56b2b519420a5485c25836d66b5488aacb18d05a9a841f0e7f3dad5b89911824131737f80dba75a78385478746e3db955045db5678d424e27a4fad5d7426d022200b3daf1e5b591febd099514291a9e54b66884dbfa82a184ab8f8cba46fecfad39bd9577c0b5f0f28ebce44499612851197da59e710697395e5e888e379d1762744b10fa6b21dc620cb3d511c3886cbee2438993a515f48e2a5696c871c0aeb6038b68123c5433dcf408ff91e3570bcb1bf3b08966a39cbb3488f2323309857d44e09953e15335f7f99936a7d0a55af93ad32e7249a5982dc2c3d393165464f349fe18c20c930a1f5266e2bd23210af42d6811f1bda846e6ad2bf67fbfc98f93638168a1a08c6885635f8c295b54536f52774ffae77531f9eed1f95fdbed3a1f44d34dab64a48cb9f7caeada96bebc297e824029a7bae2306b6fcec343d07b14249b6cf290078839269246d3b955c2824c464e61a29c3315990c748cf6baebbeac366f6776aff23d97812b4b531eac2ce604486706ed447580b70ffca0b9e25e8cb69b5a9eede36c05772d5ca2fe9b8053ae9019b7dda8e63143df757eb646ffda4e1c631fcdf9760975a62a446656de017292c022aab665452988cdd0531c0a58bd382f60e87cfa1a0ff12b3f1f9334565fe05067c32157582d69c131418621374f830b74d70551661f61cf41fc98b23b691c323f7b84dc76e2072b603f6c23464577f82f96375c7ceb92ff6e8837394629240f990125abea4ecd5b4c29444801973aeac92b8c5f7d8ebc748645c0779ca0a7919240883227896db2ba5138c60217ae47d502b89295e6d59f9b43313ea0e12588e630e4b736fd56928c2bcb43ecdc74e63c180aed38f094f3b48d6968c33968e04696d637cb3101d9b69ad725d9f6fe1fd379e6b307913f8281a1ba7cd37d32a4025f044665badcfa06cea9b6be94fb10474e1f674ba6ab8e2dad693d7d748b450d0508fc37b2de0c573b36df0b59d71227cd0160deb282d73e9f1f583eedcf44e1c8c2f5739071e203ade32c8565943736dc15f8750475b78d0c717952c3b560b05bcf34a2ca129384130914aa1510606b1c3020c8be1778c763b6daa613353cb5140405e81d988957688880be3922645c615710f9c1ef066a0647ad32d340a0d6abd19afc047dce6e858d93f404b37679991b7c4b059d130c73ef191ec7a83aa5bbd770965b2f224d13a25912ed9fc4f5b4a3fd5d589559763d596240f8bdd3526253b7312daaa2c034227e625342fe01fa081f7aa1c5027c8b12405672a6e19de38788e9d4b4b8e1b055c23c72b1b7c44a1519ca5f2b7e35699dc1565f52ef67eebbfb9807ff2c58c6c805dfc04f62a24271cff9d624abe246e451f558877b09d337786924147ff0f4d141e89470d7468cd42b06f74c1f6ae16c6f20ef3bb1f57197619f86c490672126817152fd0a5833ce5058e47c3d3c8aeec300580aa08358106e00d90e9ea50d7ace07bdd514e163cb475af1e12a32929cdf0f5c4a862a0559eaac6f1118e9b09302678cafaf93786ba72c7c9840bb85b8a713d4c99586212da56e8616ee87d4db0ab1df01f248dc3ea0d7937d79aaae8b1829d92dab01d11aa6365fc781d7d952ad60e7babd1614d1df8ebf42b5ff9077a034a2324bb1b9678fcda6953ccf8e055f2fcef69a6caa8018d088621c5378d182cfef5bcc6551e8dfa451effab320bec810ef6d6669c6ca71ad278fbc56010a11764917d14419f92d4e4c825b6436d28f9c2404d7f5cd4ba7e5e10bb1caca692b503184cc55be3578dd2386f80c06c43aeebd6fb023914cfa48573eb1ca762d838d1cf3903220a6d9e0ab22a5d45c12dbecb48386e288e2ae2f9482d47040e9a3e1431fe9df8b220cd0ac9e02a57032593eb9d164e0b64ff5dcf937320ff9d2e8fca427912559db8c12f05b2cdd90b6120f1d1012aec706343113f541c22d2fa0413e060c39c66b9adae8195c2aaaf33c16805303d9fed775ffaedb21a90987c69a5360ac641c36b2f579cdd71cffd5d4b0eb6653aa75de26379c1154078d2539a8e18a00119786fecc403f799827b71c5eac25412655464273e4dcd132b15e855f1f4b095ce89fa0449f1cb4dbcfe0ccb208741b37ef7ae87e3386f7cba5f73c55d23d060913b86cd458974571240fb36ac37626c775a452e5e334227d94c7f59bfac55a5b2d1c800c30ee72bce484868ae8b591cc0362474ec4e9c483d1c912566ce6117677747059a4be34ff9f65ba58f0eb076968aae7c94d3fd162f2eb4f2f9afccee60d42b4345800521cf4eb5e4ab65e32c88998a99b39436426bc81ccb9d7d9f6a6d221f605bd1956e4fd0278836c77b8643f7808a0b223c18e54c3f4f91eb744177b3da1ea7108d1a52592035b44b1de4eef5ed525b5ba37572d33fd30c5d04943d78d5cbddd3f8b0843ccb818d7adf0b9db06f11995e33c96e848fd73cd16d9129201106388ec6312584798d31385f5a36edffddd75ee42babf1181c88012422e801376daef207396828d36b3ac5c000472fb68221e5313ac84cddf4ab25593d42b7a7b3e1efaa23f03e5678d562030d3475d76a9601637546a71dc37756640efc0b14bfc284978b476cc295d00b7676e58255155e6e90b193479acc6e579addb8b72ea19800c6035c446d4ebc07b2629fd8dbe9dcbbe718390e4a2515e31bd54e622ef5708e20e9702546f15bf4c7190a8e8e88a8fe5c2ce57799b9471101e01b2d7fcb6767bc6232866bafae19a03b18ea322baf13f02b3872a1a4766fc405f4f3995eb40782d989d9f87e5e907b35b26ddeddefce14f5247db219d7832537efff807be70b45d0218cb01fcadc9c229be57f71533e300c996d38f7bcbbe63b25cfae448a80a51dc1c8d918aaf0b6e4ad91a08ed40ec7b991491ca266831edb05a570a8dc922bb234458341fe736bb3d0972c1ffcb19a631542d840b5f23122ecd2cdc783cbad464b538b171bec4f3a27c8a25626382f40dcd49a6e772ae0f0624b183a9870f4b8d6b3f6585c318893253a4df893a7246ea748ebdd3ad5b19ce4875bec57a4b6b2ca55dbcff1f3a2424bc7ff6358f89a3fadd4a49f333164d74f362f2df12a6946c12e993bdcd78ce101d300c55c6f8e131999d36722872a25b4119cd646ea55f55353e030eb8bba6ed1d3976b1ad55da44095208af6553203809dbca5088252a08757b97408a8bb171de27815c6dfcaab835e5951cc7e4b801553ffbc9d9b8ddbf2aab4e8203154fd2235e0569b27c4e2a54f02b0f94eb9de370bd6f2698dc7730a19c96129f0fb12205a959446f40a91f67f23d34591d86fca39765b4698aadd1f28c84cbce95129e59002a2f90838d316b71dd46ef1a803ad4ff604e18353b3ed2f4d0821ae56872171f7e7b4e1d6922edfa10311ae9d7201cde4f9cde777316351c077188932d3abb31d77b185a783d39d30b6a8b28ee3b553a3753eb9a79a5f793213c5c158d0cc24b40db180c08964f7a3a9d0b2c03725c4a534b726392dfb846506c916a46987d12eb0fb2502f67e213d38a8f8ee00bba2d5a55075fbf191bef23a6a78232b1f1d24eabe56d604d46d328e625a6b622f57a691b74f04adff364d816d73258ea9bb3d0599362365aba17eb5a4ee00490db9d5c5141ac00b1d1fc395964c6cdf6512a26d3cf86eb9f2dc2b2d5c583c390bbc3254adfffc4fe2769d198e8bb96f747555b56469444a357ccf7a383c0d06cc46cf7584215a26c159afd1b4cba169bdb6a8a5ac91711b21f892349b945e40deda82306e5ff8db4e7ce8d866d8c4b89fae50b6232dc0b333369c9745b0c6dbbb11f9190efede47c3b3df4bf9c1198d782b5c752303a4fb7fffb91e653fc35944680756c413d0296f8d3d14469932444d0e5f24731bfb17eaf241a10fa3d7f84f60370f714f154f0de5aed614e7d9e708b1f9773d18d24646c02394f193c6fe7e0558e027d26d068df75c1b1a890040c06ff4f13a0d07182729f92f6a2c9cf6dd3f412c8dac015fc6a00fb780dda2169a234414d2f11aab4945007e2018c6e1f08a3e77161de9071a3ff89ef9f1e30ee492f5c2bbd6640fc832c013da422975470b185ddf51fadcafd46cb35c739d3b062825439d24c39a0dddf17562b7d33b2b69ab376b5b7aa674d9e42a9e7360d87f20bfb0f45bf755a97b370847a635574912bba790f53850b9e0e0b755212520f8940f48ac91ec01a1d2086c84b5f9a8fdf2c6e519213bf6169a4aa2bd423b7c663374ef838a1cad33612c8caae95f339d49361fe4fad33ef7bd5900d7eb08720ebe88c811922f53eb805c2da0badcf579893ed9b10ca63355469be6718d8540c5aa93fb8237f6a9da17af40359611b1c7a1c91773afc69cf42bb01bec1cee37dc835e817d394fa0c3db7cb2055a88b6ad9260f00b9118c8d4b901179ac8ef8d4348ea5dc1f357967f36c4ff1138e2117a603b4b684c5b4e5b328ff27e0136f687c8d59cb04bc6b4d0cf17cd90cb5fee68813b3bff6675d02722b0d6a4eea117ea1f59009af0834bfe693a1167a4808fdd1a207cafe2e8c8ee07f314132c24402a06478e610391eca1d3cffd2d87b56dbb20af1ee7386272d6a726082dd7fe55cab025b4db4571fd6f42149ed165d8b8ea44d11fccbcf243bafa75c9ac38d6f7c06839225a730a21e44ac0f9c088eaec5998f60002c99ca4cfd770427e61d3dc07eadc58d87e242fe88a828e5935d3a80c4a0b9b8da9fd1859f0af65840a871643cb62746767e6c20b6a5cebde00dfa0bd0a5f374c9594a7d4fb97a4473019acceb07047442543814a02919287b956cf4c89ea5b3a335c161c7a95c30538315a1d8917b9c1a2d8d1b242053d5f07ea5b625af04c72dc5832fc262723deac148e78892f42ea3a7015b2d21e38a9a88330e37978f3633c5d34852846d2d9182e3b513cb1ce5adc54db0ce82b757847a5e847abb2dcc900f45bb053730b83e1577864735209e93d21af79f7309b76db3f72ecd38f306c1b97e063824f02c1c3f3402afad2dfe11791ae9db2b6e030d91b7bcbb4ff1e79fb12c54622a952b97c7543f8adb9fbe7d155e8aaa6644cdad139795ea067f3eaa412402ab34c197e193a14b9330f29306d15c782a4d32b7e88a02e647d4c5e27eb3ff2b969ea1127d47c14162c4ace266446317f27c826283c82a8f5f13375c0f98296ae30d99e17a9a1960ce3158a29b61455666386724f53842b4c969b5ec410926dbf7b2fc86d4c32ab3158e50f9555cf4739af69768098f7223cadebbc1f0c654bd41066d1a7d2ad56ca4d6c1393ca3d4e547a66ff9c1b36cf3e3e80376a31acaeb6617e446128e3528d779a72f64d2a6d451aae2fa915abd1dc5cbd837c4d2872045797bfeb2734779995d3a800df5d5477a6a33f2103f5a7891359032d116847b31cb3143281ad0581a34048579e352ee883b1ba2152c9d89f19b56ac6c464eb6f56638a47fae33f168cb0b2e6260be79aaa01320182d207c244c4b608efedc8a83213ebc43364f02fe4d0d57120b5b3fb9211e20f3b74f138467ffaa48c2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
