<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1b9ecea0199b4c4d8f90e9264eb60a5462dc050615588d6a676262f995eee5c16f8ac55bb5413b91e0561b0636c288fbb686a10bdf11512016bc92011a334d26c18ae8b3e540a3f8d9ca25595ae55828140e9a2683eef49dbfa0eb02d963e828d5d43cb89570c12117bea446a1f430831b7a4ddb5beb2ba7002cd149d16ae736f453e6e158e90fef7655af1b43eb8d3eee1eb972097cc06babd0979cf9027650b1c5474d670a137847471a2fbfa598e56e0aaad327d07886184ac255a0d33b6d2dbfb0851315eda0d139aaba8478a902fca910f1d33e23c4a2aef072ba883d373676ce49ce0f98b125fdd164c5e8c5caaebdf164246dfbdbf58f06873716f5cf414ecc80d19c01d872578356e0f93caa9ee86ebb92b066c7e8f1c0e2fd2a6e0869daca1c142d98d3887ba3fb8b23cdc111a8682656707fb72d53f5504779d9168b1ddc215131fc1667a51312974eb908072a0dbc449afd8b0df5165ae8739343f6c43e0e205e2d6f49fd8a35434b7dee94185a0da8baadeacdaed16283f7546827f72eaaf77eae9f669126932bfb5dbc69bf43830af2b9062a098e38d9823d8615f550872bddb4dfab333530e6291b5359e2c44ef78f0c3f50411abd37e3df803bc9e466b427d6cfdb077526dbd2bc7bb6c21dd757740488689ad5083fb23ba9a3d897a26a95a49518dc2b7069807204eae14ba50628c66e85291d4232163b61e668eab9fd17743773af4f99e68cbcb4b590cd48f730cbb2384ef18d9dfaa2c7a2d3f4a23dae1d58aacc22491ba9b79149ace47f767944401df7e9412ac568c8f15347721550b9acd2254e347775ded0abe95d6bb501448a7aaa2b3f17273797ebd7936b77546f98c4bef147ad31e463ceb4d84947dac857ba3d9a5e94542f7f6e6f7b45b7d2b326fe28f0f7124f1e19dd71953ca30cee0f46a743f671c51d7393797115338db60ddf49e7780af547594e6d5ebd52b26177d79475d23cbe0b690943f5e8cbe29fadd30ae770403fc2059e140113883bfdeb89fcf2dd035ce9d58034c736a7cd9fa00ef592f9f7336d16cb5c0bcad97454c9f298fcafe036c0fe92e690b272d0cce54572f960096aa3846a9a9524d0bdbda5c17fa31fbef59c0085aaa8d7af5c774138a7304dcc97dc9ce5243bfb134c4547a2ac658bb6f526608c8e62444561b323b06b6d15475f9dfda80850132544d7939de69798e7383516cc03db12888b2e8c3d42b82621ac4a96165c27cb903388ee4de20ea2630387e1d9347b5530f2d21aaac7429895f3312e49e1554fe79073e2a51f60c135a207b3b16af5a7dcd8409754baf8d8774a2ab5d89d97c2b3b5127193745b2c136d392427eba3fa5a5f61845e4b99b21b88e02edb674d56d6f1a887667b3458e77a916cb49d5066547f6c6c610d9d67b0491e41a7bd7596213d4396cbc5bbec9af163325b9cdf6dfdc621539ee2208e4ed8076a89ade7c6a4d76d02f0e88f79a982103bca773068df7be3a1421d5c50b540628b39537ed32a611775de70810df4cef384a83465b449d85404f14c50a02c4e5a01d8e6206e2fb331d51aa88d188157c045ad8d40a43cae6d3f9a50833b79a4e57918012ab9f5bbbf57b4b282b035e764b740c1d285469a716750967b5599c7d186584b0253bb8dc52060b3ecf4375387d127d9c1f9b252bbfae1e9dcd4097bd41a1f3392cb9677caaf48de038c8f2f7e2c2e2b943338e472be6d9da04690ea6683f0b455b30b4d6f4f9785a5ace893abac5cc86f929016fe8af575598fb8a30c6068ba55d563917717586de60ecc93819ac9b0f44401c14a3d4829a7da9c6be8ceeb6845ef40379ae3132482930b0fd6d2fd2da3e2445cd1ce528a6d9408ea8e8f3fc34031e4ed1cd2eda5362361c11edba9ec16bcc228359e5db4d65ef95aef457e99a9c50bf41aa978058bafbea63259f1fb61618e7bf106ab69e2356208911ca9e157d3271841480bc60d36dbdbf9ee81b5b496dad76bff29bb4761dc98f9d771eb7d497c09c7b144a5151e6245db6dd67b23b1448ff32816a4942ec62f3418491b5a208aff98dcd122e611068f27dcb50ac6208db194da4db67e8aa1d9058297580759bd9cbefcb5a1f73903fa9234814082995e8563d11b5fb10e05c59284f864e7c7700dec9d2f2f6d359f53b5b58cd7eea93bf2f2007f99b6f2f8b54c8783ee2b8c2fa2c703c05cbd99db85bd8cfef1d9511b5b9b20f15c3de96529a43823547e020b4c4926ffe35f235f9d65005c2512634d1c69cbb50e202ea7c7c19db1bcc5f3bd0694094b0f4d572142e071cf670904446a8de00a7731894cc00fe7fa57a9ab6eb10b2f2597b7391a011ad4c0dc8f9e9a0c4bf4977e31a02c421261ad4b3405147aede8c83f201344ddf5c1bb69880a357f32345b8a665e65262d57259089e4d9f997db149f0f5043f8f28545733e2edab6e5e5506ece44819af21293279878833352e0bc2da89f30f2f1e4ba51bf62f3b82b1c3353c6ea1f6fa506f4fbae357a651f75482cb2da2dd555740d6f6eda5681d948fe3cf5d1993ff1deb72917fb061d3949b5cfcc8d2493588db971f66e0ac23adb8979446a592a16c98ed1eaf2a3aa4550f431e6d5dd7b8af4c6debdeb1f4efffedeeba46e23f5e5d871c36f0a04585832de56a41af87f8f59b5179c15511e8212afc7ea9d4919af00aa351803d08adf14849941e54b147498f5aa4ba8600da279ce38b86f2b249c8db11afbadd5f9d034943230b674ee7bc683f44728c8272038e04bcef413cc08bd3d4350bf60acd2638fbbd112de8e865d4e29b2699b7a27172146bf62f2d3a21ab3810bbf50bede97d16dc2bc8988dae7b9f482726cc763248838c4ae1110195f51dca33b4ed5a14b2f960791a19b43666f81da26d052bcd5e0240f6c63d59127c844b8366c54ea9d233b525e77d0bdadb58f78ccfef9fa814333692bdcf86041034006b67641314a5c55e2224e1297523e248782b9b881b2b0de8b4a439d90aaac4a9390170b9928e15d028c4e92b692d87d840f3751b43235f785399f93d7e1b2d2a7e5cf580422b55fd83a7289d9c159b83e024e9ff64d05d6b6d3d3aa8b239bcc702a0d5ed97515571b714166bdc53b8f339b39529e50a1300bcf9c5487cdb0257e4d805eefc0d4000161a18d1d8c9150b2b6fbb1e11c3407a3958531644cb0f1be97db46ac5700b5da3272b48bbab78d528fe0c67a67bb098ddef1876897ec3a8f36fea7bb285691e5b24b1989102aaebbc9373cad959fa75a892b2c82f3b63d910ce4ee92984e1a8295864b4ae6d3b335602742a27f19599eb40ded6e58f440a71aa07c0bf82538e9c1dfa7451249ab87d40cd9523ba3026f4ebf8276133f564b69577c797b77e58bcc20f4a1fb29eae3dfebd817754d0527b10385abbdfc7e6a187499c13d01e3c5b61607ebccaa668a9613fce658e68d8a74e971b80a37ba76249fd828a67b8b2d4acb71d3d6a326f0aa44b5e03fd7f55cd6abb2034386a6c261b4c9ff81243d9d2963d627c3ba380744337e467f473a3643ac447a37a7721168fb4cd579b8c8cb2f03045513ac7cda8dfe0b9204efa0bfc0417226eb5197422d4d62039e0c6317bb30bff5b22f1f8db987924a681b7b3c714191e41caa5280e025e40494b6ad9ae9bb08e59d2919dc615ffd782e73055c038b45a312055c52ac904a8f710cd9399ccf5677a8cf9eebc46009382136dbd3d140a5ac174e6f18a25709303f587d2ef156e4b71862e56868ab1c4e3a5e69215e509ca1fa8938dd4857037817553aaf1cbbdf471cb445b015318d8d7e4169814626bb1a7f595366a711a3e7dc4085497a43cdec0fe989a0e8e594a0bd16af0879f826c10cb245c47330ff363a466bcc55990a6a773b235a61d670a9ed35dec87810ba83f12c5d3b309d877b48dd048347d32ae18277a15302554d5801cc715111343d67543040ad2484cdc9f4d3cba03239ac04fe7187179baa8bdd23f46ac362e1d867f5dd2fdcceed177df9b45b26fe32418f9573c4c1d7b028168342ff686b62bca5c999359f3a5ca56224b4cdd905faba0319c7988e1f42f8b7750b5af6364262db204e4044e2a7a09da97c3b012d47aaec55d22860badb0c3eae1bfd797b1f662c5df8c6e3c11a8ef5ccff54826be53ae24dc8cb60f7ba7a7c7954939629a6217e307917bebdb37db3e4cc57027afb203db6780722ca141003eb13dba03202109e20e80ab750ec8ea76364ea33d5475f276359e46aa754214faaafad056653b898cc4e96cb0c063e42b665ec2a796e3bf7d50ac5252d1e0b04f018dca67641dc1590a56dab7b43acd4f82741e34321b064b865e8a92041e0f1570372c16fbf28bb1366a53e2b3935ee1b029b50a6e83dee1a1715ccccadc1d5dfa16a5ae32086dd1f4bbe30c4cce063720d4584abb86a6b3bf0f93cf46effe7166304729b9eb5e3f281bbfca83b37b7ba3b8c85fa48b83a70abb6a1cbc1190f1d6b7835144c062950038ffa15b67646f1ff4c39d7431c23fd8ae9da182e441c00600e96664ac54f9e8276ab0ab999c21a17948153acd67ece669535cc975ad5e01925fb74236f8ebac3e855aab8aa139206f9f13a6289acea8752ea6b8e19eed0a50a46e3d76ec582e175010b4b2022acec9def0825a27c87f8f8093b46194117ad1208fd174ff376d96f620463b294bd3f5dcd74f9ae6a2259a5a837179f89da58e5c27b0195933e5bdd113414d3bd04f3bec236d392f63119cd56c9816b8912022b327d0050f27793d0802d9a63d692e5c0a55326af228368a846c20dbdaa3a57eaf9d5fb64e8746394b1890376878fbf246216917d88787ddceb660253133c63d741a77a7994485674fe4308eac6548ded36c596f046c26aff065aafcf268695a085b2d72cf90e2357fdc988b1a870695ac2668548acf3017b4ed98dd4a2467dd88361d6c70268ef57637240bedd9825fa2b6caf4b3eddd75ef505c52db4961b4b3627f747c0162284715f179504ef4a1c7a8adee58addc3a7318e795c8a462b9c6e808fce0fcc4fc5d4000690bf4a9b8697f2acc2ac9d80e390b57d3e3a9535b02934ac889385f6e8b4c74c4908567de6d40516b6d87cd16b2f0e600c544334b832f5bd4cf78ac708fb4b7836422d0a3769c1af104dde4023a541f173fc3a16bd99ab2072e500ed6ad5cf74c27c8a85083cdb070bd147ff98f41ca7f29aeeb08e8f8093454f9848c8c92e4b1ab9079d4ecf6face39f215fb8ebb3609fd5989d547aa7862e6966b0d047311f743896e0487fdab349b32255f985bea994fc473ef81c59ce49f65f23287de76bfbe3f8127632c2da7f705bb6e92785fce2733accb1cbdaf9dd3b407370ff29aeec0079863993fdfef918508d6702e027aa7c9b6a5ea067143d22bec4cdbb9074fe4989c6611ca732fbb9acd5cd058d7c003c2034557de2a152881f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
