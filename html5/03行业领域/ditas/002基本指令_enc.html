<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b65fa2f1b845a19ec16ddc5025ecd97bd180afe523dac0b5afe01d2f4113e99d8412d36ef35e5241b317d4135795e0c328a4161becd6e4f21c787a934159ce6827beba51ab1a12a58b6520789a6cb414c365bd98e7cabee4d54625cca94591f35e21e06c2e7125725fbe33194324ee1a697b0a77e2b72ee8a9f40ab207ca9b9dfc3c10d694799cad3897d614d08f17d585384f9963b6031316464e035e71c5fbc40623c2ac162d8f9413f0e18a700dff5ab77273a9a201863ce6d5505367ee00d497dcfb097170a39c2219402efb375378012476984c23ac71d8eb386b94fe8f088fb6e0addeb6559167a2c14417d57f611b604624fd388880d732b507fdcab96cf963725d710a3383279134b4dd25b48dfebe0c97c29693a4dd1d3d0c58856111a365958f3a87105c6c58a80387e67b9ef9ee72482011f6f02dc0731c32b4466f90f18e4cf349a223d353f7b17069a1b22bec7c648eab98db89719f55ec0bc1b9096d4796427cfe6efdc1147eb7df431e64cdf508396e121661097a4c3edc2ef596d436d8c8b0a94bbfac7c5251f7e9bd56f061901d94f5e4acb154fde14d78b008d5383140339b91694a96719233fcef8f122f6f3b838101b626442c1c365c9cb984e1f9f0878ce4110d3beb3703e207fcbb20cb4264915058ab5faf608c52e73e058ded42b590766f385691bd58c2e0d41144610bff225c1d72d09997801a4cd3445072d0b161e405c4accdefde931ef863692426b61c8dbe9b54ce9ad45f631f546cf238ff5b1f9ad85b998e36436762a42581cde58c8dd441630225ddfc3ff6eb7f90ded3e5cf91c6e64374e76273fe1d05f2a2917781f74bcae49d6fdfa39f9c1fd163c2d69f52ff0fb112ae8b69fe4a44bde4232c93776d30b22c3dd113fda329ccbb322fedef1551ce93a7e61876499618bfa9c5b613ceba5e2954577e131d7efbcb4f813d68b0b3b89a03967aa374923ef7a4075abbfc40dc9c9d9f66e7dc30cb09fc525adb06ea6717f0a029b5fc7d87d69d87f65f0f84d3228fe5803af447b1c80dcf0cf17ecb72ca9453cdbf83b4f4fcca05b860eefa645b8ba865e8c601ebd95e93da01662414fda1114e4e4fc20ff27ddc2f3aebbeacb3d83a224bce5830e6c48043de4ea303f84ec56d6564438a75da964a00370c4a510cd4b425f39ecfc64e6b80ed55e0979bfc5bfff0ab99a3a092f672d20f9ec6f3560aece6b3dd2e242c15b3b7f69e08ac8e0339ead4830be238e74ece9dcf5f513a55bf15de6ef242e024bedc3e84a90718f2d6104fa8a8ec80507483be5b1aa5d0b9818d93e16cf47e2fb1f6ba7aeb42eea6476c450b27b1f49a58b7cd005b78b1386f89c971fa30e0ebd8bacc10102fcd79ec361469949fd45eb73efb4da509e1177c3f9d5003d526bfe079c75b841cca52e144b08bf27b22e90d37f4c78642a6ae7debcf513a13310e95338bf6e9ecb3df89809ca52451e0ee1a6adbe8c6692413cd0e55929551d66c827582e79b57cb7eb0b003e350907ffd51bfb2f365a9bdf6a2244b6734a8fc72110ed63b13b8fa430c3549880521989f6c7fc30a5fa46b0e99f27aab3c5498a7a157ccbca100fcf742414db16b22309a183d2c73fa518e3d7577ba711830f991eae22df95b774f8b0ef118ad7dea1992f73f9da9cd40fd224f5c0d7d909a519d21a4bbddb0dc35cd6391ba116ea56fcc9616923610d59ff16a7c408750c32a369f4c84878b3dd661b36c40c1f19503c1365be04c4f4bdb1b262d4fb2fe2f34b6bede8de951e87cfbf20f0b36de3adb518593df0c372309f9c4aa288ea30b939e6a03fd05ae57d17a9131fe0a8ebdeee2e18cae866eb9a38a292e5aa5b31b9759e0084c1375793b0fb9813b1e4d5a3689cd853b1389816252f568137813378ea75b394216a516adff2e7620869755b8c7394711fdc713484f9aa3204916454adf3e38ac8691f1df7077293c6cd3e2494ad1fbcf121f2ac17127a92f4010f0cbf81a10ea6ccf8d0922d631b4a79bc66a39fb08717f69b0312bc07746ca8396c0c4e2714e0451827415e5af1f5e27c6b345a3dfe58f1389f4a482457aa3ef3e3480c24bb379171628a55952d5e31c600d01b939b20ab092775655c52ad0a43f103912401a6799c45c6f050bc9d3eb3c10f96e8334241524cc4b3857d70facf45f83265aca8119ca717a49c4208114f8a7233afb104d8f95d6d7049434c0b078d64a6b8b469eddf0f9a7f367f7531a8a2b751d3fc4d0d32a6602b72b6650a19c04c966b0640b36d47bee7fbc473f7a8272df6b645bde693830ca22c3523217bb86465f9f1450eaaef7c3e50e2b6b0e02db95963c13da61e2ea6b795b63ab18e10b212a67b15b402f692fa9c10f6f342830959173179829fe17868c5d4b28daff6761bc83c4fd12ebb07c545fe72ccbd99321c58bfdccab37f65287ce3dbf27d945df26d57b0b9d590de28224a770344fd7e2077aca8811313447e569172bcf9a11def2e03f41e2b6b959d7d648580f8fe589937c3181cb8d56485763468bd950b2e90581ff64191fb81914f00a29ee59e90f47855183febcf38fe476aa4d42dedf0f96c293c1c130d02206aec72e8651a36e64a2e79dcdf2cdaf3a20cf2def39054d7bd3e0943e7b5917672232f8e2a3c2a03c68ec2173223e0c0b619ca18423950c9dec16e306e30dcd8c322b2da158a189fda6cbd2bb0dc402010d3cf4aea5e3ac9996446280e84c65215effb67bccf6fd9c7d56591ca32c0c19410c3aaff3b946850e3f619fd53197c6e20b9517ee61a4092940b91c80ea0ac5059c58aad46daceba36ebdcfe9b7684c2a4c45103beac43954f29ff4d10048310183143925ffecbf26111ced83ed95be8f694f50fa978a64639ee427656e1d927a610011b4cb7df269fca945c640fef6ebdbd7450def2bf39d6185b7eaa1ae779d55b62a5fe4f5f16bbe228dc12ff46050e8677d3623739921f27e1f47c02f6ad31150922d59f08bb39999d1faabd006fbe91fe669ba6e33d5989d5e84d9d9077794f1271e467c62fbcbe3fe5c3119246f89d9ac8dd06a0178b3aba44ee8b87798b9c7cc333b9329eea417e3791accea32724334f50649fbccc289c6ed50303bf35103bfaacab03839fe8300beec6cb02641c424e5b64075bb7c36c601d100ea3bfb7955b7755ed858a3be662aca31816884f2860fe5ef749b8ece9c57cb73463e74316139286a6a257939d2fbd338046639ae6fd1e67fffb80ea6e303ec42baa4775125bff8b9d5ffb6c32fa47f0e99781c81769c49b710106a4bfb55f62d59b120d821f0e4db6b372747f38b2cd533daf0cce5254d352e29f9e78874708d585ae901e386396458538da52c18b89e4c0c76f247fc9cc13c8ee50e23e1f233a6875768ba93beb4cba08220e40d4631269ed268ab1b0780384419135b8ea964a79e0672b0484bc308f0106c64600da0f49f058f13850947ab88008e0f1dcfb8ec883f945a443fe2cd218b44e7884228594c8282ec57d4cf05d847bc57cbbbbb60a082f43d376f1999be248065a3bfdb110b500e57003140fc878ba6171ecfdaf8c85762067629a153dfec107a6b6b22cb99a1c4c8e8002e3ad95cbe9e92622f2dc934d7bbb8e924d382b72436605c7ff99ab4dd496a3f1942454cab3c1dff165806d61dfd9f3b4d05f9e52bc7accfc6353e99e93d34ad95a5210e21ea67fb591c7d300b22797b3e8d01b66a14f296e25fa40bdb6644acb9a649d2d3b30d82fceb3c15603da7e807e39a35c91aef92bd4486afd39d721e39f43e7fe9d59409ea9552501c5bc000f1747c6c5f8b2705f33f2adc2f092c3b7989a92828f0f9883a1284675cd2bc87285d7040328edc76c28d99cbc3198a11b3d401a8aba524bdee083c360dbac001e5c9145c5505c4812f7b8589fdd8cc1db7473e8daeae68e05ddb62aef76e5f78ac7eb24358cac3bc9d584b74488bc8eaecf96f434e12e3e34875c4cedf4f4a586ddbb269207287f901dc19f210476a6c0a442065f2d115275365d5e83350db8ea0c2ac8f96766c0a352b07c976685333edb18971b39018fdc3168d969824b0e6bd44203d438b5e2622c98fbada5cfbb19e33fd7a58985c3d36e579f0c82bfdb4237124c52353eb1a02fa6148c673d30f5611e8c716f62ac8668a0dfd303693d91d649a97561e21b81dbc9d6f29aa7aed1828c1f29b53889287f6e9185869acb72d6a7069f57076a4b50ff95216e5e4f7dd9133bfaba27512a75853d239b2fb6597251f26da803d4dcce76bfcb2ebe5fa8f84eb780ee3beae4aafaff4889078a3f35c4c51912481cdf714a2d9f8d788333671950dc749630268f09fc5c6e8cb9ffe3a873bcb2c33fcdb697ccb82f2a93b7d3441f79512d7e6363a2a3fb3100f88968eb46a55a5c8621f5c4297aed6adc98f4e17ac7e03ad4d4ec50d632126d44bebdb044f02394001492a1828ef50d9a6377bdef6fa81a434d985fab9369ab1281fa6b419bc49249ee26f7beac03a20b3174f5b8a47c436c8262d111993ac208529254a720a03e63ea7477b1b291ee877e87d0028f9c5405f14f452aaf6596e14ed8408a23a996a42e3202318756651460a608630655fd706517d0115a14155c366638ad27bcedc2db56c510996053f9cb43b516bd3e82e344cb93a5d3cb684839d3b7e19411de48f9d12a75e28f0065164784d86d68e9e5e9cc6f9cc605f69d88cde157f64cc7be31c688fe5ecfafa5572274052172ff57348f3b1382facd1c7e848ac333bea3e3cf0ad6383a5c92e856a566647f067a0576f88a8d5a5261b4f0f43129c7efcf1bab46874042ea2b2b05cf382904699b117c3c99095621342064688376f60ff38ccebcfcea546badffb06e7beef7f342822388680267a3504a53fe29d0f322375c16e2cb6d7726edc53452e9966d6788643f35126c12fd4d671c48e608a4ca62ad31c3c0a61192a707a5f5eaa6cf098c1c2ce2d85112c67d9b72ba1c06f85c232f65fd76d814ca72d54da134ca1c8f4e9d676e79ecdf4073f0c301a37eb3227e264443b9d0f893ca02c78e8120c60954f9ce153e2a65c660d9b0dec8b3cc1058cf80cf58f3b02307691cbcd7f668a3875ef6c4e1188ab8a8b06e9fa005c6198cd0494aece5a56e6601f35cebcb99fb3b0292a001342d1159966f5596bb670a7e6c99670029f471fc79e53794e105b4ec9ccdf9bfd7b6c1633c432866b77c97710f63b6fd9f9a9b045a45f2c11e9052014cc532c17053d5108e549446048b06b18e1e75dfca3574f4977b4259d4c44dfce86a255296f1fa3e4d6583f72a474efd34b9e9c4dc3b849e4b3c18a8f245c7c7166500b2deee909c7ac017830f09f2e8be727207a461d911b725f5ce2a391e16ae8f912cf491412abbce5f355b23ba70af9fee2c1c78dff86334b9c035d72db65d0694b4deb23d2fc5d7ca1b22f9f09130f8e1286b42ccd70873c78ea9e69d7b592f906cabe07cd663af86f3209b8a9b6204c51e822e93ac27c49b6f0ef15d4ccb474f60bd0fac93f03dc5ef6353128794737a9ee0e3e7fd8504f768927fe67b24814858451dd500e771e69a102fee34525d010deb57c61b89765363ac46b1b915bf19c898fab9c4c973476f2cee3c82e3b7fe4a43efc25e58254eb5c005d0ef7462e77fe0cf944161b7812b53b19f1ea983189a12f48e2a9ecb61c9875876fd46c10cdc202a7f6b2f3c4aa897c62c8e2e60bcbb39a49c94e45f04e18f7760db0d315f91c56257eff6d63cff67a74dfedab5b438f14a1eb6b6641a44723005194c3ed76534bb8a69a73169020d3bef4618e88b1e0e1ba15bb31e49aabd432793971a2d0f4ffbaa7458c831b17dc7ba463ddbf4244c859c2d773884b3fe90d38c23041e8cc37cd7c02834b4da3493eac4596ed3068a8cd833a0a2d256d9e77d1eafd36d37b2707d19801c75d501e1c8fbb0aec6641a3e4577159fc677b95faf01efe8fd1fbc8e7457f613f6392967d9b54764c63b7ea4471c4e4145f09cc7782fd0a22bdbc8b91b2ed3ef9c1edabc7bb4fe4b75cb328e0aa942570762b861883c2f5446c156d22e84c754a484d330622a1923c92f662f294271c7e811e1960a79499688e234741af7c1c93ee820c09bf7b5d72f760193ead7fa9067138dd8586f1ee316fcda65fed6c1f2c9fbcf031ba4e707cdb9d53efcd2eaf584185c57763ee11cbef65af7b3ce4bd180d80d2f88daf64cd9db5b0f885df4c43daad2a6cd3154576c7e5302d182e42ae4daa3a7a3d2fc4fa68f002768acf000684a91c29df1adea83fa0d9fc1aea1430cc0d51305615ba5f8997d66bfc5f051ea429f6a794098c5ee233eef226f6d11e767afc4e5b84bac7a97f0e73471d52b9c408072364bb6bcc301b6ad6157104893c5c347fa13aba924147b091f3b4918a009e87e89f70f4dcc77a1a7ebee738c59c0b92c27d432da32ba8665cd85c4b5cfd7e83729b7feb93ee358c07c91e32e23332cf01c90cf1d007bfc38f161e603ac1a59b995b85da146abfdd2870464a6d973e5219417eab7676b9d1cb9af9b2f113d9f63ac55b020fe8381345f758c44ff0396afeab74a701b09983ce38753e1c18f1513e8d5473bbc9ae4c2661c46714d7d2de6ef942350ab76798d037aa1525202f22e663db457268b91e304008d41a49312818c5cee8aa586ec9795ab36b1cabca65e4f975854ff185bece0c1f2fe019237ac856e3747b058d8e6232857aeb093ffafb53f79650521f18e3fa07accd9fbb7eec9a28dbfcf4be97bc94274d691c5a82e4c8c4dc3176f514afa4ac16ba003dac473ccdb57916d02eced85a655a8d84a3916fbea2e92745a2fd896f9e25133997e0f4cc2919ea5632cca2c2897d59d4944d1e716dcd367752e29ab9e1155e6420852e6b5c278d499b54a7160e5dbe27fc25cdb3af3c00f73cc8b7acc91f42c25d218ce660feb3702820bdddd539827dadf3e1792a8fef8732bf936a91981f6dc86971fc3984b2cc88f954c623e72def263d06d6a03d9be02d2db970c3cec88ce45582891b1fbf1c0bd99a0d86bf6f5a8781a358bdbb5269e77c80090fecb5d1d98def1ecdea1706d5f8302ff6fdc31977d50dc7fd5c438078bbe79f397b9a19050abb004a8a0e389ab199916630456ef128c554a7242c8c72726270a9c2ddc1c8623437ee0955d8e4d2c600046d56bb5be6e21bc526bb0793fdf1742d7ef57a1a7e78c6508a257aa794b254c6d3fcfb8615cbc840af9388443071249c120c176af32d0d224d4e9714d0ff67d4d474aa2cc54ba2133407092eac1ef41619c53e301ed82fa7edadbe6dc134ebce43be66b1a75ad70aecfa9613ca1fb1b313717718a697af6ed57e48c404165f888b14b21e024e49d57c249e79e28cc5dd015516760e9034f331ca82522626d9e87c949195cca960c68f8b099b78f31906177445728e09f23608b858dffa3fff30c1d25c6e6bc690fbfae0ea38c6121b213ceb5aa85daec4bdf61b001b3616c06e84132d4252cedffa6507202c51b49976400b75527ac28e34890d5b756e24754a2a768edc6793f89415908846c629c4c04504622f8f16c67496b4cc52df5c744bfea3c6da79c2ef6f1bb841c6b1e82851561815efa8cd6f783332bfefe5796ca11acf0957c50e17eb916f4cc7b56f08b66f9daa38e2941ba6e3d9738eb1e92115adeefa9182165524bb85b0aae670d8925e04acdf888ae4c45e7b3938606b503b049af9b959c99e67f10871eb71aee325402d177abf043391a9c49f5bc24e2fb1680899e250915d71e05adaf833c0126ffc0e3ea4423ef3d7232e422fd0e8bd149bce79344e0c05542cc4699a439cb6bff019fba880bb98d4c2790f3f398d446ce66813f8a91979ff8882e98a52e3b60c5e63c6930949dea5ee7ea6ef9762f75dd61d2b5b78dfc87016e46afb89c3c16875ae3084536b4b7b673732f7d7ae50b6f0fb2168d4f9cdc096e0ae2b9c8f4175b27a5441f16c1f6c54d83b10e3d1bab0425b7922e610fdfce0f1eb788d151d3b42514ca3a4cbff3d5c94b0f2790ec0fbd8023c9cdeafadd3d3dbcdfcc2c4541e5145d998d70993af1e913aa4f7c1204cee5d6a845a5f3fb8bc10ea356a42c856ce5124a1ce6b59b180ebc6124f2910c7a9af313ec2daf1bbb31eaa6c74b9e52c7aebe6134e159337209a9c5ccf76a23f0622718f4dade203d56283b78ccaaea4e1fac766e6935ef7976a094ec90441c2298df6eae93bef3a3b8950336ead13db2eb5af211983bd4e4c5e17c4351ef8277706a66d8d424fe56f71092d6ca586dcd226256fbfb704677bb868806f7f5020236095f0afc316b5e3e9705ffb8a2faa490176956218e236f8ccd0ff3274a0111b3f969af3ffba3be5d281ddc1c11ad80cb8e9d8bb84d8bb91070f4e892aa41cb39ccce68de2ceee614cec88057b6c1e545cbc98e0554d5cb9199340b2068692a1fd4b33ae3f3622931ccf27320b96d103388f9f3fa2562cd40e80e32255aac9fb56976d96075f485ba84d8e2b600b13f3820fff88c985d5243d9f5122878fe2f563383527984c125a7bb9067f44feefed122e12f326c6f428d159b356a4b4d97d52a0e93299b8782ff37aa09e84710ceba38220b25f6e8ad3244faf23253f37abf9be4545337b2df59dc6a4c3989efc514b1524499a24e14d2270669799d17ec4d80928b4994fa78e9d33f400cb3cc6f65ccc98e9cd3b1ca64d534f4622030a9e12f5fe3d40f30b81eced50f90a2091f915d12aab00b01c400207df9fe430c877413ac76bf70e3b13d850e9744b8d6faa9fde5cb592549635e2c3cdafb2ee520498a84f1e70d7d66910a0683089e92a4cb64827aa01d922ebfe5cc88dffae898c3100ce4472de9c9eec0f350549c42f9fd77385be9112890807c18c947a6540cf6e4541b6c834e425172ca6d4d99ebe01338085b4f946e36404809d49b96702a6d705dca6c408b4723525af149a6ebe1c6187742ff87f9c90e9bb7d771926a88c0ea352b4273abc24f1cd34128ca0c7a2f665ffea536750606836475f5f3e314662e768b8fe64ef09cb09545727f1b8e764e547a864406644f8f394e113ba1a97672df73b84e465ce2f245d2b1c182e506d804adcdb0105d5dde3b61ac63054fea5a56abecf16bda7eee660777a2378d30cd9300e8bd7e4a7181171fcf4c75ded3265fbeadb905c2492a1cfa240e4eb3192b915e606eaf2aa62ca968322eb7464548508fda561facc83bda2a85ad09405d1b32ba0e464d017c8ba6ec9a4dcf3b0d1324f405217f31325ec5f2e40899f8d392036ea7b0c09f1efb5a6cf1646672c7dc57cb154db3cd0930b8d881f30e7331c00982500f3547f683e7a0be49c4e4059fa7cb3bb83d2c1c919d57f2cb72414379f20e9b19d8d9ec0bd978700ae5ff524eb6503ee2095d851f99f93fc63121a11d2a18d8fe99c77ddfccd69132e069eb635a8a6ab3004bec798765fa24bb8028da2a60dcb49cd56bd5af4637b4c92e67d64cde0874372c6d859de7dccd78bb28a268641f737b816267cd1885f10820fc7227d93ea589f31a6490b6d5c713a63c7fa4781d21f94ff5ed7ddc90bfc36b1f1af0a7f6e4ac4f6ce1434d75d1ac6cb392df3eb2c9523d58c065fa7b8e9ec4f19b9f18d904bbb92bbfd0a330cb8e5a653fefe4890ba9198353ef3aeea3c2a1588458b481b1c2a8939cbdbbdc3124716f2cf5bb8d8c39b048a39a3d3d97d775367dc40ed742cda59cd784cab435ef1d118582b60a47c4be15a4d2be95e068d8672bb5aa518cc9ad14df195130ae3608bc740d7632531ad41f1df2d69cf116fff1199a21432713ff58cdda51b92bba03ac833c7573adbe4dd89e6d477a86bf7ce9888494618ad7b15f7fe627f1cabb93745cefd341f7a6338ed7063ec0e5e045206cd9b52f823280dc0f15a1de6c8c93457a79991629bb7325ca51ecb4a0851398c36ad14488a3d3e40e54bac1ee5ad0d9230f5207da3ac66835b9789678b2f6a490b59233b2740e525a2e00fe1e59c23c46ffb250c8e04b8d8d70b6b830b6535009f5f8692ccea06b153df2e394ab5293e6a97d6a6d30e8d4f38c03a162b93f06400b4eb0f732b7e63dc1dd784316c55f7e24a2da4e20f38526824ac04055d898541a38d129a98b6e6c97be129f095fd83d6371353cee7ef86988238ed335ca3f8e2a5f0f5099180aae966ecc92757efdb3b126580cf804828f930526977840563310680ce71244e0eaf83327bdd83d90094cea372c95858c38661d0db157a295e6285d1ef4140c24d8b9a61104233da36e00c14e56eabe0d1016e8379a5010d18aa13c9a0d9a7120e2646b1dbdd884fe2bfbad38102b9373ed2fe26eb48227ef870d1f174294e5bc44083f2421fddec53c08326807e6648f90a284c094cf877644a2672022ae9fd1dab4188e2d60fac52e0c36556d96837d55473edf787ed9cc6434562b2399e8130d9b1e05575b8235dac2d96e90f7646916442af11d3591284904e22009f0e2c31371de4b29749c7a91f6e42435a154b9df3842f999104e8908404e7a76b3ff12fb7893ab52655e0a599ecc9aec11b848aa508a2c20f9171f9a6e7d15e2008ad28b79bb0f51f333f259a758d95b01757c9ad4da97811d06cb6a4afe1047f1d896f48885e651cbfcb4f211b2c19cbe2550efd83ede4ad9364d78441281b68447646f14a30fde5148ad1d35a8173ef405789ce7fdd0fc710200cf2f81a08019702b34571c865cbeca45d60de3f5bb12e4256b2f20b7bea7d2dc7ad13a1711bd6137af16041270ceb4cce26c1ebddefb90fab11eeb2d868bcce7125294b2a4efc73e72a599d9c949f933a6f07840c19d8fd8a0c17bc8c11841ee6da65da45320ff59b6c9bdd842d2ddcc5446b5b0956dce9300b9ea8e3d535dbf3761225cc00a72be9000ac666272218fd63b86c0eb5512d4167634c333d2c6c8649ad3d04051144b42bdf848e28b3919d51e152815ce26e818850bf463c50b7e83e827bef5b90852f41c4602bf486975b619b8acb6b81514b5b3cb082fa4b87e19b68d5a83f45e0a19386eccff9a7ce5f475cd88cedf553b193cc8d30cddf7e52104f8c00cbaf44decd7324d053d66d2bd0d45fd4e7cf90160183c77fcf1a0da2174744790302033615506f9b2e91a84cfeb8d3c82f78b29d9aafd56a9a7855b89625088de29fb3780da765f1b283bf141b70cdecd90a4aeb4f3d4f4800d323142a1f56f1f75e639d6138fc610a778d51400aa29b56309470e04e4af4d3e7643a335a7016917a26ec4f7e0328321d98729ad713de04db0868c41fd37a503f2f72403669ec5f630025e6ad44f93ffcc39816ad843e16cd4e5a3cb2cb74796ded2435ea4fc2d66491f3feff763d3ccdd6ff92ab6f4ce7ccb1e04b51c671292c615f8b081ac67337721f01ff99249669be6b53b31386d363af1c615e4ef877e51753189622de1a4e49a895b34fade6f2d114d6d4b3fb47af8e69738060bdc1ba76be0756f6a561e6d866b4f03fff85326534c168c2f7d5fa80a14a8a0b19a8944fb26631f1f1eb314dfc596b1fe781c0ebaa20a66eb78d390c81e95299ab49a4f7ba14e3937547cba9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
