<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="zh-cn"><head><meta charset="UTF-8"><meta name="copyright" content="(C) 版权 2024"><meta name="generator" content="DITA-OT"><meta name="description" content=""><title>C++回调函数Callback</title><link rel="stylesheet" type="text/css" href="../../commonltr.css">
<link rel="stylesheet" type="text/css" href="../../common-extended.css"></head><body id="C回调函数Callback-8244A76F"><main role="main"><article role="article" aria-labelledby="ariaid-title1">
<h1 class="title topictitle1" id="ariaid-title1">C++回调函数Callback</h1>


<div class="body conbody"><p class="shortdesc"></p>
<p class="p"></p>
<section class="section"></section>
<section class="section"><p class="p">一、函数指针</p><p class="p">&nbsp;</p><p class="p">回调机制在 C 语言中是通过函数指针来实现的，通过将回调函数的地址传给被调函数从而实现回调（注意分清回调函数和被调函数的概念，以便于在下文论述中理解）。因此，要实现回调，必须首先定义函数指针，请看下面的例子：</p><p class="p">&nbsp;</p><p class="p">void Func (char *s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// 函数原型</p><p class="p">void (*pFunc) (char *);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// 函数指针</p><p class="p">&nbsp;</p><p class="p">可以看出，函数的定义和函数指针的定义非常类似。一般情况下，为了简化函数指针类型的变量定义，提高程序的可读性，我们需要把函数指针类型自定义一下。</p><p class="p">&nbsp;</p><p class="p">typedef void(*pcb) (char *);</p><p class="p">&nbsp;</p><p class="p">回调函数也可以像普通函数一样被程序调用，<strong class="ph b">但是只有它被当作参数传递给被调函数时才能称作回调函数。</strong></p><p class="p">被调函数：</p><p class="p">&nbsp;</p><p class="p">void
GetCallBack (pcb callback)</p><p class="p">{</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/*do something*/</p><p class="p">}</p><p class="p">&nbsp;</p><p class="p">用户在调用上面的函数时，需要自己实现一个pcb
类型的回调函数：</p><p class="p">&nbsp;</p><p class="p">void fCallback (char *s)</p><p class="p">{</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* do something */</p><p class="p">}</p><p class="p">&nbsp;</p><p class="p">然后，就可以直接把fCallback 当作一个参数传递给GetCallBack。</p><p class="p">&nbsp;</p><p class="p">GetCallBack(fCallback);</p><p class="p">&nbsp;</p><p class="p">二、什么是回调函数</p><p class="p">&nbsp;</p><p class="p">总结上述示例，回调函数就是一个通过函数指针调用的函数。如果你把函数指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。</p><p class="p">回调函数是继续自C 语言的，因而，在C++中，应只在与C 代码建立接口，或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在C++中应使用虚拟方法或函数符（functor），而不是回调函数。</p><p class="p">&nbsp;</p><p class="p">三、标准调用约定</p><p class="p">&nbsp;</p><p class="p">到目前为止，我们只讨论了函数指针及回调而没有去注意
ANSI C/C++ 的编译器规范。许多编译器有几种调用约定。</p><p class="p">&nbsp;</p><p class="p">Visual C/C++ 的编译器支持如下的函数调用约定：</p><table class="table"><caption></caption><colgroup><col><col><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">关键字</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">清理堆栈</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">参数入栈顺序</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">__cdecl</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">调用函数</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">由右至左</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">__stdcall</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">被调用函数</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">由右至左</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">__fastcall</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">被调用函数</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">由右至左</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">thiscall
（非关键字）</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">被调用函数</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">由右至左</p></td>
</tr>
</tbody></table><p class="p">&nbsp;</p><p class="p">任何支持开发基于 Win32 的程序都必须支持 __stdcall 扩展或其等价物。以__stdcall
标识的函数使用了标准调用约定，为什么叫标准约定呢，因为所有的Win32 API（除了个别接受可变参数的除外）都使用它，这也是Pascal
的标准约定。与之相对应的是C/C++调用约定，为强制函数使用C/C++调用约定，可使用__cdecl，另外，可变参数函数也使用C/C++调用约定。</p><p class="p">Windows 操作系统采用了标准调用约定（Pascal 约定），因为其可减小代码的体积。如果不喜欢__stdcall，还可以使用CALLBACK
宏，它定义在windef.h 中：</p><p class="p">&nbsp;</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#define CALLBACK __stdcallor</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#define CALLBACK PASCAL &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// 而PASCAL 在此被#defined 成__stdcall</p><p class="p">&nbsp;</p><p class="p">四、简单示例</p><p class="p">&nbsp;</p><p class="p">int __stdcall CompareInts(const byte* velem1, const
byte* velem2)</p><p class="p">{</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
elem1 = *(int*)velem1;</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int elem2 = *(int*)velem2;</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if(elem1 &lt; elem2)</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return -1;</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(elem1 &gt; elem2)</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return 1;</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</p><p class="p">}</p><p class="p">&nbsp;</p><p class="p">int __stdcall CompareStrings(const byte*
velem1, const byte* velem2)</p><p class="p">{</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const char* elem1 = (char*)velem1;</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const char* elem2 = (char*)velem2;</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return strcmp(elem1, elem2);</p><p class="p">}</p><p class="p">&nbsp;</p><p class="p">int main(int
argc, char* argv[])</p><p class="p">{</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int i;</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int array[] = {5432,
4321, 3210, 2109, 1098};</p><p class="p">&nbsp;</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; "Before sorting ints with Bubblesort\n";</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for(i=0; i &lt; 5; i++)</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; array[i] &lt;&lt; '\n';</p><p class="p">&nbsp;</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Bubblesort((byte*)array, 5, sizeof(array[0]), &amp;CompareInts);</p><p class="p">&nbsp;</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;
"After the sorting\n";</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for(i=0; i &lt; 5; i++)</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; array[i] &lt;&lt; '\n';</p><p class="p">&nbsp;</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const char str[5][10] = {"estella","danielle","crissy","bo","angie"};</p><p class="p">&nbsp;</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;
"Before sorting strings with Quicksort\n";</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for(i=0; i &lt; 5; i++)</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; str[i] &lt;&lt; '\n';</p><p class="p">&nbsp;</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Quicksort((byte*)str, 5, 10, &amp;CompareStrings);</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; "After the sorting\n";</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for(i=0; i &lt; 5; i++)</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; str[i] &lt;&lt; '\n';</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return 0;</p><p class="p">}</p><p class="p">&nbsp;</p><p class="p">五、回调函数的C++封装</p><p class="p">&nbsp;</p><p class="p">使用到C++编写代码，一般会把回调函数写成类中的一个方法，但先来看看以下的代码：</p><p class="p">&nbsp;</p><p class="p">class
CCallbackTester</p><p class="p">{</p><p class="p">public:</p><p class="p">int CALLBACK CompareInts(const
byte* velem1, const byte* velem2);</p><p class="p">};</p><p class="p">Bubblesort((byte*)array,
5, sizeof(array[0]), &amp;CCallbackTester::CompareInts);</p><p class="p">&nbsp;</p><p class="p">如果使用微软的编译器，将会得到下面这个编译错误：</p><p class="p">error C2664: 'Bubblesort' : cannot
convert parameter 4 from 'int (__stdcall</p><p class="p">CCallbackTester::*)(const
unsigned char *,const unsigned char *)' to 'int (__stdcall *)(const</p><p class="p">unsigned char *,const unsigned char *)' There is no context in
which this conversion is possible</p><p class="p">这是因为非静态成员函数有一个额外的参数：this 指针，这将迫使你在成员函数前面加上static
关键字。</p><p class="p">&nbsp;</p><p class="p">class CCallbackTester</p><p class="p">{</p><p class="p">public:</p><p class="p">static int CALLBACK CompareInts(const byte* velem1, const byte*
velem2);</p><p class="p">};</p><p class="p">&nbsp;</p><p class="p">静态成员函数虽然很好的解决了this 指针的问题，但是由于静态成员函数只可以调用静态成员函数，这样似乎失去了
C++ 类的大部分优点。那么怎样在静态成员函数中使用类的非静态成员呢？<strong class="ph b">可以给静态成员函数传入参数，而且一般设计较好的回调函数都提供一个数据块指针作为传入参数，这时候可以采用如下的结构来解决此问题。</strong></p><p class="p">&nbsp;</p><p class="p">class CCallbackTester</p><p class="p">{</p><p class="p">public:</p><p class="p">static int CALLBACK CompareInts(void * pData, const byte* velem1,
const byte* velem2)</p><p class="p">{</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
CCallbackTester * pThisObject = (CCallbackTester * ) pData;</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pThisObject -&gt; CompareInts2(velem1,
velem2);</p><p class="p">}</p><p class="p">&nbsp;</p><p class="p">void CompareInts2 (const byte*
velem1, const byte* velem2)</p><p class="p">{</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// do something</p><p class="p">}</p><p class="p">};</p></section>
<section class="section"><h2 class="title sectiontitle">参见</h2><ol class="ol">
<li class="li"><p class="p"><a class="xref" href="https://www.codeproject.com/Articles/6136/Type-safe-Callbacks-in-C" target="_blank" rel="external noopener">Type-safe Callbacks in C++ - CodeProject</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://www.cnblogs.com/zhangjing0502/archive/2012/06/19/2555288.html" target="_blank" rel="external noopener">回调函数</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://blog.csdn.net/youmengying/article/details/4449827" target="_blank" rel="external noopener">用VC创建新线程易出的问题error C2664: 'CreateThread' : cannot
convert parameter 3 from 'unsigned long (void *)' to 'unsigned long
(__stdcall</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://www.iteye.com/blog/1419619" target="_blank" rel="external noopener">如何实现类的成员函数创建线程- wangminshe89 - ITeye博客</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://www.codeproject.com/Articles/6731/Using-class-methods-as-callbacks" target="_blank" rel="external noopener">Using class methods as callbacks - CodeProject</a></p></li>
</ol></section>
</div>
<nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>父主题：</strong> <a class="link" href="CPP%E5%BC%80%E5%8F%91.html">C++开发</a></div></div></nav></article></main></body></html>