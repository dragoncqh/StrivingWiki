<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc8599a00c8c043cdf66d32ff3cebb748cb14652f611b10fd091d3ebcf0ec997d47fc3141a4357d595459e44801ff45a030af712a8e7c97ee15fa8d37b2242dacdad4be97565f4fcacb0240d2789810c062dbad71390e91201b327bce53f213c0c73088d63b06d4ad97f9abeecbea62073a4216f841bf8349d9905c4e1492e9f341d5e8985f5e0a1b07bc7f702fd0b77a8cc77336fbb02ae53ef31c3618d3bd258a1c4d1d8538603ec97fc36244acf0c624b1dd737dce7b6fdc3d4a5bba7eb52a50ba1c29ced0bc39193f8e6783b6be5e85769aca90be5ae372b181a761d165e212b5455ce268c8aa7576ef8f210830ace615ca987dd0747f73e5ae00f47f3796dbcc41d20f23ac9caf7acd07d497371cfc3cf5e9aa9b29cb09545898fb8d536ed9c12505d9698708e12c15b4cf5867c03319dd9cea0b842c7afecf8140a03b0d770e874d12b8e0b092f7358da91d374ec664f306bff84d30969f6a43e7bcc5ad4e241c16f33da8af125f59d75d1bcf65dd9d42a661480c71c99a20731f914ff3a90fc8e079c545639ce46b560da43f0ce7bca2e7fcaec9a8414768f43053f0df436f47ebf930003dda082136ac9667ce7526957a84d7252f85bfcb56886af6247a37e06ab9eeab6b1497ef04e944764abade173daccee90bb1ebf86006c23018a6c835439245878f2030df23f616dd655e8f705de4d91187d00bec1133a066bc6cb437e2d704eef5dc1443725749832f31b48a9a58570a7daadb56ec6fc75fd15042464fdf25d6a4e80f9c36930219b0903c180612e259cb1f51674561f47cbb263ab2be00a211702c7b6396a7536e8cf7968c6a858e24cfd7e5fb002d67b6e827d525bc416012e57df359b11149ae93d13a1fabf5d06d36f3bb2dc6ffbcdd0eec7285b03953c311f2f08854e7ebc569cd00d7c56ae2072ca19d05ba82b2f979bfca7697192efb6dcd30768420a2b6b105b00e478c34d24081fb8f50417575e1d481d35fa1bd14ddb7a6abc738890ba3b32e26c1402bb2ede81bcc91650c62b6bc7442b12bd97aa5206e4fd7b4e147fc750c2b7c29b02f9eef563eecea63dcf32b249a6177768928518a0a8440d0eb80a92fa3d156e92ad1cbf6efaeeca6a2aa4f75e6aa065117c837289b9cc07216337f4422c7bf391e1d676d61e026af6c2b17dae1004b2a006013d0f6b309dc5d2171770041cd2104b5305989e9bbfd30fa95a0570caa1585f2e042c2ad11138024f75c57020380e86572404186021ac8e056bb00822c55b03925880b89d3d3159444e19bf1f8c21e46381f99499e02f499b1196a3f9d8d64ce5858ca3fdc8be4e85a4f35a108ffd955ccfdb8e98ded1f0daea0d9c66a8a558f66ba991ebf3a8170462a7a118348fea85e53fbbe30d7176784a30e460141bfe109079e9d63f61eb7033e67387e062a91f30f709e41ae671a907808abf2b6c937366db26fc76445e622fba7ce6f37165fa8107947a0638c9ebfc6e925e8dc8bef9b13e7559fdebbf3d764cbdef348f3066a452394f62e0473473e6fd80d1d5df494beb0d229ab7b7b302867632c983126e0186842b86f353958544f2614aeb552b3cb5ebf399448f0a89867e0ec6c9e8abcda3f0e6a7356bcb8fcc95d368817096e912f4161ceef2b4004bfea267e1fe05ef04ec94b1a652ba7feb62bd681ce077ec2359fa93f72c35bb10c94aad2a8e2d9986239014a6428ff0fe4acec4018641b3fcf1a2485535d4cac51618d5a019173cc914767aa9e7c2a3a14f22ab9729dc21aa3f8ce56945925326b4f5e8da2afb6cec25c9e09302f8c99a04dd996c65f9328af8212d124af94a71fe4d14be05acb316dc695b8556047d03bde8615342af36c114c1ea2fa6b5aa7c76ed5c1b4501a549a0ab7fb48620a0466a2ad2193df6be0a29ed7c86f13c647a1d865a36368bfca267b8285b384a48152ee93cfff2fbd8ee35b387116641e169cbdeb4b6335ad53d7aaa62294359f920445ce97680c50aa825e7a69763e0b65b02ad71c1cd1f6cba951a97b5b9f2853fdef6796b2661189c6044ec0a7cf6f8366392791de636c446ae9b02a3a4a91c96fa3d3177a9951df3239ff8e84ee211fd88041d570a137e1158304075ea2f66b979503bffb2ef5d3796a5709fa933899b85dd56683b9da27416faa11a5aaadcf2e2e8f8ac817555453d63d07503404e8d5e9e857aefd09abe3123d3b8d851cc33b078d4ae31179e790bed5704170432e34e8aa9883bf78a0823fc7a285990e2fc4ec6cfe6c1e3c68c74a70a09e1653dccc90777fa2e7ab5795fdd0b33239b5a9a2b139ae7f1647078cd4a5f0a81b57d7cb9690c6b5ccdf98b5130536b193073739c6ec02084f7baf3479f0f247116af52344adacd2e4021049e62cf917af6d332616fabc454d3e8f448198f7fecafcff77d1802f62833c619c360eb0c3cbf8def07f798397c358217d52d1c4bd54d44c08892a9448f256a9cb6e59ae12018764d1c5a163b8ae7f16b6a343e7f7d9298322ed5e19704ecbf4418cfb9d15f37d46e60f8734513bc7e62129084a07d6c4c9bee38854f4e1c7008e49efc51af2ea3795e2c6a3708ebbc21e993ca0f82428b09e9b07a0b128a02d7bc7ebe3bd5194901b33b4fda923b715e5cadfeb9f2e8175feb7f55f53046e68d9fe9c486dc5c2228062fced485f6cc1a353932ab05a2c7b5bc32f50b611d7f4be083e84198e9df4085b18cbf88bd3c31a7b9cca11edf901c18229919ad7b5c65345a1e0da67045755b3797e51c2e902c2680fe8ec1d1e9474f718d4d5a2a62412f6d677b310622c26b9506ad6f51ce324793fdbb9b842c23f963e729125fe486e37d7db2d1be84dc561c5f27ff3bd8be46b88dbefa3bfc19116c53508fb48f7410f839d807e011f6810c249134664b44ef3b8bfb975dca279df6089f56c570264c875984b321e17111c9a1e58210ecae759656895af4e4be941a20b1eda1acea585fec2b76a9c661407a198cfb3fe54ea80f359cf326a7a1bdb95518ce5b9f36543a5612a3e5825de914cb3eda99eb771d776e73fc23cee6d6a5ddcdda220dfa03d3ff93b513820955de21c8f04e9b3984fd23d61cab440998477d2189c3077cb45e31deca4ce7e61928b0b61f12cddf0a04f9c207a8f3f85ad8f13bdf4a631c5b994e76a23b452bcd380d85bd5d6f1d02346bee3c34f6407edc7085d9166cdc0cff783abea31c0c57414a868d99953ccfdebd3a36e1ec185cb5b5aeca3e8898da8bf600666632a0d854574c3f0386b5a749f2f5c693bc81ce63b5a89e39320122286afb7d0a62855f22c8716223141f5b15838515b0079ab683978ced81697d9afeddcc9d4c776d3c48b7b7b434ed411fb6c8d5e385f655373234222d86cb68186e669aa7330d49e1b64b63748d8f19f74dec4ac330975765727021403b021a2ccf9f9ad57819b01c795928596a2fe453020b957387e77c69d217be9409ef57aea0ad66db1f30a73e2c82b9aeca9affcfb854c147fa77de802d912d1bf1a4abd7715bf3639b8432c06dc0d5551ab24d0e2ffe1a2b71c4c40189c72b0e7f8e1aeefe8c6fde58f7a728e2d27006aa9129dafaaf0157b3b57a59dd8887c7f404e9890c42e7ed4dd04218d5b88762a0e02cb5119db4ee8bafc671ee3824e77ab5a64519ad5fdade70e382bf69af8a16202e16415035a525e38c58771c1c8ce9c7e8c03797cb572765aee6403694de280aef30bc35db1ddc210e59150ce4c1a2cbc74ed6a4121acdb9a09900458a488ac4ecb07a156372caa1bdbc8e7f717377f10b37a47c29a07d9702af9938e4829b3227577b627a8822948e46498afb7bf85b96e74b72e3de0ca371879c154c456aff60f827f1373ca7be7422391348d6772a6573321d444531df70833d01720454f3707f5e0e47c671ecbc6c85e4da572f7c6cfae2bb67c45524289735342c98617afca28b98be97e60049f4de77f0f311e9f4f62d4f6b946b95001e72868224d846f95a4b9337265e467385d785f735f29d367dbf880a5056b5fc50ce8c5f80b80e4a697f8b86892bcf0731f2422ab53c2e0ecd10bb1cb2b4afa8e45fac9ae692ca861f8a291a68b5a5c150984d7125d0bde79cbb192be4a3848939a223f59b07d1755b9a064b04cbe96d0bbee313a4256c5c4bffded258816636af5e1207aeca8e17f0623d8722e0940db06ac20b1ab43407bcd2ae367cc727c9cf487658da807270d8e7fa6bbe63a0f7b26b2e5fc28a860f39ea64383131fbea4abe2ba2f8bc33585c9532eeb959bf81f3466393a54e30ad5da50dab8eb991b5d04ad5f7c6bbf589a4033e5f9d77e1f7589ace25597f29fbe853a5f8d7e6fd2cced5c36f314b68adc7b37866ab658cee95d0cbde9cf48163b5bb3bc2e9b6ba6510ff12d11e80e80d54ced796938f3f79217b92add7030a2dd136c53171a12d377435162680c109116632b484e54b4abf5c59fbdb9aa79910183ab262019f550e65bfc0870af7019b21bef6c51350281f0f710967b763eb22daf4f4c4b4fadfc5a02b1b6702c64997e5595898092f13689bd13362f5f93991eba3eb05f6fe14969ca6ea4f410d72ddb27abc05b460f6d7c86ed5ec0986f2e1f9c0640b51e5d974dc5a5eb2a830b7803c53abac5d6658a6603958684cc257e7099aa4b4acc221dcbe009b5e7d0249af534a3280835f7864c63db1f77973b662b5aa63614ecc619a89cd1bf4f5728a36970b410bdb8de8852306a442550adb26ae65c8d8483dd240c346b3d0cd816633c72b2ce3ab256694f906b41be332d81f5b3e0e0bece8f7db75bbf4089a580522b0dd464cafc12717514c8a89b3e40de814f0dec9c9fea68258c92a29cacba85e3ac363890811c3c64ea9dd30d6e499a78de441c54445f6897c989433886243075b2754314e0f58269519ad80af5f89595e9f83550ac2ae07c601a7f072102aead2ccb007acb67e2d5450e4eb868ee41b94284c27efc33843cbe64497ecc727ce9d6d31cd1d90c58598ff07c2fbe66abe02a038e3caeb25810ab0d4091e30a86ed4208625509796d25f88154d5a6da2ba99f0c4212fb0c929a9a17987c4be28358e764401dcd30f80e2d84ca360f2497e83757e5032dd91e44c74654fa1672843ad8d97c0894fbcb23f0f49ba4da49042cf68fd127a2e457cfd2ad603094c41be7291b670f37d4536cd89f4e4def113edc7f315b6d19d67c3ab901ed55f25c98a765d328acf1d79860fb6fa3e30b7a676a3cd39bc6fd2ab90b2e66fbff7cd3fae37f9126f203a996200c590f3da9a65d41c3ff1e69b5cfa4c8cecc007024ae3acb467591a9c7f05b1788cae89133e5d8be4511f016777db47c2566b78cd79a3eb531c02e9c9007f40e95bb44957c893c9438110ea840ed89172f9005cb5c3c506268204f6b1d4e1735700c035a9a5ae608b4ea5d5657cd6592468868a4db6492e699626905ac7addd3e95b5437f96041b53a62eacd7099033003e3fa34ed18b137ba4cb21b9ff565f4f07b654e46f94442a474f0ea9611f8dbffa9b42c164e05bfd6db4d4664655e73495db507e714be24e0e7f6c71dc7717129b50b7dea6f3226fa7847873d58b47618dd73b484a7537eb99f107832e0763df413b1203c47dfd2cea3419cd955af17a2b25fbe9fa7b6c97f895019a051f83312d9f62097ed53c920b7bad77f67c4b110484f6ec0874c5b52033177c7d36ecb7b4cfb9b08059cae5b31379f526240b8be63ec7562ac22ebf3a097189fb8c1dc7b2b0b58ae2dee41222ab3fd4839b794ca5df9519cfdf15019518a17c36d98a8cffc315d19527a80f5e111fe16858435bec5f614bbece589cc0331754e7b651672e1e87c3333bd8a3783e2e6c0e74569048856e66097c26bc87cf06c796b4aea42ecaa6cfb0bc291fafcd52efb0c366d6d72d53575e3964ff0400c9f7042d241237d58df1063c4259d7bcf7ee56a91e2c2024a0b33bd7748772890d008841e4ccf14962cdbb2cad9028493811be1dddbc3179a42f8ed2005266cc077d4c4314347cc1afbf3dbd07cea0027778d8847241db68c4ab5b4efd0f12616d901ed36ef33a64d25bf6c26e3b4534c64f52868f7f00b5cb12c920b752c2b0574e6e1b07739847064472ac6e8a1d85d8c135cfb1214087c4b441cf3d8186dd6a0ee7194d6269689cc22efd89ee1f4cb7363234f88f9fafc3652272cf7e3b5c4272426dacc363f58d89b91c6663fde74afd726bdc458e62ea9d9b1d943bb90cb995b1aa23e5c189b4b04c6e37a8d451f073cbff8a08c03c2071708f6880c238f65ff419ef1cefb0aed1e7e5bb82b9dd2ed08177337a95a2ef6d55cf9d6d54ebc3e0080b77fe16c53406fc4004be47b97be4f7a631d4bbb48876390d1e9844d43882f92c0bc086fc2031e91095abf785c439cc2690012bd9a92fbe4a8e4a75dd2b387cb92ddee3b3b322c1d2dbed1c9f22fff5016f807547dbab8d3509d2dc647eafcd1047a21edcafb5944d437f8cd7b9511c1b7ef64225fbf0672bbae372e416e2f1e5d34585efbe55dce029be10e77dc7b4d166771bf7ea356b77e7780a4416c9ad0d95aef9f5f7671001f5a968db96dbb745737522608dca271bca7cf7d43ecc212b3d56cc61e125ef504cb94233d1448ae33afebecbcf04f321d5d689a06b658cb8a4366b8f4693f57899f8f30376d4e8a48632376a2ca74d945bdeccdd49c3ae5ac44938064d31e53d9ff5d0874c92aa36274a528bf8d79fdd5492db9ecc963bdadabd627e545b4d0537b6a185ed8f071759f92a3bbe9cf6ac31aecab3c87d2584c82cf2a34f68479ecae4b7d2679acdd2d4a32e6abcede62e40781b6c1a46af6ef7ceaf3ab49cb2b0ed37ec2123935dba04f4ae75a54a3696a9e99a7808eab131251ef15010002fc4b555a44d3ea4c2347282afcc9cd63527f21be8b2fb416ae4323454ec89a02b935ad64f6abd3e833df8f6ee21df5b955915bd9e86a28a963ff7a78ffb07852c1e56a7779d4ab827ba58d5382a08712f48db8bf36d33d1e17dfed106b1eef30ce5041bc52e1adb0159872880fbcadc81b436cfc7ed37eb71d504f6385767edc0394020b048d300fedfd3b965f3cbe84d6a6295ebf73d4d9d14f61eca5cb742b6eb4463eb4f65665bf7d61806343b00f6e6927e5e8a627172e10472232dcbc129c7ea5073b0a09c2a57d7e42bd4a9b0e994f746c0d4794e61775c173cbd305f93dd39b87e763b6267531c0970844848f3052df80a2d9ade256708024528d24e9be34204dae513e609677fbc2a5e7d67ab00e53096eb2bfc5f732f6e7e0dec61bd33fe69ee325d22bae6d9a92d2831a55ea8a6669653da0bc84e0e3d6d4ac4a9a7a692dde252bb371c45cd60f6edca0497a212d3d1dcefa956c33a26f50cf0e2b1dfe28859f0f8a9283acc7d5538b89c34ddae4901ce5acdb9a5c7e5dff3202d4195d521c94a6d16e4a29d5dacbb4baa1d2c8004609f557beada861567bb83b7d06db794fafb71856e954cc012b2eee5e5d8a14ab8440169d602b541ec38665ddf76d1fc4e90be78516a1d810d8837662c4c7f693e9c217bcd737ce8dc3e73037719546a682b0f4a0d9e6c052fc2065c71168e92a2fc388ff05a6a4d7757579e83cc9db65d8d377634f6887e96f97d38cf0bf8b1bdaedb814331eebc02d1dad65abea5e0564428e8d4973fbc1986ac66e71781071f974b84eb4703da8594c325f00f2e03934634610aee1af32809be1963c753c033b8280a5224f88536205d56c19b190ba010c78142943c930834ce2fc1388b59120faa6c43346d38a30fd4638474e67d6f8db419e8e0be7b0f85b463785e17361e3c7ac911b2e8626ebfa8ca65f0d07f04432fcfeae1a2edd5a29f6a48e7c6555cb1d7524f6dfbdaef345d7ab335143a9bb18a5439c803358171643eb965bc622ef9092e9c955124acf5ddb01464aa6c79cacb7ffc9aec7d7074bb3ca23da446c92bed5055195c2280cefff5d498b9d086e68e80e838407b785dd396f6ffe55609ef677ec266bc14e87a9c40ddb8c2659b7bb720636724eeee155ba53e90a43f67e1f36ca9b275d1bb0ce57ea6df250dabbf0e7d21a83b94489d68da0083f93b84621a50e1b271c94535013909bf773fdd70ffb15d5a34661f9f616ad06e1b093a8385009b43ed8e30da8619bcb9ba004a13395df9e5c6d8094b9c55736b55178605c5d7b617e19ac90aabebcc63d3082a9374051312f22ac6ca7999256249c171376f88421866f01f0a9854bc9bd8625facd544192924b2e29b2aa95e052ca8790d80413c2b04258ddf48d1720f88d67511175562e90f0d6e883093980682934548f34e05207bc46ee40ee68196f9e6bdcc242b9806e7db97a45c65912f4cf2295554b7f7f02f77e989bbda792249210f1413a5227111b9d29bc616e832912b3fd808e9abe06cdf3182fd95bacb13355bf905a939b9e578315e945bd117f6beb0a64b73d7b7007a1226aea35df98efb90f8ecf4f657e556c3a86b772693769c559ebd9621c8027c1d4a977e2e6f63afe2bfec4eb771f56fd2fb379ebaa9c0b07239024ff5f4e50be25d06bd8159d0a6e56c0608cb46c8a4a3d93eaea8b88ac0e83909511abc7a002d8059ec312fb5fe4e834d365e29837b9ef733e83e6679b9cd4adeb1f0600cb8ecd44d93854bb6ac948607d320dbcc0799fd05f218d95dd2f341d9ce22620d03d3b3df7753b2552ca4b9d47e0f2cc34a8ca550587e29d410891d9dac6a5ef243e64c61372322dffceea28e434e70b2416d97d9d0a8759c301db3708bc6b71449a9d7ac4f23f99b8e2d4991bdf73419338d1543a57fc760c522653008c438b7e6a9f392592ae7f377da6cc6814e24e950ab3303d9c4003f5abaac5d856d8c4bd19d18c282f83eb58785be161622b7887ddd943acf50fd3c542ad2ed6d3fc77c402ff82eeecfc3c4017385208b1d98419c77266e2bd94eb77c6099049a19878f657a5e89f81c9883490dbe305efa481a15025f9bec20767f51ad605c3f65e399d553a1c7b6742c63a841f6860694af215998357fae983caf884d3ed8c0df72ba6d5fcbf2d3de2939ef0f3bf87c1cb3398bf6d31896ff42cdd897b0af416dc5eefec011b98fda65be60726bc522bf6b710a63b06624d87172461e4df341e4d178d989b7009d544fd60071193ffee12a2137ea5e34a1d965c670e4aef4d1c3d29e565e1c362e9fc16a10e5018d1b06644a8dd6f0364ac73d0d968048ed69147a86b0e9ffcf51631bb19dbe96b86861025a24d09b3a29fbc425b2febfb9cf983997f15fe9feec2a5ddda75254f5e68746a84ea2bd40f455d1b50066803f4fcf1464da3d414fe5a6d7768ff50203be8000c3a02cf0269451acba685267ed51fe538ae814b028c7e2ee64e6eada94667f2d870bb00d1c680bba3d0fff6ca5af28fc585e540fa30d619b66eaa646800bad30ba108bf4105d15cd102a529665b089b62d7c8fdfa12c9fc87b25bf7757212f2a0d6e3ec760cea6930b7d99fc8aafa9dc13fc25cacb2774d20383c5785183f05a8298e6508e43c42ee75f367591fd14fbc9f1b2b290f351c779714ee25c68dd91d0154b18795fad72bd9eb025ae3d7c6699c7f595f927b037bbd710e23f1f6626701a853384f733c2ca7f4e5a2b05dea7b5ada5249dfc15439555f87c04b364d51c5d905b24549bce9bc2d39109fd4026365ac47fda3072d5d7f027d3ad92afd1f95550d5220b76a3b0b8ca8f98286cfd6e2e06c980a00740b5ede1e6bb66e72c276e469edaf7b215945e7730998306bc60eeb4af627f36e212289644195999ce069901103cbbc01988cd7f29e9600b83cc6ff29320bbd3c54eb6fb620e6f23f2f3cfaf26ee1a9fac1fdc81318d8123a35a0871ff67729e89d6f6c6cc762b460673de2f13c15e0eb759b4a45bc619fe4579d04356517689e68cf98b4c5853dbe284af2e66851a9d373e421994d84ec1a4d995194b58642c302b4fc977f1e6e596f7a0b8127688563051314d7be850ee39cd972da7789ce08d5184adb6e68182cfd73cee538bf50abb6391cb65e15acec9738436ccb4a7f79a4345e7698871bfa594c05736cad00ad0466b3327c0aea9a257d80cc2a94fb7751f30fdbff238f9c3ab18c225dcaa5c1e263a65ec764d21508667754ab91739403f6529a92251b2ba60c9688e7c8d6a22f9e643ec7cc7f2219ace033dcb727bbfb8d6cb03ab06f1ca1cab73b435a1419fbbe36be2e5205abf23e28296c7a49b351b48dab374b577b27a8e7d7f7a31f40ba8affd406d6460534f9d24f4775ee7bb826a0777d36ce4eead3bc8a90ac0af35c5616e57aee1b6f997a074befc288a8aab5923e5879b1dffe04ac96d3fbd42719da89f6a61890141f8bb0afe44d099daad73a80221abb0cd63c2d50a8c474edec1da2f85a066094c9d22d040715529c9e7ef6c6cf2e92c5f8a0cfb17c50438937c88d771c0d057dc054a149bcf32dbce0455c631fc419cf67d7ba37ac3504eba9bbca721f2d521f9a7d4d0a8207bbd6275d99a53e31bc215e9c30aaec66a714814fb152528473d2a36d81d4b98641de3c13df830aeca7c12294265128b1c938390fdc7af50113750e3330de4843f057b55fb8503b037c4d1fd4721b0be0b4519771220d6c05af556c731a6269d3e5112a225d3c4906d8a6f8defd1de7cef3b98bddf8d8e49281bc8c2ba5ec8c8424dd454bd0cc5c8654c9faa2bd67f31a43b440aa5a6e5c09d0c0a6abb775d26354fc45684b9fda338d61b0129b8213d5d0b17d6cbfb9959bc0be2227ebaf54303dca6bb28f2d06da600a459646b3735c58c22a48724b09b7c304ce15ffc3e525d495ec91a31daa33318925a37679285b37e072b41d1d6d3f85559cdd3fbe87b180008d1364c4d301c2102e6a640ac6d2250abc75258e71b8112d555f4814845b50978d013efa6a59f622fd30c14fcacd14d6520a02ec4497cc6ba84a90035069d7a68aed2112a6b95e0376c1f0aada68b58886125604f12e8c0155af66e4f4ed2aa80f5d55ebfe85e8bec2618147630dee99c2031576ef9870adee2c6a406cbc85dcf838d9d077740db59034bab17d8e13d1d418a945a42aa86b6e9e5fbebde2ddc9457ddf0b15a3b952198d7fb7d85fdd0eb10725c86d6cdc1436110bf7e90aea2b8d02c9c10290ab86f66b789a7604948cc8357fdef4c4560edd91a71405b0784911b784b64b4bd3fa378fbbdd8679dd8ab9e4e58ede33a289cbeefd88a25462063ab4184ae8a210c2d848c2e58900a03a1018ab0f634770995fc5b824d7c53d7ca580186d569304c75096f030a52af2d70b4523de2f9eb3f6672c5cc0c4a0130d6cba6a656fd5daab394bee8baacbb42504243adb6aab7965e15a5a878b264317a63a4bb058c356b68542cebbe51e8c8cc7ceeb70a4bdd2c49e16eb4b3894187db03595bc433fa089b446b3f29857fdbd0dc5502c98541f97a75985aad7d7b2a0763aa3a078bbb553b79c260f1fd1ec8d52dd57c9e195e2413a1ecc5e520bb636258afa45d0423a70ed0b623c3d12265655817656a6baa4298ea0713b9bba6a7c0cf13a23e0db0a9fe083c18ccb3808275d62c4032ac061905b89f253e3b30baa9a269e8ed9ba35e9f11edc0d3b0979ae6337e80b1fb8ce992a7427a92805d9e95dc0992098e4fd1380cd6bfa739ac9307ff2591749e067786654fc948f441ede75d634abd03e0500ebc5f30259a1277d910777b426625c0b6898207f9777be37b5172f6afee5b96542cc3382684361dd3266866e1b2ed6eb88a8bcf12aa1298f9fd746741db260b43ce31890adc6b61e09e315a6fd36f950afa004217be907c5eb32fd8fff024e0d2f079550ef313a197a1f2326ed65957138829856a85b7b2079899973739d796ae5e0cd9825db9cb2b26f0ea87ff2759c8e7b8e66c95a23e9b2a40ad338b7aae6dbaa06da1290b78cd1e59a38de5ca921d02df6f3a0ea91a33b4254581b702019612820b0d3140e7a26bd27c7dbf4e95dfa6265f06cd906ecdbfc1b0609d3e9b1dd63b147fea38f91eb1eb87d2bab9e1393f0d2c1321b8b3bc947e2c1481d6ed2630821dd159c1243287cd3fedd215fd3b2c2c7f6a28c2fe04e8205c373ecd350879c151870d61ce3c421324a391db60d5b8e951e404d44c44ffdf1f5746688dcc5899f712fa6f88afb2ee6adde9c37f68a82779671ed93afd68d1505b4e1654ef93609820b985915e0442d455bdcbfd098a91c4955e7cbb516d89b2afae4e74f7b697f9c3b85bb276b9b271e541cf963f3242fbe55be78271261dd95cf2203691ade8aba6e45426da99a8839de95db1ef97e57cf979ea11a21e9176214eb33d64c53bf821e7298731cc94064a93729946e34fa5c70f858b63297fb75bde04c41f44ba25a4140a2e0ae60c9b1b40a3d1635296ccf2ad16a9d533d002a83a823c4e2966e1e51b6db012c763edef6e9da8e24dc5703ebe8e903c884850dc86336d6dbf7d2fb0ea4fb1327d9fd7448b61b3895d37e305d51434333b0b01dee6dca8d8ffe60dfa74fcfa92cf764a7bf3555e4d93e21553d4672649b710dad694013dd01cdc9061bde8957d1e501f8a6720e37ecbe90dd5665b30c442570ec20b0bb71d1deddbd03958c5316a0027790b2031ae6d3c4cd805f343fb9c52c6ef414ba0e96a2cbc39560a7d6300ebcf015a9ef9c61d4fce22d3a5af26192ddc281b3f6801c76a830a83f56ec4423210bd64906dfba52f4d6c2eba68ed3609891fd76f8fcf6855372cc3928155814586b0d58a304cc9f819dc1fd12b0ce6777129d9b8a1eb0342fd684014e035f07cc12900b6018da19121c68b253b7485d711d47076d9608061c6ff42a71f21875fb25b52ee6e7f68a07bf11b0f94321d9824a4129ff8a254cd1b1cf12ba8e1b1a0fc759cf46e4ca2c2aef9ed2514d2dfef8549d40ee86c0c07a1b4adfaf7502be4cee89210a36b8b24a755dc62d49f29fc2251de9a1dbcfa918a370df0c61d5e1f3b06f02b9e07549a264ed55de68134ffc9554fea792dde61bb4739df1c1e36a5b1f39ea0ab82d14bd65df9f970b7563ac1892a2214b8d5b0432e885ff1c3b499acb6a1c6afeeebb0c43072effc6b1a6a00d21c790e7c13e8e413a41a88a15d07668d18aa6c7611fd0552899698845dc6e64cee66deb36f0efc55f6559aae8c86b21587d88a1ab6a273294a451519aa42d37741c965c3c9daf974b59e61ef26fcc4aed07ebcc3079c06864de8ffec9f8a23537f4324c4e711255da313281d7474365589df0aa13c324e2e92fa8a2a0075e3344e04e2ed2b1044da47addc2fadd2f251b9b0c923a687005fd5f883b60f575f5c046482d7b0d05ca07d8317074a11632d02e60e5afbb1353bfb34fa5554f9f8ce72dc30d093486a793b0931cd4dd876dab72e187c30812a90330668858f6252fade477921742d4fb992c098d198267ffeec7131f426095951101c7a278c03239da40db8b0238fa638ab818cb947e0963f102cc7e0c8e9ca7e55243b6c82e6211f9c59f981f69946f029a892a8a6ef5ccb0bdca34e9291926f51edfc1122ad0d4c68b454804e8dc2a358c9b9d7ccf0aee4d2ea640a9b40214d2dd7897d981ed8a264cd61d5afd8213b05a35d08b69d07f661b31b6e64148e104d199015485fcf227650","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
