<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"deb021d9a019480a08d6c719a501798068463dc2f963b555c40640b13d30f50e615340b7c5146e12f01aeefa3fab8c8bd0ffaabe8ce8bf59e8ac58f0df06192c6b578c535255abde2561e309fd5aac041db8292d3524ffc03518937d0fa9d84c37bc20b42d4200138ca74a72adebadc4acb0eead9f5410fe3bb8c8a4053bf37032894473f08341b120e7c8f871ba38d6a85b91520fd2838b0a4af56f1ef9ad92629dcdcf20334147bc691aee274237647642eff032566693b5a16cad6148dcc904eba3a0324eccfed1c2c62a1f44827e42361d805575712067dcac953789d7d918a36d958d42f97c9c5a0d284ee6706a6cf1ef3195cb228eb5451c372f3794eab38e170c060da224fc13b81d92401b15fa29d3efbeda285c79954a9e2755fc4d4829c8d6cdd1a8e105bb4f5247ae0f23517356c54f1d4bcd8d31a826cca26ad768ae9a445c12aacbe11d329b3079ac22d3d1b17998764650d3a2bed4bd7de12dd58e32f35dbdf5f9c72604787e228e4339b1abd4e9c1dacbb86b0a3bd397254ec5b54ed9bc494691cbba3ef17eb305b388ac2c4eb009ef9b51f0a34dedcefeda0590a8b01f519ae248efeca973dc3d19c53d970e66a08f2768d5b03aca0ea3e88339e567ff95f61ac3c1413db3e82fedc935931f5b04445ee2c66080aae21447af787704e6920e10ccd80e28038ab281bb16486f9fbdbfa90d5a15b867a6472b933050b332beb8cc92e93b56fbdc7d9199bc5cb3c39c5ab804797621f1c3bb3524ad80dd7fb992f70b3eaf36e19dc0f87e1d36cf59572def5326c927193fee4175b77a6f90467b4cd8555eada0a62301b6f94557ef168496965452dbfd1161b20c84a5d22e0f17175cd881e59d8270669597553fee13f7763a2e7a28ba6c8de8f38aaeda206175d24e73610fa190c377353bd8310d3351b0893dbc0346186b143d9949c6ed4aec6b3bded21e000870d43ffcf57ec47d8645eab8a7d60490ade5def7aace273a3d2ca2fee7ad93d7906225d5ed4df2a69337d144358be0122694840286ae677afcc5a4d0156d692d67873526972879738b065d6f082259cb2d28cef1ed236f2748b5b396fb555607032a95ab322fb1378278f089a8fd4a48809cac9368254aec17d1262095ec55bc94803e8f2e214d75b2cef936881d16ba2d67abb110d95ce9ea8f6ece93af180ba21996623a3a73b1230003eb75b88ceb5f01d9e4f3efa51de6954eb333b7c55613b48fd7331d119522983793d3b779192783831168a8a5b7e0e4fee02491c5092fb433a9e07678f1a8f26526f90a0b092d90645ad303cde23885d14b1fde6643cf4281d2cf092c3f327880d6dffc24ce281817c99d0e7a2fc5d09cd125836610677b52097393c822593a8edb034966bd1b449436ddd327a60a32d3b2b2d88a302c80ea77d8af89fe46925cf6595594366349939e850a94f964b8052ede30c20d1ce50dd9906b35258d4006b05f6830ad6bbe923dd113fdec4f5220f6025cf58c08bb72d235d76306d583fcea10ea1cfe07dc5d1086cb6e0deee9bfef71967f19e4e2ca380e93f32931f62d7c387a43d5ceae1810ae38161ce480ac26f5104e499032c72db51bf3c5ad5f47bedb3a9a2dc310cf7f53d1f01a0b7c03eb3aa979e9150fecfe74fb02570ebde433524a56bf59440a504e1833b2c83882f6a3b3e6e14afd294014d38c73c76a0c55d473f831a31f244614e8c2fad6fc1bdfa02b10aff7c3b7df65eb6d7baa8cadcbc8920084188214734bee1d422bba93b368c41dc4014f74034eb6df780f8f3cb963400cc8afa28af20115a12c5f2578cc9d4ed661591f6ba68395c9b2c455b57e3e5a0118f0a849dbd4d4cfc8e28272e430565f33ed944abf4661750a183c3ab7e6f81a316d7010c6ac7bd08f6421c16a9cff36fd6ee756b83e4ea2e237cca209fd9093d43d545948fd27871d0b1a2c3f2ccc655a0811362f1ea2842f5775314bacde29f3ec52069343095ba12f75086e4c18e4000034363dea1b58f48f4fc4d60f871304f8f1c60e82d40c824e4e3873c5a151acaebb4a2ed8d9629f874fcbc879091bec3e651ee6c42213c0837ea1a8767ccb0e9c54d316cdc5d218e9894e3486cf3cf55d03903f4016725c52bc14a57f0ce13e1599ee44791f74c5a54fff2ef648fff2c6fd62662193a1b14b111e97ca2864afe87c44a0d2914f4b425730b23e839aa86a243f8c80924514f16d09bec1fd50ac3fdbd2a59a04a78a3124b64cc4738ae84d2f489b5aa797f8fb30715e5b5dbc991bbaf1f413aa46105df6fe20bf48b74b9ec8cc688e4a54a9f6a455f2237cba8b1824dee902346c3560246201a049d769f33fd23a64c334b53e24990a23f8780a29222fea2e0a938a44e6a18265c930212bc96c4ca7daa03cc1f204a2b026aef8933252ee48185fbff57f3faec8e53912b141be4d68ddc15d1ab5f8f4bc557e4ec2d260e7e6ad51aa1b1cd05088caa9b39c2d5a7fe8a196418fa7ce41f7c7fa7cff4f0953c8eea129f5a2891d1ed2868853ef4f755937ba270ebdbba1febd10aa2ec0709ee24acaa8ad09f60230e6194ac205ba3132126c4874b4619ac576ff0289422d6c3aaf22089354a190817f8bcaae7e2fd6d324df775620b9a87402176b346d8649f31279b2d5c32b41ae4d687b8b52241fb9d5eb2dc6ee6d67d770694a70ff4bf79109f23caf4eded66256c7a4441754294b245b1fbe3b11c045177c62fc08679d2b1f152f07f16b1b733016f5f9f251667a6e5599c997653039189a81cc031a585fde255cb79f7ac0254b1be9449f7abf69b61871f253656485d64872d76dc9688cbf81074e44da7448c39ba86cab393268f6e8ea338a774556a53c3f2591fa31a1f6d31f29d00c1492c6a44e6aa8d76074a9e81071c7e0a6dc3e7057aacc3eb5157372c0d8d650c14e25d8b9cf09e192b48ae591b6f2f9fe61a8572ea8bb7f9e5376f1d886e0463ddfdaee775b051c6e7a6378a61997729d29968d0a18d73b8024dd4c04e1a93c42feca08683605ec96fe2259c520879624c3f57e5efd8fc7ae93aecf1530b9d739f035fcd822ccb1c71b226d43387ed48d32f3647f6d7097a91be0fce1969628198904ff8d3c3e5cb4193e700134c49ba1f1e609324066143d151b29b06240982f88e5204e054ccd8f8a6f8cabd7164be5b673ed1aa478f0b1670505838eed4aa8993a2bceb84e99606c6f72a21308fdef5e40928f72115f43edf8a77e85721761b797f7ccf69640b2ccfaaa447b10513c52410e71b9c2cb57d7ed686fc2b4b0ff62b197f3d44b80bf5ad7de50bcfd262946ba9c1901dfaf73c148f0a04f4c4b26c1d3ce0aa4908083ff70dfa6317448bb9ab10357602c473b3dacfee1faa29b32f6b0f129d4f26f5c3f6ed564678b082a73a524f65a68c9a3d1e8e2a5dc4b4e3a33a3a3e508d967133a215c412dee97cf20cd64a5c5006ec4cc20086cb09245cf35837a6a14411c49db33b05172f00784e86e7194c255321d6c3de4e25abd2d65a3063e7ae522254e13d40be9c3cb04eb7b9bdcec4efc57da6a8ff0ca2212368d444eee00f1bf766fccbd4de692800fc82491a3a0024e589af6636e0e643403d7592b022dc388658f5266995292ff436fb4f22c9f3dc34feb0694ef1da4b44d278e1f89398c97d43c64336b43246b49bbed19a93e3c55d0f62289898dd06a888a80b23a7ac89213e2361ecbc685d202906ab71c7806e2f77d66587eee36d3a64a50c54c617920bc8b977d1fa6a3b3c86fa56dd0cee7b1497beafb4ae437fc998740e4763b29c26c4c3c1a4b6daa4cd586d0443ed67c55965cfe060dab9578d614630de3c67f67a36733c149b75805252b13fdac5af03f2fdcae6cb0f9161754f2afba038c52ddb860d0ad194bc427a7d89dcdebcc88c5b6da2d90d671bbb23d8e454a961d57ce2c779af11c4a59d8cc600cdc6bda6709e574093b593bacc3d46dc11bfebe2bda8b33310fffca5f80183d3cd5aea9ceb1f99afcdb020605dd26dfb6a419482a9765b181cb42050fc17d9fb174a52fe29e9afea2e76140295f24e7b0bffbccc5d0d1f2cc1465023402adec2a7be9e3bddec22bc5a83712e6a8ac703e31097ca04cdbab87d8c377a44acabdae00ce097c90b04b8edcb15f29e27852d2b69407bcc93a808f1a028b4c564b52189683d8fb0f20ecbce4013c45e9b624d52cca8fd20b8712909fb7b0e61cae7208e57d7b70738a41469ca6358696b6dd246f04182bf9f7c353fba63fe4d8c712841a76fe508575fdeaa55312ebbb2865b67bfef12d7110a67df28b7a4aa46186e6931acbf5422e1b5951c9461c48b30ef702f751e4332992aee6805b2437866a9d7d04ea25bf568e4431bb62013af831cf2f601a87610c4c776741f7b84ff11257d2352000dd14b10ac0a871136d2b51ac991322f3ac4e6588b4486d9c0a1bd9726f0e4d6917864198b091e3c50f6eccce6ae506faa8c9a907624e66df9891d94c686ef53d1b6d7bcecbe6e62f2c89049dcfccf8014c8609838671f187351c8540629afab9923b35814008ff7e45c1181cb0e7441b4bbfbb5cb0622708222d01cede927f6f63de75d6171f11733fe27db9cce626d7760ac483bff6cfed64483b4d1f3b75751803cc9ef878a3bff896a1b00ea8810f0e79b4361af5710e3241e7411ef01450632b73af94e12c90d0718819a777497e9c887d4a65f17924a6db1da674a0576aefa2517889ca2850cc236f23baea7185ca3d2b73b7b2b39f107e8a7e881a8cc34a4652a35af7905b9c65c8c8d3e2204143c2eef784047c03f8b551bd71837bfde6bb8054a554619b3aef5e93ad3100908cd7704d1fafdba55e90d5c5d05b8d51d0a2a7c5a6a0263ffab8ac74c4289cfc9c674ae7ef2c86b3ea8971a0a54673c19c62eb63f78973cfc3e069ea128a4e158d2adef0a134c4996137d80475a8f635798be6c5b5db6e49e29cbbf35739fe4905f93595842d6a717c73c11fa2a9e199fcc4851263a62b2d42763413c038fb646a30b31480f10d53a901692eacf6689f9c8110118b966db3fb74b052cd4ff2b728cb3db0d3b2b0cf9f8f200a4fd97d2fd7cddb0ec1cf9e58cc5a32ea673b8ad47872aba6910db0fc0b7323723691282524308a19806cb340f5b3a813c3924d9774e334fc305e8da7e3dec3b588d3782c486ff2445ab3a783ecb25e647c3666baa044caa7df5de8ab4d27c85172e52db7cdb9afed5c5c8d34ff35215f634ad08f374ffc254aad14fd126c88fe71e47963cd35bf210cf833b105a9a2c658d3e7a0512d0705024637005bee0fcdab67906dcc1a1faed6516f44edf87ef57b2cc5bf14d854fafe4be3a11b43260c06ef2820a230dabc405ad00d27a85a188d8f33189743f38952872468a96c85afe735a20bd15e6222de723f84c70a9d1ec6ed823fc565e741fe93b748323d33302116de3b596e99719e6747ec140bb14915930ccbcadfc1cb9d3533e3fe65bf12f8d850001107c75437eb0e4afbcd28a92750b24c60961929acb48bebc6101d300ed1fbc494b314ffe4d13bdfa34ff3ec992c6d183771f20f77b04f5f2f90f2e456ffe3fcea6617b24d5b0b56ce5777e014ad9857c7c024ec7c65403d4bc9516976996c9f41007538be957a0db22a4a4abaf46db72de5c202af7863494c4eff9373991ec918ebb8f0c738d5cb88a27bccb8a66c6355c14491c06a07a77d2d0fdb215b8d0db39b87b8a14f5cfbfd5313663329c15fb15c4312745bcd1a8a5efa6a25264e48f726074c5517dff6282f621d7a6b3be84dbdcf8dbbd4631c87353f90a2f1757daf85df97155f1cbf2304a39ae7fc6b5dcaa37645f3d1367a5b407276b7af4112e1a8874e69be045d15003187c337bb8ea8c19332a3755de9fd7385e343fe06b241736f79c375856d9f199ad0cd7d3c4a7bfebdeed145965e874d6fa4532e71e193c4035c6c53eddd4b83ed2fc512f25553692a918fbc346a5f86167a38a34496cc79f3962b9b9bb5a51e2989e1c3b4b6946b1f357ab8402d5e8581f71768d695c2cc0f8beb8fd7d4556eea95fa7475e557f6ab266bfb3511067d42449d6cfd56b7ba4e2850109f0b470c4fb7796644345a9fd2fc82c73d17fb6022c3c84fb5a70d8a66a69a17009f317577a15827fd41d71bfb342a3791df92b34741a85e4b16bd6b4392b0fb996d929743dbc9f2cbf01146fb7a7439e34e434eac05ca004a1d12fa3253f6c0071a381a5b07fac2f283970d34fabd6513b98294c3cdbeb5f795d42f0d61dc633a7fefe9f10851ebd2a85c89a8258de9378e5ebca96e369a4ff549dfa57f4c51caa7d404a347e3f98edb321a2a847eca58704c9f35ed27a6d17b7a1b5dd4f9127b261138eafcfc347076a8483f1f174a306feaf0593d9e05301df1f6de36fba0033a39964418732116ed8b8347d8f2ba05f3aeacf3f0f27ff7865ca1bec86c20a7135574fb712e1593145e719e2cb0b7f5140cb9d6cadf542a1e2d913126425f23c545e6a044ad5e6271335886a9885a368bbf2b1fb069e65ed76d04a0155da952741bfc0c9d548e997e4b8ed86f274085653d45d70102b3b55db668193454eb96aa20fd48e1147e3a73ab8b96748767719b1f48bb6768628be4ba0e47859404cc740449bbf2fe25174e5dda4c62e49c406b319f3fd2d3103926222849f19d78179fc2a4c4c10ccc38ce8cf723664f662f316d268ec53a7c2fa5fe91f365097b88453535512bc3b7f6c2396db8e05b61e37415df416e11cb83cfe0d4a1bb650c92da76d81268a34e1fc5facb97f12211bd09224618d4db1d8bb0c71d8e517ad773b50b5afcc4206c994edd92170b116183ab85028a4ba82c149f51a42aa7d4e1ca9a9ce49625ec029196d1d7b2786e1629d106e8086f6733e5664bd3a5ade4fe603754c17a97548db1a436c18d0933a15b188dd58580afdf3e6ad96a86f5deee9cfe5d0754ac4b90169f427a14cc443e20eac422f1816f2c4f8b039b18070794d0fcfb5bf0f2b45682d8c80ac36c3aba06861abe6d0634222d268e50c24928ee3006a52f8d15e516c9bf498267a66a722d82cea2f3c604e5d1f0c3b7fa177b213d27c945e4efdf8431993012a014ce5b54db9e51336a9bcf8894a8eaf9b1744b6d7e197ac5b448157637358e7dae99bf8c87f9a42a6d68a6bfd4a204006380207a012ed18e969cbf74ffc7c8254ccb2ad6bbe5c7eefa66d84e0f085a7b6877942bf588e95935a6587cf681a086d2e44f1b92caab3d40e3b536dd5fc4018a045b183871c710a8c155815bb5078b4f274f0999402454cc4423976df6d0023127fd4a4cd72c0d45898ed4b9a5eda249beb1be371106146e7fcf16b7b5ab64f1ceddf73fc756141e98f320caced7df638c79ed5dda652f77e69a9d0d4da5696df2afeedaf1cef972ebfe4767f88d880d0d1281b7d1dda786209f816a952a4eb1fadb4f41dee6cb643b15a89349302f53eceae1bba1dec209fb336de3831770f26b9a4728a33695b26223a79a870ae6e994c4b84dfd0d381251cdaf052313ba54b343b35bb29991eb7a7318d2b8fade4aa3085f9244608fb7728c48d67b8b0e40700a97167e63e8532ee08dd091efc50e6a9a4773420ac4afea7117038bf3b5d1f8416d36053759b9e31376feb06b63c1d00cc3e4424fc3f7cf40cabd07f3e35d17a6e894159eea47a83ec3e7bbd963184957d750d1dbdcd12cd7fc06fd84847aaebe05a1ae98e28c25133569acd22aa688871b0b02d4a4529b9aedd7475491b0650a7b20c1f8358548e829458559495ec4e566ff70a41eb2e9c5105a7cdeb60a44d4f5d0e46597f6ad8a2db63757587ad0053a270ffbe331c7581b8bed0de9f04b733bd132f9611dec82efba0e0fd81267ffae18ef60a8613d2ca84eda3581dad2ea120a6e00e243a3fd9e53041730e3e16799bfec996893900b29ada73757f6c631dc4e8e079a729e3db7218c42e8fc5dc256b7e69893390a87e4848d9ae03fb3751d8cd91c3f36dd92d1494cbc8292e09d4f705db4524dcc3b69aad808ef65e777cfcfc862d7ad0c09e38b3557425554eaf2f50dce3cf394e19da353c594e9b42c61598389bfc5f0faf6942dea588d6785572ca3e2a297e2c8538fe706b58f0d6bb25c36f2ffc529658aae9c5235b426bae28d63412222d8913e7f662837f08641375f8737d8e5c2dee0b4c82c617fbb8e8f810343465cdf88e048ec7cf986c58b86f725dda70707bf76d39bf08b49b83c6918da2e4f63c0aab2f7abb5eea353b231f098c0a9c6a1c327ccceefe4c35ed87ae8542195a19fe9af335fb212668d51ab295f08de94055c7d0bea779964b0bcd15a4f9b95de5e93dc4a70d2a3813dcd4b938b3a1a0696501431e1c3750e716d2ba6d7a98184b7dd0c770b098b4523a71650d3451bfff531c8bf99a41fd9f3e0b9b52c149d223f933e77b20481acb14e6de6bc7975acf4d5b521dc695586c162569b97a0758e3aa861191a512eae192a729076098ac8f97fcb502ecacd75dd66d80d492fb997dae9744b310c52726f96bab6613b36c3db8dff1b856ecaf5a984895c406aa96f0e488846a8e33fc4e0222c809708a1dd43d8205974b5f312c7a2da8ada39c4f1d10db770a829f2e4db6c81919edb3ef17c86e1e1b9f43de14809a3216a76b23b5bb2b5413c2607e8ee022233706f32246c294b03c9971585ac36c0592c9d36468af3a743e266bc5361729d372ae08735693c98ab4c888466e7671ff23e0b92dfcb1a578f7afba03ca5ed89e7acb0c810d11b019f8651d8ac54a7bce43063493df0270b56f77b85dfbe049d72cceea328ef037fc959007898a42b6e3fa4a02664187e8f37995157c9ceff0c9a242958bfdd3d405995c452d196b797667eb6bdd5e9018bb03764be07316ec74659db9e9074a52036a47e21977cd1f62ccfadcf1001a095a4df321e607178058d8417154c93400ffe8c5b97246c8119417982778c60529cdbc69be15b31053bce3eeb7e1ab7de517d73ffbec31c0c75e40f1e12de4d40babf7b351850acbb9cc36afb88184582c36c36c566ffae8c47f30a28351cb2f95870e6bd0332970d796a9f249af8e2498e827aea340c50039fae527acea7cfa48d440cbab9cea5fab561be3969e02a12613ef6791d9686b0935cc66a4cf5fd5ca7a889f15632738636eaa7039bc33089913d63af5f4182cc2a9b27aae020dbf6fa7588f67d7e7d4af5f88ff299ccd0e709c5ae11232de2ddde3236ba259fd6421f218391dbe85f4d68432cc667fcc1a227b04ede2fbc77aa935bb64474b8834c0fb9bc709df273cf40ec4cc065f85e6dfc675e4b1b03c78aa97e710a1fbfffbd19527890d28858142b44e08c7040ec2003179c4ea9b33e1f6c45f5084baa17aa925d775257876dde25424fbfd4089c3f34443af4958ffaf19f651a83cf486c619616b68efc3bccfbae5de0d62d9e8c25e26815eb853651d3e3c056f167a51a3abca1cd6c6fefa4cb3cc115a8df8357d051e236e2f25402be5b65e111af417d9d5d4a3b086c86bea538886bb081c7f20bb4cec9240ae72d7ae0aff20709425ec7f7e9d6257cf47ccb693410124f55e224ff5f7885b5d0381a79145ebb04d17dc6cef964f2f7f71a39253cd4f8083194f56842ac308bd2c0d2f7061aefffeb318cfe4b54cd48e91a912e17379192bf1708554e03025b7c40df0440af8a56d6276122e97ab826c0df2c5e932936194ca4c55bda89f5a0022b6a96a9234d65820f87056f8446a2e6d1e090e82772630f1a75c8866e4acf0fffaaacfe8cb989a248ef76a60ec14968cd9363cf3f080cc0ea6f0f03375a9bb6106df1311b8632f675b586d05040bd7b1a6e33bacf4836a9ba87df52051bcf48c39c00ce8d48ab471445b38f2d2b42b9fc54eaf8a2fc61f163baa9bc4c4f6077a95a44d959cfb225affa9a88ce3a4e74dc18ee7d48ba789a6b53be6f270ddb4e1a985c897c227e16e99a32d771b3a83dd0a7ec24c53671735ea8130bc993540aa2518f4f13f1ae98bfc4c73c8c73bea23c9ee1cc1cdeb474cd2a296788035e12a93f7e5556bce536c444a34d779424f161aae10edb024c6d4c1eff4a7b98776aa407a90c412c9aba61360b6a90a62e0aabe9f97c69e6f96739974c8fb05b4dece86120356aef66b8cd15a685ebb1a16907154415a2c3ec0d3b385ca8f68c044813d8c197352fb2600369aa18fdbd58b24509be8ca7ef34b7b60b89d0d08a7fc25bba14c9f5beb21ecf94142cefa9e014b867cab2799c74df7fe60902695136941bda7090e4921f7a57a52d860c5dc47e63a50dfd505e123abe54c444adc059c0d25778717688bffae71a5b6ae76eec9b9c74d54a47853906dbfb7a0a36708a103b43ebbd4a67e2d7a0b678c259da3b734395249c4c55a85def9c94e077a1b641a420d75ccb9b81428a850365f1e93b4f87e07752426d2e25f319c289e41e837aa30b92f9df3623e473d2f68c5c63a301f23a0d2644cdc4b7b0f76308ef298358ac7e87837b4014e4d12f193265fc50c0fc8927d8e06c293848d5624889f923d6b238ca32a572c7f16acde24401b8c836d308a8c68361c40da0244e896a5ed4bf9d52753e6a41a8150566ba2511b56165456a1e5ceb6eff0af269c08fd8e057ea8a032011b25ce7d1e68e3d9984f101c74897d2bca508a533a722ef147a626ba67da361a3ef1bd79c9df41e50aec29e8dd49722362ea0ef9401b76f1a0d873033d51c09f12b877baa89c24e54cf1e1c93a94d5f574a2426f4dbda37ade653ac21568d6e492103daccb9a46455dd28553ce49a82da4c8b09db5d3bbb4f03a268bc0330f44daeff13a95e08fb5412f4c1640ab84804ffb7c0d36159539998a23bc3f71bb1710152ee626d6fb51958ef922181358413d4a8fcb02291b5d96af88d60b48a4098303bea521ac680f7456086a74778bfffad2300acc737fc29312f8d361d192532e8fd121fc3f1efaf541c3a733dbe2710055f9f7e38294b3fede27419374403f728f2ae719a4dddd448dbf81d80bdd317f66478014783556b0235602681e7569e2b6d52c8bd05c12b904e007cd1d0b1dcb09f0e418a61fe6ae7b200f755bb480a40784ce508cdf92035e837f398214ae8e44830d0cda02403e048fc0ce90fb08fe3fb9e24deb0719437b495b82a9058248c4a318fa261f363df0320d0eb2c7da57b16a274f86bbbc49f63584a2309362c7a7e1f21277f8db07669942b3d67eb0b315f71a8dbef200ef89465c741afdad82481116cc34fe8db2def36753a5d60e35bc3e0b05410e6b4933170f91b12bf24f36019044c1da05131dce4d126510d2cc3e8741265961d48b9f61503f2f38e3f70761f6fcf1c168196a5efe34101417ed8656d24d05a00f148d482081a3bcb4995816db3673d90160615531b828c35089e7e568effa3a821898a9f00756e1be06c534c5c80ca79061615a5f712e276142190f854af3993ce13ff934a3c7eab9065c6e83b0efed11888d83edf33fbdd9414f82043ef51fc580f02dec7317f7f81134e5652ab8e6f9d98f4d0efb7c7949cc8620a30e848e29789186728978a0e116ee0d5f2d7ca9e2d8e93c99d638ba2bed64ebd1d3be6b3deb322ff8758c219ecaf5fb1030de1ae132163558ed95c46c5a7b3f36c790f60d7fe545211c96a1f47e0648d45b6495d8e3407335fcd9f8c5cc8849c2946c9fb52af58c17aabafd7bcb53224e4e27380b0211c713c5895c2a5e2683ade43e298f7003a0c44c19f92c73fb28fbc1bd685aa3dd97fe8312a593c831aae2e2854be35563803eabe58cb0af054f0fabe68a1b6646d1b9d72419dde433504cc2543ce3975ae05d6a3a20c72b58aba4fd6e8be0445a313aad80f3f487ce0972d9dd534434a8cbb128c9bbc3288ebcded211116cb8a7c813189e99f2f80417a9c937264ccd22bb15a80cab47b2d07e2f6d9c991dd507cb5651775bf3d0b7c88a41072ff120f1721c59f94c178c08520344885e202918171e4d22d7ad5a7b733591c64a45230a5e0644221d661ad5d89524f9e7ee5a6f85602a718c549a9ac2db82c3fa6392284802c9279bebb6988e81d08944ba7ea6b0ff942c60dce89d80ac44b69eca4fc50da8c82ab841cf87b7dcc95cea75b889be83a98cb1623276d134fbca69fb2454a441e710045631603991a48f313ebcf0769449c6f3d72b044426b5f759b98327f7dc83051d40cc822c9fcb8238d6209a65dff6226684232ded29d7c5ef230c30c293c09c14e4e2aa9c6b71f473e4bfa4249a81e47248d53f2d23e6715e0ba74f379f3b6f0c03be6e376bde6b60d3eb715f9648c5d6230f9d30499d088c0b539263b8ce7598c03f42cd9a8cd9ffd74c9551da3d71c3b5285a1897bae38d10e35714ce62f583a963ca0cca03b0843ac037ce5d534dd164d7b325a75c8b4d215d44555731f92ea5bcb1459db7a855568108635185c43d16d0cedb2ffc7c227cc5dbb073bc5ca9e7fa6deddce321ea78456e1a5e4553eb911773304387483a9541d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
