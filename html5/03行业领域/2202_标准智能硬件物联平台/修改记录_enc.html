<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"003dc5e00ce7ad80f874adfd7945ff76ec7afd65eab65328d5d3a4386638b2aa6d147affc20974fb715c632200c2a39dc904bda8ed02c10b37debfaa987087781dfe9978494610174f2a33abea1022b6f027035daac17f81885d89dd4ef816d98634ebe70e5e79e4b50acdaae87ae99da380fefa24c3554b5cb4324d71023c5c2aa5c51b3135ea404878b0d1380f520e8030263ea63ab6f2e29045885bc7906fac1162e510c62275fade263d075237afc36a27cbbd43630262e5b1fc5d065db23dfb994376ef3ef56d38ee3aa332bb861d0ebf2dbe319fc247c9d24508e735a06bf96f4273f22d7309aa9fcf1c594cd3879f539761b83c2a1295f3a35832c24a3358bc5759d8cd96d5ab93b050c632a91d028b60521ce880a426e512695f317bd293ba11b43db1e2b3ed3ebb22831ded38fa287fd0bd548c1c2390a4baf6e9193d5e0849be5dcc2596d378f5b9ddc42115398c10d4ce43895fcb403a8282fcc4edb6001a6fc9c60fc1521cd24a7d7de82c51594729dd066eaa52c876d7af15ee987dc788bd87184cb942d33a749b66934a2e36eab5f710da90d9659421e6ce56ebc9d0455fa38a9369fdeb4cdc4dc397d6486b650f0e36d1877e7f1e28aa81bf1cb3beadc3e6a4d293ce5c2e01de5d1c4c789c3c3664a36fdf54379ad0334430f6c17624ac0456226e98d83a0f9ed721762973d414493bb5e17790768486abdfbf68d15ef85270ec1f6e144fe0fb00c25b759ff405318211fe8fb769c99d70272dea11b5c0639e10b02d984a36461b0f5114fcf89c0d395303d8c383eeebd189300daaf321c0934a142a82c1dabc6cefacc159edcdf8bca2e438771bb3c75bf0a6544ca325c6194716dec1cbedffacbaf40ffc02d5721113a4d9e1237277c158c40cda10a68a830e6a1c5766ac2850f5ff7fa1da965003ddd697268b951b9eaf8fc3eb07525d873a57168ebc3a2025a5866eb323618aad71d3fcdc80e288bbffd31fa58bec54768025b5351d8454be26049a0561751c67ba4b320225999b74e041d5c58de704037e44fcf7382aab3ea3b01a15e92a2420cfe9c231b54a449a50cf88ad3c481d3bc710335884fc0246dd664be855819793df2a212a37a2c1a57a33f49fbc49fc102829f0ee177c7b0dee463ecad8ef558e9a53b5c01e574ce908ba5c1fc7227d465cb061fc5763f789ab588083f36338a36963a3236cb78be8aea2c9ffa7ee793cee223ce0f9aa9271634e639511370a089ba7f84b6fe07860425dcde50a0376b2c22ded68d06a2a147ad26a2772a5c4a5e4383f575b51a7c0923d1c04eb92bbe0f8e4ef3ebae8ee0d4e97f3517b757904a39f19d1d9dec2b323a523950a47cf39b0cf03ace6a3a078443a8695b31b22d7ff588328809426a2add785489880f1fbb04d7666e3db13c71fe436ff514270f0bfdaa3ad784b93d530ffba56e36c52ea5cf81d291b377fac08330cdd66df8162ee9328d26e5fbae2891341283c027ef852fafcc92410595fe619e6bb42a533960d6023b3f9fb3df8d6b733370d982bcde91967608887030ac8a0e71e20aab5bc36aef1443fffc7e1e02675c9bc70d6cba775957d0a18a4bf44e241b2fce56b54e795a73225c64f7c72636e85e6b64ca0274d74057b2f75e921a99d98e7e06c406f97cec34e771eaf547608cae1e8972bedc2e0943872da50cd8c3662b8b5aa5f0c132f020e8a1c93dc335d89800307dbabcf2e7998748371b30d21fde827b8fa320f7eb3a9669e2ad02e418253e38f19a2909ab61a555c7001a9ee676a4caf0652b58df8a1a91b0accc7fbaa6139750ea044230292564735ff6e11fa58559df786d5b9e5a198405a4533a774ebd8543b49fd67408362f78f440d4d273b3e58335ba149d2df3f46f22da56e413b4b1daed8ec14bccc370d383103aae4e4e46c338f95e56bc5e0e1b347b841e8d72ba8a8d74bddc71eddc32c3483a1dc24257658bb64236654d26b71e6ab8c42f805d34e4aae19e8efbf5385a103c4d1cf9af62741b6533f22c522588f7eb88ab04c6bd00fc3b60d933a25feedf2fe4c5e0ae0d7a53da2381e93e2743e2804790f52ca3c8217d75652e222b0840c1c91ce442bde1725dfef6b929d46629e74adcb3e502760e817d244b6d1b297fb46006d785f882ddd9ff8c9c30929929052896bfedc7da418b666c9fa7a0c31be04ef48d04359cc5234f270128d9ee3a490ce88e8467a5d452e091b9e725737e60f7b8fdf4f2c9d488b6313b8f484a7d77e5cecc3b5e89a96ab377061f91e3faa07ca14330b4555fea3b2ccb8eefdbe09bc98467fcac3bcb91fa6ddd510e4dad3e49ed660350c7d5db7194070383aec695915942ab9a93a5be1b452007049eb654cb0d7269309d5f18de78eaaa88a8518a4a0396e6cc677433db9858f774659bbab295ee55d50b95295a8e7e59ae96c3c90d54c8f9d27dca96b0060c12fa8e9be7c39d40539a1bfd6cfd1af112eb338799e06d53af4b054ae3b05168347796611ed61c6e3f7bdbb3efb08a60708c12c65a9cdf43eefb798a461147d6a4d608cda871fa77cb0821f4a8086b46e67d2af227bb2d49764e446e248ab8dc84be370694299369994ea147c5f8ce659f3c96435a00cbe0a9b3c0ff25dade1aa7c451b9ce57558b182e055d69829dc641cf967504b4d319dc057f822805406523b0faf664816078aa8b44e3a565fbe77efd3ab4e045f6f05a762e7e337e3b4696bb73e2cc3216a0d224f23d06d9177c0cb65f41df55959750512ea1b4ea118422675d545e9eac01b252a7ef4d9cfa09880eede074c27aa947f4ccfc170678fbd52c80d1d97551910fd5ccdc3a3c782bae37314509274dc743e246b4ad4a4179d106902988ef40640d8c900d03e401231f7ca4907634282428977e7f98a0d50430c66d3c439500ab953086d69c70fa0565ce31bd0fc2aa1d13ef38257e7ceeba6b3a3ac9121aa84ab2d734db621787dcfe919fc8e3c76ddb86a41fe05e5564d04a956cdad87469a6afd8542001d414612bf9a60c21d7b5e3f61e494ffb9e3d65f19895bc23ab341684c36d87617edb6656a849a6600eb48eff3f3afab5d9344a1bfe2b3f96742d513323df4bb58f0e16ed672e377f20711b8981c6f6a3f17df39838f0e771bdf1b2cebe7afdee9d3033747061c903c10c5aa7161bf6a65bb12107cc4ddfe388bfb0a5b567c532ca9053fab4a572bc2157e6c39b09c1042cf3edea28e70dd40567c03500b44b103805798fdae4f70dc3cf66894b090afc49a298295ed72ee182b8ef7010ec26a862a6484b310ba10bbc1ffc5327a03e907a8113470c97c3345a9eedb58aed11bd7bcfdc4a115bd7268e63e30f17e6c72d901cc6b5f4bf863fee7b164e01faa82369802c7f24c758bdd47949e0d510da267c76b01b93d84e524f78302e8209d620b51922a39ca68c83bfada326b0be41413e8356efbdb97d14c3d2cb7f6e47bbb5488db08b95e57872749b4f7f0dff989085a2cc5c35f301990c4a3c7d1d94b8c8becffb33c4ea7b63d130a23007fb38bc37ec4e8e582c6b279d5eb87b0bc4deaac6c32565e9d6d68f892bb3e96d8a4535c355a3614cc441ebb56eae5ebc713df8a91d5b0cb383de463f6f0654a1be0d8d1732a1b9af13fc7396f2a83945d71a40b0b9a06a059b242fe5f1ed10ce9841629a5f42b971e583416ef5f50003c052ba8a3d2bf242c37cb962feb1cc5fe082e442f43216190e138daafddc2feca1c9fde300a01b98b564ba4d73f10830ba44382627161b5fd5c6188ba7550147bb569d8908f0b0688861c6aec94c49eabfada000c5d182c82e6f952455388063f95178f7b8774274da3c5d2d5b38dd1d585be285b134c87f2e72b512e1608a89d190acaa564ad1481cb846f4258de2c459df2760a9c9fa9eac6f4bff9d4bb079f2a9832a3c504d4dda7eb7699884f3265eec407481ce98387a69b6d2a7b239554b995bb329dfd73aa00f9c5fa92bbe58ad52cf79e0b8e68a285b64288a20429f4b25bb948dbca6bb518b6e1291590791db8f79a684589778918d5787215f2b4062ca592f328d030fa888e471f1af02f527156853f61b0c1e98fdabc5fc59b3156162e29d506fdc1b354dc5b0bcd69e9a61be5dcef29149a24e1d5870521b12c55c6307dd5a3e3186634d657f8ecbf1b15b959b5fa805510e1b66d4dd48e7376a158a056008e91bb185ad5bd572c21788f6289e41415e17da15b849af7bb6a6b77ef67509b62957f36b91facffb1585e24c2e8e3f44ce7e08eb8a420ce8567dda8869f0c4d057b241aa94e9b6dd9efd14dca477a17bc729cf92f2958ec2fa65778e18c2f4452c601e64af855a98d79bdfef399d4642a86b626da97e3fce58cc3d689d5b896841f9df961ac592c132f8367c665f21f4495cfe19f83f381bfb0a76098dca87b2e6403258ab23fc1d1873578b3e3559c97c0e925d7ab30805456d6f313821a46fac5c267d4fc2403895553d3e8f5be01d2b387f87114c16d70ec0da39494642fb733b17bed938a9e6eaf61c24ccbcff16d0819ea2e495ece9aad9c54182aa4a887e452f1cb9aa81da17f49a2a46c0c6aa709e1d5a1e916e48aa91152aa43892844c8863da96e8cd5707f852b5230fd645d5e64d57e0ffd9dd6a851a3f7346760af5f73d0bb52869b02aa01ea04fc11dff6f129e62b051a720798b25a6db74ad35f5d64ca3a07c45b60da6a40aaaadb971341b4d888faa379c3968e846e0ea3dc6fa3107c97d04634850a367d324da2f720f2f2688a9c412249ea74d84e92202245be0fa062cd4fb3dc9da3a2ca5fe33ad8023aa9ec4bc6c244de764e797a54eebc75ba4cc04b5f3125f0a95eb476c63facfca710f0df02d8f937d52af5198467c9a12dfde7db00b98bd46e03410c5990d736aebc2c0981ed95fa915bf4b1d2b0ada3c6260c1bb8bdc9ea9dcf47c922a82fa93eb3f4ff3c7d8b40ed387498ed6a3d3721c07f4dea7cd122fe8f6d12abd58e85dcdd3012c57962aab5f1394854ef8ae160e8060f9c20e948db7bf87b173a5456daa99287e823977c3bbff74e71b61b69b29fa7da57362299b7c3193728f200b93467c6ec1abeac09cc03a91f296446697c50830a1967d985c517ebb177858a51e2465386bf131a0e932560fd441ab68eff6b966cbeaeca34862fa18eb4bd4f1b8e3fd7349d089a38a78e667a08ee8ab3e3e5982467504c53905cf2889e548fbfb025967f7a2c155e2473ebef1e3f47d6ce327870711e3b3a908b42e4446c0bc61df3cadee1a25255159bc7481b18e22516cecbd110c930a862f2f630dcd68d8825d828f49b8811b735fcc3fda82c6fe7767896dc4ff9ae090c9c043896ab158d88b1150783b2ce3aa8056cd16d413da2a9926b616bf8e015c757fabeb2f4b4f37d7ff90561281ffcfef5ebfd814bc1480211d7599112c1e315afd262c28a4793beb0438b76792d999f2117e9d4bd6948765afc57eb1db3e05f67477efccafacde68d9f3180b53a25e1fad6bd4e75108151ad2f0fe041c2e0adcd616896a5f4154c861b61609521086217934bab654fa02ac028b5b4cffb3e501e62c5d3141d8ab5c7e73cd8c67b71999beffaaa37c9524fdac7be227dfc9fe4a0e828adc269e121f615af9e269e313321222c501a49a776f10c917a54f018f5b9071d5f48189ab565217b66e4648cd0640db089a405a7aebdfdd450b14e92c6fc190d4743ca1007928689ab0f6f85ddf3a5107f43e4dc66307b27a987aa47cc738499916619a53a86121ff3b064b7acf70a2a2ca1f9668c449d9facdaca0b4479ed460e5448e332dd21eb784f1d9486a12d0c45d9e771baa89054611c456be951e304387ed4632ea96746809422b2d8dddfe0004db2d63827968a6c6733994f53afe5bd3f31248a356676f183122cc49005f77cda62302f5158e499fef68d524a29b703277c407052af397dd48dafdb217691882314b9471b18cfa027b5be57ac818f02d07e37ac843ffe465b1dc20e5abd67552c9d29252deeb5fc1a32619d78524664eb5d2b1cc6fcd6292d72a909fc03b333d139aa289cbfc168c7be77e6929ef4decfae2d9eaf98b057a3bcf68ce9ba2a084b6b6e3e2c172c57fe3b11468c76d16b913970b655d0b40d2c4f4c105e7fa1506f337f903302bc37fcf622df9f4fd4a0660e12e2c6191ffe64303d837217aae9464823d42c5606f7035603434a060b76409e50ef0e8f0c0fc204eaf15ae4a97775f27fad5a14fbe4f5a84cb44cd4c0ec4011adfd27da9a172790cd2116d9d29d8dea5b433276b45c08ad9c27ccf2021daf554d9334e89692acafd0be02b3a16070b695913c534eccb035cab4046f75fc4e006ef7c63c0814a58609a00924fab985ff1b22ea93652bda282dd86b0b45e5d1e09288cf5ccd1878b44efb12e012b73f31a54dbafd8a7a050b08a12025ab2613edec14dd51561aff15fa3a046c61f0aed537d7f062c26c08d11fe1136a1206c727391e7e087360b4b2959da9550fe952ceda2629a92a37316fc14ac6246dd1cb7f12f60316c88683e984d634eb150a9cfb6f52d19a262eda6fd57e0ad2b6f5b647b48627b86cab94fb26e58f1c7c6adbea1badfc72b6e232617248b8e984f6f7743d1ec33e9786caa578ce5026b85314a911a25c2d6d1f3282352e0eb610c00eb2de164823eae0a8441e8e187c7f6d7e16eb8799873f08aa28ea74cbec1adba3a69a581effbb9953a1917bbe9b7ad794d33c0e319d29dd8d05d78fc93abb2f42c9f4cc55e20571a67207f43c94f91e1eeb55aba480544b190c65c7c8d2c52f312330e1fb96dac3b07608b5a62bc1f4a62f91ea3a34898a8fd543b44bd43ed82ce0b58a3bd5168cd140823da9b3b0226e672b37e4685ce8823446390baa0107bb7887c0ec0833af7d5145316fd39c326fa1e32badfccc906edf50056677295e25d1ecc16d86ab62ae2adbac8ac57f67c98ad839e6990c6eae9049163919d4ccbb7ae6932021f637468e19c3184177c6b86bee6c514cc3a7cf133481ec49925f2442f53d55ce746f33de3637c7325698458a303bcf2b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
