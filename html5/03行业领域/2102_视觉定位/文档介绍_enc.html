<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a604661ee3cdb5caad712d1ecbebf9f2610f64e61e6bcebf3dd558606101243219b78b1f5d9c5d47385a03904fd9a7072fa7a31d8bc76261cc57707012a2b4d2006851d5389bbd59bb841d150f538ce330d0bb2fd22679ab72de8ed786c57cb5ad9401efa79dccd06cf7254e806ffcab2bd7f252d833f09d45bbcf96c6bbfd89d8a1e1ca1f461bc76166b7fd4f1f17d5d73c34fdcb59fef05e8e13967d1863bc19cec5bffa426c0e665f751406cfe50c59ed348f477f16e5561ffbe62550ee5683f54ba328cc14107b56ab222e8e455ad135acf283f738b271121e47ee8c6c301e6c79120b09a6e3eb20a1c132d9266d31c47f363c857231fdee36d4419c0dad0482a71cb881915f799adcd859693cfbf9e43763ffa95d4a8ce096213e7eb41a70584535d7e4b2a0eb89a865bdf7f1f4dc7b47786d2860afd10d28c08c60289335978925a250fe9af6843f758e90f46e8670ad038d7d05eb264b8d48cf50f4c493f0d6a99fa833cba5377c727eca52b4757ac474c4faac656af3e1eb49a86e9abbaa59a780802dbc6539ec0a3c9a50f6f7155fd1fb63756637d8ad1d3d492b7dd46ab7dbb4d616f52528ccbe259406dce0cceffdaa73e2ae9b5c152e4d93e94e456fb63f5199e6227491d41c5c53bb26f9336e9fc7d0ba439947624abc9934631a2437023dba8b6f54cd6ae1ae341829b3a34d63b3884f65df2805751fbb49047cb9d2a9180941cc288de9f5a6b5f3060c813d66852875084390b0df1509b34e3b755340982f6f3adf1caf59f2e076b3b956ea62a6ba798dfe4fb2d438f7bdbb0aa6b69c012c084b69540a987835145f8a6fbd3ea448d8f9ebaa9b052bbc08e1b34c849509c792b222f9c6272782bac5ffa26a7bdb8383bc0ca98d131695092c56cc646a4132e3be621538789c0c024ebd6bc2dd379a46c39bf1085aa4795b6a5ed658c0e8f8c201419fbbd24c19b40a388d9fb113d4fd207fb98720ab2541a2c5dd60cdd6dd263c0cb26beef919317d069ded00a962e74a34455bb64aaeba224ced293099a1ee8fba97b2d79ef2057ca611890d3511946dca6fbb5673a9c82121e22caa080ea54c53e35016dffd526b1b5da38c3a1c8ad1d0d4bcf99794cc8b115ed71b565d49f8cdd4ffc5b06a2c3e33adffbd7862946ba9c1be8cf5a6bea19e459677cfd7fa17ff894277920b448442d7aef0ac02a186221da00a8cac1a7fc5eab26c7698ee4418c6480aa6e059507868b69cf36e369f20ed7fbc9208141a3797adb943f9e1f86d9924cc7e26d21434de84db21881c3a3e7ddb79e88af7abe0a06bc41a0b53bbf7dbeb76cb0c4302b153ca4979bf153b3a7f745d3827a8068432163b1f56dad43b56b97d9393f03192455b59e25fafad908737c224e4f27898e799d01be20b4526b1dcbda2435d709b431c1000c7691460a041f308108d4143130d0660517fc1dde39bf77f3ba5c0dca6cbae09a5f685b53e8c8266231964355acd1648e7ea2c3c592c5e801f5738a8777967e85b8c8eaf2d40fcdca982a551291e58980736b97597b63349e8dde9d5310de3fc7b51f639fe62f1d7840a1487b19363ee706e5a564361b408e80d59f21411ec281e1504215a9b08848f009d0d11ae53b1e3ffa23206a266817f9cc26a6fe6de11284debda395a6feffa3bc0ec8c86264a3adca30ff6e5cde3bca785505cb7e7d1249bfa8c75a348b16c6b2669a554c22819516803eafd01decb078d9b6b494488597f57c116c14e63ae39bd963634755bb189568dd4ad23f9b27b24645289c7c51c8fd56670b781d17e4622f2279ffc7d295e9ddaed66a595d221c7e721efa12f92c9a48d28f4429301290c889d57ae7e776ec694c5de2ab671691ff855e6e0d400f95bdc4627e461d91f1be5a37f622a5f30517947ab753b583a735810f8890d656ab2bbb002812661ffa17f06dfe0e0459320d89b5d6e499386298f455a6ac3666e9adf0cd67a294b66b5227ec2b39ab05381f061c4edc968ea243bc70e74962483f8b8d13f9119f5d7ea7f1dc7e8d80c74b0b36a203f89d2d5b8d7ddb74ef92da17c5d266f9a626e42a12f3c45d10aa510f6b39b7a7171c5f6bc89a08f45568b7f857888ebb0aebb9277c948851ff381ff00922cf599430a7c5d9861351bda73493e6a33e8c122f13397edac84f1079eddf8ac6856fa87dc9db14e2792c6d866ffa133c251e84a5e9f09768a73a42203ceb31643c5499c0dce5d025afa93638ebfc064c4ca493533012816ec6ac015509370e641bf790b2f64c702dabcfebdbf340d4ae94c98520278e84572be381d7dd9aba6333fbb200e0d838559248a8a1cbefa8dc454f98c71b6693740f8a03178babfd52b6f791d44b9e65ed20d0fbd347a0a7accab75e9e0a6110cb0309066fc975dba768ab5d1f40c3ed7422becd401d00c48ffddb8ff8b8472be52ad399a01735ec1d67d7cf5beda9ffc03fea050dc7a5d38e68e8c076e848d99e35963a50c5b5ce362720681ff67a33fc52ca2fdcf3bbd9f4bcec837086451c9cc557868d30f5a27f18f665f189b2f02ad309f4b7e4bb3e89fb023090952a41e3177c60260a3124480786a6ed70d3f322fd1106b39dfb9709eb89d81dc1bca16b5c17cedbf0b093e95d187aa2d4d18228907e16cb07124065837ce526a88d27aba82fef0cbcd1d6081cf07f06f6f32a2bc6c15f642c0df785c8c4adaee0c91687f09c3bb8b822ebdc5c09381526449384c48a8f270d36332155a682abdec6e339738dbf9325187c1ca1a4e36b5f7f429650254cbbcba0171e706f31ebbf7fffbd01c8b58048b32789c8981720478236afb54d1263fdf4757133b984ae02ee749ef71181dededa1627e600d2becdeb575a07bfaf29bcde4b5a6596b7e124b0e3843cafea114a2ccc68cfe5b2ce33a2594b63ca868fa96aa77f6c146ebf7a2d8efe4be2b0470afb8640c88f02cd36a8db97da3c6be92723f78ce02c862f83e3d737123c22b9f0a745d87add3d2e1789374a318df761737f8e0fbb0cab0e1116a7b26812041a89387364237c2ec4f41e3a57887c8eefedd2ed849faf240c83fe15b8ab0fb99a212f4a751b3107421f8cbd8710c0fa06a3eeee8502b09407ee8bcec45b55179f279f04fc7d20a3a281d68a4b3d0dc44c7a7592b7f854162025ac700ac7b41042035e36885ba4483c5f64cd383136a50736cff6ec29794e567b0590f832906593eb24a03fe9d2bc1820557a2684ba31862b21a3dfd1c6f7a09b8aea29928da1d431493c6e9f3f5e5c705f148cd91160234a6447675b4b132d0ef87263e7e32733b459b3183e489ac2af4c1d0a2a6c491266bdf489fc2dc76d141f4ba0ee5738c09054af2ca8bd9fef603481b50b3aaed5bf1df7f7b199baaaf454af19223f29b8e3b1cdbaeb77de441ae855cabc415c44c68a5600bbacbf0a06d2f77adc09e60879b6774ed5441dd743d85dc0a96deca1f14bf2124860b0f0d5d6c6571bc350b7b966b774479b408341339ca3b6addd33ed1bdfe6556a8e914c14320e5231b19448c4ed77866eeb9835f38ca569b2b95b4d0be6e02f858c6c3ca3f357692d97e7ac5c8421d80e8216b5c698c2a2795ab4ba4cf47427df5a9665557a775ea3544a0ac05ac0de39cac47d3e3f41f9d5ff919c527211626c240f1bb8b6108097ceeba979ddd8cbd9caca89b9a162037329fb338cda00e5cb6da0eb49b846182d1fc903526dc4c41b2ca64bdbd0fc37a263e85a83368a6eb17996d7552afb157cb1b8bad69b8b40ae81cff5a48556cf86a16d0e7e338a442a08feccb3dbf97c9b9f2fb016da98d7a231627d2154d40d44f1b53aa9964c1f10cf637191dfb271d6da74c07529e15ad40bed8bc2c8ff9728a44f2a424455be6cbc433496bb48bc7048af3abd9a1b74fd207c02c428eb7907185adae4c55afb94d5b8b1fbe6dbabc4de80b7eb67da642375e4860bfbfff80fbfb093f6d841e77e8a3d3be7b936d1fb6f4d134db733f82dc414bcdcd4cc4d54e31364395d27bea35fcdc6dc253299a5989ec669a9c7d392193b5a143a7d9179b79f5780520936d885e87115579be25cd4c1448d92a8beab0567889f4d54d5d8bbfb448756c61d5481a46db215d754567bbd4aa88c0e587993faffbe51719a3d62af40f2d6e3f82d3e93ab9b5e31f6eec8872dd15be0a65c88bdfc62fffffeb4327285c59232a332fd27178246afcddf38c3bd0d8e0f71b6ad2f9f8b8cb04e395c434f95c0373bc09c5d96d0835622cc77e6332a7bf4739bd45866b673e4fafd63ce3fcd287c1dc8c44b7a2f3eca85ed0d2fac9e50f22fd2c8a6aac5b88b575092d68295187355e5e9391a21426746d5cf25a56f45cde0b28470fd989b6bb0f1545fef6e88f43712081df871fd9132f502b0cc5696d9eeeffd93c95e0161b33ac3c302f61b2a20b1b7cd667090cb206f40b365f5f0413f68e7012293a88c90677fcbcd0f68119e31499629c7fc9e7c615898893c7522a128f6df709ac92b9330d0b46bd81e5e725d5773d21887f3eb8f036dd0f588bcdf767fcbd74ae57b3236b97acd446a818028d79be1db1c6049495c72f8481af835ea715c46e639db37e7e71ff518a9feb8cf47cd0ab1c644997245bb71b0cd21bfbbe9e3b5dcbc4ea48df84ad4c8c04838d3dd04a1cd70bfe74751b636ca61ac4d7ffafbd7a4a02396e7f4f530e4abb34bcea8e8359a91c677717a532913184b12937a18c4e449f8370082478b06e7f3bb8658c81a6ea522719e998c787c04595d05d8bfca0d3f313ad2134b22c7fca5747cfefb756e1c3308a492dc9be5e95fde8a866e625ec99a43380eaa3afdbf3158a8151a44a975426d5a6b36eb5c005a6dd2d4fd01f534061c538f0737bcaed2668abea0eb326cd47ebedb74e775ca7d29b7383f087bd97636bb12cfd2cc491beb1ff95f6bb47ba101f82c43bb0f1d756d368c92e6b0fb174de9f825dae485029caa0b9c500c1c47a9555ee715572e7484e4f12eff20b7cf5afd709e6952dda0ad5e4e912e18d078c3aa29a8f6f98aeb4460c4a60b499f00704428367b6344c70f00b1a29493f709dccc76bf1ef643b2d3638b559f606732fb53f7d24f97d2b396396589f018b6a4598d5aac1fb5f0e43286d1d359d04a6cce985a9bc26b47b7a02b14e7606c75f5ddf7758cabbbbcaf40c0d93c7c7d40d139dff8bb323cb55b6ef309b0adc6e7c70c41a79de47f700a6b7b61faab1befc9194a2eac16eafe995df572a114ac2c18803efee2c96b8a5f2d6b59eeeebce4365bb6bd5b31cc04e562948e292f492bc5bf2f805ed5613ea9e576e5f09a6b9fefff595927a5db89209ce062255a6d798cb7127f691cb54997be7c95664fcdcdad6eb17ec616b1735da99d3a2b08b558cd94e48a92a07831b7eac50b3f172cb6bec256d8f252713f1f341320adce678fa1e2b22ba425d0c15f1e0b3b127bf84947a82d4fd989f5bf4ad9f7e471f70b7275567a70fce28a34aa44f2420089bcf966a70fc3882e0870494007a145db02bd4ec15b43dd4501ea144eb6780f733b3af8bed927bee39f99a934d8d4843be7562e96efea538c745625d3b6fcdc6a3c3071a3dd7dcbb8a64277db3e68d378dba0cf27401f6e47c4bd75f3efd4317eb68403d0759837c4603c59e982d09add3c5c7e7c4acdcf730cf95dddc0ff9f798d5fde3609aaea3f0ec689f83e59eb0debc5e224b68cfc9461d21dec69c4fbb8e7ea286555baa6d017419c421637e8992018d0b13bc0600e893a5b056b6f0787d8d8c2b3d24cb3919569dc4c2addccd931ca21e31873c06026fa8c34f32c8b1189aa434452ee9ed903d0a2057b39a5967a67ff4a017ec3921768e0e1d6ada45f6268eedc0eded3fa6d32b1e7989bccb01a712ac8728e138c535ea019350e6218deead2b2ae4cd5fb9a75a32b1a0398613ee0b1c313dcba7face2dcd8ca9b349e56c8268f2904008de0e81835f60d486c71fa9bebefaa48c7ed6c18102376bed75fd7bf752771ef02c9d867cbe01a813c359f791feabe496adb1f44f4f4faf4dc0d2ff81887fffa5a67552e595e348041023277bab4aa77b1c2309874c389b9f3e727cbb72232f8634faf391e2cc08ccc48364f1d979eaefcb2b13e76a9b82dbd1bac9d9d710332d5263b211c488281dcc6ae5db00efa17a4f90e905376bf2ba6b5ea558aa49ace496878240067f33c37e7e381f5dab11bccb9b1f996f81f0c859196a91a4544563b586920a7e36fac63dab16785eecb5fa697baa4f093de356941203b343b90b0212275df83f6bce7d4a553977b027df299bc22f852e75bc69bd1392f6163bb9f9a0a53db438e1053cfd212791397a8d5ba37317662ce65723424c5b17767ef6c49f5857e2fb455de18010cdbae2f9095099ea11dd2a67408e7806f934d640529e0df5346f2b3a9a6434dc13fc5a9a9550b32e64d971ba004b1772a9f9882aaa6e5c4abf5a82ca09cf75213cb548a0c134b5f0f1b22090820be7adb04725aec3ebc5658c1f2a34510afbc36bf6a7ca1394258bd4de5994c391a34134821ece97121da075612652096589737ea790abcddc0e2c60d3d285e4c198d990b02a773015c184d3496f639361dddde109204f94d658a863600a9ab9d37a3cf582923fb13f46a209af4520804eaae5166114a79c28b0f49e8d318aee11b99ea1fabc9a71b1f9ce07d072bd2e2b848d77015a6a9989f23c445dfcca5573e4a28474d6c5d0a27c1415de630a3cd620c7598552bbff1f23cf7dffc96fc1c76b5959a7bc5656d54c3a197d21336cf8f06899137530d3febcae1a69f2b51824ffd1f6f5abaf07c1b5e64dda4f50a5ce68d6832a3a9b9d07cbfa62157a2da56e04a7833cd75f05f2d1c4b5f001a0c1410fee9fa4caa342a1f5b563d82d5110cc8c0a0a91982ef2c27e03a792dbdf5b5416a81a884c6c72a93d5b21919deca1d5fad49f010bdba995cae564f96b0872e29e68979ed05f9ecf2d1b88e0a9c88724e92528392b4bc2427d86f2272552bc948ac1980a12af4d33d58b59a845efe4c58bb91f463e1f1891e90360595da0d0c51d02a6c3cb0c270bcf12e195e95239ae5240e0016201e8f55bef1b78b8caae398ddf6760e4e837f4f0fa57f45c5ef8da788187ff0f2f77b38022b5c99e7f8b8fabad1c79215519b6af284dcc27f220b62ae46b3382a3b90973931484e48414f473ed2902630a4234392ee69f0f6610aa824ad1a79246126a85272a59c37c854f95e155a4fa2a329052bec40e1892b14276370343b1bc82c72ffb7e675b90af379f04f0b238e304acb4260b7cd602e8140751827235c5f621b3e05aa9dc7d84865b155403316eca0e07160a7d42b95adc252e3a3dee6b3718e71e039d9381fc12d5e01906fb0038fa5e326911143760944700a4d10f23b2cb357976a7ce35a4e3f63d43bbdede196a71d75dc2807c642b6662b6b8565cfcfeef427305cf7deee16ea4e080eb5eb3d32059f83393d44b927d383e8f63e47c14c95b9ebc12c561fefe2ee8f47f7d205606da647251468ce6687c2e793c25ff63f6d2cb695aaf160ff5592f9c0a3990bb943949ffc08a41615da9cb260e508af422c7bc4a1856c59af1ffd149c4783e3c3a9b63d92098d7a5aa63b50eb4f69b29dacd320e8e22fb6d55758e5f6dc08bfff7da30251907723a913d683bd825ebf1c306792c74ddcb1ddb29625284070bcf113225dd31e40e466efcd878cfde52daa990b103faecb3e4552f109e636fffed78c0a483385cea84945764b5cab41e6d4ffe6ac5518449d025925666d55016bf2f474ab13a9c1f31f2260728fd022ed566692147b55baeac711a148dc34af9a4cb38a2d5b40bca29ccc8a2422da7ee27f9da7b1787375274e0c44c77007a162f9c7868a071fe5817ed17f00e9eb6929e34ee664dc330131751022494fb44e062f6040c3c9aaa2d8af26760d15937803356bb30e0e6011eac0f58f20453839e75a7bd25fa5ffaab3d4e46c0a58bd6bbc5ccaad569eae65424bbfcf5f115d61eedb10e993bcd15daddebea95935f6895e9b1badbaa0f1821fe1ad5615fc640fdb9d0e122611d9f5660b5a254b85ad6c5aaa0714507f66430a5e06dceab45ed44f874d3ac0dca09548ff0209bc6faca878381af35c35df544d90984573aca749830d9cf2225b68d92de043d87579504a7944bf46a79ec57583b6698ad542f3002db1eb1d3d23dcaf045ee2cdc66781de5d204380bafb0bb582088ca7a833e0e3629af2645ef7605a17b74b6ea1677fa1df7a8f4898dd4a0a52714e6a21a483f8d907a1ed4aeab8f82b03b62c8d89ae6f18e3100b5d01c285a0146540c6977f865893b191496ce615aec220c890a1ad4299ba6c3f59f49ec004d11965b5a182182c753e3491537cb965444dac08e37a9d805ad75354dea2216868402a033213fbd5d6c80de9392f91cb596fde4d11d97769aafee6c10580fd7b08177220eafdc6ea8907b34036a4d8739d565e36e61b9fc6bfba46eef4fda390bedac8e0c789af326ac6832b60702513476b7c1e4760a439b3ec2679cd5bca3882c1da59e7bf99f4a0fe69878b5a489a2034041db14d8c2a7d368832fd0c16e9f7dd043049aa9bea673107bfcae8948a2d57963bce9656243b2e16f35885d0a8498cf522975e0c1953f3584f85c7898096a326cc469052c1a1185615815f3c9c78ce7e4a8ed0c8ede0c736c4afe0a33ae80c83c96549ae71dfdbb53f8b2f200e48ad24eb5de034376b7339aae2e4862b48f95fd85a33daea6aec928dbd253467f43366ab3114510acaf9ba8d1707cabf4f0183f252e493ed053ecc6729fcf2a510470a82cae8b6f5ad5dcc92300ad6d965472a0546492ce0b46f7e0374144ce5fb8aee6a9d883e8bdccc8ebbe33b1edc05ac66ad30c3bb567263f7804d7782e6e61cefe0827aa34c6d4a644bf85ed868a77d6c560738240836bae8667c74b3f2d9606df1ba6abb97b483cb9758038b00f807033da694a6a5e8248d4e60aea832b3d5719e96d1f1e2bcd62b57ff8f4ba9ae77c2f6ab794a7c778db2b37a1f9f98458a13950d49a3ad999158fe254e0d893dce78cc8452a3118d4d9e428ac77107a6d8371ee9c629a4550780f1c44b43921448825646eec6b9601157b031d8ccaaf2e19ba08b7ac78703cab4fb22137ecc5755174a61d475f237bd14b0a2203f8930fcd134b2f73156725370776de2e7726d5339cead0bb63e78481ff39d0f68918b7c4191cd8866cfd14d2e990d9fdc84b2ee79915347b166c4573da9d37d70a65ace8cf8a03a4beb33f897158097943f07636f37b06d3e22200b508bbee977260118d2dd05106239f4a2ad062c83757da959d35793b02d45eb90c91ed58d528b78a2f37aa301eee2cd0b5ae6132b698fddd964eceb043ca84c19f7905f7b211ae429d821941e831f43a31cea89a71486ec5cb3cebd7d8248f753b19c42aaaea4edd8d695b42bab6af4e0413893f33aa98963079687ce02bba885f40dffb8770d1be9941b843792262854580db73496964968024221696881179dc651b06145cef57f6e7319ea87ebae7b27e544f4d492612c855e3eb6d17d1e9ba1d9eb030c99f2ec1be685da055d1300a14de45d5750487e2df08aefc4bce2016beaf4d6759a5087a84f304cf5abe447f64987c1be279e688ef8902264b3452a1097d63a16c2bd9e46b912edebd1ddec59bef1f6cf46291f137cd97b7fb78a036ad064c0dc801314fe4687c183300b4cde1f17538f3e69ff272585096680bd69213c2a20b17955ee78d4c0defc49338d79d372a1308462d15c10d390b17763285ab837a70895a9e996274d5a4119015288437c1dbaac610a63c000dddc91595c550203beebff4f81984a7b4560bd2e251111eab9154e6bc583d69d0e8670d74db7bb1f5918316e0bd688f8628972dece7259588aac7cdba22eb8380ef01b36e7b08047a70cc0687a2025ab17cc5376168b42e1effbe77be447ee8d1954871a51cde06bf61b91ea5dd7542d586aa7fbf9d63fde46263b95597b8e73628524e26dde066b7e599fa2ce30c3de04a455ae9de78d8544dd17a0a1178d8b5fec86780b31538d3b33ffac23d84ada5ed95e866e177016478e550bb18f85ab1d1a5cd9a1b257fe4c7213e268e8c147814c0435f0f39cd1b5adaa9deb649ee6adc122b87b24d83d1201a07196f14da3aac23e3e4cb506ce52d4339473c04b0116087fd296fe2a6b5e4d173c268171934b359d00ea8d097a3ce60afd6d718b151b417dcc786361905c06c5e668a8de79027ce6da2ea611d89d2b8277fb1b731974895bc151afb178b1d93c5e76c0ab69993f2b2da11e6351164b73d15c68b3d0fd520cccfd4137e174e6a960171d7b3507cd114f480aeda0ad62cde96eda3080ce4eed0930572b2512614506256383d392fcc22f60d240fed5305955db84a72c837862a6e6dd055dea30dac016bfc2ad55ec672afed1caedc916d7f63cdc0e3fcd988264d0d50dbce035c9afc6431573761dc39d3d930c561989da5d59e51d8e0bbf036d6d5c46a7330215827b08eb5c98571a4282f0b6c8cf387ad42c7ee57b6bbd430aacbb6c667838aaec1009863ea1c9dcdf070afc379b96358e19eb8abac1bc30771762271ac672fe7befabe2c77970b88ae03b5c44b781c6f9bb2a2fbf49e9dbd88ae2de276a87913d41514838f0219cc8997fca59c122ca21da9e04b45358687b6139f43ba0eb01013740c978b9ece26ee25a627383ac69bf2ab58303d9ea1381b3c4e5c93346ed849c01907aa1ad6c24f06b2f91ccb3585a7478e8ef8e3eafd0c65408f2083612be8ef1cf946be0c01d601d67b31013632bc74d098ec7853728e15174a28a032b2efb2c105eb2d20af18aa0186e4839f5c55f023fed1589718f6cd50b4ab12773ae4a145ea6cf0ad2fabe4d957ee50b8894a98029ba50e7ad48bf6f612f46a21b41adee62b1110aeedabab8d0cc42e7d683fb7d51b208b1b39402a6d059f93e70a20ecf469df3b27d5304bbf4211d5774a1bf408c1f261226766e10e37be1c7026f24903543143966a9a0abfe9a8f445666653e5f52a5ca7b98e5da7ef528adfb7ca837df1cc677550d17d8f819d19334e18dea9479237253dac123eb691174ec7493d385f2d33b51bfdbb661bba6d3c3994159368f5ecd3cfc72afc5d114997f487ebd64f6305389b4592f5ae896c18ca5239fa993f57e109b33326a410397521c995bd77922545cf833fe20e37a0c352c90f5186da4a4e95f06ceb06f368b0823f73008a4102cffb0fbe29a4ecf43402ff14847c357a5c87dc82717cb9119f8ec53b6a483b946ce27c3e1a44dbd1a82c47e7780a018fa257c0a250e71c7167cfd09aca85f675e7ccedb51ade289a770bf9d8f3f2dc3ec526fdb2f16d788e4ad88cec3c479e7461cb6657d2fb66543855d67c43c54877e1286be63bd9b49cac529cf818bdcee544fc090c335bb273f9cadb5fd7b221d75bf0cd5ce03a9489cd826f5e86924949f9d623d13373835114edf2a19262bb4449b04822f708745b2c633651c8267a93a08a150003ec51b3174d9bf4e5cb58b2e5ae4d78e224728c13abae8d661e93e231f74928900ebb7697d431ce895ea426a4362c1493afa238c8a06bc3e4c47deb8fc346c0769d620664a0dafc8a8f0f6516b9efc60ac6cab716d2a6be805fa52c7b015092055b8dbe662977bac2c3a746373f3131143d49ddb04c2cbf02c70820bd01a36c78263e849991e620e83e2180582a111266fac90ebea34099a71b6e09e0773627265da1d977147b1299a964997af338aecf3bcfe525c831590b5221c268dc053dee40da9e9486f7e2ff0a93534bb6ac1e5fa2927b941b00dbe9677f44d34fdc7d245adbfb2a2ce83b9dc63119459536f707705d851c61fb677488b15184c5283e11e9f40f5bbc84f980416cefeeac210de292d6b39f7f64f749a3199e90cf56236e739645a566098706c67609a9c6b2432d458e77e5ed10b26a60be22dd0e3eea312d2cc310ca9d54ce5cf73bf5f52af1b056215a4e0f84454e50862aaae3a24ad711eaabf2f0700efe700307c028e9c6d123513de1878c26d7731546607d6cff0d8d56d66974384e2b5fa50021002f5a7a47dc6cc84b7ed1ff052efef76895b3141a761227a1764681aef1f6a8ba5f1708a2973d04f4869daed2c58594838f099e83acf031117f49a3bcc510ab2b5ba35353af45d901cc76718b4d63ec529a8207b8c15f11530f52ea42be330d617f3b8f0125ae0b4d121f413686b034fdb7f2609470f3c802ec42ad14d0cddd01dbb559e1cf1944fbde329a1b01c79b44315c8abbcb95b8b90a1dce9f3e33a497d8fb36f5fb8a6f26c124ebab7245cd57145e137e8d1c6ed8cd8e481dbf6d015344e85153b901b1573c8349bebb6113218f4a1d673e107ba65f137922ce0ea3a0a6d27244983ab8e91879c170a896e296bb14a569cf3ecc1db3841f234b8d29382716ad1644918ac32d4b70fa7b7c12139ecc3422df1253e113ef157f5f6b2faa1530ac36c9ee06ec45fd438fd348ebd0b52b44f9644213cb38f9908c9ca9124e800658e7b6f8fbf548b373e3145edcb9deb941c76397ad380e3d04f84f2b9b70bb58eaa29feb1c3bf879b5ff8984b27ae97abefe070cf00b7214dd838c3f9933a5b970a7eb20c3c113a214fb275fa18608a3fe74385d9563c55e9e63206bec9435f4c0ba1dd9a1e62cee0ffeb6c468f1989e031af66e2ae9d0ac373a3a092fcf1ffb98acdb084bdd2fae1e80c85e225965168fb24e89dee74d5ada71a052fa94294be1c98d133cd9dbf21d38e2d1997dd42bacc3b2059377039dd936bea83dcc00bbafa12c22386f2b0035f01af9133d5e8b199af0469e95fb1cdfb6aa3df5943ee70d2ffb892507464bf5834b1ba19699e11ef39dd30974f8fc90a4c4c9574d284c8265aa55fd9ed05341c3a0b0259669bc53e1b66d7b25103250eec775d5a6957d254e8ed836a4524e117d01145e50d83f4f58be377fc30a95e06d64c017d10b380889e9074ab690332672ef9256696dd721eaf145bacf425679be6dbe019a3702e283bd859d213fbd5d80dd094b9758c543d6f39b2fed90ef0119cce1c4f350e83131764ffa409bd1c7a6890ad0ea56c4f240139f0a5783c5d9b44deca5144cc2f35d2c017fc4b860ba5eb2a5c497521e286204a47fa10af0d83688fd9ad3b26d854c5de5d4e17b85e187320dcaf3a9bc21272ec209c1f60cd00b2209e8460cdc5d92a2ffd9375d95d87e4162145107a674d9e1720bf5bef502c7b119c60d03edcda81ad4f79d548608898f352dace0a7869aff5d4db7c813d114602e568073a349e7cf0aea72829a66eade529c8762c1809de7e315436b32e885f2c7460b0039c6498e2613e67463bc968ee3d81d7bb90039702bacd15919e1893fc36bad3c356c18bad97be05ab29c96e56447263cd72139155d7ec54de8486f80d0fceb8436f2d30625455c2a88249dd107ab242b1ce68201bdb4ba9e4828caa92302508b80681515cd179f2396d0d605b4dd64b6214a17647843547f525ae694f482c4c5e5a4e39c7f5adab52cfeee7b53178a38533d4a0fbef4192740","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
