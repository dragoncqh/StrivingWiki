<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2dd191cf4db21d62824066aa94e17fcc0140768672b6a10c1989d2d3a0e81a905897a912b9f9b3197d751e27e7743ed3769108329cb00b441165162939b2319966f62180fbb0d069cf0077eb4fed3e7108cfda9c67454ebe3e1238d1e2cb4355d961f2a6a349dfb9b33bee28312f19a95752289984343cc5e07773da2d9f5577d46d049c1b74afc9c052a06fc34055032f3fe258bed1ff56fdf427104dd516f3e4bf96b545492f24c7e4ff3e5b2d837cf11fee045f7f277723f1e2e2b7d8e0237dd22da47ee2b4b9823f28e2a5b886aee75c4c7ec9ac563bdf68d7b8698c5c66c425e76a563d1452196ed7e3d0c5ed56a38fae6c0bc03360e5a2935b8e1ba568048241edb06a3bbfd738b0dff0e51e55e08c2c8f3882055f1f57d3ec71dcdf93bc0e12f0a8ac5ffffe358a4ac2e2d7c3adc78a6001ec3ed253b979d496ca82a62f0ff5be8082221ae1d884b1056750a2f44c7f703ee2f852a759b57447321c044f777fcce5a512ab785c7787b3d1aeffb4d6492bfb93f729412db9837de51fba0561fe2de0422d8898d93491faed8d5c87b897eded343f76258d9cc0dac68697de19eae73306a7797dbb2b9033ac4a34cfc06ae836e9a05b90570de3885d0cba571afe019d683eaf529d51cc062a04cf0e53fd8bd4a1913c0d2dcbbb5595556a653513329dda968872d364bb909fccffc38a29fae2b6a6afa66953bfcaf9ca0be2fc497864142971056321abf210a3865b30369b30898a44efe06247c035cf103d745a236f0395b70688e7efa18c3843e8a5a80d81e6719dd82b2943ca29bf03ecb36a94b12edc15c61d6e0b75888119bba71aec7d2ca87c3e9efb07c7a70080d04872c5d1294ebe641d24c47bdbf01253ca40e6b1c106c64578d0e5d180514738e82662dca438401b8a754bb7c38b846969dc97a9d8d7dcc169a46d9126d06c2c7b9c02436f8a043d7e5259071497f5253bfcd28ef567aa2d8f749f6e15da24416e3d08e51da98cd2d148d7ec761ea0914ba09d1084b09e0bb5e57f540194952c8b5940ee3e4ad1bc5912f76288d0a7cef57c49d8b2899181b61617b76e983bcd666c0879a35c8d506905a067145178b985dffd6dbbd65a8efc8df82f32a48e771dac3474da25fd9fcbde6232f112e7c52548aecca6b8e07caae4b16d00c50583ab40b4cac877d295e277f005eccf6243bf8345f7af46548b1975ac6ee92ce89f16e4a65b925de7ea2866cc3458d2dea1ac5e75d36395ca27134ae1db8e46952693a1b55a9107570103ba55e8c292b8012281ffd7d8e3a14c4b45832f1e455a5072f36eb8345cea3b14eadb0febe2991fc8e036738d9368c3e501c5bfb6e9fb89ff4618fc086b0d12b4860649f8519013e64f248f48624a5db22894dd359937a5e1831f730581696e940e3223f3f250dd68c86414d0378b7777e2870590db31d3aea429f0abe2757359122b3f9cf01c4a06543d1f10a87710065534842517e18475daaf593225eedec85d22f3cd9a78283421d6580029a907d724f455fe21433a0843553acb4256026261275ea1cc043f6eea162e3bd8fe171afa6ca95f1b367ad09ba9e69cdd1563c598db7bd5a08152d6b480cc5e51ecaeeb8c8bb9ef14544c01a5a4c7fa1a9ae3258385a6f42119d04876b194fb0c6f625ad68702cea70b142d257d60d4d3a38a4935ed60cfe571b49d46d36445b44618cbb03df1c8a0577e5f043833d5ab5ee66d95ef7f5635749ba24e1938b1de3b462b6132e77f7cc19f28f37c24858829d805a37875a8c4a112b76b15a2a165c523168d7509de719e8691b3633f160c11a7cae47db84c1a7816ef195ac19763923f270e36f19ae7aebb3cc88a4263fc511020d0da03029b9e464dec22cc340914ffc71736e94dc596a5b3f8f6ea6425461bfa5ad5bd7069ffa4237dbfe8e019a42483a1032f464df65aa227e9c6707dadd20a570246ba913a9756276e5cd48b690bc2a91ac26ae1a74990be179b633a991264bfa4b9bb7d332faee0086cf67f26db061e36fead5cb846beed2b5bd95640c7de7a73f5961d54017ecbddbcaf94ea8c80d1e2bdb659c90dd0f6aec63fdf6c76ea84964dedef23be7b1dce3a8cd006f244419e8b5613d70787369f0cba9d4d96cac320646234fcb930acf722e41885cdaff7748595035ea04651b37a03bb8774a87cf3b1d1bd13f6e7592c528b1478cbc4486f3bd121f61620524ee2717babefb18a7121983a2131a1d4183b5d16c99911b74b42c7cbc27c9dd149496c5ff7c14125dbfcb5ace72e776cee459fdbeee043212a0ac7c8a20f726093bdf2702acaba0a3aabf25d79917481aa868bd753db935da6c990b7bee18f54adc6fd8407c61f367d4be59f1d3602bd5782ffe8f78ed62dc17c7b2a55be1c84fc3b95a0bc16239f20e2d1256f648d05db3bdb484e7825d2017385c71d768184ad01cd55f32f9b79db378b62dd3dde494d170bbc92500bbafa25eba31f525b6d7b6952c817824b2761a5ab83fa615a5085ece0cef5355dc8d3f9a80b1fd5481ae65801660f6737cd734b1ebd25724927b6d4930a531a6b135bfde8022d756d41c6e7361130e3edded09ff9b8230ce45736d5261beaf6d38e18bd2df96cfba4adc70b69a192205a8eb0c31107ff443b07fab6ba0d0baff46de6884e9e4544832429efc8c27107fe138532c98b8a531f42c5ea2e458c4d5eb7cd6cabd193f0306f35e24297f0471d2fdfd9604f3e94b8ab7d1e9d66c2f1b59b06f60c5d5417c43f49e24c79b845702817691248adbf9b3b6ed5db902b638938151fb72ffe1f7b7bc17fc3c89fe7f22fe64c07ef5de8d6bea37d1ff9190c949331c1a94898f257f593139b25c0ceb5a880f0fb61e7073fe4d36100fad1426fc6d4bb74aa1f64168b3383044384e31bb152d0b0ab04511198e3b09a8863e0e4baf758aaa80a1d3787be999886391811f91b001822cad897a8d7c28bd468e2e829addbf397621a22ab08d1e0287cbe4ad1dab6d8a6262c3a98094f0909245a57050e5f14cac46e69e1427f0811d25e5f5ec5e437bfaa9420549805567e93ecea5dc06a686aad73c533c9a7ff7e55787e5335719411622253022530175e1abfe1013e535c81d39146bf43b7420fb38c4f0afa120f5cae7f5c7d916f5e072a0cc4e36d9c73e33bf91d0d8182bdd72575701698b2682d9820c04a60e4dfcb68033b6adc2f888b16d42dce81b68af0b95edfb03761b473f081fef146ab553a5598eeb7034c90a90e0ba913bbbe89478a3f6a267810947e35246e342b44328d1feccad2c55ca60035c778a48e8d396893a71ab21f8327b081939b92d5ebeb21010b337bd663f943b7ac3421ae5a05e05403b2ef38ed4aced58eae84c815d003ef145e87902e0e90d425214248b825bc0938b4483e29c314cf64c80ca1f33dcaaf0ddc276e519076e6a755b4fe507b0680e02cb2611e43fa45fd95e77d5b12cce87e096faaee01d12ed5ec03f0453fc1b35d0a0ca7d9b705852216a5ef9bdcd1feee87d14c6e0ef01f4da4ec5fa73f5722c3a031c2610ee2a731ce448585a0008d402fc73677c7973be7e2336af655b39db975d20822db7b5023316063361c5be3e667dbf852df09a8814d10bca3741f96bd5b2a9b8469df3c588fafa0ee714ee798d8e8ff23ec995dfe55cdec2db5018d71d64bd7d5b1118445358898daccda1edb98275cb4b140aa8c5e7f87324adb87508b5386efd61c0b192c9df8ba6363fbb79e8dbb25dbc0d8b6ec9e83219b4d5fb2b3a8c86b148bd1770a83410876e1a0c412470c9c486b3ff78cec215d473461e2f4fc0b39533d1c90b4121620ed9e49b428ecbeb02e38fa5eaa70861c93f6d748245566096e4e253cd894880b724f105594843168ff2a3f3ca1e8a4cf24b6ff2e5287bd137de973cfafd412c4257463b40d09625aa4e949e9ef89b6891bbe3ebb53c46638dacbef0b00708ea0437fd9bc5cd245ec146ea9bdf838fd83bd4f9b974ec9bea5f1387d886415cd702f3066dd422ae444b19f4b48ae31eb46d1476033ab478d3ce9d01cd6d39e4a954892387e2ce98172fef5fdea4bd67d4a3979eddf08090bb281b77ff50cfbf10bf016adee293b6b99dcdc0682517675346ff935424e5023c81cbfe388ceeb9e333fdba503f021243e844b540575bb13f427bfa70610f8aeefc2e33d5c0072bc41317ac902838bb9e923b787b1a406878c19a19ebddf5e66e0abaddfedd96f6db622e953925a929f713520bd3d7426051e3438741232e3e6c9e526cb67038ced9f30611966b56f58c0946be5f2d4f67fe1a1e20740966ccb4bb95ebda9307e5b238573d5d8e5796c96275009d65d1274c0ffd7b7ab8a8cbd7253762a462780d66b75a3809a5ce9b6d02df5e78f3ac6ee39acec4b500dcd235a433d727f59e6883ac3552f7537b95f744351a8eafc94c5d0d0bc4c983717d4e8a0cd3b534d8067c1f910145c3a396c0f15148edaa016469f63d0d14db17b09d86034547ecc99004f763b5204c5f3d19061d0e411d778b64bfd8159d837de956e13dacf106b1908aca8888745baa706dd0b069deb942ad1fe71ba8e8104e321843f37e55c80660858c23c4d2ed0b45c7def82e66de28fcc00273f6ddd6fc262164d6d3f4ef46d2a256ed836ac392f86fb3af21b2a641d8004b22b91c10b7e7b9cee6e1031159dff825e3f3bfc8aae63fdcfd66f57745b867f0538ffbd35a4587ab598745e325e47cfdaccb072a77fa04a766418e268e4545316fc777aae5abf05c406f63050b0083f0d0362addd750ae3eb6baa767d8ade79a5913edd848709792dcb97bf1a71436a62a909b5e274fa049338b7a046bd729ab95c6b502ff8a5fcff60eeef2601d7e2f041473d3e87eeec35b9cb3a45e14a4c897787f725147c9bf2bf05df044df27580bb2522f52f0499f06e71fc10f07f8b3af6d69470ea7d2f533dce32821ead23bca91e103cfe7c88e9ae3f4fe8fe85e994ebaa63405cd3b03d62b6fd1530f3e8f6d79642820e9c2c3d3f9ca7ab4720018792db1b5f5ee5c5a35952945e61db0cf9df658c5381cb297b433647d009d02e90552b40a8c69abf01de971715369672bb4d5ec9cb2d87ecad690a22f4a965e840d78f3c7b921a2ef00cc58352e96472a42ce34c2b6eda06e4b2d4b245844364da27f9a7b0d91f72834a77cf2689b75df87dda06cfcbf50443afb180e9291237209bcd49c1608dc48335d9bc7e09eeec51716ef9a13da2fd79ed0b0baceac5c996b9459ff11054e798669ce9db613ce8887dc3202b7977e223559a652975918d3336b74e93a1fc360332dd358375cac7bf919c1e9d373a135a512517ce2349bd5385201597ca7b0deb14994a54af738ad9ce398e364fd1195c1073654e1cf6e16b32a47e26dd9b6f8e98ba6b37b87f2129e470d7ee36c2a3e44443cacf2eccfb18fe0973df992c5ea38cffa0d9b3ea4996304b6437a6d5f13d41bec4cdb3e230f1a01b334ef5a7e6e00809a04e6fbf177615ceaee478fb862f690483d428133af904dcb038f3aeb5bf0769cc86fa25761b573918ed6fff4c1df215d2b1a1fc97fe322ba76157830a2ec3b810838cc9bcdbc12344c38561425d95101a1acb179fa2a0df45220a56582840225f15031f43b734897545855471633c8203207993118afc706c2f4921cd8ae98f0427805528eb67636ee375ebb72a4e173329a845f8235c65d86ad23baface30f5fd34fc69c1b237acd23802f7ca3e36019f5521273422e61dfdbe975eebffe8dfb557b156b634b3531b29237b8c876c4cc682a51a2659f75bcb01af238278193e064e60627da5ac71e3dea06668c2b983bf8637fb13eb14ce3c090108fd86f5093738b379e66ae9db90f85bebc8416abcc4c6c51826e1a95d383acb83be3ff4a99f833606be00a62d0deb2c05b7324d66dc903219dcd68a96610415f4df65eedf7c5066dfe394158fe599c8d1e37f9544402099b3e8832f7e842b9748aa94e8145a66f4e9b8556270f7efc395cf5b35210f173e116ad87ba3a88f294c268ab33d3a6def51e04be7b072709c0e3d734ec0e59063f255c88a2b5bb7e7eb61649c0ebe162a20eb49910bba6f9618d8c30189c5fb9757eaffedff97bd55bcab2ede9c0c5877fd8fda77254c686b353e24a57669b39724a765909f1808c14f46142d5092c1f32f0d8f3c29a7c49f7dbbf5ecf4e832e8c5aa6be373617a081f0a05bbc9e940e3252754be60ce8a149e4760b2880c42856a5731f4a8ac327b2b146a4e74db3704bfbbce50d4934376f88269032f57e472cf9106f6627cdc220765f7934c207c1d99290d1871ce08a7248b3db8433de705aae632b491fa83b63eff8a4f6139cabd22eeecab65a81b12cb718fe2355d0bd4ed3a8efa8514a199ae0cf4f69b7da9f5cdbe3e26234cf19c162c60c0ef53b53f218f4b15ecb5673473fc541f2b069a332819d06a75ded044577222e9423e528b22799adba92dbcce458a8beaa3392e685a0a4930be38c04a2acd3ab21d1c823be8d92997adf4f2a8d3614a6a5755d471194328b2abb8541a891637746d41b798827dca4878d3d09a95d74a458dccc910344e7bbe1b222dc49f8b837383ae08232e5186048972e552e9bc8fef948652ea098b109b32d033bf5f304b08bf259009fb18aeb7af05976901e7eff7f187571243976bd039c4ee8f3da2fd2f445e7fff610f10f22e454b8773b0898fcc491b1dd1ed3ddbe9810c10c09f9092d5a3c130aa704ae233ed5603a7ea2dcb0d2bce2435ca91ab5fb61304abc645f3086621888c95deb4a78c82050b80add87fd6fca6cbed3def898cd76dd06f358ff91c08ae21f636358bd7633249f300a1d5013714f2053d4b792fe9234effbaec5854c9dc162d84af86bb5fd0f2d007e2f1c8510fc3cd23db08443118ddfff02d79b71b0a75c6c4088ab3443dbc399d8982dcbb8cf913c79e693268e5047aa63f1294bb353d416333d26c7976fe083389c9cec011092318cebbb89c2a29380d7e88bac63dd0105cfe6f98da5a82b445673ea98bd4e3c8d46dcf51117271d6809df4dda04773c1118a55cf1d0042ee849bc6af557a6602dc49565eac4002396648afc58a4c3d2e89da8dd2e68d09868c8dfd47d524ccdb576a2de0ff3ceedcf05531128059af95ff1f7ce78f9fd5ce5b0349b3422eaccce3a240900e8f7857e1a8225c05008d2809a111063be4439cc11d71cb1a8a368c34e71d772f4c1261719f7a5f2f34e2a68bf7bad5d7a2995b7a3fc9dfa3767779865ac278be0155921328e44c38cc0ccf6336937c2a679bfcaf1a51972edc84073f62b7f08ccf2a31d03d07a60ee1c4ba1cff4652bc4dad1802a5c40e2ac805dbab925ecef054e73bf490be145bc8dab571ec68c7e9677b980c00889b90a8e34819fbf9a5e15d0385914e1edb413db66aaa0bc957277e15ff78d8f26ec75919e734ecccf492ab097d278cd912f0ac05859d53e6313f6f9e294d59ace3ee9bfeabf54bf8e22c7d824d7e6a9b7360a76aa4391f8f0a5cac96eda5c92a5cc2637ffd0e927a8eb22d33df3d7a448671cfc3164a3f3f06ed5f404d568483b349453eb0ebd7671817def58b48aa6eaff739f843b7a1ac2a1207f85ea21546a75a9e8d191c7b5e9ee360d949d0ef8fd5a60c4ca760f30058dd46dca1f5bcbe839946f8cfd488dccfb8349842aa7913317822bf46c24fb2ca2118f3ce6c7e20d982f8c33824f7044378e50048a8bfedc2c695326965b8896936d1e5f130eec2b99fc34a89564e187c7328de5708022e1984a3d8c5c4e05e0f26b7023fe5298f58b33e087c38ed45293e715a3e0a97d656c424ab553cbf2bd42f6ec54da49ad8cd6b33e7158ff4eb15b100786828ba61d074e40e83341b67c012e26845e50442729e396fddcc7e7fc4f11e2b26731f54b50b5adc54bf14ba52aa515b53547481a426ffbcf1ec6f1bf2297cfa0c2b4b58eecd10ed65bd6a32908d686e12fc506da958231124f9892f1c26bb1a3494a61dadf9881b03d850ca6660d9712199f68867455755518d04ca6c980b86b98fb90bdc934584d693f55616b82d1c7dc15e456a306eb48ee52950fd6c90a1485e7f201734b38fbcdaf808d1c766858c1b0cf335ab15a5c6c5ceb119a13aebb940734de2f2f64d1e2a3ce747ecaf8c0ffff7ee16a8893927a47d5ccb90da037117310c07f3faee970485a4519ae5fab95aa198e6d157296f0b286c09c457773151c4e892ce26162ee958115a03c6560e6287f805817967cfba2e80187f795a0d1e773cad90a620c473e952ee4ca28034ccbc55fcfc0ecec0f6f87fc55a58e8cd0315e1cb3706a29e4a48b705f54b23ac502ca7616c1b807aaafb2bef558faabf6f99d46d86dfc37cbd3b2fe863599e17709fff4a2379bf42e8c4d6d812f3779f0459aa19226a00bb48916e7abdacbd6ded9da1af23acdc318e87620ae74a21b08fc5fd999f4cb521eb7bf38bac1afa7983f135dcc1ac4eb67ef3fd64586bd92a3393bd880e32beb8a890c49cc02f0496a0d5a80a248ecc4964979a90cbfca4d0ec9e25e8de3645d4e88df6b36b79c8a5de30b4b9f169dd4391096faa4413a4f8f9bf3fbfca6a087d1107b03c3fd39b7d1a9baea3965cbcb672444168746eed646ea24504e3d5e6e399facfb00d6cb004979b27431795bc453a49db1ee46108fb63f57dc01f33df9a6bd50702434bec128489302368309592ca7d0dddda50f88a84b99f8cb2ed42bf8cc42856e3783ac37e202fb3911c86c82333456f80e7ce14f93184c1827b92b597f10b05f425f9796a6ae7d0836d57a062e15aaa9a760dc210cf172cb0f961bdac8fda271b382def575d3580321cfadadb9ae7988c80bec2448c994c6d506942760a32f55306e4c2e248d4696a9efc382621ced3cfe41fdbc6c668afdd92b6c6ba2347547bbfea60f53703540e2021df6dcd9ad80af14db2095f7da44cddb844bd1569e44f67d5ea505b4f74c4d5816f713026b102c375f334b0f21e5a18549ed80c56993e968208978bf4eafc8e7190b9661b86987b004080a075d97b1d688eebd078b3a1f80378e1f558fae1eaea456437f0dfbc10350b52c356f4779b4b5b76889994f9bb0e7ff3a6c2aaf81b132dd7747b2c8be72eaad659361a6c741628ebf80d94a9118a7db5a0b4420a624f44946303401b8219cfd1cb97f4d3b30d90d4fadd0d3ea1e02accdcb906a87e670b9bf1d3bca03ef3c774f97d63f55f54dc92363e5e43d1cd10de33fa651095fe9529382166a306bcba04c8485f59a7bbda660c36a8464e7dcc37c97a5d2901bb329e06cff7d1ff7e090bb8c46a77b9a7e3acc7a7f11b3a9d9d7761107dbc1bba1c5bdb2fcb690eca8c1ce76080690fc6814eaefae81d94d4f51973e6b189b72579a54ef9250a5248f3179bc7367eeee871a63e2acaa32d42ad827715c570858d9d7492d0ea51538bfaac483736490b75ded6a3b8d47c9b50fdebe4e2666e8121b53b3474788d331c891130d201e7a1ed7fd80aff23671d0440155b382bccc6c86ee79d8448eeadcd7237b13d15e719700803bd9dc8c63fa81b27f7759aea4a93ab30e73e46ae4cebd9250fd71b66dc6b99176fdd7cf5bde34e1e40d539d2f4db7fac181a80349da94f22e23996a2577405bc530891710d5958024bc94fa8a5d63b83c3773de7f0dd5d618edd1e88f62a7754f67d1dc83f51450a6050cab42b29598da48c6c699d93db422a3af688123770d80ec599f2c475dac5ad5278b83bb3418b14c7294c9371cc1e31e88907da1a13201aab86265c324ecdbb4b064e73271418ef2fddb4a9f3b99668ed334d487f0a04ff8a553fac33606508dede9acd7c17c3b8051c34bb3e644c2b2b79781dea4870e9943bfef12de6f4794528a33b7639b1f2f09763d72b8600d89ff06b175971e6204c97e91eddfb3fb85d4be93c454ad9936f36b052b56ae643aa207e2713fc8895bc48fa2242145d9b984c3e563f88ce54880f9824c2cd9e95a9fcb07a41f460e2ebd7cd4384a7ee024e1a0c06486e7253f2d8de684d77e0cca8c774f3f64338a54ad03cddc08bef006aa1f509b179f75eb55cf177eb4cb4bf9774433b19e917c85483b03e9ab007dd03816e4e0e76717f0f1903f21b730b4648c03e2b76680666b8c5c03c880d42a4a9e09793222d30fab6633455aac3256b69b79f283d0e3eb74604e75a0fb59a9f1a59a7562ce6f4cf8ede0e5d9ca05bfd12779620046e418c9abc2eae9938ac992b4b2e554606514d9f1fcac1ee40bbfea0190977abb0227171d4bd5f48b06272ee05ec6ff38dd29cf0baf46fffe18182b354470504da185e78e2b08c870507c1634eb01c02ddbc3c7bc3da1b9afd030f4e9656521597656eb785037b239fcf35855fed06855b8bd0ec494b687790bf76a2d9fb25860a2ceccbe529dd001c7a6d279a8c3d4ac7024111119300325205584","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
