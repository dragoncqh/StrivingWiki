<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd10a32f95259995674ccfa63d0fdc0f1493a6fb805b1bd9785969d8c494e9aed161896e4cc84a80b9ac8805c1f3d8369655eeb4b81ec4ac17ab785304000f946d03b06b01353fea14e4164237ec9498858d8c8ce06d64c681c2602eef270d2b7bb2578e2b2e2ffc49882a6746ae3d6c39988e775372806c45e20e1d5ad4d4d692cd80ac056eb653bef14ca0829ce065b260e7a56e823e148c97d134f9f8c57bb1c345d53b280c1becbe46efc6de14a1350c837258046ce0e369b3d1ab7a2002d628f3449af0ac5e69c498110c81dbaa62a62a1cade651d2025c41486413b68418ba007240d342ac93ecf2744b2f0c8f48d450d95411f4455c6a4a953cb6920d73c6f834fc61c952eb75f4c68da13648b28a0c5bf5c3755da51a657a74ecb8290e03429639950461347308d5616ab50a58faf25ede7331562c5bdbd31f42b5e61bf26e38f433aaa9d262c14aa8698f77350b5f7b06017bd0472c7e5bf2a71164843ffe6e8c281d31ffc5a8ee7cbbe12c8263c6e4a7dfe9f8994e3eb47ba8af68cc2e9d8e1e389f1ecfc53c2b221edf297f4561f0be31fab162e613c90e781e9420ca9c647e4c181a0a3650cd960d6af93c1c6dd1484acec7704e2fc406b31e69a42d39e695f51ecd4182778240d478dc696721198c86033d3c513b3d4f2a9225a400430c0443405f493a13b5dacb914c8cd27316668814cc255caf7d1523ac14a5a007ed57644cb647404f43acb52dad3bb720ba269f620c2bc2d4f4b3993512e99d1e401daff8548804cb16fd0ed7edb427ea20cd262c67b47ac1ab4ad05730dcc778b2b3ef2a0f021b6b7b5e93d1608e0fe3b86c2b121d7701ca8a47e71b80f4e73a3f075a36c7b3b5c325b3fd4016d3cc9f1c7f5e1334ee22868328915baaa8f5893b1cb73b16c3279a9fa687e9d26d744ced499823e18e8131e597f2a4f39865a4726d3f7ba5b9ac15b6ce426a4886d9eef65d93092146efdd7b8c055a4f80c5d1d9931b099373b7a6c4675c40c6dfe93932e3eaff706372024196966934cf4a676b02dede3927b6e59f4e547565efa96a930d50834b5e6a00126bdcfc0b23b42abd1e4dd2cd5506949428cba3b6a19d436521101df536791f4116036cbc1c2fabeedf08dd90e5b7c5f1f26a68f7d49599a2070e2f64bf7b8e888363bedce72cb758673308e8f33b4467ef6262777f470ee341cdb5be2fa6c3cbe4905eb91f6abd5b6074759ef039a4e9226448e930a73ff1bf8654c946f2c61b9927c3b7792af2696cd2f6562fb39f82794b5b649e8ba7db1c7e6ee33d4400ec66270cabad833f3c9394aae17b93265ec4dfd63d892bf2430d6b4f7b47780a4e470aed1a72ca562cec2754ecc68a25805f516ea569f9e3e71f3a76bcb398a0a3b4e09ba3f047e7450bde6b0822365dd64ebc44a715aaf978204ed23c25f1654c37121b980a7ef9877db114ec8286898d35fc47de310679dcb91b45a26476b79d33eec85a843d45b1fcd6e890fe813d4d3207813e115b28049d62ef12e6df19dfceafaeb963cf88e0808669fcf11961dbee34deb5b7a4ed6d749be741d9e5c03cc2bfa0d68363d11177682d51f8dd6553364277326edf8a33178cdad45fde035407a32aa33bea250349ecb53fac804014f695a18baffd4464de3375de29b26db97c646218765bd1e8ff5bc424c1f102f3a517857915e55cad7ac949b7d0cdca40e4a31c7e43922d5c2294ca9da5120e5ee713b393692a5207a5ad4e423e7413ae843c1280dedf8f0c0e8f2aeeeef529ff70939a2a6118e825f6aa97f1125fa9990f5717f232516b6d470ee45ca6f267a9199233b420ab0adbed4712e6ae3797c3147f5eea38aa84094d20fc37439363ce1b8948fbe34fd545cca8ee79a21f50f093392d8d73c6e3868f11ec7ad1f7a830f4941afff9bfb7881ba93667799088085c7fc930c2f0675cb22a10e8afe43bbd369da4c4a3df4475e0ccad1ee4d1d2f39d5215ad03c0898b8b534b512aa53b66ab7e90b489c5fa799faad55a98c627907b69489583142d6cee1b31af57dad2bf495cf3583fb9b2c36c9ddaf44285f8b721f6ed47570b34282b220fbe59b5a41b58324ec99c474029d083bcd3b563fdaa43c6cd1184d6fe6d2b7ade06044d06d137c29aed618c5d52c7e35c56f6a2dad497b2b59b67fe93db45f22acfad60ae728a71e96bbe3bf619be932aa494288f9dba0351aae218fad8d8afa56681ec44ccecfdf53af3fbb3b535fe7982ac3c063dab73bbcf91f7b1e226dc64ec420e4d2d0d5f2840ae56b0c38b69f82d5ec664d9f7c7296490559091cc9203bda7d93540855a75326c98248d73d0dc4008f5f8d3271354a9eb97956d906c2763b3263362f9e99527dcc63f562d6a696dbbe107d14276f2bf323ba2ca418a33a95a97c92c1ca51d0849834139490121f5dd10d46a7447ff292043b5b68136afe547441ae586a474b8ef585022c8a824192e31ec9cca0b579c5c9db104bbb7d3a51c85c497c366223766f7af9f06b5eddbeb9b8b042dba5c89dbe9a98e782a5602fbba4fa42a16df5fbeb8f5680367f8354399322913c2d3b4e461337926a015f5d7c03c09e0ca8faa2e17f0d24f70d2f4bc766178e59a94871f4a5a3d14f95f87d50cea30be5b92a9b11ab3dce8ed3b06f1dbac4391f5d63baddfb46be829cec3e62df333d41477bd1d78b29c3544f6f4e86ebd1c25ea1bdf9ebd7ad264811b362773b224b9d38ed610a7b5d498357b757478608521a00d0481931a5a807ca462aa9d0cd13f97e21aeec507963e66169cd9a3d0c803cb0b3a76ca3002d3ba7d82f9d2d8d6e0005411860cf3c2d8c098bdf776504d06556395cdfb2e0ce4c2345ca4cbf99bd1c63a433d74b271e1c462f7a58d3aef72608f0db2f7f26e3e9545452ff6a5bdb74503146f9f573af28c2b30a4d1ca4a6bf4802516724c19507dae1336282173a5dfcd9690a675fe7c90ec0a9764f975e32ec8d95eff6353862d6899e672763e611620a556faab5c6f0d8bd66f2fd07718469b5ba05a0e498fec7c7a74b632acf031a43150bc22cfb289b2bd42c97eb62ceb0e95582bb8bf7b220f6bd80a985c9ce624d40ea28abf7f237fafdce9482ed571e25436e70ea02ffa92fc65c72f206ed0b7901d4498e981c516c3da34bea65b024d5474b4947d80b7bc94942d32fe3dc0f7701f22666022deee7312eeebfe73a336464b79adbc4b4641361901f98bfd0178013f249b9ae1bbc0bb5e71b4d13b140ac3ebd7305bcf08003b67df79e6657b740c96e0ba7f4c1f53d8f9d376ce42646e4d38140e4c409913bc1180f8f6f5e8b1fed2aa12f12e41051b8e7603d09edab541973b89eb2c945211ef0326a88c1f4f043b772d1cacac236fb41146d3185c67e144664b84fb729e75524c5fb4575e50e2ed5998827f7ef6d9b3d0d396c956441daa434dc4b5d67435431f431bccbb1cfa78d9aef5385e6682600bd3135a2bedd4e0af257c576f532fe9ef549b59bd576a5e5bad7f644ec0f14d3453a81e012bcf690ecbac5eaf09df1da5abe5aab06cfe26452bdd0623f110eefdd369aee65327903614409cfa14d43ec56e85468704a86b172fe5e0cc32759169d4333b0b0d4d270f2cb1241d28d99bd2014a233972191af924f190eab9c4934b195d528abb0c2658a7ba5b57cc4d05330d602356d414c3bb6d304fe14b78ee0364ccbe44d1f1de7877476c54bd1e807c11b39064d0bb3bbc6b0a9865b4caf2fc89ba357e325bed37e3483e20d70a936d09f25dec31b2caae1aeef2650b2a8dca99ffe6c6f97c0c330e3d3d493f5e6a64552150f84085d0c0404f430bb2f60bd2a4ee1bfe2b8eb4687ec83a2e4f32815ee81ae661d9b7765db1729e71b6728932c7210a6e47d5520b80a7b73138622fcc2a27c1bc1b29bfd0939fca2a243d7bd8fa4adb82ea1c5d364d8bdf039c106b21d6cac02a17d0c7c50dbd3940f2b19653b0e14163f174c0171b3fd755c549991c878c571c71cf7b1326e1c832b6bd4a81c092c4d12b536b264e9465091153832f701d4aff858f648933e1bb3daa1fc17de7a79224868f2cea598acedc09ab14922a86bb95817992b7341499db98a3bec098c378a7e67b5051d57a221fae7f243d203624678ac9658a0b596356476a33014bf7de71f95f47f1a3ff143af6022c071ccd6653c3273463a7457b1191ab4be927765b8b58383ec9d1744b6d091b3e664f9f8da47bf65838b9e3cee1d0027577de88d97e43279fcb4984f504048db6c68daf1225aa45cef4cb568a0e07f01ceed3628e5d934060abcfb04499d7a1a7e6d9986eec2375a9cd202ecf0d2602a6ad7fb56824a8c25515dc6a40334512c1d1a373ca88913b30de3e53634706b4ddd202589e45284915078f977113f21243e666a74adaf6fb04260bc1c80e4d3759de53abe28e72a173a6ad67e0633e4cb8c7630ac165ab3bc6ffa10f3a2b47a4075706ca79ed0de30fe5d1c6f68a1ee0b38cae5f5ab5b541047c6bce31b1c647407e78b5f7405415401df6f695d0a1d831bbc3eadcc07ff1ad8df02bde15e7410abc8e089be72be2b0af8e08b871083dd60d446089639350119a2fe4542b154871a2ca6dca8e4a46e9d8a2cf6e9b5c68485164bba90ea033e7671c08c0088b64c2eb6a96ae2b565acf665aa370e763942aefec2ec8e88920a50aa395c2c39028b876178bb1a09d3aa51966407264d240e3d33373a2d4d2ce9a6fea1cd3e5a0ee58e14bcd757b290b145cc0ebedc4b3df0fb7f391c1b92dc73501a3763520c2acbe20eb815460197122c56b9737bf5b0df16da18af2a584329935d44251e3b6a921b4860718d342771f26db8ba39a59891e33b3a12997edb58bf44f73b4843f76da6f4aa288c9d09cc77ed01b20ea685afdb28a0ec67fb96b8d398b78c37c740900d12c44d556be5e6d57d73cb29b0b27ba9b9df1584055262f93c1309fc9bf7ed5f8c3d55f96de2ee3e2b32e3fa004b58958e80fa1c6dbaa92c36f689115b89dcdbf88c5c68c202dd609ad78b51f634a7cce4377b20d13042efa4aca7261ab0d762e9d275e8f4338018390a029ccd4cc3b8cc70495b48a349c5826461e0e1fffba0b8a662f807f43ca5845c88cb5874d64ee5bf9732ee9dfd401737c3dab944d01542da3332d2ac0ea70e393c28cd6dc75eda0a2935ec065108b298f719aba962bd848c670792cb140d133eecaea4d9de58958c06d669e9f39e80c9f0c34bb5cee136b539fdf9bbf53e102d7776a785027fc66ceded7291336c99879f657db29962080fc3eaa84ebb372ca3cae76478f06bcbc237767353db7237d40ec747f916c9b7154ad23db3ff276c0760d2ca62868de540fba2591ab872693d748d6a86747bddd5f64105cfc1a295a03a52c6cb5a17cf36f98b7818ee3f9d2a0df52c49b454fa9f18548b74f5b823e192ce3004d43df89b320f96b4449c1a4553099f4b1fefb940bc9cc603e0d004b4eed3230662d97cbcd414613f2fbfceac93996f271ebf2f028f80bf4a996205d23b7095a29ec36f1b8dc2f12ef3017b61e3495c1965aba2f755f06f22cef4188b3a593f9963b4b781a24a746c780c43d4f09765b909ccc8b4d37b2f9fe511afe049ae160107c25402121b75885d1214ed47b3ae3590bca0d50ffc05a776e8c94f7fa69d920f6b2f1b5b1fe8cf3e0e15f5e3cc09ddc69cf6eeeed57642711e605dfd9a3092a0442bdc171af7f4db6bb101b5c7a17b67b2fa1cf30e987c5fa21af8802b457c781d290076eaa901e7923ed518e3fa107c07f7b323e4d49478729d5755fbcc829d8ac78159bf168dbc99d43cf508bf3391223f27ba1855daf78216cacdefe188314a0ece877d96791ed6c2bd7d115016f8d73cc9837438971ba938bef86da3c194ff6c05ac6b1c16db16997bf7447c720984cf7bb5e29266c46c64a20d7ce1612241bd496c09bf90808ee10373bbcb692dd9d86c4bfc65c7c64fb669f94f3e366b3ef66686593d1de7b37bf294050f19e9a6fd9b2af1e7d856560cf051fc68a95ff207bc6214ad81d85c1a4de293b5704ef024ebad12d6facd6294252170025d09b0ba0bcb238ad18340151a13a8e9786d38f84599ac7ea2605ae6deec96781b7887fc0f82c85f003918d0b00ae95e18fffafec8455b51617d1b717565a34d476fd8cacb3c777973786e83edfa0dcfe7dfd50520b3c995eb6fd308878596e074732c0162aa2270458f9dceb8073a026d0e508f2a0a8530af22e5cb20c66af6dfcfe5ec0e0e1636ea1eebf4360be091fb61ea5d84117c543a00b88f7f6a44a1610bb7455cf1feae1da0b94a7bd2d35195dc75d54d2fa8b4590fb18dce0dc8211300e9b4f5f2ff88308992298477f814ce0e0115b6550ae6b69ed844878f357566260bf1369f698ad596ed32d61fce03cf6ec736218b1b6c92a209b398da96cb7bc19fbb5f7aea28fa3d0deda0f70d4345b31af78cb70726feff8c5f84a73abc12cee4cdbc31590c533293d15f299edd835cc0d880e8fdd47bf97cfbc7bb7d741ba5d883319234a4513999fcc2908b5bb616d4f957d8973f2b9bf6cd3ed3fe8de9ac36692960639a82421594dca89f40344c0a99565cc7b2ddfaa17d2896cbb3aa772c62fc01d7a94b723383a2c31e4ee44e76841bc06b15e7497ca8cda947d84d9c47cfd9dd7f67d2eb65eaa6133c39a4a980d92b3d0512edff1bad00ecdc50a6c33ab49a1f6a2441b0454a12418820045b1d827fc254589e29ceb26d85f78c495872bede080dded80f258c7b399f1d9a6090765442867813f17872a5782b0c5301531e2ec79c8cf76253c1713e72f3bd8f25a165f55e953106dfe9efe90b5e5409b75c3117746b6fdd7f5bf1f72cd5fc253f592313a71a8c3b476b9e6cb754996052474b6edab06ba9c528dc129c4c96a57a5dd77df3f2f89de79f525e9bac9db37473ca1521f8f59ff0ef15569f04b40c47c3b5afb7ee2f18a27ef93b1942fedb4fd31c630be385a89ad82bd882ab72a8a768ac67ad4879fa84bd647f22b03426dd75df939c3b9ca64919fc7716de92903470fde53c26b871b397f2a06590a67f3bb14d75720a2cbf3ed6a13ac512a065c5fbd7ec62c1a235f59a4ffc664f3259bc91bd8be5dbe8edc7edd08a7d9581450a16080e167e6a3db6d7f707f38a39c53c77f0e6ec3ea04219ce5bc8afd407c2dd7bbe97723b04de26588e44b176012a2b8528775ad9e9bba23e3694f5b8c45c40199ef546f37115bd294709eecba862c717e7f59106a885c25239f42663e4c9a4197af81866946cf13637ea971c64f9c4ff06e0251121e30334ca3335f6312bf23bfeca11e38de772c9dc44b22238cd2a3495d8039c7101c662630d8fe997d5a55db842bf41016d80bb146b01a61b1150933f4123bacff31b01cc4b8dcf09584c88dd263545b853fb0fa5df770336fd6d7d1016d7aaf6b0dbb9f4b731f3e52248be7233434a5d3602e2fa494435ff4ebdf719b3ef679bff9d1f0a8060bac4abca8800dacdb36a47b8ccafba260a4b35a841cf7c623017d3388a57b5305777dff26932efe4bac595901df12f737662bd294540f6801c40d9d1a35eea13874e657633cd5f15e69649e11fd0c1e1d2fc34384b8e0e2761b58ca983107beae7abb55df14cf4e9c375264230e49443f745957311ed048404e4296c19a04fa7504fea405d121c69ef0fba62e77275ebf7690716f0d3ab2323d688f9147342934eba7c987c5a55bdd51205da85304992230036f99271793444af7a1de604ae564594239702a88f5bddc75d42d5da27b046abfe4d21990af0b642dba7097618a2aa51fa2228026b4bf57a4765eed1157d9f2b3b26e99c3c967f9765b1769531598ea276e184cbf217feaafcbe01e700f8cd9eff2f8ac7e4817d18a24033196beed893f84e3ae91705595fad851f0d69ded1835316983c1512ae6748a5e154e482d842e50a92dbb4376cd6a3470721c53ac86988199ed190dd1babb7bc07917fe22e77f6747432b715aeb83b8a42f556d588b3963f8cc94853c8d268e5fbdf4c1f618b7a285aa852c4cb1d5ad982c9356acae7abaf653b64d3a33df6901847f0097da17ba4e8bab9682969b33ff4064ae2150f4a50f7fd1fedd9a463cb27f6b8c1c81aef2f8e40c52a486b8b696f002fcf5f3d10c05f5a40f1cd063e1e05724a4dc1246b642c5bebb730ebc71a9da190d85e9b387487cd4847fc90d692c1aab0af6ce429aa3f0a9f415bbc97ea4e63bf1ef2a668db48925c768a4e41bf6caa984dee70ad2e26ef83926266838cb7c408d0bb181cc890179cad405b92d0f2495a572dce80776dda2d9b48471e4dc00bd225ec52bb57c9e6f28550a8eac277067f5cddd9250edded8f67e816142334680fbcff2bad8f64da9c8ff43fccc9ac7e9b519937cdfa931a00dd1d14d608760fb4db6390995e8970feb92bd0d04e13f5de06c6af6ed703069b0689308b529abdc0aec01c0c1d15680526857d92c7b6bd6c75443ce273c031d3b92be62524673b0a70a615a069ed11f2908db1f4b3053d2357871d05e7d3c65747e5af613766060a55d8bb9abefaf9d08519ac97fe576b9e216c93df76dddbeabdfc6b6570e9725d4d9e26ffdcfd3bc6da43fe1cbbbfe8b14785d20b687ef4ab37646b257bb0bccb07d1adb8961ce7038a7d073a6e9b9ca1efdb37affc156c07695b213b4218067797c80ad6a6838e0bef01fb852628ccd6931f92a9b68ea51aa72bdea2663995ad10b3d3ab7c5a10420d14778d6a7e57c473b3363c0b4f610bcbb558dc90a5f67aa10c90d388f3838416a174b504c69307e43280f3b29570cb0ccc83328784d1f79f16e0fcea934e71551ba1b47c6fb850d81a4fd5144e353939f63cf2b6102de3ab5d26e71e11eae89b47eaef3730933357654ca6d131c4363c3fef9f79774282246e65d7e3fe5135d84c65aab501841305fd8d013a5fee6a90551574bfc06eeb427a2ca1155b47caaf8c306dbfab2fd197a6794c85848bfa86cd8acc2c77114331d569b10a281369ec16635fd2c361af846fffe3edaf2e85045e8ff234af0842c3bb6221680407cc84ef089bbaf333b468d0b6cf53524555c80949860ca967efe987c920f163cafc6afa590294e17832cfe5e7d653e94942d5fb727df04cdd766e8aec3b4f8ff17faafa1604c0747c23f16fb03e6781730af1f7fd5419c1efa2d6ea2eb061043a69230d4fea2b03764a9f60225895e64e4785fadf4420b11a1c111c2b628eae8b753155d7b34a34dfc67e7c523b4a4c1be27b754e23788e245e3aa25532e6386d8717046575f3608e177b25fec3a2e820faca23ccbe436ddaa83c175929abeb683ab5ef18759bc574ce8266e65936c95a66493e1b7490ccffef2485f239cab3d4731a7fc55526c0090e5569ee9ccae603ba894737adc2a16a5fc96fc8b0a54a6009c8b6e60e13bc4221235013c2a32666b9c485a24b61c31d30a3260892f3d8adad8c491ee56eade3c74a8596e66491e02d6844472bec4d13a457e10dbb8ef55b875ce074b20984211cf4f1388a773ca097da6f9ea9f020426ca6ecf077e6d3e66a73a9ecc5a555f6d8cb89fe31ea94065657e4ef67a53b72d783211afc75bbc47b5814dd39a92e981bccfaf3b7b2bdcd1ace81ceb535bfb5e100a4ca35e2a448acaaaf11224df57aa9ca571dd1546334eafc33e563e87c1aed626726bbd62a805ad6bc686f78faf0b67eb932c9e9f2b22fbafc052d457ae1eff279f3a83746b8cb58befd6966fa97994b7168daf9cc9e278021e987b89633cc824eb21cce9ef18e62b8d8a0e0cc0223fed2c50fa6f985107e7225c7f6c0f4fc7b11a90382c97277760f44efaaf74a2a5c070abc841907da2148ebc639ed490e73bd8c5097f019376063bdd9f3f6914ff16f7b45542c9f70895696856ae0c2e935d4b03cfc644ac77aaa0a7550c8695280a092b73ffb13cbd43d5a35223894c890d2864492734e5f1b5e5f01726080dd78881c617334ec58cef6a75190e8f25913fef2c2cdf7bcbaed4101351b5328165aae86c166755941c3c92f8bfdd8d35c468ab3c27d95ae4742cce2b6e6a1e64aebfb8ff1f417722fc494979b1dd91708dc85548db268f0cf882c31d4758bc39d549411238ef097f0e9055268813cc94820288cafde56803af6eac002a22a4dcfba330f888f034a43a999ed5265caa663018a84132db21b4d616196aaaf54f143b0f90ca97416b45065f4a97545a0e66e2126852fddebab42bef9b3037ff69b4d8b2e6b000c80b2a5653f32a577f8b391d14dc84ea732966b2fdd8c734ef32a3e152fa0a3e0b9d319a3ce6807456b3d429b8f93e45693ec502f3a3add3c859fd80856d6882ce1743ad1525d2939a9c84e56de780c34ff29d3bf127bd245b042fe36630430b18650a0537fda8753e1bc7027425a40fe59e17d2055d1a5d27388a497aa482e4bc0c69d60d6318aa009d85836ae23566800ca18090c7548486b56d46bea97053ce1704471355281552d4d649d1e595f39c0edd3ea14702e3f0998bcc1839a27d3b5d2cbdd957b376f0a1a091710963bf7fbad41cadac0139dd53a58b28e3bf2cbacfec08f8dbd636849c2b2dc156261d52b952bbec1b2cadfae6c68484d8b6c7dc448a390cfda1fad7b5baaedebfbbb6458d503ef1f3ca88641c999f379434a060885c027859bed1ca6b0c3e3750c9e59ca25d2f2cda132b9951116f39815518c52460c99a5484e3ce0b5e0b530e5a007cba6c20979808f15c614cd592918e688a2993b7c2405c0e9c8be9c1b6c71348d00df594fd9794ebb8c1c8b6558d0f9ce84a2d12f1877c9e52ea2b44dc00ba1e2e65e03594cdf7b13f9302c036e40b43da0cc876ba526c5dfbe1e6426b090e07718913523f8f2c32afc34ec01d6b78d822a2f7b4c784899869cfef05a82a3179867a448927ba58c4b9ed3331a9f75501de4e2ae0ab2f5741257b7c23872a3f21c28977d8dae856fe6d420835c7fa5b61af2b6fa8024345b0130af0288fe6662e0919bdd2e8743ee07b56a41504a275f3ca7f5af4e9371c36d4d4263ff6ac38b4578574b22ed5f9af26a0975cf9871d3cdbfcac10510b9f73291bb08df4d3fd3456c2313c09ce51a11db52c1d74bd36c1c288290b4c31732a805ee25b4e08049f20524c8a0d5adf7394d148a9bf7e0baf038d83a8ebd5ce837e93387f9781040e8f3be75ee448f875de0bb709e5c153a130db94cab3fa8c1b8ece8ae8f6f312f4e8740baf8af569d05e2ee7966c513e507f1361791a4150546c222b9a1fa46a2f6356314bc1c582c32cf4d0da88160c8d225b4c5f375296e539fcb72e0763aa9539eab585bf389473473b47163be1a13a9e4d91a598f7600a30e30547e68bbaad474fcbf2356c9bcd3e2b9bccbdad2c7db8711e336f28823c351fa970a5eb2b87346cc57f91f6ec93d6952f8433acaf046a7487327f96f99b27ad01d515d5143467fc8e675762d159448cb860a8bffaa566d691aece3c1ca9a8b239a4806e96a7de75e2cd0d42b3911834c860cc74375ca48b7f3a88a042524f7b8ce9340451738b7d70d1025b01a99b4e3f3c30100a49bff986a23b260fb6f3cdb149c3aba43d248fd6524b85d59968fbcfe39a199b83ef31eb974809d46595afe6f55242ee7487bd3aca81de28f58dd1c6fbb2b58c587ed190aa8a333ea37a06f450502df3640904027bf6d56fe316f007f4fdeb7bb61f909b1689ec9363b195c44f4c087bde7534da936a161bde03e2a86bc729e173d6ea35dfefcf7202dedce75ac6a50a7697ac08d25abde039587fdf8eb862ca12d9bbff4fc5e5915b91098a9b11f38f61e98b718ea2f98531f3748c1a0213e11424fa95e140cdfceffd8887ee8ef0c6b6dd7bd6d889f12954eaa7f544df876e093df9dac855f25ba69dcc12f4c56ef06a0052edf9947d40f73d5487c3c7246d923416ff34161cde46ac0fe84dbe510fd52e9b4c449bbf5780361a409bd992f4c4d59cc19d87f6e36f7d892980d9449b0f32b7e312deb8d0b7e4dcaa9729d77737e640fbd6a9faad45a8f63c384e1cf6d433cc337a2c5d2604405f5740ee3c7f58c6acc58099f3bfea66413802b3eaadf3453df9ce6d2f3a9a0bb74f1b82b070d06a615651725a1e813b783609a31fc91ea254a840a13bfa8cb366ddcf176e8ebeac10f0bf28ff45c570a1f88dcabc7a81c1cc76cb606eaeb3aa455ae1b82a9b620b05c741903578618ab72d9d2ccdc4d8c6d31462fed735ba4599842729a54bd27b07590bc5fdabcec9db7e89b769d38d4abcff4c307cc4ebaf8becd1c0482ff69907ac9e4b1251546a81687936ba53b15bdead0a003f4975f971e210be86e35443df27970019006d3441462f356fc0bfcfa3cd6cdbac6cc32b15f29e2736a7631ca510f0ac799f4cef64b1c76f3b494eab4a123050e6b9deda6b2c83404d76787c4ab99062f72ea029dec2616421281be7aeea6e642fefc7018603a575fac337ce28c997729e349d5f5f1841aad6f76e839fe95ef0de4553338279deb30e0dee91440eddb21fa4feca73a6a46d3a67c519b9aa5ac13166e87430a4e1634f75864d4e0cec51302df875ff31fe06cdb0e98c71a198dffe0d19eecbba64d82da5d228ef84161890b4de34928896ab0579afc035f7697ce69bbcd52901b07038256995fcc699340d9aad091a9678ef6411f4d87532dadd8f3ff3bd758f2e9a5c6e90fcc1167110ce8318a2be9a9c63edc1b48287233ec3805f48b5d5922debb862a0a63903e52d9da78bbdd01c40cc7ac52778afc00e17a6a14239ff76f9886153490057ccd320f5c552519bb052063b9c09e81d0f0182a380f6db04aa2d8bdb9af3e03ad3335ef15ee13e6601813c4b0cf3dee33c84f5f23696d4fce5fd6efec1507b1055fb9803b4c77f746b8e6de7a1c38ffbd47c9b0664e179eccc553af90b94495f284ee847237fd30e0b208df418e879427533632c4ce426bf845e75ce337cc5010f343be54853b13daef95b066281013f397ec3c30d9237d9ab5fcc63be886221e2e7d5e882d4c20f9e586e28acc0ef7d59b9d73e0e5e9cca2f4c5ab2591484c805c3851f8046efc84de7a986fa57cd18eaffd0de6d7657a160b13e55916a081d04514857be97f17e17de2728ff4e068c3fc623806baee8d904ed711f6db149de4c5fa3ee7efcb5e5f86b5cb9394f9b5431d709b089269729875a175931e1db10bb276765009e58b23507466bb4dfb2b72da7c03826b89ef26da5d46ec2c8ab45d3319b5fc775f60bf2d81e64322ffe7d2bda8467389a1172ea15a42208951314cf22f411b17bc69387cd22bffdb8f0c68d7ab5e3b1b369983a5dd5ae994967346d8dd12609d89bc14334ce2a5845ee34e4fe041c4a9efa45fa6e450e7317cfb98f44e906897e2ce4438d67dc1d0956ee09ec46e352eccd9d94e5ee83fcdd045ee3903dc82c775999d9d75057de5ae510bededf5209628331d6c70b8f264a05ca07f6f0c94568b5956ad60f069b12747116fb65c27f71b370f7073d6ee8981586b1c8b2abdc6df4f72d41f200be8163844688697e8b8d76ffd21b13eb1026fd9fb0270a0b81995add336c3108f4ae05e8fa4db43db00bec44af902f1efd8e9dfefa8ee73445d1dfcec7c8bccbfba5a5ee5b5192718364df07a61b2f4148398063ad907c2a74afe42050610cbf3971d66b45599737517cc3d293d7c52ab4bf20debd93af80ee19d4cf45b903a2f4954b219170711761db4b24246ce6bfe4737e762ea5dc62c6e9b4e22916310deec86701bcc61e33e00e4c72005c1e5f7af8218582be0d3e7b08143ea57fa046fbdf6770fae2e1477fc5a0322de0b34c5dd11a253d806b98d534aeddac320f35cc8da0e0dcac965b5f7af4b9463ca2a59630275e461b66a3c642fc7ea1f938eff77ff54d197998d93be645e01f724eaad37d6652b54c432dd1ec058c096dab77e0543dcc58e2a1cab19670a2299a6f9a37e0f86f58b4cd6222678abe5eaf8a5ced14306b071f74124c94bc0ee5c07c1537ccecdf23b2a1b6e6c6d8c6e7abd5a2e8e05c646ce38fa0970b0dfade8f96cf7baa5fcc80476da6e84c6411c735f96cfad39ddf1b99ee36a08ce161a4b00feb52c041bd6e645b08da73f552da0dc4a78b44c8defca0d130bf1c38d98b01416f362d2ae9a5b3bf05b213b075e1937b0df3d70981cb2649f7c58b4dc85017594ebdc5f6d23509403626454a04c8be1f3a6a2c86378f2d67a8c701f8476496d1085dcdfa0d8b6ece1dcd792c0464b4a17ec79877ad60b9fe0fe24c1c431b16960a439390b71aa4372ce402e900d2451c3fa24612137730205f858a1739ea5117530232c38f51d8b4808ff06ab50ae91f2b545796114b5ae0a0dd8e1bf4a76018ee68c447cd1db319e91ba6a635acf4c2f95fb7535feade729e59540ed94aab62234789c8aee5f11c4c2d97636168ee90f7c3ff6b5ec4f910407bef62c5d7da40c486f43d95ab9a47fba4a55c4ec9288777171698a7c1a7a356e928072a75196e68a01fda37b47f7ad5093bae3d260b189ecb2511ed6cbe09c0fc5c230ed47ff903ef07adbf06a628d4cb27f39b31c89864141a73ae8e2d5a304f81bf661de61a984725038459d637ac07b9501bfb9e55f3fdbdb78de007c0e9b0c2d8459d539c18d01d49e4bf6ea91192b7f62597cb8c7d6c952ec59b305c023bb37904e19bc74da879143d204bb3d398bacdc3250aa878de3d64f85fa6f4c36e22c4953c443ee80651514ac48385b0215ff772547401ef00a117eb38fd3bfb6aae9c2ec18821bce9936d8f867bfe41c649c05d19eb6cb221c38c1e800dd7ca4997ad962a97f58fe54944c2c9af104211aad6ebc68be374340f62d47cd4e83939589c17f17cc16bc3b027246747c6fdaaa2e14b47f6678f28ad91603454c4b3f71b11a0a04466d927d46239f91adc891fae62573137ee9658b76f1991c9dcd28b50e1d89c2843130e23a788f8c7ef897c96f075aedccaafe186b7828f826fe8341840f81e0c133ce05ba8d82176dcc50c5153e9271885d9e9d82bf82d87fe2e77d0986edcc15f4ed876a942903c4a97e5e9efa2e481d6979a6ebe455e9e3eb1497bd59816bc91c964e70a453f060d5f1ded0e3d56260c843cfecf86e5dc5bd76611b85001a6c7257e8307e1aad21cef9ad6653ede33bc22dcd43173332624e09e50ff098018c6453695d2355d506ac92ee07e76c55b78a5b66b28049388c680d97e6f760f0b63ffea7b4ef939c1c74abbca7c4f62370fa1ffe5d1e771f034f654ed987f802b127dd8428a9c7d4fcbf66a57603c3d1228c449d5cba22f5cc9ecbab946c34b2886e36d9c4ed0c72c1331b3a2a0cf75ae1876efb50ae70329ffb411c7920bcef33a77d01afa0c82171e9d59020fede693a65e76298468f23ad09c052714b4804af154cad8fa5b714790bbee3512f1152359edf93e0c6c1088a81b8e6e4ec69656509dc16fb7a1d9bf691b1824cf57c617adffda0e42ac7154a465e9a4aa2696f85ac73635557c0486b292b51f0589182f1d5d67b21f2041606c607ff76a5f58d567db0d9f9fa5aa6cf0258980349d93d986499d3d02cfdc138eb0ed9ccd6f4fe2d55a8f9767cce8490b21af99c15310818eb6c6c2a84708acb1353046dc5f53939901786d730ba5e5f8fb4b4000c441b3ecc4ff6bbc6e4b9a5642df68bde2595c73ac70d2ddbca368c87d6808388ef2feced5adb4ce51882f17bdf3f897c121e8e262eedfc6e136385f66efb3c148acb548db48eed88df2b1d6587942cc896ddd8683d0606455acd2ce0ffba932d6ed45fae6b6eecb0bb030e19d0099b59e927f4bfcbf71c97c47a9e91765525b6146e25b72d272bed3eb454be85c9a4eec37074aaf656506817dd8553a12209cb50022489ead6036755c030930ad23bffcb6904f95d8df830800b773bc9cd6014bd7072d25fa207c77d7a464299f48e09bedfaa5aa867b16a2b4f08da8eedaffd9534b40b253d369a752ac514ae24b10b0c380320e251d5185188b450735d62a3cfc94945025d8c4d629c61b4731df75e1bb55c1df54546ee7f98c7fd56b894892347778b18b162898a9a0987821cf7f5e47ba5034fc2b7022c87e94b353f4b3a560ff85feb0eec220471a94d90e9850fc02ad02c037bf111be1a97fe022b442ab08a0af28537ae15938ae9bfbf940d81a128faaceac145046d85104a995744caea0838c087bdf9dfea93dbd8138e2922cff6c2217b6a673b6e98661ee2f469d21830a390a0dd0a0c7ed202fd98d433ff5d4a2595b81bc090ab23299b897ecdbf6eb388022ed960b6a80b76c499abf05caff6b7890191949b9082846d7880e9e0e03bda8c3e3f3041afbab372aa1e83b40418a0bdd42d5f58f331670ec44a7428015e393a9caf5b167dc2ffadcf6b13b7dd76e1568f9f8de95c6aca30622339967ce34231e3f00dae183ee3e734a49b4ff544880146f38cf563b9bcf944b4665066bb3580001f9c498804e816bdc0fcaac3724845032fd11e80cafa43fcc35704564d6f163b25037a1fd6a5a22678e8591ab480c2a558cdb5c7c438c20170d5b0d9b4fc81974a21f4ce6e12254ed8aa326e3b5c5c2a2066a66affc215a22daf0eabc26caea3e833049cd8c306b3a458bdaadf3caada912a5113783dd8d3e2287e6e183e9c07fd87bc3a305ef7f0235f32dd882e952c43c7d57a12a38ca29e5628ef4c8c25387ac7dfd6c8195b2dc7ff39e648586a7f38efe67a8cff7b21448f76d153aebe4e0dd85e77d4f591072ac00df6f80c9729e53f6be0c475dcbe3d718fae4337e99831f38f3bd4fa00f1d097c0719f1aecd56939be393556929b105e90d1e4c15c99dede6f572d5ef082bb5c60f3f78cbddcc86bc7c45d5217b46b87f103b2c4c5eb648beb474a63dc28da4a053658bffe067a5115487423df287ecd45f8f491aad9ff8d0b209e814ddc2f1f63fe05a6ecf3a08e2f633f8d293ec128371f6af011b1397bc8b30269083f07d64dff1c2bc25aedffe55f10d4234f9beae6741bf6342c335fa96c941701abcc2c5584c6392051ff85d0dbf7e73463715984e9a6ab8c3042124e6a7288676976b00e5f8f2366e278ed41e5547796a503ac131982a6dc079254f769d5904242d18ec2646b8c136c475bbff9a45cd97beae9c1ecf6cb403102d157ca77708a195d50e98efe644cfe681644728d45ee669a8d10211b139c6608a78c1ead3ad64e0ae12d38e621d725a79de902a56ee8f939e10bce4577c86aa0ecd57942702797744c324e254d96189c0895b53baf1886e6fb05da19ccedd584f31104ec8a85f91e545621a567425c7fa40704e0c5f0bf83e46cd7755ee90f7a96eb971d37b8d8505de74f84ec4c8aa03dbbc3b526023bf08b350b98a4b90f6039470e458c173b10bd67604021aa8c071cc72d322b702f0595191ebba046a31a7e38bcb3a477dae430da0d3833e14ed847be015e95a8bde1668389f19245ef32a52f2cfafcb7c68e180e628e179cdf7810acdec53aca0e7ebacb0e4cc8e8e3566c1291c908a4c60e5e6b76d1e3275d87f80258af691dd80de5a768e5a18492d2db90e093191b103fbdf299984060c50930e6a4bc20eab553bce07cf0abf7f57ad02186e52dfd1667bdf3be1d4c4c9f507d2c50ce2595d91dec8b945ba012499a86f1f3afa8077603dab4b724d3c07e7a1365a0b4ba5d07dd3964c4fbdebbfc8d2bc9e7e1e3082a718d7ff345facba8fd78cd3bfebd4e326406ab416a16af1695d92fb8c4433ddfddca4429c606d5c973e90d3514350c3fd6f843ac6a2596c935e94dd6d4c78961815dad088ccece9a9a1b13f0a84e58401b6f04d6468f90badc24430fb00656a3977eecdc849cd9e0afb7ad2effcc34ce8d6d8db7b1327c54c53ceeafc340cf4d654d2f69acbb262b034cdbb6852a41a45f96be304e3a51c36ac10f47684fd498259c25b00ca34088e553e191c1317d263cd223fbbe751d67abc0605eb5f08e57e0b377d60ba8bb5159c9f21a132936135589b6e7f424cd7719c6e25fcb26ff170d74f3fc6da5dddd59bb72caec71d92d4292db43dc51e909d18457e7c5953df1022faa0ea540b87ea0c43c4ef2d4ee6d0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
