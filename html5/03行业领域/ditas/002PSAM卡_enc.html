<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d6995b6003ea259657dbe064444edd309c260fe2f4263f43d4da555db5a87033c76bf615a995ac02c1aa44e33711fa11b0ebd8db336f7d5cbf1acbd945d36a24572aec614e0171de52029405107f0d7297d7188a77bbc0edb36db3266894ffdd249ce2fd9890c49891a7ddf96a547a2dd34aaa74089d0839c7e626d5beb2550b6328b0b98f319ec5ffa7184123d46cf3bb95f037efda5b9562dbd50a9e2ea6a0a7968dd8149b3b07d748ef6ee61bba513eb2ee3665b1b76ff1dd20520cee86f91c6abb14bcdbe1f253a81873c494ec6a297d34f80823c0604b551f45482271e0c47f6c2200975dab9958fac6932f88a58c035fd2927397f42f7a8ed53a4180709d8cd2db76a0a31c8e7e20377fb989107a392be58c35fbc3aa4558a2fff693fdfeaa4e783c0e72be98c078764fb758f30b0eb00e1d8911d7a3411c37b96b77f0f54f1efab2cd6d2486312e46b351c1094f120497cdc56c3f6a234ca3d4951cb5284a24921d5836c0ceb835f0291ea5b1afdd9bc2d8c10c1ea6d47bd1d229b5439fdec116d48334931cbad97ebdc7d446b8b840814e2c733a32ca8474979aee4e322683f7d25e2c03b8f85a8df91c5e30c458e872e82625d9e5ba2566f6b28234c3f12d5fd650505ac7ab18ec9132fb8a3d2878f21906b15c639b99ccd9560adcb803ea85fb03e760c354159614a190fd2d14ab2049b8411cffac88431c44bdf597e185825a39e5274f039298a6d1b4b38f2b76d4c886bb8d28f0c8199992a0c183cd6bf293729fbfcb0c43fe7fb925345d2e424a3005727e450f054b176dfe94c8c43746dfda836b86f402bd64d2c0bd944a586b50e2f90e1b73254ce48c851d1bfd030e12bc074393d5cbc0d328cba10ae174f7562cf0d473c364c5216d41af03a738d79f46a031327993ba54b30352f0870f66f237e6c5061e07ccfd03d03d8d97e576ad984214d174a7fa49e93794389fd1f2dbf8aa765eb2d4732c8290049fe587b36a2587ff813b7e46c4a2b9fc04c4c2e25a4c7f0493ab0550599bea6991154dd89774c483b05902f119473ba30a4bf33f21293bc11257f16f96bafed63e1b4214ebb27b0bc122dd77a4e6488db6a35fad214ffd4e374f3547bc13cea681b00eadd9e1504799d1ca028648f3e38f1e1087bd21f7b2859f41a8155186e54236fc91c81369dc908e7e0d257866f24fbebd3b76b8cdf6e384945da358cb10d50c919e2949cb4121771c886c53ff0a15eee9fe8689f248969f6821ecf02bbe4699f6d429c3d1f84ecde448359bccc299976ed809f26c5aaddbb39320b470108b6369305b349570279445f931dda25bb9965ed905780b824660bf8ad184a9dd11e5e749c606298ec245b0ae34eb784ee31d963c8fb6cdf30ad66ff9151c31824a78fc4516395fc84256ff4183055f1dc432395bc835ca2e3cf6c3a0dce940df8a068d8e8a9e5f346b4a34f6b5b03fb450125fd2a91c918be697eba33766803a8755e01c64dd3284c5aaf1200512dd5d9c20decbf4e402e42444c98a8895a422bcddd17d5e1c500deb55296a518155d48c22c3b9f4b3022730891f4467707f8c8cfa45759c56c30622c19a72b9cc2602d6fe038a9f14081acc99b16f473722965db65e7dcfb4acb26a7cdd0cf22eeac38be22f0de24939607b50720d00c83b325addd8594b7de7280c9a17d1b61d71c168971429c656c5a526ee1d3c92ad655378306e26d45ce037cbcdd4422e5b628951fc74b2d43525db550101d65a3884068414245a0f620d6af97e64195e79ba8bb4446151eab29d04c75190e542804cc590b50332ba6fbbb16f00d262f96f4a20e07670c085b7b40c649a1c0c1b3847360ce442210e78f5c2f7f005df1806c9e9dc21a36f0a3de2025d79ade7a812ef18cf7a1fd0f650f4428f4c1678fddc951cdebf844bf0b51c4650314799a23747f4cdbcdf395a14b83c302a8bbf0cae4e772d8ba7efa20af26de05dba967f8b07bf4434b14faf0fd0e533d22d3ad0262bce031f0816c110049865035b126333a709c37c6cef944bd075bb514e0ce618f8526fd6b7d51b4787c82bb845d17fb08bccf83a3712e5a573d9a53b09338a7a4f9e01cddce799b31951bcbf53893e6132b4367e4d1eb3e0fb385246b43ca04447ea36953036363287f94cbb6bb453973757c00fde7c271f25a61b3f67d65aef78f4d2c2a6575a3aac048ebc1dd15290ac3fd018e1469de80014d6c7bbca5181bf2b6cc6f03f837e9a2efa8f9f8672ccdc9290374b66f714b9362f3c79effdf5698481b52cb77ad7a412d143ff0c35b426047e25a0c7f5b7f5d98d61b653c8056d93b558dcf5e262788a4510a99dfc8aecc4f79e554347e7211cd4fe4f946cee074337ab9349e8a4bb47cb8075d38cf6fdd4abc4adbc5e37798e4f95656f6cf43c1a9e8912fee96509c26a89ac05cc47a88955fd519de65652c2fe5f67a7b02c6a7b2e71bbe2af25eb15e0575c1fe323584e3a5350a2424faf3d327985f8110bd4c1c477ee3828ebf83f8257b254c383c6607cd54c214432089ce2bc956d83b4434c4b3a7f9bad6050535c3b685bdf8f880fbdc05dbb0332184e3fb8a1ecf2667e354f0b1d81b3e2909bb4ab20cac73cb000a2116867131a02e69e390c7160f7bdd7faad084959fe5f8c4c823adaec602fbe3276073710983ae1deab0cdb9757c967f1371bc01fc7cdfbb6177634bb39254726ce36af5f3173586e8efc8009ae685a18b31006a826ad90e2c2199122ffeca081f138ec78b4bb1c3e5c665f9f8276abffd3c9e339fbc78390cf000020fdab5fab3b3b346550de3522da94010a3e1d80c90ae782ab91248df98e335f66af7818305fe1536754c4163322508afe1375bb161034ebd9235190efe30eac4fdb193c17d2252de91e4b0c43f39f1f8e4a2ef2585c26ecbb3483b511188a530a20ce8eb889a625f11156b4ce357532d24bef733dc0f5ac15899dca0d94eba83cf79fa0f8c67e7579459326a2669171d08c5c5eda91b7ef9eb29ae62932ff2aca8c0dfd8834feead2fbe729b9ea018a5dfdb17ea1e5562751995ec52c530d03f89cfb8214ecb0a4b8c591365257606cdd014cb42b7528d73fc661b8b184c9de6d6153785fb8f6db8888005ed2ba6a94ad846193f12eed61c83b44d23c015f97e019f69cbdc42f2038a1d98c3aa4817f07702b9cb79ad327e19e8eb24d7405a1ab53d704a87c2ac097e4f67795aa71d78827d98e8ce0ea7fc1e2bb2f9660970a3da9364c353637b651cd756e9250c036761301df50f7f1acf4a1558ebcaefd98d8f22e7259ac853a66dba39ea10bdced3ae615938fecd2bc6bed410e51bb8bfbc4cda02c5d9b8957447ea54b160919be6860d14163ffa4e0656c1b34bfda1ef5b1adcbf3e2e9ca526fe690a71e8218c8a75de77f558d6b9dddd5687b859ab4537d6cb0ed1f4b83a1fdcb6f2d8c2f9cffe8e84d73655308b358a7e669e79028e9d38e10727cbd7a11306a4bbc5f30aa0e944c0be568e7dbbf29353f772b4125f6d8c1de81486f3f5081d832727c63ddc5de0add84b8f3bc0af418271be086d34b87ee228fcddc0335a7863350e12d70c593b8d72b3162fcbbf64f4617eb6d29c2ab8578e21589784ffd68b4038dfa1ad52f57b392a2432d4d58a30cfd9a43f3c9950287669e42bfc777e323a5d9feede1ae1692287be04fda6eed44521ccc246c5322d2f6c72ff961b2d03e21723a0030e43f2f62b7c36d6dd317b144dd07aab68960064ce073191133446797e9f63343e8e8cc368e00ea92181a3e75d1da1c8d723b06c28bd5c90a5d68d0fe7ab046950371f3f2d4777c3b4284dadce12673d99ef0bc2e8b2a002191b0737849dab859f1aa108ffe4b11bc66040a71e5227538f260ba67ffd0e10abea17f222850afdb6893aa66b73c66604af8b6b7b285fc7f00ce4965ad478bb79c4973fb197e7f5eb4c42950df890d2045cbc4adb462ad3bc552f6b0b950cbb3932e423ca8f5a37d5ab4125850f4085a796a8e2393b06e638b29ca58aeef54d99cdae069cf67ee56c13fd592fdce59c8d889bee9aa2fdc7348ca63b759eca575d97916c12d177cd456f2473a199c6ac444b1b224b143bc46fac0127111196245578207ec7045c1b922fefc5c8582e7be037c5013ecf72e3ee07bb0faf3c82cc2c039a29ad9216e6373416ff6b2ab0269c59537be49b604fa1bb5ca70e39921d56bea1138aebdbf0e983e016a8c81c87671d831a0e35839aff368dc86108682f34edcef44771648074ba0a37a91e6a7fc74dcc282deca60c3f85fb069b55975414e9f984a176b1c380eada032c7b6d20e41331908cfb5050179a78723411301cc45de8e9423ca697b829ab3eb5fa3b58e4884164a34bdf219d49008e9b02db856a769996ad471ae53c80a28680eac597032a4755cd306b73bcbba3f2f3be4a0df443f018bca8ee4da58d3aac84410b87ecdeefa323579974975306ae9be5fd507d295fd50b0858c4f2bb67cb0853f0f83a87bea4c890e2ef89af55fb9a42e30fe3c76990e30331d6ba4ed2f28f8bbdc6185128accfb7f845e1cab3617a6f3b8d262712b6b768aace0df0d34c870d2dffbdf3214b508c77ebee0fa333318bf8d3ba455f81df4548e0d90f5e3a6cc6ed420cc93923db463bb3913969c16ba17c5ea4bcacd38ec7a70a1115775bb65d89895d137ec3be2a9fa67b855599a1cedfe57efa8c1ed63b39168def6760fdba051c6ae57841833ec1188756c3b6c7a042145642b94e1b4968c5ea622f5a2aea52caccd2f7328310304b656b48237f10b7385433d4a5bc7e7a44b7415e6130f081e6fd30126ccb69f179ba4d2876f041ed87dc2393601101b6efb6d36cd77169acc5bf88dff0d9ef2cf34464f2e0fcbe12297ff9ffe1d6a4abfa73528db35c1345a9bc26b28ebb8a4647f848f82b91cffc5b67b56cf2f21a96212b9531811bce6a96a12f2e38d8d4a3f498c2c95b743cfd18704fc5e93a50e5fccd95cdba3577d338950935acdb9a61560d526945815ac2af3c82fbabeb9bb90fb096ed2914f217af58d027b1debb07ee68620d960f8101fe358b27a28e277c003f122162ee58d2bf1c534714d28148fedbdabd085edb963c4207a53745a5e1f14a621c3faa17e27b449b66702e8f2c2cb247746d8507580005a5edb85af7145cbbbffcafb4804c65273070fa22e22ffc6ddd6033ace9721228d2160adba5e63f4f8b8545efdedef9b975f0f30b1c7a1d4a247099c0fbc1f873fd7b1fbd98a502fc2ed67e09098fcea73e1e15d8fd46212797b01d468812f249695763bf313ff245c969f012bc08076b90f5a38f295efaf8c25419670a06ed448ad7766feafb4d7d049925d8e484859fe4a6ec1bfc88f8d4d5d8ac93c3587417d864ea98823d6885d926fcf6aba3de8c5780030a6a87c48edbf8a247cde928a32b30902d006b7563511cb8d259c845f4b717800335438b68adc92074422a4ac0b04e2d9d44e84e64ede0b8353624890ac3c31f757009310f0238e6fd000f8d9e7d31aac7c9059fdce2e5b3529f4ed9029e8651fc1bfa12d76debd47b0bbe8d8f6080f702f014967193455765774df61859a8d8ec202a7f8fd54c12308280e284adb1867cef0534a85dfc200dcb97385f658abae8e149fdebc5f088e3f54608fbc1df13576f0d85b3eea0e71370084620b26fab3712c287d04918bcef0565f8b863c7b50eb8931b769cbb5a46b74f323769f43b3007b78ffab3459015810e6accd540619e23935915f1500e2fabe4d86c71ae49027274ba8d12b76108b12ea1984d26fc18938c7e3019ea0cd646c221a179fca5004ff69ce07a0d5ab80a806826d516309c6b5c9dd1fe39c81376f20dbe9c23de213f8173da908a976687f2270a7120965069713732899175eccfb892a01f857790018d7a059d189a7ef7e6de3cb2e0a51c8b39b91cf05b4682af42bd2e7a2900f258aba262cca7f366aaad05259ff4014a6df325c4993b10f8091f7ac61163122d0d3ba297d783a3fd354f7488bd08eb9bbb7a8b93e15b8dcd1d3cb9ce524fe76cb0b54d555f2b0bc53a5964bd547db52b699b1adb5ecce4273dcd85faabdca3dffd1aeab25d060c2184bc4958e2e2346925e96dd38762ea53b625e1659cbf7471ea44eaed3ff4b9e05a558b39d5f84030bc0ae8f503a9febbec614df21383bed7cf64b323fbcac02e3c611600c43bcbeb829e0823258a5378fa512adc139f627e0bdad53f721ea22a5b0209f6a875d4c62fe610ca8435661b37b58a68c87d095eceb2690df8717218c881f18fa4a6397bd7ee86ad8e5330cf800a6b7d6c477e91fbceee8712518e56feadfaeb4cf0ff665bf6649bf696dcfed78a2bdbbfc9809b8d8430b6b86e41fc9888d6cae436e6345483415c789da7a31371b342b594aa959c8bd25e4e5516afc1a51d53b1a241d039d9f01217365bbc7731813c67192101aaa442349acf13352605a31bc9feff615c5cd152b932b0d75914a14d6e47a1e0ac9ba31a5fd229484e11fd2981927934e06e3b6a535542048f764ef5e7dca0ed3c2465667be42418bf47edd441897927afa732f64aadb1b8930ac715732b76cd3c12a6fdf7325f240626e64a72047c65c0894eb50297148b659bd72e09450ca1a98201b4bbf748b110722e07cfeceda13c07cf7766cd433312ff7b31ac2d52bf220a0e92917be1773ea8373bad37f5f4dae727cd8f4c83d0a941fcf9633f30b36f7138f0f00299fb750868451108f34e229675eae644c5e7b47c373188e755ba17bad173fdd90fac79517698dbd64951611bd5aa75b34cc5d22c3b29ad89d794b673009df6e686903ec1048c6fa635bdeaa84c3e78cb4b8d46f29fe0e16a1b586b637abb74a9cfbcf417f9e64a95a69b2dc7f7b7dc870a1c40d7c6b218c8d4b13704a41332962d140e74d15e718b3410f366a312e35edf047ec3b3cf02cd8273c2e7f07ade529a256a79973d2f1c093b180b81596e1bba75041854fea6b18bb5168513dc809a92a001a3021715f22d3fd4b6cf668448d63fc484a2d56abe4067dbbffca39bc815947aef73e48d6e455ae5a87dcbbf09cb727b8942e22f1ca5ec57d67a690ef20c712abc628e8a6677a38006538e64ca5523c83401888c61e57fc6a7c83e4160f8978515ddeee2ef37470eec1454bd09098629c305752676438e19626d3c5f51e1e1d543f16f5f8d6d8039ef79eac418155a417979a31217f93d2febc0f786e02b769224584d68f05d5dbc3cf45fa5c7edcb0eadc439de48079d64c142c49602870ade9765ca99603dd96d7fb3a6a1f1bac4627b60a2773353147ab9e78909e04100f4ad2be62bbbc52ee9fc7f56bcb0df2ea8a20fa1fe1fabb7c202acb24344495c978eb0be7973f75fa461c2d1971adc95de5e195620e7167dc56341ced098f8ed6e5c6367d117ed42567b7f7e226e79b902fb74bea1fbe154358f7a0bee8cfb9cc1fb9680b5fb480620e8775547ce10a855157f9cc4e170e7e7b37f2885a85b9f8ea99999c2cf09a03abfb9b8e69641189e49358ac3355b1c305a5df3d2d85256fb7fde33b6b5e2c9c8ffa52883277188422b9d4fc215776f84d38a158b98094c92574f438e4fdfd329bd55ed50d7c76c5a4081eb80a4b60ebc3cac346d074bf6c42ad12d2a42a4730a7455f06811558f70d9a2f45edce3409f6a854d0a3b2e5c6d033769c4478992799ee9b61e789b61325ec8401949fc676a02546dbd1c06f43ad56c605c2def392d89f2b3fb763b43cfb19a98b5139c21503cfe2cd9487e2fdeb8da49b4cc6aa18024cf2bc0c0f3c0fdc46bc7e7bc708fbcdca518b0304b11223dfa3444e0633e24ce934d8e39d2ed0270ccc7d8392ad1c58d5009e1bb8ac03ffc45adae219b3954cb68c665d12673563b8f29830c30cd4cfd97c0442e539270cc9ad0e2acbdb0778ba0823a80fdb7cac935b60134996b961457fc084d05d4b5cde9541f245c49e7d9816635bbc7fb49d8d6a00a556cd66a9396ebca27271f2080b9b4bae6196d29bbe856c1101538f492bb2979ab3d5a18512e6ddd8d67d1638bc19ac13d26678db749874591fe54d97bc193042385662b3ab9799e23482c09b0352a4cf5740db5ad726ebbdbfe2036696d5086d8df22da43fde473fb8a25eee3b37431af70c05e38a5e8666a7f36751e295683cc1c44a8d6722ab718076acd10e9a9e047f87d2130c1f952baab239b2d9b8961f27adc901484a19057a9dac83ebe8b0563899f348996d717ec65d4b7df389837522c39771403c15c42187a6b53206abb1191f89f5aee1a266fea4cf13149b8331b5de6a556cb47512c87457c2e5dc12f20ef2088bf84c898ebff853526ad1daba00c6267ab6d5aff80b329e33e4eea2132495d8b2e19ab83ee0d24b531bf1bff7bca1bc66b56c743b2fe0adc814f0d00549e5265fe9e28008f81b93948e970d52522d9d3f2539708020368927289882489ae907ed392f6b52ea9a27e6cd5283bb8b3b44d23fb796549b7751a10324205455060278fdfca7d174ed4d74be6f904e626220753b0b0704fbd82ec6fbecfd188d604d2ef3e9a96db4e3d0b974c40cc893b965943e25e0fa405e519d6e23dc0f61628ca8f811b14a48e00188c7269b724bb8b6ba5af20962c48dcbd7e3846a65256684d07baa9948e20c651b6913dfbc43abd8939ded90127d44bea810a2986d0064c38d8500626997ce1dd4bd863749207d8eaf53e762c720fb5aec84e13aeb859e0c00e55154b1d2a29e73bbf2c579bc5e5eb48e0b81054d54f3af10ae2f860550b15c31d66476a41f195644594312a10260743c3ae679eb36f43df007fb8e045736603464febf10afe122fe3ec9891186eb76a1c8dc1ba28ca984e65d492498391d3405bf22da49bcb21ba428b6f2a12791094cc5517efddb501066caf191ba6d9fd7a5dd1c34f2b12ead971049b41066e7e172e4263a5df47620e1fdc11b50de2d6981f98118866797d73ac2fec469420e12236f46f14eac32112d1e777dfba710a582faa8ae43b145ddf486df46877aed668e365ada1794607b64794b192f9be3d104e607bd689b8209ed683153ede30ca483ab7bbea2ac286c22afc9afff4dc44cc605e1d07af36bb791361d9aa301297b5b6ed90a2d71e096c01b4a705068f806f8153f9b896f940bbf0ab81d5bfd25112953bda27015eb361356045b9aabc05362ab172324332fd01c44ac6ad288fe381408a17d2ebf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
