<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e7fc38cc9a688d218fa6e57152b31299084c82145869a38115f4f185b224ccfe8bbf8aa786c99645326a289e6942a60dfb90a1cec87ab8f71443e7e13a640f0b06ee306fbf3d2f688d62138a1077a18472796f9cc75640aff788e831b0345762438910773447a270fb44b3ab21aaad8e53216fbcdedfaab339b6eeb0971bd6bededf535f21a30024ef78b5df533e4743b9c7157aa8ddc07f4779027ba315b7d92feb0c848105c6ceba92cbce1a65d92336cea10f54c80704f3694929c3ea9756eab284ffe5ef0a62f0dc2f59a057be5ba920ee9bbbfb1157c86fa315dbcfd17080bad2a0d4e705acfcc9bc44208d65675b8c893428e5e726d9b43084b5bc3ab5fa358c39aa4fe5185966c4d5e5945f6ece0c771af34360616aff975e3d0faa2e30cf2506a18da937bd74a5fa2ab959d4746eae2cce71d8981be06ef639b910e9760e8bfca1234e26e126057eaa34da7d9815ac81891f4f9a4392229635e5b6c4338bdc72f8153925219d8fa4a52758cb61e963761cea1efb3bdb46d36dc85d9bf866248203bc9ebd152112ad1a18bbce4d9113405a5708c9020de846bdadd1fc67f83223075dc448597d2f3d129a01c75560bcda2ba812b2116aa1ec0a47618832459019e1b1f117d6e7399db0de98e68083c6e699ef053608b0a3327e99bf0cd27b32ceea4b1752b58bdd7d1ca9ebdd4da4923dd557989ae062db3a75e682a0d4ed84371444994ef345d500017eb938a1446f58b74e3ea579c360e8e421fcb151ac5b7cf6d69649dcba79b51844a0655a815b05671a75be1ee1c9f96a136d8168e0ba201ed4e20ae82e154a019fb93c704550cf2b00533f83536d21959929e7da0858643953712184137c28b9b48040add0a63244c103eb51decc5ad3ad1afac2840286786be9c5ceb3ce754db97895025396bcea51449904b9827a7aa2cc205858b43e2effcd6fe7196f0670ec14f5e64ac9a70920f75ed60830f14617daa413b7faefb5c1131218922aabcb583f930c8ede2fb730fe288c1a7e08aae006819762662451dfa84bb0521c5943a55c9348ee025d91cf03add592f4ee4ee6690868e31ebb11b4841202356a1f78c60ca4f58f8b651bf9d6f63e20847f48f2d0834afcc3e6a9da7d715b7d26f2d6f8005bfa5ee41a7cff658b1a7f92dea339b634b7b6fb49dfb09a41926fc5d3ff5d2054189d46b7880b546dc3781e476387199d5200df1eed2ac02970b95900072bc960ad0df9f16aeb72f22b36998a8781a6cbd45b78fe42d52b98cee75c2396d950b29af76cd72b08b5ef960513a930447920cd3df56537ceb8cf04a06215ecf2ff74a955f6233b79d331a00a5308aa40b535f7025f49b8d9a7b689fffb4568e09154df439d57e76d5939c8c038f4c39c0e18577d26caee92042d74ff8736f6729733c018a4c7e69f1a3e3fb8992c80e1fd1f06a5d744075ada08f061cc294aacf15eec0a17f4bde3eb83b549ebe6976ef87d983a49c2b3e168ce03f34c7604a96ab357b56f8ec18a824c4157ba410c7a6ebbc525df11eac4402bc19bd9efcb78f31b29549063efbb11becb35f2443193907ed4645bdd8f332dc10e5c839b469e10aae37ca11eb529af359e3d57ab9e794acc78f2cc1bd6a39e77d2324846e58c436d8b17d04dde5c7d1c7fd78ec57cfa1aec35ee8400ef8f69f93054f5c66bc2768a6106aa74dcea2a3443e53da7e737506402b63c20c01c31252e8e750d4cdcb6703c631a051863afb6c3e24aeae6e9c2a23d20db82182ce695578513e7ed85d616cd7db512784a9ec06811dbe1e1fa1c1c2b1f95ffb7a3c9dd0aba1e53f6903c48c8afe82262867d82944f0842ea9e3069b5366d90f3d12393f2a24ce03c8c4329e2d71d608de35e31aa04e0f88fe0cc69ed19807034c4ebee4b4b288ba8c4935c561d16ebb266ee52c1fc6b118a56cd3223944e19eea41d010de90548423f20c592e273e152b100035984777a36a3ad6cb0f8d12c3939e733b1d5612215bd87d4b18efbd3c8e0e7b042de20e09d8cea7165d6b63d0886e4fd18507302006d120b8e01518aedad6ae9b1f1f81ac97a58428a041820b045e0765ffa165202d3cb78734abb1fcef69298640d5adbca6bb03d2963aa9970a30f12cfbdae52bc19eb35f2711ba12d58324fc922c8af190d69492b0996ebaf500b7578835c0baa6c990ba5a39c8f57cc8ff47354f9f27c2de359f2561ea1fd14776899e520eeb6c9dd6a1d2652418bd37e90a02839c7c3759f78c4728616e4e4e088e471df6f2475e8008c9ff127f117a01428553f05c085cf9fbe5df21e59057e4d7ce01a9f33d35cc2b325d27f10ba0692eceed386e3775009ce4c5119b623198e79b0a59befa76b0f3d4b522187e2fab2ea45a2dacd3a4f30bd2acdfcb6c4187caa416aa5335141024175824fd6aaccba3d5601165250e79a7f3de3d1e62e19bad9cd24f966b3f7f97cbec05fa80454e3d1c5c2c45cfa8b9a199a9937aa8b92c45277204244de1139a1f7425daa0f10aed66a5413bf19933e82c5f4e77db1b97de633c3d63aef0b8cee46c13b9cc59963f7c386498216472c80550fa90e2572568a1019eb365b2397138e711d8c5e7225eca770b4afb47b896ffc7bf5ea10714a9428585f4f1ff44f8d6cb8b2a4b995474433a5e702e1bb0e14b48d9832403ffd773b0a76e1b4419f211ff207f383b580df4615eac35e86ad1d8383f91fa8c09bc91b4d4e3efce42bbfc153c38f6052f8d72866ff300786a31c770f1d20293943afc4e2955a09055015daf2739b53679f792daf07127cf813563ac03206fa7d9d36829b8f31f09e091be6683e50f190a91cf1414397fb1254c39a51936811317dc90ecc51c2b8b41337ad61480269d53df57694bf13a4a9c6e603255621cb1b352651b5419835473fc9a11d36b7646961804e905e00042a2e6b1d85315c1fd53d05251a115f7132014a518c8ad40fb82bd38ad450467f395188c8b827e149fb48c74670abceac0150cb1a5fdc2f50ffceaf0a2b023b2ddd15809b4654b5e8b65564345602d8ffb2993f2199a62e231414a1a3f2c92ba867c9bd1255d69358cc470b51a802c13bc1b627cf9c06dee11c3502c758b78d4a5a559e076f9e7907ad217d012e88677272ad8909cfc158004b752175df416eb37d976b26cf59f9be8fcefe0ff373ccb518ae4736b828839a0e9b64c359858eb82930743f18166d33c27a667f32f194f10816f9ce9c4769afb528d0eae497938a14c8098f1778b45c48f6c4cf8d2dd4641690e58f89a6eb6729e94a3c46b16bf61a318bf7651c2416d2f2247ec5a7135eecb4995c0b5fdac0f6e70487f27629e2bda42c17bfa4c5e3f361d0147fbbb2ee7bb86a2f6fe291513d789df666219dcfd68b2c47774364b859d7a0ed694b3579636fd4fe52e1f370b0b88b6acbffe6b0b3c93398e0a2205a3abaa1ccb0d7dacd01b420844a5e3d25e5e252d41fd5968c893d657c0d01ee65432f02080d9529e1e37c36290129d6fdaed2676e429a9224d5177f2fb3f8f58401b187819d349361e8c65faf29f4e68f04905e8c910d4d8696e4b607cdfe63231031de68af2d466a8f918ac2cee3100d5a2c849b397452089a49cb55a48abd50131d32ead340efb6e933050896a21ee301724f66221246e7c9901b5c1bfc3502e27abf130517d365285455a8929df5abad7cd9add161b7d5ecfd4ec117f437ee10de99a34239cf951b4c6ee702ca5079ba6145ec4e039c2c750701d7883c590c40c56c62caed447d4c9f108ba812bb6b4740d5cc837600c4b825720d75f5fcf919f555a6f2191b811e1aaad559ea9d62882ff6c0d1f1b1fcecc77a133ea7bb58b5abe0764fa20fe30050b71d731312d6a6b257a10e75b91d6f1811da338427989bead3d4e4804d566a54d0550d264e6086f3a77613ffdd89f134e975ad5c55e4796d33d0fbef390d4c2c6f52d9556b1b390c7bee96a644384373fd31fc9ff7611e7e468115af652dd7607b12faf42e9e99fe2f99bc31b2b656139a224c55dd51d3d08984238ea2eba5da4f58d14c809c3d5143b4605ee9a1d298fffad2834f91f7bb1e80f2ce65a0bda68cb3b69c4625fa20b7b57a9f4749f78d724e57725cc16bbdf9f4dbe810c74174f43a9cbfc213b2745d019d08bba52238eae0ccd55b0e6d5ed86f4ab470d37c8303342cbf6597368d34a9efd8fba42b5a82ad3834d5e731463332c3218e4a24d91cd80c41db0e14d7f6e63baf4cd5dfa432dc971734ee04b61e6c17ad6812dd9ede74c223fdc174b0199bd2e1c7666c3561f8cd50ff3d3832023338fb50aea55edf1801ec957fad052ca423071e5846478ce10af8c21c2025ac176ff2a3c6febe13755a281b2ebb77875270355977645641e92eb5033999db1ca5dfb8a8ebc78a26e873481bde9370aebce51dc91fe25b896727565bf4374c3d8d947a7becb7d7212daef1e14978fec0285fd83ce3bc5bbccb9816f302c526f6dfa244d021ec1f8345cd611b51fa54965b37c2d81a5c25c5f72010cc1eae063df644fbf666a03af100d046e69aeb9063d15bce49fa671e224e3e68a777ec678a7e15c54712bc972156725d69f55a21325862850ee0118824d88f8ac75b9b9020b8cdb09b5f06587821c3fb52278b255f2c647903025287717a73886ea002060eb4b12df2bce79e69acdc7cdf1afc1dcd119d05999102c62c4f6d35741b16b433289f83b8f042a521489c0215579ca8d29a4496516f47a30a7a3d1da7bfeb5a1e18d83b866dc09810316a8104a4409ad283778afa65b24af2d3ad9a59bf8ee977088e9b0a25a7f787652e35aaef22c2f2c1f7d403d1dc5bedf250f292ddd4448b3596830599a2b612ab072f4d27e4cea7d13bfd15de728851cd5247e6034fab99bedc02009a7135b32cf677bf49e446522aa6ade2a3103ea4127381a6eeb1601b3cf910c74f13c03f8732ba2a94a00f1e34a3d25f74ec2cd59dd681933799a317de56d900389724701c0ee4e13a07e7f1b6c3874a39f4e2b0d1306c99b58fc4ccd34a89dc9b3170c438ddd772048dc4096e027c54d161cd3b985201bdbb0eb6d0e7092966bb0be354c8f4b4b9331b44392ee21fbf274a65bb2181c24f46fa54ff847b4d5d7e46ab3d55cc5272e572aec154bf559f7a4b4bf96f1f27580d56cf3e3141498e66251e8a5d7080fa2afb0e55589ea7fa9f19cda372ff9ec72d1ac552c55d8dab9d861f40640235798a92ebe13c5f3c4a5fec2b28abf5bb0df39600b76262124d33e2c1709dc2ce94f87c6be36e8c0916ac3ae00963a25cd8e967da249b5e48d11e2b0f0c9e489a48b4167c45450627ec7fafd99033049bcd10e9522537777bd2681cbf07233de7918ef149e97534a6a85b0fe1365e3dfa6cf95ef705ee75e0a6e22d55e9ed5da9f32b3351b95737b3fe5780625266a651cbb70838c9d367e0474871f3edc0d8209922731991d08c2369a85ecefb271192064e0cad35965af33533b6c9ef1ad942b35e0a735c084e4655617f9adf782dcdccba91373479b510df7292efc26b3c2077db18931952d04630ac5933064171f2a53b5203e595d73969863df5847b64cb0c441eee84bb1d1e739bc60d316354fe3cb7f6a2183534fc461f7a09ea1d50259e7601d7ade649766e5fe9df5f3136fc2cc0041cb43a6566fdcc1c9b5ab4b5e2102cb8cb3d4601a4817b204f8f772b4189bf95e0e0af2a40c7a54e556c16cb5fcb433bd2a8323205182053ec9d2ab0eefdb2b2cf2314936e8d8a4dd514114695f65ab77988853141fcc0ba6f2cc7f6c2fa3be4df68fbbc8d657ae46a849f6ec7ae961b20dc813be0f11ac4139786289aa0b564d29b19633845262b2fb16ab1b46c4ff818438187e08d3edfdbd72cd0c4eae2c546cf2614fcee6677a2e98fd937cd5a0bc3e096f18dc8c0fec9cb3000cb55ddac65d170d24f8f7ff052ca7d4109559caa3e67484e59981880d681f8a2c29cf38eeaa709691c08063604c6b71981bff3cc486a2387c86651f6d32c00ef1d6d575f9158455fd0adc812d75e65ff91e767bc95f7cb14b54cb031e968a01624c43d422c50bb60a76574094e118ddd167389d0f83fdac0a65f89003fb228c4897ab233f96f2d707c918fbaac647a62b5bfce6844f43c63e4c96bbf0a9eeed8cccc17ee758f26238b9a5bc665a29e9cb971a7bbad5f5fc865e35390ad2d7efd16412b428de8222e9c95e0b4460c0fab107f81f966777201ad920df355a61231ebdb9dfc2e42c50d0163edacea30bcde33855de9a0af430d504299f87a0d07a367f2d9145dd60609938a3d22c546e89e4ef82315e4db1cfd1dbe94115688f8a32b682bde80c6eff5d81ee85b63fa4f2e68b351c7536bab53fb705ef88bc7030568dcb4b2b59ae757373e1ec564c6b6869a5b38794fc56c0b21b3c29417d90cf5a2a7c161b860f968c0e092757d4cf83281e9b181d737fd63ba5c9c8bbb87195ff26eaff08d90cbfd74ab5266cbb32c4471c4028e1741dfa1bae09ad279479f0da69a586fc5c482e5166c3b5b3618cd578ed19799d5958f94bc9a3ef6d7dcc03837cc200e15cc4f636f1e5dd11019ab8f8ec171f81a6f0c569810981aad9a45221069172f0a7e50b0b455383ab1d168abdc74fd607c9ee530d270c86d101a5f4a7adccebd20bc3b25592ebdf3ab49098091ab171550606bbe8ec63f134b92b8c2ede4b3540e5950fb79582036e7a6737ca47c338702af8c015b99ae732d535733a649f8f37776a13f37266b240fc32cc920c666f83955dd349010e940ad5e97ba68206fb5ce01274e0945b451abfaf178d1361292a802e701aa06342dbef618f4e609d7c14bd489d9de791464b5d64543d0031adc91006f4adb161f0649a6f2599cf63987ee7b59d70a4a96a2ed8fb8a82c5ea43ee24c305557643ca0d2a298611c3d081d3293f26c97bcb430dc65e64fe86a82ed27e5255716878300506ab0f5d48d2654ea522688dc3d7a365992791eeb69bcee4e5a4f24d0ad1a4cfcffe1f0d0bd05e19cd4c9f962ba6dbab01721b8c56e7d8ac40b4a35c2297f274a5563641dd7d45fb93cc60d9a7dc2db479523a2ebb4d96e7d892704034680f938e983e74930db3387310aed393864d0078bdce23e569e005fdc30c5b3986780766f1b738666c5aca7974c60d83acaed4eea68dbd70d922197d07c73d3cfd0e43d5666cfeb82009d82db9cd54f2d60828148d0814563d28cde9cbb928f04249ad4c75b933ea65e255c6fa21ea35f923d659f8a5f40fcfe97394b45c34de1ae7ed10f21062002756d97e065001dcd5f63410fa250d996208669c687bab5d6ad04dedf6205fd7564e8b6faec5446e0bc8667ebcaaaaf58646d905376e706aff9c9ac985ee6b290c913c9689064f23b14e09811dd24add2f80f4f1f6c88ff21d2c217e0b24a42402c187e0db7b9f56c40bf7572d4532802bf2f13bbefdec2c4847f5ab079b86ed392d061ead7f292adbb7377cca8ced0a507f401c8537df8d083e25f8cc5f5af319d2aa489bb640324a93fa90ac7c1397b6f37280c3005b29129e9d53a9450ea34a397a70432d21dc23c4e3b38117925b290312167a920c5bfc833f75d952ac011c8377cffe47d3d45cc9773e6e31672927cfc44884f9364f99b1728f90e0f8f1050e87000e5be0b89a03ee72f75a8b0d5acba8d7369f374821488bb83e401ea400bcf350ea85f1e0e986a8b564ea8b6e434e0b8bea0533a633fa09fcc7f9e9cd06b708472de90a4712ba03402c7c5a8e4462159ad0f34b1a6b9c6d9dc7e1498effc7b2e1f4dcaa77f967daf6f2310523dfddf765bd02bc7be07b9be209992d5527f51bdfc533e874fe5abb2fc9a9bf4a05863a7e2ee3852a6a9e5a54f9c477776b7baa61745933ed1cad2a71c1b09c04e8ec3c71b0738510799baa7c12b2427ca5e1c1112c8f7a536827a526426ad5209a77c88eb378de3d2506135e5c2579097cb5e657d42ea807a5af57b1bb5b667b7bceb974cc591e16d600d0225daad90c7ef184b9728deb7a08aab8f91b44b1e469bc97acd39e3ea5420738eecb6f40a07c0a1b8fffd1c19bf8092b233bd1dfdd8671dd063e6168b74b967f1fec17eeacbf4d2b6ecbc3c1be82c768aa1e0ade47b2581c9dda989a0e081c959618658c12b4e1a327719070fa66fcce9d2515e00d0e45af0b43bb876912d709d599f9bf47886180aec30bd3b23d402485a795e8adf3518584a08cec11ae28511e0aa2aaee93c297204c8b694d927a292987ea028b00872cd3271ad1d48cc8c91c20606502c836d5a249c57f46cd01840c3e72ad8b49ddfb5c6ac3deecc37fab66376d50526b80c4f7c6262c355cd5b53a2ec6f6cd0aeca062eaa157a5f110590ced50fd25c73b241fb9b9fb7275af1c780b4b092bffd2ecd61993a20a72439a00b19e4d095453d33d95e4fc1ac0db4ba05ada4c19ff5c14e6eca673a5ba1a7658f2e9b363b74cf2764c211564c6373c4c20de6a162c36c44f49a72c5af7587f96b6d22153dfce58b6c2571359e3aa230e8dae396bc787a7f908fe1c8035214c02478b539f905a1bfdac2838b2e9a780536379d0adde7f33c8e784aeae683cdf39538607ca07ab1644d39551f96981015c351ffc98ca11255db115691c60725945eba65bd2dd4f075773d8133c91e5c27ee9e43237a75c6759400f897cf7d37d90c50e9a5f55be4798114980c9067cd25c8ab4e483b4ae73f6f100f501484247c82ee7e4ae5391f2c702e4c3271a29942ee4f9bba85c842084d2d4a68f2e06d9ac2867ba9c26cbb108f17cc338bdddc6d926213d139836ea5fa49157458e8c55748faa4e359b01f5ebdbc72c059b6098889bd3e5366572ba5864381089fdab2d48ed9da638a3c362990e23b489c85bbd944f278b7a4e8fdac43cf0d7b9aee3a60b95ed04dfc7e6d56c5ccc22fa1a78b4ca54041aa6a44c3a9abe03978b9eafaf0bf8571dcbb29a076b1c220f35544ab71a4cfbd45da572c6bd78baab3edff0ce4afc1e9b9b2931fc697503726735ab8e44ecd0734ea3932bfc8ab777d6e51ad1baddf059f8a4216d84a71619eca7cc3b28e1f11a4cbc268fa44cc4a0193f8864c8f78b09c1f079f905d65ae82b09add500e3a2710ab09ed85208ad78f501182829ec9ef57a6fed7b1d35706fdb717904e70d2f90661138710006823fa40eab9b0350ad73dc8e1b16af60189ef66903270179fe9f14f8df3bd3ba7375f4edd5071c91e41e1fc89eca53dcd6b6e3de4081cbe0e49fcbc8b2b82b25bd37bebd8853dd14a6c3f091b2c24ad3f8b3fb8be6b0ed275557403091684f4beac0fb3aa0f800ba64acc539bd6593149517ddc20cb961ec61876a1578c133445c24afdd312db8750d8dcd17517222d6b89668d3dd2afbe5b59b15e03d7b1b748d11832335bd3f804175d07cce6108684482deddc4affc2958efb39bce96ae2e7f675d7ca923b76edc6ab4253fdfa42e8b8ad8a0cb90578eedb8edfeb0a4dc1eef59cd64e5b7a21b2ac1011df91d1befd97a4e671a831f24bc5f1db3a01592161ba6eb0d7b1a1b3bd1a372e9e5fd4cbe61c0e6e69f4e12a7864d33210985e09ee2eb224dc19f0413f29554275c8c3f9545d127483945fb737575ca5ca9f098eff909f56ce4b909f89f9ab0c591db05b60cf515033da8e5b381adc97a7fece0166b7814aaccb0a72ad95e3d941b3e8d2522486e8daffa96e020ffc59484de5894ce421dd50d605be455760db0a9a8641394b834fe87f1fd8cf6cfd8f3543156c85be7e9cd899ce37d81c5ebc08876b8cf65652037b50fda895e3a0de2969dce82ba88f13fdf23451e949ca8855f2d945c52d20d9094f0a2160b46f96407fb5928fcb2619cb1e7f2640203ffd2d2e59b49b0362d3884c67e334f5d65eacebd7e2dfb39ff3302a3b6f8c8132333b068658565fa24e187267ab0c6c19a864a91404af45e580f4a96ed35c0c7704059986ed13c8abae5bd31ea791cbce183aec5b9ca2ee9ec9a448f3d2465ccb1e66730a7b799b0b19eae5312aaee2334db1334ef648a4ca50654de0f2a601af3d377aedc1a6e2a49ebae98d4afff00aab196a7e159135433d8567f1483537d165eee51cd8121687ee592b75bdb744a275559904631c50127051bc3ac12809b6cffbe9d912d2c5650297ca6da41bbd98d97a1509c740e7b0f9dbf1d4882a545015cb566bd765048b305bc9039c8b21aff10c4cebfd72464d32f2c520d9ee5b2e36278a941b72f9f88ffade2aa11a6d34ed03e3e097e26571b95ee99056f737b5aa1a1eae848b0fe8dfd12ad039a75bcdcd19e483857533cd6a1b798972b5ef1e6f7a4ba4efe36e1419b039f503086f3a8fb68ac5716dba71e58af030d4ad2900d52a96efd4d7114517559fa8181a4f757c6eefa789b95155eab74f857692d4779e014c1bd82e0a124e8f6d9dd4bce598a9d14fcb43dc7c2e7016324c09d050a5d06942951d4775413f1c46c45ee6d3c3d0faa0d9c96be6632207eb013aeb874f95024a3c3247fd909bcd6734c93079c634b41cffdaae9abb3ed073f635c973f4856b3364dfbf0f9c3d9be43251a41959c983f51a74f477013f00b1187200f726336014f0dfa63336ab177bc74e52743e5d7cbf7fa5bdafa03e911507e34576d7993438636f8abf4486511073624ce13185ad86e1771ec5a2d0dc8e087232b65df0850f34e8170a634e87099d83e7a7704b3eeaf941eb0f393505f110bb12bfac6e29703f896f89fb63fbcc5cc8f207173fd48710abdb6be1cd4a6eb01e8fe7750995f6f0d8013a55902a50f75f2d9ddc7b97e247865c4bd5c5ca0bef27bb8d11f25763937b610b2f3ddffb922a89199bc37b6b4d623592256bc463ca8d259575cd7bb3d4cf2dcfbe8b4db9892b24f0db388394547f0ff1b7fb8e732690e1de865fe865cec3f1204d10b1aec2e7b794ded093e358f12f7f7bd23a24f0b498eccb4f59d147eeccb7bd4d3fdb216ccc81211a5cf8573a73e37c30a8208c821b584e5007cc618e46ac76a90179771ab91a724b74e85711b1bfecb166612b98c2afe6a03138c1330fa9bf1400e0e9524352d11fb86281b9662caf6d2c80aafb342e347e7d0f3b8142c155995d91023d333a4a8b04abf8709454e762663b16b0f7b905bc4ca254e01e27afbe2727dd0fdf622cfe4e853799dfcfbd458dbf3fb1f73b5d657ebaa1096a4ac44fe437761380980a6ee857fbaa86d13b51a26530a57af0c43513ae9642576dc226d1579d2795a94886483b72acece3967b54c03dd6fef574b0a5236d5a5cf701d86039c2a0e30b6aef908a619216c239e7140600d822d8f76e4573ace4754f8466dcf18c2a150b9d0a0c9825556fe0ec7c9d0471c05324737eb45a4eab318c04ce03c1cf3117e7d9117810fe296eb46a931b70cd1d4990d4b73734bc93f713f129869f365ac03f89157a1acc437877ddfc07bb86e5567ce15ea136cb7226c7900657d6109e849f382e20cd79315f260120200c2fca44192862d6ca5432ec6de47e1a2fe21bd13a4119e0215f287cfacc26efa5f1074a828dde68f85c536906e175b841a46b26e46dac37cc9635b89eac0e12d6c131ddc2ab367c3802e79dc0d8c70c9ef56aec9157e309fc065a3c99ec3ba3a9567ba65d88ca4163465bb8a10bbf74a11e689de41941117dcaa82982a4885868ff8db8e73ba222eeb34f606c5d9f3350efb81e07a7296d03727926c6b7c3496aa25a7ee821233827b03d4b80c7cd4a274aab720ecb1aa1e960bab209190af1294591ba6a16c936ce159ed77b4d68972b100cd30e13742b5f0661cadb060247bed227a7410af27dfc3008fe02498a0b0199720e1f18027b697a312c5156d86484703bbd59b29ee0015f84cb6133b4b5d67f57b956212319553b047cf76318533737dd39aaec1ab21722c3b63734c02daadc549a1698491119c6fbec77ba85567a43cc468678820a41e7f0cf2bf55c1f6a86d313d8e7fdee60654df824cad53b78b7ae33f1014dae868e8d5a0eb182518326bf674cfb9d8506d63be75f9f47adff8df3a877017e1e7bd6061a0d35af45bbd4cadb32793a7ecd242963baa665e33ca3740f398a093ef37be2d1cad96c9b6969ed008a7d344803250c03ddbb496d1394c8ab5c43fcf85b9829a4693b90112dcb1e1f805afd2c38f11ca10396f84df2082c67ca3448ce2574ae0d50a139fbaf721606b8d652adafb13f62e42b0f7c7df4077d971faeab76469f9879678dfeac4d6947e4f1e85cfe43b39bae0baa87ba43983843740f494a70604234f3885ba742acb04ecc2ad518c7eeb57f7f1890a4cf51e1f399001a3f48a438fb48f47b7d26c5d8e0d1cd5d9ebcd09290a85c189a0ecfe62b79b267836a8b92b95828da978824136e5addbc30612fcb756abe67ad8d069ddf38000aae65c6c8b64d67919748523550d2324d262eee5220aac9cccba8371f3971ac8bbcf7024e652b10f64aff17e19ad79bae52cd8636f0cd40e93e98b7375564ec5d346914f69eb40aeed15668e6414d9c01592512b6041ba69307a5606ec93716c783c6988cf0b38a3029650ff2572c5e877b6f365a3027c8b3fcfc0ff5bfd0b192f94b86cd7565ecd80a8dd986d2ae444982e1829bbd4dbc1855a28261c30ecc392fc277d23b826e124547a0c9e9e52f428d1781b30115dce7816e8cf070230c657aa422622c6ec3f74dde622872c75b50593683036d11008bdd1ad6d591cbfb2cc9f193c9214c22bf39cdc270c640c3a181cd091d1458a714df4dc9cad7aa425a7f4901a5758f425c9291e35a0f364af65d521e3f5056f3ff98aa9d09788c3b71402353d2c511b7f6f99ad7cf341a7d66d0b439c8117ae244ac4aa0112719611a43fbb96ea9216f5d167051649b830a25d95171b61e271ab8d53e047fd1b0582cb2fbd07cfb7c27c384197f92590e30aac05d0afc324981cef7e7c3a480d218d2772ef4390b9abe01da384b770fcbd4c8a76954b901afde964c5f801a9da8c4a3402d6c4e66f58c112503a756c1d724c1782468c82bedf8a1619626bcf7595403a1c358c85e0136143e3b6a382ea9aa67244c9795044b9d23115dc76fae8c45b392268f4122924b440ce604ed4063e14f67f33e4273ec7a39756187c658c9e46542be5fc6da0eb79e594e47e29ef05f419299256b6c78eb10791626b6c37bb5bbcea5cb9a7b2acae5f661a5aa9fb112e996837828605d383ed7b14c752012b746296deb7d496a7e798e45601029a22dbb1d9c18b936b99b057b7e093d6e5d5909e46c1a2c076b8d124f548459a4320292e5c1bf9e656977db6f3225735bc458b84f6f52f33f09f7365a0455ab453acd3059edc593640996421674cd78ece5c463036b70371228451ab0606bc274894b5a002c6fa00123cc4c51b40a9971afdf9e514ee80da65c8d9401856c1a4ed3ba3d9fdeb9c4a44f900d1286bf4c5e3eaf2f64fbf0b1cf7d710ada577389ca31371fbd24a2ec68fe25a0cbbc645217ed3460c2409f8e8f9ffdfd2a02cc1bfbfcc7fbc38f054ed5c7912b53bac5ae00102f33270da7af025a4d8ebc9f6c346ad19dc0b73c2b66ade2178df3964ebe1275d2aae91358847bd10140868e14f3c9cdf5cf291da96d8597993c10d61692e8b582d35c08864f606066f2ad3cb117abfb59530862a1401097533f92f269073dac78a6fe972a02a599128409b5dada0718ac512b24af1b4a43760fab8b3de48a1c0a6440c1e971f95613029f9208a35f191933dfaf81e820362f73bd5d8594114279f4fa352a13e6eed76b90c8c0c0e8d4cb6928de54f845255e3a5bfcb8783acc7c5d682a9b5fb78fe1f34ff6b309770bfd8058ed2c8d22312bf2e5047357d8eb1644316d9c57aaf2a63a00bd9b6a35593c1d1a9e0cc6d5c76bdc097a913249be312c06d5ae6a5a4de666ec29249265a9a0e76344e3d8c1ed7c070e852f198ae2c32e8324e73d23065843799b2d7cb68f6c5e6b5228515a91f6632bf6a9a19bed68f1ebe9b505f16e3bd540054a9126095524b5cecfa283233adab86fed26313b178a31c3a9e0ff8e3614cf55316cfc654a49a65e6232c1c9a9d8236c528bf1b62eaa8a0101d688e57d9e06353cbddd60395f304564c0898b9a55e5f00d6b6ac6d41b1affb73a444cb01501d16d13b5784dac32bf69a7688352d72013e4077e181e8d00a935d21234e668aebdcfab23b5e22e78cd6e4062371148cb96f58628be9763861b9cfc885e7afe324456c36c8f6b7ee64ec034e90d7310db34f9d3c38db956234fb65b04bce28630b715f091d1dff8984e7b523a3400935a0739396d7260e6b81e3dba3218dcbaeb257d6d940beb0ed0056f6ab154bd125379bd791fd7cb0e7017eb754c11ae79751778230cfeb17270b8ce58234091e06f8d8b945b8846d5f95945b5ce917d5e17e8cc151e30a13ed61a1b52a6798ff2c5f2eb37e625a1790f4102fae9e6357a7d11a3397a083a825f37bc0f84e07259fead65da95cdc29d4b715a5cc1cb63548bbfd72bdc81a5c5883e21f0680e16d89c775e32283462366ee824c72fce0d2ff87cc15b75c3c717ae6c6e39a18d0c5ec83c6519c33fa0f9eecac7d12c4bd66ee0a361f3d122d161df735f1ee25b4467f8c2fe57d568309535a837b383ee33b8336604973650b1558dee5ca40ea18bf80e5e0b8ad841b3a85d1df745a5695883852f40d2f710ed75cf57f647511f15ff28f325ef99cd144d56b6833b2b59238658c3516e748ab59262eeeaec8cd8338390ea4b4ce94c65ee0ef4f860f2b5b584f6a59b0ef5a0aa4dd17b4475ba837de24262530e81b7f11e8a4bc7b1a80365c6973e3f87047ed1ed2fa2daf7e4dfc54d543d9ea4d6bdc5cf766f7fe199875b3b8371e37b3cde55384a206d811fc9bbf67f97126b9010783833725da26a7a8fe7abafe70c4bddd66807cca4fe71b8713f75a60f8070478f8fb741c2e39490c193233c8a4dc0d135af2aab8b8e42cd9206dd9bf0db2519585ea55a7695f952a569ef2fc92b2cd5374be29d1d0a6e96194aa94230837fe252aee5c0ccf40212d577f8f44c7c234f13d5a55850a148e7541c9099981fb25a9bbfbf63e7eb2b84e822db9ee1be2fcf4746d16849bcf2b082681944ec464992b0dadb7ec3ec5cee545548038c8f202f996fc66226ca085783436749bafa75eef69b13286f6b7178810bba55855273ae9c3c35e8f2f27c0cce36db53a0e376723344204548aeb92aaa69caad67be493673e8914e7ea7dd2e12f052b0b8129776f8e4a3a01f7248280403a26051caf51a7deac45868c9a1c5437cba01776e0aeb190187d140893c80967d9f80f40be0d7a0894c61c788eb12b7188f4bbdaa6335842c7c6f70c18790d35ef0d70902e60c82e939d454ae62d861620d7e12db24358dbbe8459c1ff270b9c1daf5f22013551648ed130d778a718431257d36d2ed74eef4aae2b43efe613b74085a00372f3399586b103ec794a4703204ac6260de64f7180af5162f2601006b6f96688dd3927d9ff0998fef40b3e6759fba3a4ee99fd5824a033586a12927ff90ffd6c8de53da2205ba68c8f8d27a0e90ccd5a7f7e5931bd9052a950dea9ce68716abfb03c5553dae022ae78452585fa327abd3b143ddea810e40bad3a0188f10019c7977d31863ff8287b5f9bb790e2d9f974ac34539d11d4f84aaec3efdca03619e84d08b72edf85e055b55b62ccff73c06aa4214fc487182ab2439b748babc15758b1457f80ab24b4e14ebdd4a446c46f8e0b0d7a16d91a5ebe52ddbf16697728e76ea661e5dba258d2feed59b2d3ffeef6f65a155c2edf69bbea397d11edcd8e0fa9d1a875993a8952ffd6d2e56f09829fb91595f9ebd8dc6b51e6b189f2ef867ae02cd40b555404ff08abb2a148148aa6257f47217b37442435027d293ac0b10e44b69f7b65ca0b1e4566d24c63b07","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
