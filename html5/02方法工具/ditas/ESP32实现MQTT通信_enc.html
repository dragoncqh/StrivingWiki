<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ffd76a38c2c65d65007cafcabf7889d636b4107376a31fc33cfdd62fd53f0c72875f21f7a103a4716b4c6cce3dc4c4236d05f878360b8676672a42713a285d4e6bd68f9745ff75592b316b7ab7f48bef8ddf03a8b4903015bde623bf370c76361cae1f893667a9fd46243e80ea3c4d77cac82b4e72e7f42e72acf336d1154687569aca53b9492b3dd76ea3c6c4850535e75b0a3b1f54a684fe9f995133ea80231d5e06358f9719fd53b11083c0800c43061be07d074927a4cb406cd38581648a426d7807fba8b4155a8d74dc984c4762ff5629e35db621c7336a959f417133f4b6d41735e8e29ce84e1ea3978446a7c364742d5f36dd158c481becc341588518cab022ec6f7adbfad414f26304f2bfc6951a7c7b434703962dd20482f464e43bdfdbbc79ea81fa5e2b96f316440c2a8b43b4832878395f9c869f76d1e80dbe6f1b0e40726216cd22ffce53a445a234662f0c362549307df7050111b1a0fa567541482eb9213cda708f18bb204006d5ef88721c3cc334ff3a8aeb5884667e9c2019a4d1922d76ed67b2d3e7b28d88def98d7f72fd766236660eb5ba9036a6a3262ebcd9a52de7b93492e8d2997ca827783da63acbe53a69b1080da1b8e244341c6f647bbf402e703b8605a41e144bc4691c1190d48724cefe6597a5499531ef78a2fdb42e662f7a0cf40a1980ba84f90b078ca9983f3fe12fa1591789442dec069d832596cac72e469dbeb244ed386c1a63bc81896dbba39cce6e416592e667c292968525e4bd81a34b517a3ddc023ad904f639c752f07bf442cb4a8276b6fff611356d1e301f1e0d8b737179f9be019688ff15b0495cd8480bfd11c981292c5a239465d31f0ae7e1a7c333ea44781b3b6c6dfec89e634eab05fd7abab16b0d6437e25abbde523aa844c2464ed675ef806f9168f6a1a9ee8f0fcf6e41629030abf010fb084d0a6a1e74d09fca5ad5951a185720d8bbc417f2134c281cdce2c900024f81df047137ae13ce25df40038481f008cc9a9cc2d65274f484d619749ab81b197f7151e2ad6adc3d052d22ea8a6b8dae5bf3cb8964ad34b7a69b083ca0f4df417266d9bd90ed1d73c16fb45d6ed1031fb86041203af9eecf216d837808a9fde8d92eb0e1abe5173cf341c320f0eecdffbeeab49231265e458fd5f79a10e8a768aebefaaaaabcd1524ab38be4f276435e5dc02f6600c9b4ba40a9b8f050814df99add5e1546dd55c0b5c06517e9fed71dbec7dbf0971a10005ff13328c3894109480c0b40091708dfed4c1db7a15379cc6217391dad5a9b22598d44373ece84e3fc45a9045c913ef85e4fcde5bd31ab64ef13b7f1d27e0a02751ec604d41b5a57381a4542360df7421e0f3dac876ddb320f5ccd69a87d627a856d8ed7e27d8de5f766449ea163b3af8740c8db4e713667809062c97491a018a760093ce344fcd15685411f28d43f933592a383db81cd9f47c419f61f257d9987ebbc78d11870b4890bbf77cbfb6556631cae1fe184bea132d392cbbac63d61ee965c6cb22ad72fdd4a09f55330b22ba85d33a334d7c3e3476ccfc84fc8ed10a15f5a68bce000a0967fb16a19ef69c475fe50aee8d00a85df9d8bf48cdaab00b2409e6e078ac804896deb8c2d4ac9b839e89048a44e15cce19fd924a24d46583ba2843bbe81fd12ff2ef30d8d9ce4ba87b7483777730cf7cde547eb7c594633267d1b2387f3de75e7166c6d1a8c75cbdda55112af22e53550acde07e48ceaa4353c32b3bf87fd77a963f18a439048191bd455c64863c96375fabbc0887cad12792ef165b2c7819db8add3fc541f3dcb5a39ac8c4eeec93a78258945d2fb0f7df44e37c0f5bc931beffa0e35b8ef5fedadf309a8b77f8973899223921513faefb51a75dbf4f45831914651e65fcd4e6fbc0383a7547fbacba48a0b95a5206aee8cbaa25612d448718cfc5eac518d6b2be65fbba79312d803b1cb824db5edd01648c3fa17c93be49f35640bab66fbe852e8cd197cbd16e48ceda2f17a318bb85ea68acec2b3d4575db96ac6dff12d75c29db12fe3cc4093dbc5b8f7d21e37faa21a591bc5edc9d9e615e1caa67c508c663d352f8d737afcdd78f548b3785f8149cb694866a73d19e11b71e5bbc1c7dc9c81a41a8a8b99bef20ca2adcff61d6d641197766ccd6569dd43e0f0d95facc84fcc924a1c06746d2bdff6890c861caaea4de5f201c8f1569a4f58556c891f3fdd89ce8750f118ea1b58071dc19348aa21342f0881696b6e5cbc4b93e128f1501241c5bd60ca87685b00ae3ff0f67ca23cc61f0bbb6cbf224e1a4b1b0e1b9831d57f26d8185dc33f068952dfb71f2393911dd728467ef5f915966c8fe358eb281108a4248606766415b91723f467954ba035d7d7807c3587ce61a3b2922885ed82d1be5a40dd909d4ffacdb0a03a5266435a9d4461782da216d3a9d4cbc5cab8f5ca93bfaf3e3f5267bdd26f4f3b3b2e2b62cb8e602fb38383a6a48d74be6827eadfeb2cfd3d24ee2d66e2cae2af073cba814d0c5986e4eff2dd49ffdd1dcaa549f8e11a293463a35693ff76ac675bea18b4746886b7caca308b9426512e5d43da8558323598e80407ab5f42824274faa953944f5d8762d4b4261ace509eb67f403091fed4bebc9a8cdfb06f3297a1d92bebc9da3c4141a496d7460629a6415fa8e28ac32b5b5e569eb4f2923c87acecbfd2d86dbe9dbef068cd4fb0da14622031513638c3942a87ea177ba8ce706663d9d2d91ac9b440ba56abd45b70c951af44a91d39cec3178007ddf6fb98963fd33f841d040c586da2027881103b496dbd09ab6d16f99e6c046edd32b8623f7685c995f49afe2428937639dc132d21629a835864db2af1263f1f4f5adf053c8d563c5e4af67a16871deb75a608a0c24b2670ef795cbdfc5dc8b225eeafbabad963abb003cb7038f85945e973ae43d80fb428589e145a04c98d0b4be631542548e2ab70f69e66b8ed994235c7e69e0427aea21cf68cbd528e438a5401c29a11a38daa2aab50731f836e566e683062ca13f9275618f88e34f715dca8d9b1af4966464529a34f997f85247c3681d4827f297135ddf0c8ae12c4df6630144dc3503bbe2a604b345e1f616b70927549521974c0a26b74e5b8bfb88b0ebae9c842b78583b2f9e4a5e35ebd659acf88636b426b8d94534b7669c11ad27731892a850b59ef062525f93ce632f6a882e63a9cb094ec7131e1347b3432fe8adaecf555a2c3cd9e4a9e0e272951614fe02358e19f200eb563646aff49d32b776481f31de87c88cd76cd872279f4e0bfd4f11bd5163908bc4031b032049bcfd0f46c33cbc9b38290e2566c841fbeaa59515067a399248980e2089bc0d7a77a3ecf5b9bd02b6ca25947247e881046175517d04472f79dc5c2f26a403870f108fd33d4f596999535373d47b14c7a6d6bff48852a1a5f6328db9a1c45e057dafd486c21a57e21a2c05680da8504fa07926d53e30d45db495ed6212bb7497edd3e091278297f9e5b95dfca69a96545aed47a72ecce47cc8d699f641a2e09a50b4ecb913a6be5b39444f8dad9f7bdfa74a98df9b425237fd48fcfb5f7ade96f0fee4e2e02fce92c41d81b5ca50873c0e5991b1bc26c1f4ce2da15d017ac3fc2ab381b789889aed1ee46711fb663d98df2890fde0cb12a19bdb042cd449db5555cd037a027f5c316b44350e8b5518501aec1c00f9b5f5b396efcfd66f5fc2fb7fe453ad5435f09bf00ae2e3ec6ec1ac869734612eb9e36b1f249e2e8854eb9e6e93baa861dcd5a3427b3747ef5faec3afe82b902d898cd1654c65d58c7203534103e5b21097cb229bdb1e276362c51bd4f9929fcdbe8060f3e0b79fd9d25630c76033708aaca3781e17d75c2f92fe4bee1d32e70b945df0f1e88781f395fd3329278b98808b5142de9de30e7abc8427e267c2a228176a5f28340cfa886aa24d01a04dd5ec78e6cddd6bb8731579fc7a3b8bf19fa6dd235c6dc46be3690bc8808441781dbbbc873b890f22a8b94a187accb0ca815e25d1eb833e0174770ff17c0f15e0ff6a58252f1a876613d4521a68a36a7979d7622e34b8675d3b9c0e153216ad16b67ebbb52fa0abdd71edf79b02e14648236dd6c67528ea6bac81ad239bb0d6038b2621a269a1a5de4ff86f66ab47bc3438bc6c66e2000e5d689a57e12a48dc087ac7b60ec2f9bef88462b434da6b62a2b7c4eb11639c613de10ec1b60b7e25b14406e7298c318edd6ae712dd8ae8f125995656970e759a526f4eed4e6aeb4b8c2e33ccfd33857b1044439d5a56e23812a37a841652e0252af207aaf7ca0b1f932adaaa413732cf11cfd7124bb6d481c3a0e78ec91e4c424037172f33b26e80710dbda587dbbfcf418954619b2a81753349f948843891d61a9bfa279f9a8c22ba368184c637de17efa74bb2a59f218bbda03b8ad0d5df8a88f203632431a3ee3d535f983e5ce8f792512edfd63c74b53659e96303d24af70267c93991225bddb1b79dd2fb1d51330260b67b29da13d5350c19fcf9a277c9bbccf8ec499958c55e695a63855c2400a439248646e880c5248bf8961a665c7d8f694bd9abd5642b9cc2b2f48f04b5c2c60247cdd1557c5c8bddeb8f284e1d6495df4f8876766f100ecec3a3016becde3ea8471636ab23b133854d55dbbca7574c604a7501c3ee8edfa8b1af157eb3b4e2d231451f769f426c042837e267558c1bd142a8b4fb4294627ed55c371b270e50da19b7afc1a95ee2568b979e6995e665e2012198e532d944aea014de20a571a6b4653bf7572a673eb886c2d1adccb10dc3db06a5923d871f28d90b251bfb64b59819d486c3c3416515c850230e0a87d7fbdd2a6f541feacfe56a92b8ed93eda458665b7edaa83b2f0f6bf3f530694510554b5f423a186766e6189148bb6b3a89a7463629e4720afb078e6ba5cb5ff80a54d547081901725a9995a1b4fe3219bb6a362f8e1333501da89c8a941ea3b64ae5e4cf876a9fdf7830f9cffb6c61c83a0763b2a2a607d7c8c1538c94ee81d456d08612cab794aabbb098102c2eb07f76948fc60f312243154096cb0686a6a290ea9654bf4d1779463786bffcbc74ce40b0c3398eb458345f855f3285fa72790c3a756e269977a1f861a308471c97145f9d5c1c0b4c53013a35dcff976a04bce21aa9f2172ccc9b0b91f4b0e353408872e287b766d9e2e9fb8961d18d7fc1b0536f5f968e8bffd7223e6063a449015981da72b7d44802eeac97aac1c635a1e1faf353ae617714d20e61a7d04a43c5433745d03a3cc5254a121b4cdc07e9613ab4c737604e7e4368113a8a1daed26220d9bec96a374777bf6fe000e5078403eb1b1c3d109d4d64255306d2b7d29deb3dc30c3c253a537027ce04c86999b74174b9d6caa09cf9f2c407f0ac3734fd2bc4d0ca9fc3a4068718cca2bf36c316cf54a50ec04996b102d91759b35e3b8b2f0e2e3f8f2dac973cef10cff3ad4cbadbc20549c99b934f19fd5e84335d129fc8087891465ac02bd6387214910a544596ec8ad0af7c9d9b24ede81dba8bd75d01e756eed77fd64224e82a6e544ff98ac282df3b2627667d39aad8d2d3b620d4a5320abb7e44a32b46ff0377ad90f5837f34e5a4d85b59fcef3002fac0d174f385da84924fe4ad42460f2ebbec8d120248b7a81808536a074705528226e0a0711653678dcba58110871c7b6e25b293faee451978b4321e192638bc9b644845c978a96d2463c4af79f4844df68b1d0366228887a29b587b2af6396a0743f3ef1df925f8710e4c1b5983753281e7a4bcdb9b672f1e08c6b5a384cb710171ab02bb1201a8a4348bf3865206161a45e6d95e950354dc09834085671bcbb4566ed33b1bd2d23416436a51258137b57cc5f451e82a77aff143c95c3db999fc7e60824d8a2336099f788b2b535ab0c5a7100f82f38b4356928bcfbb4f40408189da4379579f7ef4d2a6562b6e517903e68cdccd62315aa5c8bbd229d5a9f1df9e90ec76302d3c8f1f988b50fdad3b65de889d82b54d446ebeb03e2a9aa1a4065cc269ad2c55a7723e9c12d47a009adfdd0b67b26441d8c4de887d5b9bec01dd9e5711ef7c0dc5069a43774bb8d80e6562326c49d85887d354e2d37031fb5f91e7f431a265c48a8e6150d17a8b00672b9bbb8578f893f3aa6af73aa0a4d052e9d75137eedea40a63d988ca67b269b456568f22e246cff73ae19ebf51223f726a5dafbf4dacb334659eb745e1f5a5bf5cfa04fabb8278170f63c799ba18e67839857dae9195d5adc249f20d1f030c7f10a7a553c8fbd79aa566b0f0848247eb373d328eed4c0100496dbd5e7b8b2460a6f87c195a2c9fd91720f8fab4ce8df9690b830a53505a3aad14579cd12fa2804f38d524bd6e0bf297fcf006355caf3826fed604b343934e00468e451f90aa9b6cb03fa1577ef89f6e8b6523fe55d880d8dbc2833edae8a6fc3b20b0dc00a1e111943fbd119146bac69a64b5e488083b930b8f5253a90569d2d6cfd9428fcc0cecc2d69c8ceb0b5adf35454d1292c3d7028a2e39429672ef1e451a582ceb0eaa494a35223555f053c3e21560229fe89586331b4011ea320c41827eb68a01880d71e35a6f65b093a49a28096bef6cade6a643a7f4af6a264d65ca140e74dc1925366498cfb2f09e3254c898c557ce43e5f3ad826614cf352f060cd6951de66f4ebd28f14e6b67aaadee146f8d2d0032b78f22fe5c4e5f07d9dd3818a349109f28e3dff585f346bda3fdf82070b9af2bade50f29830c2925c8faa03c33c16f9b579458d8f8f9a538f8436d5ec399c975c2cf0ae192761b90f0b6f2c8d09d8ccdf82e00d9d0e1b56b7d085082c0629b4a6dffce635c84b3ad4d8885c6d33ba07f3bbed423119d9019b60728c41fef8704ae992d372485125e75ad1e84c9e7d40b45c650e0af69cb88b56618278da1a1eb5f44b3c3d0c74baa40ef78059487389f6354bd9c2a70e1df31b364e8cf496908d610c079268c0d15f6cbe4a1a3219e6ec09f27d8faeb24810e78c864e0ae09797acc52e1ef80ef74a45694fa98bcaa10e07798a59f806ea071391d56dc84836f64956a70fa750d996f29f87c8d50578c0d80b1a92d6dd84e05e6b6aa47883279d2a719e5d22db7d49790efafc1c9932b8d4de9d7fcfbb40875d1595273e31d03dfb7c504faf012268ee673d428702a996b461366263b1b854d6de343cb5d7dc1ced0d93f9dec449f951f70b92279eff6f0555774600b6d63843c38bfb2fcfa287e89b99b87862694b1b9822213edec9f05e43d7721e786baedff89120769157b39cf55d03a11dbda70739be75f85eff92d06b592f38b48ca54777ac91f97cfa7d4d64728afb40be1279d4fcdc09c27ef7122f9ecabd21e81e0fce8896fbc24303f7c2206a29972aa8b5fe89f610e9d5ab98ae15ce58a62801334191504a5e6d2309b4fc698993f9206fd787646fd30c8d35f139d99dc07c6eb2e92385a88eb59458b7eef124fc146511a90b6a66ca48f972cef2beb2e759b1a680b731068e89578852675cae77845f303f90b8069adb7430854a5f64174d6802d625ba5c33d7e3f34295f5e1be6a8a963bcbbadceb4b6d7e262fb075463762aab435015f34bd80befd158f0eeefebdc78fefe40a360ffadbf27fe51801d61cf22921f66651eca92ed5b31f745be0f4e6e89455690a7e82b46553268ea3e174066eae7a534ffa226561da1432c85cb03053ca6fa8a3c5284e4f35aed6baa5dbdb7008b2afdc5fd88bd25bdb05e0b5f0a5d506f35fd08f706196ae1130ee645f98e699d7856b06f492d9edd54baf25a34c61c122398443f310d2d9c8bdc5f21af0ea3180ec1a4b064682355115b0dc61d16e416f5d61d70bb1c6f1d9e1668262a2338b6069ca673a0f8c98de489a561cdaf4b0292ec35f4dad2d49893bedaa3c24116890daed676fb7864d0f260d83ce4bef673fb8f93ce285d0e0ed2ab638128106a1b103f1093e4395bfd55da4a3f6dcc687ee6b056bed5fa041451a47934d8012327199ce8d1e846ca547cd878d3beebb440d2ef8e400ded894550dd9fcaa03a20c9cabacb3c665e1237b0f6f4f978340433d88db8988bb53ac860d58a36678beee5fcfb3527443758663d3e64f931eb41b1cd781c22b8b28fb7f08b3d32c39b71a7d6d616e5345285c461299873405c4be55cb72f0da690a5655c687d4e0e86dfbd829edb98c6b3fa5a112ff9635ab983a0f5c74b917d6554afc5d11db591205a3c6b29e8d76edccba4ee42c7e3857838910733dbbdf67a904777e729b993e728adc17e274f6162b5ac3830ce3ca8f5355e09cca18b0be82969c3ddfe9039a1e249f6a0ca9de16a717b4284e28d2bdb039bd8d3f81dd0aea141c877c035f9e4ca96b17cbd6f8c81577d9c9a9386d3e775219d679ae5db98c8b734497a8941b59fe934259a9b9db5902a1c507e8b746f5c4f1ff16bb6b9081599d2a21ddf967980a93de72636f7ec89fa036b91fecfd4e8c6fdafd61d3ebd5c60f388858cf31599f29f385a2c47730980a2e01b9ea00b74ced68529a91b6af0bccb0a7cea35f2bf5da016c36be764297cacb94362a094804a8174ae964d00856a5bca2df3c0ce43c72a2c2e70132bccc7044be400cc3fc86a00238dd67ff4c2702e168fb40e9ffd9dc04b59506aa86082f1d98348d59c50385cbf18631ee2ca76d0ee48d4d1d70690d1d72cc9010c5959a71eaa350325362c70b20f53de850feb1062ace3fde598c1b5a9d8dd49555af76d551ea9d48d1e7f1e633b5f9028436a9506f4b09cc8265c3cb4a55881765f716b7082a9a148c2e6397e273a194fd0b9fbaa9f4e50902bb851399489fa55403b43d0c63385a926d090488befc940a3f753842609895c9aadb9bcfe932856cd52325c057c096bbfb96fddd17cbf893be95d8a671984a7b88761e2bb6d99842149f08d60b04ddac26f54959efcebefcad36e5ccc6abfc978525fcf64fdef26fe3bc1d09f16a9a96fe2e2d643c1360da0d0987105e0ac7f9986c62492135242599380568e83aa4ff5f0ac3392a2501c511d1bad823fbbc096e66f43caa035f1c82cf7d7d1049ba8c2a8746ef43f15adce8862450528e6d44c1c1234a92044d3963c6a21f4ef146743f9fb9d9c8a618d2debd390bd81938581cfa1db86fdacbf0a4f0accbb1afb4cf7ade9f8d1242db4494ff1211e1dd370e7ce31fe93717c286c28778d4df4a9a13b9808a694621463d4b2eab3d4660f8458699fb6c04bc45ba675f785e300ccefda7ca9f332ba42005d7190be3640ffb7b3771ec819122c779fc81156371dd013d7e1175fb5f05fa3332d9886df4f4df447a1e9270de62c0d5d2bc53cd5d498a847e6e45c8a74c636b661fa96cb6615481174e1ce18cf37ed4d4e81735f1354754ee4abf7c311f74d30e5c006bb361ccd4f81204141de16f60365d21a8f8ab41da55a5e9c57e86ab9b9670824f63f950fe79d2c2e530cf7d2cfbeb12fcedb634b21581373613cc01521a94ccb1ee115169082edfc56b68839addb708215e8deb082ad3959a874ff1db69dfb32bed111a43b298874d251147a7d2e0f2bb079a9be2fe6b49ea3e26985e3a8f98e64ff59717cc659772acf8f8d033c71c6b60e3f29c5d63b38e5033612b22a76e8a11a5163fa06f327ea4f8d1917acbf1b8f9da971af71b64073ebf9b12580e5a77d962663f1df9c1a35ec797b103c32e7c8bf483c038fd82f83ba9ba9ee4be888abd3fb5db334d1daa746dafd7a049ff3f8bd54dc687cc1ed85f2ad41189bc79ec8307f0ebea00110f797632896ce09e5a3c1f1db2e0e5125e6ea6a2bca1e2a383c6a52ccc37c5618d34b4e0559eea7d1e6f4a189e951d623c4396306eb86cbdebf9b19171bca4a55bc1daaf4bf6c89edabfb1d3e826279cbb496a1dc0e969a6bbbb7ea1256ffef4e3c19922fbd939b9d5822bbe0d83823fbaff3f8d5935698925f99310b1664df9be0c15324c9b358ffdaa3bc555a582d7413bf6c370e999f7ba3aa4f0e7aa055a1ebc47023b8006759d5890bc73ca6b88e37abb3289715fe810d83c499798be75b4b301636040353cd0413241f7093cbee891bf2a26456b0eb6ed777d5e99fe5b5bf5159a54cac78f80089e4f855795e258e7d244e71cf76041b3b66c46d069d211f37da39d93ff8335863b381d6cb2b5ac60efce685f270c4728c5b3f4bedb1adb2bd9938274f45f92dd06b7fe1f0354f79f64379983d6acb9983d1a468401900153b5f9330c3059d9d0f79a3cc95ba49972c795e41f3d7ec9a7200b6360365386f1487d7ac10ae8de589329fe655a1db237412d35001a0215ff6e8976d1ea01d853845a9000729dc4e6499f2c6ab73e847674a4557122e634ad7275606259747fa409f15f0f25778040ea39b2627d0fb1f8b1f8a299bc82cdad4befdec0750eb25895f84593818929479ed3f97e264a84ca9d629871cb0e8ad94186377ed29fddde5f680508b6277c23751ada240e089409c97f389ed3ddae0041e9c0ab9fb9c39ab54831f081e3d3659c9a3db12cfa51fdaa9059011006d41c2f2de33446bcc72b29f849a0caa2943e4120c735f30c7cd00cc32c35cfc97f6334c1775179ddc7a2705212eef047fb7b5fb9d73be76d31f285aa459fecd1eec4f5b6dd2b02921ec2a75790cb7d1a113a5549e7968162a3dfad079d83416372c7e63131664a24cdf6f664a72df6ca15b8891e0fb94c5af8ce635f9f5e97cdfb58dcab719252dd2cb1293cf386bc8cbda9d8840dd5c8e79fda3e357dd8d19c808a8fcbff9dca568ba47f5448e6801d4daa0c166ab60b1a94bdac83a0ac90cf2264f9e9020987eba5386b4067c2c0e29788460eb6da73516a19dce26fcf386a0dc9a8614f1c6cf771c087fe03b0f2c4da6846a50e4a92020324f2f579029e81bd76c83982aa6fea5d7e21c019bbc03159011d1b9792016eaf652e81a88f9258938c8e3e83c0511257e056374650fba90a1b6f4ecbaba32aa56b35fb4131c51dcdaaed18ba9a8ed8acf1de1226079033634d71814fb54acdb32f35ed11c7d4cbba4a9ced99c54c7c6ebed51cae69778defe8b0a8ede8fedb95c0362b27ae0e15fc1b43509ea4aadf1cbcb514760cd3afbb3cacf6933de808f81a46f06113cf58d2f63f34eb17e925cc595c3e14682dde344a29f01bd7319461d2c0a6a35f8b415a0266ee6e9864fc025d7024e0331e148d51fd723445d22d019ea54b3355ce1446e8458f806d00520f19be563e9ad2e829c02feca7bb31ced98a657a8a707d81e3e0fa104360b56bc7155c1662938cbbcc53a0248ae8f2edea02ad00f797a6b4dcac03e97180673ce254fbba55101fd5e301878212afd9f0f5aed286c68806fce82aceaf1c660ec460f0c915f6cf9b8388f50c8c39f03bd3a3a1797f8ccc667197abeea820ed76ebdab4d1c3f9ae70beea1e41eefe719f4fec6d582123a2fc5e0294a4fddcfd4fe8b961954bee489f0ee287d88db5db8c16140a2dc153b8a5775d62e29e5cc6336e5a2f68697150da68ab0baa7b675652cd0dea83ec2291ac030813c95d87dc373ec04b5b9ba6f5271e6377689f8021f30fb8e2facac888e617c2db4d81a6aee097064f4b202b4a6f81ceb65474324ea6aff6f64673cd297fb5208bf0760f394c3966b73b9476b43aa1427215ea9ad92b1f95422cd26b5283ccf6db24dfeadc286cc3cfa34e38614649cb665e1e33e1a37b03f3e4771047c2063dcbd52490079510bfd94ca68824a7cb2b34de025b1db3f5b6a85da6f08bc7e239302a7b8d738a85637e2203931fa779e3d1faddebb085135836234ba796d8ed29d4b287ba657e3f562ccce6b9701be21b36dc3fd0b9d964469d58e6d41d0d279fccaccfda138c314bc48419bf22950772c1a4937189ab936fd975d3c2acf63f785ae7fce78f4f5fb06432c35993d31921a544d89026a033ace21850b3426454aa6f8fa970040a7f3d1bdce7399dfdc4de990d26ee388a9acceeed452a3a5ba571f7a7253cae57a7a9402e2024afd975bac54bb3e57284b5d083bac2673057dff71e2ea4bc88526657e8dc544705976701499ac5f9f540f2b1261222d132ab54766353762a429e85cf9a6e185633dc8d5390b70d3cb7c208ca60b5493302af6885fd0b539e435c15aa15b747820cea0d113858e0e16ae3bbabbb2ceb8d3cca68c949d63b7000de3d2dda5e61f89101bb39b727c69bacc14e7687a343ef5d5e4d56d2b653586f391b50406764345f16bbd832d6133ece0c0fcb8aff17465985402bda7dcd31796c6c927a8c495f587c9340ddf2653266506a1ebe8a13943287a00dcecc666841a13596a67b90e0ca52eafd3dad6f4cb7ef8cec946a19192e6d3923d5f37d1f9fb56fb9fe0d9bebd5a679ce45ecc0e469debf72e2ff6fbb80f01f0abd15e05c2c88ead124","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
