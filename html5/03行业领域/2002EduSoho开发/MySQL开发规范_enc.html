<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fc696f9d3a5dee74d5b7044f13d554301dee4b87289e0b4c2470e25ed0bb334b5467725213feccfd007dd070170349fb02af300f7b720096a25bf60109b243659854b5ba0ce193cea11763a5c3406e7e09cf7a37f02b4bb4531745dd84083cb49fcbc022d5e2f281112658bad9a19b346ad0123bcd10e7e59c8248979858d2bc2ee068d03d8bb9855df5fe0a50196c44d8c49d5cbd4a0e146abe073e6a7baeacab89259ea23d4091a3c21542f916542600875d5a61789c11ec71478d83b5ddc29e2442dea87111f7ac57373974d741a80824907bfc317b699faec3709bc1edaf9fce56b9cd934c78e05250801bfb929498e3fa0599249f084b57a4a740b36769763bb979a75124637b70f24af4f2609cfff5263a50eb7874ddc240c9e9fced89b7045d16c6f692d11cc45739b55607f4a423bc22eaaf1a55e9c3fddcfce15b8564cc7302eae1ecf7b85d8654121b814e6fb96215891893c36e2b9e5dc52c39e5a807e9110d096b914d2574afe402434917924fc32d71cb9fcfeba21bdafbe8bf99c2fbd6ce71768273b8e5f250007bff081995cf913c97ce8c89057365b24f5eb163764ecc3bc994cf648e4cf31c2616b85cf0f32c7271f819e446bfdf0ee02d4da03e24c69c0ecf500f45c9ac88efec8e42423496e279ed1bdf145dfb2e2899429a2585828fc1a94b9eed4ee952b98de494876a897d761c90c340e20d9b827c5ce2134f6eb54e0d7075165b838bf21d1c197b164100d2bf431be28f3bee7b82709e9050d40e5d719c629fc640dcfb125d707df70e65efa2d591bf66938e9c8273e7de2498b1c4d20955cfa22a86f2ef0c2fa90b8ca737f5a6176090a266b9ecd47387034a2431cdf15bb14d8c1eea9a14f6fe2ee6bfae4ac999995da25f7039379128290b58372b8f5667e27a68a137ed69da5b8421b903fb472b880f163e05c5d239c8ca9cead3052284b6ea8dd04acaa4328659722a87321a97cdeac692595b421c3802f80db160584ba46909fe70f284e47152172e133f67f9658d6333c614c40ba34720079aabf75d90050d96bea46114b8c512786c1b0576df3beb865ce4418aeb98a1349aa3a8f94f913c282ff888ee1c53f11260200bd31941321f7567bc79a66cd98184948808cb9665c606b7e56db8b316ced91bed7089553ce46767db25526c334963d78f4caf987133204a0b2783a0eca3aff3f439f992c87eb2eb97a6f02a228de2d59aa428046abe9e9bdf269c92e76e8f29d1e0d595e61e8f73050e5892c79c97234f789853755e44e4e001eeb1c67d32b3700c5dab0167f53fcf6ee55c6de3b6e1188038a4971f7a6920b54db4056ee6d9c7fc87207b66996cad7257b2645fb2a869a677303a2d9e78aa32a67831d01b9a07b38162ef4400b49666ed63a7e9446ed356afc17927dc0ba6eba79ee2530625569e08a33cd140fdddce99309d87a079732d3810fb323acb3d132612c554c80dcf6718f48aeddaa21fb25a541f107f4b66a73f7e79dfa6fa9112f70a8f06b98d67031e75278218f89be837adb8689aa219ffa6650ec3a80b9a8add2c0617ca656f677cdb987786412792ae3aa8744fa2dc8d821b9dee6f611921fcb597ce1b048b8107930bfebab6e2877847625498f71fa37556c047e08cf6ccf97d3028ff06c6bb929d50fe37470d68635e1f839fe3e336c8ffabcce2ef8445cf5a35f6f9afc7fbdd4d2d80c430a2f02535b5d6c7f6aae4a64fca63e588c8944e27e8ed175142142ac9ffb528855272d16984397e576aa74117615e3d85982b39f994ddcd874afa6c3fa0d7bc76593df2ccfd0bd60b86c5d5e5b9f8fc12ae3e559ea244c410241de7d6022efbfd3dd60effafae02c51301c269be5e052500faaec7e125efc08d6980e2e5b88224ae3c3543184ad84debd818ecf1ca8a4d418c1372f88267d084268fd30ba0221818aa52347bc0a541d8297ce046ab48ddb902391d06771e34674a419329ecabee07772bb19689db57b29349b21f13c48bba2c5aabca499e31de41650ba0be4296cb4593cd94a480bd49b7a7d84b1be05f95a43e4598425b19351ddef193e25e70502e0b61004af2fe6fb101cd093fc1dc13bc129ba8802f8fd7257dc352563881243e1f8bc80cdfe1fde5ebb642ce5aece643567794c600bf634b7589323cb4292a10d4a55f49598ac0a9c480a1124ced235fa3f1452225a9ef92bf7dbf470bcc1cf5bc96d3a7e85c9e6e92903fb0b31dc178de7f46b5583006ba8338a5f474c8124afac9f52943acc40e17b02c55665fa99bb8c9cf1606d9515e4645cd6d0fb8b10c130bd8d8df14b41604bc6cc80eac7c2c30b7b8bbc632a347b5ce93d97d88df3a50e98e516fb5bde627578d8d33c0182b232cfd921196aea194cf41cb097d67c162bf0f8c5e56ffa80d25098757b69878c3ac4abfd3dd9a491839077a327c25cb982720afc2eea6ad9ee0d91f6bb5c677b25d3f67c842bcaa09a0942b866e13d3c7e01cd98191ff570a6c6da5864c89fca414a25f9f3e453936c12363b7513f8eda0b7220b02e4f9f91171c316d9d7b1dabb42a935f092c5c0e0773c1f57a277bc1449e48eb9ccafca994e48195e88ab97b0d3417bfd99b111e6c647777132006efc5f82ea1f719be4cb5b76b02353467a5f72f106ceee0ea69839ff2a1086858d5085d464f7671c7fe88bd8a4217f8161cc4630ac5716ecd6080717c71008a581e700bccf00df7021ac46006aa6a6f4c4b5e4305eed895b513f7ce25998910edca887a0225c69c28bf44ad7bdb32b24c897d731f1873a409dd4352e7a032f9b43839758911866b3ee0f7c5ae8e73f78cb2b51d95e0b37dbeb28c6cbef76b05557d65a097fd304242d92c5337e5a47fd57000beb6f2377125a0e264a51d33b452296becc8a909fc46efaebcb6ec6adc134e144d88d5cbcfb27d8defc18dacb140df69be168e8fe8d5edd19dea61802da003acae8a0f9a2ce07801253420f2667bee6f101859a76b24928e374a054f2eb7bd81e4767d95c7229f59222f9313013d663a488a8d5130061f9993615dea2de7f823c7417ac215a241b79ad691df3f3538e2e2e963c7d92f8a91ae349dbd11bffb414c81c00cac6af36fb6009f5866219f0fe0254eadd9b1d6ebb30b931ed2246a8c681cf1dfc44a4b86cec6e9bd33ae28d1cbe7a72e310a697bbc9942c2d80c36a9c54066f8a7ae8e993d72f76becaa96aae8a35dc08cbe0812e574d1fdfa23693a9202f5bbdbfdb9257710e1b20dbfd93658e46659982eb7e533d8c4708c09a0dfdc67edca4e865a78aae95abc5ceb474588f9c5886d4be451c6273b9abb58a155c5c6783247d2f12e09a0db5e6e67361130ea2b4d264c246bb1ea0c35c7afc2136e43c20f52f35dbf791cf7a5ddd10e66f9760e9619c15050e1ebae2b04a037434d76af7cb1abf33cb15ae737745cc176a649b5b90c5f87994443e504e6adb9496093a0c9488bb8bc6e27993fdb28dd6ebea60360f2b6432bede2916a8b483d84774876da5c3f04d5f0ed0924c19e1204f8a6b80bc1dee73d7aa0556a03e5c0150495ebf67979972f8a5c2a11dd591c7f1750ed4c154b94e70880070a528aa922a6143e40476ff345e0e04572bf49e30a7a8a0f048e40687dd035126434323bc701543f3d0e442cad8d4c64e9711d34f666fecc08f6240fc0dbc91609ef3b5ef5a516c70e5d3f0a83fe4ba127f32dca1a418d8870038cec2cfb8a79b3791dd9db4cd79efe7530542759dc95cdb65e28d0f89ee226f7bd9bf124ad9e9cdec45760f787adb4aa26885d4d1ba82d8d211147737472e96fe8e8a084339e9232b8c4af8c7d1286d735255592aa15ee332610644f8b8b02e9ce92de4fd728fa4aad01f390e6b89615f1f0de7206303fca525fcdbd94ede498ad695d9c3bf5f1a810f718f2ac46c45b3396dd4f9f2aa04f686b010af5abf8f368b9450467271b535484c66226d84b94a948391e3cd57c06344bae747f677d98683478949c5ec4efee0db456645a4044948a6cd89192b993b82fa20f917073fe0e401ddd40df7d8fbf1a8cc27873c3284d0a00d06c7451a544658c7f3c5802479c300ef47d735a48824669199df663ccb2e8b176a8892f4812fff3026f5e67462a415a8853d18d896799531a323f4a2ea7fa26ea824a7dd5d78b3191c4bcdcad4e7eff6157f7a62cab7d0ced0226b3f3c8d4330429dc79a482c34660e734b1fff46c9fd25f96f470153649dbdda789caa2be7b2b97d91851c47745619ad31b57145a802e28508a2b426d6018ccde57535020ff092977152c38748e29740453a0b75fa3da76b54be2da8ec2950b5d40a09bbd11140300efcf83d2f6404e53201a4983df1a9b4c99533ebca1ceb59633b0997d88629c6d036f5317cf8112ce5b9fb33ed49ac07d9e8805f04245e331d4637592e5fa64055af1ad981a6c2def73e83adeb0f04fe38cfd1932c09e96161a27a83884b744d5ed32419a2943d234679fc995973790123f17d794a10c13944a9f0a24c2595efb3b34fb2c583332ce6ef0b1d58d944bb045bd267b573e48739e6231460be07634da22aaefbe5fc2b39c411e36fee40b7a8017cddb3f88e7699a3b484ed6346fa6cc7ad181272dc75ebe8c4447d26ffe6d5d97fcde7e80ee882070c595a0b1103a972cc826fb67ac55dcecdff83e11d7550c58b511aac82b473fd6e9c159d12b3bbe38bd13f1e71f6aea40224347648dd7f4f78f5f9968f2fbe1d26bc5c2aec8738189133b2ec5f461ca28db6bdcfd4998204a2cc171132a39ca37ddedbb9fb4d8f9a603c985ef0f3b511eaf0e0d542f81332f5f0880b9c92966ab4a6de83115e422069f5cb2a3c651e85c3754a60768c7e227fe8ca4519b97245a0888ae54e379cb12f34db38c1d3a646eb374918b7358d461851d99cd06bbb60da45941b3ffe782025fbb7f34291aa89e460ff5577fb20954abd181f389c1aee59916aefa3ed97c801a14ad79fc2ee0706345c185d0d60091b9ebb051b90481a0bd777a61cc46c2165e0e00ff54010270b5da6b1bcae6ee109212bbfc3f8c7a08ad493d14d8fe9d5d367b9416df6a8ba12adc66b03d3ea3c9d986377d6fc928f6b2d54ac9ad6ec484d1f0617c77b733994f55b8117c75c784450dd71f919abaf2836f3393ccafae7f01551683982d573e30e6b8c37a0a4609ceac0ae10c68786efeaa9a6e75d9d6e691f4bf55f61034e6918b5770aa90242ff82f8d5dee383fbc0dd16a7685fbc1dbc1c055dfc2bb0f6aaad5ed6ca8fa582f57ce1f82fd5f01fc8d7e161f09c7ac0496213f1d34d4497595052e001b5223b80ce9eef4bcdb2e3f2d72e7f4f2f3ddf5d9c6df05e8bcefe744f0a886c64ae2ba5d3dc689d601d45667a20fc5be085a903b05275e1465c06bdca3ee0711cd596c88f0209f7da0267e20df6f99b286f8fff348e362332ce36b71ea72ff82be97f59c9280a05535bc9193c40158c42b0ff340e16cf2a03356a58312d5dd3a1f0bdbe2198ab3a2a63d534a15a6c468d403ba18136ebb2c6fe4e5c8b4a36c3d6ff31f29bc482a64468036ca9c3fce81f1bd12bf34a33430424d1a512ac94e247c3a2a12da5182dcf4f8e770774e8d8e810397f9b43156016a96f7e80cbbf1ffd25cb44900c77ddb1499e6bebcd93cf0b8aa75b4a8b9b50169fd0e23d2465c53be56db4788b38c307c3c30dab589912925d1d2c9eb3a4f62ee70c9a45be3b94b0eacaeda4a8aea975a90033a4aac8d6f8669de9549b31618de4416f69a0f83421e01455564c5c9f396cc89035d6130b4838fe6cf24b338dade662db65c62fbcc2d4934cf071198d876dd88ee77db903af2a1fcc2c1e57745d2f144a55197d075b547aafad02edf84fd864ae291fa6faf3aab97875531f43b99b94421d7d84d6f424f0fe1b5dc123546626c40df0fc3856b768222b2eef8e7036ee6e4638d08355e4929e0d4340bda3068c143ab6d66a381220f947713c25b4e09c8b67f5b31d08eac312b7dd40fc369ab244a7494a11b1b9dd1b2ab6d8f1d7623b2a5bfeb3e16ce13d40a8ef3e01fc87d763574dd55e949e4d85d0fb05e718c9762603934b4c655c48a2cfe9716b81e99d045b398bd912da6df394f2b6187dbbcd3c30449f6d43890e5a313dccd0406a094c462f0bfb48a610d908886b0d1f9d7d4dec3a3d09e653e22056f78142445aebf00e16107a56155ab5f798aeb0f5a873b33be58b30123d3052a4a60b6ce5cb2edf8536eee97814e73f8018b46007fabc6005fc043ff11ea375896f06d4e2a0270aecfdaf44f5cba8ec4f07cc95a7e65a2267139f0ef2ab278f2ac9e399f026f4c703530e2b1e5b224e09872f45a0732cc2bed43f634dc4d57af328cb5b016e06f2f120795b992209fcffc3a0e4e978b02f62c2fe95ff85a8e28022e28bc56b622745da5cbd204cf427c36306794978c1c093843c7bee59eb537f10c9bda4e994224139c99142c1c985bff497cbc0c34a28da20e35ff8e731e9f57cd5180524379e49cb29a508231fdcb5d439a8df221ba77ec0d2b8705b19d7ad0d0d80865f14c91a340f6e2a967ab860b88af9c12d0a88a2e97d501de3ec3f7afa5a47b6ad75a466fe109dbf3c71e442d9cad60ef8d8a32d545dc60ed4eded97ea7506d8f49ed5ae9a72b3eb72dd0c307dc64c17144df9daea49e4f387b25318dd555cc75b42dba3cf52ea87d4d0e3fb34360189cfb59f987ea1f809c9bba6f10e523d7aa2843c201a845ba12da3bd204c3bd0d278cf2748df67d9ea18de2da11a1060e2a845a4f86e06e362521ba503d7f98e4df2c0fb2d3417e8551600eebfa2c1a57d705e7a5f73572baf39760eea2da38a3c88a4a99562581a18a900f14b165dd278f9eee20fc65a9853827800cb841b8e34bf0d2f6a73e72830778497f05c3937db16660da4d507f624437132bed316fc35d97830bb6db226d3db4e8cd3bb072ddddb25bc5dd5fbfdc24e5a6ffc495c82063d4c043c89ce6cdb340dda5a08ebd6254c8cefbd1ccb0736762cc918b4dc4642358c0eefd3a7e0d4aad831d78aa73ab2766da38d42795bd074b8a432e1f54962e19a876b1d8dbdedf70e1a125e098572ee619ff1ff6f2cbd711b7605bf13bfdedfedbbe90778d7fce89e5e50f9776b2c9f53388618792ed7255e303ac84db8f8561aef41138f80e3e8e9e2e7eccd9fc6ff68e8ad141bc813f2a513ee5546ddce951af66a06a6b58268a36e9c0c9788d1aa6917fb66dc2a47fcad9ce961cba18f510690414bcddbbf62236e36e3ff93938c7427d1f9ad4c4dd8ef3a512232c07affb9d7f1dde111ef76457ee8fa1027897f46ed4e7ecf73c79c95712fa599aba033ddfa3a276800820319f260866306e7094a296f56bb0167b1018244dfd1c5040c0e4cabe4b6c672f284e9681358b119b832fb1936498581147f9e48d1de9d82e7623e146b9d0ee815e9402e377fbb591c2fa1c5e2e0f448447efc6900d83d3a2fc9aa397c0437b1c8539037d47ab2c87d70e7a569b22331996fd06dabec23444266dbbedf0d56d8113f5c0b99e26ed712a9b585a7f8717c3b1bd0b09fd5ed3c75556a36c9bed0a2772c203e3b8eaa3827e80e949a37dfcde31eba871f823d9765c9ee17d3ec86468c3bc9babde4e38c9596627510e88173601f9e6b265a967f05e35156768c3f025b2eff8309ea19670709239350cb24f14e964b11fa5817c0028c7d477d63cb4d40f2ddfde05e20b90cbdafe7b02dcabf0f213c581acc94afa546a26bfe5a44a8ee7ef9a41aaf0c3fc18829b0a9f8d936415168f57e7e944d86160390e18975eabbda64a6340e32f152792d91ac826f243d8d76b514dc8ff26734ab8819998a129707f81780b6f95b6644254c2f0c1d196e24014ce30ceff46a6286ddf22253eaef73677638b15c6f81e60f7cc74c30377052528e822e14a6f7ac9031712318fc085bd3511693f812ac0c00f45d8ead9de84e71b6c27a6445ce7b9a71a0f6be40e0d8d68d6cf367ba6b4241659e9aa53cacf41d11e0dc61fe79991d75cdd244b2159ae31801a2a3e0b0b0f30a3fe4e6b77b73e00fde1ab3153772c19f47383a1631d6c4cc07854089579f9280d1b03294a1893beb4ad1bc02b5fe3866a8e41098717a860cb95df98da690db92bd378c438e5932b71e1013e8ea409a5ab79043b712f0b9a072e3c6b7bc960e6fb92e23adf8598abd87980014bcfb8b68d30aa512721ca8112a9166ead256b8c557110ba9574212cf8c4d1b88b8190c9875fa99049fdfcda1b747e0ece3c9c458bae55c8d155758442d85cf43be1ec90fb68a9b1484b9f76ef553c93e6261a56a59899b01c3ccad80f485610d6e6ba48de51fd5e6a941b7a69ef2f4d1875caa3d6125aef702601b7e900927331ad7d2aba52faa287d7e808191126d10bc7d9e65e47af317188a70c20db9ad24b02bdcd12cdbd07ba96310892f2a74640d6278339f93c8a8b9487713cbd0e645faaf3f9c71fafcdfa27047fd00dc23354d7c50872fb549db17372d6543eda5208e9e6cb8d4c7437138a6d6af3b14cb6df204c005becf70cf766708fce9d413cdfadd4a5de97963b3b7c21e06f89ca4c26b7f122b0d79ebbd4cff3d7f64c28bc467aef977b3fb8c0a66b8db175b85c41f1c4637f2a15972eacd702cd44e5446000f73a6931bdd3b30bbf7780943d645a3601be7e6ae6aae9a4938607f7396aa89e7c51ce3f66825a6d9c62cfcb2869c0933612ce4f07d1146dcbd5a8acb4fc0938eb76f3be5b24b4b739c083ea3f8f25b444495d7de8991209350b0b1d6ccd05304dce21a203e9d5902287f93f5ca066681ff393658e09c4b9e756ea237f7e34ad836379ff92d4b2e9cbf0abf3fdb9ae63a260ca23d42f0192b0a841e423e932a2e3de164d7f44a48e64d5714f6471432845754553089bc909e75ea0341196ff7087725e1ef7a5abda87230049f0c191071348540504db8ca4f930e46311c580d506dec1787d7b6c5ba4d58888e12e055ba0e3ddf49c3ea647b7a7bcc8050e58e82f6e4392261a5d542759a0b5cdf4ece72b3b4076049b6b5d06d95c7831494f1e7c5d123e0d53ab2c0af5832b379c6ce57d0546c0805f6182798b9d6b2837a3b6ad089e67404113bc24a9289be0a500aec4ad94ed4af1fd7800c7204232260663db2b2f0dc754f483d0e18508090af2055cd76e23d65393f2018c462e9cff08a99742f0f63ce39efd9b9723ef17bef6dce5da990d142d6e534bdb027c60e3c43f0c742c1145c6bff7289cd88d2cab1a56ec13aef7b3b36f8fa94aaf5042ce7d1551c625f7398e9a8dac604859d259f01b9d9fe4f386018dd657ded86f30cd2be970b301f1ad8955194d6e7950594724de7bb707db60d9016a18ac7fe657f6fc9abfce36363d9aa849","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
