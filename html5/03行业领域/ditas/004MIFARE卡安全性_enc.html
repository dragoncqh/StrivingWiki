<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"661db27743341416da8b69d0cd3a4e3920726cfa93485ccd29873717248638421cc098f331d4e5a83fcef4a31f58a794b04e8860850d523a829c67e06a55b89951c5dbc1c52815a19d4311d4c4b755410da87be33fb11db4996d27104e9af011131d970ca5f8adb39f0c87b60cd01cee83e5557aa4b06179b827d61259df937c4049725287bd53742b6c41564f63353e6cf6964f27a464cbfcaffba1f06b86a0224fc0dfb1ed82f96645b52453c1be02cbf107f6221372bcd6f00b76534b1311c547d30255d9481c250d8b473707437664068030d3a8fbab875fe85a52ee2944fd19260630c983fc30650b2cc45cf17f63b51c1b7d6770ce38482a65db155ef1430a823c1a75c5b41f66e233336560e5997727fd3b6a48c676a2e94ff6efc3d20750ed6fbb78e9d9f330c1448f15d56fbd626deee090ad9fd4c909e79c9dffe7fc2590080ab28be0f9880b7478a36aa8aec1eff2fa43b1e72bffdbf0e1b02a82c266c0a246d838e427e864da1f789eafd56b48c0274fda76883a014ed97c33020eb7d8cbabc8aeba4f8792b4e464cfa8f32e73aebaa306623022d9cfb9c796e3c4ba0721c2eb33daa27cb781259bc7d7e1fa4cc6a54768784c45af1121aee40fb346072d8060e81cd4597697b5210b0e816ada9b598d33aad4dacae1404f6b4263f60d2dae84cb9d82023b3a1a2388c62200507265cd1d9f3a15f5ae8394d8d29fd0444c2d2f96f42f419bec58b3f2354cccfafd500a679ac830bff5541171e19ba04690e702b53564e82cbcd507e2d12ef6cc333dba9c66fab907671a04e91c0bd6906963a160fdfa8031d37bf73cd25298421796eb724c959e3948a9f48b2c5fb42bba2a56a23efa9792b3cf4dfa63c024329d3f2ac554df6f75546e102cb75a554240e4203e5de27ea89dfa2691b1c5a71adad1c96a1650876a0d72339e300a13caf496f2ed68a10d6994a73d87a28bb3828ad58084842e683123b082f9da80c9ad2513ad77894d28d51965f0adf43f7a2af49252c30033ce59b9c211dbc413ada35c2f5bf6677d1b16f791ff2abc7cd02b79d0df60f84004a258507fa760da54630f7bbc709c778b9607ff35e8416f250c785e6828c1fb7a45e56eaf40654156faf7e1ee901bfd8d2e939c5b24cfecf71874b11705515d219b2d4e4d9750dd9fa9c9fac573c01472ec9321bde7ffd471833bf60b1fd5bbd3e91b0789af63bc6b62876d8c1adfcdd1a45c307fb416af15915bab3c1aa530826719589c3a250f087b8eb535637960b9d240ae58747e068b51cdcc250ce9737d85749ad6ee112f3939812d635c1dfa2fb07865e976906c2119d8372b053097b8bcf0cb248f97e37ab291f9006eb0945f4ccd07f943c755a498d1e16201d27661c5f353ee233c153e7a64f439fe09acd0d79b1b1fbf893aa3e97f9b81915848887af8216c9ff8a4082fb8f525b11d3225671775d41e9c7d37dff553e0f02c0ba62f93d66117aed0ac33af13a291f9b54de7b0b6601ce5dfa04149bcdeeef1c416ae29ae582b5364d82ee67321b22a653694f4d8881a7fabbb4302e0dfeaf6a5307b5f05abf5f92139d07c976f5fdf441e3bd624e2a94dd65625f1a8f1fd96ade5b25c25bc3b78468c88d1b614b2cec8fc12822b55458f4ac6354965078d17439527017302ed6a2a870ee3e34032d484491e8f61f7ead22ba769f94ec5803aa2e8268d42d7077c03b88e46ec3a9f7fd536e1628370ece1ff56bc902a5004f57b3ecffd1b955c4cfc102508d2adfcb623eb7e08acc96be1bfde0793b9e248307026ef1f51432faa43c455cf63793a8dba26e052a94d103c0f047cc75cfc8fb0b54da95f2947681867cf558a25f267e2a57a2ea674508f9805191404ae05d349e50d6425f793ea23dc724ff2228211fb0f248aa0c397168d496f9f75530d3bcc79f781155d94f120720fdd383a241c9bd37f4a65fa3ae9e1db3a3432d1932785a8bdf4148d87213531242a9b5aa3b839114e46cdc014b906b3b0e75c6689a087987c6d931ca9cc227ea952dc627d451c22a5cc8f60265ffc889619b187b6a6f8b855effd1074241d1f66bb48ac88beabf754ca4a9665b977ffe97098ef5ec0c33af7f6e5cccbdfabbfe33ba5cbd8b2bcbb72769dd44e8e953679468b6b71bd0c9ef11510a4d5ee934b2effb2cfb2978b8e4a597f88a2862926d128c932346e32a0580ce3926ea5ed62f4a93ae2480ca4b0fcb28e2173f34935d1b0a71cce1b27ed3d093fc86e1488d47450223fbb322f669e1c9f5bfb8934bb5e6373ca1f79345360353cc39b426a6025def72171f1ceb9518ca45eb4a6ada1af4a4bf2e2f979eb1fded781e7bdde94d9a05e35635e5479978e279576deb8e33cf5cbf3ef875c22ae543389f9f707de6606360da619f67c08b6672e7b9b6fa50c01297d99fd3aa991a1b11d91ffd38d5cda977280edb52ff984a1007f687fcc0ab7fe3e5dff383959cab9eda76f4fb1af70f07dc6ec414b91e5a3a6e010c7624c2c38303c09f19919fc1c7e72e7665c45a72ab76d958f60505632e30490ffd7ff5a5531bf5c07c5d0a07d2ea8305016f7e699d7e9c7982dc9978eaf0b3df07c4a4cc8506de3c4e2a92bd2aef4b6d611db04018eaea0eb3e5e2327003ca90eb72d42b96283b344b7597c490507f4fa1ea7b0a85a0cbad5abe552f6e6a7aaf636ca6d0d058ec990c1de631dd0ba9c877e2ba6a53fb674121c9b6f6cdaaa68f1e3bc2c27e2f88b5cc2c6708772a05c2e0f0fa7aa0348378543bbf24a246e25ce240ff8700c07b5093bb50496d0c1e4df1f14a3416ca697f769254d0638c8f68f5e6d29ee5c3a40c5749ea4a21cd8525950e7d26847bf9080a51f9f50866cb916205254430dd2402c0213be1369d645630fc4b539d626256a90b1e087030289629aed2b550d952611a8efbf40e21895d0ad8968f88c1c4b369c1a6430c91050ad5a515546544f435feb15ce25f2d05da96deb4aa6b0cd050b957590059f8e7f973f4083016f6788ccf8d93b28716e85f68102b8e2baa91f0073470b3d7ef814b7ad4a3dd506b9a7926ee06f69d53ba4283f1c21d51c38b427354da1ad4fabe3d9ed8219a68f237b42e846fb0efb9c8ce055aa84b5ff929e421ee92bb55d4b9ae026d0dcaef863f16b2652dd7330d18ac17f59aae4daac4a7a5c992271503f2a929bb6178b05d83468ff80b4150b901bf56acdabb0955a10f3a55f0a644aad03f6319501680a1c30b9482199a3ea04131c10a9951a63b557c38a272f7616eefad4924d9d17625941764cd4a3b130df8699ac1707a6dbad37f2b1bff9e3149825cb28bd680905b4f7fbccbb7a2d76ef2cb5f89842ac32436e636c34277588abcf376de35c8be8bb524767ed92f34a14e0c294bd2a9cabaa0f931a45f81717f5c8657319207c7ef641016f759826a4401453d645a94e5d86dc6bf94debd427741b3ca532d5a63c04fc0f25c760172eddcac7ee5e1aeafea77afd299af36f5181ff532fdb1990554b1886a6c3e007c7cb8607d61ccd7b8615b7f483718e6401aa0a2dec06d964ed2f064fb9ff844a25cd8f9041cb0e9037488f9034b1b99e8ed1e2dcaffaab05cd90ff27a04fc5d8ee361333f837e0af8de8e391602cd69a225d7d63d768f4a0a53c874182ec9b819609c473a0a1250a71eb8f55f34dd6378fb4a313694abd7e397aa187a4dda6a39cff586242e7a2af76fa42a9db049f25467b046511cb0be4823dd24c90c637c0bca916e5cbc269bc8bc0541916762c42c885fdefb1f8c877f426de1cda4d49d839fc6201c97a98813fad33d395c5453f01563025921655aca73c63fcd16425213e8f1deac0cfd92e36268a8f2f893fd9b624d71a29d3ffd381cc83d9a75e0c510492013eb30e65e01dc565a30c48d71eb28f33814b41429eb2191f5331cb7a1d5c0afa2ea309340d3e27d828d5c2323dd1d934968def4c98b94fa14b1cf1c8a98b7ef88ad78d7f423fac8f05892f12849cea8cda3c6c077b2b5a95be24d464f0a021a59b041eddff7d82a159f42dfe2bc4085c8bd64609d67171ac1dac021a39d893ca1481d087ae9f78c3b1a5141220f8c61775066a2d700cb3b83e442a07441b526c4dd1ab41cb6e0723cbacef71fcd939e3b5d65932c86c37f4be179fedfc0f26d8159e2c8127ab6cd336b40f11e62c19d91a199e82df982ba54bc544e904bc3091b18617498dc14ec4757bc0d9383a94cca49c183c3a8cd2ff8fdcf592cc1ec9b6a81030a4f95476a36465c47d03e2b2bd9b61dd99cef6e224c80d6b14b3ea21f1333e4c5cb33285cfab0255b60b1de8013d4bdfd7c9c3a02df58041f93f5b5090c1662e76fb68588361044b515f6ed5b6b141d2b77d246b98fa4586fc8e7c99bd04d1ad39fb89c80fc2945715c3cead02a96798491ba6607cc3c61cd0dcf68256819e9143fa8ae914d6867cbaea31674bc4030eab6934b4b3b0366d3030b0e646fb4edff70e662e6fc459d1b198a2143141ea8f99b7acceb9e97658c14acb3818d5d93572c92c5a10b21d9357156a12987432594b173ee9174fd0262b3dd8af2e91a5d3386e3a240a565f745f743ca82f573a2ea3c7fd5e801eb45da7d1647cef29f165ca1495bd54aa21dff6f3552fead3a3ba300ad24349f069bc87c4d0fe6ae2a9ab9fc3cabfe92e74a6793b16009be71ca9c836d8ea8bba616fb3ec0100c217fccbefe5cddfb848a1b1140f8bd2086ad00dd03163ecd8978f6f259bccca3f40f66bd0b1699b4134228f0e30ac31076eef87656d15fe2ee74af26d9b029db8aa1321eb5590cd68cbd23144831988c9e3c9a2291294b6a077be89a0d29d88a05a1e8f287acee446a92b816090b1fbee59f9db099102e023ccff96d54343fa4dc49932daae4847484acc51daf60af601bd20e20f2ad31132240d714f326bf57a9e305fad3288b77dca71fe2570d02d1261b615150789df4cca7d55f5bacf4c9ee0dea26dccfd034634b0c1fcd6ef3b1e9fa30b135f5c3e3ce1ad4f5a514854952fe125fcafbeafb10060a5c7b4c1d6e9da607f26417c634b33dc395700e526595399c6c06e7796441312d92276954bb4d93c7109f8baf053856cad97fe8cdd73800041ce314ac8d1bd1f3bd0588889012dc2c987c25b319b79fdc6d1cf4bd9344bb212dfebc482320c9c2d220c2c5433d61b43bdc76245d08672fdd46a2b7972973e4c59d6f1592c2bb4749e2114356596520330a0defcd25248e046891493c96cdd115f87dec03b1ea54913614b6ac2d332dcc7a89ca7002a037577dce2a5856e167662e57691938b477f8d471927a9530e3e681b2122a4cac875061a53e03efd75c8322b9fbe76e286eb87fe7239f8359cea1b1742d0214eda74426a61dfdf27945487519ca7dab0c9ee10553e25805d9e75423222371a9d8c354e8f4d177330c05f148f007f0fbfaf9d7ba43aba9620fb562c19144f0ba77635e964a1b5d9bea048daaffbbac89c9aca74f56a9f6c671e257cfe66142b55fcdb529cb368b59ca49c0aaf9720e8641fc3a0ad55b10699dc4bb3b56f9007050ee57cc2287fd9bd4ca0eaa28deb58f4195aaa3b6b2797d80f9fc9641e67e3cbaf42bbb65fc1624ae9072441612505bcd5d79bfc4e2d1bf29e5e700e876e71ba80c589c18848cb61eb604b3472aa031df8bdb875972c3f6d38607fdd4e909ada101a63b170559eeca99e60b594ef76f3f2be024c673c397d6b29a2ff8a80ad9b786adf27b1d24de77853673adb024049073ccc034d0b6b7c91089d16a7bb673db74e97a971878d8d43f932ced16f2e7c75fb152ac1b9563f1af3bc78cf1bd478c9ebdcf2ec9a73d5bf9cc1e19115ae6fe9a7436fb747ab7865a6d9c9d20341c763209f33529ee3801655361b467ce1155ea5d8ce33350a3b7f59b0209d709fa07028a878d1f4957bef1f830ae6285d9cf6a88811d3b4a56bc991bf1dc0aa8dcc66d56e813caa1e36b4121c1667fa597e984d270486f76ae7bf06730cc6ebdc13984925657c4ef8bbf389c93dc5a9707621283db578ad40943e1af16e76be07f2b20fa5f6858eaf22f4625b2bc39715dc42b6973eca543549ebfb3721ef81cc0fb863d82c781e27d0fc59e8b32deb36aa5b63982a357c5ca21c940711105afe9d9c91c4db179caa0a94d021e780cf28101f60b922042d21b876d177d0715921de7599a11d35ccb7243d2854151daded54d4cbe96aa581a17e1d47495bb0881c307b26fc98e45d3eb2ea7c8b2c2e5e70be83cdb79d929d166b7ec2fe3fcbb3827f3db1f3e6674a293128c38d9f66fb783f2de861a47ea0da0d0b97ce8b8255497ffd5819484e217146e3ca390a441ef91c8abda95aa8ee9ccb904d3dd9fa8615ab2129041620d7d4329ebe47946f447ae048bccb48fd054a2ff7dcbd15fb9382fec7a5a9c1cc3b3e37c673d51382056523d576b5bcbc1cd1b52e4158e109be0f734e2778a769c802cb36e7756d9fe16d38e4de6d74c3467937831517d660adba4e97d85119564a17b5e3fa50ec45cd1cf2207682a46f67d74af384f113744db3c2def6d6de821ec616e588f2726cbcfcfea5d62465985070054045335a4d740e2618a8b5e9d9c22501b87a1a79fbb0252832aeea46ebf047e579d5e315fe54733aeaa77b199cd52b5d9c1d8b212f7a911e6d025858ca6e34fd08d36ec803bd07ee4cc88beff5642f1a91d7d6bc878a06452d4ad17077bcd3dba0166c95d1f33f566b6bb580b4a2d5b6ed798bd0017f98220b0995441df623205dc713c62027f7547bcbab584d8afda0517e26a39593e5db46cdbd43957b1390c39fd1b499807584c017cf9110899be6c5c12abc98ec82f4efa860318ed5e7565e64204c87c1ae11c924bc66640852d69adbc6a670f9a23b2916a9eac88316d1112eccea57482cc6bafa52619044558a67f2622d23a60e3538a8c3c697d7e625782ac36d6735a966d3e9230edba7f9339164cc3c3547d193773973d017d44d5d46d6d30fa397d5cc63e42d05c15b4f1b73d51a7505d7ba9fa2e44b2a58279bcd44f40c382d148b171bd61e28088eba0019b90ffb7e29c806345b93457b49cd608e7c58eeba484be142202b971a28fce521626928a9e8c1f0f3ff1f582992dbbb0f8eccd66c2c12370c93308a2c0f868873ed4f0d15f3006403dcf9cec2dee06d2033d592e3fbf5aaf9aef28301c62db27e2d2a78d053954a25b1dce20ed7e4456814d5f02b8f3dc2852170edbff50a73dcdd40089797459dad3ec096b0af1947c4dad2da2e784f38c1c0d9c2d46694a10c47f1f0a5ac6fed806003fad5a29c8006354719a9bffd1d7df4df8a562ba5abe32035d7aadf7e02498edab2e6458686722bc762e9e1de3e33bd2b65142cdd174e36a5b5f68ce922d652c857b19fb82f82d8a72e21a7888a47d34dd6dd31986ae1ba12836d2c6112a325f395679bd24971932f552809297fecc7dcd404fc62859726c2c95155f104e7e569d65c5be47fd5bf7511b409364cc516e87bea962d5af0642a81f738fb72d0470fa4889132cd6a6c8524c75b18f4c6fb356f2d8ed0e33d924b5d89685dd72404a4b4ab9aa01961272d428429eae843cea3f9aa6d604cba458bfdb679b11266093d13bb57d9852315ea2dc9bf4fc5ba2c6b8419d78567932999d0a58513d0f307fe43c1299597a8cb8f9eed5c114d98c8979641355d499a5beb4b8a078d633ba200ebaed7df18a7bed3102d90d4dbb9524bf8b178d0ae8976cbc51ebf4708aec7f840ff4efd2df31d1e29f779b123c72b4859d6069e0b52e7c9d8e730f4f718952b273f42c9b6bb7ff9f373996fbd72bc69eddbcc897072d82bedf9164b6271b888486020179b7578d8907ab8961a2b11531b05e03e1927a2d2291a629aa9a419792b881c9bef34825aa15c35be121438427dd045fa5215f582a10098fc8e32705abb016bc580f1cce9365608707420f2f6aa1141f3dfa0ce7e7cad26fba08af878cb5167c1913868fcad66d7b38e360948f8015cfdddc546ca78d9172e378b9a49ce075e53324342f709b2034056f476f281de08611b751e011fe23ae6bd2eccb91a60d0eb7a93c4bc24ed92561e60f9df40794601f1453ead8e3005eca67bae0b0f9a19d599ffad73fa05e090266be8f3bf1b03e306ab5bb4db6f388a783baaf1ca1423143bdc01a3b49176b427bae2427493dd836cf47965bcd283a7fe371cd0a52dfd3c442d8f76bfe3d259c3481eb94955f420acee03ba47204e283866f0441eb21b1c0757e951df800abe2b1afc9548560bb6f470a795265c0134a5c836096cba87641114fd69ed17315eaf971f314d9bf223c8c27b43a0d7514b3d45518982b12bf278f0354d7374c513d3e8c93d6d1266a7dd3750bff479a9984cb6113ea28c901878c49f739035061d649e604810631c97771e740b68dbc67f17ad52140ec0901139361f5877ab6f9a97228b7be1600cdbddb3cbfa9080e0ab9e19f5e8faceceb5dee47c1b416359218da01e0af7c7a582b5ecee32a9caeb1b68955f64161d87b9e576de01f59eebe0d50ed73c6f03f64b3c1147e778c5627243640ef8e9503b5e07949442893e21f17590ad19bb61a411c6eb4450aaad8b210bed9d0c15ff6e81b56621cc1e5ed2f814ac232680a09f8de21d60c5e1421f6d2a1443ce30c1c4bfdc341285a9cabcca2515c42d137f2f21fb1fde4ef8b67f088ba2c7dca21fa9628598cd10282eb0e382adda2dc885bbeb543bb5cccf0fccc002e8bef2a33ba9d91a4e02a9f5a5688bc312fcb838eb092517973f9553f6449eff8e1c9a94eebcc5e1b74c871cb871750ed7e319574cc94bbb0b28276ab58d4b622ede60c18988173ad1224f57f24708b8e9c7b4c7558c91d4efcbe033696dbef56439b657c91a0b4f7ed4e838ac16da275293ea4d8ed5ef34b1e536c562597bc64c1fc31f90902c06c3004033fbd4d7f9bbb5e38b84d1c915dd660693b41a6a60ec8dee66e5869a50d64dbdf6448c02835ab435d075f42ae3d2651d241213192a62516298230a5070a2c0b140ca132d19813dcb5e21d75741d419293953f180893efe5a17dbbbe9f1ea86773451e4e0dbca29f4ab08e14b4b2017e0070d3473034bb2e8d3a3f2ab4c4b10fd545073a78a569fc23b5c7e19017f63dab09703d5b120a4f3560ec17ee540dedc4e174ea5e22b05b195b77292e6b6cfaa614d388dc8a3487680b9473e887c474f9bfdab746ac0e87be27b34c8fe0b8e6ed1ac9dcb68167d869142c315596119a0f293557016128e4dbba33c25d3e950f922ddcad8112a77a65eb66d57af4368f89143cafe9d05ccb990728244fadd8b53b65a4a3ef237a08bbbeadd426d8a09419cf4879c5d10894074dd06020d7c408e4499e8697efb503cbc723da7a0fe36bc819fe2776b2fdfa15d600574e4a2aa72f96f6eafea518436f9d42148a7da15a18527dabab09a4a0df0f43496c3cea36ad683fdcb989cca783fd3353420710c4c385830f2e9edd5559d45935af41d892962253763839e65d03ae69eb4c6ec264de33855566763e8934a4f219cf3ae13ae5b385c79d8a35414afca1a5ac6035b9941e1145419a0c310bb12495bb93e455708f6e0b5db27f3b97231e30291cf869d6e120ecb0e323b9da0e4dfe6409b6f1ae3b272746e3c0a84bbf9b3b7dd6fb19a142e8181afe6e937110540663906d1b2d85d1e417626811986d6cd697a2cf509b357a0eb017f8cfefc6cf5650fdabb2a057efd17e441169a63d755ac7697527b6f0b73ab4e9e628cd188962bff1318754ae7bfaadd322ba8a9267e77d9c0030ae9a2b090388f6e667427871f24ec3238188d05965e3fb49425d2ccdc1ddb9c8e53133660d53b46dc62c192f269986cb030ed9ff44328c44b0de2f7d27dbc458ef60511f02d8e2169dad4032bcc552bc20bb3df03afe49bb2acc27501627cba1a06fb8642e144258368cefd8cc39bd09383a20dcde26859cad45eb4ae879ad3a6456730773f6631f5a85db4470c3ea980983b774052e8a797c190552ee2769700753f74e312d360ce6f19ad9c3c255c2440169b9c8f63107097f43847e86475e854caad9733a7efb8043362f1eb8cd28863f898207d833455a50594196f41561c356045055afa3f504f05848be59b79e6ed1a93422617cdaaea4fcaa6626886a7bdbc82c5673d63549badcf279fb7ace1785794624be3b8313490d166c38095193881df500da9edf98e580f98f139b8834caff053c568598e32df0db359bb7496df7cb9a26e9eb687016a657b461906eed5b684ec2ebc63f804960a1fac145e2ed86bf04cf082abcadd1f9523603db3696c759b5391ae753ef33ea82a39d4b85591e89fc68f52185efc620c3552afb7747bd663b3bde7455901831b99948a2209b4a20bcce9ac5ffe73e840e1e566b64ed581b9a8e4506b0bed485d76cc2e617333dfd870e0b56f0846993fd973e8e2615919af69a42842bb75b667405f24e818a84213af3d84fe72f238160bad2e80ea2c9af7815319edff5c343c0d3b0b0df489c25c45a88666f43c0cc8a555e4fcb9d662108b9ba56450128057f1ac30342c4fc75dac0acbe5465afdfa32bef795585fe11a9929d6cc905b74ee659cfec02e7ce0b2b0ea50d7f39911729e0fc3f21dc538156e4cc52477930537b6033e2e92e09a0099a9a7ae09c3589a9b1a60d13e08cc116911123c0eb9539ee2d7cef6541e5868542566b41e9116e020a0768f2f80f3a1daa3e70732858d8e8daa364595ea36d19e1434ca5bb3e9ec25410e68405f81c2d47150891765fa70ac04c19a1f16caf329818b7284749c13b4138c40e8fdf3238a63738ba793c4db885f826e151725fdcf350e246959a54ad5b71490d0b31a807b71216cc9571fc9ae992cbb25c0b33f6c993ebf039fc738c9b0a5f3b6a4b04c8b826d2346508b2a226e26ebd0e25e0956af30b5921da8866e1de7723cc6f22d71647fd90a32bab08626d1587f8eb2b8da1514c88906fe8a980a33c155930473b74ed04daa1a26d0115b558b32fa1eff088b59243d5b88dd5c07dcd1a7d65c9d0256e83d457f1c214aac655145e055ba526f5cc286975c2ea9e345d0621c4cbc56fe9128c7f12473dd7cf0bca5e351c2f754c49883c665e430818d9b878f1f4d2a84fa110f090d46b789d138a6a7292eb3c9251ede1bdc8ab1b0da7166fce3d949a535d785d6a40f638b926047c7a8a8724e106bbf1e353dc66031705f4c839bf08e4308759b8d8c3842b4008f0b43af1beb520212b5ebeb0a713c7f8c6087e2d1b83ead8ca99f178bdfccf7b63a20ee6e8897130b89be6c5477190c62ab9650c6be4893c057c18360a9456aa7b1706147be39a565f8da6b26612cb33b8a195ec93ce1102d18df68dc35143e30e0a82abdb2b8d5b2259b624dcf94f2362252f2f5a32467318f02ae10ae7a1ff3991ffaefe0a5e56812158f23e7d671fced2b6c725690f5fb0e41aecc0f75982ed83c5d47027ab757e672cda96f5ccbe8f6dc28532a8379ab23fb1f649519ee4868da8a6f897b3a959e26393859ce16731ef93a2ae030d0ec194e98363b93d6be3ebd031dc36bd9f924dea6ee7d707e2b933a74993e8d6b79462f4e1a0dd617c00c0ae9db223445428c591ff3f13eac17bc301679978ec4bcef9f730445396e60b7d41454139779f79f729084414d0f9f72474d6fb5e1a06191c4be0f3755316319d1938696fd24e975adfa8b332d35103165cd43c021a7ddbfbe67055da9e36bbf1312e053517c06cf951954bbf42996b3d8c7f8b000faaccb270aca51dac361d852228fcfaa6215fa6db6f0b85f2d3128c64d58caf7cb117cecb9c3aae30643a2ae786aa27c2842cd44c0c7b4e5c90ec6d3e9670357f43d65971ed81a2b10bddb22092bddb7ff2a6558582da17ca1cb0d9ae6c3696d77ac364538dfa1d8e4f1aa0bceb1c06307487f390c2ce088fc334cc8677abf63f6241d6850c8391e4da7499f74bc0b8031fe7fb3f4c955c83b9d4583e200468a51ac1c9138374011067fcd47079136cd419aef39de75df0374e70e743dce437561c0defc77ea93b18ead22fee8ad7f116a0cba428c74518bc21e880f984ca4e70670ba098517b2ab8c9446588d15ca3ff21a18c8d1bb08ce3311bb1495239a774bb002abc4fbd827a1c5d3a69c0da88e86cb56ff7b8afa38c496cd1f743ae81e5182e7b454d1f29a9e9cb1bb71c416ce670cbd8a0735c8e938beb71b656001550768cf02fd89c8e438d8e9a80e57dabaf7d69f107f8757537c542bf00350743173c871f42e0d2c9a164f9f00d4516517771c6d53bc1885c829114c4ff6b6423ff7c2b42bd510f40468fe304840b488df853d7f6777eacbb67167b23fabe4801f79cb0291e85ee13f988429c8390c9c6c02173eb46995101696859ae2442d6631ccddf26d4ce0c5f4afbc95b0e5c873b4258645297c4f958e900793d230bc62329d224f43715da345d02dc0c7157de6dca311234fcea2daa6a4497068c5a00ba0c18867c710d8f61831c92f2f788710ae06c5f5e2a1e0bc0e66eceaf412f1ab6addf9ef3cf368eb6a4c86ac3f5450a7d0769125724d5f84f42aa96d8328173f76f56ffeba3566158b6968f8a42dfbb028920671c555f8ea54a94901edf9d5dee9e112476dfe4e9b2e6f6624869001ab04208c940cc425ae0e39092cf7b6190a5efc536162090948cd6356e67e3db4104b2add07f3f0b1ead6f5db2f79e19b36a583ed0c926075cecb46511b77c3a379ad26288d6fde6017c1c69698f7e598cb19213e2ec10296b72a2e414218441120e297327115d7dcd7f76fd9e48f47b58057ec95f5792a1f617471a074ad651b653e5aa890a064fb7c4e53fcfea31db50a465ad4ecf764ec8fdb08e8f658a4e14acdde9ed70f001cd07b55148e9f236f98406e0eae0560209c66463cfc38a41214a0667b65ee96000892eda568dfa4b7184e6f331aabf5b4373888f8f44f779336e651abd70372983016eeb1dda36ca0c10e162800577ee767dfd6f8ff5b33d717b571d4a148f113f75ceab3f71c0026098e5dbef3350a392fb1b5a750d27f2ff2293c22ad8117ce358b0548261c56f459b5510dbd780ce071b59ba6268ed19d4f852d41e05bc62509b95d67b2ec5172738c6de7c7be2c21f2a78f0d0f81b5e231e88c594de0998437810710f42639883beacd176ed3e2c7a16cef570e48e27a2b94b75990ea400b82ef2135a63d26c0bd8e2ae5b3f1486d8a19ca8effb052b9273a083b371989065a9a4c830504af9be68c9ba98faaf9a22e7e77428f42665c1a0236dfcd4cbb44602749774989af246bef6695b5eae937db1781dfc471d34af83f8e6c520e23a507b2c39ff23c3a56c2c0249cb0fe1833f5df00a42ecd923838e186a33007ff3bd003e1930b83c689fe4626c479f2c2fd86a30974025e425f252fd4f238d47adf36","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
