<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8111944a66178f3ed7c0c769063c467ff81330507a5bb5336c7191188511837e4dd538ba70c87c6eb116146282be7c8ff48412aaa057b57e9c1b65a568f3e4b2ad001a044691abeedeb99cc745182c1d405d5f7f0464b93793af25c348a38867ddb141194e8dfc7193fc44fd3c6b8271f46aeee27d823994f9c12489683d2e4e061487ce42616946ed8ff14884ad71c115956e8c256f9999b920ec7ccc6b9c457030044b661de61ef6680de69918a53d349c1e0915e11523e1b437dd0c85f0d2560c7cbb562a0ed41f966febcdb085ac094d2155aca88a9688ab43e2d4b24662eb0a9fb55c966ac9fb41629d97d0cc5343e7a967e9dd7eb8d345eb6130ff7d62560fd5bded8ff652d87fe40abe7a68e9bc86e83762c5cce497ffa2e0cdc65e2719412da768e48c08d11eea3d771f7bb8e03734e539061bb6b5d232c55056a64a5eeaa8a4cd5be391d8118b9024975177d154fdc6e7c318cde322ff39aca9040307f528b212c051514b8bff0328c21eb3cb56f283326e6f2480d7d61443b350cf3beec0734f9da9f8f4c61202cdaaef58eb3dfae8b71faa61ae3d3ebb54d81e67a40d983b10f6e7092f1afdd9c3957f6f0c273e1f974d3d2cd00719b3aabf5a605a74c4833cb2f368b7f46a7040cb87953aff41799e76a1f9ccf3191660621bdfda1eb54c6564ad933f820363880bf98122bc4bffeb82bc9f07bcbaa2108a8e26fb17ebb4e2a7075c6d95af622abbe9ffbe26899bbc04d3c0306b0572e5b55769033795e0e137836dfe15ceee75a945e2425733f26704fbbfe7d02910ef83348d8827607de1ce20f27eeefa2d5ccfb9f3a547c41e5b64afe74225c50c112970203a9f64d995c73d7765e5b5bb64c1fe64301775cfb2150a1ee214d48c5b090c646aa041f26beb272ba3a3cf6e4902b9c1002c743a8b4374172f0e0661f843355e768d7159cbdb9d72b6d8932f4a37decacdee38cb82939f564bea5fe507c97b3124f9076030a207e8958d06fa499616903319ad8162aa4ccf1e817d2899dae2b6592351eb779e9f5ffc9a9e64528a56d41ba0fdbfa31f118a26f8d8fa99f683bfc8cbb84b1c7cb6535a06353f11e8e16b41bef69c3ac49b5ab080267eaed2ebd9e7ed3d965b09d3adc94bf06d06c9bbc89677a1a0f71c19369a7dce571caf0da26da8fd8901376e85af94b2f8e0f3e915a71764ce0288604f043dab479e897eceadc7ab67f8189b2d428a340c0b1ffea996bc20a63ac9f798a67e8c43560184be6a7fc36f6772e2046966fc169912fbb5a2aa7e00b944e62d8d9d9e5c6bf39ae3146c7c403a713297fc0ad5fdd89d4b0ecfdd85367b876d5b44450564f4f8dd2cf119a1b48b0927570f721559c168afa2bef7a27637e8370ff98371bf3b6d3d29d3ca234c807fabef47358a5896001c87aa2a21ef5da4d4bf490118a8e213281dcde55749cc59e9c1d8c4ba90527a2d1a8748d5df748541822825667526ba1bd5bb0497996802b9891034fb58a5e50a14535cc2dc020e831571d36f1585e467a77700f18a2a22ad1f70acd01204409668e156b5a594f72212675eb982af2303a37b2e8c3dd256361e560bb291c6b72392ecb2261b1c82545797f011b81e6ab1da26845a02e1e7d61d78fe7755fcd4321f2189c06aa9ee7fc66a7d7dcda803cf506c52b990ddabc3378c22616901ac86f18c7a00200cdd15c7831814fbb68b66357cd7143708f39c1def26c3493334c0a80e38184f735465c6d13894bf5e97679205db05c9ecdfe63f40c10f1a73d5684e81b5b9a430c71da0ffe337725e66bcb26391ec260ec076f0fc7d9a94c58893301cdb26a279d61d527d7d7a7b6f1f534b27b0748681823336e9b86059a6f1f6b9585be48a8deb08eaccaa0f064ef9dce7f7a255a8e848703ed5f63f29b4d9871bec970ddf3701eb182b0e8337e24dc68eee92794694f35c5af06ad4aca22713029839ae5b6543a211c95bd002c06f5ccaa7a058b807fb876b4a0492e80457754c379ac9ce4cef51dc313f854869f1e4ba8fca28adf527244cdd7be302100fc7136a59931179c4ad1684bcdb4673b1857d12bce5cbc74bd93276191e6765dd81756e4a58bc0fad31b09444264f345f0e935122d825ab507086559d9a0452c018ad9cfa9c79b5154afbb61aa857e99b61c55f0f32a82002ec80f0c5f8de30a0408da3d7f8f5bcff1af8eaaa63314e1321f8a4eda512b7fe53bba7df6a4e50ee2c965f4b768c97d6a05a3acf26fbf6c45d0b455ceeb32750d0a83b103a1b8a2c0489cfe1f62404900850c128b15a1a55aa5992cf368a8b0d212dcfc00e657a9a4f822fe926e7b6e0e0c0cef457605d9964afc29bf9adbd774b62b5e55cbb5797a23d5c8d93faa980b11d79e32701e21f533c11f390911b334216b2c593460e1532c3dc7b693746eb938f76e4dc35981129db520372e3099d7bef547ae2e657869392035a66dbe2c8d4571f3e6362515f86af75ee1de5465db654ff4578cd1c148e5187ea2b29f3748a9d1d43ea8e820ae2b63f4a4a4ab474268ca7a7bfcf66aa650b554573bec2823425cbc16bcdea55fb004aab24f0567b99fda25661237be71969956211488b7ec3a1b084aabd427ff7f671be4f45b7806665481ecb62ba969e4e9ae6e4b07f0ed84d4fa34486dec18311b07f55dc38e8bed65793a4853ec2127a02608423990ed95a655f0f2fc12fff45471ec7ec78853ca387ff70a1a852fad2967633060d6b4dbe0d8cc8bd22aa78aa93a6c10b49d2cf26af705849e96e6cf12982b6f4875af2f40b74e9d174721cd9b5ea383b3ab9c0683cda26ddb3c99f2ea65ede9a114d75bb35ff1d3a85bc7aab4cf977fbbf597cd8dec1eba752969d7d0b6cea75edadeba96e0fc1ec959ee451681c430481a3b443da1749c7d9faa8ab5ba926477a8b02893a3f2ac016a29c09b838c0005fa087f69fa8dcca5192ee272ae4d97277b114e0e087bf37afe9f431ffaf0c65bd864e3ba761654ac90cc3f90a9022395f381fa72db06fc1d5eb229983b67f3f870c72c50592bf0e4efb98720ab0c5817ff9190a862198c172a6db659dacd0b53e5b481c29f12ff6e378d5a660c8decb77b3645d2eb236a38b55766455c7108ec8d49b74728ae729ac82d8a9e80273a806df6621207fb4ee387c80a01400f408aeaaef687fe38770d4479fbf735569a80bea14571baaccc38f8809211f26753f7a94aab0cbd797feaf947ebf027fc61a038941e8b4107d295a3ed902b8dad6b2a12ff775a1831d84ae3cede0e661ac1798ad020abf3ea8c83a77a79d68fffda506ad9a4f3f5ac30842d54831643813724347f577754aa45f61a5d75ad3f572653616190fdd7ace07146b2618173842454759f843cc556bec71e7e8898984dddf724fd477cdc88abb42d426e461b3b035260c77caa3c737943014b414b8c4e9b810d5e28e2fdb2a5c4fbfa6c9e4205cce7628227cb372589d20d4e06e0c729f346e8588a3e968d819a15234512978429b7502347f0e4a1b8435e9124b9ec79e4cfe6a2e6a587dfd46ed5ed3bfaaf5dc5e518dbd2f887150fc7afb638ae28f14ca8bf14101058cccb4046ad0150e926bfa814aa4570b1c7c76237ab877da731cb172e8c5af83a570a4ef266b26a1bec2500b87d01074c045107e716dd5d8154590bef023ae133609810a6f8931a01a3feece6fac47c98e2cfb5ed84954dd74fd172578413efd9b544e8d4180a4b75ebe38977c91553ab9869d61460702cfd445f15cfb6be01be7fdfdcf6f6e34e960c9fb62f9819c6c417c27888aff745575b28bf756c6028bff14ee0b8b72c2251ec42e25a405bba5623c56bf5629688fc8169d827e58a799b056bb03bd00d42190610bf53bf00ce0f2f2970731b2af8889452619bbcfd379a6593417c51f4f81e0510c0f7f9fde02bbf1cb9ec237c4e68e3b4e808516277de6266e8bce3db8abd99f52af44a2ee5826ed921550d086fe8069e0e1c4c33ab42691feb8aee4a93d8afd1f2ce76788f900aba57a76ca4dff73599e2c38bab109fac078fa5c24bb44821ecf4e6fc2f13c8f62b542b3a70987d639c95aa3a1d108c84122071db6c0da0ec4e568e371a60b5705104619f54a66d3f6898fd873104b5c2b99da061f60fe0aa159369002dc44eb245c7f7ca82e13968aae38aa4715be8f160d135b5e99f72a924626c953036622ed9c2e95d3910b5c2aaa2c03d47ce849cae85d15b44b34982dff8e4767a0d7550109001e9b6f1c8e2e78f9f9e544e7cf1970c3988db8fc893d27a8cf43fa6900fd72f7cee456a3508f9b32609e639968818dc81e469f27aad0fc68e802192f37ad78bd2426113b803873b333cd5ad00437348749f8b23f1e3f770400389d7f7c357b9a99ca092e6c1d0091f746f167f00e8bf52065bc4767704bf00e761fa42773a250c7d16fac8e23cddd706758db2a78329818bd3e0aa2cf1b7a4f5dfbeb2b8ea2fd2e5358b30e2c1058639c7dbfe33b62b098370b096cb00b58682fa68f6d3b0c1c2ccec02076718b6de99247ffff928a70362c5bb130d19938e404e1ca7ede55c44b892f56316dba84c686cf130aa01d2455384d89758278749b95c8a8bee8bf3a81b2d771e7c1e1cd1a154a8e5ab85c237643af6c007576d110f3eaad3fca58d207f124c1152de4d463e721e3aa343992ed85073f7955764cc315df212eadd77139b60b8b1482cedf1994758e2b3a8385f0799bd160655a50950f667d2bff7316a055066ab7e5c90042464aa9442ee0434217e163a64c315f3eae461db9f7a88685e27e028617e41110237ae8bbd57c693b42923b8c75e9a2c1859c1952114acf4acdf9e476ab93498b17cc945976f0955b048f339e6385ff33c2476597d10a3a3d59456b2caed15860c296da03f2820fd3e9f0a81f7ea67d718f965f0f9100332cf3fda22831f470098b41f1ca704a64ac13748309150003923c7077875cce4cf2a2f29d62718959109e60dd5d072a14da42ff8fb3a42b3ca6c3dcc66250798c3dda747f541807948ebb49aa9d853d8bb5db4c802f45e7c764ef7db8f0dc233f909e15152d7f3873c12de8c264f9829db783f34e0ff5a322203a2a0f52cadf2b1a0cda82ed9466a697eb8f700f6ee9c950661e873b4fb589f370fdd13ced0d9574a90a4580f5952b15c521db23b6d5dd2f317c697bc062ba3cc885119b38f1ef4b602365130b03b028c02e472016dccf2f24b465d5e5ce0495cf4c0a0984d7767866d7fe7e43952a9c4978f044b27b59b463f044cea8fea99ae462557de3d85ef47407890964c4ea5b36ffd9ffd4ce1c2e2da7397e8b21df42059dfd269b234d040bf5f6a024cde6ff970a9b548251bf52abbf3dd1112c0c127aff544230680fc753a91191c484af25ce9c52e3d27311de0619ce1014959d393ef1e638b42f2f9777731749ff43174c77d8e1a96a264df7dd1841bfabc33cd2cf5526634c8269af14286915be1da9348e519ec03cc2f2abba0e56141075d82890aa47cf14f1da49903fcfc4913413ceacde6ba73da5000098eaa0b9e70fce1cdabc9a6267e0f74df4b0968ea60261c1c44f6a6f8c2c2846b636f296aea9185bacce5fc53cbb5f51aae23d47a6f2f698a6bf77ec30daa0b80e9a2bd6756fb7844f000939c8d1d4535d0575debdf20966a176c039fd6c5b5a66ad3406ab5b029cf45e9194e6f77829b03750dbfdcc00d5c29aa1fc40063337fb4f9314bca4df6c4957d29601945e778e2d0b72d99b7545d761e7df39f4d09bfeb0769ff7ce709b647551320cd9d05fdc9b71c4c9fe455e731c7f7fc857596ad4be53724d7d1af4608ba2a98216d424cfee5078496fd00f3880eebb7b4938df07ca5df447be5839430e545b79e58b423ed66880fdc6772a6bd99f4cb2045688c31157950720d0c5b027bb72a8c6476467fee1ab295bee82f3b09876e1793fbdd9539047772eb19e99c54c8796b09fcc48278cce64ab74fec425e21a4254c748a5d605f8b7f8923498dd7dc71e2708aaab0ee339c1a0be8ac4b37e3b5881a63bd1cd848a9e3d88516e427b3977d6609fc0651c9b2c23db9227a96fdf423a75dc2773892b213a7164960c083c7ca8899ac77e2df30408114e1646bda21421d1901735cf3b0c528b480e5a1fefc285861d9784a71a23435a95a2492ca7bfacc90814fe8e4a299cc38fa3cd03181173de76645c1bf85d5b8af13ba1a0d3d771d71356a0bc75aaf435c3828145727bfd74ff5031bed99c4629b593dd510803d5e47279902a420b60cf2aa12b73df8404e1349d21bdc5888d85dc8e4ac7e880f892d5d826a0799f996d305cf60eaddbf36a58700e9e55b4d8920e323167f16dc37f811ce7bfeea7f35eb73887d6409e152eaeafab5d44f679a306f3bc7cdd14e6353dc69c0ddb26fdb06ca5395038b3813d1da72c72fa855325a68094d8e17241643952a29fa1565e5d893cffc6a319b8099c3107dfc631d129971398d933769cf9953ea24a1497641a95a95c2222ea49cb668d27b4a05bdb2f611500e33e75389e57c2ec0e8d2403ae76d3ee4e565c1d2b715ff752236d5f3e72708d2cb7ba3d0fb014aa2b2138c174d362a5be5c7929078513e7a78d8e585e84124793a1c356dc8fb16decbfdca283da4f8ec1c775fa24b9bf116c53e01acec088417715283e28ca226fe0f1670e51f2aa79b906124d7d21ef0001b82f79e72ea686d3a8d51f252340a0ec27031b69a320900773086d9a0615d1fa942c14239be8fd61727fe0227c6083c284978a2757c708b5d1470236d2afce45e93bf002d0151170279d832b92190425b2c540615f15e4a4d30bd6ce0dfe5e17609f3b6ffdff24e02afa99af8047804e04d4ad5e2a6c8ee157561bef9b7f1424dc275c5b5af087950484fb29844669a1f2d15cbcd6607b98fdd93d463ef0cff7b2ccadd45b13ab67edf3828e75fa3a3399e82e50a8a3021cc150cbac158a6fca0359f66b58882138e86ba73f3a9b13122e96b523a019b5855a4f67f99523c9aab07a328d2dd7a8a237bae219abc498aa2f78da6a1ddb003ca865fd4c9779003821d54e7578303c9205fa71a0e20c0bf6605aef9bd4eb6b941c34e613459732f76e7b5cf2e1eed473fbb1c4a4954473d2c5284b38be9faf8af0b97b76f99113227585ae8793f6b0876059e7669f716abde43b2eecaabc224a72829e2f02bbd382c69c70ea21aedbcbb441b03a70cb11c5dd3891ae7abc2da05b83ef987c88f2f48f1603c018385a48f1ed1dc777f3dd87acdb7c3633a7a28fba2873fb918a773b52debca2a91316ce90371af0955275b6748d9b5aa58e03b0d3e84d9b09f40bdd4fdf49c0954207985a5b217c52a42ad0dc19906ac4549cf89548d68d2b3d0265444ebf80c7b737a934305712d3bb515e61ec4e9154c45bb7c8649a421912f9be8de002d37bc1ab02b202f97a93bc21629a76707065b400ec5042797c1e9253555003c3315c14b1d5e92ded059980216ecb2787f7dbbfb46b05a000e64c099e6105cd90b9c8b251e66bccf113a1126cfdb24d3404b1fba2ee188ebe37e06945a4e1710a58f2d491b5042e3306e8432b9d1591f424109a3cdc31a7a15405507cd8e8a933504434261c02595ae9fb837ca3144a2cf811d51b18a6349e0bb8183139a78c97ea2b05acf9385b5e3bc26ceadd68cb7cd7e0b2d001b3a9a49b105565ead6bffa982045ef956e1dd990c2aa79d6ba4037cf63b5a315cf6ea3c04df5fd122f68323eff9b9545ae0234e6077c44e08b46da5b3150b13a667705516083e4a0d964fc245a93d85059600491d858ba0893b5a4cf39ee6ed30de1e7d809e6ffeadf314dc8ffd29b8f828c3780621491a7c753225f1301ad1624d6137731b7645c4d5133c2cefd655513d0d0616f566a3a530f99b87ad2a54e89ec2082777283ca99424881afac572f3d3316abf9c23bef25441a7572edae3980c6654efda4b88c1119492e10145713617d788908111b682944f7943164f80824c2362b3eeb0e06c54c69854f9a9f195046254f6095f8551d876f514b46b370126295e2b91b5847108726d56c1b22028a62539214cf0d6fc3d2a14051c691cc277c34f9a5f407d3f446550d99214df1262e407058cca937ea7f929c1375207320dab8b4c91a38c45b53a87bba74100a6eda94496294022f172a3d5da1b07032f4c02c6f3a7f2e258a2cb7d8141e48790b145ba4522b83d8e0bc349a10c8863ab8772cec356b2c3a7c8a7715c683c998981ad3d4a463d6cf243ed1d324dfc28dc52396ee61b696d6481c60e7e3946da8e6d835ec1ec8293eb258c4f6f55c57d673feeb76f98a531318a447dfe7b7965835398963a6bdc27e90ef439a6918289c051599afe74eb144714277b11fe3ba02ad349fdc87f9919d5c3d271fa29c52d5cc61b61f688f257e435a5dada2e060350085889fd3d8f9fa3c4b096dc3f5c07aa4c5a3e86c0b91258d1f5bfe929ecc23e13ad1f79d2c4dc293258d4da3d5c6904955dbf194ffc039d3019e677dc8f954c4a1e05e58278289c66a04d5c39d81a64fc458b0ac9e3eacfd4d53ccd5100fd54ca8f4994cdeca9acba42d3660c2a5c51b42ffe1fac391a5125501adc8b0f1e129c9f966abbcb528ce9e86801be87a381d13255c37d4d57994f9beb185c321df1fc4bcf4d66f804172901c26eafe4456a4a64e9a9d6d890e285d030f80d6ad5bb75a6668149dd8bf89cc1b3587c601cdf4beacf0c470ea426b7aa2e48785a4a3cc1abcd4ccda47786546eb64f87dc031769e91c12a0ddf799b9cae9a73e57de4263bc6ebe01c6cb403fe63aa24f7155961affb9126fb249761dea5e9da3b691fc82f776b519447829788ff476f3516ab20213ee873843701730ff37f2190a44d46098322d8486412fa70e18d68f4e1b1a77518cb0698dbe8ec2f95cf3fa39e29fb5d2d2f2a0a520972532e6d1c0303340911ceb49452beb2c9463e6fc8974800b64fe94d019704bd3f3b831415d7af771e300f847c7693683496d3c04f966005f7ea8ad59a3413532078586471118a75248012c480ffff1ffb819b151c5ed30109d758e72789c5c4b34899d4e9fa99213a666f80aaf3674ba492fd3c3324df6d6f2bebe2de632a34f645b2ac089ad05d24d6b2a2e22e16ba3555965eb94aa577e659bf57998fe167936457173cfe39e9edb8cd59f003055600759d70ceb9ab21fd82e9da2c14e5b6ec9eb5a8480d60fc135d2a8c460a2ed218994caf2c62e4fed1f537a4be32c445c8d625e6851f111eb5987ac8b43319bdff87f272178ed214d19ce2aa4f39fd78ddb77677922c9ecd93375f380fe5832a86a1137e47eda0cdfd8c2607368b3ade17e763e8e40255321923ac976c400870892ad08df51a1c9a220c85038eefa2c02642064e0f37335b5aaf817191c70fb0d463517f4deed13fd4c2fa5837ca251a99203380115925cad4bcee98f5bb28c6415e2176eb198fe85e11467f9a57087d7a6008a5c5469de811b7d552579e9b3f317b5e91ae5dc77b73987272f5acb59fc1ea698525d943ac5bd52cdea8273a3741cdee3388c32e71f7daeccbc2eaf82181ea409095e80dd1d79ee5c9d7868b38af04768f81c05674cf72904e33b7316fa26a708e03832d7e2cae70ab8c1962aa66bc172ac5b33872e2ea29cc17f994c408b0fef7cd4bcd4ed977bdc9c101e6dd9103b7ad0810bdf736ab86feb84f904bc2676c9ee56d5812835d074cc216cfe38189c349cedeb9d2a8b82760ab911b483d6ebcc38e5461551a08bc946e593be6d7466a5900507143a8e517f96bc08077cfdad115ee458a0a9c33928467326e9e9a9105bd56ebdea0edb900bb608f2b01274a1a492cabdbba0a7f02768f34f227bf323adecd21e32259711049dcc8e131d2b600a716de73b8d83dabb099828d4091509d9b529e5a55657e2b03376e85b922db9b0046c5a89ae3fddb6841e2616e1f2074fe346f65235e8112c9b6add04b08df435b5e54374f89f0e21148c94175b1ff6d8b87d83c460b957a04f67fd66e335c928457e9debb5082196796a3ae2609ffc5f523381d99b76970d3f1c51a3565960f553833d3500c5bfde21b3521f6f2ae4366f34bbea90744b748b046bbe67cf309fbe7dc07072749eda6d98d6bbb1d4613334d5a5c41d7bfd3fe3c66355584fa5f9332fcec93822e30071ca4726404ea4e8324afabee1dff37d065a830456326027ef43faab2cf866f0bc44e786d5a1e93dacfd2cfaf9b19f859406f6d916bba6175659db9dd1d7bf45b7a41d0fb1049bbeb554003fc9f62e23a6e193b2c922571dee913daa34669d4ebdf7664a1f9c6a7008775dcc8a611a3b5f4ee81e4c76c261f4b959f19f8636ff856d093d48ac4f661b0a45c1ab53a2f29207e3c9a23b07ef0248ad68122e1b5829e10c21645459d0bbba16ad3884185f96a7e45eecdaef2b4d6a3370e3eee16bb013e18b8237b96753c7c01eaecf4b98face1519983e6a39e09539649d92edfd3301df01ca071cf95cfb2e16aa32f444f5bc40624f7f6721efe2e13a59148d799ae2bb644221b0fafb4101c48a2dca171812314a21018e501bae3fc08486cf3fda3663fb8a4370765408f4c88d2c388973514359b04d3bd5610a3591692b626e348a0ad39d8f9d12cf9c300323671e85a49a87fb02fc9d2ac0e2c097831beaff9bfc393bda2a076ac69506621f8e336dec2f130fd943ecb2937c72816ada453d6de4e0a944ea33fe27edfe9a281b9b3f96c33805ec9fc498c0864f96688d46482fcf5cf51b9d64f7796e1866406c4d818bc27d6fade58aaf1479b7c3597350de6e68347d3d1345c7044721194024870a854602a908ea891bb1b53c0a5ec2849437f38c078822340a8bf9140a4aac182742fd225f315ae8f8dfec79249dc5aa6299fd43881e025a43bb82fe2b838b529c2efbcbb00ed349a5c77164b8161491a3e0ba619d24e6ab20e4351b4daa8884d9b28335694d924b8995bd07622035d6247f639befb7d27b980ad852b9a81bd2ee16dac539fdac1931c580d31dc9877d9d955fdd32d4c01a868f2ffc23dc9eac57b1c2d73548f191cd1b328886a4a66a2fcac21d2b78bb7aee327f0c5f19f212fca2ffea4d36ce8d0b408065b949edf9800b0b6a61d87857b8ae51dc9daed4b0c12fb648c55d1929658e95a8576cbc5c0d0c35a4797afaedc36695cc563602db2b9a7484da9d0af55dc4bd42052d669de677eb854834b35d8f202bfff4b9b593fda69d739f67f25357f1825e1bd74408a42bea7404aa5b63c965e1149daa9412ea1f0a003e3b9b4bd2a3ffc1b6476a3ea63f19ba518917475f861b599ec983bd4de7ee3e03e91084636930edc317bbda64fd10a3ca51ad15126f96a7abad835052e733f88561d52790112bf6f24a415882baedf285ca5fe2226e9335fd3f2d0e9813e60d3ad18049accc02359e251039225ecd6b7cb18c75cef6907b39acd67d8cf1de84c25121cd6b3c0c7e1de230560b509299ade3e3ea3d1746f5727c4c18ccec5016508b435b68e604d51280301a90c06dea55225c94adad4cf76e2739e201b66cc12bf456937a44086771b17e8c0c97b88786dddd0d8ed0ae5ce0350c83ac2ad76251aacdd59f02360f3f3bae1d4f2243aeffb499e897ca3adb28a0ee7e490c2f41961b8ea4e19942c92546e421d3bc2baf607df96523c5369decf530b3595751381d742b1840afbfb44f054f78eec131937e63540b37d3d68acc0e2d16a0c551facf8e89617f3bf663c42253097c518f9321c6b416a3575c621d038d30cec6dc78f13dafc1a2ccea912ad6c6ceceba12b4b3eaaecc4a44452057b614c71acc1c2473bca88849f71b478146feb0b42fdc886f69ab7f51e5cbb5917d25660fb1fec0f2abfe3b66fc30dca5d254c5085ae52141ad9f27fca76b967282c39f13b99f763498cbd9dfd44e065fe0edd7d55b580f0b42b0eec8cd048b7f780db46c32295f9bf6062e9f7002a234a7aa473482e3ec7643761f285b63e0026c7322da79220111b15998d03366eb1eef48a0c2c48a1773377001c7c3747f3e783dfff7c7dbdc4e4f964782d3805c268bd3451f26fd2a4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
