<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"72385834c6d3722eb3d56d86e52a77734efaaa3d03eac9d2f8fb775ce8d38008f923aa70e1046eeb543445f52aa1810924d0fb85c6ef9d8f3f414c968fa6c3db8f9f819ee8805e692a5e06d8d58f6e01746c04c18cd4230e76c75169dd105179b8ca93eca170fabf5f975b76ba6fa57c9226cdda97e8a2159caac95cb1bb129618a26cb181c9232f4db3496f50c65925abd657b497d2c17a191a7f873ebfe947813a3945dc96848bc03843cd678aeedc0794915b22d8769afdf7fcb2b1c9e9a2e9aa89530f62018e70f7d913299489092c0adfe7e9ab3188dcaa66267db8375ffc7608a386c8f86ea6c709b8bae9090a2962a1671445be89ed2808c5726ea6b0b846fbdcb16b37e8a2ea7a1b9f6496aea917672c2781712f400c3051ef0836c49440552ef9b668bcc6392e5755576634de8d67848bd398567b76b4fe2975d1975570a2b5e2259bb134cbe014959d7c4af12d387bb46625ed675e7b39950365c19e71e2b0e84a80bbc19844d2dc75571fb90184ce6fcd18861edd4a3e29f941b1908f762159d1e65b6ca5d0751c8923e064ebd9bc759d6958595dc253d2204ee3e8fd4d48eaa677090437ef07cf0a5abf93c703cea5392ea050d2736485b15487bd77d0366300897e423bf610027e95d3b8670526e6a6e98692a3faccaecf4aaad9c335099c36c0d77a4ac8572860d265b01f4e5bde63e571cf4ebcb0e8fd07fe8ea97e5d395cfe934eb4911feb4055200dd7eda1e84e773aa4d13864fd746a928d2f72c5c6c4948c78867e8546fc1b820b791b07f6cf3c5120c735f9a961e904adbddadd49f8a00be3b4e06edb9ff0d7c505530b37bc0ad655b0390476fcc45376df963972ca2da8f15d1ae3d5b41f7184e8dde9e7489d0f34501208a98908c565273f4abd62fc4056603f2f4bf0f46b2106ee3a892716fe0e6c7fa071eb8920b85e02da25271f68a3810d79db523c08339c26b49c102204988f84d26df834a682dde60cab08a228981099a40b1ca1f2342736e7bb14e62d65fcfbc0f589a74b83950c5219ec2e16d5eb2d94472711855bb80077557e04afd049c9b4483fb224da49025a10a1d3b0528811a8b1c0186587bb5a6eba14d25e4f61258396cb3c08a42c3c9b2988417361bf04f4e7deb0230fa5c544bc4ea2743fd08663d4d36f8a0d4363be1ac921e9451b33bf9313ae90cf1c50d058d129ee806810f8b0d457c2ec6e22159327c0dddbfd74526be8c437a995fa84e1341b38057e3581975733044764ae9125f6fd143791f446216f9f23ec3145e559e51ae627417c392f658e12a9e0b55aeebc6b36ec309c448710d0146373902286e76ce5d7cbdd30a0e7663b61e6fd9e8978cd21a0b02938125fea0f195bf892fd60120e2ab15fc4258cc623aafe850e428e83fa8a17d581929c7978cb822576d73dceb1f9cd19eedd24aa6e67832ca0bb026c7768399fe961d7dccc531d117a1f0f2b00e608317179cef62c5b94d479b2748d5bec0974b6676a226db2c80416bf5060a8dd9f9d69867a3412ce265edeac4f06fbfb81d4300c17179ec4127bbcc6d5dab68290015baaa4a5c06781576d0c0429ca1ba8c676a8bed89c9d1706cf0a5b72c523e57e1bfa8f686d47f6d3e472612f8b6012697801179ab007f003d925efc00f940256263c614d81cd38acd5a26e591a23bbc3c943f9267e1109b5f561a936c581a1b7b7abdc550ffc29718b58f8d7a01d82df492697d46a3da82d02b6d8ef2b33581c1e62f2c12c8307e610681cfc687ca24fa7caf52d7b445d158fd46803abb6b9ec52ba11ae8e11abe51b38911c7a5a2470fce59ee35679d20fa965a136e710dfc5039e889e261d90e75074293a724cd4cb95c119d2a91eb2357469632b01d3092f315c7dce3d9d8fb4c457879b46bbca425b8f242316dc814af517bab002c3ab6f59f967d934f6dcf237ee6d4e9ae536c34aeea7894823ccb8d9b49bcba59e720e1e2bf427a3e0e913537c9634f6fd510039c36d90e8fbc6b59b1030fe03135064f1c04a7df386fb924728b8c520ca5877e2c1c55d1af57d397b53171bca58035198448145a26d1e46f21f3ff714127233e1452adc79e4b5dce28d2658851acc82616a2d5b8067a2b42bfd27a26521f5d0b740105231513a9b2c71ac43e7eaade0b619df077bb51c22a95d6f0d8330634414530eddea758a5dbab68f88625809036fae5556201ac3c0e5e5b5fad8546a29c8cbc7078ccee3d91885018533bae2b325b30a50fb98a32efe8f4b8254ced09095b68c281a5d1e622611363b2ecdf499501966891643db36198195699613b07eee68819807daffa79f521b4b2bcb2e216c19ffb0f308013c1192163150e5e601705a1cc4f27ca44997a5070d0e854cebdf7085f944fa935d4c0b5436d9bbb7d1de18b94d5d1f7da72ebee8289e2ffe7e956ef7e8718c1dc1a3541fdf31a45349b398be59d5bd627f787246ba20aaf62119b4c518a903fd0daa6030c140e02183b3d98405db463d3cd92ca67f3f6b0591f83ddd0a0d96438e26ea2b6907b1449834681fb44229a0a24fc78c492287553a1d81515449065d95f3043c7538766770df012387d96a7399ae715691fb452f7805ca2414d4e478117d279291bbc63d74ceb0d2a4d1cdac8bd87a5f04a8564768b28bc1dfe2ba4c2c9b62bdec0233115d007cf44225c6814c9872c783ac68e1a41425e7252a27355c99a5073930f1a2f4abb07e58d21830cab6bea43def2816363cd6e94630e6e33e6578e5cfd6fede23b2f914195d694a7468a85c6763a118c1a6fd0a91baf110e80218f0475a2f83ee29f4aa79da3b63fa9cc1bf88585b780c8ba1e9c5447bd6dc933f3d2b995e0406507474d03f59915ad228b5f2fb4fd56014af9ec481b5b36639a4aef7c0f62a7826a2f34d2d7eea72e4e28c2439bbf0384448b860cde5ee54f97fd193a870c2bf657c5b5a5f9b83fb38339c7fa000a4f13d8c02eb8d6534b161d51e1614bae3566513e1b1e3710d20fe2ba4f15c3f8f24e65e889f1da1f52a43f584fa0623630c01fc2ea789594d9d08bf8fb06a5194ae2bda2c6e4f6385bd5fc2188a2e6fc4d4d3ee5edf69459457070218ef654a563523e5652d6d29db4b60ed3c16fc2436c5e0b72e694b3a6ed445dee9542aed24b6bcf0517820bb16bfb756b2d9505df13273b1b0c6d273f52147a1b574c02e8aeaeb23f77660c6c3c0973c118510fe248c9e6377f62384500eadb794cbc74c705914422c34fdce6bd6ee823d05bb44417cecac992b0e3216d8c630e0df5077aa574826c9fd87bbc3108072be0cb2f0cb739cf7d0955c8da48d4d1355de2f76ceaf1ad520b0531042ff0b8fb04a140671192a6d9cdde79fb3c7b616bc3c0da06e4c8b8fb2dcea37493d02235179db8e8265ec84c358abfb9e539e4f426d95f4b538cb5faa76a8592038a53163c48ef8ad98f299340c68d6526c5b27f13241a454ecd024b1b56d55600dc3bd28bd9d8e9d6b2b6d545c944d1d76cf08bea36fac33f6cb4ce422adc5a85893cec8f0472c1125d13b7b6d344b8bfff4d519d4a8e4951fe42fcf7d7740b87abdc1cbe68a645e277373c359dd7abf3c0fbc94f8ad4b7d2b433ee92197e0516f1090b926a9f1f6839bb4b06c467af87d85034fafd46e177629b8389454e9b1f036b3a634c654a4154c3acfb672eec4db1450cdf758d002f86c450c46bd94dabcbbef05352b04a80cb1b183571163347e34120a9073fd45f3034552156ee10b1eb5ef2dc7bc72f18ee3ce3a28d20640884d57cb3578c5aeaa2c70e9a5ff5f3af3da67281165974760a37d25c48ad4932d20ad2b1f35ffc5c43f292fd6db222c668f41e189a66466badc858fd06dc998b9eeed5572d1183b20d292067ca482b00d3cfc6ecf3a1aa10a2b5cd073018097cf8c506be34a0320df014dac789af6b3824e0c0008a9fd679043f27ccc826bbd9f5718f44350e7799de967b22bfc88aed9ec64036d7f41c96af17a4b7247ff91f95d8f93fbf203e4a622f9c9d7919b45eb0132469be2f4f4d3472b7d27e335e1bb8f3eb80305f90d56c26434b96edd34a506ad9f5f13589cae496084adf2083fce330a8b36cc78ea22a017d7df2130a3da78ffc2e5a3b5c0e0f68c0cbd64377d64e54096d2b3bbb513963efb6d9ec56aba0f965f25a8eafa3ad3321ec0a80cedef206cfdb1a8777af80c14236962eceb719ba7ab2dbf89145eca29efe25f407feb087abd23e483a833f4a0b66048eb1b9e918eebf389513cbf111029314b182ff1b190e378ba95f109188c9e9a765c73b059182e425ec9e0da7f83b63e0cc89b5a80b118a0e529c295968d750772206c7a6eea897114a6f8d558ac86903f9c52b813467b15e0d0787f65e7490c116a8a210e21963be33f71bf1146725967a7468fba1b991cc9d8e9ea0becc02427e193caa4b72458a5221afbb459c08e9ddc6fb3eb9223008c148c0ee45a02a360bb3533598c3f002112e23fd3503bfefdb8a9120e53a40ef1d8dd855dbe165e9a1f91c8c7d0b09cbf159d7dcf37a39dad1100852fb94370e49187d4eb575a25225c66c5b59b91359752fef1f2871ffc045207f43ef0878cfe18d201e0488083b582f06cab3e786b0f9a835489ffb2b3ecc99338581d0b083187d749266ee2fa15ded9dfe7e03560d719b9df1a2c2bd99761f4b86222d66f533713d4a0e9b34efce39e0500df23c3e4a343c5a3d9df56ff37a82c693598e52bac38835d412337b77954f141bd072dc47300f24d3158c74979bef2128a132f076b2a3b73ef59655488fd030b6257cd7f425a2eb3c677289952063a99a733249e5969e316f8f089bcd1be5d33dab222844808620ec573ab1e1b0bd37cb728da4fc8aadcf3bb4a65376775f52e4fd801ee6f0598c5d5e00d92b091f3f99e31787ce8275c979081717f97bb5dcfb31ad424f202cc052722c9899845896c7f09be6afb45d9059969925db0d5ae7ede1f5b4ca44400c8eb8ce7854ee37406a6bb81744e8c62bf98dfbd00172ae8f9fb75f4b54b3255fd57dfb13bfa760f59a95617f1403e4d6147ccfa1fb86de8f29fdfdf54d2cb5a0d80b205038d49fc771ac6afb617b3f008e30a3130996f8dcfd4f0d27319db4459bd9f0b669cb9dda6998afc1240fb1e9827a8ec0a73d8f16fe02fde39f6371f711c2d84fdbfaaa90574084ee5ab9295ad0303103bc60ddd9be942ebca80349f5f758635c28506b0c65e6c4632079cf8405c46530ba07a98786a47bb5f4b8564ff9d2c01909e85ca54119038480ae91331a4b51985a8db51bf9436e5a39f9c473470825ea839139fb3623f4640f819d7539de696d3c34bd3da08658953ab3317d00d1c1eb97af667e4b7d8321d299cedbd4ab1c064f0d43311e43740504f211e6bf174fb1a00ceda355c82f50cc6c030261aee609f09a6d1e05edb4f081912ce33f297deee474924261f760e73f58b22b0c914c1e6665e5f7c1772e3998cc9c29a794ec3348945a34b3948bcad9b7d7e67556bbc2cc0113e1ee9ba5573b12836c02b9ebfd504f3a6b80d6aece2aea98ff5de8bf81b3e4f0d537d41149c300b8c26d441dd8fa2c692f2d37ebc7fd5e385dfe7654e2c4df80c78ae00983cac0573f8b7b7f6ef65ebbdee5ca6c1ddeaec81bc671056272f24077369a926aae2fd7e0fbd87eb12a79ee3e39ef96866d50e56dcbcca25bcac9ae20f99657bb92dd45f55cd28c3cd8f3dae5acedc7b09c25e551de67a6a2685d681f36a6638c9b7dfd08c3768338e52386e7a13955ba6054a37184f09532bb88187b78ca3b0e77653be674a8cc38b0823cbdb75e3ca42b0f423259420fd1de83b388e8a6a9dcfb5c73776da9a5c97f095365373d74c6f2e39a0406c523bac7f6103d7ddd50e395f8de79d65f6cecd8ab313c3639a24d40560f872004c72e56f8089b816411e9aab5c64196f713f25d7cb4744bffbcea4436df26c8bc3d89aaff911556916bf4e83e9fba21615cc7248f9a575104155282f1275c3e33124c8e4a57bde62df63f726601cc179789eb3f76e8f703f1b185afb9b6df021260f1de26951e31acdde0d8784b1ea7e9311bf8a54b15426edcc0cb1ad74f4c65b7d6cb825da9b02f747ae858c1756b199707ba5b5002b1ef39c45728922b813f8219fc9f47ec1063f7ef27d71c287dd4b05f854c9960199a4bc4fa24196353720722102cd018d0d9c3fd58a37b78178e7b811e33dedb5b8d8a671f88834834382359f48da728d61afd2b04d793a85aa99eff9f4292cdb70edde5ee25adb78e1911b9169f0b3459e35786de7af4e56646ab43b057ffcf47d6715a10a95df9cc93c2819ed86f938e16d6f65972bd4dd1df5f76ec10c87bc138a7bbaee479ec670f550936eb092658be6d8f000f401b0dc7368b56d5b112dd52a2005e27fc43c4d9d190d3c42455cf5f902b2307a515e9bcbae04f0a9c84d8564444157c5cc3874164eba9a847792f66cbe600ddefd4b77efaeabd010088048625ea5d139f816488f9904d039f6d41c323b8be7c44f349c2b67d946c50e3ad1ce0301fcca0d0484ef68f32ece5ff9c7c5e2b72f1bd404482719f8f61a52e067490b19cd084809d5add51b476e17729ef193d387cff0c9af2fddfdd611a96d098aa501e76bbaac6eaf24f2406a2020608afb154b703f0d6c5f4cf9cbc4b358af93f354daee06d32910fc977e7a89f98a143e66d2c05de3edad70822d0b32facf0a2b766513f9537c08bfe3c897da5bb29e2b0de7ae637769b188b8c2caa4b7bd5ddf0f3948364eaed6a238e6afd37c1256b4b51cf1af7eff75d19775768ced0198484559c3b344b242fdb027af250b88b25a2daa8938234ce795fb12199c0f3acb8009b516cf579ef03350a801fa6900d2a3ef7d9c9e444ffdb07b927208ebdc751c022f9cfe44af4dbc73e0a12cf1a8477c61927cf3ede2ed05ce83818400fad5429566b1150ef0c0a4ba3fa5489963a7d4a76ec0568a6639f48865f78d427e1acc0297360624eec0683776eba3634353861fcf83c39e471f6c1deed7cc81b672ea977e5783170bf92c96590d198ce492dccc707f61ad17a522f086812d6af0e5ef8fa58a265a83941d0f8f8267ca6f7426f803e89d0c6ca8bdede683b084f966554d5d56230eafdc1bed99e44db1fa4416dfcfb556fd3ab18efaa6814c93ca70aefb6d0b2b925743a6d75fb73db4b40dee5ea78e6cd46119611f8cf518c7f3084e2c37fd290058853e963b0fabb2661582be4946872c7641bb233c0d86a1a537a097abb9b6043568d4596e568a447041a72b303d723716bc9504176561b27d7d562e6178670bda98c9c25bb60b18534654b1b091c9e29355e479f63a619582a075b73f989b9697b265557a2e09ff3e33c018e016b1bd92401bf5ff371acee01c5cc28990c6ce4499b74436c96a4aea97fe1a445902aeb66288e61c6409cf4676aadfec692d4932e74a1019407565d67c0cc3c7dcfc29a84cc3e695ad1cd859cd7e65e7997946ae7d907834fad3afe165a1745596b31a90f8f864140b905e43c444dded2a49dc394d3e810553a92d8ddd2fc634917074bb3f9f7e66d1435ddf4c8e142e45b2efb3b3b00f4c556de6b0c2fcb02726ab15a2012ac91effb0426342154207cf117e25f3da3506a54b00557cadcd4e66e054a0766adc97c6c661765632de0dbcd6f9d1123a8d10e18f49957236157d6aa513987af53c32e58d189fb440da63aa627f7dbc4b77fd9e4c913cd8ff9997e251cea2ac65d0d9a3e4d7b2934af045fe083c38b473ca2db21def9b99530cf04045d7e658ecbdb9262e5d495d1935ce69f13cf184c61c8f2e19cfa5a3adc4abb39b339fa5659b8449a1be641a20f0d47798f043b1a75836fb8f3f03f2ac77aa0b2f11b6340cff675fca3ed215893132bd957975cc113ebb728534b35ca429e63f6999cdf76d3bd0c913b54ddeb8f158ea91478ff7c8ce609488ebe297c29f129497590c014abc58220ef857d7dc02b9e15477bc152df5171dbd730c12d09b789a3ab24eca02d5be3b59bdba9bcf8884a8d92398dd49f9288b8ea7ab15c753bbfc74bcdca174c94882948e0dfe5e28471102240e9325bdd87c5e46d3d20ff721c0e58986dcc27ea87b5f7eee91299d50f1213a1cfe8822d9eb5a110ef2758f3fa509d8b7e565a0befaae6b4c71fd671be723b50be2246abd2394cabfa7f6d1c7ccaf216b21636c5f203de246823a10176fdc11d4a36132a08d977918ce9aa3e350d3fd114b5adffb4b90d672c938b5ac21a6d0c8418c4d0ae79af75b8c91aa54c74b4f596d6213b2a66206e1a75d4464cab8c82769d055f8b0bef52e6f72f650c9ca4d0cc7d766fb689202691d551aed8c71b97bb51de4e4c60f83f4d082ade41226be1d9de2f86a0ed99af1958334de9e695ea3c1f4bf604cb789be4cd479b3ab58702e84d38b5a244199dee1c515df250680458b5ff43c44a1fe21db80a5f8037b0e1d4cd0fc5c068c05f2394c607624748ff3aef3defcbb90b9ef340e17d5844c0167536676976fa32922ef27a2727bdbb4d15a39fa0015419427e388a2d6a3ec8c5b11f085ae84a27688677c7f76db184ead7330d77f79def6e83ccc1cc807a75c525d48c85709ec90f3abe17031cdae216bb8901fddb43cfcc5989afe543209771587fc0d2c7a599642eaf91937561b07d7de8780bcbd557ecbabf7db305a82f2d469400ff2a116e6d4c3b81918a4db61edb681b8f70cb5295c77be7f70ccea8fd5c1ee289576c15f665cda25007f30d2f51a2dd05be94a902d4297d6c004906faf253b25dec59deaca4d72261b4a69c85c6ddca2e921f01cfe5cd4147d165e8db6e0324e81486d25eff27bea4cc0a6fc6b928c16946a9ff27cdc76ff0b56f378716f826925628a4298c2d4ef9ba756d9c609e5278fb0e01b028fd71d7f60f6d2e374fb896412310845787a5984441958bcf71d8cd9d3d8ddbd5e78546e63c682fb2515290338f6acf444ad73c622d8652c57c26e566da247d1ec38d24f438d717a2b786422c48dc4a710b037682337129fcfef93dec586c7e43a031fd08a913709e08242846823aa6c77ec1c7969d51e156bfca7aba77cbe3b317ca970864e41f56027e832addc20c474377335b5535149411ba8d6d4f3269132374fd97f4d50f30c9044c710bd6411a48d18a70afc67dfbdeeca3132dde0bcc18a72929ba93a467412f72058ce6a4e09a68a78cfcb3acb4141a2e4a964fc8e3c32cd8c50f9ec4def7672927aea350e924e3baadc5568cc7365e8afb94d8832745733aa8cff286ca44d8f655f6038de3864977a09d27e9c120f858d581f27c686864366bb2cf1b721d7ad923078dc3adfbedf6643ca280725d8c95caa082c28a7454626af344ce460ea2087bafa9cfc1ccb2a78c4fbc736c96636af9c749f34652daef0c044aa242b6bd2cdb956bb52628b001778d2493df5e4aefcce94fc16f22942f3f777abb7c01712b23bb2042b431956ff73dd6880b0c7a8a3e7e29b103adade8fb3e013ba6cf46af81b65e1f96a628b06956c2ea2852a466fec3c7a4fddef0d650b840d9c95b78f2687825ba4f372140aac9e80fc918f7c8579958fbd7562b59d1194b246c73963c05dc55670331d84b08d7c27e7eedf1f310f4e517ec002234d4d5cf2a2b4a9245d5a30d4dbaa4ac7d9950213849efcee385d5efdb68870960981600a226e15e974a4b8250c5a652e4542a9cb3a1b750e23fabb58e2e16f15512834464bf6a68ea4a538c3aa2967ffec261cfca222c157edb96f0733af5b8b505bb1ee62c1594802d6a42d62ea671334d2e6e17af4b0024e80f635accc9268b7e7c920f6c960eee762dccdc10ee5f3418e721e0450fe71c375ffcb638dd93f4ad93738c3a98394a790e82d14b0bf56aca995b4c527c854774f42835704360d062d30c65a18897f5121985d78b3a100ced9b3429acefee48f2c12726ac9848dc668f0760bdaa8a5768b8ed6a71024a223c57f7b13286f18a4874b683f5fdad61e17a87086f349a2edd2bc29284faf9b7e66a32b17fbf5ae4a1d48576a50734eb92cb7b48b7f1006bf6f48e7e000d1c9474610b26807d90494bcab25279425be4b92e1988a4fb8952b9db51b468ea6e670d7eaf4970c8b3b12cc3771a102102b166169a46db76006f3a5ba60481f15acec5d8b83f9deb1354990f582b4de5e0fe91c0233dbdf6758ce8d4dc85f8133435935f854285ebc01b56e32b3ae90c4518eaac56c17d44ab0a0efcda9982fcd1228e6add67f93ec9ff3288e9a3eea9b6fd69564c47ca62e5554cb92025c0a54452b0a612a17ffc937932ed08cdef89f49fe83625136c140230aa29e7047ee780296b14cc96126b1c12bb6d927a299f2c295adcce3e1b12f1181dddfd5ed78d7e0ef7475a8200f25d8268a268ca11b7f00f4505d0c71f0cff1be33c45089604dcaa0a83382f5ced46e1d9e001c2decc5aa2e698c777eaab26d1bd34e17139167afb28bd05cd32032e5db03acf19d2365e6a13017aae1a06b3c91734d3fd08f572cdc476ac7fb7ea7ca1477711eec063a663b079afdb9f2eca0f47d88ae3ddb1d6e4052846770c3da85fc3d2e0c526b4e949f9f44c70b3cc21a37102e68323aa230db58e90829b142f10b0f9ccc073792a37c2a0bd35e1f23adfcd6a8c3287d2a12988dda81ef5d1d18d71b18c2295bf827aba51198b00f89dcc1fa33ff4fe786be9574eb7cfc11ef2ba583810571445b8c6fb8abbbd4ab8c9bcace8db83f919c84227dafd1dbed852ffdde4774e964e409072e1c19c6c7bf265e89a563873fc2ac88e4db626818c55366691fe70b585d9c0fdbfe65217c0785e01d6f17a2e46b897826fed6db1e5ffd3ad41df6acb8736c58259542a9731754162cfee6de4f4c75a99170d2b3917c5c63a6fd25ff813532e9572102cfa0fc77dc7e5d282f7c544a364a736c03732e498e13e952c5e83eb41ea98dc259bb49399ee6dd0ba7bb539ac9b8e1cad496e0f6ef59501f8d05e08b63410c15f1614461f4f63533c7321a3913a7ed01e950c4a5339954df6123a5f420b0726535a4468ce527ce9506afa0268a0b81cb5d6c0e2b5cf2dfd3923153683e1cf6bebe00824ae33123b53dddccb22d6dd27f0bd9fd78c5a74623f336fa7c2ad89acedffc56e5d7326cc60f93e8ea15eef94da371c9e60df9feb309f7e5b50a631ecf75dbfc68884e48ab0498a5e445570f3f44c12fac51d50834460b21a2a0a70e5f72f13c4aafaffe1cc0770aa9b49895cd7d325cc60266d2c6151f87a08d0f25657b3f6cadaa726bfd1cd5ab2c711c14a75baa57c3ad78c8403557a4eabc05c0ea877ca07ef99aa775eca57ecf3790c0dba3fde41b8e394010eedd32c518e6f8e4fc79a2c5cb89053b997d981400615e30fcc423b068da6294ac96abfdfc56b4d0c35c9705b881af330ad772b9f533bf2728d3094e95647705d518482a2699bf226f7feb4c155ed981a7ed4ebf4adb9f2f36ddd4c9974861695262285f74a415c471eeccde9d878549116c93dfff86ae48cd6453830ee0abda4eae90e9e1b4fc2fbc76cceea31449bcc6d3a057b2d728f27c222abb7b44c28073a80a6b5186d8e9bdcfab3cf4e2b8d667f93d68028e6721e009c0961e78bf992542dbbe8438ab50ca6a358d4a41a8526619f4e354c61204fd84f592fd7ddf7f507e194a6d11d73d32c5d8294ea25f3b9c0070e1a98b32c33e1a2db77c47d92ab315107464a2feda1295afe23b6f88647c0b60d3142975db406ea61fa672ab75f8a4337c24ed935f5f0ba721bd038c922d05711ed98407b8c3c53289b18969ca9f377a6f53edc9574a0b1851880693e25d4c39b5e0c70c43fdf2a0edfe0842a7edb58a61e191e024cccca4848e311ef549bce513c8a1a2bca04595e2050a10eda8ea4d4ce6d7f765e8f6310189650ef39e5bd21ddebbd27393c6df52c6a36a81e32e12c32065371133fd1827e8f09abe20c67a7f702e8268932e5396763dc2b73a3bde218bc9db2ecc67c1183e21c94af980fcfa4200e277b74d71e61f46d8f810327cbf1dde84f726a64e909d308ca3eaae2aff3d441d4b56fa1536ada55d025beb98e5be97dea03ec6e93ee9da585dd3c073c5a968136ddddc0c9e9210504c6cf0282f0c27b43e8a0063dd2d3e4f803a76a4ddf6b923851d6295dd93141386433507400adb3378a469a1fca40697e85665c4c355c06ff73f0d180563bdf11947ba27bea33924012ddb4c560b65d9c44c1799ca2811abf15457fa65f1a8603fae9e6130cb6f86cdceb479be7d470d9dadd3cde925023875659dbe4d85742cc35a75e0837a00cce8209eacc3e7952311cb3a65780749d1be3f15b30c25d940826903ae29e45193e5defee2449eed9e3b8bbddb34c63dbdb622143082faf2a53253213e07a7687bc33d37d022af8450a9cf2a4c0923e24b16413bb82d6ab9bd83325498f1b1fe8daf2d07b902268e73f0cf56b3e39dd42187b315f19b7ee0fe9a5d84e51b9e58e82c3cdfae21a9b9f856cfefee06e91fd94d50ce1bc385d1e70500016ad4eec109792f712a400abceb73a6d49e5f99caa5b4b2cbabd79a1dd0e228e574666f305bcce950b80e043c6be93d4b6fbc17ee0970bc725da1b79d58e027586741ad49945efe37cf4f40fbcaa7942609a06a1d464ecd258df988c606e7b40513519c3cc6e4e8a21a3dea3982f67ac53f9d47d14d0f8b0bcf161f43b81b2793010ed6986e84ba47ec9d620f0ed5d588d46751472dc36ecb9e9460ff27945e675d137c5438364f6c25e874e2e113615076eeca65f2756dca74edcb6e8d7f8fe097c8c6ab214cec3ba180836e3ceedcaf5d680b2d3cddc3b9eb298a6813c6cc92adb56dec1076ac4fdb6dbca0ee965f0892a23bc4506dbf54a35a3dc3fb746777d0ddd85274e44ef2888ec588cd5bd6053a25bea9fd4dd41ed92da899eb02e69929e72f8df3bcf034b5e2ca2b24b064734d280db2740553156bc2fe40b4987344454e375dc1c35e1549b1b68aeaa75b68c2562fabd845d7878c1da6453f2b1a2ef7d187ee50c9367ef0f592742d9a7c1ddb5a42a89c826a22e7d0b24f1ad9e0103db0be308ebc0f4fc2c7c8e23da6ea3cbecbfae80bc6183221e5bc812f4d86617a12999f7358a7a6c39a4ccd9635cf33e9998dff2b54a38eed410a64356ee257683bab3ede2412369e205f4ce43897d05a688a13f7b2b54b0ee0abd5a791107cb1d5a0e3c0d714a7ce281cf453a1a22a3fa787e2a7cdb4b4d016f1f9ec2a7fe7eaa12ff0dd6907b80b387ea8f73ed5e392d6275aaaefce9a62159aa90f06ae31a7d2ccaed39809142bab7b0612967cf85b40fd9d314f52274e572aa8cad7ed17e5f908ad9a5c492b8d87fa15dc2d156928cd269eb3c3ab225a592203881735af4e293c3139191befdf1f85e2e9ed61271191bdca117f3778355a693f86da28c3b0062996a7f8b75bd215e6b70f3e6e59929bb2e1f2c3f6ce84f8e6993f9dcdea35c521682ad41f19908ec052ab78707b0aa172fe02bfe96a73f1da1e5b8c25d0ff1f12b3efe53f50d7da4bec35f082c5b7c253a3f253d054a7d74419eec5eda7857e7f39209ea4a293b00546d5fb367021751e368f71ac1bc4ffa192e2fb2c6bd9409d450b85e9743843110ff0c4ae1415e9c105a2f225e22fc0604658b25579b3983016af5c0c9521e045b1febd6def9d045a258ed6baae6191a24cb908179c183f2c4cc6659adf8fb2bac7bdbf5d3c6347ac8d898654cec1b0a6bf72b51b9c9a45ca66a550fcc942f620012f04c104d86e5bc053c3bfcb75d92efc8a5da7b3b700ecc04fd723502d015c63ca505bdfb9305bc05702eb099da162d07c2e5d2f9a6917c97fe9e6fd4bcef254250ee081da525316471dc5fc451bd8356eff7b235985c6f1fd4119cd87f0592549a0b7ad67c4de6c60fb4dbd3aeefbc4151934e620bde787437d6ca1af7eafa190e7b43ef8274697206fd6ac78e00f15f35f3baf1dc1bd6f0c9e98966512766390e0f06f538e406c58d1b81186ae77d7eac2b0525869b6bb7aa51ef10d24952a5e77a68b6fdcad76bfbd2631e70099bb654c7c592fa0373244fd52dba03bef5cee2f918cf1a95c88da4e54329e9d18b3e5416593aa5397422b0d242ac2924840dfb4f54e53c0c0aec5db71030735234ffb062734437d5d979d5955853e549be0d3b184c826221084069f1871cbc5760e184492850d4fe962f5c653da991418e8cc0f64c78625b3d20ac08c8e9e1489d26f81513133a9946ef94062435854bc9d6fe4e4de8235ab926e843dc97f0b9052d398754b69ef32619af3c8079645639024233deb4b9aa4532b4911fd43ee3df67a59b601717ff2b9da314f37648502b1fe2eb5051c3eef220c07bed74713e8f451dbb39a7fbd0a0be34e12f2bb781566dd1aebe4dfca84388b1e97cff96fa73c4a38577cbe43632e0a6cfa1f823f1690838c1ebfb59194bd8e07c5ef34e9cd8ff80a21a6efac2489d6942b9cfb46c995bbaeed1c8332715483c93cf998fe9a170cda86602ba839295c2169dfde8219953904bd7c2938bc7a5becc4f262bf8971a2c38d4ca400c81e26001655a00ff6ac9bef7f5e8229f563e1e34599a1550ec7c24394b7409fb37acf141d5b7909f3b923717e5ad4e8ab77cdbe105c6e6150c1a801dc22ce13850eb48400262ee06b47bc30f92dd3b00d63a65d6089e0ec600f6d360d1e36ae718caac49faa550d08778b9cb28ae139e72692abf0b80391320cb50cd13b6763a2455cd3af2f4b3716de0a636e0ccc64ddcde8e498bce4d8f71bb8c9394d9c85ca288e79401a3910feeb4b2d0d63c70e7dabe220db3b41eca85ba42538fea69c7a554ee92492a576d17df94cc98c8082993d4128691e1ef6d93832a03e99b1906f13feafe0b6bb14861f2d88e682edd5b5cc02377300212480321fdcc8e1b30f63f6c6034db994f5c99ad4dcd920b832397c171a4f98049116f4074badc138546d37a23e6e4d18f667f8290999fdb9829959b7f534061bbc97dc308069365c310b0aab7e403a1c00d6d302b6984e7fb35ae8eeda88ca6df5760fb42fe77861fe24c15fd4a828480d4cdfabfa37f7be775fb8126ec07a835409c46fe4bb0120ed1f5703f3b89910d944865be67fafc539a73887014705a43b928bb58c8587d52b4b52c7e5fdeadd93ad406a8eba8c07f2ce278f40da48d50f3f5d8ac2a9ec42b8f2294d037ed35bdae658a93dffc1758d4c59b03a9799fe30b5cbcf8e9dd787f9a524ea3a9fad0e984bef768fe7411e9c532111091267b677f6a60cc779da089d12c056ea3be1a7bcb93d4788a47bec244d9916f6ea8dc480415a6028428886badfced47f2193160492270dbb64e7469f5e669bb38a37af4620ce60b76c431df04ae051c9866413134471d817be92b8cdd97d5b92242cb3d03da3b7c9f1878784382131d88a1ba785542582283c9ab9f741f4a4ec3931dace1e73f4cc49e24b9b12961dbd76ffd7efe8a0e91e7bcbe98201a880ad102b8ebd594578005bb9c645f1b7dbce3631416ce34164753fdd299fba0c2d9052eef77ac74e0c63f09e6bcbf481f315b7674dc0ae23bc68e89c7933219a8e1bd17dd8175f36ec941a18a9f711c214446295b70c8e3f4b40798257c5a990dd6c959ac18816e4cff500a7f70a82f278f7b805577800260c64b8b335c6cf53b28f0a8aaa80305c3a32000e8e240deb00967a84bec1832afaaec1bdb2bb985926a10d28f8f1f92f56ba3142154d5ca7c997e285d0cd25a47fce4c7219ef059cdc96ff55e2af075ea2be400f6ed82e53cae07008a305","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
