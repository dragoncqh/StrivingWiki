<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"808ce9826122354ad86c9b918736204b46a3ae9ad411bf5ffc58c4bae66dd6926ef2d8cdd4555f4df20d0d73aaad23d9df8233f227ee71bbcd9fb8d23f50b0611ba297b581ddf7f79a86ba53a0be6996b6a50948d3e8607457ab7c11daec0cca2f126e8c52e38bb310b7210d3a7d33481b8fbf10f3744ebbc2e0a1f9187c614068438457df6d5adbb4b20189d298eb0f3e10043241aba6b4661c4c945ff67ad4594f28c58afec2093333fcfcfa22a724fd4a7fadd3f8b2633fd65c55c6a6c4e79aa5b99da9448c2ddb6246835620c4e550b3b7e81b3289f20b8ef56342f7b71036e782486c3c0bf5f34273eb9a285853892937105f18c127d58bc9336ce9823d05d9514b7f6d478895a210e1dc5ad7882e6fefca33a9af834ae1abe832453321f124552171b8f0b02975380bd73d04ecf0b001fd27c30df7513ffce6f91edc633e731d6212dfa153da2688a18fd65f5cfa2c2d0624a62117a9d328d994cea0ba6145651dd44f498fe46e441fd6d1edb2dcedfdc14c73b4c4832894e268f8bdf37420782bb9db05bffba9110964265afc7f74d5a98b293830ac436595a16e21c0cd8e899f9fcefddaab6317e0dfa89a01561a991d496f36ba4a37732b0ac98fcbcfcb6ecdb9203548b345c1357bf4d894f30fb8c98c2ba1f9920d0de4daf008d34d0475b1203e4a36471c1866aca1ed11100ef0833d728d0f007776eba2737b02f9a5fd50d8c2ff3d7a71cc87f6e11417b3e615b91bc4f4c031e8f027b794049cc87b4a0ed615d24ee0f53b8ee2aefb4fcb7b4270ff989cc2c7309eb6e966228c31212b646c46c3033a513950287041e7f5d87f563173959393d5d3c05872851c6636dde4485cd2fef57e8d0b42c277cf9b4c13f52a42a6358c26bacd4bef3e703dc3a976bd9bf205512681e8213ae811b1df8b3f113452f7e9a97643ab373ffc56c0042e1e4f2524e08098b2350a3f6d7549486f99924a224346edb7aa7b7c131eb1149a2ac988e34fa02b12df031d2a4e0cfe6b07491c479b65989443491b70483f105c9a815a5a165006cc73867665ec036d8c24666897fa6a8759cbd1233cdace0d107e844e8878bfafb6c817a8f5260dd7cb157d64c314976ef08ce28789e59a72d3142ecf3a064cd278f5bc180fe7ea6dc2ff0bc55d35a864a844391605d6f0b1d49a6acb3c0fdeed4542932ac915ce82dff0f5fc528992e5cbd9681f8a7ceef6bf5913f208f9f49e5cbb52013cd49308408d4e8e1e210d47d38da26de50ec272dab545e641702950fd92ccc34f52db46cf902fc7f3b758f94e91cf0c5626171f2a91cc288a08541d330573a8b42bb67502edd4002488e32ba514bfc3fe4eac9a20a6e0aca0ed72eb60f6264f31b287e7a5d473759ac9e0c45e76636eba099031e1e14bd3010fd880dbc9c9ddec480d9b63dc45a32b3e55ad95982548e9f452a4561902c75dd0693116e5c42c34787c1312cabee216c1410a0f986864e45f71026cbb507c43d59c9e53c04cc5e74ded6021dc2843db25a73b1d0fb854c50f89ee9807114ca5c15f61ad7211e142c9f2475e80552e0ca45508ee84cd5f4ecdd8a969d97e7a4710608ab0c6f3fac60f5d746bc81517647774b8d28c6306053dbae16dc555d9dc0f0cdd7062c8220f230796b5ca00588abd12d17a77ef2fe1650623db1fe8e9a26f02e4d020559835ef77553b74c6c16e8ad566069a0cd4855b04f5d0adf5ca0f0207e9c7bcf9bb9977256879802899b2eb175169a83fcc42030a5ffbc861aa66efaa965dec5893a160189f2a5d0872836d0c169864360982615a4346fdc0736a33d9812c1eb29f2a479ebc7194abe8b1dd4ca38489d35a9f93cecf9e9d288a28079ed7c371dfd2063e5385c0108c59017e958a9cf720ce6fee6f05c75532c9dc8f63a6af417974e9f8fcc947fb9b28f9292a6513b4f7a4a78c197b42ae42ecd163c65c17d3169a3ff9e4da77c5f81aca6626f903d1d828803ae818b775d63e1712d276d8c186ae16bfee46cfb000c50487599ceb51310d925572cc8ac12d2d5d829f11fbdc32a341fe3360525e5a5b3298a26528a60216c4fa6dda279900282fa3eb51a3e0b1d1667ba352e63ecc1b1b8261a4ec535325a6342f18b89638d5d8b5c0da41d103e6076aa5cda2c86f73e519b53fa7d0f61d8107de80766a195086495d1f05ab50279f46201fd3878837868fcbd29179685ce7e347b39902a8b4fb0918b154eb3c2fcff2111e076027a3a532a25f5c516dab581b3c5bf44fd150a13f9d43fe094d7bc7db144e37a879cd6bee990b61d9cb86a8b58fc4757f7b62d114b607cf5c94414b7adc0a9a2ae18a7a04b32ef446d6174ef8107015a47a8f8fe0d7646fab87ae3e0386788f1459c25296223f15c22c0194a88ecdbf2e7a7c14643bafbd9bf3ebf33c6025e70b7e784fc8df1cba157239b71c2692e5c68e12328d5548e8a9ac95a0fda34f7606264cf4b22736ead3c8f4abcd77dd9d09090f61883c5698e7b14ac1da95ca7a2908751e998738ef507846990a70b39245da37626416d9847e5f1a828d56ad35c307c9e68a291bff58aa8b5e9eb634f8ede0ddde295deae0f1c800bf07a06536cf3dfa62c328aa59af06a0df89d541b1febdfc7b97665dc9c7503a211c565ca3d73220e1ba2c8f78120e817fa09a5084606961e6ef143d87b9fad066bfff3faa8cfab8b7f8ed864f8004745cd08995a116fcc88b9d66913fe3f1070bda46fe8b201dd26d9761a2b111adbe4ef9168985dcefea22db6c7b2c9e152ef4ec54d1cfd661b1800c51e0e1815550e2f165be3e18981d1e3d094f6cec2ac2a392fc094ca81f0ec65481a6e10de86101ae259ce74348a45c31a3024de78f9f7e4a0a0631261b7b8cfa48c64a25a09c4e208dea8da87802e5aedb5cccf20769b9f1b67bfdc8ce6fa294e91cfd353110183ec0d00e181f4645f58abea1cb9468dac8dcd2353598f9f4d351669d1dac6a78a7133a55b73872133582b114ed93f7eb1d1a4f7d54d45310465b3b917786c8c55863e9156d6271061daf3568516bbbe86ef3d190171c659f0394f5a635940f1235f511eb7dfa13f9ea8ced8255279b67d39039c16a051791c305999f62d740786901d551e96c319d3c91203788d28b878d9efef53066d4ee2de9e52cdfb845a2dcd7c221970e7371375254a52fa99488d9f96bd82c10ee622820b020f2dc527cf44ff4cc35a9fa981993297d872feb6e7d0380b6a8b69a57814c1a66f101d2f4cf228e5d456b4b052b93dd53c74bb4d97fb4eb106542e307224555aeb17692b5978f70920e7eb5f7b51f1294bbdef67c99fc95a8f9f02d106aef72b0b10772cb36478689d10f6d6a1b1547e499df760a95c923f3f31d9bdfbfcf3410ef638600fbbe163688da1cc032e16770d7359f8505167b4a5a29607d6ea960cc35159c14310f947db9436541b0500707e77f29783fc2095a725c2ef45e99334882d52468bb11d4bb6ad4a424f9c81d7a71d1b5ba19c5af48dcb5c04fcccb941a68c9cbb723217b896862f0cac7ecc917e9f2349a31ad71990ae850cd0afb5f7aba49121b990244e4ad9a3592f6c33db49a454e426683bc02af4aa8d85a6e2afe7ee03811eabad345876fb04e14337b31dbf5253f7357d42317f4c101c09a87a9b71d508c9c4fd81f582ccc4d0913c310a58af5cd6b0cded73a992b30d06c40c4ac576f175a9ab089895cd42c7f68bdc4e4a9b56aac24f44d27b7e7d4c0c9cb581cb438c88ab68fdeb7d2ac52fe39c662e8326aaa74f20fecb4d5c303b490d63b2cfa4115b3d4b43578bc8e0b5850d8a480088552bb6370e046b87e0c2cbc4a1e78bfa39b12ca70cb69074040c169f23fbd47b49fbf3afd106c63397df3079515303dcbad083757452d40de1f6bfe51c147a6d9612fabef9eabdb494b761dd677ea453f68706f4bd110f88f337eef061e987ad6adce5f1376521a8965e5626c19c3087131d99405c8c4a6b772c79a5a57a755572ced37970a12a6ee139a4c9892995ff31f83f05ecf90b94460f93d9836f1ff520f777fa867163a441955f7cdac0c8d5c662203ecbd4096bb882242e96599e576e5815237818bcd1c88af686f5e3395d827db5c3f81ac5c172c83b92df82d9860d9c4a6986fd8bc49903461ef61054a4fa091c690b0ab18581719bd008299f3f82d6a9679b969c73e62d752442b09d5975ecf2b8be7e0c054d1739ad12024851c1a811656f82d565fc7c50e40c9ae44e1fbd43b603275284da1d578ae13b6e7a45a7d39a858ac524a8a4101382672615958febe9f244d0c49b2c53aea4f106ba369785ea2d548847103af05d60c187b174ce680c28aac44e8f593e2a40da32ede0e2ce3c5dc0b803784922cc9faa130620a18c95e7c451b9b0895c5de568c3793590176e43c3f3bc9f03b316bb58e46a3477814abd622f2b50cf8a5bfa6a5c0de87e37adf3b7af2fb373784960782169f94e8ab7aede7a3ce620d928287a884d44c388bb04c4d570ab58cd8d9ca8de1e87d9b1cf51d2b14aa162e6bcb398c966bff7706d629662baf7ff55a0b337189815abdd74abbafb07010c3f71727eb61ce84834b6db588b337ee850e899f81d986770d89108d653b0a982304f66900843464ea4e459b2d68bfd08495665ae027fd00677edddf197d526180c96a0b6b4c803d11033188228bb81a62c0a16ee2b466ec0d5dc624755b90684f19de02357dc5c1f53630a0cca2cba790614d2b0db257c99bb9a7314691f5a2e5c219f58fd8fabe4d8308b7deaf4e96f6930744ce92cec485bb21c344be8fffb8e9d14c33678893877f488978a709d67db9a3b90f96b423773bee26c3e0231721cb328bbc54a4759a53270c7fe461946188a6443207a8476108b71983c0ee43f3ee8882285efe8e56ef86f2aead3bbc6809ca6b856773776efda9bd1a8ad7bc5c8d3f304298f40b122d6686f41a868ceff5d6fa93969d4372d547b489d4ec4ba0c20b84c6398185d0b985abdff6e97fa6cab8e771ae2a10b12ab2dcf9daaba809ea5ef4baf8c6f0ca37706b4804ca0e4c8a6968a8e0008d8b738cc424406115d8aad859896220e1bc5c51d42b7e857c409cbfd9dd707ddf3347364700b2a16c385ac762b45c97aef5cc4c888afbbf2b3aac936cdbb9b8ce86771c8a26a61b02ba7ccacffb8ef4d6b80a132addec7271cba85b73e31f6b2d987e7f61fec901ed32f2513779ee7a0e1088924a2098b9a7785ddf27cc1e0ef91a1e50cec12c81c690b40b1bc5a7b421931eace5a03b2fabcc559aa19ea43c1b9f01675c3e3fa8e9ba490e22014176f18dd843bdacb249837569f1a023d4109e64a15c035cad235105733839bd94d0b13b4cf30e6c27ed26767a4d214816fc0ed1e011c3c05688a6d82483e6a2d893b36724eccd4cb15b6f2f768b835a2a9412584d7fde0919d5cac40460c7ed9268071fd2ae8284fee8acf8c1a3a8d52db843db2d9d8a081fe389e41c70ecb632a68ddc7abb4c8bda051957a6496f59bdd555bcd43ee3d7dcdc0a3a58c5cf7d5590b104a82973c577ddf9ee17090722ae1f71f7247811dfb78748a37c596690a129f78c6c8c76b7d1ab44091c20a9188416ddde41eb1bdba75d0bccfce9a385e1cfc4f0ded987df611f30a99c1b4a9b694297884a72f2d61d5797c423248aed24884fa9cbb8edf9511902f80912dbd5cbcbd7972b10dd81b3c28f98b9961f2c7bf482b6a39db3746f4748e3fbc064efa2a32e933bce260317ee3a58b13ebd429efbd72b470048b05c2a430041505e374d9c4e91f0bc3a89a6ed726abc287c658b062d5a80728abb1c67c258cff5366638f8a21e32de30fdfb3db2be96675d38f6bcff287a69f28a6c3ad5df0c433e1d93ae4df778369199627b48ade874d7310e8134fd885b5481ec45164290eb98148230a131d337b0b172d411eb24dd925b0b7c77e273f6462d8e1e20d48efd77ec347d3ada4d7544d755ac087ea08d175e453ac746269371a7976090dae87e763f2c75478b65dba38386712ed46f45a7ea1f1300e8e09875678cda3535616f13c1a1452bdb5bc446b9a6205ab1e06c308f3fbe361d99c94ee1ecf87030bd0a2bfc81785a780f6ae584c0ad51cafcf241c45f91a01c31b38d2b8c041cad8537c51bcab7dea0bc563131a3b97bfba048704fe282ac33747b388e3803897526f4207f8b70defc4d9dcc63acd187fd4b5d0be8c8b15430b37c3cb169bffef3298343d1d848eec31c5e47bf25594ba766605942ae3ba23ce66f6c4f44d52650db23efecf486251a00fd7670ac757155021d9544014df5973ef5f5537fe68f465f8a591e61be82f793d66cbd912370cc0206ebc1bbbea0274bcc586749d22465bcf8238e3d056231f9a44d62ac70b72d4c18dc074fcc7032d655672dc2f46bb467bc82d8bed094a6b359e406c55e06dfb2c8e50333d660c82b5bad16c4cee413acda216290fcdf5289f4636c4889493bdb0b531edf687ec989c8d378d0de7d96be40e4d06fa75da045bec601804dcc5f78a462bca567b7c52f5dcdaed21dcd8ff4a1b206a59c1d35be7538ab71ae0263ee2b1eb1b95aec9df100109908f2a7599d9e087d849fb1954de038e0828e94f118d1709b269b216cd5a1cebf77ce2a935c2db7c86c98c11c581625378f9426b00ee8e4e00de162c5125f04821287663faa7cf44283202107e023942cb74228e5ff57ce4dfef62379da08caecd5a011893fdb8d62acb143c1243c5d107365ce52aacbbc333db217ed3f9247874a4f609fe44d2a739991179648dd543892f4aedde31b4d0eb78583eb6abed772f479668397ec03eb254f112d8f571f313da6fe6f98eef2c1a421d259bbabb299d7d90f3e62c46c4c31b1162c02131e40f6cb1d0fe30964267534e64287a3cedf93f311e5627354a2748c1920ed49c5bbbaaa0852c2dc0e2b551ce265ffe987fa7bcb4cc6ff38078a67694ccd536b24ce9f7fb8bb6da0032ef3bac6f92b35966de2d850d67cc0f2eaada5c17134712da2a04c4af4dee355db74469d2511b39f7b8b9c8c681dc6ef77455841fdf2ae5bea638a5e00ce7b1c2a2dabe994599ac356989a6638c9c0b633039a68576d4e8ec47e5b74c7804327dc60926283f121d38dd77178e61755f70798c075e40371f3fb9928a732d4791b9ea87033e54a7c8278d76c8eeb41ac599f7b5761ba791adc22496a1dc4edaec2b667c648b5bec4c8d783f766573f5f4e125070ca4773a4634f30c60ec61a2fda2e38b2346e76cc2a184be6c5c17692dd5489b461627cf2a810d876e399caf1c238b373420685e26c7a25f172bbcdfc3efade0f5b432c007de22037e3b6eb77448591043fc74b1dd123a3d3975d55461175b00dcc7a6ef3bae557bfdf69a8083b60da4105043e0bdc780063937d4d1faba618a919bdfff4495d67b0758979dc637558731c2a3555738d624c8bbfb06cd6428ae189c38dec7e7398c728e3ab851b8121d2b77342f771d75d736f5e723779bc6d8c1c21367f0ab4180824ed7240fe542ff5bbd703f4eb68a5e27f02a0e7472e3e2dbe3498d81fc83a8e6fb518da18b8f236aebceeddd07c5ede9a9df590aff601aeddcc25c99f7f34a2853233641279b558163eb5e75dae2867b584fc3fab7e4b4fc0f71c92153540f646bce88783850b574cebdc70c6c6fdeb8b64844f45395507d3859ec2bbcc0799c345f707ef7adab344d0a2a3961236ccf2155f535ce59df07c6f584c37fc9465223d4f122b30b6c8af70acd57b9ea1133ef739d2e10db591284a2ae69f4b2c64243ea6ddf48c1ee36d04936ea426941f698ed5a180eb469701a19a9db6bbb83db4b0c43a93215946c78ca73033ae0c01375c28a976cbc507f853c9e57dd0529043ed29636379c4c46cf6e76244d7e9b286f83c75a69082b865c421e98721a2e5a11a85ca9fd5a95cd3e6f5ffb3403617741651c1f4fd7aacabc2cce57319914e39c219db0fe4fde4ea9d19ae03190e92004aaa34f29a5d25ac7d8b09651a22da4552c322d2b026afc63852e84dadc70c4516dd2a789aac9298d6f02774a3f3ed27980d1e54125810b5f7f7526219b11668bca6e054e9cdceccbedefba2697960b77f5fc19cb647a1a1097788ceda8a9108724413200b3eabaf6f7b9a33a3b8a52520ba83b3bf078e15de3218e334f89909069b6ce64209bdf673c239ef0eba6a7dfe5db482a54de47de206908170b4ef9a6dafa928d9e8dc720b8229fb96d21c53f78d4781f55010576a3a533f6d4fffaca612de6ca5a41384ad256997c6292ee7f0c54a55b4c159368912eb180ca05e76938a381ea3d37c9c375a3eee17d8f98c6acbe0ada6e1b78c936128974434a612be4604dc56315592a2826e63b2b018583b0c36cab17904fede25016671ee88f48ffe9df6bcbd5fbe8f488ac25c7fbca59cecb99f8e1816259236cfb8ef044e2d1806297b554bb626b002347b514d4583c86e9592e317a568626648fb175fded164f91cdf3a8cd4ff6f443058e5b78c5b16a6a93a96e2e917543e5a40761eda8b5b67f15481df459766e3e1a870029f20064de9a956531fea77dc2576002abbb2b73c68c295e68d6e6d29b55684e819a09c84e0ee4ad543380bb268c07f1f3e6fbdf9bdabc78f3cd1b79c1126b5304e233662b45d32c94aa3a66af57a19455ab3b58b0417c0a8bafb22947f8daf73c0afb73e73a7625bfa4107444e781ce13a83ff5327502fb062d9f4979beadca8975514eae8b24914511a0cf1e2ea40fcafc7e884cef60629d2c7ce46f5c0c8f96caada90f1ff75dd2c0751e0ae235d7e4b632df7e1295ed72cb0aa12dad950835754d313712ada8f99b728b7bd2ac80682f31c79ba4d550f90adfb1a441aaff8baac7cf522ee5d29d72686b9ed034e784ab10bd05d5a3691b40e702d7dae371409514bfa629d5a804d800623a02dd231fd70fc2fa7ed7e155a348b4e3cbdbb063b456732c65fa7036b666d714d47c1442c08f5146290d0f05ca13e110f5ebb7fb0e1aab12a796cf81117c5f46a80b556d60a32896a0f0109397d6a885c68a5bfcf9933bc240ed209f481570a7ecead0e988abeca97b822fb64567326373ff1a12c964bbe4e40ce58c9d3d965840e459af9afff4511b6195bcbabf1d81e190d13397ceeb73d46eca68555e397db693dd6380de7d36cfc63878d2dbbf7b787c56fa26edb8a7e7cf42499f50b8fd6701cf4e4940bd6f03c437c22e6653f9de4538a66635a8a977e6d8054a6a43e77c128343e922c0a6a6de8e253cec8a4e04c6d9d6341fbd3aa58e640dc1bc3f21d258cb8bbaeaab971151205cbeaa1e4cb510b1a72d865da5343ba4ba3b70289e27e7b8faa8a02434ced24677a794d4b00f771549b025b95e25050e931f0b48ae1bf67bd7ea40688f9a4be9a6337d7d0ebbcf26cac64f48d5b800d06d9ff51de55986acc07259c9c3710ee553b817d315cdd0023d26022476d8e6a6e1ee57434d99937f26b78da5fed8df128b15772aa43ec2d76d9c01b897aefd2ce3ae4b107ad24483e9e33602434039526b7795164a37da97344dcc99b939ade1ae262e44a4fc6dac97fe07e1b3e2207cc9b78602280271064562dbd6fa6ea136d3ead864e8e18be7975c0e7c62ae15715cffc2c335227c8547e8ea5bc90c6811119d9d89270cc3a42b3240ea968e786457f97aea801ff17c9cb107eaa2ff0a4b07ea0ed16a8c50088e77ce302970b6eee2a2b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
