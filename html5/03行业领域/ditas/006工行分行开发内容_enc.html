<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bebbe3a36deda34da2ff130ecdea743b4c78dfc71e73dce281a64e58e3f07ff676577c03dccffd43e2f72fccee21e65cb95716eae287cc68d7367c13077e426bb6f1ceb2c163bd5357f46ca5fce48c9c7bed7f51babfa6304932c7ccadba7c5543cf18c10800b4941b5010c4fc566cef697a0baa5957d783722d8371a53470d5dc9ca53d2b2399cb314bd34ec3682c171373745082760c0b67ed558a3488e583f7a8027032b9af83e7afcd463abafed670cc80c575f1c771d2cd0e91b643e58a4d5cd27fa6e31e9cdf7d5029d3561d57f7a4ba20d9c1913054fe0326a6ee4af47ec31190f5846beb01f77a6e253817866faf816866f1c613b18336246e96fe00513b9e04546629039da38e4d508d8b1a2f71be62aea51a3875540abfca943c34d66f5ba9a644bf7ca91726d3c64f16bb907eca3480eacbf9236d281c1d04e0d78c599a9f82741165802b77077d5faa9586ee9fd70ccf9126f60b68dcd3408bfc81f9de2fcc70e1a8256bc9bc090689bec2a0ffad1d70ed8ece96cd0ff368a0a58aa873e56205e4adb80df5161f8a9b09e23c4be20148bd47b0873d1827fcab0af62b257d3c8e0681d4103e94b3f1ca48d659f91bd31dfd72f4550347e008eb84186d74f8c937a4fb14a816c51ef0cf0ed1e33259d1745104b1313fedc21b7f2b75c7869349b838fba06082bd38fcb281bc6343068d622521cce52138ac804a93561f0a841305d9e7f93952c3c90903ffa9666e0825dbb81cfa2a9b7497fd308dd951c34b56f28fa3c6357e8e9b36850c4b7748d8e810e754df453a6fa1574c5846a767c517735f7dd985ac1e2cd45f0e67852482b42ba1517a07b161485c84be0b42fd2b837170cfcdaf513b3b8317bd32c32ce06f3aeee6a418b47f66b3a5fe0a51daba291c1e7f38833dd9a84fbeca04e8ce4eb5282117197312cc2914a2dd933b9db3cc34344677f05a9ab9b0c074bd63b7081c6bea2e8da08942ffb9f823e75f1615ecac5f4b9b4de64f36cb31498212c53aaa327b84b4976e2d2a34938761ab56fdce93598488965fe4041a58b05e5294fbc7ec90b5ca4d5efa9539ba4151f35d501818469875193e34caac3ccbeaeaf4a5afef9af0e3fecdfe68a7f9b0853b0b4825de57fcd79953dca70d10f28981efe9ad68fa49406fd4cd26709f3013a88407516d5830a8f8c041cb0ab55e0290fb117ca6346bf2ac260d545dfa9cebac7caf114b6dbcf35e5f3178c6f942dfc05cd23a851cbc87b9662d3342f9b3122d1b4961a3e9c9723056d7a309ddaeee5033ba1dfc46f8b45914d24d5fe4546675d282ab95d27d1133fb91ba66e857ece8fdd0a5916f6d94a975c1ce7dd7737e55b6800224f65d2beb8df16b292a06fa993cb5f924f82c61cceb3959cb83df3cfa76bb913fbca374347c9776aa80eebd3f314e570fb9dd4695ebbbbb27629f9e0aa5795a1dd50714233388537ffe373e930c04c255a164142161fff0c45eb6373f24a5279834c1f87cce0dc68383cc1360d4922b3555eb919f1e6c3ddbeaad5f2b53128ad8cb3488ad0a0ea42624279c5f2f7ec837c19cb6f3d8f2c66c6d3bb5b5c21f652d06bc327a997cf4174b00e31a603d58b07e0e38f513f1279c4b3a99b83ddce5518b8ece0a1a81f337392b79873ae96ac5542272e96bdee957093592c84c7f596fd07e3e70d7fbc3d2b64084279372a3aa2fbe8f751875cf48208019ffcbe1af244ca6c1abeba5e2596b58227d33422d2d122e2f8d76eab6fb9c2aabb07a08354b9b21de68934b7726ff39b661fe9ee9ce1c85f447575571799eea2bcf694db6f887e01b4877b8c1e72f9ce61b7c0a35634c2a8e2721631efadf9ebc717459b8a3d128a92ac67041ce3a38dd91dbfa7514e25b55be19b2808b79ebdcd0c9706f011dbae3045c056076524aeaa526a276f1e048fb043cf0ece1160ac07f89934deec357c7bd90e342c7568f6965589a41f55e442a7492432fb4a1c6180c12868a1361d27f5dc88e600ec0d473c4a40374e71c3e0ef6e03c50534c914a8d971e8d10c60ce0dfa8d1e1ee5c4db30138268e8822a131e1e237f05296427a846155bbded4fe3bbb61e45fd2a12fdda82ca70f0c70a899e52d6cebcadee05d12a81f94c4d6729c4ff626b127409f187d11e9c54fefbd37bc456ffd192c63060bfc4fec2a75983e797541da23dc1567dbf1a4cf3c700017958f6c88b0e8efd00ef136b6d3659c36dfbe8592d780a8768cd8d2160a0cc997f84c3eb26c9d5c0016d081a1c4a90ce557b06a4d649a43ab9f617d69f9667f165ec3a9083835d38810bd1bf7b27b01f0c2b8be3dd1b7ddfee94f77f4c06c2c5b443424fef4276eeddaa8fa74b00197686762169a6ec739990fe7ac304cceea116803164159e45be663a8fcb99d21499dfaa0641d7799f1c167939285f60e96aa921e4b87f132456eacfd742534b11afe2495392698437db755a8685d6f2801024c6cfe56f37d8fe52054a8c2dce72436c1553db8422ce4c6ca085903b8495a39855efa4bbd84e4522db932090aa6760d0f3a9e16f345f53c966cda098ada11491793f4d64a8360db5f63ef1fb229cb8ac5e115237dd158612db79aa90274682cc70e2d2c2ff0d7e1e28dd9d182f65742af11ec1ced358091577a5de059adf94a89a024601b417af66538817e25d2e23908961d04661156aedd7adad69983a2943024dfb82240eb8dde360c431afdbdb7e71fc9c89bd0008ae4c92622dfdc52412e5738d6475205219f3a1f329ca7a3054c8ce72026cee3775865ee808b150b648f23ef40c577dbf7ad070640798f77068446a792b83d2e0743e4d811544f9b8ae4cb35f5773a8d7374aa8b165240b4e8136cdb01036a56412f00a2535431ddfce78258fb40e3a19b29d641dc9c66d8360381f3987e217e8d941ace7891af1d348a96c97d1579b11fefe0bf17a68b73f4f16c6a7cc0a5262f6d0d06d7e9442182d76b3d333959acec1091a09d1ed1048e99c25bd3d566c347a2c3c73a57342c9f5c5aef7176c711e17cd516776b8d334748f3ad64bbeee484241ed81c43846598a62c65f6d75fd6a12cb38f253e7e10d964db9a72ca842e323b107a2c87fe846766005847ed234ae4b95f8fa3509f00b9e7670e6fae49ce8b3b36830d1b4b04d4a355f44f318e033201492b50b864056fe804c9307cc9c05037e18b914481797b658812a8db903f9fd22e543c3c851765c1b9f69ef5de9a29c352c47b043f888b178708e475f78bb2b2999e7ad654b7f2787ea139ca1b87f41198181fb9fb12071802e7b17a64ff69605bf3652ec9eb62ed0575fb776127a0ec7891542d531bc32e14487db122a58fcf04f8bfd234c21f15c8a9d22bf40464b4ad55b7d92f72871e9a342b58198ce8a3f15f6628d5bce10d09e779f7eac75e2e84c80f8a770a5fb7c0ee8ff8cecae3b1cb09978d6e8cac4a2a312195b111af6d2d3c720109856003fcf8023b74d8b442d17322f6a2d832ead31d48bdf66c7ba3bbab74664873b5beb4abc55499f473d3790873935501ac1301b36adf07dd36454028eed7b0dfaaa695209261774ac6467a33539c048d333e82d325a6007e700daeb276e6f2debce1106edc584ba980fdb6b96fa2a73f6fb82cd737148fe7d01bfd971a4f362ae195bff5450d57998f3d1d45bdd6ce598126cd2c42c69b07e69f95265c420d7a041d9b54744733e589c60ca1f74a4b27edb3e2044bffb75bb1507a2a74ae8972185de29624f55452450b83b1c295fcfa0e25aa6f9f12da806bda33778ad8279055e124835e856abe8b2f15343d698e8aef30b840fa1cbc004bd0473a3717e1967fb934196ff3222772690293fcecb71442bc60c6a0756f895c77f6e8791a0698d8ae27ad2ba12d9c284437947aa550fb7d597382eb57a887d16452d1d1b98828dd83ccdcd7fd1fc2c6d1a571de98cc47e0b0ac472c3c495e2efa8c402d9a28e0b5c727fa7be9df1e79cbb673acffecd427d8318d75984a9c8c4d3983a479161d35cededde6415ceff6606ada9fa4034fd380e42411e129a7ca2c545dc0f39c5ba01b1179945234f47502d6b1871a27ac276b7148290a64736ad2fab37616ced3c130afbc57c9793c1bcaac9bead6be643c290376e611e7153ec12520c1d59b4187afd560f882cf91b1d2ef33d2b8e867c38f76704d35f33ba92f8e4decb5f39e197e3a3a0913eed917fc9132a96e9817bce7562b7560a40f823bdb7cec3a7d70526e8534225da7a9004302ece08102c572e8712dd3a3344a70c55b7079204e29a11e81da9829671201ee531c1c155f8dfa850acdf74cdd186f4f18a74be8921e6e2e02ea46a219ffcd4dd28e92a1bceec667be0f4bb30ee6069d3a9d8a16deea71b2d5fc8d01f8e631ecfb0fde21867e9a5257ea6003b04a3557a92509a8cf0b80e3d2d6717c159260eb69b4af6a8c62016f2d47e1c44327b5bfdeca9127a189cd5dff3b9c7f128f4b180ee3a983a03a57d76f700ff544d80b2bdab7a0761d08dbd19fb42fd95246d2d01a051f0795ef7e137cbd3753c82ce3a19c4b6974e4f64ea84d9dc6d0c4b285c35af7c932204871224f1a8f5e60a3a43f569a6f917150589fd368f03c03805b46f87d350067d1180afeb91e0ed455cbe0218b4f3488fd197061fc4d634b2992e9f2f6afa4a30b726edb75b1c72451ce59bd6413d3dc143d1dfc13b93899dd19e80cde345979b93a0ac7a45c2061e52dfe018225652f9ff0bcb32be74f5140ade96b83b09c8b543b318e03c980bb54909b751b3cdd3fc9ab257fb979ec52d934c91af54e40a41e429b9b1420304649665cbd0eeee731203de8323dfd23840e63991c907bd8ea83a4e2d90dbe4468c7c1c1d94c679b7ced642707b8721249cea16aefb0c72aef3a0de2fd0abd3a4983b9492b5b077d95be795e9373faf3e890a8e25cabe0d91dc5b50adf0c94d17a5c6b2bf06b7aea860c87f3c834dbd24d24b494feb78ab61d3ba9e8f5be1558d7be02a1e8e30015f5b3ce75b103eacb940e7aef30df8206167b7ba68fab2e299e11ef7323eef0a15e515c63acd50aa5b6ba9542bd58fc2f2fac81bdb795addb57e12f9d9feadeaaf9d49b4ffd61d05ac22c3fc1d6aa89de8f9ec562fc36b306eca3da4d9b5061c71c9b6ebc3db5654ba982c93a2c86a25dea0529ef584d465e93df7d4d049fbbef74bf9572a640eca57f7fa6836792f50c261d7394ab7941944a64a8f13681927aa1809029cc6db697e2a77b07d429db8591a852c8aabf12963ed5369e4f0a62645f1cc8bb2955df2d7fd466382a011f35ad12d23b5280e142bd5963d72f7a48f2966088682e034f8223fc35fa4e768d0898fb9585ec4d7ea15fff381ff9babd1900fd5d9c46362e8d740dbd011fd96009ece6ffe121549ed4e970135f82c17e634674292b806684965c047533f236729166130b0c61e62618465d147281d5cb578bd9ddd3b210275090a2247510941f8c0476d6d9f101487719ec1abdb12200db19656d7e888a12a8c2be37a913b3a5bd6544c82c5ac13e4785f0fa26c258ade212f5db6ce14e986bf6bf1c8bc926467557c9bbdde982edda7731ae36d9cdc6594292fd95bd27309f814b7b488a78f708e2887d0088c1f1126d65353d12a18777810c57d712aa22b8a36b84c2e772a45818b0f76dbbbad8ae5dbf67bdb3902097695f3ad70b4aa33ff6192df94458e87b45fa86bf7783d1d769d823c3a25d469ab8c712f92d00a1986d75edfdd26db41122bcf8b5ab326548879a8caf77dda32b48e6476f5d476cef73c81c2e40596b971ab8015a950ecd047b8b9478e5e29374bdb3a9a77ee8690cca7a3059f9a9af22df550afb9fce818be51c3e02d9ac6eb4e0ac0bd2aa4253a8f292c9c4671064c55b3cc42bbf784efeefadb38ce1f1a559aa1a898921dfe5970a1047eb4fe08a3689a8850c82cbe4bbcc53f1e719f2754674e8ec37c5d4f0eb40095d6bb5614a7fc730ecb28874c80a2309b7cec6b41f79d7ed99433b7472e4794ffb467719e471f8cd1d082db84fe9a11439a6e2474117de1dce478cecd9f021edcc68c8c0515bc44445c2c3877ba4984f4a52995b8e9e3252eed8d7e85911acc16a1d869af7bf316db314d7e0763f7c881a807dda37745318d74aeb5647a23ddfbfb909aff62c56c11354c11e4f3e914c33dfc9a697b6c4a958fc5d05974a6444fdf088f718518367e0193f3045fa353d9f9f972068cb51bf934f62ea4ab312680de7165ee89f79e6fb400e68b6118624b613adf1af8dd6cd3dc0ee5a29fa423d9f279e8a11c147e10590c07b31ae56a49d6125097e8705ade95c07cee67dc45ca550e3fc3c7ed6711fb53c56d6694d29e649436cce2af3e9b4d396d180701694a5f36530828fefda50e283cebb32d894900f9be837b7ff7df7dedf8bf1e27b9ecd579fb028b563e464351e68f2b87a9c4dd5ae512713c14ca33b2ec93a8c874b2e7cc6c36715c118cef538dee24033fb90170f3531476c2e97638a899511c7ac84db3401ea3c6d0e7dbe91b91a0112e4bb93872c8b270d668b568cad327171144cd8c01f4abf8bfdfb4e2c6928532e8657faaa044413aa98319bc0c76be38907","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
